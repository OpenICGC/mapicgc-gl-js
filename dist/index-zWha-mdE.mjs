var l4 = Object.defineProperty;
var c4 = (r, e, t) => e in r ? l4(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var H = (r, e, t) => c4(r, typeof e != "symbol" ? e + "" : e, t);
function e2(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var a_ = { exports: {} }, u4 = a_.exports, pA;
function h4() {
  return pA || (pA = 1, function(r, e) {
    (function(t, n) {
      r.exports = n();
    })(u4, function() {
      var t = {}, n = {};
      function i(l, o, d) {
        if (n[l] = d, l === "index") {
          var m = "var sharedModule = {}; (" + n.shared + ")(sharedModule); (" + n.worker + ")(sharedModule);", b = {};
          return n.shared(b), n.index(t, b), typeof window < "u" && t.setWorkerUrl(window.URL.createObjectURL(new Blob([m], { type: "text/javascript" }))), t;
        }
      }
      i("shared", ["exports"], function(l) {
        function o(f, c, u, p) {
          return new (u || (u = Promise))(function(_, x) {
            function T(N) {
              try {
                B(p.next(N));
              } catch (z) {
                x(z);
              }
            }
            function I(N) {
              try {
                B(p.throw(N));
              } catch (z) {
                x(z);
              }
            }
            function B(N) {
              var z;
              N.done ? _(N.value) : (z = N.value, z instanceof u ? z : new u(function($) {
                $(z);
              })).then(T, I);
            }
            B((p = p.apply(f, c || [])).next());
          });
        }
        function d(f) {
          return f && f.__esModule && Object.prototype.hasOwnProperty.call(f, "default") ? f.default : f;
        }
        var m, b;
        function A() {
          if (b) return m;
          function f(c, u) {
            this.x = c, this.y = u;
          }
          return b = 1, m = f, f.prototype = { clone: function() {
            return new f(this.x, this.y);
          }, add: function(c) {
            return this.clone()._add(c);
          }, sub: function(c) {
            return this.clone()._sub(c);
          }, multByPoint: function(c) {
            return this.clone()._multByPoint(c);
          }, divByPoint: function(c) {
            return this.clone()._divByPoint(c);
          }, mult: function(c) {
            return this.clone()._mult(c);
          }, div: function(c) {
            return this.clone()._div(c);
          }, rotate: function(c) {
            return this.clone()._rotate(c);
          }, rotateAround: function(c, u) {
            return this.clone()._rotateAround(c, u);
          }, matMult: function(c) {
            return this.clone()._matMult(c);
          }, unit: function() {
            return this.clone()._unit();
          }, perp: function() {
            return this.clone()._perp();
          }, round: function() {
            return this.clone()._round();
          }, mag: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          }, equals: function(c) {
            return this.x === c.x && this.y === c.y;
          }, dist: function(c) {
            return Math.sqrt(this.distSqr(c));
          }, distSqr: function(c) {
            var u = c.x - this.x, p = c.y - this.y;
            return u * u + p * p;
          }, angle: function() {
            return Math.atan2(this.y, this.x);
          }, angleTo: function(c) {
            return Math.atan2(this.y - c.y, this.x - c.x);
          }, angleWith: function(c) {
            return this.angleWithSep(c.x, c.y);
          }, angleWithSep: function(c, u) {
            return Math.atan2(this.x * u - this.y * c, this.x * c + this.y * u);
          }, _matMult: function(c) {
            var u = c[2] * this.x + c[3] * this.y;
            return this.x = c[0] * this.x + c[1] * this.y, this.y = u, this;
          }, _add: function(c) {
            return this.x += c.x, this.y += c.y, this;
          }, _sub: function(c) {
            return this.x -= c.x, this.y -= c.y, this;
          }, _mult: function(c) {
            return this.x *= c, this.y *= c, this;
          }, _div: function(c) {
            return this.x /= c, this.y /= c, this;
          }, _multByPoint: function(c) {
            return this.x *= c.x, this.y *= c.y, this;
          }, _divByPoint: function(c) {
            return this.x /= c.x, this.y /= c.y, this;
          }, _unit: function() {
            return this._div(this.mag()), this;
          }, _perp: function() {
            var c = this.y;
            return this.y = this.x, this.x = -c, this;
          }, _rotate: function(c) {
            var u = Math.cos(c), p = Math.sin(c), _ = p * this.x + u * this.y;
            return this.x = u * this.x - p * this.y, this.y = _, this;
          }, _rotateAround: function(c, u) {
            var p = Math.cos(c), _ = Math.sin(c), x = u.y + _ * (this.x - u.x) + p * (this.y - u.y);
            return this.x = u.x + p * (this.x - u.x) - _ * (this.y - u.y), this.y = x, this;
          }, _round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
          } }, f.convert = function(c) {
            return c instanceof f ? c : Array.isArray(c) ? new f(c[0], c[1]) : c;
          }, m;
        }
        typeof SuppressedError == "function" && SuppressedError;
        var M, E, k = d(A()), U = function() {
          if (E) return M;
          function f(c, u, p, _) {
            this.cx = 3 * c, this.bx = 3 * (p - c) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * u, this.by = 3 * (_ - u) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = c, this.p1y = u, this.p2x = p, this.p2y = _;
          }
          return E = 1, M = f, f.prototype = { sampleCurveX: function(c) {
            return ((this.ax * c + this.bx) * c + this.cx) * c;
          }, sampleCurveY: function(c) {
            return ((this.ay * c + this.by) * c + this.cy) * c;
          }, sampleCurveDerivativeX: function(c) {
            return (3 * this.ax * c + 2 * this.bx) * c + this.cx;
          }, solveCurveX: function(c, u) {
            if (u === void 0 && (u = 1e-6), c < 0) return 0;
            if (c > 1) return 1;
            for (var p = c, _ = 0; _ < 8; _++) {
              var x = this.sampleCurveX(p) - c;
              if (Math.abs(x) < u) return p;
              var T = this.sampleCurveDerivativeX(p);
              if (Math.abs(T) < 1e-6) break;
              p -= x / T;
            }
            var I = 0, B = 1;
            for (p = c, _ = 0; _ < 20 && (x = this.sampleCurveX(p), !(Math.abs(x - c) < u)); _++) c > x ? I = p : B = p, p = 0.5 * (B - I) + I;
            return p;
          }, solve: function(c, u) {
            return this.sampleCurveY(this.solveCurveX(c, u));
          } }, M;
        }(), V = d(U);
        let q, Y;
        function re() {
          return q == null && (q = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), q;
        }
        function Z() {
          if (Y == null && (Y = !1, re())) {
            const c = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: !0 });
            if (c) {
              for (let p = 0; p < 5 * 5; p++) {
                const _ = 4 * p;
                c.fillStyle = `rgb(${_},${_ + 1},${_ + 2})`, c.fillRect(p % 5, Math.floor(p / 5), 1, 1);
              }
              const u = c.getImageData(0, 0, 5, 5).data;
              for (let p = 0; p < 5 * 5 * 4; p++) if (p % 4 != 3 && u[p] !== p) {
                Y = !0;
                break;
              }
            }
          }
          return Y || !1;
        }
        var K = 1e-6, ie = typeof Float32Array < "u" ? Float32Array : Array;
        function be() {
          var f = new ie(9);
          return ie != Float32Array && (f[1] = 0, f[2] = 0, f[3] = 0, f[5] = 0, f[6] = 0, f[7] = 0), f[0] = 1, f[4] = 1, f[8] = 1, f;
        }
        function he(f) {
          return f[0] = 1, f[1] = 0, f[2] = 0, f[3] = 0, f[4] = 0, f[5] = 1, f[6] = 0, f[7] = 0, f[8] = 0, f[9] = 0, f[10] = 1, f[11] = 0, f[12] = 0, f[13] = 0, f[14] = 0, f[15] = 1, f;
        }
        function Be() {
          var f = new ie(3);
          return ie != Float32Array && (f[0] = 0, f[1] = 0, f[2] = 0), f;
        }
        function ke(f) {
          return Math.hypot(f[0], f[1], f[2]);
        }
        function pe(f, c, u) {
          var p = new ie(3);
          return p[0] = f, p[1] = c, p[2] = u, p;
        }
        function me(f, c, u) {
          return f[0] = c[0] + u[0], f[1] = c[1] + u[1], f[2] = c[2] + u[2], f;
        }
        function je(f, c, u) {
          return f[0] = c[0] * u, f[1] = c[1] * u, f[2] = c[2] * u, f;
        }
        function Pe(f, c, u) {
          var p = c[0], _ = c[1], x = c[2], T = u[0], I = u[1], B = u[2];
          return f[0] = _ * B - x * I, f[1] = x * T - p * B, f[2] = p * I - _ * T, f;
        }
        Math.hypot || (Math.hypot = function() {
          for (var f = 0, c = arguments.length; c--; ) f += arguments[c] * arguments[c];
          return Math.sqrt(f);
        });
        var St, Mt = ke;
        function Lt(f, c, u) {
          var p = c[0], _ = c[1], x = c[2], T = c[3];
          return f[0] = u[0] * p + u[4] * _ + u[8] * x + u[12] * T, f[1] = u[1] * p + u[5] * _ + u[9] * x + u[13] * T, f[2] = u[2] * p + u[6] * _ + u[10] * x + u[14] * T, f[3] = u[3] * p + u[7] * _ + u[11] * x + u[15] * T, f;
        }
        function xt() {
          var f = new ie(4);
          return ie != Float32Array && (f[0] = 0, f[1] = 0, f[2] = 0), f[3] = 1, f;
        }
        function zt(f, c, u, p) {
          var _ = 0.5 * Math.PI / 180;
          c *= _, u *= _, p *= _;
          var x = Math.sin(c), T = Math.cos(c), I = Math.sin(u), B = Math.cos(u), N = Math.sin(p), z = Math.cos(p);
          return f[0] = x * B * z - T * I * N, f[1] = T * I * z + x * B * N, f[2] = T * B * N - x * I * z, f[3] = T * B * z + x * I * N, f;
        }
        function Dt() {
          var f = new ie(2);
          return ie != Float32Array && (f[0] = 0, f[1] = 0), f;
        }
        function hr(f, c) {
          var u = new ie(2);
          return u[0] = f, u[1] = c, u;
        }
        Be(), St = new ie(4), ie != Float32Array && (St[0] = 0, St[1] = 0, St[2] = 0, St[3] = 0), Be(), pe(1, 0, 0), pe(0, 1, 0), xt(), xt(), be(), Dt();
        const ce = 8192;
        function Oe(f, c, u) {
          return c * (ce / (f.tileSize * Math.pow(2, u - f.tileID.overscaledZ)));
        }
        function $e(f, c) {
          return (f % c + c) % c;
        }
        function et(f, c, u) {
          return f * (1 - u) + c * u;
        }
        function ot(f) {
          if (f <= 0) return 0;
          if (f >= 1) return 1;
          const c = f * f, u = c * f;
          return 4 * (f < 0.5 ? u : 3 * (f - c) + u - 0.75);
        }
        function ht(f, c, u, p) {
          const _ = new V(f, c, u, p);
          return (x) => _.solve(x);
        }
        const It = ht(0.25, 0.1, 0.25, 1);
        function yt(f, c, u) {
          return Math.min(u, Math.max(c, f));
        }
        function ar(f, c, u) {
          const p = u - c, _ = ((f - c) % p + p) % p + c;
          return _ === c ? u : _;
        }
        function Kt(f) {
          for (var c = arguments.length, u = new Array(c > 1 ? c - 1 : 0), p = 1; p < c; p++)
            u[p - 1] = arguments[p];
          for (const _ of u) for (const x in _) f[x] = _[x];
          return f;
        }
        let vr = 1;
        function sr(f, c, u) {
          const p = {};
          for (const _ in f) p[_] = c.call(this, f[_], _, f);
          return p;
        }
        function Ur(f, c, u) {
          const p = {};
          for (const _ in f) c.call(this, f[_], _, f) && (p[_] = f[_]);
          return p;
        }
        function Nt(f) {
          return Array.isArray(f) ? f.map(Nt) : typeof f == "object" && f ? sr(f, Nt) : f;
        }
        const We = {};
        function Dr(f) {
          We[f] || (typeof console < "u" && console.warn(f), We[f] = !0);
        }
        function Tr(f, c, u) {
          return (u.y - f.y) * (c.x - f.x) > (c.y - f.y) * (u.x - f.x);
        }
        function Yt(f) {
          return typeof WorkerGlobalScope < "u" && f !== void 0 && f instanceof WorkerGlobalScope;
        }
        let pr = null;
        function mr(f) {
          return typeof ImageBitmap < "u" && f instanceof ImageBitmap;
        }
        const _r = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        function Lr(f, c, u, p, _) {
          return o(this, void 0, void 0, function* () {
            if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
            const x = new VideoFrame(f, { timestamp: 0 });
            try {
              const T = x == null ? void 0 : x.format;
              if (!T || !T.startsWith("BGR") && !T.startsWith("RGB")) throw new Error(`Unrecognized format ${T}`);
              const I = T.startsWith("BGR"), B = new Uint8ClampedArray(p * _ * 4);
              if (yield x.copyTo(B, function(N, z, $, J, te) {
                const ne = 4 * Math.max(1, 0), ue = (Math.max(0, $) - $) * J * 4 + ne, Se = 4 * J, Ee = Math.max(0, z), Je = Math.max(0, $);
                return { rect: { x: Ee, y: Je, width: Math.min(N.width, z + J) - Ee, height: Math.min(N.height, $ + te) - Je }, layout: [{ offset: ue, stride: Se }] };
              }(f, c, u, p, _)), I) for (let N = 0; N < B.length; N += 4) {
                const z = B[N];
                B[N] = B[N + 2], B[N + 2] = z;
              }
              return B;
            } finally {
              x.close();
            }
          });
        }
        let qr, Kr;
        function en(f, c, u, p) {
          return f.addEventListener(c, u, p), { unsubscribe: () => {
            f.removeEventListener(c, u, p);
          } };
        }
        function nn(f) {
          return f * Math.PI / 180;
        }
        function vn(f) {
          return f / Math.PI * 180;
        }
        const Hr = { touchstart: !0, touchmove: !0, touchmoveWindow: !0, touchend: !0, touchcancel: !0 }, fn = { dblclick: !0, click: !0, mouseover: !0, mouseout: !0, mousedown: !0, mousemove: !0, mousemoveWindow: !0, mouseup: !0, mouseupWindow: !0, contextmenu: !0, wheel: !0 }, gr = "AbortError";
        function nt() {
          return new Error(gr);
        }
        const oe = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
        function fe(f) {
          return oe.REGISTERED_PROTOCOLS[f.substring(0, f.indexOf("://"))];
        }
        const ye = "global-dispatcher";
        class Le extends Error {
          constructor(c, u, p, _) {
            super(`AJAXError: ${u} (${c}): ${p}`), this.status = c, this.statusText = u, this.url = p, this.body = _;
          }
        }
        const Ye = () => Yt(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, Qe = function(f, c) {
          if (/:\/\//.test(f.url) && !/^https?:|^file:/.test(f.url)) {
            const p = fe(f.url);
            if (p) return p(f, c);
            if (Yt(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: f, targetMapId: ye }, c);
          }
          if (!(/^file:/.test(u = f.url) || /^file:/.test(Ye()) && !/^\w+:/.test(u))) {
            if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function(p, _) {
              return o(this, void 0, void 0, function* () {
                const x = new Request(p.url, { method: p.method || "GET", body: p.body, credentials: p.credentials, headers: p.headers, cache: p.cache, referrer: Ye(), signal: _.signal });
                let T, I;
                p.type !== "json" || x.headers.has("Accept") || x.headers.set("Accept", "application/json");
                try {
                  T = yield fetch(x);
                } catch (N) {
                  throw new Le(0, N.message, p.url, new Blob());
                }
                if (!T.ok) {
                  const N = yield T.blob();
                  throw new Le(T.status, T.statusText, p.url, N);
                }
                I = p.type === "arrayBuffer" || p.type === "image" ? T.arrayBuffer() : p.type === "json" ? T.json() : T.text();
                const B = yield I;
                if (_.signal.aborted) throw nt();
                return { data: B, cacheControl: T.headers.get("Cache-Control"), expires: T.headers.get("Expires") };
              });
            }(f, c);
            if (Yt(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: f, mustQueue: !0, targetMapId: ye }, c);
          }
          var u;
          return function(p, _) {
            return new Promise((x, T) => {
              var I;
              const B = new XMLHttpRequest();
              B.open(p.method || "GET", p.url, !0), p.type !== "arrayBuffer" && p.type !== "image" || (B.responseType = "arraybuffer");
              for (const N in p.headers) B.setRequestHeader(N, p.headers[N]);
              p.type === "json" && (B.responseType = "text", !((I = p.headers) === null || I === void 0) && I.Accept || B.setRequestHeader("Accept", "application/json")), B.withCredentials = p.credentials === "include", B.onerror = () => {
                T(new Error(B.statusText));
              }, B.onload = () => {
                if (!_.signal.aborted) if ((B.status >= 200 && B.status < 300 || B.status === 0) && B.response !== null) {
                  let N = B.response;
                  if (p.type === "json") try {
                    N = JSON.parse(B.response);
                  } catch (z) {
                    return void T(z);
                  }
                  x({ data: N, cacheControl: B.getResponseHeader("Cache-Control"), expires: B.getResponseHeader("Expires") });
                } else {
                  const N = new Blob([B.response], { type: B.getResponseHeader("Content-Type") });
                  T(new Le(B.status, B.statusText, p.url, N));
                }
              }, _.signal.addEventListener("abort", () => {
                B.abort(), T(nt());
              }), B.send(p.body);
            });
          }(f, c);
        };
        function gt(f) {
          if (!f || f.indexOf("://") <= 0 || f.indexOf("data:image/") === 0 || f.indexOf("blob:") === 0) return !0;
          const c = new URL(f), u = window.location;
          return c.protocol === u.protocol && c.host === u.host;
        }
        function Ke(f, c, u) {
          u[f] && u[f].indexOf(c) !== -1 || (u[f] = u[f] || [], u[f].push(c));
        }
        function Bt(f, c, u) {
          if (u && u[f]) {
            const p = u[f].indexOf(c);
            p !== -1 && u[f].splice(p, 1);
          }
        }
        class Pt {
          constructor(c) {
            let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            Kt(this, u), this.type = c;
          }
        }
        class st extends Pt {
          constructor(c) {
            let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            super("error", Kt({ error: c }, u));
          }
        }
        class ft {
          on(c, u) {
            return this._listeners = this._listeners || {}, Ke(c, u, this._listeners), { unsubscribe: () => {
              this.off(c, u);
            } };
          }
          off(c, u) {
            return Bt(c, u, this._listeners), Bt(c, u, this._oneTimeListeners), this;
          }
          once(c, u) {
            return u ? (this._oneTimeListeners = this._oneTimeListeners || {}, Ke(c, u, this._oneTimeListeners), this) : new Promise((p) => this.once(c, p));
          }
          fire(c, u) {
            typeof c == "string" && (c = new Pt(c, u || {}));
            const p = c.type;
            if (this.listens(p)) {
              c.target = this;
              const _ = this._listeners && this._listeners[p] ? this._listeners[p].slice() : [];
              for (const I of _) I.call(this, c);
              const x = this._oneTimeListeners && this._oneTimeListeners[p] ? this._oneTimeListeners[p].slice() : [];
              for (const I of x) Bt(p, I, this._oneTimeListeners), I.call(this, c);
              const T = this._eventedParent;
              T && (Kt(c, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), T.fire(c));
            } else c instanceof st && console.error(c.error);
            return this;
          }
          listens(c) {
            return this._listeners && this._listeners[c] && this._listeners[c].length > 0 || this._oneTimeListeners && this._oneTimeListeners[c] && this._oneTimeListeners[c].length > 0 || this._eventedParent && this._eventedParent.listens(c);
          }
          setEventedParent(c, u) {
            return this._eventedParent = c, this._eventedParentData = u, this;
          }
        }
        var Ge = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, centerAltitude: { type: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, state: { type: "state", default: {} }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: !0, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { required: !0, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, "color-relief": {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_color-relief": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, terrain: { source: { type: "string", required: !0 }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "projectionDefinition", default: "mercator", "property-type": "data-constant", transition: !1, expression: { interpolated: !0, parameters: ["zoom"] } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "numberArray", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-altitude": { type: "numberArray", default: 45, minimum: 0, maximum: 90, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "colorArray", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "colorArray", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-method": { type: "enum", values: { standard: {}, basic: {}, combined: {}, igor: {}, multidirectional: {} }, default: "standard", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, "paint_color-relief": { "color-relief-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "color-relief-color": { type: "color", transition: !1, expression: { interpolated: !0, parameters: ["elevation"] }, "property-type": "color-ramp" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
        const ur = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
        function Sr(f, c) {
          const u = {};
          for (const p in f) p !== "ref" && (u[p] = f[p]);
          return ur.forEach((p) => {
            p in c && (u[p] = c[p]);
          }), u;
        }
        function lr(f, c) {
          if (Array.isArray(f)) {
            if (!Array.isArray(c) || f.length !== c.length) return !1;
            for (let u = 0; u < f.length; u++) if (!lr(f[u], c[u])) return !1;
            return !0;
          }
          if (typeof f == "object" && f !== null && c !== null) {
            if (typeof c != "object" || Object.keys(f).length !== Object.keys(c).length) return !1;
            for (const u in f) if (!lr(f[u], c[u])) return !1;
            return !0;
          }
          return f === c;
        }
        function Er(f, c) {
          f.push(c);
        }
        function tr(f, c, u) {
          Er(u, { command: "addSource", args: [f, c[f]] });
        }
        function xn(f, c, u) {
          Er(c, { command: "removeSource", args: [f] }), u[f] = !0;
        }
        function dn(f, c, u, p) {
          xn(f, u, p), tr(f, c, u);
        }
        function Jr(f, c, u) {
          let p;
          for (p in f[u]) if (Object.prototype.hasOwnProperty.call(f[u], p) && p !== "data" && !lr(f[u][p], c[u][p])) return !1;
          for (p in c[u]) if (Object.prototype.hasOwnProperty.call(c[u], p) && p !== "data" && !lr(f[u][p], c[u][p])) return !1;
          return !0;
        }
        function Cr(f, c, u, p, _, x) {
          f = f || {}, c = c || {};
          for (const T in f) Object.prototype.hasOwnProperty.call(f, T) && (lr(f[T], c[T]) || u.push({ command: x, args: [p, T, c[T], _] }));
          for (const T in c) Object.prototype.hasOwnProperty.call(c, T) && !Object.prototype.hasOwnProperty.call(f, T) && (lr(f[T], c[T]) || u.push({ command: x, args: [p, T, c[T], _] }));
        }
        function zr(f) {
          return f.id;
        }
        function Dn(f, c) {
          return f[c.id] = c, f;
        }
        class er {
          constructor(c, u, p, _) {
            this.message = (c ? `${c}: ` : "") + p, _ && (this.identifier = _), u != null && u.__line__ && (this.line = u.__line__);
          }
        }
        function oi(f) {
          for (var c = arguments.length, u = new Array(c > 1 ? c - 1 : 0), p = 1; p < c; p++)
            u[p - 1] = arguments[p];
          for (const _ of u) for (const x in _) f[x] = _[x];
          return f;
        }
        class Mn extends Error {
          constructor(c, u) {
            super(u), this.message = u, this.key = c;
          }
        }
        class rs {
          constructor(c) {
            let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
            this.parent = c, this.bindings = {};
            for (const [p, _] of u) this.bindings[p] = _;
          }
          concat(c) {
            return new rs(this, c);
          }
          get(c) {
            if (this.bindings[c]) return this.bindings[c];
            if (this.parent) return this.parent.get(c);
            throw new Error(`${c} not found in scope.`);
          }
          has(c) {
            return !!this.bindings[c] || !!this.parent && this.parent.has(c);
          }
        }
        const _s = { kind: "null" }, rr = { kind: "number" }, Vr = { kind: "string" }, Gr = { kind: "boolean" }, Hi = { kind: "color" }, Ga = { kind: "projectionDefinition" }, Vs = { kind: "object" }, Xr = { kind: "value" }, io = { kind: "collator" }, va = { kind: "formatted" }, bi = { kind: "padding" }, Vl = { kind: "colorArray" }, xa = { kind: "numberArray" }, Po = { kind: "resolvedImage" }, $l = { kind: "variableAnchorOffsetCollection" };
        function ys(f, c) {
          return { kind: "array", itemType: f, N: c };
        }
        function ti(f) {
          if (f.kind === "array") {
            const c = ti(f.itemType);
            return typeof f.N == "number" ? `array<${c}, ${f.N}>` : f.itemType.kind === "value" ? "array" : `array<${c}>`;
          }
          return f.kind;
        }
        const vu = [_s, rr, Vr, Gr, Hi, Ga, va, Vs, ys(Xr), bi, xa, Vl, Po, $l];
        function ql(f, c) {
          if (c.kind === "error") return null;
          if (f.kind === "array") {
            if (c.kind === "array" && (c.N === 0 && c.itemType.kind === "value" || !ql(f.itemType, c.itemType)) && (typeof f.N != "number" || f.N === c.N)) return null;
          } else {
            if (f.kind === c.kind) return null;
            if (f.kind === "value") {
              for (const u of vu) if (!ql(u, c)) return null;
            }
          }
          return `Expected ${ti(f)} but found ${ti(c)} instead.`;
        }
        function Ha(f, c) {
          return c.some((u) => u.kind === f.kind);
        }
        function Wa(f, c) {
          return c.some((u) => u === "null" ? f === null : u === "array" ? Array.isArray(f) : u === "object" ? f && !Array.isArray(f) && typeof f == "object" : u === typeof f);
        }
        function Hn(f, c) {
          return f.kind === "array" && c.kind === "array" ? f.itemType.kind === c.itemType.kind && typeof f.N == "number" : f.kind === c.kind;
        }
        const xu = 0.96422, wu = 0.82521, Au = 4 / 29, wa = 6 / 29, ih = 3 * wa * wa, Ro = wa * wa * wa, Aa = Math.PI / 180, so = 180 / Math.PI;
        function Dc(f) {
          return (f %= 360) < 0 && (f += 360), f;
        }
        function Xa(f) {
          let [c, u, p, _] = f, x, T;
          const I = Fc((0.2225045 * (c = Tu(c)) + 0.7168786 * (u = Tu(u)) + 0.0606169 * (p = Tu(p))) / 1);
          c === u && u === p ? x = T = I : (x = Fc((0.4360747 * c + 0.3850649 * u + 0.1430804 * p) / xu), T = Fc((0.0139322 * c + 0.0971045 * u + 0.7141733 * p) / wu));
          const B = 116 * I - 16;
          return [B < 0 ? 0 : B, 500 * (x - I), 200 * (I - T), _];
        }
        function Tu(f) {
          return f <= 0.04045 ? f / 12.92 : Math.pow((f + 0.055) / 1.055, 2.4);
        }
        function Fc(f) {
          return f > Ro ? Math.pow(f, 1 / 3) : f / ih + Au;
        }
        function sh(f) {
          let [c, u, p, _] = f, x = (c + 16) / 116, T = isNaN(u) ? x : x + u / 500, I = isNaN(p) ? x : x - p / 200;
          return x = 1 * Uc(x), T = xu * Uc(T), I = wu * Uc(I), [Gl(3.1338561 * T - 1.6168667 * x - 0.4906146 * I), Gl(-0.9787684 * T + 1.9161415 * x + 0.033454 * I), Gl(0.0719453 * T - 0.2289914 * x + 1.4052427 * I), _];
        }
        function Gl(f) {
          return (f = f <= 304e-5 ? 12.92 * f : 1.055 * Math.pow(f, 1 / 2.4) - 0.055) < 0 ? 0 : f > 1 ? 1 : f;
        }
        function Uc(f) {
          return f > wa ? f * f * f : ih * (f - Au);
        }
        const oo = Object.hasOwn || function(f, c) {
          return Object.prototype.hasOwnProperty.call(f, c);
        };
        function un(f, c) {
          return oo(f, c) ? f[c] : void 0;
        }
        function sa(f) {
          return parseInt(f.padEnd(2, f), 16) / 255;
        }
        function oa(f, c) {
          return $s(c ? f / 100 : f, 0, 1);
        }
        function $s(f, c, u) {
          return Math.min(Math.max(c, f), u);
        }
        function bl(f) {
          return !f.some(Number.isNaN);
        }
        const vl = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
        function qs(f, c, u) {
          return f + u * (c - f);
        }
        function hi(f, c, u) {
          return f.map((p, _) => qs(p, c[_], u));
        }
        class hn {
          constructor(c, u, p) {
            let _ = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1, x = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0;
            this.r = c, this.g = u, this.b = p, this.a = _, x || (this.r *= _, this.g *= _, this.b *= _, _ || this.overwriteGetter("rgb", [c, u, p, _]));
          }
          static parse(c) {
            if (c instanceof hn) return c;
            if (typeof c != "string") return;
            const u = function(p) {
              if ((p = p.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
              const _ = un(vl, p);
              if (_) {
                const [T, I, B] = _;
                return [T / 255, I / 255, B / 255, 1];
              }
              if (p.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(p)) {
                const T = p.length < 6 ? 1 : 2;
                let I = 1;
                return [sa(p.slice(I, I += T)), sa(p.slice(I, I += T)), sa(p.slice(I, I += T)), sa(p.slice(I, I + T) || "ff")];
              }
              if (p.startsWith("rgb")) {
                const T = p.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (T) {
                  const [I, B, N, z, $, J, te, ne, ue, Se, Ee, Je] = T, ze = [z || " ", te || " ", Se].join("");
                  if (ze === "  " || ze === "  /" || ze === ",," || ze === ",,,") {
                    const ee = [N, J, ue].join(""), ve = ee === "%%%" ? 100 : ee === "" ? 255 : 0;
                    if (ve) {
                      const qe = [$s(+B / ve, 0, 1), $s(+$ / ve, 0, 1), $s(+ne / ve, 0, 1), Ee ? oa(+Ee, Je) : 1];
                      if (bl(qe)) return qe;
                    }
                  }
                  return;
                }
              }
              const x = p.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (x) {
                const [T, I, B, N, z, $, J, te, ne] = x, ue = [B || " ", z || " ", J].join("");
                if (ue === "  " || ue === "  /" || ue === ",," || ue === ",,,") {
                  const Se = [+I, $s(+N, 0, 100), $s(+$, 0, 100), te ? oa(+te, ne) : 1];
                  if (bl(Se)) return function(Ee) {
                    let [Je, ze, ee, ve] = Ee;
                    function qe(_t) {
                      const $t = (_t + Je / 30) % 12, Rt = ze * Math.min(ee, 1 - ee);
                      return ee - Rt * Math.max(-1, Math.min($t - 3, 9 - $t, 1));
                    }
                    return Je = Dc(Je), ze /= 100, ee /= 100, [qe(0), qe(8), qe(4), ve];
                  }(Se);
                }
              }
            }(c);
            return u ? new hn(...u, !1) : void 0;
          }
          get rgb() {
            const { r: c, g: u, b: p, a: _ } = this, x = _ || 1 / 0;
            return this.overwriteGetter("rgb", [c / x, u / x, p / x, _]);
          }
          get hcl() {
            return this.overwriteGetter("hcl", function(c) {
              const [u, p, _, x] = Xa(c), T = Math.sqrt(p * p + _ * _);
              return [Math.round(1e4 * T) ? Dc(Math.atan2(_, p) * so) : NaN, T, u, x];
            }(this.rgb));
          }
          get lab() {
            return this.overwriteGetter("lab", Xa(this.rgb));
          }
          overwriteGetter(c, u) {
            return Object.defineProperty(this, c, { value: u }), u;
          }
          toString() {
            const [c, u, p, _] = this.rgb;
            return `rgba(${[c, u, p].map((x) => Math.round(255 * x)).join(",")},${_})`;
          }
          static interpolate(c, u, p) {
            switch (arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "rgb") {
              case "rgb": {
                const [x, T, I, B] = hi(c.rgb, u.rgb, p);
                return new hn(x, T, I, B, !1);
              }
              case "hcl": {
                const [x, T, I, B] = c.hcl, [N, z, $, J] = u.hcl;
                let te, ne;
                if (isNaN(x) || isNaN(N)) isNaN(x) ? isNaN(N) ? te = NaN : (te = N, I !== 1 && I !== 0 || (ne = z)) : (te = x, $ !== 1 && $ !== 0 || (ne = T));
                else {
                  let ze = N - x;
                  N > x && ze > 180 ? ze -= 360 : N < x && x - N > 180 && (ze += 360), te = x + p * ze;
                }
                const [ue, Se, Ee, Je] = function(ze) {
                  let [ee, ve, qe, _t] = ze;
                  return ee = isNaN(ee) ? 0 : ee * Aa, sh([qe, Math.cos(ee) * ve, Math.sin(ee) * ve, _t]);
                }([te, ne ?? qs(T, z, p), qs(I, $, p), qs(B, J, p)]);
                return new hn(ue, Se, Ee, Je, !1);
              }
              case "lab": {
                const [x, T, I, B] = sh(hi(c.lab, u.lab, p));
                return new hn(x, T, I, B, !1);
              }
            }
          }
        }
        hn.black = new hn(0, 0, 0, 1), hn.white = new hn(1, 1, 1, 1), hn.transparent = new hn(0, 0, 0, 0), hn.red = new hn(1, 0, 0, 1);
        class xl {
          constructor(c, u, p) {
            this.sensitivity = c ? u ? "variant" : "case" : u ? "accent" : "base", this.locale = p, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(c, u) {
            return this.collator.compare(c, u);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        const Zr = ["bottom", "center", "top"];
        class Su {
          constructor(c, u, p, _, x, T) {
            this.text = c, this.image = u, this.scale = p, this.fontStack = _, this.textColor = x, this.verticalAlign = T;
          }
        }
        class ns {
          constructor(c) {
            this.sections = c;
          }
          static fromString(c) {
            return new ns([new Su(c, null, null, null, null, null)]);
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some((c) => c.text.length !== 0 || c.image && c.image.name.length !== 0);
          }
          static factory(c) {
            return c instanceof ns ? c : ns.fromString(c);
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map((c) => c.text).join("");
          }
        }
        class zn {
          constructor(c) {
            this.values = c.slice();
          }
          static parse(c) {
            if (c instanceof zn) return c;
            if (typeof c == "number") return new zn([c, c, c, c]);
            if (Array.isArray(c) && !(c.length < 1 || c.length > 4)) {
              for (const u of c) if (typeof u != "number") return;
              switch (c.length) {
                case 1:
                  c = [c[0], c[0], c[0], c[0]];
                  break;
                case 2:
                  c = [c[0], c[1], c[0], c[1]];
                  break;
                case 3:
                  c = [c[0], c[1], c[2], c[1]];
              }
              return new zn(c);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(c, u, p) {
            return new zn(hi(c.values, u.values, p));
          }
        }
        class Wi {
          constructor(c) {
            this.values = c.slice();
          }
          static parse(c) {
            if (c instanceof Wi) return c;
            if (typeof c == "number") return new Wi([c]);
            if (Array.isArray(c)) {
              for (const u of c) if (typeof u != "number") return;
              return new Wi(c);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(c, u, p) {
            return new Wi(hi(c.values, u.values, p));
          }
        }
        class Ni {
          constructor(c) {
            this.values = c.slice();
          }
          static parse(c) {
            if (c instanceof Ni) return c;
            if (typeof c == "string") {
              const p = hn.parse(c);
              return p ? new Ni([p]) : void 0;
            }
            if (!Array.isArray(c)) return;
            const u = [];
            for (const p of c) {
              if (typeof p != "string") return;
              const _ = hn.parse(p);
              if (!_) return;
              u.push(_);
            }
            return new Ni(u);
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(c, u, p) {
            let _ = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "rgb";
            const x = [];
            if (c.values.length != u.values.length) throw new Error(`colorArray: Arrays have mismatched length (${c.values.length} vs. ${u.values.length}), cannot interpolate.`);
            for (let T = 0; T < c.values.length; T++) x.push(hn.interpolate(c.values[T], u.values[T], p, _));
            return new Ni(x);
          }
        }
        class jn extends Error {
          constructor(c) {
            super(c), this.name = "RuntimeError";
          }
          toJSON() {
            return this.message;
          }
        }
        const wl = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class pn {
          constructor(c) {
            this.values = c.slice();
          }
          static parse(c) {
            if (c instanceof pn) return c;
            if (Array.isArray(c) && !(c.length < 1) && c.length % 2 == 0) {
              for (let u = 0; u < c.length; u += 2) {
                const p = c[u], _ = c[u + 1];
                if (typeof p != "string" || !wl.has(p) || !Array.isArray(_) || _.length !== 2 || typeof _[0] != "number" || typeof _[1] != "number") return;
              }
              return new pn(c);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(c, u, p) {
            const _ = c.values, x = u.values;
            if (_.length !== x.length) throw new jn(`Cannot interpolate values of different length. from: ${c.toString()}, to: ${u.toString()}`);
            const T = [];
            for (let I = 0; I < _.length; I += 2) {
              if (_[I] !== x[I]) throw new jn(`Cannot interpolate values containing mismatched anchors. from[${I}]: ${_[I]}, to[${I}]: ${x[I]}`);
              T.push(_[I]);
              const [B, N] = _[I + 1], [z, $] = x[I + 1];
              T.push([qs(B, z, p), qs(N, $, p)]);
            }
            return new pn(T);
          }
        }
        class Ps {
          constructor(c) {
            this.name = c.name, this.available = c.available;
          }
          toString() {
            return this.name;
          }
          static fromString(c) {
            return c ? new Ps({ name: c, available: !1 }) : null;
          }
        }
        class Wr {
          constructor(c, u, p) {
            this.from = c, this.to = u, this.transition = p;
          }
          static interpolate(c, u, p) {
            return new Wr(c, u, p);
          }
          static parse(c) {
            return c instanceof Wr ? c : Array.isArray(c) && c.length === 3 && typeof c[0] == "string" && typeof c[1] == "string" && typeof c[2] == "number" ? new Wr(c[0], c[1], c[2]) : typeof c == "object" && typeof c.from == "string" && typeof c.to == "string" && typeof c.transition == "number" ? new Wr(c.from, c.to, c.transition) : typeof c == "string" ? new Wr(c, c, 1) : void 0;
          }
        }
        function Yr(f, c, u, p) {
          return typeof f == "number" && f >= 0 && f <= 255 && typeof c == "number" && c >= 0 && c <= 255 && typeof u == "number" && u >= 0 && u <= 255 ? p === void 0 || typeof p == "number" && p >= 0 && p <= 1 ? null : `Invalid rgba value [${[f, c, u, p].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof p == "number" ? [f, c, u, p] : [f, c, u]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function bo(f) {
          if (f === null || typeof f == "string" || typeof f == "boolean" || typeof f == "number" || f instanceof Wr || f instanceof hn || f instanceof xl || f instanceof ns || f instanceof zn || f instanceof Wi || f instanceof Ni || f instanceof pn || f instanceof Ps) return !0;
          if (Array.isArray(f)) {
            for (const c of f) if (!bo(c)) return !1;
            return !0;
          }
          if (typeof f == "object") {
            for (const c in f) if (!bo(f[c])) return !1;
            return !0;
          }
          return !1;
        }
        function Or(f) {
          if (f === null) return _s;
          if (typeof f == "string") return Vr;
          if (typeof f == "boolean") return Gr;
          if (typeof f == "number") return rr;
          if (f instanceof hn) return Hi;
          if (f instanceof Wr) return Ga;
          if (f instanceof xl) return io;
          if (f instanceof ns) return va;
          if (f instanceof zn) return bi;
          if (f instanceof Wi) return xa;
          if (f instanceof Ni) return Vl;
          if (f instanceof pn) return $l;
          if (f instanceof Ps) return Po;
          if (Array.isArray(f)) {
            const c = f.length;
            let u;
            for (const p of f) {
              const _ = Or(p);
              if (u) {
                if (u === _) continue;
                u = Xr;
                break;
              }
              u = _;
            }
            return ys(u || Xr, c);
          }
          return Vs;
        }
        function Za(f) {
          const c = typeof f;
          return f === null ? "" : c === "string" || c === "number" || c === "boolean" ? String(f) : f instanceof hn || f instanceof Wr || f instanceof ns || f instanceof zn || f instanceof Wi || f instanceof Ni || f instanceof pn || f instanceof Ps ? f.toString() : JSON.stringify(f);
        }
        class Di {
          constructor(c, u) {
            this.type = c, this.value = u;
          }
          static parse(c, u) {
            if (c.length !== 2) return u.error(`'literal' expression requires exactly one argument, but found ${c.length - 1} instead.`);
            if (!bo(c[1])) return u.error("invalid value");
            const p = c[1];
            let _ = Or(p);
            const x = u.expectedType;
            return _.kind !== "array" || _.N !== 0 || !x || x.kind !== "array" || typeof x.N == "number" && x.N !== 0 || (_ = x), new Di(_, p);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        const Ta = { string: Vr, number: rr, boolean: Gr, object: Vs };
        class bs {
          constructor(c, u) {
            this.type = c, this.args = u;
          }
          static parse(c, u) {
            if (c.length < 2) return u.error("Expected at least one argument.");
            let p, _ = 1;
            const x = c[0];
            if (x === "array") {
              let I, B;
              if (c.length > 2) {
                const N = c[1];
                if (typeof N != "string" || !(N in Ta) || N === "object") return u.error('The item type argument of "array" must be one of string, number, boolean', 1);
                I = Ta[N], _++;
              } else I = Xr;
              if (c.length > 3) {
                if (c[2] !== null && (typeof c[2] != "number" || c[2] < 0 || c[2] !== Math.floor(c[2]))) return u.error('The length argument to "array" must be a positive integer literal', 2);
                B = c[2], _++;
              }
              p = ys(I, B);
            } else {
              if (!Ta[x]) throw new Error(`Types doesn't contain name = ${x}`);
              p = Ta[x];
            }
            const T = [];
            for (; _ < c.length; _++) {
              const I = u.parse(c[_], _, Xr);
              if (!I) return null;
              T.push(I);
            }
            return new bs(p, T);
          }
          evaluate(c) {
            for (let u = 0; u < this.args.length; u++) {
              const p = this.args[u].evaluate(c);
              if (!ql(this.type, Or(p))) return p;
              if (u === this.args.length - 1) throw new jn(`Expected value to be of type ${ti(this.type)}, but found ${ti(Or(p))} instead.`);
            }
            throw new Error();
          }
          eachChild(c) {
            this.args.forEach(c);
          }
          outputDefined() {
            return this.args.every((c) => c.outputDefined());
          }
        }
        const zc = { "to-boolean": Gr, "to-color": Hi, "to-number": rr, "to-string": Vr };
        class vo {
          constructor(c, u) {
            this.type = c, this.args = u;
          }
          static parse(c, u) {
            if (c.length < 2) return u.error("Expected at least one argument.");
            const p = c[0];
            if (!zc[p]) throw new Error(`Can't parse ${p} as it is not part of the known types`);
            if ((p === "to-boolean" || p === "to-string") && c.length !== 2) return u.error("Expected one argument.");
            const _ = zc[p], x = [];
            for (let T = 1; T < c.length; T++) {
              const I = u.parse(c[T], T, Xr);
              if (!I) return null;
              x.push(I);
            }
            return new vo(_, x);
          }
          evaluate(c) {
            switch (this.type.kind) {
              case "boolean":
                return !!this.args[0].evaluate(c);
              case "color": {
                let u, p;
                for (const _ of this.args) {
                  if (u = _.evaluate(c), p = null, u instanceof hn) return u;
                  if (typeof u == "string") {
                    const x = c.parseColor(u);
                    if (x) return x;
                  } else if (Array.isArray(u) && (p = u.length < 3 || u.length > 4 ? `Invalid rgba value ${JSON.stringify(u)}: expected an array containing either three or four numeric values.` : Yr(u[0], u[1], u[2], u[3]), !p)) return new hn(u[0] / 255, u[1] / 255, u[2] / 255, u[3]);
                }
                throw new jn(p || `Could not parse color from value '${typeof u == "string" ? u : JSON.stringify(u)}'`);
              }
              case "padding": {
                let u;
                for (const p of this.args) {
                  u = p.evaluate(c);
                  const _ = zn.parse(u);
                  if (_) return _;
                }
                throw new jn(`Could not parse padding from value '${typeof u == "string" ? u : JSON.stringify(u)}'`);
              }
              case "numberArray": {
                let u;
                for (const p of this.args) {
                  u = p.evaluate(c);
                  const _ = Wi.parse(u);
                  if (_) return _;
                }
                throw new jn(`Could not parse numberArray from value '${typeof u == "string" ? u : JSON.stringify(u)}'`);
              }
              case "colorArray": {
                let u;
                for (const p of this.args) {
                  u = p.evaluate(c);
                  const _ = Ni.parse(u);
                  if (_) return _;
                }
                throw new jn(`Could not parse colorArray from value '${typeof u == "string" ? u : JSON.stringify(u)}'`);
              }
              case "variableAnchorOffsetCollection": {
                let u;
                for (const p of this.args) {
                  u = p.evaluate(c);
                  const _ = pn.parse(u);
                  if (_) return _;
                }
                throw new jn(`Could not parse variableAnchorOffsetCollection from value '${typeof u == "string" ? u : JSON.stringify(u)}'`);
              }
              case "number": {
                let u = null;
                for (const p of this.args) {
                  if (u = p.evaluate(c), u === null) return 0;
                  const _ = Number(u);
                  if (!isNaN(_)) return _;
                }
                throw new jn(`Could not convert ${JSON.stringify(u)} to number.`);
              }
              case "formatted":
                return ns.fromString(Za(this.args[0].evaluate(c)));
              case "resolvedImage":
                return Ps.fromString(Za(this.args[0].evaluate(c)));
              case "projectionDefinition":
                return this.args[0].evaluate(c);
              default:
                return Za(this.args[0].evaluate(c));
            }
          }
          eachChild(c) {
            this.args.forEach(c);
          }
          outputDefined() {
            return this.args.every((c) => c.outputDefined());
          }
        }
        const Eu = ["Unknown", "Point", "LineString", "Polygon"];
        class Cu {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? Eu[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          parseColor(c) {
            let u = this._parseColorCache.get(c);
            return u || (u = hn.parse(c), this._parseColorCache.set(c, u)), u;
          }
        }
        class ao {
          constructor(c, u) {
            let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], _ = arguments.length > 3 ? arguments[3] : void 0, x = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : new rs(), T = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : [];
            this.registry = c, this.path = p, this.key = p.map((I) => `[${I}]`).join(""), this.scope = x, this.errors = T, this.expectedType = _, this._isConstant = u;
          }
          parse(c, u, p, _) {
            let x = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
            return u ? this.concat(u, p, _)._parse(c, x) : this._parse(c, x);
          }
          _parse(c, u) {
            function p(_, x, T) {
              return T === "assert" ? new bs(x, [_]) : T === "coerce" ? new vo(x, [_]) : _;
            }
            if (c !== null && typeof c != "string" && typeof c != "boolean" && typeof c != "number" || (c = ["literal", c]), Array.isArray(c)) {
              if (c.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const _ = c[0];
              if (typeof _ != "string") return this.error(`Expression name must be a string, but found ${typeof _} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const x = this.registry[_];
              if (x) {
                let T = x.parse(c, this);
                if (!T) return null;
                if (this.expectedType) {
                  const I = this.expectedType, B = T.type;
                  if (I.kind !== "string" && I.kind !== "number" && I.kind !== "boolean" && I.kind !== "object" && I.kind !== "array" || B.kind !== "value") {
                    if (I.kind === "projectionDefinition" && ["string", "array"].includes(B.kind) || ["color", "formatted", "resolvedImage"].includes(I.kind) && ["value", "string"].includes(B.kind) || ["padding", "numberArray"].includes(I.kind) && ["value", "number", "array"].includes(B.kind) || I.kind === "colorArray" && ["value", "string", "array"].includes(B.kind) || I.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(B.kind)) T = p(T, I, u.typeAnnotation || "coerce");
                    else if (this.checkSubtype(I, B)) return null;
                  } else T = p(T, I, u.typeAnnotation || "assert");
                }
                if (!(T instanceof Di) && T.type.kind !== "resolvedImage" && this._isConstant(T)) {
                  const I = new Cu();
                  try {
                    T = new Di(T.type, T.evaluate(I));
                  } catch (B) {
                    return this.error(B.message), null;
                  }
                }
                return T;
              }
              return this.error(`Unknown expression "${_}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return this.error(c === void 0 ? "'undefined' value invalid. Use null instead." : typeof c == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof c} instead.`);
          }
          concat(c, u, p) {
            const _ = typeof c == "number" ? this.path.concat(c) : this.path, x = p ? this.scope.concat(p) : this.scope;
            return new ao(this.registry, this._isConstant, _, u || null, x, this.errors);
          }
          error(c) {
            for (var u = arguments.length, p = new Array(u > 1 ? u - 1 : 0), _ = 1; _ < u; _++)
              p[_ - 1] = arguments[_];
            const x = `${this.key}${p.map((T) => `[${T}]`).join("")}`;
            this.errors.push(new Mn(x, c));
          }
          checkSubtype(c, u) {
            const p = ql(c, u);
            return p && this.error(p), p;
          }
        }
        class xo {
          constructor(c, u) {
            this.type = u.type, this.bindings = [].concat(c), this.result = u;
          }
          evaluate(c) {
            return this.result.evaluate(c);
          }
          eachChild(c) {
            for (const u of this.bindings) c(u[1]);
            c(this.result);
          }
          static parse(c, u) {
            if (c.length < 4) return u.error(`Expected at least 3 arguments, but found ${c.length - 1} instead.`);
            const p = [];
            for (let x = 1; x < c.length - 1; x += 2) {
              const T = c[x];
              if (typeof T != "string") return u.error(`Expected string, but found ${typeof T} instead.`, x);
              if (/[^a-zA-Z0-9_]/.test(T)) return u.error("Variable names must contain only alphanumeric characters or '_'.", x);
              const I = u.parse(c[x + 1], x + 1);
              if (!I) return null;
              p.push([T, I]);
            }
            const _ = u.parse(c[c.length - 1], c.length - 1, u.expectedType, p);
            return _ ? new xo(p, _) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
        }
        class wo {
          constructor(c, u) {
            this.type = u.type, this.name = c, this.boundExpression = u;
          }
          static parse(c, u) {
            if (c.length !== 2 || typeof c[1] != "string") return u.error("'var' expression requires exactly one string literal argument.");
            const p = c[1];
            return u.scope.has(p) ? new wo(p, u.scope.get(p)) : u.error(`Unknown variable "${p}". Make sure "${p}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(c) {
            return this.boundExpression.evaluate(c);
          }
          eachChild() {
          }
          outputDefined() {
            return !1;
          }
        }
        class ai {
          constructor(c, u, p) {
            this.type = c, this.index = u, this.input = p;
          }
          static parse(c, u) {
            if (c.length !== 3) return u.error(`Expected 2 arguments, but found ${c.length - 1} instead.`);
            const p = u.parse(c[1], 1, rr), _ = u.parse(c[2], 2, ys(u.expectedType || Xr));
            return p && _ ? new ai(_.type.itemType, p, _) : null;
          }
          evaluate(c) {
            const u = this.index.evaluate(c), p = this.input.evaluate(c);
            if (u < 0) throw new jn(`Array index out of bounds: ${u} < 0.`);
            if (u >= p.length) throw new jn(`Array index out of bounds: ${u} > ${p.length - 1}.`);
            if (u !== Math.floor(u)) throw new jn(`Array index must be an integer, but found ${u} instead.`);
            return p[u];
          }
          eachChild(c) {
            c(this.index), c(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        class Rs {
          constructor(c, u) {
            this.type = Gr, this.needle = c, this.haystack = u;
          }
          static parse(c, u) {
            if (c.length !== 3) return u.error(`Expected 2 arguments, but found ${c.length - 1} instead.`);
            const p = u.parse(c[1], 1, Xr), _ = u.parse(c[2], 2, Xr);
            return p && _ ? Ha(p.type, [Gr, Vr, rr, _s, Xr]) ? new Rs(p, _) : u.error(`Expected first argument to be of type boolean, string, number or null, but found ${ti(p.type)} instead`) : null;
          }
          evaluate(c) {
            const u = this.needle.evaluate(c), p = this.haystack.evaluate(c);
            if (!p) return !1;
            if (!Wa(u, ["boolean", "string", "number", "null"])) throw new jn(`Expected first argument to be of type boolean, string, number or null, but found ${ti(Or(u))} instead.`);
            if (!Wa(p, ["string", "array"])) throw new jn(`Expected second argument to be of type array or string, but found ${ti(Or(p))} instead.`);
            return p.indexOf(u) >= 0;
          }
          eachChild(c) {
            c(this.needle), c(this.haystack);
          }
          outputDefined() {
            return !0;
          }
        }
        class Ya {
          constructor(c, u, p) {
            this.type = rr, this.needle = c, this.haystack = u, this.fromIndex = p;
          }
          static parse(c, u) {
            if (c.length <= 2 || c.length >= 5) return u.error(`Expected 3 or 4 arguments, but found ${c.length - 1} instead.`);
            const p = u.parse(c[1], 1, Xr), _ = u.parse(c[2], 2, Xr);
            if (!p || !_) return null;
            if (!Ha(p.type, [Gr, Vr, rr, _s, Xr])) return u.error(`Expected first argument to be of type boolean, string, number or null, but found ${ti(p.type)} instead`);
            if (c.length === 4) {
              const x = u.parse(c[3], 3, rr);
              return x ? new Ya(p, _, x) : null;
            }
            return new Ya(p, _);
          }
          evaluate(c) {
            const u = this.needle.evaluate(c), p = this.haystack.evaluate(c);
            if (!Wa(u, ["boolean", "string", "number", "null"])) throw new jn(`Expected first argument to be of type boolean, string, number or null, but found ${ti(Or(u))} instead.`);
            let _;
            if (this.fromIndex && (_ = this.fromIndex.evaluate(c)), Wa(p, ["string"])) {
              const x = p.indexOf(u, _);
              return x === -1 ? -1 : [...p.slice(0, x)].length;
            }
            if (Wa(p, ["array"])) return p.indexOf(u, _);
            throw new jn(`Expected second argument to be of type array or string, but found ${ti(Or(p))} instead.`);
          }
          eachChild(c) {
            c(this.needle), c(this.haystack), this.fromIndex && c(this.fromIndex);
          }
          outputDefined() {
            return !1;
          }
        }
        class Bo {
          constructor(c, u, p, _, x, T) {
            this.inputType = c, this.type = u, this.input = p, this.cases = _, this.outputs = x, this.otherwise = T;
          }
          static parse(c, u) {
            if (c.length < 5) return u.error(`Expected at least 4 arguments, but found only ${c.length - 1}.`);
            if (c.length % 2 != 1) return u.error("Expected an even number of arguments.");
            let p, _;
            u.expectedType && u.expectedType.kind !== "value" && (_ = u.expectedType);
            const x = {}, T = [];
            for (let N = 2; N < c.length - 1; N += 2) {
              let z = c[N];
              const $ = c[N + 1];
              Array.isArray(z) || (z = [z]);
              const J = u.concat(N);
              if (z.length === 0) return J.error("Expected at least one branch label.");
              for (const ne of z) {
                if (typeof ne != "number" && typeof ne != "string") return J.error("Branch labels must be numbers or strings.");
                if (typeof ne == "number" && Math.abs(ne) > Number.MAX_SAFE_INTEGER) return J.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof ne == "number" && Math.floor(ne) !== ne) return J.error("Numeric branch labels must be integer values.");
                if (p) {
                  if (J.checkSubtype(p, Or(ne))) return null;
                } else p = Or(ne);
                if (x[String(ne)] !== void 0) return J.error("Branch labels must be unique.");
                x[String(ne)] = T.length;
              }
              const te = u.parse($, N, _);
              if (!te) return null;
              _ = _ || te.type, T.push(te);
            }
            const I = u.parse(c[1], 1, Xr);
            if (!I) return null;
            const B = u.parse(c[c.length - 1], c.length - 1, _);
            return B ? I.type.kind !== "value" && u.concat(1).checkSubtype(p, I.type) ? null : new Bo(p, _, I, x, T, B) : null;
          }
          evaluate(c) {
            const u = this.input.evaluate(c);
            return (Or(u) === this.inputType && this.outputs[this.cases[u]] || this.otherwise).evaluate(c);
          }
          eachChild(c) {
            c(this.input), this.outputs.forEach(c), c(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every((c) => c.outputDefined()) && this.otherwise.outputDefined();
          }
        }
        class Ri {
          constructor(c, u, p) {
            this.type = c, this.branches = u, this.otherwise = p;
          }
          static parse(c, u) {
            if (c.length < 4) return u.error(`Expected at least 3 arguments, but found only ${c.length - 1}.`);
            if (c.length % 2 != 0) return u.error("Expected an odd number of arguments.");
            let p;
            u.expectedType && u.expectedType.kind !== "value" && (p = u.expectedType);
            const _ = [];
            for (let T = 1; T < c.length - 1; T += 2) {
              const I = u.parse(c[T], T, Gr);
              if (!I) return null;
              const B = u.parse(c[T + 1], T + 1, p);
              if (!B) return null;
              _.push([I, B]), p = p || B.type;
            }
            const x = u.parse(c[c.length - 1], c.length - 1, p);
            if (!x) return null;
            if (!p) throw new Error("Can't infer output type");
            return new Ri(p, _, x);
          }
          evaluate(c) {
            for (const [u, p] of this.branches) if (u.evaluate(c)) return p.evaluate(c);
            return this.otherwise.evaluate(c);
          }
          eachChild(c) {
            for (const [u, p] of this.branches) c(u), c(p);
            c(this.otherwise);
          }
          outputDefined() {
            return this.branches.every((c) => {
              let [u, p] = c;
              return p.outputDefined();
            }) && this.otherwise.outputDefined();
          }
        }
        class Sa {
          constructor(c, u, p, _) {
            this.type = c, this.input = u, this.beginIndex = p, this.endIndex = _;
          }
          static parse(c, u) {
            if (c.length <= 2 || c.length >= 5) return u.error(`Expected 3 or 4 arguments, but found ${c.length - 1} instead.`);
            const p = u.parse(c[1], 1, Xr), _ = u.parse(c[2], 2, rr);
            if (!p || !_) return null;
            if (!Ha(p.type, [ys(Xr), Vr, Xr])) return u.error(`Expected first argument to be of type array or string, but found ${ti(p.type)} instead`);
            if (c.length === 4) {
              const x = u.parse(c[3], 3, rr);
              return x ? new Sa(p.type, p, _, x) : null;
            }
            return new Sa(p.type, p, _);
          }
          evaluate(c) {
            const u = this.input.evaluate(c), p = this.beginIndex.evaluate(c);
            let _;
            if (this.endIndex && (_ = this.endIndex.evaluate(c)), Wa(u, ["string"])) return [...u].slice(p, _).join("");
            if (Wa(u, ["array"])) return u.slice(p, _);
            throw new jn(`Expected first argument to be of type array or string, but found ${ti(Or(u))} instead.`);
          }
          eachChild(c) {
            c(this.input), c(this.beginIndex), this.endIndex && c(this.endIndex);
          }
          outputDefined() {
            return !1;
          }
        }
        function Al(f, c) {
          const u = f.length - 1;
          let p, _, x = 0, T = u, I = 0;
          for (; x <= T; ) if (I = Math.floor((x + T) / 2), p = f[I], _ = f[I + 1], p <= c) {
            if (I === u || c < _) return I;
            x = I + 1;
          } else {
            if (!(p > c)) throw new jn("Input is not a number.");
            T = I - 1;
          }
          return 0;
        }
        class Ea {
          constructor(c, u, p) {
            this.type = c, this.input = u, this.labels = [], this.outputs = [];
            for (const [_, x] of p) this.labels.push(_), this.outputs.push(x);
          }
          static parse(c, u) {
            if (c.length - 1 < 4) return u.error(`Expected at least 4 arguments, but found only ${c.length - 1}.`);
            if ((c.length - 1) % 2 != 0) return u.error("Expected an even number of arguments.");
            const p = u.parse(c[1], 1, rr);
            if (!p) return null;
            const _ = [];
            let x = null;
            u.expectedType && u.expectedType.kind !== "value" && (x = u.expectedType);
            for (let T = 1; T < c.length; T += 2) {
              const I = T === 1 ? -1 / 0 : c[T], B = c[T + 1], N = T, z = T + 1;
              if (typeof I != "number") return u.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', N);
              if (_.length && _[_.length - 1][0] >= I) return u.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', N);
              const $ = u.parse(B, z, x);
              if (!$) return null;
              x = x || $.type, _.push([I, $]);
            }
            return new Ea(x, p, _);
          }
          evaluate(c) {
            const u = this.labels, p = this.outputs;
            if (u.length === 1) return p[0].evaluate(c);
            const _ = this.input.evaluate(c);
            if (_ <= u[0]) return p[0].evaluate(c);
            const x = u.length;
            return _ >= u[x - 1] ? p[x - 1].evaluate(c) : p[Al(u, _)].evaluate(c);
          }
          eachChild(c) {
            c(this.input);
            for (const u of this.outputs) c(u);
          }
          outputDefined() {
            return this.outputs.every((c) => c.outputDefined());
          }
        }
        function Iu(f) {
          return f && f.__esModule && Object.prototype.hasOwnProperty.call(f, "default") ? f.default : f;
        }
        var aa, Ca, Hl = function() {
          if (Ca) return aa;
          function f(c, u, p, _) {
            this.cx = 3 * c, this.bx = 3 * (p - c) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * u, this.by = 3 * (_ - u) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = c, this.p1y = u, this.p2x = p, this.p2y = _;
          }
          return Ca = 1, aa = f, f.prototype = { sampleCurveX: function(c) {
            return ((this.ax * c + this.bx) * c + this.cx) * c;
          }, sampleCurveY: function(c) {
            return ((this.ay * c + this.by) * c + this.cy) * c;
          }, sampleCurveDerivativeX: function(c) {
            return (3 * this.ax * c + 2 * this.bx) * c + this.cx;
          }, solveCurveX: function(c, u) {
            if (u === void 0 && (u = 1e-6), c < 0) return 0;
            if (c > 1) return 1;
            for (var p = c, _ = 0; _ < 8; _++) {
              var x = this.sampleCurveX(p) - c;
              if (Math.abs(x) < u) return p;
              var T = this.sampleCurveDerivativeX(p);
              if (Math.abs(T) < 1e-6) break;
              p -= x / T;
            }
            var I = 0, B = 1;
            for (p = c, _ = 0; _ < 20 && (x = this.sampleCurveX(p), !(Math.abs(x - c) < u)); _++) c > x ? I = p : B = p, p = 0.5 * (B - I) + I;
            return p;
          }, solve: function(c, u) {
            return this.sampleCurveY(this.solveCurveX(c, u));
          } }, aa;
        }(), Mu = Iu(Hl);
        class is {
          constructor(c, u, p, _, x) {
            this.type = c, this.operator = u, this.interpolation = p, this.input = _, this.labels = [], this.outputs = [];
            for (const [T, I] of x) this.labels.push(T), this.outputs.push(I);
          }
          static interpolationFactor(c, u, p, _) {
            let x = 0;
            if (c.name === "exponential") x = Tl(u, c.base, p, _);
            else if (c.name === "linear") x = Tl(u, 1, p, _);
            else if (c.name === "cubic-bezier") {
              const T = c.controlPoints;
              x = new Mu(T[0], T[1], T[2], T[3]).solve(Tl(u, 1, p, _));
            }
            return x;
          }
          static parse(c, u) {
            let [p, _, x, ...T] = c;
            if (!Array.isArray(_) || _.length === 0) return u.error("Expected an interpolation type expression.", 1);
            if (_[0] === "linear") _ = { name: "linear" };
            else if (_[0] === "exponential") {
              const N = _[1];
              if (typeof N != "number") return u.error("Exponential interpolation requires a numeric base.", 1, 1);
              _ = { name: "exponential", base: N };
            } else {
              if (_[0] !== "cubic-bezier") return u.error(`Unknown interpolation type ${String(_[0])}`, 1, 0);
              {
                const N = _.slice(1);
                if (N.length !== 4 || N.some((z) => typeof z != "number" || z < 0 || z > 1)) return u.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                _ = { name: "cubic-bezier", controlPoints: N };
              }
            }
            if (c.length - 1 < 4) return u.error(`Expected at least 4 arguments, but found only ${c.length - 1}.`);
            if ((c.length - 1) % 2 != 0) return u.error("Expected an even number of arguments.");
            if (x = u.parse(x, 2, rr), !x) return null;
            const I = [];
            let B = null;
            p !== "interpolate-hcl" && p !== "interpolate-lab" || u.expectedType == Vl ? u.expectedType && u.expectedType.kind !== "value" && (B = u.expectedType) : B = Hi;
            for (let N = 0; N < T.length; N += 2) {
              const z = T[N], $ = T[N + 1], J = N + 3, te = N + 4;
              if (typeof z != "number") return u.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', J);
              if (I.length && I[I.length - 1][0] >= z) return u.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', J);
              const ne = u.parse($, te, B);
              if (!ne) return null;
              B = B || ne.type, I.push([z, ne]);
            }
            return Hn(B, rr) || Hn(B, Ga) || Hn(B, Hi) || Hn(B, bi) || Hn(B, xa) || Hn(B, Vl) || Hn(B, $l) || Hn(B, ys(rr)) ? new is(B, p, _, x, I) : u.error(`Type ${ti(B)} is not interpolatable.`);
          }
          evaluate(c) {
            const u = this.labels, p = this.outputs;
            if (u.length === 1) return p[0].evaluate(c);
            const _ = this.input.evaluate(c);
            if (_ <= u[0]) return p[0].evaluate(c);
            const x = u.length;
            if (_ >= u[x - 1]) return p[x - 1].evaluate(c);
            const T = Al(u, _), I = is.interpolationFactor(this.interpolation, _, u[T], u[T + 1]), B = p[T].evaluate(c), N = p[T + 1].evaluate(c);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return qs(B, N, I);
                  case "color":
                    return hn.interpolate(B, N, I);
                  case "padding":
                    return zn.interpolate(B, N, I);
                  case "colorArray":
                    return Ni.interpolate(B, N, I);
                  case "numberArray":
                    return Wi.interpolate(B, N, I);
                  case "variableAnchorOffsetCollection":
                    return pn.interpolate(B, N, I);
                  case "array":
                    return hi(B, N, I);
                  case "projectionDefinition":
                    return Wr.interpolate(B, N, I);
                }
              case "interpolate-hcl":
                switch (this.type.kind) {
                  case "color":
                    return hn.interpolate(B, N, I, "hcl");
                  case "colorArray":
                    return Ni.interpolate(B, N, I, "hcl");
                }
              case "interpolate-lab":
                switch (this.type.kind) {
                  case "color":
                    return hn.interpolate(B, N, I, "lab");
                  case "colorArray":
                    return Ni.interpolate(B, N, I, "lab");
                }
            }
          }
          eachChild(c) {
            c(this.input);
            for (const u of this.outputs) c(u);
          }
          outputDefined() {
            return this.outputs.every((c) => c.outputDefined());
          }
        }
        function Tl(f, c, u, p) {
          const _ = p - u, x = f - u;
          return _ === 0 ? 0 : c === 1 ? x / _ : (Math.pow(c, x) - 1) / (Math.pow(c, _) - 1);
        }
        const ss = { color: hn.interpolate, number: qs, padding: zn.interpolate, numberArray: Wi.interpolate, colorArray: Ni.interpolate, variableAnchorOffsetCollection: pn.interpolate, array: hi };
        class ji {
          constructor(c, u) {
            this.type = c, this.args = u;
          }
          static parse(c, u) {
            if (c.length < 2) return u.error("Expected at least one argument.");
            let p = null;
            const _ = u.expectedType;
            _ && _.kind !== "value" && (p = _);
            const x = [];
            for (const I of c.slice(1)) {
              const B = u.parse(I, 1 + x.length, p, void 0, { typeAnnotation: "omit" });
              if (!B) return null;
              p = p || B.type, x.push(B);
            }
            if (!p) throw new Error("No output type");
            const T = _ && x.some((I) => ql(_, I.type));
            return new ji(T ? Xr : p, x);
          }
          evaluate(c) {
            let u, p = null, _ = 0;
            for (const x of this.args) if (_++, p = x.evaluate(c), p && p instanceof Ps && !p.available && (u || (u = p.name), p = null, _ === this.args.length && (p = u)), p !== null) break;
            return p;
          }
          eachChild(c) {
            this.args.forEach(c);
          }
          outputDefined() {
            return this.args.every((c) => c.outputDefined());
          }
        }
        function Wl(f, c) {
          return f === "==" || f === "!=" ? c.kind === "boolean" || c.kind === "string" || c.kind === "number" || c.kind === "null" || c.kind === "value" : c.kind === "string" || c.kind === "number" || c.kind === "value";
        }
        function Lo(f, c, u, p) {
          return p.compare(c, u) === 0;
        }
        function Ia(f, c, u) {
          const p = f !== "==" && f !== "!=";
          return class OE {
            constructor(x, T, I) {
              this.type = Gr, this.lhs = x, this.rhs = T, this.collator = I, this.hasUntypedArgument = x.type.kind === "value" || T.type.kind === "value";
            }
            static parse(x, T) {
              if (x.length !== 3 && x.length !== 4) return T.error("Expected two or three arguments.");
              const I = x[0];
              let B = T.parse(x[1], 1, Xr);
              if (!B) return null;
              if (!Wl(I, B.type)) return T.concat(1).error(`"${I}" comparisons are not supported for type '${ti(B.type)}'.`);
              let N = T.parse(x[2], 2, Xr);
              if (!N) return null;
              if (!Wl(I, N.type)) return T.concat(2).error(`"${I}" comparisons are not supported for type '${ti(N.type)}'.`);
              if (B.type.kind !== N.type.kind && B.type.kind !== "value" && N.type.kind !== "value") return T.error(`Cannot compare types '${ti(B.type)}' and '${ti(N.type)}'.`);
              p && (B.type.kind === "value" && N.type.kind !== "value" ? B = new bs(N.type, [B]) : B.type.kind !== "value" && N.type.kind === "value" && (N = new bs(B.type, [N])));
              let z = null;
              if (x.length === 4) {
                if (B.type.kind !== "string" && N.type.kind !== "string" && B.type.kind !== "value" && N.type.kind !== "value") return T.error("Cannot use collator to compare non-string types.");
                if (z = T.parse(x[3], 3, io), !z) return null;
              }
              return new OE(B, N, z);
            }
            evaluate(x) {
              const T = this.lhs.evaluate(x), I = this.rhs.evaluate(x);
              if (p && this.hasUntypedArgument) {
                const B = Or(T), N = Or(I);
                if (B.kind !== N.kind || B.kind !== "string" && B.kind !== "number") throw new jn(`Expected arguments for "${f}" to be (string, string) or (number, number), but found (${B.kind}, ${N.kind}) instead.`);
              }
              if (this.collator && !p && this.hasUntypedArgument) {
                const B = Or(T), N = Or(I);
                if (B.kind !== "string" || N.kind !== "string") return c(x, T, I);
              }
              return this.collator ? u(x, T, I, this.collator.evaluate(x)) : c(x, T, I);
            }
            eachChild(x) {
              x(this.lhs), x(this.rhs), this.collator && x(this.collator);
            }
            outputDefined() {
              return !0;
            }
          };
        }
        const O = Ia("==", function(f, c, u) {
          return c === u;
        }, Lo), ae = Ia("!=", function(f, c, u) {
          return c !== u;
        }, function(f, c, u, p) {
          return !Lo(0, c, u, p);
        }), Ue = Ia("<", function(f, c, u) {
          return c < u;
        }, function(f, c, u, p) {
          return p.compare(c, u) < 0;
        }), tt = Ia(">", function(f, c, u) {
          return c > u;
        }, function(f, c, u, p) {
          return p.compare(c, u) > 0;
        }), mt = Ia("<=", function(f, c, u) {
          return c <= u;
        }, function(f, c, u, p) {
          return p.compare(c, u) <= 0;
        }), jt = Ia(">=", function(f, c, u) {
          return c >= u;
        }, function(f, c, u, p) {
          return p.compare(c, u) >= 0;
        });
        class Jt {
          constructor(c, u, p) {
            this.type = io, this.locale = p, this.caseSensitive = c, this.diacriticSensitive = u;
          }
          static parse(c, u) {
            if (c.length !== 2) return u.error("Expected one argument.");
            const p = c[1];
            if (typeof p != "object" || Array.isArray(p)) return u.error("Collator options argument must be an object.");
            const _ = u.parse(p["case-sensitive"] !== void 0 && p["case-sensitive"], 1, Gr);
            if (!_) return null;
            const x = u.parse(p["diacritic-sensitive"] !== void 0 && p["diacritic-sensitive"], 1, Gr);
            if (!x) return null;
            let T = null;
            return p.locale && (T = u.parse(p.locale, 1, Vr), !T) ? null : new Jt(_, x, T);
          }
          evaluate(c) {
            return new xl(this.caseSensitive.evaluate(c), this.diacriticSensitive.evaluate(c), this.locale ? this.locale.evaluate(c) : null);
          }
          eachChild(c) {
            c(this.caseSensitive), c(this.diacriticSensitive), this.locale && c(this.locale);
          }
          outputDefined() {
            return !1;
          }
        }
        class wr {
          constructor(c, u, p, _, x) {
            this.type = Vr, this.number = c, this.locale = u, this.currency = p, this.minFractionDigits = _, this.maxFractionDigits = x;
          }
          static parse(c, u) {
            if (c.length !== 3) return u.error("Expected two arguments.");
            const p = u.parse(c[1], 1, rr);
            if (!p) return null;
            const _ = c[2];
            if (typeof _ != "object" || Array.isArray(_)) return u.error("NumberFormat options argument must be an object.");
            let x = null;
            if (_.locale && (x = u.parse(_.locale, 1, Vr), !x)) return null;
            let T = null;
            if (_.currency && (T = u.parse(_.currency, 1, Vr), !T)) return null;
            let I = null;
            if (_["min-fraction-digits"] && (I = u.parse(_["min-fraction-digits"], 1, rr), !I)) return null;
            let B = null;
            return _["max-fraction-digits"] && (B = u.parse(_["max-fraction-digits"], 1, rr), !B) ? null : new wr(p, x, T, I, B);
          }
          evaluate(c) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(c) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(c) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(c) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(c) : void 0 }).format(this.number.evaluate(c));
          }
          eachChild(c) {
            c(this.number), this.locale && c(this.locale), this.currency && c(this.currency), this.minFractionDigits && c(this.minFractionDigits), this.maxFractionDigits && c(this.maxFractionDigits);
          }
          outputDefined() {
            return !1;
          }
        }
        class Fr {
          constructor(c) {
            this.type = va, this.sections = c;
          }
          static parse(c, u) {
            if (c.length < 2) return u.error("Expected at least one argument.");
            const p = c[1];
            if (!Array.isArray(p) && typeof p == "object") return u.error("First argument must be an image or text section.");
            const _ = [];
            let x = !1;
            for (let T = 1; T <= c.length - 1; ++T) {
              const I = c[T];
              if (x && typeof I == "object" && !Array.isArray(I)) {
                x = !1;
                let B = null;
                if (I["font-scale"] && (B = u.parse(I["font-scale"], 1, rr), !B)) return null;
                let N = null;
                if (I["text-font"] && (N = u.parse(I["text-font"], 1, ys(Vr)), !N)) return null;
                let z = null;
                if (I["text-color"] && (z = u.parse(I["text-color"], 1, Hi), !z)) return null;
                let $ = null;
                if (I["vertical-align"]) {
                  if (typeof I["vertical-align"] == "string" && !Zr.includes(I["vertical-align"])) return u.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${I["vertical-align"]}' instead.`);
                  if ($ = u.parse(I["vertical-align"], 1, Vr), !$) return null;
                }
                const J = _[_.length - 1];
                J.scale = B, J.font = N, J.textColor = z, J.verticalAlign = $;
              } else {
                const B = u.parse(c[T], 1, Xr);
                if (!B) return null;
                const N = B.type.kind;
                if (N !== "string" && N !== "value" && N !== "null" && N !== "resolvedImage") return u.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                x = !0, _.push({ content: B, scale: null, font: null, textColor: null, verticalAlign: null });
              }
            }
            return new Fr(_);
          }
          evaluate(c) {
            return new ns(this.sections.map((u) => {
              const p = u.content.evaluate(c);
              return Or(p) === Po ? new Su("", p, null, null, null, u.verticalAlign ? u.verticalAlign.evaluate(c) : null) : new Su(Za(p), null, u.scale ? u.scale.evaluate(c) : null, u.font ? u.font.evaluate(c).join(",") : null, u.textColor ? u.textColor.evaluate(c) : null, u.verticalAlign ? u.verticalAlign.evaluate(c) : null);
            }));
          }
          eachChild(c) {
            for (const u of this.sections) c(u.content), u.scale && c(u.scale), u.font && c(u.font), u.textColor && c(u.textColor), u.verticalAlign && c(u.verticalAlign);
          }
          outputDefined() {
            return !1;
          }
        }
        class sn {
          constructor(c) {
            this.type = Po, this.input = c;
          }
          static parse(c, u) {
            if (c.length !== 2) return u.error("Expected two arguments.");
            const p = u.parse(c[1], 1, Vr);
            return p ? new sn(p) : u.error("No image name provided.");
          }
          evaluate(c) {
            const u = this.input.evaluate(c), p = Ps.fromString(u);
            return p && c.availableImages && (p.available = c.availableImages.indexOf(u) > -1), p;
          }
          eachChild(c) {
            c(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        class Qr {
          constructor(c) {
            this.type = rr, this.input = c;
          }
          static parse(c, u) {
            if (c.length !== 2) return u.error(`Expected 1 argument, but found ${c.length - 1} instead.`);
            const p = u.parse(c[1], 1);
            return p ? p.type.kind !== "array" && p.type.kind !== "string" && p.type.kind !== "value" ? u.error(`Expected argument of type string or array, but found ${ti(p.type)} instead.`) : new Qr(p) : null;
          }
          evaluate(c) {
            const u = this.input.evaluate(c);
            if (typeof u == "string") return [...u].length;
            if (Array.isArray(u)) return u.length;
            throw new jn(`Expected value to be of type string or array, but found ${ti(Or(u))} instead.`);
          }
          eachChild(c) {
            c(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        const ln = 8192;
        function vi(f, c) {
          const u = (180 + f[0]) / 360, p = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + f[1] * Math.PI / 360))) / 360, _ = Math.pow(2, c.z);
          return [Math.round(u * _ * ln), Math.round(p * _ * ln)];
        }
        function xi(f, c) {
          const u = Math.pow(2, c.z);
          return [(_ = (f[0] / ln + c.x) / u, 360 * _ - 180), (p = (f[1] / ln + c.y) / u, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * p) * Math.PI / 180)) - 90)];
          var p, _;
        }
        function fi(f, c) {
          f[0] = Math.min(f[0], c[0]), f[1] = Math.min(f[1], c[1]), f[2] = Math.max(f[2], c[0]), f[3] = Math.max(f[3], c[1]);
        }
        function Vi(f, c) {
          return !(f[0] <= c[0] || f[2] >= c[2] || f[1] <= c[1] || f[3] >= c[3]);
        }
        function Xi(f, c, u) {
          const p = f[0] - c[0], _ = f[1] - c[1], x = f[0] - u[0], T = f[1] - u[1];
          return p * T - x * _ == 0 && p * x <= 0 && _ * T <= 0;
        }
        function Gs(f, c, u, p) {
          return (_ = [p[0] - u[0], p[1] - u[1]])[0] * (x = [c[0] - f[0], c[1] - f[1]])[1] - _[1] * x[0] != 0 && !(!Ka(f, c, u, p) || !Ka(u, p, f, c));
          var _, x;
        }
        function Ao(f, c, u) {
          for (const p of u) for (let _ = 0; _ < p.length - 1; ++_) if (Gs(f, c, p[_], p[_ + 1])) return !0;
          return !1;
        }
        function Hs(f, c) {
          let u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, p = !1;
          for (const I of c) for (let B = 0; B < I.length - 1; B++) {
            if (Xi(f, I[B], I[B + 1])) return u;
            (x = I[B])[1] > (_ = f)[1] != (T = I[B + 1])[1] > _[1] && _[0] < (T[0] - x[0]) * (_[1] - x[1]) / (T[1] - x[1]) + x[0] && (p = !p);
          }
          var _, x, T;
          return p;
        }
        function oh(f, c) {
          for (const u of c) if (Hs(f, u)) return !0;
          return !1;
        }
        function jc(f, c) {
          for (const u of f) if (!Hs(u, c)) return !1;
          for (let u = 0; u < f.length - 1; ++u) if (Ao(f[u], f[u + 1], c)) return !1;
          return !0;
        }
        function Pu(f, c) {
          for (const u of c) if (jc(f, u)) return !0;
          return !1;
        }
        function Ka(f, c, u, p) {
          const _ = p[0] - u[0], x = p[1] - u[1], T = (f[0] - u[0]) * x - _ * (f[1] - u[1]), I = (c[0] - u[0]) * x - _ * (c[1] - u[1]);
          return T > 0 && I < 0 || T < 0 && I > 0;
        }
        function Xl(f, c, u) {
          const p = [];
          for (let _ = 0; _ < f.length; _++) {
            const x = [];
            for (let T = 0; T < f[_].length; T++) {
              const I = vi(f[_][T], u);
              fi(c, I), x.push(I);
            }
            p.push(x);
          }
          return p;
        }
        function Vc(f, c, u) {
          const p = [];
          for (let _ = 0; _ < f.length; _++) {
            const x = Xl(f[_], c, u);
            p.push(x);
          }
          return p;
        }
        function Zl(f, c, u, p) {
          if (f[0] < u[0] || f[0] > u[2]) {
            const _ = 0.5 * p;
            let x = f[0] - u[0] > _ ? -p : u[0] - f[0] > _ ? p : 0;
            x === 0 && (x = f[0] - u[2] > _ ? -p : u[2] - f[0] > _ ? p : 0), f[0] += x;
          }
          fi(c, f);
        }
        function Zi(f, c, u, p) {
          const _ = Math.pow(2, p.z) * ln, x = [p.x * ln, p.y * ln], T = [];
          for (const I of f) for (const B of I) {
            const N = [B.x + x[0], B.y + x[1]];
            Zl(N, c, u, _), T.push(N);
          }
          return T;
        }
        function Sl(f, c, u, p) {
          const _ = Math.pow(2, p.z) * ln, x = [p.x * ln, p.y * ln], T = [];
          for (const B of f) {
            const N = [];
            for (const z of B) {
              const $ = [z.x + x[0], z.y + x[1]];
              fi(c, $), N.push($);
            }
            T.push(N);
          }
          if (c[2] - c[0] <= _ / 2) {
            (I = c)[0] = I[1] = 1 / 0, I[2] = I[3] = -1 / 0;
            for (const B of T) for (const N of B) Zl(N, c, u, _);
          }
          var I;
          return T;
        }
        class Oo {
          constructor(c, u) {
            this.type = Gr, this.geojson = c, this.geometries = u;
          }
          static parse(c, u) {
            if (c.length !== 2) return u.error(`'within' expression requires exactly one argument, but found ${c.length - 1} instead.`);
            if (bo(c[1])) {
              const p = c[1];
              if (p.type === "FeatureCollection") {
                const _ = [];
                for (const x of p.features) {
                  const { type: T, coordinates: I } = x.geometry;
                  T === "Polygon" && _.push(I), T === "MultiPolygon" && _.push(...I);
                }
                if (_.length) return new Oo(p, { type: "MultiPolygon", coordinates: _ });
              } else if (p.type === "Feature") {
                const _ = p.geometry.type;
                if (_ === "Polygon" || _ === "MultiPolygon") return new Oo(p, p.geometry);
              } else if (p.type === "Polygon" || p.type === "MultiPolygon") return new Oo(p, p);
            }
            return u.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(c) {
            if (c.geometry() != null && c.canonicalID() != null) {
              if (c.geometryType() === "Point") return function(u, p) {
                const _ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], x = [1 / 0, 1 / 0, -1 / 0, -1 / 0], T = u.canonicalID();
                if (p.type === "Polygon") {
                  const I = Xl(p.coordinates, x, T), B = Zi(u.geometry(), _, x, T);
                  if (!Vi(_, x)) return !1;
                  for (const N of B) if (!Hs(N, I)) return !1;
                }
                if (p.type === "MultiPolygon") {
                  const I = Vc(p.coordinates, x, T), B = Zi(u.geometry(), _, x, T);
                  if (!Vi(_, x)) return !1;
                  for (const N of B) if (!oh(N, I)) return !1;
                }
                return !0;
              }(c, this.geometries);
              if (c.geometryType() === "LineString") return function(u, p) {
                const _ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], x = [1 / 0, 1 / 0, -1 / 0, -1 / 0], T = u.canonicalID();
                if (p.type === "Polygon") {
                  const I = Xl(p.coordinates, x, T), B = Sl(u.geometry(), _, x, T);
                  if (!Vi(_, x)) return !1;
                  for (const N of B) if (!jc(N, I)) return !1;
                }
                if (p.type === "MultiPolygon") {
                  const I = Vc(p.coordinates, x, T), B = Sl(u.geometry(), _, x, T);
                  if (!Vi(_, x)) return !1;
                  for (const N of B) if (!Pu(N, I)) return !1;
                }
                return !0;
              }(c, this.geometries);
            }
            return !1;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        let Yl = class {
          constructor() {
            let f = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (u, p) => u < p ? -1 : u > p ? 1 : 0;
            if (this.data = f, this.length = this.data.length, this.compare = c, this.length > 0) for (let u = (this.length >> 1) - 1; u >= 0; u--) this._down(u);
          }
          push(f) {
            this.data.push(f), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const f = this.data[0], c = this.data.pop();
            return --this.length > 0 && (this.data[0] = c, this._down(0)), f;
          }
          peek() {
            return this.data[0];
          }
          _up(f) {
            const { data: c, compare: u } = this, p = c[f];
            for (; f > 0; ) {
              const _ = f - 1 >> 1, x = c[_];
              if (u(p, x) >= 0) break;
              c[f] = x, f = _;
            }
            c[f] = p;
          }
          _down(f) {
            const { data: c, compare: u } = this, p = this.length >> 1, _ = c[f];
            for (; f < p; ) {
              let x = 1 + (f << 1);
              const T = x + 1;
              if (T < this.length && u(c[T], c[x]) < 0 && (x = T), u(c[x], _) >= 0) break;
              c[f] = c[x], f = x;
            }
            c[f] = _;
          }
        };
        function Kl(f, c) {
          let u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, p = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : f.length - 1, _ = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : Jh;
          for (; p > u; ) {
            if (p - u > 600) {
              const B = p - u + 1, N = c - u + 1, z = Math.log(B), $ = 0.5 * Math.exp(2 * z / 3), J = 0.5 * Math.sqrt(z * $ * (B - $) / B) * (N - B / 2 < 0 ? -1 : 1);
              Kl(f, c, Math.max(u, Math.floor(c - N * $ / B + J)), Math.min(p, Math.floor(c + (B - N) * $ / B + J)), _);
            }
            const x = f[c];
            let T = u, I = p;
            for (Yi(f, u, c), _(f[p], x) > 0 && Yi(f, u, p); T < I; ) {
              for (Yi(f, T, I), T++, I--; _(f[T], x) < 0; ) T++;
              for (; _(f[I], x) > 0; ) I--;
            }
            _(f[u], x) === 0 ? Yi(f, u, I) : (I++, Yi(f, I, p)), I <= c && (u = I + 1), c <= I && (p = I - 1);
          }
        }
        function Yi(f, c, u) {
          const p = f[c];
          f[c] = f[u], f[u] = p;
        }
        function Jh(f, c) {
          return f < c ? -1 : f > c ? 1 : 0;
        }
        function El(f, c) {
          if (f.length <= 1) return [f];
          const u = [];
          let p, _;
          for (const x of f) {
            const T = To(x);
            T !== 0 && (x.area = Math.abs(T), _ === void 0 && (_ = T < 0), _ === T < 0 ? (p && u.push(p), p = [x]) : p.push(x));
          }
          if (p && u.push(p), c > 1) for (let x = 0; x < u.length; x++) u[x].length <= c || (Kl(u[x], c, 1, u[x].length - 1, ah), u[x] = u[x].slice(0, c));
          return u;
        }
        function ah(f, c) {
          return c.area - f.area;
        }
        function To(f) {
          let c = 0;
          for (let u, p, _ = 0, x = f.length, T = x - 1; _ < x; T = _++) u = f[_], p = f[T], c += (p.x - u.x) * (u.y + p.y);
          return c;
        }
        const Jl = 1 / 298.257223563, Ru = Jl * (2 - Jl), Bu = Math.PI / 180;
        class Ma {
          constructor(c) {
            const u = 6378.137 * Bu * 1e3, p = Math.cos(c * Bu), _ = 1 / (1 - Ru * (1 - p * p)), x = Math.sqrt(_);
            this.kx = u * x * p, this.ky = u * x * _ * (1 - Ru);
          }
          distance(c, u) {
            const p = this.wrap(c[0] - u[0]) * this.kx, _ = (c[1] - u[1]) * this.ky;
            return Math.sqrt(p * p + _ * _);
          }
          pointOnLine(c, u) {
            let p, _, x, T, I = 1 / 0;
            for (let B = 0; B < c.length - 1; B++) {
              let N = c[B][0], z = c[B][1], $ = this.wrap(c[B + 1][0] - N) * this.kx, J = (c[B + 1][1] - z) * this.ky, te = 0;
              $ === 0 && J === 0 || (te = (this.wrap(u[0] - N) * this.kx * $ + (u[1] - z) * this.ky * J) / ($ * $ + J * J), te > 1 ? (N = c[B + 1][0], z = c[B + 1][1]) : te > 0 && (N += $ / this.kx * te, z += J / this.ky * te)), $ = this.wrap(u[0] - N) * this.kx, J = (u[1] - z) * this.ky;
              const ne = $ * $ + J * J;
              ne < I && (I = ne, p = N, _ = z, x = B, T = te);
            }
            return { point: [p, _], index: x, t: Math.max(0, Math.min(1, T)) };
          }
          wrap(c) {
            for (; c < -180; ) c += 360;
            for (; c > 180; ) c -= 360;
            return c;
          }
        }
        function mn(f, c) {
          return c[0] - f[0];
        }
        function vs(f) {
          return f[1] - f[0] + 1;
        }
        function wi(f, c) {
          return f[1] >= f[0] && f[1] < c;
        }
        function Pa(f, c) {
          if (f[0] > f[1]) return [null, null];
          const u = vs(f);
          if (c) {
            if (u === 2) return [f, null];
            const _ = Math.floor(u / 2);
            return [[f[0], f[0] + _], [f[0] + _, f[1]]];
          }
          if (u === 1) return [f, null];
          const p = Math.floor(u / 2) - 1;
          return [[f[0], f[0] + p], [f[0] + p + 1, f[1]]];
        }
        function la(f, c) {
          if (!wi(c, f.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const u = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let p = c[0]; p <= c[1]; ++p) fi(u, f[p]);
          return u;
        }
        function ca(f) {
          const c = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const u of f) for (const p of u) fi(c, p);
          return c;
        }
        function Ql(f) {
          return f[0] !== -1 / 0 && f[1] !== -1 / 0 && f[2] !== 1 / 0 && f[3] !== 1 / 0;
        }
        function ua(f, c, u) {
          if (!Ql(f) || !Ql(c)) return NaN;
          let p = 0, _ = 0;
          return f[2] < c[0] && (p = c[0] - f[2]), f[0] > c[2] && (p = f[0] - c[2]), f[1] > c[3] && (_ = f[1] - c[3]), f[3] < c[1] && (_ = c[1] - f[3]), u.distance([0, 0], [p, _]);
        }
        function Zn(f, c, u) {
          const p = u.pointOnLine(c, f);
          return u.distance(f, p.point);
        }
        function ec(f, c, u, p, _) {
          const x = Math.min(Zn(f, [u, p], _), Zn(c, [u, p], _)), T = Math.min(Zn(u, [f, c], _), Zn(p, [f, c], _));
          return Math.min(x, T);
        }
        function Ws(f, c, u, p, _) {
          if (!wi(c, f.length) || !wi(p, u.length)) return 1 / 0;
          let x = 1 / 0;
          for (let T = c[0]; T < c[1]; ++T) {
            const I = f[T], B = f[T + 1];
            for (let N = p[0]; N < p[1]; ++N) {
              const z = u[N], $ = u[N + 1];
              if (Gs(I, B, z, $)) return 0;
              x = Math.min(x, ec(I, B, z, $, _));
            }
          }
          return x;
        }
        function ko(f, c, u, p, _) {
          if (!wi(c, f.length) || !wi(p, u.length)) return NaN;
          let x = 1 / 0;
          for (let T = c[0]; T <= c[1]; ++T) for (let I = p[0]; I <= p[1]; ++I) if (x = Math.min(x, _.distance(f[T], u[I])), x === 0) return x;
          return x;
        }
        function $c(f, c, u) {
          if (Hs(f, c, !0)) return 0;
          let p = 1 / 0;
          for (const _ of c) {
            const x = _[0], T = _[_.length - 1];
            if (x !== T && (p = Math.min(p, Zn(f, [T, x], u)), p === 0)) return p;
            const I = u.pointOnLine(_, f);
            if (p = Math.min(p, u.distance(f, I.point)), p === 0) return p;
          }
          return p;
        }
        function lh(f, c, u, p) {
          if (!wi(c, f.length)) return NaN;
          for (let x = c[0]; x <= c[1]; ++x) if (Hs(f[x], u, !0)) return 0;
          let _ = 1 / 0;
          for (let x = c[0]; x < c[1]; ++x) {
            const T = f[x], I = f[x + 1];
            for (const B of u) for (let N = 0, z = B.length, $ = z - 1; N < z; $ = N++) {
              const J = B[$], te = B[N];
              if (Gs(T, I, J, te)) return 0;
              _ = Math.min(_, ec(T, I, J, te, p));
            }
          }
          return _;
        }
        function qc(f, c) {
          for (const u of f) for (const p of u) if (Hs(p, c, !0)) return !0;
          return !1;
        }
        function tc(f, c, u) {
          let p = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1 / 0;
          const _ = ca(f), x = ca(c);
          if (p !== 1 / 0 && ua(_, x, u) >= p) return p;
          if (Vi(_, x)) {
            if (qc(f, c)) return 0;
          } else if (qc(c, f)) return 0;
          let T = 1 / 0;
          for (const I of f) for (let B = 0, N = I.length, z = N - 1; B < N; z = B++) {
            const $ = I[z], J = I[B];
            for (const te of c) for (let ne = 0, ue = te.length, Se = ue - 1; ne < ue; Se = ne++) {
              const Ee = te[Se], Je = te[ne];
              if (Gs($, J, Ee, Je)) return 0;
              T = Math.min(T, ec($, J, Ee, Je, u));
            }
          }
          return T;
        }
        function Cl(f, c, u, p, _, x) {
          if (!x) return;
          const T = ua(la(p, x), _, u);
          T < c && f.push([T, x, [0, 0]]);
        }
        function ha(f, c, u, p, _, x, T) {
          if (!x || !T) return;
          const I = ua(la(p, x), la(_, T), u);
          I < c && f.push([I, x, T]);
        }
        function Ra(f, c, u, p) {
          let _ = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1 / 0, x = Math.min(p.distance(f[0], u[0][0]), _);
          if (x === 0) return x;
          const T = new Yl([[0, [0, f.length - 1], [0, 0]]], mn), I = ca(u);
          for (; T.length > 0; ) {
            const B = T.pop();
            if (B[0] >= x) continue;
            const N = B[1], z = c ? 50 : 100;
            if (vs(N) <= z) {
              if (!wi(N, f.length)) return NaN;
              if (c) {
                const $ = lh(f, N, u, p);
                if (isNaN($) || $ === 0) return $;
                x = Math.min(x, $);
              } else for (let $ = N[0]; $ <= N[1]; ++$) {
                const J = $c(f[$], u, p);
                if (x = Math.min(x, J), x === 0) return 0;
              }
            } else {
              const $ = Pa(N, c);
              Cl(T, x, p, f, I, $[0]), Cl(T, x, p, f, I, $[1]);
            }
          }
          return x;
        }
        function Ja(f, c, u, p, _) {
          let x = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1 / 0, T = Math.min(x, _.distance(f[0], u[0]));
          if (T === 0) return T;
          const I = new Yl([[0, [0, f.length - 1], [0, u.length - 1]]], mn);
          for (; I.length > 0; ) {
            const B = I.pop();
            if (B[0] >= T) continue;
            const N = B[1], z = B[2], $ = c ? 50 : 100, J = p ? 50 : 100;
            if (vs(N) <= $ && vs(z) <= J) {
              if (!wi(N, f.length) && wi(z, u.length)) return NaN;
              let te;
              if (c && p) te = Ws(f, N, u, z, _), T = Math.min(T, te);
              else if (c && !p) {
                const ne = f.slice(N[0], N[1] + 1);
                for (let ue = z[0]; ue <= z[1]; ++ue) if (te = Zn(u[ue], ne, _), T = Math.min(T, te), T === 0) return T;
              } else if (!c && p) {
                const ne = u.slice(z[0], z[1] + 1);
                for (let ue = N[0]; ue <= N[1]; ++ue) if (te = Zn(f[ue], ne, _), T = Math.min(T, te), T === 0) return T;
              } else te = ko(f, N, u, z, _), T = Math.min(T, te);
            } else {
              const te = Pa(N, c), ne = Pa(z, p);
              ha(I, T, _, f, u, te[0], ne[0]), ha(I, T, _, f, u, te[0], ne[1]), ha(I, T, _, f, u, te[1], ne[0]), ha(I, T, _, f, u, te[1], ne[1]);
            }
          }
          return T;
        }
        function Qa(f) {
          return f.type === "MultiPolygon" ? f.coordinates.map((c) => ({ type: "Polygon", coordinates: c })) : f.type === "MultiLineString" ? f.coordinates.map((c) => ({ type: "LineString", coordinates: c })) : f.type === "MultiPoint" ? f.coordinates.map((c) => ({ type: "Point", coordinates: c })) : [f];
        }
        class lo {
          constructor(c, u) {
            this.type = rr, this.geojson = c, this.geometries = u;
          }
          static parse(c, u) {
            if (c.length !== 2) return u.error(`'distance' expression requires exactly one argument, but found ${c.length - 1} instead.`);
            if (bo(c[1])) {
              const p = c[1];
              if (p.type === "FeatureCollection") return new lo(p, p.features.map((_) => Qa(_.geometry)).flat());
              if (p.type === "Feature") return new lo(p, Qa(p.geometry));
              if ("type" in p && "coordinates" in p) return new lo(p, Qa(p));
            }
            return u.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(c) {
            if (c.geometry() != null && c.canonicalID() != null) {
              if (c.geometryType() === "Point") return function(u, p) {
                const _ = u.geometry(), x = _.flat().map((B) => xi([B.x, B.y], u.canonical));
                if (_.length === 0) return NaN;
                const T = new Ma(x[0][1]);
                let I = 1 / 0;
                for (const B of p) {
                  switch (B.type) {
                    case "Point":
                      I = Math.min(I, Ja(x, !1, [B.coordinates], !1, T, I));
                      break;
                    case "LineString":
                      I = Math.min(I, Ja(x, !1, B.coordinates, !0, T, I));
                      break;
                    case "Polygon":
                      I = Math.min(I, Ra(x, !1, B.coordinates, T, I));
                  }
                  if (I === 0) return I;
                }
                return I;
              }(c, this.geometries);
              if (c.geometryType() === "LineString") return function(u, p) {
                const _ = u.geometry(), x = _.flat().map((B) => xi([B.x, B.y], u.canonical));
                if (_.length === 0) return NaN;
                const T = new Ma(x[0][1]);
                let I = 1 / 0;
                for (const B of p) {
                  switch (B.type) {
                    case "Point":
                      I = Math.min(I, Ja(x, !0, [B.coordinates], !1, T, I));
                      break;
                    case "LineString":
                      I = Math.min(I, Ja(x, !0, B.coordinates, !0, T, I));
                      break;
                    case "Polygon":
                      I = Math.min(I, Ra(x, !0, B.coordinates, T, I));
                  }
                  if (I === 0) return I;
                }
                return I;
              }(c, this.geometries);
              if (c.geometryType() === "Polygon") return function(u, p) {
                const _ = u.geometry();
                if (_.length === 0 || _[0].length === 0) return NaN;
                const x = El(_, 0).map((B) => B.map((N) => N.map((z) => xi([z.x, z.y], u.canonical)))), T = new Ma(x[0][0][0][1]);
                let I = 1 / 0;
                for (const B of p) for (const N of x) {
                  switch (B.type) {
                    case "Point":
                      I = Math.min(I, Ra([B.coordinates], !1, N, T, I));
                      break;
                    case "LineString":
                      I = Math.min(I, Ra(B.coordinates, !0, N, T, I));
                      break;
                    case "Polygon":
                      I = Math.min(I, tc(N, B.coordinates, T, I));
                  }
                  if (I === 0) return I;
                }
                return I;
              }(c, this.geometries);
            }
            return NaN;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        class el {
          constructor(c) {
            this.type = Xr, this.key = c;
          }
          static parse(c, u) {
            if (c.length !== 2) return u.error(`Expected 1 argument, but found ${c.length - 1} instead.`);
            const p = c[1];
            return p == null ? u.error("Global state property must be defined.") : typeof p != "string" ? u.error(`Global state property must be string, but found ${typeof c[1]} instead.`) : new el(p);
          }
          evaluate(c) {
            var u;
            const p = (u = c.globals) === null || u === void 0 ? void 0 : u.globalState;
            return p && Object.keys(p).length !== 0 ? un(p, this.key) : null;
          }
          eachChild() {
          }
          outputDefined() {
            return !1;
          }
        }
        const xs = { "==": O, "!=": ae, ">": tt, "<": Ue, ">=": jt, "<=": mt, array: bs, at: ai, boolean: bs, case: Ri, coalesce: ji, collator: Jt, format: Fr, image: sn, in: Rs, "index-of": Ya, interpolate: is, "interpolate-hcl": is, "interpolate-lab": is, length: Qr, let: xo, literal: Di, match: Bo, number: bs, "number-format": wr, object: bs, slice: Sa, step: Ea, string: bs, "to-boolean": vo, "to-color": vo, "to-number": vo, "to-string": vo, var: wo, within: Oo, distance: lo, "global-state": el };
        class Ai {
          constructor(c, u, p, _) {
            this.name = c, this.type = u, this._evaluate = p, this.args = _;
          }
          evaluate(c) {
            return this._evaluate(c, this.args);
          }
          eachChild(c) {
            this.args.forEach(c);
          }
          outputDefined() {
            return !1;
          }
          static parse(c, u) {
            const p = c[0], _ = Ai.definitions[p];
            if (!_) return u.error(`Unknown expression "${p}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const x = Array.isArray(_) ? _[0] : _.type, T = Array.isArray(_) ? [[_[1], _[2]]] : _.overloads, I = T.filter((N) => {
              let [z] = N;
              return !Array.isArray(z) || z.length === c.length - 1;
            });
            let B = null;
            for (const [N, z] of I) {
              B = new ao(u.registry, No, u.path, null, u.scope);
              const $ = [];
              let J = !1;
              for (let te = 1; te < c.length; te++) {
                const ne = c[te], ue = Array.isArray(N) ? N[te - 1] : N.type, Se = B.parse(ne, 1 + $.length, ue);
                if (!Se) {
                  J = !0;
                  break;
                }
                $.push(Se);
              }
              if (!J) if (Array.isArray(N) && N.length !== $.length) B.error(`Expected ${N.length} arguments, but found ${$.length} instead.`);
              else {
                for (let te = 0; te < $.length; te++) {
                  const ne = Array.isArray(N) ? N[te] : N.type, ue = $[te];
                  B.concat(te + 1).checkSubtype(ne, ue.type);
                }
                if (B.errors.length === 0) return new Ai(p, x, z, $);
              }
            }
            if (I.length === 1) u.errors.push(...B.errors);
            else {
              const N = (I.length ? I : T).map(($) => {
                let [J] = $;
                return te = J, Array.isArray(te) ? `(${te.map(ti).join(", ")})` : `(${ti(te.type)}...)`;
                var te;
              }).join(" | "), z = [];
              for (let $ = 1; $ < c.length; $++) {
                const J = u.parse(c[$], 1 + z.length);
                if (!J) return null;
                z.push(ti(J.type));
              }
              u.error(`Expected arguments of type ${N}, but found (${z.join(", ")}) instead.`);
            }
            return null;
          }
          static register(c, u) {
            Ai.definitions = u;
            for (const p in u) c[p] = Ai;
          }
        }
        function Yn(f, c) {
          let [u, p, _, x] = c;
          u = u.evaluate(f), p = p.evaluate(f), _ = _.evaluate(f);
          const T = x ? x.evaluate(f) : 1, I = Yr(u, p, _, T);
          if (I) throw new jn(I);
          return new hn(u / 255, p / 255, _ / 255, T, !1);
        }
        function Kn(f, c) {
          return f in c;
        }
        function Ti(f, c) {
          const u = c[f];
          return u === void 0 ? null : u;
        }
        function li(f) {
          return { type: f };
        }
        function No(f) {
          if (f instanceof wo) return No(f.boundExpression);
          if (f instanceof Ai && f.name === "error" || f instanceof Jt || f instanceof Oo || f instanceof lo || f instanceof el) return !1;
          const c = f instanceof vo || f instanceof bs;
          let u = !0;
          return f.eachChild((p) => {
            u = c ? u && No(p) : u && p instanceof Di;
          }), !!u && Il(f) && tl(f, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"]);
        }
        function Il(f) {
          if (f instanceof Ai && (f.name === "get" && f.args.length === 1 || f.name === "feature-state" || f.name === "has" && f.args.length === 1 || f.name === "properties" || f.name === "geometry-type" || f.name === "id" || /^filter-/.test(f.name)) || f instanceof Oo || f instanceof lo) return !1;
          let c = !0;
          return f.eachChild((u) => {
            c && !Il(u) && (c = !1);
          }), c;
        }
        function Ba(f) {
          if (f instanceof Ai && f.name === "feature-state") return !1;
          let c = !0;
          return f.eachChild((u) => {
            c && !Ba(u) && (c = !1);
          }), c;
        }
        function tl(f, c) {
          if (f instanceof Ai && c.indexOf(f.name) >= 0) return !1;
          let u = !0;
          return f.eachChild((p) => {
            u && !tl(p, c) && (u = !1);
          }), u;
        }
        function ch(f) {
          return { result: "success", value: f };
        }
        function rl(f) {
          return { result: "error", value: f };
        }
        function os(f) {
          return f["property-type"] === "data-driven" || f["property-type"] === "cross-faded-data-driven";
        }
        function co(f) {
          return !!f.expression && f.expression.parameters.indexOf("zoom") > -1;
        }
        function Gc(f) {
          return !!f.expression && f.expression.interpolated;
        }
        function cn(f) {
          return f instanceof Number ? "number" : f instanceof String ? "string" : f instanceof Boolean ? "boolean" : Array.isArray(f) ? "array" : f === null ? "null" : typeof f;
        }
        function Ml(f) {
          return typeof f == "object" && f !== null && !Array.isArray(f) && Or(f) === Vs;
        }
        function Lu(f) {
          return f;
        }
        function Ou(f, c) {
          const u = f.stops && typeof f.stops[0][0] == "object", p = u || !(u || f.property !== void 0), _ = f.type || (Gc(c) ? "exponential" : "interval"), x = function(z) {
            switch (z.type) {
              case "color":
                return hn.parse;
              case "padding":
                return zn.parse;
              case "numberArray":
                return Wi.parse;
              case "colorArray":
                return Ni.parse;
              default:
                return null;
            }
          }(c);
          if (x && ((f = oi({}, f)).stops && (f.stops = f.stops.map((z) => [z[0], x(z[1])])), f.default = x(f.default ? f.default : c.default)), f.colorSpace && (T = f.colorSpace) !== "rgb" && T !== "hcl" && T !== "lab") throw new Error(`Unknown color space: "${f.colorSpace}"`);
          var T;
          const I = function(z) {
            switch (z) {
              case "exponential":
                return uh;
              case "interval":
                return Qh;
              case "categorical":
                return Jf;
              case "identity":
                return ku;
              default:
                throw new Error(`Unknown function type "${z}"`);
            }
          }(_);
          let B, N;
          if (_ === "categorical") {
            B = /* @__PURE__ */ Object.create(null);
            for (const z of f.stops) B[z[0]] = z[1];
            N = typeof f.stops[0][0];
          }
          if (u) {
            const z = {}, $ = [];
            for (let ne = 0; ne < f.stops.length; ne++) {
              const ue = f.stops[ne], Se = ue[0].zoom;
              z[Se] === void 0 && (z[Se] = { zoom: Se, type: f.type, property: f.property, default: f.default, stops: [] }, $.push(Se)), z[Se].stops.push([ue[0].value, ue[1]]);
            }
            const J = [];
            for (const ne of $) J.push([z[ne].zoom, Ou(z[ne], c)]);
            const te = { name: "linear" };
            return { kind: "composite", interpolationType: te, interpolationFactor: is.interpolationFactor.bind(void 0, te), zoomStops: J.map((ne) => ne[0]), evaluate: (ne, ue) => {
              let { zoom: Se } = ne;
              return uh({ stops: J, base: f.base }, c, Se).evaluate(Se, ue);
            } };
          }
          if (p) {
            const z = _ === "exponential" ? { name: "exponential", base: f.base !== void 0 ? f.base : 1 } : null;
            return { kind: "camera", interpolationType: z, interpolationFactor: is.interpolationFactor.bind(void 0, z), zoomStops: f.stops.map(($) => $[0]), evaluate: ($) => {
              let { zoom: J } = $;
              return I(f, c, J, B, N);
            } };
          }
          return { kind: "source", evaluate(z, $) {
            const J = $ && $.properties ? $.properties[f.property] : void 0;
            return J === void 0 ? rc(f.default, c.default) : I(f, c, J, B, N);
          } };
        }
        function rc(f, c, u) {
          return f !== void 0 ? f : c !== void 0 ? c : u !== void 0 ? u : void 0;
        }
        function Jf(f, c, u, p, _) {
          return rc(typeof u === _ ? p[u] : void 0, f.default, c.default);
        }
        function Qh(f, c, u) {
          if (cn(u) !== "number") return rc(f.default, c.default);
          const p = f.stops.length;
          if (p === 1 || u <= f.stops[0][0]) return f.stops[0][1];
          if (u >= f.stops[p - 1][0]) return f.stops[p - 1][1];
          const _ = Al(f.stops.map((x) => x[0]), u);
          return f.stops[_][1];
        }
        function uh(f, c, u) {
          const p = f.base !== void 0 ? f.base : 1;
          if (cn(u) !== "number") return rc(f.default, c.default);
          const _ = f.stops.length;
          if (_ === 1 || u <= f.stops[0][0]) return f.stops[0][1];
          if (u >= f.stops[_ - 1][0]) return f.stops[_ - 1][1];
          const x = Al(f.stops.map((z) => z[0]), u), T = function(z, $, J, te) {
            const ne = te - J, ue = z - J;
            return ne === 0 ? 0 : $ === 1 ? ue / ne : (Math.pow($, ue) - 1) / (Math.pow($, ne) - 1);
          }(u, p, f.stops[x][0], f.stops[x + 1][0]), I = f.stops[x][1], B = f.stops[x + 1][1], N = ss[c.type] || Lu;
          return typeof I.evaluate == "function" ? { evaluate() {
            for (var z = arguments.length, $ = new Array(z), J = 0; J < z; J++)
              $[J] = arguments[J];
            const te = I.evaluate.apply(void 0, $), ne = B.evaluate.apply(void 0, $);
            if (te !== void 0 && ne !== void 0) return N(te, ne, T, f.colorSpace);
          } } : N(I, B, T, f.colorSpace);
        }
        function ku(f, c, u) {
          switch (c.type) {
            case "color":
              u = hn.parse(u);
              break;
            case "formatted":
              u = ns.fromString(u.toString());
              break;
            case "resolvedImage":
              u = Ps.fromString(u.toString());
              break;
            case "padding":
              u = zn.parse(u);
              break;
            case "colorArray":
              u = Ni.parse(u);
              break;
            case "numberArray":
              u = Wi.parse(u);
              break;
            default:
              cn(u) === c.type || c.type === "enum" && c.values[u] || (u = void 0);
          }
          return rc(u, f.default, c.default);
        }
        Ai.register(xs, { error: [{ kind: "error" }, [Vr], (f, c) => {
          let [u] = c;
          throw new jn(u.evaluate(f));
        }], typeof: [Vr, [Xr], (f, c) => {
          let [u] = c;
          return ti(Or(u.evaluate(f)));
        }], "to-rgba": [ys(rr, 4), [Hi], (f, c) => {
          let [u] = c;
          const [p, _, x, T] = u.evaluate(f).rgb;
          return [255 * p, 255 * _, 255 * x, T];
        }], rgb: [Hi, [rr, rr, rr], Yn], rgba: [Hi, [rr, rr, rr, rr], Yn], has: { type: Gr, overloads: [[[Vr], (f, c) => {
          let [u] = c;
          return Kn(u.evaluate(f), f.properties());
        }], [[Vr, Vs], (f, c) => {
          let [u, p] = c;
          return Kn(u.evaluate(f), p.evaluate(f));
        }]] }, get: { type: Xr, overloads: [[[Vr], (f, c) => {
          let [u] = c;
          return Ti(u.evaluate(f), f.properties());
        }], [[Vr, Vs], (f, c) => {
          let [u, p] = c;
          return Ti(u.evaluate(f), p.evaluate(f));
        }]] }, "feature-state": [Xr, [Vr], (f, c) => {
          let [u] = c;
          return Ti(u.evaluate(f), f.featureState || {});
        }], properties: [Vs, [], (f) => f.properties()], "geometry-type": [Vr, [], (f) => f.geometryType()], id: [Xr, [], (f) => f.id()], zoom: [rr, [], (f) => f.globals.zoom], "heatmap-density": [rr, [], (f) => f.globals.heatmapDensity || 0], elevation: [rr, [], (f) => f.globals.elevation || 0], "line-progress": [rr, [], (f) => f.globals.lineProgress || 0], accumulated: [Xr, [], (f) => f.globals.accumulated === void 0 ? null : f.globals.accumulated], "+": [rr, li(rr), (f, c) => {
          let u = 0;
          for (const p of c) u += p.evaluate(f);
          return u;
        }], "*": [rr, li(rr), (f, c) => {
          let u = 1;
          for (const p of c) u *= p.evaluate(f);
          return u;
        }], "-": { type: rr, overloads: [[[rr, rr], (f, c) => {
          let [u, p] = c;
          return u.evaluate(f) - p.evaluate(f);
        }], [[rr], (f, c) => {
          let [u] = c;
          return -u.evaluate(f);
        }]] }, "/": [rr, [rr, rr], (f, c) => {
          let [u, p] = c;
          return u.evaluate(f) / p.evaluate(f);
        }], "%": [rr, [rr, rr], (f, c) => {
          let [u, p] = c;
          return u.evaluate(f) % p.evaluate(f);
        }], ln2: [rr, [], () => Math.LN2], pi: [rr, [], () => Math.PI], e: [rr, [], () => Math.E], "^": [rr, [rr, rr], (f, c) => {
          let [u, p] = c;
          return Math.pow(u.evaluate(f), p.evaluate(f));
        }], sqrt: [rr, [rr], (f, c) => {
          let [u] = c;
          return Math.sqrt(u.evaluate(f));
        }], log10: [rr, [rr], (f, c) => {
          let [u] = c;
          return Math.log(u.evaluate(f)) / Math.LN10;
        }], ln: [rr, [rr], (f, c) => {
          let [u] = c;
          return Math.log(u.evaluate(f));
        }], log2: [rr, [rr], (f, c) => {
          let [u] = c;
          return Math.log(u.evaluate(f)) / Math.LN2;
        }], sin: [rr, [rr], (f, c) => {
          let [u] = c;
          return Math.sin(u.evaluate(f));
        }], cos: [rr, [rr], (f, c) => {
          let [u] = c;
          return Math.cos(u.evaluate(f));
        }], tan: [rr, [rr], (f, c) => {
          let [u] = c;
          return Math.tan(u.evaluate(f));
        }], asin: [rr, [rr], (f, c) => {
          let [u] = c;
          return Math.asin(u.evaluate(f));
        }], acos: [rr, [rr], (f, c) => {
          let [u] = c;
          return Math.acos(u.evaluate(f));
        }], atan: [rr, [rr], (f, c) => {
          let [u] = c;
          return Math.atan(u.evaluate(f));
        }], min: [rr, li(rr), (f, c) => Math.min(...c.map((u) => u.evaluate(f)))], max: [rr, li(rr), (f, c) => Math.max(...c.map((u) => u.evaluate(f)))], abs: [rr, [rr], (f, c) => {
          let [u] = c;
          return Math.abs(u.evaluate(f));
        }], round: [rr, [rr], (f, c) => {
          let [u] = c;
          const p = u.evaluate(f);
          return p < 0 ? -Math.round(-p) : Math.round(p);
        }], floor: [rr, [rr], (f, c) => {
          let [u] = c;
          return Math.floor(u.evaluate(f));
        }], ceil: [rr, [rr], (f, c) => {
          let [u] = c;
          return Math.ceil(u.evaluate(f));
        }], "filter-==": [Gr, [Vr, Xr], (f, c) => {
          let [u, p] = c;
          return f.properties()[u.value] === p.value;
        }], "filter-id-==": [Gr, [Xr], (f, c) => {
          let [u] = c;
          return f.id() === u.value;
        }], "filter-type-==": [Gr, [Vr], (f, c) => {
          let [u] = c;
          return f.geometryType() === u.value;
        }], "filter-<": [Gr, [Vr, Xr], (f, c) => {
          let [u, p] = c;
          const _ = f.properties()[u.value], x = p.value;
          return typeof _ == typeof x && _ < x;
        }], "filter-id-<": [Gr, [Xr], (f, c) => {
          let [u] = c;
          const p = f.id(), _ = u.value;
          return typeof p == typeof _ && p < _;
        }], "filter->": [Gr, [Vr, Xr], (f, c) => {
          let [u, p] = c;
          const _ = f.properties()[u.value], x = p.value;
          return typeof _ == typeof x && _ > x;
        }], "filter-id->": [Gr, [Xr], (f, c) => {
          let [u] = c;
          const p = f.id(), _ = u.value;
          return typeof p == typeof _ && p > _;
        }], "filter-<=": [Gr, [Vr, Xr], (f, c) => {
          let [u, p] = c;
          const _ = f.properties()[u.value], x = p.value;
          return typeof _ == typeof x && _ <= x;
        }], "filter-id-<=": [Gr, [Xr], (f, c) => {
          let [u] = c;
          const p = f.id(), _ = u.value;
          return typeof p == typeof _ && p <= _;
        }], "filter->=": [Gr, [Vr, Xr], (f, c) => {
          let [u, p] = c;
          const _ = f.properties()[u.value], x = p.value;
          return typeof _ == typeof x && _ >= x;
        }], "filter-id->=": [Gr, [Xr], (f, c) => {
          let [u] = c;
          const p = f.id(), _ = u.value;
          return typeof p == typeof _ && p >= _;
        }], "filter-has": [Gr, [Xr], (f, c) => {
          let [u] = c;
          return u.value in f.properties();
        }], "filter-has-id": [Gr, [], (f) => f.id() !== null && f.id() !== void 0], "filter-type-in": [Gr, [ys(Vr)], (f, c) => {
          let [u] = c;
          return u.value.indexOf(f.geometryType()) >= 0;
        }], "filter-id-in": [Gr, [ys(Xr)], (f, c) => {
          let [u] = c;
          return u.value.indexOf(f.id()) >= 0;
        }], "filter-in-small": [Gr, [Vr, ys(Xr)], (f, c) => {
          let [u, p] = c;
          return p.value.indexOf(f.properties()[u.value]) >= 0;
        }], "filter-in-large": [Gr, [Vr, ys(Xr)], (f, c) => {
          let [u, p] = c;
          return function(_, x, T, I) {
            for (; T <= I; ) {
              const B = T + I >> 1;
              if (x[B] === _) return !0;
              x[B] > _ ? I = B - 1 : T = B + 1;
            }
            return !1;
          }(f.properties()[u.value], p.value, 0, p.value.length - 1);
        }], all: { type: Gr, overloads: [[[Gr, Gr], (f, c) => {
          let [u, p] = c;
          return u.evaluate(f) && p.evaluate(f);
        }], [li(Gr), (f, c) => {
          for (const u of c) if (!u.evaluate(f)) return !1;
          return !0;
        }]] }, any: { type: Gr, overloads: [[[Gr, Gr], (f, c) => {
          let [u, p] = c;
          return u.evaluate(f) || p.evaluate(f);
        }], [li(Gr), (f, c) => {
          for (const u of c) if (u.evaluate(f)) return !0;
          return !1;
        }]] }, "!": [Gr, [Gr], (f, c) => {
          let [u] = c;
          return !u.evaluate(f);
        }], "is-supported-script": [Gr, [Vr], (f, c) => {
          let [u] = c;
          const p = f.globals && f.globals.isSupportedScript;
          return !p || p(u.evaluate(f));
        }], upcase: [Vr, [Vr], (f, c) => {
          let [u] = c;
          return u.evaluate(f).toUpperCase();
        }], downcase: [Vr, [Vr], (f, c) => {
          let [u] = c;
          return u.evaluate(f).toLowerCase();
        }], concat: [Vr, li(Xr), (f, c) => c.map((u) => Za(u.evaluate(f))).join("")], "resolved-locale": [Vr, [io], (f, c) => {
          let [u] = c;
          return u.evaluate(f).resolvedLocale();
        }] });
        class Hc {
          constructor(c, u) {
            this.expression = c, this._warningHistory = {}, this._evaluator = new Cu(), this._defaultValue = u ? function(p) {
              if (p.type === "color" && Ml(p.default)) return new hn(0, 0, 0, 0);
              switch (p.type) {
                case "color":
                  return hn.parse(p.default) || null;
                case "padding":
                  return zn.parse(p.default) || null;
                case "numberArray":
                  return Wi.parse(p.default) || null;
                case "colorArray":
                  return Ni.parse(p.default) || null;
                case "variableAnchorOffsetCollection":
                  return pn.parse(p.default) || null;
                case "projectionDefinition":
                  return Wr.parse(p.default) || null;
                default:
                  return p.default === void 0 ? null : p.default;
              }
            }(u) : null, this._enumValues = u && u.type === "enum" ? u.values : null;
          }
          evaluateWithoutErrorHandling(c, u, p, _, x, T) {
            return this._evaluator.globals = c, this._evaluator.feature = u, this._evaluator.featureState = p, this._evaluator.canonical = _, this._evaluator.availableImages = x || null, this._evaluator.formattedSection = T, this.expression.evaluate(this._evaluator);
          }
          evaluate(c, u, p, _, x, T) {
            this._evaluator.globals = c, this._evaluator.feature = u || null, this._evaluator.featureState = p || null, this._evaluator.canonical = _, this._evaluator.availableImages = x || null, this._evaluator.formattedSection = T || null;
            try {
              const I = this.expression.evaluate(this._evaluator);
              if (I == null || typeof I == "number" && I != I) return this._defaultValue;
              if (this._enumValues && !(I in this._enumValues)) throw new jn(`Expected value to be one of ${Object.keys(this._enumValues).map((B) => JSON.stringify(B)).join(", ")}, but found ${JSON.stringify(I)} instead.`);
              return I;
            } catch (I) {
              return this._warningHistory[I.message] || (this._warningHistory[I.message] = !0, typeof console < "u" && console.warn(I.message)), this._defaultValue;
            }
          }
        }
        function hh(f) {
          return Array.isArray(f) && f.length > 0 && typeof f[0] == "string" && f[0] in xs;
        }
        function fh(f, c) {
          const u = new ao(xs, No, [], c ? function(_) {
            const x = { color: Hi, string: Vr, number: rr, enum: Vr, boolean: Gr, formatted: va, padding: bi, numberArray: xa, colorArray: Vl, projectionDefinition: Ga, resolvedImage: Po, variableAnchorOffsetCollection: $l };
            return _.type === "array" ? ys(x[_.value] || Xr, _.length) : x[_.type];
          }(c) : void 0), p = u.parse(f, void 0, void 0, void 0, c && c.type === "string" ? { typeAnnotation: "coerce" } : void 0);
          return p ? ch(new Hc(p, c)) : rl(u.errors);
        }
        class Wc {
          constructor(c, u) {
            this.kind = c, this._styleExpression = u, this.isStateDependent = c !== "constant" && !Ba(u.expression), this.globalStateRefs = Zc(u.expression);
          }
          evaluateWithoutErrorHandling(c, u, p, _, x, T) {
            return this._styleExpression.evaluateWithoutErrorHandling(c, u, p, _, x, T);
          }
          evaluate(c, u, p, _, x, T) {
            return this._styleExpression.evaluate(c, u, p, _, x, T);
          }
        }
        class dh {
          constructor(c, u, p, _) {
            this.kind = c, this.zoomStops = p, this._styleExpression = u, this.isStateDependent = c !== "camera" && !Ba(u.expression), this.globalStateRefs = Zc(u.expression), this.interpolationType = _;
          }
          evaluateWithoutErrorHandling(c, u, p, _, x, T) {
            return this._styleExpression.evaluateWithoutErrorHandling(c, u, p, _, x, T);
          }
          evaluate(c, u, p, _, x, T) {
            return this._styleExpression.evaluate(c, u, p, _, x, T);
          }
          interpolationFactor(c, u, p) {
            return this.interpolationType ? is.interpolationFactor(this.interpolationType, c, u, p) : 0;
          }
        }
        function ef(f, c) {
          const u = fh(f, c);
          if (u.result === "error") return u;
          const p = u.value.expression, _ = Il(p);
          if (!_ && !os(c)) return rl([new Mn("", "data expressions not supported")]);
          const x = tl(p, ["zoom"]);
          if (!x && !co(c)) return rl([new Mn("", "zoom expressions not supported")]);
          const T = Xc(p);
          return T || x ? T instanceof Mn ? rl([T]) : T instanceof is && !Gc(c) ? rl([new Mn("", '"interpolate" expressions cannot be used with this property')]) : ch(T ? new dh(_ ? "camera" : "composite", u.value, T.labels, T instanceof is ? T.interpolation : void 0) : new Wc(_ ? "constant" : "source", u.value)) : rl([new Mn("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class Nu {
          constructor(c, u) {
            this._parameters = c, this._specification = u, oi(this, Ou(this._parameters, this._specification));
          }
          static deserialize(c) {
            return new Nu(c._parameters, c._specification);
          }
          static serialize(c) {
            return { _parameters: c._parameters, _specification: c._specification };
          }
        }
        function Xc(f) {
          let c = null;
          if (f instanceof xo) c = Xc(f.result);
          else if (f instanceof ji) {
            for (const u of f.args) if (c = Xc(u), c) break;
          } else (f instanceof Ea || f instanceof is) && f.input instanceof Ai && f.input.name === "zoom" && (c = f);
          return c instanceof Mn || f.eachChild((u) => {
            const p = Xc(u);
            p instanceof Mn ? c = p : !c && p ? c = new Mn("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : c && p && c !== p && (c = new Mn("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          }), c;
        }
        function Zc(f) {
          let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /* @__PURE__ */ new Set();
          return f instanceof el && c.add(f.key), f.eachChild((u) => {
            Zc(u, c);
          }), c;
        }
        function nc(f) {
          if (f === !0 || f === !1) return !0;
          if (!Array.isArray(f) || f.length === 0) return !1;
          switch (f[0]) {
            case "has":
              return f.length >= 2 && f[1] !== "$id" && f[1] !== "$type";
            case "in":
              return f.length >= 3 && (typeof f[1] != "string" || Array.isArray(f[2]));
            case "!in":
            case "!has":
            case "none":
              return !1;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return f.length !== 3 || Array.isArray(f[1]) || Array.isArray(f[2]);
            case "any":
            case "all":
              for (const c of f.slice(1)) if (!nc(c) && typeof c != "boolean") return !1;
              return !0;
            default:
              return !0;
          }
        }
        const Du = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } };
        function Do(f) {
          if (f == null) return { filter: () => !0, needGeometry: !1, getGlobalStateRefs: () => /* @__PURE__ */ new Set() };
          nc(f) || (f = Fu(f));
          const c = fh(f, Du);
          if (c.result === "error") throw new Error(c.value.map((u) => `${u.key}: ${u.message}`).join(", "));
          return { filter: (u, p, _) => c.value.evaluate(u, p, {}, _), needGeometry: Qf(f), getGlobalStateRefs: () => Zc(c.value.expression) };
        }
        function Ap(f, c) {
          return f < c ? -1 : f > c ? 1 : 0;
        }
        function Qf(f) {
          if (!Array.isArray(f)) return !1;
          if (f[0] === "within" || f[0] === "distance") return !0;
          for (let c = 1; c < f.length; c++) if (Qf(f[c])) return !0;
          return !1;
        }
        function Fu(f) {
          if (!f) return !0;
          const c = f[0];
          return f.length <= 1 ? c !== "any" : c === "==" ? tf(f[1], f[2], "==") : c === "!=" ? Uu(tf(f[1], f[2], "==")) : c === "<" || c === ">" || c === "<=" || c === ">=" ? tf(f[1], f[2], c) : c === "any" ? (u = f.slice(1), ["any"].concat(u.map(Fu))) : c === "all" ? ["all"].concat(f.slice(1).map(Fu)) : c === "none" ? ["all"].concat(f.slice(1).map(Fu).map(Uu)) : c === "in" ? ed(f[1], f.slice(2)) : c === "!in" ? Uu(ed(f[1], f.slice(2))) : c === "has" ? td(f[1]) : c !== "!has" || Uu(td(f[1]));
          var u;
        }
        function tf(f, c, u) {
          switch (f) {
            case "$type":
              return [`filter-type-${u}`, c];
            case "$id":
              return [`filter-id-${u}`, c];
            default:
              return [`filter-${u}`, f, c];
          }
        }
        function ed(f, c) {
          if (c.length === 0) return !1;
          switch (f) {
            case "$type":
              return ["filter-type-in", ["literal", c]];
            case "$id":
              return ["filter-id-in", ["literal", c]];
            default:
              return c.length > 200 && !c.some((u) => typeof u != typeof c[0]) ? ["filter-in-large", f, ["literal", c.sort(Ap)]] : ["filter-in-small", f, ["literal", c]];
          }
        }
        function td(f) {
          switch (f) {
            case "$type":
              return !0;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", f];
          }
        }
        function Uu(f) {
          return ["!", f];
        }
        function fa(f) {
          const c = typeof f;
          if (c === "number" || c === "boolean" || c === "string" || f == null) return JSON.stringify(f);
          if (Array.isArray(f)) {
            let _ = "[";
            for (const x of f) _ += `${fa(x)},`;
            return `${_}]`;
          }
          const u = Object.keys(f).sort();
          let p = "{";
          for (let _ = 0; _ < u.length; _++) p += `${JSON.stringify(u[_])}:${fa(f[u[_]])},`;
          return `${p}}`;
        }
        function uo(f) {
          let c = "";
          for (const u of ur) c += `/${fa(f[u])}`;
          return c;
        }
        function La(f) {
          const c = f.value;
          return c ? [new er(f.key, c, "constants have been deprecated as of v8")] : [];
        }
        function Si(f) {
          return f instanceof Number || f instanceof String || f instanceof Boolean ? f.valueOf() : f;
        }
        function nl(f) {
          if (Array.isArray(f)) return f.map(nl);
          if (f instanceof Object && !(f instanceof Number || f instanceof String || f instanceof Boolean)) {
            const c = {};
            for (const u in f) c[u] = nl(f[u]);
            return c;
          }
          return Si(f);
        }
        function Ki(f) {
          const c = f.key, u = f.value, p = f.valueSpec || {}, _ = f.objectElementValidators || {}, x = f.style, T = f.styleSpec, I = f.validateSpec;
          let B = [];
          const N = cn(u);
          if (N !== "object") return [new er(c, u, `object expected, ${N} found`)];
          for (const z in u) {
            const $ = z.split(".")[0], J = un(p, $) || p["*"];
            let te;
            if (un(_, $)) te = _[$];
            else if (un(p, $)) te = I;
            else if (_["*"]) te = _["*"];
            else {
              if (!p["*"]) {
                B.push(new er(c, u[z], `unknown property "${z}"`));
                continue;
              }
              te = I;
            }
            B = B.concat(te({ key: (c && `${c}.`) + z, value: u[z], valueSpec: J, style: x, styleSpec: T, object: u, objectKey: z, validateSpec: I }, u));
          }
          for (const z in p) _[z] || p[z].required && p[z].default === void 0 && u[z] === void 0 && B.push(new er(c, u, `missing required property "${z}"`));
          return B;
        }
        function Xs(f) {
          const c = f.value, u = f.valueSpec, p = f.style, _ = f.styleSpec, x = f.key, T = f.arrayElementValidator || f.validateSpec;
          if (cn(c) !== "array") return [new er(x, c, `array expected, ${cn(c)} found`)];
          if (u.length && c.length !== u.length) return [new er(x, c, `array length ${u.length} expected, length ${c.length} found`)];
          if (u["min-length"] && c.length < u["min-length"]) return [new er(x, c, `array length at least ${u["min-length"]} expected, length ${c.length} found`)];
          let I = { type: u.value, values: u.values };
          _.$version < 7 && (I.function = u.function), cn(u.value) === "object" && (I = u.value);
          let B = [];
          for (let N = 0; N < c.length; N++) B = B.concat(T({ array: c, arrayIndex: N, value: c[N], valueSpec: I, validateSpec: f.validateSpec, style: p, styleSpec: _, key: `${x}[${N}]` }));
          return B;
        }
        function zu(f) {
          const c = f.key, u = f.value, p = f.valueSpec;
          let _ = cn(u);
          return _ === "number" && u != u && (_ = "NaN"), _ !== "number" ? [new er(c, u, `number expected, ${_} found`)] : "minimum" in p && u < p.minimum ? [new er(c, u, `${u} is less than the minimum value ${p.minimum}`)] : "maximum" in p && u > p.maximum ? [new er(c, u, `${u} is greater than the maximum value ${p.maximum}`)] : [];
        }
        function Yc(f) {
          const c = f.valueSpec, u = Si(f.value.type);
          let p, _, x, T = {};
          const I = u !== "categorical" && f.value.property === void 0, B = !I, N = cn(f.value.stops) === "array" && cn(f.value.stops[0]) === "array" && cn(f.value.stops[0][0]) === "object", z = Ki({ key: f.key, value: f.value, valueSpec: f.styleSpec.function, validateSpec: f.validateSpec, style: f.style, styleSpec: f.styleSpec, objectElementValidators: { stops: function(te) {
            if (u === "identity") return [new er(te.key, te.value, 'identity function may not have a "stops" property')];
            let ne = [];
            const ue = te.value;
            return ne = ne.concat(Xs({ key: te.key, value: ue, valueSpec: te.valueSpec, validateSpec: te.validateSpec, style: te.style, styleSpec: te.styleSpec, arrayElementValidator: $ })), cn(ue) === "array" && ue.length === 0 && ne.push(new er(te.key, ue, "array must have at least one stop")), ne;
          }, default: function(te) {
            return te.validateSpec({ key: te.key, value: te.value, valueSpec: c, validateSpec: te.validateSpec, style: te.style, styleSpec: te.styleSpec });
          } } });
          return u === "identity" && I && z.push(new er(f.key, f.value, 'missing required property "property"')), u === "identity" || f.value.stops || z.push(new er(f.key, f.value, 'missing required property "stops"')), u === "exponential" && f.valueSpec.expression && !Gc(f.valueSpec) && z.push(new er(f.key, f.value, "exponential functions not supported")), f.styleSpec.$version >= 8 && (B && !os(f.valueSpec) ? z.push(new er(f.key, f.value, "property functions not supported")) : I && !co(f.valueSpec) && z.push(new er(f.key, f.value, "zoom functions not supported"))), u !== "categorical" && !N || f.value.property !== void 0 || z.push(new er(f.key, f.value, '"property" property is required')), z;
          function $(te) {
            let ne = [];
            const ue = te.value, Se = te.key;
            if (cn(ue) !== "array") return [new er(Se, ue, `array expected, ${cn(ue)} found`)];
            if (ue.length !== 2) return [new er(Se, ue, `array length 2 expected, length ${ue.length} found`)];
            if (N) {
              if (cn(ue[0]) !== "object") return [new er(Se, ue, `object expected, ${cn(ue[0])} found`)];
              if (ue[0].zoom === void 0) return [new er(Se, ue, "object stop key must have zoom")];
              if (ue[0].value === void 0) return [new er(Se, ue, "object stop key must have value")];
              if (x && x > Si(ue[0].zoom)) return [new er(Se, ue[0].zoom, "stop zoom values must appear in ascending order")];
              Si(ue[0].zoom) !== x && (x = Si(ue[0].zoom), _ = void 0, T = {}), ne = ne.concat(Ki({ key: `${Se}[0]`, value: ue[0], valueSpec: { zoom: {} }, validateSpec: te.validateSpec, style: te.style, styleSpec: te.styleSpec, objectElementValidators: { zoom: zu, value: J } }));
            } else ne = ne.concat(J({ key: `${Se}[0]`, value: ue[0], validateSpec: te.validateSpec, style: te.style, styleSpec: te.styleSpec }, ue));
            return hh(nl(ue[1])) ? ne.concat([new er(`${Se}[1]`, ue[1], "expressions are not allowed in function stops.")]) : ne.concat(te.validateSpec({ key: `${Se}[1]`, value: ue[1], valueSpec: c, validateSpec: te.validateSpec, style: te.style, styleSpec: te.styleSpec }));
          }
          function J(te, ne) {
            const ue = cn(te.value), Se = Si(te.value), Ee = te.value !== null ? te.value : ne;
            if (p) {
              if (ue !== p) return [new er(te.key, Ee, `${ue} stop domain type must match previous stop domain type ${p}`)];
            } else p = ue;
            if (ue !== "number" && ue !== "string" && ue !== "boolean") return [new er(te.key, Ee, "stop domain value must be a number, string, or boolean")];
            if (ue !== "number" && u !== "categorical") {
              let Je = `number expected, ${ue} found`;
              return os(c) && u === void 0 && (Je += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new er(te.key, Ee, Je)];
            }
            return u !== "categorical" || ue !== "number" || isFinite(Se) && Math.floor(Se) === Se ? u !== "categorical" && ue === "number" && _ !== void 0 && Se < _ ? [new er(te.key, Ee, "stop domain values must appear in ascending order")] : (_ = Se, u === "categorical" && Se in T ? [new er(te.key, Ee, "stop domain values must be unique")] : (T[Se] = !0, [])) : [new er(te.key, Ee, `integer expected, found ${Se}`)];
          }
        }
        function ic(f) {
          const c = (f.expressionContext === "property" ? ef : fh)(nl(f.value), f.valueSpec);
          if (c.result === "error") return c.value.map((p) => new er(`${f.key}${p.key}`, f.value, p.message));
          const u = c.value.expression || c.value._styleExpression.expression;
          if (f.expressionContext === "property" && f.propertyKey === "text-font" && !u.outputDefined()) return [new er(f.key, f.value, `Invalid data expression for "${f.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (f.expressionContext === "property" && f.propertyType === "layout" && !Ba(u)) return [new er(f.key, f.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (f.expressionContext === "filter" && !Ba(u)) return [new er(f.key, f.value, '"feature-state" data expressions are not supported with filters.')];
          if (f.expressionContext && f.expressionContext.indexOf("cluster") === 0) {
            if (!tl(u, ["zoom", "feature-state"])) return [new er(f.key, f.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (f.expressionContext === "cluster-initial" && !Il(u)) return [new er(f.key, f.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function ph(f) {
          const c = f.key, u = f.value, p = cn(u);
          return p !== "string" ? [new er(c, u, `color expected, ${p} found`)] : hn.parse(String(u)) ? [] : [new er(c, u, `color expected, "${u}" found`)];
        }
        function Kc(f) {
          const c = f.key, u = f.value, p = f.valueSpec, _ = [];
          return Array.isArray(p.values) ? p.values.indexOf(Si(u)) === -1 && _.push(new er(c, u, `expected one of [${p.values.join(", ")}], ${JSON.stringify(u)} found`)) : Object.keys(p.values).indexOf(Si(u)) === -1 && _.push(new er(c, u, `expected one of [${Object.keys(p.values).join(", ")}], ${JSON.stringify(u)} found`)), _;
        }
        function gh(f) {
          return nc(nl(f.value)) ? ic(oi({}, f, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : rd(f);
        }
        function rd(f) {
          const c = f.value, u = f.key;
          if (cn(c) !== "array") return [new er(u, c, `array expected, ${cn(c)} found`)];
          const p = f.styleSpec;
          let _, x = [];
          if (c.length < 1) return [new er(u, c, "filter array must have at least 1 element")];
          switch (x = x.concat(Kc({ key: `${u}[0]`, value: c[0], valueSpec: p.filter_operator, style: f.style, styleSpec: f.styleSpec })), Si(c[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              c.length >= 2 && Si(c[1]) === "$type" && x.push(new er(u, c, `"$type" cannot be use with operator "${c[0]}"`));
            case "==":
            case "!=":
              c.length !== 3 && x.push(new er(u, c, `filter array for operator "${c[0]}" must have 3 elements`));
            case "in":
            case "!in":
              c.length >= 2 && (_ = cn(c[1]), _ !== "string" && x.push(new er(`${u}[1]`, c[1], `string expected, ${_} found`)));
              for (let T = 2; T < c.length; T++) _ = cn(c[T]), Si(c[1]) === "$type" ? x = x.concat(Kc({ key: `${u}[${T}]`, value: c[T], valueSpec: p.geometry_type, style: f.style, styleSpec: f.styleSpec })) : _ !== "string" && _ !== "number" && _ !== "boolean" && x.push(new er(`${u}[${T}]`, c[T], `string, number, or boolean expected, ${_} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let T = 1; T < c.length; T++) x = x.concat(rd({ key: `${u}[${T}]`, value: c[T], style: f.style, styleSpec: f.styleSpec }));
              break;
            case "has":
            case "!has":
              _ = cn(c[1]), c.length !== 2 ? x.push(new er(u, c, `filter array for "${c[0]}" operator must have 2 elements`)) : _ !== "string" && x.push(new er(`${u}[1]`, c[1], `string expected, ${_} found`));
          }
          return x;
        }
        function ju(f, c) {
          const u = f.key, p = f.validateSpec, _ = f.style, x = f.styleSpec, T = f.value, I = f.objectKey, B = x[`${c}_${f.layerType}`];
          if (!B) return [];
          const N = I.match(/^(.*)-transition$/);
          if (c === "paint" && N && B[N[1]] && B[N[1]].transition) return p({ key: u, value: T, valueSpec: x.transition, style: _, styleSpec: x });
          const z = f.valueSpec || B[I];
          if (!z) return [new er(u, T, `unknown property "${I}"`)];
          let $;
          if (cn(T) === "string" && os(z) && !z.tokens && ($ = /^{([^}]+)}$/.exec(T))) return [new er(u, T, `"${I}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify($[1])} }\`.`)];
          const J = [];
          return f.layerType === "symbol" && (I === "text-field" && _ && !_.glyphs && J.push(new er(u, T, 'use of "text-field" requires a style "glyphs" property')), I === "text-font" && Ml(nl(T)) && Si(T.type) === "identity" && J.push(new er(u, T, '"text-font" does not support identity functions'))), J.concat(p({ key: f.key, value: T, valueSpec: z, style: _, styleSpec: x, expressionContext: "property", propertyType: c, propertyKey: I }));
        }
        function il(f) {
          return ju(f, "paint");
        }
        function Oa(f) {
          return ju(f, "layout");
        }
        function Bs(f) {
          let c = [];
          const u = f.value, p = f.key, _ = f.style, x = f.styleSpec;
          if (cn(u) !== "object") return [new er(p, u, `object expected, ${cn(u)} found`)];
          u.type || u.ref || c.push(new er(p, u, 'either "type" or "ref" is required'));
          let T = Si(u.type);
          const I = Si(u.ref);
          if (u.id) {
            const B = Si(u.id);
            for (let N = 0; N < f.arrayIndex; N++) {
              const z = _.layers[N];
              Si(z.id) === B && c.push(new er(p, u.id, `duplicate layer id "${u.id}", previously used at line ${z.id.__line__}`));
            }
          }
          if ("ref" in u) {
            let B;
            ["type", "source", "source-layer", "filter", "layout"].forEach((N) => {
              N in u && c.push(new er(p, u[N], `"${N}" is prohibited for ref layers`));
            }), _.layers.forEach((N) => {
              Si(N.id) === I && (B = N);
            }), B ? B.ref ? c.push(new er(p, u.ref, "ref cannot reference another ref layer")) : T = Si(B.type) : c.push(new er(p, u.ref, `ref layer "${I}" not found`));
          } else if (T !== "background") if (u.source) {
            const B = _.sources && _.sources[u.source], N = B && Si(B.type);
            B ? N === "vector" && T === "raster" ? c.push(new er(p, u.source, `layer "${u.id}" requires a raster source`)) : N !== "raster-dem" && T === "hillshade" || N !== "raster-dem" && T === "color-relief" ? c.push(new er(p, u.source, `layer "${u.id}" requires a raster-dem source`)) : N === "raster" && T !== "raster" ? c.push(new er(p, u.source, `layer "${u.id}" requires a vector source`)) : N !== "vector" || u["source-layer"] ? N === "raster-dem" && T !== "hillshade" && T !== "color-relief" ? c.push(new er(p, u.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : T !== "line" || !u.paint || !u.paint["line-gradient"] || N === "geojson" && B.lineMetrics || c.push(new er(p, u, `layer "${u.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : c.push(new er(p, u, `layer "${u.id}" must specify a "source-layer"`)) : c.push(new er(p, u.source, `source "${u.source}" not found`));
          } else c.push(new er(p, u, 'missing required property "source"'));
          return c = c.concat(Ki({ key: p, value: u, valueSpec: x.layer, style: f.style, styleSpec: f.styleSpec, validateSpec: f.validateSpec, objectElementValidators: { "*": () => [], type: () => f.validateSpec({ key: `${p}.type`, value: u.type, valueSpec: x.layer.type, style: f.style, styleSpec: f.styleSpec, validateSpec: f.validateSpec, object: u, objectKey: "type" }), filter: gh, layout: (B) => Ki({ layer: u, key: B.key, value: B.value, style: B.style, styleSpec: B.styleSpec, validateSpec: B.validateSpec, objectElementValidators: { "*": (N) => Oa(oi({ layerType: T }, N)) } }), paint: (B) => Ki({ layer: u, key: B.key, value: B.value, style: B.style, styleSpec: B.styleSpec, validateSpec: B.validateSpec, objectElementValidators: { "*": (N) => il(oi({ layerType: T }, N)) } }) } })), c;
        }
        function da(f) {
          const c = f.value, u = f.key, p = cn(c);
          return p !== "string" ? [new er(u, c, `string expected, ${p} found`)] : [];
        }
        const mh = { promoteId: function(f) {
          let { key: c, value: u } = f;
          if (cn(u) === "string") return da({ key: c, value: u });
          {
            const p = [];
            for (const _ in u) p.push(...da({ key: `${c}.${_}`, value: u[_] }));
            return p;
          }
        } };
        function nd(f) {
          const c = f.value, u = f.key, p = f.styleSpec, _ = f.style, x = f.validateSpec;
          if (!c.type) return [new er(u, c, '"type" is required')];
          const T = Si(c.type);
          let I;
          switch (T) {
            case "vector":
            case "raster":
              return I = Ki({ key: u, value: c, valueSpec: p[`source_${T.replace("-", "_")}`], style: f.style, styleSpec: p, objectElementValidators: mh, validateSpec: x }), I;
            case "raster-dem":
              return I = function(B) {
                var N;
                const z = (N = B.sourceName) !== null && N !== void 0 ? N : "", $ = B.value, J = B.styleSpec, te = J.source_raster_dem, ne = B.style;
                let ue = [];
                const Se = cn($);
                if ($ === void 0) return ue;
                if (Se !== "object") return ue.push(new er("source_raster_dem", $, `object expected, ${Se} found`)), ue;
                const Ee = Si($.encoding) === "custom", Je = ["redFactor", "greenFactor", "blueFactor", "baseShift"], ze = B.value.encoding ? `"${B.value.encoding}"` : "Default";
                for (const ee in $) !Ee && Je.includes(ee) ? ue.push(new er(ee, $[ee], `In "${z}": "${ee}" is only valid when "encoding" is set to "custom". ${ze} encoding found`)) : te[ee] ? ue = ue.concat(B.validateSpec({ key: ee, value: $[ee], valueSpec: te[ee], validateSpec: B.validateSpec, style: ne, styleSpec: J })) : ue.push(new er(ee, $[ee], `unknown property "${ee}"`));
                return ue;
              }({ sourceName: u, value: c, style: f.style, styleSpec: p, validateSpec: x }), I;
            case "geojson":
              if (I = Ki({ key: u, value: c, valueSpec: p.source_geojson, style: _, styleSpec: p, validateSpec: x, objectElementValidators: mh }), c.cluster) for (const B in c.clusterProperties) {
                const [N, z] = c.clusterProperties[B], $ = typeof N == "string" ? [N, ["accumulated"], ["get", B]] : N;
                I.push(...ic({ key: `${u}.${B}.map`, value: z, expressionContext: "cluster-map" })), I.push(...ic({ key: `${u}.${B}.reduce`, value: $, expressionContext: "cluster-reduce" }));
              }
              return I;
            case "video":
              return Ki({ key: u, value: c, valueSpec: p.source_video, style: _, validateSpec: x, styleSpec: p });
            case "image":
              return Ki({ key: u, value: c, valueSpec: p.source_image, style: _, validateSpec: x, styleSpec: p });
            case "canvas":
              return [new er(u, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return Kc({ key: `${u}.type`, value: c.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } });
          }
        }
        function id(f) {
          const c = f.value, u = f.styleSpec, p = u.light, _ = f.style;
          let x = [];
          const T = cn(c);
          if (c === void 0) return x;
          if (T !== "object") return x = x.concat([new er("light", c, `object expected, ${T} found`)]), x;
          for (const I in c) {
            const B = I.match(/^(.*)-transition$/);
            x = x.concat(B && p[B[1]] && p[B[1]].transition ? f.validateSpec({ key: I, value: c[I], valueSpec: u.transition, validateSpec: f.validateSpec, style: _, styleSpec: u }) : p[I] ? f.validateSpec({ key: I, value: c[I], valueSpec: p[I], validateSpec: f.validateSpec, style: _, styleSpec: u }) : [new er(I, c[I], `unknown property "${I}"`)]);
          }
          return x;
        }
        function Jc(f) {
          const c = f.value, u = f.styleSpec, p = u.sky, _ = f.style, x = cn(c);
          if (c === void 0) return [];
          if (x !== "object") return [new er("sky", c, `object expected, ${x} found`)];
          let T = [];
          for (const I in c) T = T.concat(p[I] ? f.validateSpec({ key: I, value: c[I], valueSpec: p[I], style: _, styleSpec: u }) : [new er(I, c[I], `unknown property "${I}"`)]);
          return T;
        }
        function rf(f) {
          const c = f.value, u = f.styleSpec, p = u.terrain, _ = f.style;
          let x = [];
          const T = cn(c);
          if (c === void 0) return x;
          if (T !== "object") return x = x.concat([new er("terrain", c, `object expected, ${T} found`)]), x;
          for (const I in c) x = x.concat(p[I] ? f.validateSpec({ key: I, value: c[I], valueSpec: p[I], validateSpec: f.validateSpec, style: _, styleSpec: u }) : [new er(I, c[I], `unknown property "${I}"`)]);
          return x;
        }
        function _h(f) {
          let c = [];
          const u = f.value, p = f.key;
          if (Array.isArray(u)) {
            const _ = [], x = [];
            for (const T in u) u[T].id && _.includes(u[T].id) && c.push(new er(p, u, `all the sprites' ids must be unique, but ${u[T].id} is duplicated`)), _.push(u[T].id), u[T].url && x.includes(u[T].url) && c.push(new er(p, u, `all the sprites' URLs must be unique, but ${u[T].url} is duplicated`)), x.push(u[T].url), c = c.concat(Ki({ key: `${p}[${T}]`, value: u[T], valueSpec: { id: { type: "string", required: !0 }, url: { type: "string", required: !0 } }, validateSpec: f.validateSpec }));
            return c;
          }
          return da({ key: p, value: u });
        }
        function sd(f) {
          return c = f.value, c && c.constructor === Object ? [] : [new er(f.key, f.value, `object expected, ${cn(f.value)} found`)];
          var c;
        }
        const Vu = { "*": () => [], array: Xs, boolean: function(f) {
          const c = f.value, u = f.key, p = cn(c);
          return p !== "boolean" ? [new er(u, c, `boolean expected, ${p} found`)] : [];
        }, number: zu, color: ph, constants: La, enum: Kc, filter: gh, function: Yc, layer: Bs, object: Ki, source: nd, light: id, sky: Jc, terrain: rf, projection: function(f) {
          const c = f.value, u = f.styleSpec, p = u.projection, _ = f.style, x = cn(c);
          if (c === void 0) return [];
          if (x !== "object") return [new er("projection", c, `object expected, ${x} found`)];
          let T = [];
          for (const I in c) T = T.concat(p[I] ? f.validateSpec({ key: I, value: c[I], valueSpec: p[I], style: _, styleSpec: u }) : [new er(I, c[I], `unknown property "${I}"`)]);
          return T;
        }, projectionDefinition: function(f) {
          const c = f.key;
          let u = f.value;
          u = u instanceof String ? u.valueOf() : u;
          const p = cn(u);
          return p !== "array" || function(_) {
            return Array.isArray(_) && _.length === 3 && typeof _[0] == "string" && typeof _[1] == "string" && typeof _[2] == "number";
          }(u) || function(_) {
            return !!["interpolate", "step", "literal"].includes(_[0]);
          }(u) ? ["array", "string"].includes(p) ? [] : [new er(c, u, `projection expected, invalid type "${p}" found`)] : [new er(c, u, `projection expected, invalid array ${JSON.stringify(u)} found`)];
        }, string: da, formatted: function(f) {
          return da(f).length === 0 ? [] : ic(f);
        }, resolvedImage: function(f) {
          return da(f).length === 0 ? [] : ic(f);
        }, padding: function(f) {
          const c = f.key, u = f.value;
          if (cn(u) === "array") {
            if (u.length < 1 || u.length > 4) return [new er(c, u, `padding requires 1 to 4 values; ${u.length} values found`)];
            const p = { type: "number" };
            let _ = [];
            for (let x = 0; x < u.length; x++) _ = _.concat(f.validateSpec({ key: `${c}[${x}]`, value: u[x], validateSpec: f.validateSpec, valueSpec: p }));
            return _;
          }
          return zu({ key: c, value: u, valueSpec: {} });
        }, numberArray: function(f) {
          const c = f.key, u = f.value;
          if (cn(u) === "array") {
            const p = { type: "number" };
            if (u.length < 1) return [new er(c, u, "array length at least 1 expected, length 0 found")];
            let _ = [];
            for (let x = 0; x < u.length; x++) _ = _.concat(f.validateSpec({ key: `${c}[${x}]`, value: u[x], validateSpec: f.validateSpec, valueSpec: p }));
            return _;
          }
          return zu({ key: c, value: u, valueSpec: {} });
        }, colorArray: function(f) {
          const c = f.key, u = f.value;
          if (cn(u) === "array") {
            if (u.length < 1) return [new er(c, u, "array length at least 1 expected, length 0 found")];
            let p = [];
            for (let _ = 0; _ < u.length; _++) p = p.concat(ph({ key: `${c}[${_}]`, value: u[_] }));
            return p;
          }
          return ph({ key: c, value: u });
        }, variableAnchorOffsetCollection: function(f) {
          const c = f.key, u = f.value, p = cn(u), _ = f.styleSpec;
          if (p !== "array" || u.length < 1 || u.length % 2 != 0) return [new er(c, u, "variableAnchorOffsetCollection requires a non-empty array of even length")];
          let x = [];
          for (let T = 0; T < u.length; T += 2) x = x.concat(Kc({ key: `${c}[${T}]`, value: u[T], valueSpec: _.layout_symbol["text-anchor"] })), x = x.concat(Xs({ key: `${c}[${T + 1}]`, value: u[T + 1], valueSpec: { length: 2, value: "number" }, validateSpec: f.validateSpec, style: f.style, styleSpec: _ }));
          return x;
        }, sprite: _h, state: sd };
        function sc(f) {
          const c = f.value, u = f.valueSpec, p = f.styleSpec;
          return f.validateSpec = sc, u.expression && Ml(Si(c)) ? Yc(f) : u.expression && hh(nl(c)) ? ic(f) : u.type && Vu[u.type] ? Vu[u.type](f) : Ki(oi({}, f, { valueSpec: u.type ? p[u.type] : u }));
        }
        function Qc(f) {
          const c = f.value, u = f.key, p = da(f);
          return p.length || (c.indexOf("{fontstack}") === -1 && p.push(new er(u, c, '"glyphs" url must include a "{fontstack}" token')), c.indexOf("{range}") === -1 && p.push(new er(u, c, '"glyphs" url must include a "{range}" token'))), p;
        }
        function Fo(f) {
          let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ge, u = [];
          return u = u.concat(sc({ key: "", value: f, valueSpec: c.$root, styleSpec: c, style: f, validateSpec: sc, objectElementValidators: { glyphs: Qc, "*": () => [] } })), f.constants && (u = u.concat(La({ key: "constants", value: f.constants }))), S(u);
        }
        function Uo(f) {
          return function(c) {
            return f({ ...c, validateSpec: sc });
          };
        }
        function S(f) {
          return [].concat(f).sort((c, u) => c.line - u.line);
        }
        function R(f) {
          return function() {
            for (var c = arguments.length, u = new Array(c), p = 0; p < c; p++)
              u[p] = arguments[p];
            return S(f.apply(this, u));
          };
        }
        Fo.source = R(Uo(nd)), Fo.sprite = R(Uo(_h)), Fo.glyphs = R(Uo(Qc)), Fo.light = R(Uo(id)), Fo.sky = R(Uo(Jc)), Fo.terrain = R(Uo(rf)), Fo.state = R(Uo(sd)), Fo.layer = R(Uo(Bs)), Fo.filter = R(Uo(gh)), Fo.paintProperty = R(Uo(il)), Fo.layoutProperty = R(Uo(Oa));
        const D = Fo, W = D.light, se = D.sky, de = D.paintProperty, ge = D.layoutProperty;
        function _e(f, c) {
          let u = !1;
          if (c && c.length) for (const p of c) f.fire(new st(new Error(p.message))), u = !0;
          return u;
        }
        class xe {
          constructor(c, u, p) {
            const _ = this.cells = [];
            if (c instanceof ArrayBuffer) {
              this.arrayBuffer = c;
              const T = new Int32Array(this.arrayBuffer);
              c = T[0], this.d = (u = T[1]) + 2 * (p = T[2]);
              for (let B = 0; B < this.d * this.d; B++) {
                const N = T[3 + B], z = T[3 + B + 1];
                _.push(N === z ? null : T.subarray(N, z));
              }
              const I = T[3 + _.length + 1];
              this.keys = T.subarray(T[3 + _.length], I), this.bboxes = T.subarray(I), this.insert = this._insertReadonly;
            } else {
              this.d = u + 2 * p;
              for (let T = 0; T < this.d * this.d; T++) _.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = u, this.extent = c, this.padding = p, this.scale = u / c, this.uid = 0;
            const x = p / u * c;
            this.min = -x, this.max = c + x;
          }
          insert(c, u, p, _, x) {
            this._forEachCell(u, p, _, x, this._insertCell, this.uid++, void 0, void 0), this.keys.push(c), this.bboxes.push(u), this.bboxes.push(p), this.bboxes.push(_), this.bboxes.push(x);
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
          }
          _insertCell(c, u, p, _, x, T) {
            this.cells[x].push(T);
          }
          query(c, u, p, _, x) {
            const T = this.min, I = this.max;
            if (c <= T && u <= T && I <= p && I <= _ && !x) return Array.prototype.slice.call(this.keys);
            {
              const B = [];
              return this._forEachCell(c, u, p, _, this._queryCell, B, {}, x), B;
            }
          }
          _queryCell(c, u, p, _, x, T, I, B) {
            const N = this.cells[x];
            if (N !== null) {
              const z = this.keys, $ = this.bboxes;
              for (let J = 0; J < N.length; J++) {
                const te = N[J];
                if (I[te] === void 0) {
                  const ne = 4 * te;
                  (B ? B($[ne + 0], $[ne + 1], $[ne + 2], $[ne + 3]) : c <= $[ne + 2] && u <= $[ne + 3] && p >= $[ne + 0] && _ >= $[ne + 1]) ? (I[te] = !0, T.push(z[te])) : I[te] = !1;
                }
              }
            }
          }
          _forEachCell(c, u, p, _, x, T, I, B) {
            const N = this._convertToCellCoord(c), z = this._convertToCellCoord(u), $ = this._convertToCellCoord(p), J = this._convertToCellCoord(_);
            for (let te = N; te <= $; te++) for (let ne = z; ne <= J; ne++) {
              const ue = this.d * ne + te;
              if ((!B || B(this._convertFromCellCoord(te), this._convertFromCellCoord(ne), this._convertFromCellCoord(te + 1), this._convertFromCellCoord(ne + 1))) && x.call(this, c, u, p, _, ue, T, I, B)) return;
            }
          }
          _convertFromCellCoord(c) {
            return (c - this.padding) / this.scale;
          }
          _convertToCellCoord(c) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(c * this.scale) + this.padding));
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const c = this.cells, u = 3 + this.cells.length + 1 + 1;
            let p = 0;
            for (let T = 0; T < this.cells.length; T++) p += this.cells[T].length;
            const _ = new Int32Array(u + p + this.keys.length + this.bboxes.length);
            _[0] = this.extent, _[1] = this.n, _[2] = this.padding;
            let x = u;
            for (let T = 0; T < c.length; T++) {
              const I = c[T];
              _[3 + T] = x, _.set(I, x), x += I.length;
            }
            return _[3 + c.length] = x, _.set(this.keys, x), x += this.keys.length, _[3 + c.length + 1] = x, _.set(this.bboxes, x), x += this.bboxes.length, _.buffer;
          }
          static serialize(c, u) {
            const p = c.toArrayBuffer();
            return u && u.push(p), { buffer: p };
          }
          static deserialize(c) {
            return new xe(c.buffer);
          }
        }
        const Ie = {};
        function Re(f, c) {
          let u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          if (Ie[f]) throw new Error(`${f} is already registered.`);
          Object.defineProperty(c, "_classRegistryKey", { value: f, writeable: !1 }), Ie[f] = { klass: c, omit: u.omit || [], shallow: u.shallow || [] };
        }
        Re("Object", Object), Re("Set", Set), Re("TransferableGridIndex", xe), Re("Color", hn), Re("Error", Error), Re("AJAXError", Le), Re("ResolvedImage", Ps), Re("StylePropertyFunction", Nu), Re("StyleExpression", Hc, { omit: ["_evaluator"] }), Re("ZoomDependentExpression", dh), Re("ZoomConstantExpression", Wc), Re("CompoundExpression", Ai, { omit: ["_evaluate"] });
        for (const f in xs) xs[f]._classRegistryKey || Re(`Expression_${f}`, xs[f]);
        function At(f) {
          return f && typeof ArrayBuffer < "u" && (f instanceof ArrayBuffer || f.constructor && f.constructor.name === "ArrayBuffer");
        }
        function vt(f) {
          return f.$name || f.constructor._classRegistryKey;
        }
        function at(f) {
          return !function(c) {
            if (c === null || typeof c != "object") return !1;
            const u = vt(c);
            return !(!u || u === "Object");
          }(f) && (f == null || typeof f == "boolean" || typeof f == "number" || typeof f == "string" || f instanceof Boolean || f instanceof Number || f instanceof String || f instanceof Date || f instanceof RegExp || f instanceof Blob || f instanceof Error || At(f) || mr(f) || ArrayBuffer.isView(f) || f instanceof ImageData);
        }
        function Gt(f, c) {
          if (at(f)) return (At(f) || mr(f)) && c && c.push(f), ArrayBuffer.isView(f) && c && c.push(f.buffer), f instanceof ImageData && c && c.push(f.data.buffer), f;
          if (Array.isArray(f)) {
            const x = [];
            for (const T of f) x.push(Gt(T, c));
            return x;
          }
          if (typeof f != "object") throw new Error("can't serialize object of type " + typeof f);
          const u = vt(f);
          if (!u) throw new Error(`can't serialize object of unregistered class ${f.constructor.name}`);
          if (!Ie[u]) throw new Error(`${u} is not registered.`);
          const { klass: p } = Ie[u], _ = p.serialize ? p.serialize(f, c) : {};
          if (p.serialize) {
            if (c && _ === c[c.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
          } else {
            for (const x in f) {
              if (!f.hasOwnProperty(x) || Ie[u].omit.indexOf(x) >= 0) continue;
              const T = f[x];
              _[x] = Ie[u].shallow.indexOf(x) >= 0 ? T : Gt(T, c);
            }
            f instanceof Error && (_.message = f.message);
          }
          if (_.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return u !== "Object" && (_.$name = u), _;
        }
        function kt(f) {
          if (at(f)) return f;
          if (Array.isArray(f)) return f.map(kt);
          if (typeof f != "object") throw new Error("can't deserialize object of type " + typeof f);
          const c = vt(f) || "Object";
          if (!Ie[c]) throw new Error(`can't deserialize unregistered class ${c}`);
          const { klass: u } = Ie[c];
          if (!u) throw new Error(`can't deserialize unregistered class ${c}`);
          if (u.deserialize) return u.deserialize(f);
          const p = Object.create(u.prototype);
          for (const _ of Object.keys(f)) {
            if (_ === "$name") continue;
            const x = f[_];
            p[_] = Ie[c].shallow.indexOf(_) >= 0 ? x : kt(x);
          }
          return p;
        }
        class rt {
          constructor() {
            this.first = !0;
          }
          update(c, u) {
            const p = Math.floor(c);
            return this.first ? (this.first = !1, this.lastIntegerZoom = p, this.lastIntegerZoomTime = 0, this.lastZoom = c, this.lastFloorZoom = p, !0) : (this.lastFloorZoom > p ? (this.lastIntegerZoom = p + 1, this.lastIntegerZoomTime = u) : this.lastFloorZoom < p && (this.lastIntegerZoom = p, this.lastIntegerZoomTime = u), c !== this.lastZoom && (this.lastZoom = c, this.lastFloorZoom = p, !0));
          }
        }
        const Xe = { "Latin-1 Supplement": (f) => f >= 128 && f <= 255, "Hangul Jamo": (f) => f >= 4352 && f <= 4607, Khmer: (f) => f >= 6016 && f <= 6143, "General Punctuation": (f) => f >= 8192 && f <= 8303, "Letterlike Symbols": (f) => f >= 8448 && f <= 8527, "Number Forms": (f) => f >= 8528 && f <= 8591, "Miscellaneous Technical": (f) => f >= 8960 && f <= 9215, "Control Pictures": (f) => f >= 9216 && f <= 9279, "Optical Character Recognition": (f) => f >= 9280 && f <= 9311, "Enclosed Alphanumerics": (f) => f >= 9312 && f <= 9471, "Geometric Shapes": (f) => f >= 9632 && f <= 9727, "Miscellaneous Symbols": (f) => f >= 9728 && f <= 9983, "Miscellaneous Symbols and Arrows": (f) => f >= 11008 && f <= 11263, "Ideographic Description Characters": (f) => f >= 12272 && f <= 12287, "CJK Symbols and Punctuation": (f) => f >= 12288 && f <= 12351, Hiragana: (f) => f >= 12352 && f <= 12447, Katakana: (f) => f >= 12448 && f <= 12543, Kanbun: (f) => f >= 12688 && f <= 12703, "CJK Strokes": (f) => f >= 12736 && f <= 12783, "Enclosed CJK Letters and Months": (f) => f >= 12800 && f <= 13055, "CJK Compatibility": (f) => f >= 13056 && f <= 13311, "Yijing Hexagram Symbols": (f) => f >= 19904 && f <= 19967, "CJK Unified Ideographs": (f) => f >= 19968 && f <= 40959, "Hangul Syllables": (f) => f >= 44032 && f <= 55215, "Private Use Area": (f) => f >= 57344 && f <= 63743, "Vertical Forms": (f) => f >= 65040 && f <= 65055, "CJK Compatibility Forms": (f) => f >= 65072 && f <= 65103, "Small Form Variants": (f) => f >= 65104 && f <= 65135, "Halfwidth and Fullwidth Forms": (f) => f >= 65280 && f <= 65519 };
        function qt(f) {
          for (const c of f) if (br(c.charCodeAt(0))) return !0;
          return !1;
        }
        function Zt(f) {
          for (const c of f) if (!yr(c.charCodeAt(0))) return !1;
          return !0;
        }
        function Ht(f) {
          const c = f.map((u) => {
            try {
              return new RegExp(`\\p{sc=${u}}`, "u").source;
            } catch {
              return null;
            }
          }).filter((u) => u);
          return new RegExp(c.join("|"), "u");
        }
        const Mr = Ht(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
        function yr(f) {
          return !Mr.test(String.fromCodePoint(f));
        }
        const $r = Ht(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
        function br(f) {
          return !(f !== 746 && f !== 747 && (f < 4352 || !(Xe["CJK Compatibility Forms"](f) && !(f >= 65097 && f <= 65103) || Xe["CJK Compatibility"](f) || Xe["CJK Strokes"](f) || !(!Xe["CJK Symbols and Punctuation"](f) || f >= 12296 && f <= 12305 || f >= 12308 && f <= 12319 || f === 12336) || Xe["Enclosed CJK Letters and Months"](f) || Xe["Ideographic Description Characters"](f) || Xe.Kanbun(f) || Xe.Katakana(f) && f !== 12540 || !(!Xe["Halfwidth and Fullwidth Forms"](f) || f === 65288 || f === 65289 || f === 65293 || f >= 65306 && f <= 65310 || f === 65339 || f === 65341 || f === 65343 || f >= 65371 && f <= 65503 || f === 65507 || f >= 65512 && f <= 65519) || !(!Xe["Small Form Variants"](f) || f >= 65112 && f <= 65118 || f >= 65123 && f <= 65126) || Xe["Vertical Forms"](f) || Xe["Yijing Hexagram Symbols"](f) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(f)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(f)) || $r.test(String.fromCodePoint(f)))));
        }
        function Pn(f) {
          return !(br(f) || function(c) {
            return !!(Xe["Latin-1 Supplement"](c) && (c === 167 || c === 169 || c === 174 || c === 177 || c === 188 || c === 189 || c === 190 || c === 215 || c === 247) || Xe["General Punctuation"](c) && (c === 8214 || c === 8224 || c === 8225 || c === 8240 || c === 8241 || c === 8251 || c === 8252 || c === 8258 || c === 8263 || c === 8264 || c === 8265 || c === 8273) || Xe["Letterlike Symbols"](c) || Xe["Number Forms"](c) || Xe["Miscellaneous Technical"](c) && (c >= 8960 && c <= 8967 || c >= 8972 && c <= 8991 || c >= 8996 && c <= 9e3 || c === 9003 || c >= 9085 && c <= 9114 || c >= 9150 && c <= 9165 || c === 9167 || c >= 9169 && c <= 9179 || c >= 9186 && c <= 9215) || Xe["Control Pictures"](c) && c !== 9251 || Xe["Optical Character Recognition"](c) || Xe["Enclosed Alphanumerics"](c) || Xe["Geometric Shapes"](c) || Xe["Miscellaneous Symbols"](c) && !(c >= 9754 && c <= 9759) || Xe["Miscellaneous Symbols and Arrows"](c) && (c >= 11026 && c <= 11055 || c >= 11088 && c <= 11097 || c >= 11192 && c <= 11243) || Xe["CJK Symbols and Punctuation"](c) || Xe.Katakana(c) || Xe["Private Use Area"](c) || Xe["CJK Compatibility Forms"](c) || Xe["Small Form Variants"](c) || Xe["Halfwidth and Fullwidth Forms"](c) || c === 8734 || c === 8756 || c === 8757 || c >= 9984 && c <= 10087 || c >= 10102 && c <= 10131 || c === 65532 || c === 65533);
          }(f));
        }
        const Fn = Ht(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
        function wn(f) {
          return Fn.test(String.fromCodePoint(f));
        }
        function Sn(f, c) {
          return !(!c && wn(f) || f >= 2304 && f <= 3583 || f >= 3840 && f <= 4255 || Xe.Khmer(f));
        }
        function Vn(f) {
          for (const c of f) if (wn(c.charCodeAt(0))) return !0;
          return !1;
        }
        const Cn = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {
            };
          }
          setState(f) {
            this.pluginStatus = f.pluginStatus, this.pluginURL = f.pluginURL;
          }
          getState() {
            return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
          }
          setMethods(f) {
            if (Cn.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = f.applyArabicShaping, this.processBidirectionalText = f.processBidirectionalText, this.processStyledBidirectionalText = f.processStyledBidirectionalText, this.loadScriptResolve();
          }
          isParsed() {
            return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus;
          }
          syncState(f, c) {
            return o(this, void 0, void 0, function* () {
              if (this.isParsed()) return this.getState();
              if (f.pluginStatus !== "loading") return this.setState(f), f;
              const u = f.pluginURL, p = new Promise((x) => {
                this.loadScriptResolve = x;
              });
              c(u);
              const _ = new Promise((x) => setTimeout(() => x(), this.TIMEOUT));
              if (yield Promise.race([p, _]), this.isParsed()) {
                const x = { pluginStatus: "loaded", pluginURL: u };
                return this.setState(x), x;
              }
              throw this.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${u}`);
            });
          }
        }();
        class Br {
          constructor(c, u) {
            this.zoom = c, u ? (this.now = u.now || 0, this.fadeDuration = u.fadeDuration || 0, this.zoomHistory = u.zoomHistory || new rt(), this.transition = u.transition || {}, this.globalState = u.globalState || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new rt(), this.transition = {}, this.globalState = {});
          }
          isSupportedScript(c) {
            return function(u, p) {
              for (const _ of u) if (!Sn(_.charCodeAt(0), p)) return !1;
              return !0;
            }(c, Cn.getRTLTextPluginStatus() === "loaded");
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
          }
          getCrossfadeParameters() {
            const c = this.zoom, u = c - Math.floor(c), p = this.crossFadingFactor();
            return c > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: u + (1 - u) * p } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - p) * u };
          }
        }
        class di {
          constructor(c, u) {
            this.property = c, this.value = u, this.expression = function(p, _) {
              if (Ml(p)) return new Nu(p, _);
              if (hh(p)) {
                const x = ef(p, _);
                if (x.result === "error") throw new Error(x.value.map((T) => `${T.key}: ${T.message}`).join(", "));
                return x.value;
              }
              {
                let x = p;
                return _.type === "color" && typeof p == "string" ? x = hn.parse(p) : _.type !== "padding" || typeof p != "number" && !Array.isArray(p) ? _.type !== "numberArray" || typeof p != "number" && !Array.isArray(p) ? _.type !== "colorArray" || typeof p != "string" && !Array.isArray(p) ? _.type === "variableAnchorOffsetCollection" && Array.isArray(p) ? x = pn.parse(p) : _.type === "projectionDefinition" && typeof p == "string" && (x = Wr.parse(p)) : x = Ni.parse(p) : x = Wi.parse(p) : x = zn.parse(p), { globalStateRefs: /* @__PURE__ */ new Set(), kind: "constant", evaluate: () => x };
              }
            }(u === void 0 ? c.specification.default : u, c.specification);
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite";
          }
          getGlobalStateRefs() {
            return this.expression.globalStateRefs || /* @__PURE__ */ new Set();
          }
          possiblyEvaluate(c, u, p) {
            return this.property.possiblyEvaluate(this, c, u, p);
          }
        }
        class ws {
          constructor(c) {
            this.property = c, this.value = new di(c, void 0);
          }
          transitioned(c, u) {
            return new Zs(this.property, this.value, u, Kt({}, c.transition, this.transition), c.now);
          }
          untransitioned() {
            return new Zs(this.property, this.value, null, {}, 0);
          }
        }
        class Bi {
          constructor(c) {
            this._properties = c, this._values = Object.create(c.defaultTransitionablePropertyValues);
          }
          getValue(c) {
            return Nt(this._values[c].value.value);
          }
          setValue(c, u) {
            Object.prototype.hasOwnProperty.call(this._values, c) || (this._values[c] = new ws(this._values[c].property)), this._values[c].value = new di(this._values[c].property, u === null ? void 0 : Nt(u));
          }
          getTransition(c) {
            return Nt(this._values[c].transition);
          }
          setTransition(c, u) {
            Object.prototype.hasOwnProperty.call(this._values, c) || (this._values[c] = new ws(this._values[c].property)), this._values[c].transition = Nt(u) || void 0;
          }
          serialize() {
            const c = {};
            for (const u of Object.keys(this._values)) {
              const p = this.getValue(u);
              p !== void 0 && (c[u] = p);
              const _ = this.getTransition(u);
              _ !== void 0 && (c[`${u}-transition`] = _);
            }
            return c;
          }
          transitioned(c, u) {
            const p = new Un(this._properties);
            for (const _ of Object.keys(this._values)) p._values[_] = this._values[_].transitioned(c, u._values[_]);
            return p;
          }
          untransitioned() {
            const c = new Un(this._properties);
            for (const u of Object.keys(this._values)) c._values[u] = this._values[u].untransitioned();
            return c;
          }
        }
        class Zs {
          constructor(c, u, p, _, x) {
            this.property = c, this.value = u, this.begin = x + _.delay || 0, this.end = this.begin + _.duration || 0, c.specification.transition && (_.delay || _.duration) && (this.prior = p);
          }
          possiblyEvaluate(c, u, p) {
            const _ = c.now || 0, x = this.value.possiblyEvaluate(c, u, p), T = this.prior;
            if (T) {
              if (_ > this.end) return this.prior = null, x;
              if (this.value.isDataDriven()) return this.prior = null, x;
              if (_ < this.begin) return T.possiblyEvaluate(c, u, p);
              {
                const I = (_ - this.begin) / (this.end - this.begin);
                return this.property.interpolate(T.possiblyEvaluate(c, u, p), x, ot(I));
              }
            }
            return x;
          }
        }
        class Un {
          constructor(c) {
            this._properties = c, this._values = Object.create(c.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(c, u, p) {
            const _ = new Fi(this._properties);
            for (const x of Object.keys(this._values)) _._values[x] = this._values[x].possiblyEvaluate(c, u, p);
            return _;
          }
          hasTransition() {
            for (const c of Object.keys(this._values)) if (this._values[c].prior) return !0;
            return !1;
          }
        }
        class So {
          constructor(c) {
            this._properties = c, this._values = Object.create(c.defaultPropertyValues);
          }
          hasValue(c) {
            return this._values[c].value !== void 0;
          }
          getValue(c) {
            return Nt(this._values[c].value);
          }
          setValue(c, u) {
            this._values[c] = new di(this._values[c].property, u === null ? void 0 : Nt(u));
          }
          serialize() {
            const c = {};
            for (const u of Object.keys(this._values)) {
              const p = this.getValue(u);
              p !== void 0 && (c[u] = p);
            }
            return c;
          }
          possiblyEvaluate(c, u, p) {
            const _ = new Fi(this._properties);
            for (const x of Object.keys(this._values)) _._values[x] = this._values[x].possiblyEvaluate(c, u, p);
            return _;
          }
        }
        class Li {
          constructor(c, u, p) {
            this.property = c, this.value = u, this.parameters = p;
          }
          isConstant() {
            return this.value.kind === "constant";
          }
          constantOr(c) {
            return this.value.kind === "constant" ? this.value.value : c;
          }
          evaluate(c, u, p, _) {
            return this.property.evaluate(this.value, this.parameters, c, u, p, _);
          }
        }
        class Fi {
          constructor(c) {
            this._properties = c, this._values = Object.create(c.defaultPossiblyEvaluatedValues);
          }
          get(c) {
            return this._values[c];
          }
        }
        class fr {
          constructor(c) {
            this.specification = c;
          }
          possiblyEvaluate(c, u) {
            if (c.isDataDriven()) throw new Error("Value should not be data driven");
            return c.expression.evaluate(u);
          }
          interpolate(c, u, p) {
            const _ = ss[this.specification.type];
            return _ ? _(c, u, p) : c;
          }
        }
        class Ir {
          constructor(c, u) {
            this.specification = c, this.overrides = u;
          }
          possiblyEvaluate(c, u, p, _) {
            return new Li(this, c.expression.kind === "constant" || c.expression.kind === "camera" ? { kind: "constant", value: c.expression.evaluate(u, null, {}, p, _) } : c.expression, u);
          }
          interpolate(c, u, p) {
            if (c.value.kind !== "constant" || u.value.kind !== "constant") return c;
            if (c.value.value === void 0 || u.value.value === void 0) return new Li(this, { kind: "constant", value: void 0 }, c.parameters);
            const _ = ss[this.specification.type];
            if (_) {
              const x = _(c.value.value, u.value.value, p);
              return new Li(this, { kind: "constant", value: x }, c.parameters);
            }
            return c;
          }
          evaluate(c, u, p, _, x, T) {
            return c.kind === "constant" ? c.value : c.evaluate(u, p, _, x, T);
          }
        }
        class Ys extends Ir {
          possiblyEvaluate(c, u, p, _) {
            if (c.value === void 0) return new Li(this, { kind: "constant", value: void 0 }, u);
            if (c.expression.kind === "constant") {
              const x = c.expression.evaluate(u, null, {}, p, _), T = c.property.specification.type === "resolvedImage" && typeof x != "string" ? x.name : x, I = this._calculate(T, T, T, u);
              return new Li(this, { kind: "constant", value: I }, u);
            }
            if (c.expression.kind === "camera") {
              const x = this._calculate(c.expression.evaluate({ zoom: u.zoom - 1 }), c.expression.evaluate({ zoom: u.zoom }), c.expression.evaluate({ zoom: u.zoom + 1 }), u);
              return new Li(this, { kind: "constant", value: x }, u);
            }
            return new Li(this, c.expression, u);
          }
          evaluate(c, u, p, _, x, T) {
            if (c.kind === "source") {
              const I = c.evaluate(u, p, _, x, T);
              return this._calculate(I, I, I, u);
            }
            return c.kind === "composite" ? this._calculate(c.evaluate({ zoom: Math.floor(u.zoom) - 1 }, p, _), c.evaluate({ zoom: Math.floor(u.zoom) }, p, _), c.evaluate({ zoom: Math.floor(u.zoom) + 1 }, p, _), u) : c.value;
          }
          _calculate(c, u, p, _) {
            return _.zoom > _.zoomHistory.lastIntegerZoom ? { from: c, to: u } : { from: p, to: u };
          }
          interpolate(c) {
            return c;
          }
        }
        class zo {
          constructor(c) {
            this.specification = c;
          }
          possiblyEvaluate(c, u, p, _) {
            if (c.value !== void 0) {
              if (c.expression.kind === "constant") {
                const x = c.expression.evaluate(u, null, {}, p, _);
                return this._calculate(x, x, x, u);
              }
              return this._calculate(c.expression.evaluate(new Br(Math.floor(u.zoom - 1), u)), c.expression.evaluate(new Br(Math.floor(u.zoom), u)), c.expression.evaluate(new Br(Math.floor(u.zoom + 1), u)), u);
            }
          }
          _calculate(c, u, p, _) {
            return _.zoom > _.zoomHistory.lastIntegerZoom ? { from: c, to: u } : { from: p, to: u };
          }
          interpolate(c) {
            return c;
          }
        }
        class Oi {
          constructor(c) {
            this.specification = c;
          }
          possiblyEvaluate(c, u, p, _) {
            return !!c.expression.evaluate(u, null, {}, p, _);
          }
          interpolate() {
            return !1;
          }
        }
        class Ei {
          constructor(c) {
            this.properties = c, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const u in c) {
              const p = c[u];
              p.specification.overridable && this.overridableProperties.push(u);
              const _ = this.defaultPropertyValues[u] = new di(p, void 0), x = this.defaultTransitionablePropertyValues[u] = new ws(p);
              this.defaultTransitioningPropertyValues[u] = x.untransitioned(), this.defaultPossiblyEvaluatedValues[u] = _.possiblyEvaluate({});
            }
          }
        }
        Re("DataDrivenProperty", Ir), Re("DataConstantProperty", fr), Re("CrossFadedDataDrivenProperty", Ys), Re("CrossFadedProperty", zo), Re("ColorRampProperty", Oi);
        const Pl = "-transition";
        class ki extends ft {
          constructor(c, u) {
            if (super(), this.id = c.id, this.type = c.type, this._featureFilter = { filter: () => !0, needGeometry: !1, getGlobalStateRefs: () => /* @__PURE__ */ new Set() }, c.type !== "custom" && (this.metadata = c.metadata, this.minzoom = c.minzoom, this.maxzoom = c.maxzoom, c.type !== "background" && (this.source = c.source, this.sourceLayer = c["source-layer"], this.filter = c.filter, this._featureFilter = Do(c.filter)), u.layout && (this._unevaluatedLayout = new So(u.layout)), u.paint)) {
              this._transitionablePaint = new Bi(u.paint);
              for (const p in c.paint) this.setPaintProperty(p, c.paint[p], { validate: !1 });
              for (const p in c.layout) this.setLayoutProperty(p, c.layout[p], { validate: !1 });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Fi(u.paint);
            }
          }
          setFilter(c) {
            this.filter = c, this._featureFilter = Do(c);
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters;
          }
          getLayoutProperty(c) {
            return c === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(c);
          }
          getLayoutAffectingGlobalStateRefs() {
            const c = /* @__PURE__ */ new Set();
            if (this._unevaluatedLayout) for (const u in this._unevaluatedLayout._values) {
              const p = this._unevaluatedLayout._values[u];
              for (const _ of p.getGlobalStateRefs()) c.add(_);
            }
            for (const u of this._featureFilter.getGlobalStateRefs()) c.add(u);
            return c;
          }
          setLayoutProperty(c, u) {
            let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            u != null && this._validate(ge, `layers.${this.id}.layout.${c}`, c, u, p) || (c !== "visibility" ? this._unevaluatedLayout.setValue(c, u) : this.visibility = u);
          }
          getPaintProperty(c) {
            return c.endsWith(Pl) ? this._transitionablePaint.getTransition(c.slice(0, -11)) : this._transitionablePaint.getValue(c);
          }
          setPaintProperty(c, u) {
            let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            if (u != null && this._validate(de, `layers.${this.id}.paint.${c}`, c, u, p)) return !1;
            if (c.endsWith(Pl)) return this._transitionablePaint.setTransition(c.slice(0, -11), u || void 0), !1;
            {
              const _ = this._transitionablePaint._values[c], x = _.property.specification["property-type"] === "cross-faded-data-driven", T = _.value.isDataDriven(), I = _.value;
              this._transitionablePaint.setValue(c, u), this._handleSpecialPaintPropertyUpdate(c);
              const B = this._transitionablePaint._values[c].value;
              return B.isDataDriven() || T || x || this._handleOverridablePaintPropertyUpdate(c, I, B);
            }
          }
          _handleSpecialPaintPropertyUpdate(c) {
          }
          _handleOverridablePaintPropertyUpdate(c, u, p) {
            return !1;
          }
          isHidden(c) {
            return !!(this.minzoom && c < this.minzoom) || !!(this.maxzoom && c >= this.maxzoom) || this.visibility === "none";
          }
          updateTransitions(c) {
            this._transitioningPaint = this._transitionablePaint.transitioned(c, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(c, u) {
            c.getCrossfadeParameters && (this._crossfadeParameters = c.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(c, void 0, u)), this.paint = this._transitioningPaint.possiblyEvaluate(c, void 0, u);
          }
          serialize() {
            const c = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (c.layout = c.layout || {}, c.layout.visibility = this.visibility), Ur(c, (u, p) => !(u === void 0 || p === "layout" && !Object.keys(u).length || p === "paint" && !Object.keys(u).length));
          }
          _validate(c, u, p, _) {
            let x = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
            return (!x || x.validate !== !1) && _e(this, c.call(D, { key: u, layerType: this.type, objectKey: p, value: _, styleSpec: Ge, style: { glyphs: !0, sprite: !0 } }));
          }
          is3D() {
            return !1;
          }
          isTileClipped() {
            return !1;
          }
          hasOffscreenPass() {
            return !1;
          }
          resize() {
          }
          isStateDependent() {
            for (const c in this.paint._values) {
              const u = this.paint.get(c);
              if (u instanceof Li && os(u.property.specification) && (u.value.kind === "source" || u.value.kind === "composite") && u.value.isStateDependent) return !0;
            }
            return !1;
          }
        }
        const sl = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class Wn {
          constructor(c, u) {
            this._structArray = c, this._pos1 = u * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class ri {
          constructor() {
            this.isTransferred = !1, this.capacity = -1, this.resize(0);
          }
          static serialize(c, u) {
            return c._trim(), u && (c.isTransferred = !0, u.push(c.arrayBuffer)), { length: c.length, arrayBuffer: c.arrayBuffer };
          }
          static deserialize(c) {
            const u = Object.create(this.prototype);
            return u.arrayBuffer = c.arrayBuffer, u.length = c.length, u.capacity = c.arrayBuffer.byteLength / u.bytesPerElement, u._refreshViews(), u;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(c) {
            this.reserve(c), this.length = c;
          }
          reserve(c) {
            if (c > this.capacity) {
              this.capacity = Math.max(c, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const u = this.uint8;
              this._refreshViews(), u && this.uint8.set(u);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
        }
        function pi(f) {
          let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, u = 0, p = 0;
          return { members: f.map((_) => {
            const x = sl[_.type].BYTES_PER_ELEMENT, T = u = nf(u, Math.max(c, x)), I = _.components || 1;
            return p = Math.max(p, x), u += x * I, { name: _.name, type: _.type, components: I, offset: T };
          }), size: nf(u, Math.max(p, c)), alignment: c };
        }
        function nf(f, c) {
          return Math.ceil(f / c) * c;
        }
        class pa extends ri {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(c, u) {
            const p = this.length;
            return this.resize(p + 1), this.emplace(p, c, u);
          }
          emplace(c, u, p) {
            const _ = 2 * c;
            return this.int16[_ + 0] = u, this.int16[_ + 1] = p, c;
          }
        }
        pa.prototype.bytesPerElement = 4, Re("StructArrayLayout2i4", pa);
        class jo extends ri {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(c, u, p) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, c, u, p);
          }
          emplace(c, u, p, _) {
            const x = 3 * c;
            return this.int16[x + 0] = u, this.int16[x + 1] = p, this.int16[x + 2] = _, c;
          }
        }
        jo.prototype.bytesPerElement = 6, Re("StructArrayLayout3i6", jo);
        class eu extends ri {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(c, u, p, _) {
            const x = this.length;
            return this.resize(x + 1), this.emplace(x, c, u, p, _);
          }
          emplace(c, u, p, _, x) {
            const T = 4 * c;
            return this.int16[T + 0] = u, this.int16[T + 1] = p, this.int16[T + 2] = _, this.int16[T + 3] = x, c;
          }
        }
        eu.prototype.bytesPerElement = 8, Re("StructArrayLayout4i8", eu);
        class ho extends ri {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(c, u, p, _, x, T) {
            const I = this.length;
            return this.resize(I + 1), this.emplace(I, c, u, p, _, x, T);
          }
          emplace(c, u, p, _, x, T, I) {
            const B = 6 * c;
            return this.int16[B + 0] = u, this.int16[B + 1] = p, this.int16[B + 2] = _, this.int16[B + 3] = x, this.int16[B + 4] = T, this.int16[B + 5] = I, c;
          }
        }
        ho.prototype.bytesPerElement = 12, Re("StructArrayLayout2i4i12", ho);
        class Vo extends ri {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(c, u, p, _, x, T) {
            const I = this.length;
            return this.resize(I + 1), this.emplace(I, c, u, p, _, x, T);
          }
          emplace(c, u, p, _, x, T, I) {
            const B = 4 * c, N = 8 * c;
            return this.int16[B + 0] = u, this.int16[B + 1] = p, this.uint8[N + 4] = _, this.uint8[N + 5] = x, this.uint8[N + 6] = T, this.uint8[N + 7] = I, c;
          }
        }
        Vo.prototype.bytesPerElement = 8, Re("StructArrayLayout2i4ub8", Vo);
        class ka extends ri {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(c, u) {
            const p = this.length;
            return this.resize(p + 1), this.emplace(p, c, u);
          }
          emplace(c, u, p) {
            const _ = 2 * c;
            return this.float32[_ + 0] = u, this.float32[_ + 1] = p, c;
          }
        }
        ka.prototype.bytesPerElement = 8, Re("StructArrayLayout2f8", ka);
        class yh extends ri {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(c, u, p, _, x, T, I, B, N, z) {
            const $ = this.length;
            return this.resize($ + 1), this.emplace($, c, u, p, _, x, T, I, B, N, z);
          }
          emplace(c, u, p, _, x, T, I, B, N, z, $) {
            const J = 10 * c;
            return this.uint16[J + 0] = u, this.uint16[J + 1] = p, this.uint16[J + 2] = _, this.uint16[J + 3] = x, this.uint16[J + 4] = T, this.uint16[J + 5] = I, this.uint16[J + 6] = B, this.uint16[J + 7] = N, this.uint16[J + 8] = z, this.uint16[J + 9] = $, c;
          }
        }
        yh.prototype.bytesPerElement = 20, Re("StructArrayLayout10ui20", yh);
        class oc extends ri {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(c, u, p, _, x, T, I, B, N, z, $, J) {
            const te = this.length;
            return this.resize(te + 1), this.emplace(te, c, u, p, _, x, T, I, B, N, z, $, J);
          }
          emplace(c, u, p, _, x, T, I, B, N, z, $, J, te) {
            const ne = 12 * c;
            return this.int16[ne + 0] = u, this.int16[ne + 1] = p, this.int16[ne + 2] = _, this.int16[ne + 3] = x, this.uint16[ne + 4] = T, this.uint16[ne + 5] = I, this.uint16[ne + 6] = B, this.uint16[ne + 7] = N, this.int16[ne + 8] = z, this.int16[ne + 9] = $, this.int16[ne + 10] = J, this.int16[ne + 11] = te, c;
          }
        }
        oc.prototype.bytesPerElement = 24, Re("StructArrayLayout4i4ui4i24", oc);
        class bh extends ri {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(c, u, p) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, c, u, p);
          }
          emplace(c, u, p, _) {
            const x = 3 * c;
            return this.float32[x + 0] = u, this.float32[x + 1] = p, this.float32[x + 2] = _, c;
          }
        }
        bh.prototype.bytesPerElement = 12, Re("StructArrayLayout3f12", bh);
        class v extends ri {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(c) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, c);
          }
          emplace(c, u) {
            return this.uint32[1 * c + 0] = u, c;
          }
        }
        v.prototype.bytesPerElement = 4, Re("StructArrayLayout1ul4", v);
        class a extends ri {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(c, u, p, _, x, T, I, B, N) {
            const z = this.length;
            return this.resize(z + 1), this.emplace(z, c, u, p, _, x, T, I, B, N);
          }
          emplace(c, u, p, _, x, T, I, B, N, z) {
            const $ = 10 * c, J = 5 * c;
            return this.int16[$ + 0] = u, this.int16[$ + 1] = p, this.int16[$ + 2] = _, this.int16[$ + 3] = x, this.int16[$ + 4] = T, this.int16[$ + 5] = I, this.uint32[J + 3] = B, this.uint16[$ + 8] = N, this.uint16[$ + 9] = z, c;
          }
        }
        a.prototype.bytesPerElement = 20, Re("StructArrayLayout6i1ul2ui20", a);
        class h extends ri {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(c, u, p, _, x, T) {
            const I = this.length;
            return this.resize(I + 1), this.emplace(I, c, u, p, _, x, T);
          }
          emplace(c, u, p, _, x, T, I) {
            const B = 6 * c;
            return this.int16[B + 0] = u, this.int16[B + 1] = p, this.int16[B + 2] = _, this.int16[B + 3] = x, this.int16[B + 4] = T, this.int16[B + 5] = I, c;
          }
        }
        h.prototype.bytesPerElement = 12, Re("StructArrayLayout2i2i2i12", h);
        class g extends ri {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(c, u, p, _, x) {
            const T = this.length;
            return this.resize(T + 1), this.emplace(T, c, u, p, _, x);
          }
          emplace(c, u, p, _, x, T) {
            const I = 4 * c, B = 8 * c;
            return this.float32[I + 0] = u, this.float32[I + 1] = p, this.float32[I + 2] = _, this.int16[B + 6] = x, this.int16[B + 7] = T, c;
          }
        }
        g.prototype.bytesPerElement = 16, Re("StructArrayLayout2f1f2i16", g);
        class y extends ri {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(c, u, p, _, x, T) {
            const I = this.length;
            return this.resize(I + 1), this.emplace(I, c, u, p, _, x, T);
          }
          emplace(c, u, p, _, x, T, I) {
            const B = 16 * c, N = 4 * c, z = 8 * c;
            return this.uint8[B + 0] = u, this.uint8[B + 1] = p, this.float32[N + 1] = _, this.float32[N + 2] = x, this.int16[z + 6] = T, this.int16[z + 7] = I, c;
          }
        }
        y.prototype.bytesPerElement = 16, Re("StructArrayLayout2ub2f2i16", y);
        class w extends ri {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(c, u, p) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, c, u, p);
          }
          emplace(c, u, p, _) {
            const x = 3 * c;
            return this.uint16[x + 0] = u, this.uint16[x + 1] = p, this.uint16[x + 2] = _, c;
          }
        }
        w.prototype.bytesPerElement = 6, Re("StructArrayLayout3ui6", w);
        class C extends ri {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(c, u, p, _, x, T, I, B, N, z, $, J, te, ne, ue, Se, Ee) {
            const Je = this.length;
            return this.resize(Je + 1), this.emplace(Je, c, u, p, _, x, T, I, B, N, z, $, J, te, ne, ue, Se, Ee);
          }
          emplace(c, u, p, _, x, T, I, B, N, z, $, J, te, ne, ue, Se, Ee, Je) {
            const ze = 24 * c, ee = 12 * c, ve = 48 * c;
            return this.int16[ze + 0] = u, this.int16[ze + 1] = p, this.uint16[ze + 2] = _, this.uint16[ze + 3] = x, this.uint32[ee + 2] = T, this.uint32[ee + 3] = I, this.uint32[ee + 4] = B, this.uint16[ze + 10] = N, this.uint16[ze + 11] = z, this.uint16[ze + 12] = $, this.float32[ee + 7] = J, this.float32[ee + 8] = te, this.uint8[ve + 36] = ne, this.uint8[ve + 37] = ue, this.uint8[ve + 38] = Se, this.uint32[ee + 10] = Ee, this.int16[ze + 22] = Je, c;
          }
        }
        C.prototype.bytesPerElement = 48, Re("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", C);
        class P extends ri {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(c, u, p, _, x, T, I, B, N, z, $, J, te, ne, ue, Se, Ee, Je, ze, ee, ve, qe, _t, $t, Rt, Ot, Qt, Wt) {
            const nr = this.length;
            return this.resize(nr + 1), this.emplace(nr, c, u, p, _, x, T, I, B, N, z, $, J, te, ne, ue, Se, Ee, Je, ze, ee, ve, qe, _t, $t, Rt, Ot, Qt, Wt);
          }
          emplace(c, u, p, _, x, T, I, B, N, z, $, J, te, ne, ue, Se, Ee, Je, ze, ee, ve, qe, _t, $t, Rt, Ot, Qt, Wt, nr) {
            const Ft = 32 * c, Pr = 16 * c;
            return this.int16[Ft + 0] = u, this.int16[Ft + 1] = p, this.int16[Ft + 2] = _, this.int16[Ft + 3] = x, this.int16[Ft + 4] = T, this.int16[Ft + 5] = I, this.int16[Ft + 6] = B, this.int16[Ft + 7] = N, this.uint16[Ft + 8] = z, this.uint16[Ft + 9] = $, this.uint16[Ft + 10] = J, this.uint16[Ft + 11] = te, this.uint16[Ft + 12] = ne, this.uint16[Ft + 13] = ue, this.uint16[Ft + 14] = Se, this.uint16[Ft + 15] = Ee, this.uint16[Ft + 16] = Je, this.uint16[Ft + 17] = ze, this.uint16[Ft + 18] = ee, this.uint16[Ft + 19] = ve, this.uint16[Ft + 20] = qe, this.uint16[Ft + 21] = _t, this.uint16[Ft + 22] = $t, this.uint32[Pr + 12] = Rt, this.float32[Pr + 13] = Ot, this.float32[Pr + 14] = Qt, this.uint16[Ft + 30] = Wt, this.uint16[Ft + 31] = nr, c;
          }
        }
        P.prototype.bytesPerElement = 64, Re("StructArrayLayout8i15ui1ul2f2ui64", P);
        class L extends ri {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(c) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, c);
          }
          emplace(c, u) {
            return this.float32[1 * c + 0] = u, c;
          }
        }
        L.prototype.bytesPerElement = 4, Re("StructArrayLayout1f4", L);
        class F extends ri {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(c, u, p) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, c, u, p);
          }
          emplace(c, u, p, _) {
            const x = 3 * c;
            return this.uint16[6 * c + 0] = u, this.float32[x + 1] = p, this.float32[x + 2] = _, c;
          }
        }
        F.prototype.bytesPerElement = 12, Re("StructArrayLayout1ui2f12", F);
        class j extends ri {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(c, u, p) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, c, u, p);
          }
          emplace(c, u, p, _) {
            const x = 4 * c;
            return this.uint32[2 * c + 0] = u, this.uint16[x + 2] = p, this.uint16[x + 3] = _, c;
          }
        }
        j.prototype.bytesPerElement = 8, Re("StructArrayLayout1ul2ui8", j);
        class X extends ri {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(c, u) {
            const p = this.length;
            return this.resize(p + 1), this.emplace(p, c, u);
          }
          emplace(c, u, p) {
            const _ = 2 * c;
            return this.uint16[_ + 0] = u, this.uint16[_ + 1] = p, c;
          }
        }
        X.prototype.bytesPerElement = 4, Re("StructArrayLayout2ui4", X);
        class G extends ri {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(c) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, c);
          }
          emplace(c, u) {
            return this.uint16[1 * c + 0] = u, c;
          }
        }
        G.prototype.bytesPerElement = 2, Re("StructArrayLayout1ui2", G);
        class Q extends ri {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(c, u, p, _) {
            const x = this.length;
            return this.resize(x + 1), this.emplace(x, c, u, p, _);
          }
          emplace(c, u, p, _, x) {
            const T = 4 * c;
            return this.float32[T + 0] = u, this.float32[T + 1] = p, this.float32[T + 2] = _, this.float32[T + 3] = x, c;
          }
        }
        Q.prototype.bytesPerElement = 16, Re("StructArrayLayout4f16", Q);
        class le extends Wn {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get anchorPoint() {
            return new k(this.anchorPointX, this.anchorPointY);
          }
        }
        le.prototype.size = 20;
        class Ae extends a {
          get(c) {
            return new le(this, c);
          }
        }
        Re("CollisionBoxArray", Ae);
        class we extends Wn {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37];
          }
          set placedOrientation(c) {
            this._structArray.uint8[this._pos1 + 37] = c;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38];
          }
          set hidden(c) {
            this._structArray.uint8[this._pos1 + 38] = c;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10];
          }
          set crossTileID(c) {
            this._structArray.uint32[this._pos4 + 10] = c;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22];
          }
        }
        we.prototype.size = 48;
        class Te extends C {
          get(c) {
            return new we(this, c);
          }
        }
        Re("PlacedSymbolArray", Te);
        class Me extends Wn {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12];
          }
          set crossTileID(c) {
            this._structArray.uint32[this._pos4 + 12] = c;
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14];
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30];
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31];
          }
        }
        Me.prototype.size = 64;
        class Ve extends P {
          get(c) {
            return new Me(this, c);
          }
        }
        Re("SymbolInstanceArray", Ve);
        class De extends L {
          getoffsetX(c) {
            return this.float32[1 * c + 0];
          }
        }
        Re("GlyphOffsetArray", De);
        class He extends jo {
          getx(c) {
            return this.int16[3 * c + 0];
          }
          gety(c) {
            return this.int16[3 * c + 1];
          }
          gettileUnitDistanceFromAnchor(c) {
            return this.int16[3 * c + 2];
          }
        }
        Re("SymbolLineVertexArray", He);
        class Ze extends Wn {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0];
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2];
          }
        }
        Ze.prototype.size = 12;
        class Fe extends F {
          get(c) {
            return new Ze(this, c);
          }
        }
        Re("TextAnchorOffsetArray", Fe);
        class it extends Wn {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
        }
        it.prototype.size = 8;
        class bt extends j {
          get(c) {
            return new it(this, c);
          }
        }
        Re("FeatureIndexArray", bt);
        class dt extends pa {
        }
        class Tt extends pa {
        }
        class wt extends pa {
        }
        class ir extends ho {
        }
        class or extends Vo {
        }
        class Vt extends ka {
        }
        class xr extends yh {
        }
        class an extends oc {
        }
        class An extends bh {
        }
        class ni extends v {
        }
        class On extends h {
        }
        class kn extends y {
        }
        class In extends w {
        }
        class En extends X {
        }
        const Nn = pi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Ji } = Nn;
        class yn {
          constructor() {
            let c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            this._forceNewSegmentOnNextPrepare = !1, this.segments = c;
          }
          prepareSegment(c, u, p, _) {
            const x = this.segments[this.segments.length - 1];
            return c > yn.MAX_VERTEX_ARRAY_LENGTH && Dr(`Max vertices per segment is ${yn.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${c}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${yn.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !x || x.vertexLength + c > yn.MAX_VERTEX_ARRAY_LENGTH || x.sortKey !== _ ? this.createNewSegment(u, p, _) : x;
          }
          createNewSegment(c, u, p) {
            const _ = { vertexOffset: c.length, primitiveOffset: u.length, vertexLength: 0, primitiveLength: 0, vaos: {} };
            return p !== void 0 && (_.sortKey = p), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(_), _;
          }
          getOrCreateLatestSegment(c, u, p) {
            return this.prepareSegment(0, c, u, p);
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = !0;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const c of this.segments) for (const u in c.vaos) c.vaos[u].destroy();
          }
          static simpleSegment(c, u, p, _) {
            return new yn([{ vertexOffset: c, primitiveOffset: u, vertexLength: p, primitiveLength: _, vaos: {}, sortKey: 0 }]);
          }
        }
        function as(f, c) {
          return 256 * (f = yt(Math.floor(f), 0, 255)) + yt(Math.floor(c), 0, 255);
        }
        yn.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Re("SegmentVector", yn);
        const Qi = pi([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
        var Na, tu, ru, Rl = { exports: {} }, sf = { exports: {} }, of = { exports: {} }, vh = function() {
          if (ru) return Rl.exports;
          ru = 1;
          var f = (Na || (Na = 1, sf.exports = function(u, p) {
            var _, x, T, I, B, N, z, $;
            for (x = u.length - (_ = 3 & u.length), T = p, B = 3432918353, N = 461845907, $ = 0; $ < x; ) z = 255 & u.charCodeAt($) | (255 & u.charCodeAt(++$)) << 8 | (255 & u.charCodeAt(++$)) << 16 | (255 & u.charCodeAt(++$)) << 24, ++$, T = 27492 + (65535 & (I = 5 * (65535 & (T = (T ^= z = (65535 & (z = (z = (65535 & z) * B + (((z >>> 16) * B & 65535) << 16) & 4294967295) << 15 | z >>> 17)) * N + (((z >>> 16) * N & 65535) << 16) & 4294967295) << 13 | T >>> 19)) + ((5 * (T >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (I >>> 16) & 65535) << 16);
            switch (z = 0, _) {
              case 3:
                z ^= (255 & u.charCodeAt($ + 2)) << 16;
              case 2:
                z ^= (255 & u.charCodeAt($ + 1)) << 8;
              case 1:
                T ^= z = (65535 & (z = (z = (65535 & (z ^= 255 & u.charCodeAt($))) * B + (((z >>> 16) * B & 65535) << 16) & 4294967295) << 15 | z >>> 17)) * N + (((z >>> 16) * N & 65535) << 16) & 4294967295;
            }
            return T ^= u.length, T = 2246822507 * (65535 & (T ^= T >>> 16)) + ((2246822507 * (T >>> 16) & 65535) << 16) & 4294967295, T = 3266489909 * (65535 & (T ^= T >>> 13)) + ((3266489909 * (T >>> 16) & 65535) << 16) & 4294967295, (T ^= T >>> 16) >>> 0;
          }), sf.exports), c = (tu || (tu = 1, of.exports = function(u, p) {
            for (var _, x = u.length, T = p ^ x, I = 0; x >= 4; ) _ = 1540483477 * (65535 & (_ = 255 & u.charCodeAt(I) | (255 & u.charCodeAt(++I)) << 8 | (255 & u.charCodeAt(++I)) << 16 | (255 & u.charCodeAt(++I)) << 24)) + ((1540483477 * (_ >>> 16) & 65535) << 16), T = 1540483477 * (65535 & T) + ((1540483477 * (T >>> 16) & 65535) << 16) ^ (_ = 1540483477 * (65535 & (_ ^= _ >>> 24)) + ((1540483477 * (_ >>> 16) & 65535) << 16)), x -= 4, ++I;
            switch (x) {
              case 3:
                T ^= (255 & u.charCodeAt(I + 2)) << 16;
              case 2:
                T ^= (255 & u.charCodeAt(I + 1)) << 8;
              case 1:
                T = 1540483477 * (65535 & (T ^= 255 & u.charCodeAt(I))) + ((1540483477 * (T >>> 16) & 65535) << 16);
            }
            return T = 1540483477 * (65535 & (T ^= T >>> 13)) + ((1540483477 * (T >>> 16) & 65535) << 16), (T ^= T >>> 15) >>> 0;
          }), of.exports);
          return Rl.exports = f, Rl.exports.murmur3 = f, Rl.exports.murmur2 = c, Rl.exports;
        }(), $o = d(vh);
        class ol {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = !1;
          }
          add(c, u, p, _) {
            this.ids.push(nu(c)), this.positions.push(u, p, _);
          }
          getPositions(c) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const u = nu(c);
            let p = 0, _ = this.ids.length - 1;
            for (; p < _; ) {
              const T = p + _ >> 1;
              this.ids[T] >= u ? _ = T : p = T + 1;
            }
            const x = [];
            for (; this.ids[p] === u; ) x.push({ index: this.positions[3 * p], start: this.positions[3 * p + 1], end: this.positions[3 * p + 2] }), p++;
            return x;
          }
          static serialize(c, u) {
            const p = new Float64Array(c.ids), _ = new Uint32Array(c.positions);
            return $u(p, _, 0, p.length - 1), u && u.push(p.buffer, _.buffer), { ids: p, positions: _ };
          }
          static deserialize(c) {
            const u = new ol();
            return u.ids = c.ids, u.positions = c.positions, u.indexed = !0, u;
          }
        }
        function nu(f) {
          const c = +f;
          return !isNaN(c) && c <= Number.MAX_SAFE_INTEGER ? c : $o(String(f));
        }
        function $u(f, c, u, p) {
          for (; u < p; ) {
            const _ = f[u + p >> 1];
            let x = u - 1, T = p + 1;
            for (; ; ) {
              do
                x++;
              while (f[x] < _);
              do
                T--;
              while (f[T] > _);
              if (x >= T) break;
              $i(f, x, T), $i(c, 3 * x, 3 * T), $i(c, 3 * x + 1, 3 * T + 1), $i(c, 3 * x + 2, 3 * T + 2);
            }
            T - u < p - T ? ($u(f, c, u, T), u = T + 1) : ($u(f, c, T + 1, p), p = T);
          }
        }
        function $i(f, c, u) {
          const p = f[c];
          f[c] = f[u], f[u] = p;
        }
        Re("FeaturePositionMap", ol);
        class gi {
          constructor(c, u) {
            this.gl = c.gl, this.location = u;
          }
        }
        class Eo extends gi {
          constructor(c, u) {
            super(c, u), this.current = 0;
          }
          set(c) {
            this.current !== c && (this.current = c, this.gl.uniform1f(this.location, c));
          }
        }
        class As extends gi {
          constructor(c, u) {
            super(c, u), this.current = [0, 0, 0, 0];
          }
          set(c) {
            c[0] === this.current[0] && c[1] === this.current[1] && c[2] === this.current[2] && c[3] === this.current[3] || (this.current = c, this.gl.uniform4f(this.location, c[0], c[1], c[2], c[3]));
          }
        }
        class rm extends gi {
          constructor(c, u) {
            super(c, u), this.current = hn.transparent;
          }
          set(c) {
            c.r === this.current.r && c.g === this.current.g && c.b === this.current.b && c.a === this.current.a || (this.current = c, this.gl.uniform4f(this.location, c.r, c.g, c.b, c.a));
          }
        }
        const i0 = new Float32Array(16);
        function Tp(f) {
          return [as(255 * f.r, 255 * f.g), as(255 * f.b, 255 * f.a)];
        }
        class af {
          constructor(c, u, p) {
            this.value = c, this.uniformNames = u.map((_) => `u_${_}`), this.type = p;
          }
          setUniform(c, u, p) {
            c.set(p.constantOr(this.value));
          }
          getBinding(c, u, p) {
            return this.type === "color" ? new rm(c, u) : new Eo(c, u);
          }
        }
        class xh {
          constructor(c, u) {
            this.uniformNames = u.map((p) => `u_${p}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
          }
          setConstantPatternPositions(c, u) {
            this.pixelRatioFrom = u.pixelRatio, this.pixelRatioTo = c.pixelRatio, this.patternFrom = u.tlbr, this.patternTo = c.tlbr;
          }
          setUniform(c, u, p, _) {
            const x = _ === "u_pattern_to" ? this.patternTo : _ === "u_pattern_from" ? this.patternFrom : _ === "u_pixel_ratio_to" ? this.pixelRatioTo : _ === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
            x && c.set(x);
          }
          getBinding(c, u, p) {
            return p.substr(0, 9) === "u_pattern" ? new As(c, u) : new Eo(c, u);
          }
        }
        class ac {
          constructor(c, u, p, _) {
            this.expression = c, this.type = p, this.maxValue = 0, this.paintVertexAttributes = u.map((x) => ({ name: `a_${x}`, type: "Float32", components: p === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new _();
          }
          populatePaintArray(c, u, p, _, x) {
            const T = this.paintVertexArray.length, I = this.expression.evaluate(new Br(0), u, {}, _, [], x);
            this.paintVertexArray.resize(c), this._setPaintValue(T, c, I);
          }
          updatePaintArray(c, u, p, _) {
            const x = this.expression.evaluate({ zoom: 0 }, p, _);
            this._setPaintValue(c, u, x);
          }
          _setPaintValue(c, u, p) {
            if (this.type === "color") {
              const _ = Tp(p);
              for (let x = c; x < u; x++) this.paintVertexArray.emplace(x, _[0], _[1]);
            } else {
              for (let _ = c; _ < u; _++) this.paintVertexArray.emplace(_, p);
              this.maxValue = Math.max(this.maxValue, Math.abs(p));
            }
          }
          upload(c) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = c.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class Ks {
          constructor(c, u, p, _, x, T) {
            this.expression = c, this.uniformNames = u.map((I) => `u_${I}_t`), this.type = p, this.useIntegerZoom = _, this.zoom = x, this.maxValue = 0, this.paintVertexAttributes = u.map((I) => ({ name: `a_${I}`, type: "Float32", components: p === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new T();
          }
          populatePaintArray(c, u, p, _, x) {
            const T = this.expression.evaluate(new Br(this.zoom), u, {}, _, [], x), I = this.expression.evaluate(new Br(this.zoom + 1), u, {}, _, [], x), B = this.paintVertexArray.length;
            this.paintVertexArray.resize(c), this._setPaintValue(B, c, T, I);
          }
          updatePaintArray(c, u, p, _) {
            const x = this.expression.evaluate({ zoom: this.zoom }, p, _), T = this.expression.evaluate({ zoom: this.zoom + 1 }, p, _);
            this._setPaintValue(c, u, x, T);
          }
          _setPaintValue(c, u, p, _) {
            if (this.type === "color") {
              const x = Tp(p), T = Tp(_);
              for (let I = c; I < u; I++) this.paintVertexArray.emplace(I, x[0], x[1], T[0], T[1]);
            } else {
              for (let x = c; x < u; x++) this.paintVertexArray.emplace(x, p, _);
              this.maxValue = Math.max(this.maxValue, Math.abs(p), Math.abs(_));
            }
          }
          upload(c) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = c.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(c, u) {
            const p = this.useIntegerZoom ? Math.floor(u.zoom) : u.zoom, _ = yt(this.expression.interpolationFactor(p, this.zoom, this.zoom + 1), 0, 1);
            c.set(_);
          }
          getBinding(c, u, p) {
            return new Eo(c, u);
          }
        }
        class lc {
          constructor(c, u, p, _, x, T) {
            this.expression = c, this.type = u, this.useIntegerZoom = p, this.zoom = _, this.layerId = T, this.zoomInPaintVertexArray = new x(), this.zoomOutPaintVertexArray = new x();
          }
          populatePaintArray(c, u, p) {
            const _ = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(c), this.zoomOutPaintVertexArray.resize(c), this._setPaintValues(_, c, u.patterns && u.patterns[this.layerId], p);
          }
          updatePaintArray(c, u, p, _, x) {
            this._setPaintValues(c, u, p.patterns && p.patterns[this.layerId], x);
          }
          _setPaintValues(c, u, p, _) {
            if (!_ || !p) return;
            const { min: x, mid: T, max: I } = p, B = _[x], N = _[T], z = _[I];
            if (B && N && z) for (let $ = c; $ < u; $++) this.zoomInPaintVertexArray.emplace($, N.tl[0], N.tl[1], N.br[0], N.br[1], B.tl[0], B.tl[1], B.br[0], B.br[1], N.pixelRatio, B.pixelRatio), this.zoomOutPaintVertexArray.emplace($, N.tl[0], N.tl[1], N.br[0], N.br[1], z.tl[0], z.tl[1], z.br[0], z.br[1], N.pixelRatio, z.pixelRatio);
          }
          upload(c) {
            this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = c.createVertexBuffer(this.zoomInPaintVertexArray, Qi.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = c.createVertexBuffer(this.zoomOutPaintVertexArray, Qi.members, this.expression.isStateDependent));
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
          }
        }
        class Sp {
          constructor(c, u, p) {
            this.binders = {}, this._buffers = [];
            const _ = [];
            for (const x in c.paint._values) {
              if (!p(x)) continue;
              const T = c.paint.get(x);
              if (!(T instanceof Li && os(T.property.specification))) continue;
              const I = Ep(x, c.type), B = T.value, N = T.property.specification.type, z = T.property.useIntegerZoom, $ = T.property.specification["property-type"], J = $ === "cross-faded" || $ === "cross-faded-data-driven";
              if (B.kind === "constant") this.binders[x] = J ? new xh(B.value, I) : new af(B.value, I, N), _.push(`/u_${x}`);
              else if (B.kind === "source" || J) {
                const te = Cp(x, N, "source");
                this.binders[x] = J ? new lc(B, N, z, u, te, c.id) : new ac(B, I, N, te), _.push(`/a_${x}`);
              } else {
                const te = Cp(x, N, "composite");
                this.binders[x] = new Ks(B, I, N, z, u, te), _.push(`/z_${x}`);
              }
            }
            this.cacheKey = _.sort().join("");
          }
          getMaxValue(c) {
            const u = this.binders[c];
            return u instanceof ac || u instanceof Ks ? u.maxValue : 0;
          }
          populatePaintArrays(c, u, p, _, x) {
            for (const T in this.binders) {
              const I = this.binders[T];
              (I instanceof ac || I instanceof Ks || I instanceof lc) && I.populatePaintArray(c, u, p, _, x);
            }
          }
          setConstantPatternPositions(c, u) {
            for (const p in this.binders) {
              const _ = this.binders[p];
              _ instanceof xh && _.setConstantPatternPositions(c, u);
            }
          }
          updatePaintArrays(c, u, p, _, x) {
            let T = !1;
            for (const I in c) {
              const B = u.getPositions(I);
              for (const N of B) {
                const z = p.feature(N.index);
                for (const $ in this.binders) {
                  const J = this.binders[$];
                  if ((J instanceof ac || J instanceof Ks || J instanceof lc) && J.expression.isStateDependent === !0) {
                    const te = _.paint.get($);
                    J.expression = te.value, J.updatePaintArray(N.start, N.end, z, c[I], x), T = !0;
                  }
                }
              }
            }
            return T;
          }
          defines() {
            const c = [];
            for (const u in this.binders) {
              const p = this.binders[u];
              (p instanceof af || p instanceof xh) && c.push(...p.uniformNames.map((_) => `#define HAS_UNIFORM_${_}`));
            }
            return c;
          }
          getBinderAttributes() {
            const c = [];
            for (const u in this.binders) {
              const p = this.binders[u];
              if (p instanceof ac || p instanceof Ks) for (let _ = 0; _ < p.paintVertexAttributes.length; _++) c.push(p.paintVertexAttributes[_].name);
              else if (p instanceof lc) for (let _ = 0; _ < Qi.members.length; _++) c.push(Qi.members[_].name);
            }
            return c;
          }
          getBinderUniforms() {
            const c = [];
            for (const u in this.binders) {
              const p = this.binders[u];
              if (p instanceof af || p instanceof xh || p instanceof Ks) for (const _ of p.uniformNames) c.push(_);
            }
            return c;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(c, u) {
            const p = [];
            for (const _ in this.binders) {
              const x = this.binders[_];
              if (x instanceof af || x instanceof xh || x instanceof Ks) {
                for (const T of x.uniformNames) if (u[T]) {
                  const I = x.getBinding(c, u[T], T);
                  p.push({ name: T, property: _, binding: I });
                }
              }
            }
            return p;
          }
          setUniforms(c, u, p, _) {
            for (const { name: x, property: T, binding: I } of u) this.binders[T].setUniform(I, _, p.get(T), x);
          }
          updatePaintBuffers(c) {
            this._buffers = [];
            for (const u in this.binders) {
              const p = this.binders[u];
              if (c && p instanceof lc) {
                const _ = c.fromScale === 2 ? p.zoomInPaintVertexBuffer : p.zoomOutPaintVertexBuffer;
                _ && this._buffers.push(_);
              } else (p instanceof ac || p instanceof Ks) && p.paintVertexBuffer && this._buffers.push(p.paintVertexBuffer);
            }
          }
          upload(c) {
            for (const u in this.binders) {
              const p = this.binders[u];
              (p instanceof ac || p instanceof Ks || p instanceof lc) && p.upload(c);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const c in this.binders) {
              const u = this.binders[c];
              (u instanceof ac || u instanceof Ks || u instanceof lc) && u.destroy();
            }
          }
        }
        class iu {
          constructor(c, u) {
            let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : () => !0;
            this.programConfigurations = {};
            for (const _ of c) this.programConfigurations[_.id] = new Sp(_, u, p);
            this.needsUpload = !1, this._featureMap = new ol(), this._bufferOffset = 0;
          }
          populatePaintArrays(c, u, p, _, x, T) {
            for (const I in this.programConfigurations) this.programConfigurations[I].populatePaintArrays(c, u, _, x, T);
            u.id !== void 0 && this._featureMap.add(u.id, p, this._bufferOffset, c), this._bufferOffset = c, this.needsUpload = !0;
          }
          updatePaintArrays(c, u, p, _) {
            for (const x of p) this.needsUpload = this.programConfigurations[x.id].updatePaintArrays(c, this._featureMap, u, x, _) || this.needsUpload;
          }
          get(c) {
            return this.programConfigurations[c];
          }
          upload(c) {
            if (this.needsUpload) {
              for (const u in this.programConfigurations) this.programConfigurations[u].upload(c);
              this.needsUpload = !1;
            }
          }
          destroy() {
            for (const c in this.programConfigurations) this.programConfigurations[c].destroy();
          }
        }
        function Ep(f, c) {
          return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[f] || [f.replace(`${c}-`, "").replace(/-/g, "_")];
        }
        function Cp(f, c, u) {
          const p = { color: { source: ka, composite: Q }, number: { source: L, composite: ka } }, _ = function(x) {
            return { "line-pattern": { source: xr, composite: xr }, "fill-pattern": { source: xr, composite: xr }, "fill-extrusion-pattern": { source: xr, composite: xr } }[x];
          }(f);
          return _ && _[u] || p[c][u];
        }
        Re("ConstantBinder", af), Re("CrossFadedConstantBinder", xh), Re("SourceExpressionBinder", ac), Re("CrossFadedCompositeBinder", lc), Re("CompositeExpressionBinder", Ks), Re("ProgramConfiguration", Sp, { omit: ["_buffers"] }), Re("ProgramConfigurationSet", iu);
        const lf = Math.pow(2, 14) - 1, Ix = -lf - 1;
        function cf(f) {
          const c = ce / f.extent, u = f.loadGeometry();
          for (let p = 0; p < u.length; p++) {
            const _ = u[p];
            for (let x = 0; x < _.length; x++) {
              const T = _[x], I = Math.round(T.x * c), B = Math.round(T.y * c);
              T.x = yt(I, Ix, lf), T.y = yt(B, Ix, lf), (I < T.x || I > T.x + 1 || B < T.y || B > T.y + 1) && Dr("Geometry exceeds allowed extent, reduce your vector tile buffer size");
            }
          }
          return u;
        }
        function uf(f, c) {
          return { type: f.type, id: f.id, properties: f.properties, geometry: c ? cf(f) : [] };
        }
        const Mx = -32768;
        function AP(f, c, u, p, _) {
          f.emplaceBack(Mx + 8 * c + p, Mx + 8 * u + _);
        }
        class s0 {
          constructor(c) {
            this.zoom = c.zoom, this.globalState = c.globalState, this.overscaling = c.overscaling, this.layers = c.layers, this.layerIds = this.layers.map((u) => u.id), this.index = c.index, this.hasPattern = !1, this.layoutVertexArray = new Tt(), this.indexArray = new In(), this.segments = new yn(), this.programConfigurations = new iu(c.layers, c.zoom), this.stateDependentLayerIds = this.layers.filter((u) => u.isStateDependent()).map((u) => u.id);
          }
          populate(c, u, p) {
            const _ = this.layers[0], x = [];
            let T = null, I = !1, B = _.type === "heatmap";
            if (_.type === "circle") {
              const z = _;
              T = z.layout.get("circle-sort-key"), I = !T.isConstant(), B = B || z.paint.get("circle-pitch-alignment") === "map";
            }
            const N = B ? u.subdivisionGranularity.circle : 1;
            for (const { feature: z, id: $, index: J, sourceLayerIndex: te } of c) {
              const ne = this.layers[0]._featureFilter.needGeometry, ue = uf(z, ne);
              if (!this.layers[0]._featureFilter.filter(new Br(this.zoom, { globalState: this.globalState }), ue, p)) continue;
              const Se = I ? T.evaluate(ue, {}, p) : void 0, Ee = { id: $, properties: z.properties, type: z.type, sourceLayerIndex: te, index: J, geometry: ne ? ue.geometry : cf(z), patterns: {}, sortKey: Se };
              x.push(Ee);
            }
            I && x.sort((z, $) => z.sortKey - $.sortKey);
            for (const z of x) {
              const { geometry: $, index: J, sourceLayerIndex: te } = z, ne = c[J].feature;
              this.addFeature(z, $, J, p, N), u.featureIndex.insert(ne, $, J, te, this.index);
            }
          }
          update(c, u, p) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(c, u, this.stateDependentLayers, p);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(c) {
            this.uploaded || (this.layoutVertexBuffer = c.createVertexBuffer(this.layoutVertexArray, Ji), this.indexBuffer = c.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(c), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(c, u, p, _) {
            let x = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1, T;
            switch (x) {
              case 1:
                T = [0, 7];
                break;
              case 3:
                T = [0, 2, 5, 7];
                break;
              case 5:
                T = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                T = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${x}; valid values are 1, 3, 5, 7.`);
            }
            const I = T.length;
            for (const B of u) for (const N of B) {
              const z = N.x, $ = N.y;
              if (z < 0 || z >= ce || $ < 0 || $ >= ce) continue;
              const J = this.segments.prepareSegment(I * I, this.layoutVertexArray, this.indexArray, c.sortKey), te = J.vertexLength;
              for (let ne = 0; ne < I; ne++) for (let ue = 0; ue < I; ue++) AP(this.layoutVertexArray, z, $, T[ue], T[ne]);
              for (let ne = 0; ne < I - 1; ne++) for (let ue = 0; ue < I - 1; ue++) {
                const Se = te + ne * I + ue, Ee = te + (ne + 1) * I + ue;
                this.indexArray.emplaceBack(Se, Ee + 1, Se + 1), this.indexArray.emplaceBack(Se, Ee, Ee + 1);
              }
              J.vertexLength += I * I, J.primitiveLength += (I - 1) * (I - 1) * 2;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, c, p, {}, _);
          }
        }
        function Px(f, c) {
          for (let u = 0; u < f.length; u++) if (od(c, f[u])) return !0;
          for (let u = 0; u < c.length; u++) if (od(f, c[u])) return !0;
          return !!o0(f, c);
        }
        function TP(f, c, u) {
          return !!od(f, c) || !!a0(c, f, u);
        }
        function Rx(f, c) {
          if (f.length === 1) return Lx(c, f[0]);
          for (let u = 0; u < c.length; u++) {
            const p = c[u];
            for (let _ = 0; _ < p.length; _++) if (od(f, p[_])) return !0;
          }
          for (let u = 0; u < f.length; u++) if (Lx(c, f[u])) return !0;
          for (let u = 0; u < c.length; u++) if (o0(f, c[u])) return !0;
          return !1;
        }
        function SP(f, c, u) {
          if (f.length > 1) {
            if (o0(f, c)) return !0;
            for (let p = 0; p < c.length; p++) if (a0(c[p], f, u)) return !0;
          }
          for (let p = 0; p < f.length; p++) if (a0(f[p], c, u)) return !0;
          return !1;
        }
        function o0(f, c) {
          if (f.length === 0 || c.length === 0) return !1;
          for (let u = 0; u < f.length - 1; u++) {
            const p = f[u], _ = f[u + 1];
            for (let x = 0; x < c.length - 1; x++) if (EP(p, _, c[x], c[x + 1])) return !0;
          }
          return !1;
        }
        function EP(f, c, u, p) {
          return Tr(f, u, p) !== Tr(c, u, p) && Tr(f, c, u) !== Tr(f, c, p);
        }
        function a0(f, c, u) {
          const p = u * u;
          if (c.length === 1) return f.distSqr(c[0]) < p;
          for (let _ = 1; _ < c.length; _++) if (Bx(f, c[_ - 1], c[_]) < p) return !0;
          return !1;
        }
        function Bx(f, c, u) {
          const p = c.distSqr(u);
          if (p === 0) return f.distSqr(c);
          const _ = ((f.x - c.x) * (u.x - c.x) + (f.y - c.y) * (u.y - c.y)) / p;
          return f.distSqr(_ < 0 ? c : _ > 1 ? u : u.sub(c)._mult(_)._add(c));
        }
        function Lx(f, c) {
          let u, p, _, x = !1;
          for (let T = 0; T < f.length; T++) {
            u = f[T];
            for (let I = 0, B = u.length - 1; I < u.length; B = I++) p = u[I], _ = u[B], p.y > c.y != _.y > c.y && c.x < (_.x - p.x) * (c.y - p.y) / (_.y - p.y) + p.x && (x = !x);
          }
          return x;
        }
        function od(f, c) {
          let u = !1;
          for (let p = 0, _ = f.length - 1; p < f.length; _ = p++) {
            const x = f[p], T = f[_];
            x.y > c.y != T.y > c.y && c.x < (T.x - x.x) * (c.y - x.y) / (T.y - x.y) + x.x && (u = !u);
          }
          return u;
        }
        function CP(f, c, u) {
          const p = u[0], _ = u[2];
          if (f.x < p.x && c.x < p.x || f.x > _.x && c.x > _.x || f.y < p.y && c.y < p.y || f.y > _.y && c.y > _.y) return !1;
          const x = Tr(f, c, u[0]);
          return x !== Tr(f, c, u[1]) || x !== Tr(f, c, u[2]) || x !== Tr(f, c, u[3]);
        }
        function Ip(f, c, u) {
          const p = c.paint.get(f).value;
          return p.kind === "constant" ? p.value : u.programConfigurations.get(c.id).getMaxValue(f);
        }
        function nm(f) {
          return Math.sqrt(f[0] * f[0] + f[1] * f[1]);
        }
        function im(f, c, u, p, _) {
          if (!c[0] && !c[1]) return f;
          const x = k.convert(c)._mult(_);
          u === "viewport" && x._rotate(-p);
          const T = [];
          for (let I = 0; I < f.length; I++) T.push(f[I].sub(x));
          return T;
        }
        let Ox, kx;
        Re("CircleBucket", s0, { omit: ["layers"] });
        var IP = { get paint() {
          return kx = kx || new Ei({ "circle-radius": new Ir(Ge.paint_circle["circle-radius"]), "circle-color": new Ir(Ge.paint_circle["circle-color"]), "circle-blur": new Ir(Ge.paint_circle["circle-blur"]), "circle-opacity": new Ir(Ge.paint_circle["circle-opacity"]), "circle-translate": new fr(Ge.paint_circle["circle-translate"]), "circle-translate-anchor": new fr(Ge.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new fr(Ge.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new fr(Ge.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Ir(Ge.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Ir(Ge.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Ir(Ge.paint_circle["circle-stroke-opacity"]) });
        }, get layout() {
          return Ox = Ox || new Ei({ "circle-sort-key": new Ir(Ge.layout_circle["circle-sort-key"]) });
        } };
        class MP extends ki {
          constructor(c) {
            super(c, IP);
          }
          createBucket(c) {
            return new s0(c);
          }
          queryRadius(c) {
            const u = c;
            return Ip("circle-radius", this, u) + Ip("circle-stroke-width", this, u) + nm(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature(c) {
            let { queryGeometry: u, feature: p, featureState: _, geometry: x, transform: T, pixelsToTileUnits: I, unwrappedTileID: B, getElevation: N } = c;
            const z = im(u, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -T.bearingInRadians, I), $ = this.paint.get("circle-radius").evaluate(p, _) + this.paint.get("circle-stroke-width").evaluate(p, _), J = this.paint.get("circle-pitch-alignment") === "map", te = J ? z : function(ue, Se, Ee, Je) {
              return ue.map((ze) => Nx(ze, Se, Ee, Je));
            }(z, T, B, N), ne = J ? $ * I : $;
            for (const ue of x) for (const Se of ue) {
              const Ee = J ? Se : Nx(Se, T, B, N);
              let Je = ne;
              const ze = T.projectTileCoordinates(Se.x, Se.y, B, N).signedDistanceFromCamera;
              if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? Je *= ze / T.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (Je *= T.cameraToCenterDistance / ze), TP(te, Ee, Je)) return !0;
            }
            return !1;
          }
        }
        function Nx(f, c, u, p) {
          const _ = c.projectTileCoordinates(f.x, f.y, u, p).point;
          return new k((0.5 * _.x + 0.5) * c.width, (0.5 * -_.y + 0.5) * c.height);
        }
        class Dx extends s0 {
        }
        let Fx;
        Re("HeatmapBucket", Dx, { omit: ["layers"] });
        var PP = { get paint() {
          return Fx = Fx || new Ei({ "heatmap-radius": new Ir(Ge.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Ir(Ge.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new fr(Ge.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Oi(Ge.paint_heatmap["heatmap-color"]), "heatmap-opacity": new fr(Ge.paint_heatmap["heatmap-opacity"]) });
        } };
        function l0(f, c, u, p) {
          let { width: _, height: x } = c;
          if (p) {
            if (p instanceof Uint8ClampedArray) p = new Uint8Array(p.buffer);
            else if (p.length !== _ * x * u) throw new RangeError(`mismatched image size. expected: ${p.length} but got: ${_ * x * u}`);
          } else p = new Uint8Array(_ * x * u);
          return f.width = _, f.height = x, f.data = p, f;
        }
        function Ux(f, c, u) {
          let { width: p, height: _ } = c;
          if (p === f.width && _ === f.height) return;
          const x = l0({}, { width: p, height: _ }, u);
          c0(f, x, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(f.width, p), height: Math.min(f.height, _) }, u), f.width = p, f.height = _, f.data = x.data;
        }
        function c0(f, c, u, p, _, x) {
          if (_.width === 0 || _.height === 0) return c;
          if (_.width > f.width || _.height > f.height || u.x > f.width - _.width || u.y > f.height - _.height) throw new RangeError("out of range source coordinates for image copy");
          if (_.width > c.width || _.height > c.height || p.x > c.width - _.width || p.y > c.height - _.height) throw new RangeError("out of range destination coordinates for image copy");
          const T = f.data, I = c.data;
          if (T === I) throw new Error("srcData equals dstData, so image is already copied");
          for (let B = 0; B < _.height; B++) {
            const N = ((u.y + B) * f.width + u.x) * x, z = ((p.y + B) * c.width + p.x) * x;
            for (let $ = 0; $ < _.width * x; $++) I[z + $] = T[N + $];
          }
          return c;
        }
        class Mp {
          constructor(c, u) {
            l0(this, c, 1, u);
          }
          resize(c) {
            Ux(this, c, 1);
          }
          clone() {
            return new Mp({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(c, u, p, _, x) {
            c0(c, u, p, _, x, 1);
          }
        }
        class ga {
          constructor(c, u) {
            l0(this, c, 4, u);
          }
          resize(c) {
            Ux(this, c, 4);
          }
          replace(c, u) {
            u ? this.data.set(c) : this.data = c instanceof Uint8ClampedArray ? new Uint8Array(c.buffer) : c;
          }
          clone() {
            return new ga({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(c, u, p, _, x) {
            c0(c, u, p, _, x, 4);
          }
          setPixel(c, u, p) {
            const _ = 4 * (c * this.width + u);
            this.data[_ + 0] = Math.round(255 * p.r / p.a), this.data[_ + 1] = Math.round(255 * p.g / p.a), this.data[_ + 2] = Math.round(255 * p.b / p.a), this.data[_ + 3] = Math.round(255 * p.a);
          }
        }
        function zx(f) {
          const c = {}, u = f.resolution || 256, p = f.clips ? f.clips.length : 1, _ = f.image || new ga({ width: u, height: p });
          if (Math.log(u) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${u}`);
          const x = (T, I, B) => {
            c[f.evaluationKey] = B;
            const N = f.expression.evaluate(c);
            _.setPixel(T / 4 / u, I / 4, N);
          };
          if (f.clips) for (let T = 0, I = 0; T < p; ++T, I += 4 * u) for (let B = 0, N = 0; B < u; B++, N += 4) {
            const z = B / (u - 1), { start: $, end: J } = f.clips[T];
            x(I, N, $ * (1 - z) + J * z);
          }
          else for (let T = 0, I = 0; T < u; T++, I += 4) x(0, I, T / (u - 1));
          return _;
        }
        Re("AlphaImage", Mp), Re("RGBAImage", ga);
        const u0 = "big-fb";
        class RP extends ki {
          createBucket(c) {
            return new Dx(c);
          }
          constructor(c) {
            super(c, PP), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(c) {
            c === "heatmap-color" && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = zx({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbos.has(u0) && this.heatmapFbos.delete(u0);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            return !1;
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
          }
        }
        let jx;
        var BP = { get paint() {
          return jx = jx || new Ei({ "hillshade-illumination-direction": new fr(Ge.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-altitude": new fr(Ge.paint_hillshade["hillshade-illumination-altitude"]), "hillshade-illumination-anchor": new fr(Ge.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new fr(Ge.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new fr(Ge.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new fr(Ge.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new fr(Ge.paint_hillshade["hillshade-accent-color"]), "hillshade-method": new fr(Ge.paint_hillshade["hillshade-method"]) });
        } };
        class LP extends ki {
          constructor(c) {
            super(c, BP), this.recalculate({ zoom: 0, zoomHistory: {} }, void 0);
          }
          getIlluminationProperties() {
            let c = this.paint.get("hillshade-illumination-direction").values, u = this.paint.get("hillshade-illumination-altitude").values, p = this.paint.get("hillshade-highlight-color").values, _ = this.paint.get("hillshade-shadow-color").values;
            const x = Math.max(c.length, u.length, p.length, _.length);
            c = c.concat(Array(x - c.length).fill(c.at(-1))), u = u.concat(Array(x - u.length).fill(u.at(-1))), p = p.concat(Array(x - p.length).fill(p.at(-1))), _ = _.concat(Array(x - _.length).fill(_.at(-1)));
            const T = u.map(nn);
            return { directionRadians: c.map(nn), altitudeRadians: T, shadowColor: _, highlightColor: p };
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
          }
        }
        let Vx;
        var OP = { get paint() {
          return Vx = Vx || new Ei({ "color-relief-opacity": new fr(Ge["paint_color-relief"]["color-relief-opacity"]), "color-relief-color": new Oi(Ge["paint_color-relief"]["color-relief-color"]) });
        } };
        class h0 {
          constructor(c, u, p, _) {
            this.context = c, this.format = p, this.texture = c.gl.createTexture(), this.update(u, _);
          }
          update(c, u, p) {
            const { width: _, height: x } = c, T = !(this.size && this.size[0] === _ && this.size[1] === x || p), { context: I } = this, { gl: B } = I;
            if (this.useMipmap = !!(u && u.useMipmap), B.bindTexture(B.TEXTURE_2D, this.texture), I.pixelStoreUnpackFlipY.set(!1), I.pixelStoreUnpack.set(1), I.pixelStoreUnpackPremultiplyAlpha.set(this.format === B.RGBA && (!u || u.premultiply !== !1)), T) this.size = [_, x], c instanceof HTMLImageElement || c instanceof HTMLCanvasElement || c instanceof HTMLVideoElement || c instanceof ImageData || mr(c) ? B.texImage2D(B.TEXTURE_2D, 0, this.format, this.format, B.UNSIGNED_BYTE, c) : B.texImage2D(B.TEXTURE_2D, 0, this.format, _, x, 0, this.format, B.UNSIGNED_BYTE, c.data);
            else {
              const { x: N, y: z } = p || { x: 0, y: 0 };
              c instanceof HTMLImageElement || c instanceof HTMLCanvasElement || c instanceof HTMLVideoElement || c instanceof ImageData || mr(c) ? B.texSubImage2D(B.TEXTURE_2D, 0, N, z, B.RGBA, B.UNSIGNED_BYTE, c) : B.texSubImage2D(B.TEXTURE_2D, 0, N, z, _, x, B.RGBA, B.UNSIGNED_BYTE, c.data);
            }
            this.useMipmap && this.isSizePowerOfTwo() && B.generateMipmap(B.TEXTURE_2D), I.pixelStoreUnpackFlipY.setDefault(), I.pixelStoreUnpack.setDefault(), I.pixelStoreUnpackPremultiplyAlpha.setDefault();
          }
          bind(c, u, p) {
            const { context: _ } = this, { gl: x } = _;
            x.bindTexture(x.TEXTURE_2D, this.texture), p !== x.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (p = x.LINEAR), c !== this.filter && (x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MAG_FILTER, c), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MIN_FILTER, p || c), this.filter = c), u !== this.wrap && (x.texParameteri(x.TEXTURE_2D, x.TEXTURE_WRAP_S, u), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_WRAP_T, u), this.wrap = u);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            const { gl: c } = this.context;
            c.deleteTexture(this.texture), this.texture = null;
          }
        }
        class $x {
          constructor(c, u, p) {
            let _ = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1, x = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1, T = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1, I = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 0;
            if (this.uid = c, u.height !== u.width) throw new RangeError("DEM tiles must be square");
            if (p && !["mapbox", "terrarium", "custom"].includes(p)) return void Dr(`"${p}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = u.height;
            const B = this.dim = u.height - 2;
            switch (this.data = new Uint32Array(u.data.buffer), p) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = _, this.greenFactor = x, this.blueFactor = T, this.baseShift = I;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
            }
            for (let N = 0; N < B; N++) this.data[this._idx(-1, N)] = this.data[this._idx(0, N)], this.data[this._idx(B, N)] = this.data[this._idx(B - 1, N)], this.data[this._idx(N, -1)] = this.data[this._idx(N, 0)], this.data[this._idx(N, B)] = this.data[this._idx(N, B - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(B, -1)] = this.data[this._idx(B - 1, 0)], this.data[this._idx(-1, B)] = this.data[this._idx(0, B - 1)], this.data[this._idx(B, B)] = this.data[this._idx(B - 1, B - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let N = 0; N < B; N++) for (let z = 0; z < B; z++) {
              const $ = this.get(N, z);
              $ > this.max && (this.max = $), $ < this.min && (this.min = $);
            }
          }
          get(c, u) {
            const p = new Uint8Array(this.data.buffer), _ = 4 * this._idx(c, u);
            return this.unpack(p[_], p[_ + 1], p[_ + 2]);
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
          }
          _idx(c, u) {
            if (c < -1 || c >= this.dim + 1 || u < -1 || u >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (u + 1) * this.stride + (c + 1);
          }
          unpack(c, u, p) {
            return c * this.redFactor + u * this.greenFactor + p * this.blueFactor - this.baseShift;
          }
          pack(c) {
            return qx(c, this.getUnpackVector());
          }
          getPixels() {
            return new ga({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
          }
          backfillBorder(c, u, p) {
            if (this.dim !== c.dim) throw new Error("dem dimension mismatch");
            let _ = u * this.dim, x = u * this.dim + this.dim, T = p * this.dim, I = p * this.dim + this.dim;
            switch (u) {
              case -1:
                _ = x - 1;
                break;
              case 1:
                x = _ + 1;
            }
            switch (p) {
              case -1:
                T = I - 1;
                break;
              case 1:
                I = T + 1;
            }
            const B = -u * this.dim, N = -p * this.dim;
            for (let z = T; z < I; z++) for (let $ = _; $ < x; $++) this.data[this._idx($, z)] = c.data[this._idx($ + B, z + N)];
          }
        }
        function qx(f, c) {
          const u = c[0], p = c[1], _ = c[2], x = c[3], T = Math.min(u, p, _), I = Math.round((f + x) / T);
          return { r: Math.floor(I * T / u) % 256, g: Math.floor(I * T / p) % 256, b: Math.floor(I * T / _) % 256 };
        }
        Re("DEMData", $x);
        class kP extends ki {
          constructor(c) {
            super(c, OP);
          }
          _createColorRamp(c) {
            const u = { elevationStops: [], colorStops: [] }, p = this._transitionablePaint._values["color-relief-color"].value.expression;
            if (p instanceof Wc && p._styleExpression.expression instanceof is) {
              this.colorRampExpression = p;
              const T = p._styleExpression.expression;
              u.elevationStops = T.labels, u.colorStops = [];
              for (const I of u.elevationStops) u.colorStops.push(T.evaluate({ globals: { elevation: I } }));
            }
            if (u.elevationStops.length < 1 && (u.elevationStops = [0], u.colorStops = [hn.transparent]), u.elevationStops.length < 2 && (u.elevationStops.push(u.elevationStops[0] + 1), u.colorStops.push(u.colorStops[0])), u.elevationStops.length <= c) return u;
            const _ = { elevationStops: [], colorStops: [] }, x = (u.elevationStops.length - 1) / (c - 1);
            for (let T = 0; T < u.elevationStops.length - 0.5; T += x) _.elevationStops.push(u.elevationStops[Math.round(T)]), _.colorStops.push(u.colorStops[Math.round(T)]);
            return Dr(`Too many colors in specification of ${this.id} color-relief layer, may not render properly.`), _;
          }
          _colorRampChanged() {
            return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression;
          }
          getColorRampTextures(c, u, p) {
            if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
            const _ = this._createColorRamp(u), x = new ga({ width: _.colorStops.length, height: 1 }), T = new ga({ width: _.colorStops.length, height: 1 });
            for (let I = 0; I < _.elevationStops.length; I++) {
              const B = qx(_.elevationStops[I], p);
              T.setPixel(0, I, new hn(B.r / 255, B.g / 255, B.b / 255, 1)), x.setPixel(0, I, _.colorStops[I]);
            }
            return this.colorRampTextures = { elevationTexture: new h0(c, T, c.gl.RGBA), colorTexture: new h0(c, x, c.gl.RGBA) }, this.colorRampTextures;
          }
          hasOffscreenPass() {
            return this.visibility !== "none" && !!this.colorRampTextures;
          }
        }
        const NP = pi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: DP } = NP;
        function f0(f, c, u) {
          const p = u.patternDependencies;
          let _ = !1;
          for (const x of c) {
            const T = x.paint.get(`${f}-pattern`);
            T.isConstant() || (_ = !0);
            const I = T.constantOr(null);
            I && (_ = !0, p[I.to] = !0, p[I.from] = !0);
          }
          return _;
        }
        function d0(f, c, u, p, _) {
          const x = _.patternDependencies;
          for (const T of c) {
            const I = T.paint.get(`${f}-pattern`).value;
            if (I.kind !== "constant") {
              let B = I.evaluate({ zoom: p - 1 }, u, {}, _.availableImages), N = I.evaluate({ zoom: p }, u, {}, _.availableImages), z = I.evaluate({ zoom: p + 1 }, u, {}, _.availableImages);
              B = B && B.name ? B.name : B, N = N && N.name ? N.name : N, z = z && z.name ? z.name : z, x[B] = !0, x[N] = !0, x[z] = !0, u.patterns[T.id] = { min: B, mid: N, max: z };
            }
          }
          return u;
        }
        function Gx(f, c, u, p, _) {
          let x;
          if (_ === function(T, I, B, N) {
            let z = 0;
            for (let $ = I, J = B - N; $ < B; $ += N) z += (T[J] - T[$]) * (T[$ + 1] + T[J + 1]), J = $;
            return z;
          }(f, c, u, p) > 0) for (let T = c; T < u; T += p) x = Zx(T / p | 0, f[T], f[T + 1], x);
          else for (let T = u - p; T >= c; T -= p) x = Zx(T / p | 0, f[T], f[T + 1], x);
          return x && ad(x, x.next) && (Lp(x), x = x.next), x;
        }
        function hf(f, c) {
          if (!f) return f;
          c || (c = f);
          let u, p = f;
          do
            if (u = !1, p.steiner || !ad(p, p.next) && es(p.prev, p, p.next) !== 0) p = p.next;
            else {
              if (Lp(p), p = c = p.prev, p === p.next) break;
              u = !0;
            }
          while (u || p !== c);
          return c;
        }
        function Pp(f, c, u, p, _, x, T) {
          if (!f) return;
          !T && x && function(B, N, z, $) {
            let J = B;
            do
              J.z === 0 && (J.z = p0(J.x, J.y, N, z, $)), J.prevZ = J.prev, J.nextZ = J.next, J = J.next;
            while (J !== B);
            J.prevZ.nextZ = null, J.prevZ = null, function(te) {
              let ne, ue = 1;
              do {
                let Se, Ee = te;
                te = null;
                let Je = null;
                for (ne = 0; Ee; ) {
                  ne++;
                  let ze = Ee, ee = 0;
                  for (let qe = 0; qe < ue && (ee++, ze = ze.nextZ, ze); qe++) ;
                  let ve = ue;
                  for (; ee > 0 || ve > 0 && ze; ) ee !== 0 && (ve === 0 || !ze || Ee.z <= ze.z) ? (Se = Ee, Ee = Ee.nextZ, ee--) : (Se = ze, ze = ze.nextZ, ve--), Je ? Je.nextZ = Se : te = Se, Se.prevZ = Je, Je = Se;
                  Ee = ze;
                }
                Je.nextZ = null, ue *= 2;
              } while (ne > 1);
            }(J);
          }(f, p, _, x);
          let I = f;
          for (; f.prev !== f.next; ) {
            const B = f.prev, N = f.next;
            if (x ? UP(f, p, _, x) : FP(f)) c.push(B.i, f.i, N.i), Lp(f), f = N.next, I = N.next;
            else if ((f = N) === I) {
              T ? T === 1 ? Pp(f = zP(hf(f), c), c, u, p, _, x, 2) : T === 2 && jP(f, c, u, p, _, x) : Pp(hf(f), c, u, p, _, x, 1);
              break;
            }
          }
        }
        function FP(f) {
          const c = f.prev, u = f, p = f.next;
          if (es(c, u, p) >= 0) return !1;
          const _ = c.x, x = u.x, T = p.x, I = c.y, B = u.y, N = p.y, z = Math.min(_, x, T), $ = Math.min(I, B, N), J = Math.max(_, x, T), te = Math.max(I, B, N);
          let ne = p.next;
          for (; ne !== c; ) {
            if (ne.x >= z && ne.x <= J && ne.y >= $ && ne.y <= te && Rp(_, I, x, B, T, N, ne.x, ne.y) && es(ne.prev, ne, ne.next) >= 0) return !1;
            ne = ne.next;
          }
          return !0;
        }
        function UP(f, c, u, p) {
          const _ = f.prev, x = f, T = f.next;
          if (es(_, x, T) >= 0) return !1;
          const I = _.x, B = x.x, N = T.x, z = _.y, $ = x.y, J = T.y, te = Math.min(I, B, N), ne = Math.min(z, $, J), ue = Math.max(I, B, N), Se = Math.max(z, $, J), Ee = p0(te, ne, c, u, p), Je = p0(ue, Se, c, u, p);
          let ze = f.prevZ, ee = f.nextZ;
          for (; ze && ze.z >= Ee && ee && ee.z <= Je; ) {
            if (ze.x >= te && ze.x <= ue && ze.y >= ne && ze.y <= Se && ze !== _ && ze !== T && Rp(I, z, B, $, N, J, ze.x, ze.y) && es(ze.prev, ze, ze.next) >= 0 || (ze = ze.prevZ, ee.x >= te && ee.x <= ue && ee.y >= ne && ee.y <= Se && ee !== _ && ee !== T && Rp(I, z, B, $, N, J, ee.x, ee.y) && es(ee.prev, ee, ee.next) >= 0)) return !1;
            ee = ee.nextZ;
          }
          for (; ze && ze.z >= Ee; ) {
            if (ze.x >= te && ze.x <= ue && ze.y >= ne && ze.y <= Se && ze !== _ && ze !== T && Rp(I, z, B, $, N, J, ze.x, ze.y) && es(ze.prev, ze, ze.next) >= 0) return !1;
            ze = ze.prevZ;
          }
          for (; ee && ee.z <= Je; ) {
            if (ee.x >= te && ee.x <= ue && ee.y >= ne && ee.y <= Se && ee !== _ && ee !== T && Rp(I, z, B, $, N, J, ee.x, ee.y) && es(ee.prev, ee, ee.next) >= 0) return !1;
            ee = ee.nextZ;
          }
          return !0;
        }
        function zP(f, c) {
          let u = f;
          do {
            const p = u.prev, _ = u.next.next;
            !ad(p, _) && Wx(p, u, u.next, _) && Bp(p, _) && Bp(_, p) && (c.push(p.i, u.i, _.i), Lp(u), Lp(u.next), u = f = _), u = u.next;
          } while (u !== f);
          return hf(u);
        }
        function jP(f, c, u, p, _, x) {
          let T = f;
          do {
            let I = T.next.next;
            for (; I !== T.prev; ) {
              if (T.i !== I.i && HP(T, I)) {
                let B = Xx(T, I);
                return T = hf(T, T.next), B = hf(B, B.next), Pp(T, c, u, p, _, x, 0), void Pp(B, c, u, p, _, x, 0);
              }
              I = I.next;
            }
            T = T.next;
          } while (T !== f);
        }
        function VP(f, c) {
          let u = f.x - c.x;
          return u === 0 && (u = f.y - c.y, u === 0) && (u = (f.next.y - f.y) / (f.next.x - f.x) - (c.next.y - c.y) / (c.next.x - c.x)), u;
        }
        function $P(f, c) {
          const u = function(_, x) {
            let T = x;
            const I = _.x, B = _.y;
            let N, z = -1 / 0;
            if (ad(_, T)) return T;
            do {
              if (ad(_, T.next)) return T.next;
              if (B <= T.y && B >= T.next.y && T.next.y !== T.y) {
                const ue = T.x + (B - T.y) * (T.next.x - T.x) / (T.next.y - T.y);
                if (ue <= I && ue > z && (z = ue, N = T.x < T.next.x ? T : T.next, ue === I)) return N;
              }
              T = T.next;
            } while (T !== x);
            if (!N) return null;
            const $ = N, J = N.x, te = N.y;
            let ne = 1 / 0;
            T = N;
            do {
              if (I >= T.x && T.x >= J && I !== T.x && Hx(B < te ? I : z, B, J, te, B < te ? z : I, B, T.x, T.y)) {
                const ue = Math.abs(B - T.y) / (I - T.x);
                Bp(T, _) && (ue < ne || ue === ne && (T.x > N.x || T.x === N.x && qP(N, T))) && (N = T, ne = ue);
              }
              T = T.next;
            } while (T !== $);
            return N;
          }(f, c);
          if (!u) return c;
          const p = Xx(u, f);
          return hf(p, p.next), hf(u, u.next);
        }
        function qP(f, c) {
          return es(f.prev, f, c.prev) < 0 && es(c.next, f, f.next) < 0;
        }
        function p0(f, c, u, p, _) {
          return (f = 1431655765 & ((f = 858993459 & ((f = 252645135 & ((f = 16711935 & ((f = (f - u) * _ | 0) | f << 8)) | f << 4)) | f << 2)) | f << 1)) | (c = 1431655765 & ((c = 858993459 & ((c = 252645135 & ((c = 16711935 & ((c = (c - p) * _ | 0) | c << 8)) | c << 4)) | c << 2)) | c << 1)) << 1;
        }
        function GP(f) {
          let c = f, u = f;
          do
            (c.x < u.x || c.x === u.x && c.y < u.y) && (u = c), c = c.next;
          while (c !== f);
          return u;
        }
        function Hx(f, c, u, p, _, x, T, I) {
          return (_ - T) * (c - I) >= (f - T) * (x - I) && (f - T) * (p - I) >= (u - T) * (c - I) && (u - T) * (x - I) >= (_ - T) * (p - I);
        }
        function Rp(f, c, u, p, _, x, T, I) {
          return !(f === T && c === I) && Hx(f, c, u, p, _, x, T, I);
        }
        function HP(f, c) {
          return f.next.i !== c.i && f.prev.i !== c.i && !function(u, p) {
            let _ = u;
            do {
              if (_.i !== u.i && _.next.i !== u.i && _.i !== p.i && _.next.i !== p.i && Wx(_, _.next, u, p)) return !0;
              _ = _.next;
            } while (_ !== u);
            return !1;
          }(f, c) && (Bp(f, c) && Bp(c, f) && function(u, p) {
            let _ = u, x = !1;
            const T = (u.x + p.x) / 2, I = (u.y + p.y) / 2;
            do
              _.y > I != _.next.y > I && _.next.y !== _.y && T < (_.next.x - _.x) * (I - _.y) / (_.next.y - _.y) + _.x && (x = !x), _ = _.next;
            while (_ !== u);
            return x;
          }(f, c) && (es(f.prev, f, c.prev) || es(f, c.prev, c)) || ad(f, c) && es(f.prev, f, f.next) > 0 && es(c.prev, c, c.next) > 0);
        }
        function es(f, c, u) {
          return (c.y - f.y) * (u.x - c.x) - (c.x - f.x) * (u.y - c.y);
        }
        function ad(f, c) {
          return f.x === c.x && f.y === c.y;
        }
        function Wx(f, c, u, p) {
          const _ = om(es(f, c, u)), x = om(es(f, c, p)), T = om(es(u, p, f)), I = om(es(u, p, c));
          return _ !== x && T !== I || !(_ !== 0 || !sm(f, u, c)) || !(x !== 0 || !sm(f, p, c)) || !(T !== 0 || !sm(u, f, p)) || !(I !== 0 || !sm(u, c, p));
        }
        function sm(f, c, u) {
          return c.x <= Math.max(f.x, u.x) && c.x >= Math.min(f.x, u.x) && c.y <= Math.max(f.y, u.y) && c.y >= Math.min(f.y, u.y);
        }
        function om(f) {
          return f > 0 ? 1 : f < 0 ? -1 : 0;
        }
        function Bp(f, c) {
          return es(f.prev, f, f.next) < 0 ? es(f, c, f.next) >= 0 && es(f, f.prev, c) >= 0 : es(f, c, f.prev) < 0 || es(f, f.next, c) < 0;
        }
        function Xx(f, c) {
          const u = g0(f.i, f.x, f.y), p = g0(c.i, c.x, c.y), _ = f.next, x = c.prev;
          return f.next = c, c.prev = f, u.next = _, _.prev = u, p.next = u, u.prev = p, x.next = p, p.prev = x, p;
        }
        function Zx(f, c, u, p) {
          const _ = g0(f, c, u);
          return p ? (_.next = p.next, _.prev = p, p.next.prev = _, p.next = _) : (_.prev = _, _.next = _), _;
        }
        function Lp(f) {
          f.next.prev = f.prev, f.prev.next = f.next, f.prevZ && (f.prevZ.nextZ = f.nextZ), f.nextZ && (f.nextZ.prevZ = f.prevZ);
        }
        function g0(f, c, u) {
          return { i: f, x: c, y: u, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 };
        }
        class ld {
          constructor(c, u) {
            if (u > c) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = c, this._minGranularity = u;
          }
          getGranularityForZoomLevel(c) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << c)), this._minGranularity, 1);
          }
        }
        class am {
          constructor(c) {
            this.fill = c.fill, this.line = c.line, this.tile = c.tile, this.stencil = c.stencil, this.circle = c.circle;
          }
        }
        am.noSubdivision = new am({ fill: new ld(0, 0), line: new ld(0, 0), tile: new ld(0, 0), stencil: new ld(0, 0), circle: 1 }), Re("SubdivisionGranularityExpression", ld), Re("SubdivisionGranularitySetting", am);
        const cd = -32768, Op = 32767;
        class WP {
          constructor(c, u) {
            this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = !1, this._granularity = c, this._granularityCellSize = ce / c, this._canonical = u;
          }
          _getKey(c, u) {
            return (c += 32768) << 16 | u + 32768;
          }
          _vertexToIndex(c, u) {
            if (c < -32768 || u < -32768 || c > 32767 || u > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const p = 0 | Math.round(c), _ = 0 | Math.round(u), x = this._getKey(p, _);
            if (this._vertexDictionary.has(x)) return this._vertexDictionary.get(x);
            const T = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(x, T), this._vertexBuffer.push(p, _), T;
          }
          _subdivideTrianglesScanline(c) {
            if (this._granularity < 2) return function(_, x) {
              const T = [];
              for (let I = 0; I < x.length; I += 3) {
                const B = x[I], N = x[I + 1], z = x[I + 2], $ = _[2 * B], J = _[2 * B + 1];
                (_[2 * N] - $) * (_[2 * z + 1] - J) - (_[2 * N + 1] - J) * (_[2 * z] - $) > 0 ? (T.push(B), T.push(z), T.push(N)) : (T.push(B), T.push(N), T.push(z));
              }
              return T;
            }(this._vertexBuffer, c);
            const u = [], p = c.length;
            for (let _ = 0; _ < p; _ += 3) {
              const x = [c[_ + 0], c[_ + 1], c[_ + 2]], T = [this._vertexBuffer[2 * c[_ + 0] + 0], this._vertexBuffer[2 * c[_ + 0] + 1], this._vertexBuffer[2 * c[_ + 1] + 0], this._vertexBuffer[2 * c[_ + 1] + 1], this._vertexBuffer[2 * c[_ + 2] + 0], this._vertexBuffer[2 * c[_ + 2] + 1]];
              let I = 1 / 0, B = 1 / 0, N = -1 / 0, z = -1 / 0;
              for (let ue = 0; ue < 3; ue++) {
                const Se = T[2 * ue], Ee = T[2 * ue + 1];
                I = Math.min(I, Se), N = Math.max(N, Se), B = Math.min(B, Ee), z = Math.max(z, Ee);
              }
              if (I === N || B === z) continue;
              const $ = Math.floor(I / this._granularityCellSize), J = Math.ceil(N / this._granularityCellSize), te = Math.floor(B / this._granularityCellSize), ne = Math.ceil(z / this._granularityCellSize);
              if ($ !== J || te !== ne) for (let ue = te; ue < ne; ue++) {
                const Se = this._scanlineGenerateVertexRingForCellRow(ue, T, x);
                XP(this._vertexBuffer, Se, u);
              }
              else u.push(...x);
            }
            return u;
          }
          _scanlineGenerateVertexRingForCellRow(c, u, p) {
            const _ = c * this._granularityCellSize, x = _ + this._granularityCellSize, T = [];
            for (let I = 0; I < 3; I++) {
              const B = u[2 * I], N = u[2 * I + 1], z = u[2 * (I + 1) % 6], $ = u[(2 * (I + 1) + 1) % 6], J = u[2 * (I + 2) % 6], te = u[(2 * (I + 2) + 1) % 6], ne = z - B, ue = $ - N, Se = ne === 0, Ee = ue === 0, Je = (_ - N) / ue, ze = (x - N) / ue, ee = Math.min(Je, ze), ve = Math.max(Je, ze);
              if (!Ee && (ee >= 1 || ve <= 0) || Ee && (N < _ || N > x)) {
                $ >= _ && $ <= x && T.push(p[(I + 1) % 3]);
                continue;
              }
              !Ee && ee > 0 && T.push(this._vertexToIndex(B + ne * ee, N + ue * ee));
              const qe = B + ne * Math.max(ee, 0), _t = B + ne * Math.min(ve, 1);
              Se || this._generateIntraEdgeVertices(T, B, N, z, $, qe, _t), !Ee && ve < 1 && T.push(this._vertexToIndex(B + ne * ve, N + ue * ve)), (Ee || $ >= _ && $ <= x) && T.push(p[(I + 1) % 3]), !Ee && ($ <= _ || $ >= x) && this._generateInterEdgeVertices(T, B, N, z, $, J, te, _t, _, x);
            }
            return T;
          }
          _generateIntraEdgeVertices(c, u, p, _, x, T, I) {
            const B = _ - u, N = x - p, z = N === 0, $ = z ? Math.min(u, _) : Math.min(T, I), J = z ? Math.max(u, _) : Math.max(T, I), te = Math.floor($ / this._granularityCellSize) + 1, ne = Math.ceil(J / this._granularityCellSize) - 1;
            if (z ? u < _ : T < I) for (let ue = te; ue <= ne; ue++) {
              const Se = ue * this._granularityCellSize;
              c.push(this._vertexToIndex(Se, p + N * (Se - u) / B));
            }
            else for (let ue = ne; ue >= te; ue--) {
              const Se = ue * this._granularityCellSize;
              c.push(this._vertexToIndex(Se, p + N * (Se - u) / B));
            }
          }
          _generateInterEdgeVertices(c, u, p, _, x, T, I, B, N, z) {
            const $ = x - p, J = T - _, te = I - x, ne = (N - x) / te, ue = (z - x) / te, Se = Math.min(ne, ue), Ee = Math.max(ne, ue), Je = _ + J * Se;
            let ze = Math.floor(Math.min(Je, B) / this._granularityCellSize) + 1, ee = Math.ceil(Math.max(Je, B) / this._granularityCellSize) - 1, ve = B < Je;
            const qe = te === 0;
            if (qe && (I === N || I === z)) return;
            if (qe || Se >= 1 || Ee <= 0) {
              const $t = p - I, Rt = T + (u - T) * Math.min((N - I) / $t, (z - I) / $t);
              ze = Math.floor(Math.min(Rt, B) / this._granularityCellSize) + 1, ee = Math.ceil(Math.max(Rt, B) / this._granularityCellSize) - 1, ve = B < Rt;
            }
            const _t = $ > 0 ? z : N;
            if (ve) for (let $t = ze; $t <= ee; $t++) c.push(this._vertexToIndex($t * this._granularityCellSize, _t));
            else for (let $t = ee; $t >= ze; $t--) c.push(this._vertexToIndex($t * this._granularityCellSize, _t));
          }
          _generateOutline(c) {
            const u = [];
            for (const p of c) {
              const _ = ff(p, this._granularity, !0), x = this._pointArrayToIndices(_), T = [];
              for (let I = 1; I < x.length; I++) T.push(x[I - 1]), T.push(x[I]);
              u.push(T);
            }
            return u;
          }
          _handlePoles(c) {
            let u = !1, p = !1;
            this._canonical && (this._canonical.y === 0 && (u = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (p = !0)), (u || p) && this._fillPoles(c, u, p);
          }
          _ensureNoPoleVertices() {
            const c = this._vertexBuffer;
            for (let u = 0; u < c.length; u += 2) {
              const p = c[u + 1];
              p === cd && (c[u + 1] = -32767), p === Op && (c[u + 1] = 32766);
            }
          }
          _generatePoleQuad(c, u, p, _, x, T) {
            _ > x != (T === cd) ? (c.push(u), c.push(p), c.push(this._vertexToIndex(_, T)), c.push(p), c.push(this._vertexToIndex(x, T)), c.push(this._vertexToIndex(_, T))) : (c.push(p), c.push(u), c.push(this._vertexToIndex(_, T)), c.push(this._vertexToIndex(x, T)), c.push(p), c.push(this._vertexToIndex(_, T)));
          }
          _fillPoles(c, u, p) {
            const _ = this._vertexBuffer, x = ce, T = c.length;
            for (let I = 2; I < T; I += 3) {
              const B = c[I - 2], N = c[I - 1], z = c[I], $ = _[2 * B], J = _[2 * B + 1], te = _[2 * N], ne = _[2 * N + 1], ue = _[2 * z], Se = _[2 * z + 1];
              u && (J === 0 && ne === 0 && this._generatePoleQuad(c, B, N, $, te, cd), ne === 0 && Se === 0 && this._generatePoleQuad(c, N, z, te, ue, cd), Se === 0 && J === 0 && this._generatePoleQuad(c, z, B, ue, $, cd)), p && (J === x && ne === x && this._generatePoleQuad(c, B, N, $, te, Op), ne === x && Se === x && this._generatePoleQuad(c, N, z, te, ue, Op), Se === x && J === x && this._generatePoleQuad(c, z, B, ue, $, Op));
            }
          }
          _initializeVertices(c) {
            for (let u = 0; u < c.length; u += 2) this._vertexToIndex(c[u], c[u + 1]);
          }
          subdividePolygonInternal(c, u) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = !0;
            const { flattened: p, holeIndices: _ } = function(I) {
              const B = [], N = [];
              for (const z of I) if (z.length !== 0) {
                z !== I[0] && B.push(N.length / 2);
                for (let $ = 0; $ < z.length; $++) N.push(z[$].x), N.push(z[$].y);
              }
              return { flattened: N, holeIndices: B };
            }(c);
            let x;
            this._initializeVertices(p);
            try {
              const I = function(N, z) {
                let $ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2;
                const J = z && z.length, te = J ? z[0] * $ : N.length;
                let ne = Gx(N, 0, te, $, !0);
                const ue = [];
                if (!ne || ne.next === ne.prev) return ue;
                let Se, Ee, Je;
                if (J && (ne = function(ze, ee, ve, qe) {
                  const _t = [];
                  for (let $t = 0, Rt = ee.length; $t < Rt; $t++) {
                    const Ot = Gx(ze, ee[$t] * qe, $t < Rt - 1 ? ee[$t + 1] * qe : ze.length, qe, !1);
                    Ot === Ot.next && (Ot.steiner = !0), _t.push(GP(Ot));
                  }
                  _t.sort(VP);
                  for (let $t = 0; $t < _t.length; $t++) ve = $P(_t[$t], ve);
                  return ve;
                }(N, z, ne, $)), N.length > 80 * $) {
                  Se = 1 / 0, Ee = 1 / 0;
                  let ze = -1 / 0, ee = -1 / 0;
                  for (let ve = $; ve < te; ve += $) {
                    const qe = N[ve], _t = N[ve + 1];
                    qe < Se && (Se = qe), _t < Ee && (Ee = _t), qe > ze && (ze = qe), _t > ee && (ee = _t);
                  }
                  Je = Math.max(ze - Se, ee - Ee), Je = Je !== 0 ? 32767 / Je : 0;
                }
                return Pp(ne, ue, $, Se, Ee, Je, 0), ue;
              }(p, _), B = this._convertIndices(p, I);
              x = this._subdivideTrianglesScanline(B);
            } catch (I) {
              console.error(I);
            }
            let T = [];
            return u && (T = this._generateOutline(c)), this._ensureNoPoleVertices(), this._handlePoles(x), { verticesFlattened: this._vertexBuffer, indicesTriangles: x, indicesLineList: T };
          }
          _convertIndices(c, u) {
            const p = [];
            for (let _ = 0; _ < u.length; _++) p.push(this._vertexToIndex(c[2 * u[_]], c[2 * u[_] + 1]));
            return p;
          }
          _pointArrayToIndices(c) {
            const u = [];
            for (let p = 0; p < c.length; p++) {
              const _ = c[p];
              u.push(this._vertexToIndex(_.x, _.y));
            }
            return u;
          }
        }
        function Yx(f, c, u) {
          let p = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0;
          return new WP(u, c).subdividePolygonInternal(f, p);
        }
        function ff(f, c) {
          let u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
          if (!f || f.length < 1) return [];
          if (f.length < 2) return [];
          const p = f[0], _ = f[f.length - 1], x = u && (p.x !== _.x || p.y !== _.y);
          if (c < 2) return x ? [...f, f[0]] : [...f];
          const T = Math.floor(ce / c), I = [];
          I.push(new k(f[0].x, f[0].y));
          const B = f.length, N = x ? B : B - 1;
          for (let z = 0; z < N; z++) {
            const $ = f[z], J = z < B - 1 ? f[z + 1] : f[0], te = $.x, ne = $.y, ue = J.x, Se = J.y, Ee = te !== ue, Je = ne !== Se;
            if (!Ee && !Je) continue;
            const ze = ue - te, ee = Se - ne, ve = Math.abs(ze), qe = Math.abs(ee);
            let _t = te, $t = ne;
            for (; ; ) {
              const Ot = ze > 0 ? (Math.floor(_t / T) + 1) * T : (Math.ceil(_t / T) - 1) * T, Qt = ee > 0 ? (Math.floor($t / T) + 1) * T : (Math.ceil($t / T) - 1) * T, Wt = Math.abs(_t - Ot), nr = Math.abs($t - Qt), Ft = Math.abs(_t - ue), Pr = Math.abs($t - Se), jr = Ee ? Wt / ve : Number.POSITIVE_INFINITY, kr = Je ? nr / qe : Number.POSITIVE_INFINITY;
              if ((Ft <= Wt || !Ee) && (Pr <= nr || !Je)) break;
              if (jr < kr && Ee || !Je) {
                _t = Ot, $t += ee * jr;
                const Rr = new k(_t, Math.round($t));
                I[I.length - 1].x === Rr.x && I[I.length - 1].y === Rr.y || I.push(Rr);
              } else {
                _t += ze * kr, $t = Qt;
                const Rr = new k(Math.round(_t), $t);
                I[I.length - 1].x === Rr.x && I[I.length - 1].y === Rr.y || I.push(Rr);
              }
            }
            const Rt = new k(ue, Se);
            I[I.length - 1].x === Rt.x && I[I.length - 1].y === Rt.y || I.push(Rt);
          }
          return I;
        }
        function XP(f, c, u) {
          if (c.length === 0) throw new Error("Subdivision vertex ring is empty.");
          let p = 0, _ = f[2 * c[0]];
          for (let B = 1; B < c.length; B++) {
            const N = f[2 * c[B]];
            N < _ && (_ = N, p = B);
          }
          const x = c.length;
          let T = p, I = (T + 1) % x;
          for (; ; ) {
            const B = T - 1 >= 0 ? T - 1 : x - 1, N = (I + 1) % x, z = f[2 * c[B]], $ = f[2 * c[N]], J = f[2 * c[T]], te = f[2 * c[T] + 1], ne = f[2 * c[I] + 1];
            let ue = !1;
            if (z < $) ue = !0;
            else if (z > $) ue = !1;
            else {
              const Se = ne - te, Ee = -(f[2 * c[I]] - J), Je = te < ne ? 1 : -1;
              ((z - J) * Se + (f[2 * c[B] + 1] - te) * Ee) * Je > (($ - J) * Se + (f[2 * c[N] + 1] - te) * Ee) * Je && (ue = !0);
            }
            if (ue) {
              const Se = c[B], Ee = c[T], Je = c[I];
              Se !== Ee && Se !== Je && Ee !== Je && u.push(Je, Ee, Se), T--, T < 0 && (T = x - 1);
            } else {
              const Se = c[N], Ee = c[T], Je = c[I];
              Se !== Ee && Se !== Je && Ee !== Je && u.push(Je, Ee, Se), I++, I >= x && (I = 0);
            }
            if (B === N) break;
          }
        }
        function Kx(f, c, u, p, _, x, T, I, B) {
          const N = _.length / 2, z = T && I && B;
          if (N < yn.MAX_VERTEX_ARRAY_LENGTH) {
            const $ = c.prepareSegment(N, u, p), J = $.vertexLength;
            for (let ue = 0; ue < x.length; ue += 3) p.emplaceBack(J + x[ue], J + x[ue + 1], J + x[ue + 2]);
            let te, ne;
            $.vertexLength += N, $.primitiveLength += x.length / 3, z && (ne = T.prepareSegment(N, u, I), te = ne.vertexLength, ne.vertexLength += N);
            for (let ue = 0; ue < _.length; ue += 2) f(_[ue], _[ue + 1]);
            if (z) for (let ue = 0; ue < B.length; ue++) {
              const Se = B[ue];
              for (let Ee = 1; Ee < Se.length; Ee += 2) I.emplaceBack(te + Se[Ee - 1], te + Se[Ee]);
              ne.primitiveLength += Se.length / 2;
            }
          } else (function($, J, te, ne, ue, Se) {
            const Ee = [];
            for (let qe = 0; qe < ne.length / 2; qe++) Ee.push(-1);
            const Je = { count: 0 };
            let ze = 0, ee = $.getOrCreateLatestSegment(J, te), ve = ee.vertexLength;
            for (let qe = 2; qe < ue.length; qe += 3) {
              const _t = ue[qe - 2], $t = ue[qe - 1], Rt = ue[qe];
              let Ot = Ee[_t] < ze, Qt = Ee[$t] < ze, Wt = Ee[Rt] < ze;
              ee.vertexLength + ((Ot ? 1 : 0) + (Qt ? 1 : 0) + (Wt ? 1 : 0)) > yn.MAX_VERTEX_ARRAY_LENGTH && (ee = $.createNewSegment(J, te), ze = Je.count, Ot = !0, Qt = !0, Wt = !0, ve = 0);
              const nr = kp(Ee, ne, Se, Je, _t, Ot, ee), Ft = kp(Ee, ne, Se, Je, $t, Qt, ee), Pr = kp(Ee, ne, Se, Je, Rt, Wt, ee);
              te.emplaceBack(ve + nr - ze, ve + Ft - ze, ve + Pr - ze), ee.primitiveLength++;
            }
          })(c, u, p, _, x, f), z && function($, J, te, ne, ue, Se) {
            const Ee = [];
            for (let qe = 0; qe < ne.length / 2; qe++) Ee.push(-1);
            const Je = { count: 0 };
            let ze = 0, ee = $.getOrCreateLatestSegment(J, te), ve = ee.vertexLength;
            for (let qe = 0; qe < ue.length; qe++) {
              const _t = ue[qe];
              for (let $t = 1; $t < ue[qe].length; $t += 2) {
                const Rt = _t[$t - 1], Ot = _t[$t];
                let Qt = Ee[Rt] < ze, Wt = Ee[Ot] < ze;
                ee.vertexLength + ((Qt ? 1 : 0) + (Wt ? 1 : 0)) > yn.MAX_VERTEX_ARRAY_LENGTH && (ee = $.createNewSegment(J, te), ze = Je.count, Qt = !0, Wt = !0, ve = 0);
                const nr = kp(Ee, ne, Se, Je, Rt, Qt, ee), Ft = kp(Ee, ne, Se, Je, Ot, Wt, ee);
                te.emplaceBack(ve + nr - ze, ve + Ft - ze), ee.primitiveLength++;
              }
            }
          }(T, u, I, _, B, f), c.forceNewSegmentOnNextPrepare(), T == null || T.forceNewSegmentOnNextPrepare();
        }
        function kp(f, c, u, p, _, x, T) {
          if (x) {
            const I = p.count;
            return u(c[2 * _], c[2 * _ + 1]), f[_] = p.count, p.count++, T.vertexLength++, I;
          }
          return f[_];
        }
        class m0 {
          constructor(c) {
            this.zoom = c.zoom, this.globalState = c.globalState, this.overscaling = c.overscaling, this.layers = c.layers, this.layerIds = this.layers.map((u) => u.id), this.index = c.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new wt(), this.indexArray = new In(), this.indexArray2 = new En(), this.programConfigurations = new iu(c.layers, c.zoom), this.segments = new yn(), this.segments2 = new yn(), this.stateDependentLayerIds = this.layers.filter((u) => u.isStateDependent()).map((u) => u.id);
          }
          populate(c, u, p) {
            this.hasPattern = f0("fill", this.layers, u);
            const _ = this.layers[0].layout.get("fill-sort-key"), x = !_.isConstant(), T = [];
            for (const { feature: I, id: B, index: N, sourceLayerIndex: z } of c) {
              const $ = this.layers[0]._featureFilter.needGeometry, J = uf(I, $);
              if (!this.layers[0]._featureFilter.filter(new Br(this.zoom, { globalState: this.globalState }), J, p)) continue;
              const te = x ? _.evaluate(J, {}, p, u.availableImages) : void 0, ne = { id: B, properties: I.properties, type: I.type, sourceLayerIndex: z, index: N, geometry: $ ? J.geometry : cf(I), patterns: {}, sortKey: te };
              T.push(ne);
            }
            x && T.sort((I, B) => I.sortKey - B.sortKey);
            for (const I of T) {
              const { geometry: B, index: N, sourceLayerIndex: z } = I;
              if (this.hasPattern) {
                const $ = d0("fill", this.layers, I, this.zoom, u);
                this.patternFeatures.push($);
              } else this.addFeature(I, B, N, p, {}, u.subdivisionGranularity);
              u.featureIndex.insert(c[N].feature, B, N, z, this.index);
            }
          }
          update(c, u, p) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(c, u, this.stateDependentLayers, p);
          }
          addFeatures(c, u, p) {
            for (const _ of this.patternFeatures) this.addFeature(_, _.geometry, _.index, u, p, c.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(c) {
            this.uploaded || (this.layoutVertexBuffer = c.createVertexBuffer(this.layoutVertexArray, DP), this.indexBuffer = c.createIndexBuffer(this.indexArray), this.indexBuffer2 = c.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(c), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(c, u, p, _, x, T) {
            for (const I of El(u, 500)) {
              const B = Yx(I, _, T.fill.getGranularityForZoomLevel(_.z)), N = this.layoutVertexArray;
              Kx((z, $) => {
                N.emplaceBack(z, $);
              }, this.segments, this.layoutVertexArray, this.indexArray, B.verticesFlattened, B.indicesTriangles, this.segments2, this.indexArray2, B.indicesLineList);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, c, p, x, _);
          }
        }
        let Jx, Qx;
        Re("FillBucket", m0, { omit: ["layers", "patternFeatures"] });
        var ZP = { get paint() {
          return Qx = Qx || new Ei({ "fill-antialias": new fr(Ge.paint_fill["fill-antialias"]), "fill-opacity": new Ir(Ge.paint_fill["fill-opacity"]), "fill-color": new Ir(Ge.paint_fill["fill-color"]), "fill-outline-color": new Ir(Ge.paint_fill["fill-outline-color"]), "fill-translate": new fr(Ge.paint_fill["fill-translate"]), "fill-translate-anchor": new fr(Ge.paint_fill["fill-translate-anchor"]), "fill-pattern": new Ys(Ge.paint_fill["fill-pattern"]) });
        }, get layout() {
          return Jx = Jx || new Ei({ "fill-sort-key": new Ir(Ge.layout_fill["fill-sort-key"]) });
        } };
        class YP extends ki {
          constructor(c) {
            super(c, ZP);
          }
          recalculate(c, u) {
            super.recalculate(c, u);
            const p = this.paint._values["fill-outline-color"];
            p.value.kind === "constant" && p.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(c) {
            return new m0(c);
          }
          queryRadius() {
            return nm(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature(c) {
            let { queryGeometry: u, geometry: p, transform: _, pixelsToTileUnits: x } = c;
            return Rx(im(u, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -_.bearingInRadians, x), p);
          }
          isTileClipped() {
            return !0;
          }
        }
        const KP = pi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), JP = pi([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: QP } = KP;
        var _0, ew, y0, tw, b0, rw, nw, lm = {};
        function iw() {
          if (ew) return _0;
          ew = 1;
          var f = A();
          function c(_, x, T, I, B) {
            this.properties = {}, this.extent = T, this.type = 0, this._pbf = _, this._geometry = -1, this._keys = I, this._values = B, _.readFields(u, this, x);
          }
          function u(_, x, T) {
            _ == 1 ? x.id = T.readVarint() : _ == 2 ? function(I, B) {
              for (var N = I.readVarint() + I.pos; I.pos < N; ) {
                var z = B._keys[I.readVarint()], $ = B._values[I.readVarint()];
                B.properties[z] = $;
              }
            }(T, x) : _ == 3 ? x.type = T.readVarint() : _ == 4 && (x._geometry = T.pos);
          }
          function p(_) {
            for (var x, T, I = 0, B = 0, N = _.length, z = N - 1; B < N; z = B++) I += ((T = _[z]).x - (x = _[B]).x) * (x.y + T.y);
            return I;
          }
          return _0 = c, c.types = ["Unknown", "Point", "LineString", "Polygon"], c.prototype.loadGeometry = function() {
            var _ = this._pbf;
            _.pos = this._geometry;
            for (var x, T = _.readVarint() + _.pos, I = 1, B = 0, N = 0, z = 0, $ = []; _.pos < T; ) {
              if (B <= 0) {
                var J = _.readVarint();
                I = 7 & J, B = J >> 3;
              }
              if (B--, I === 1 || I === 2) N += _.readSVarint(), z += _.readSVarint(), I === 1 && (x && $.push(x), x = []), x.push(new f(N, z));
              else {
                if (I !== 7) throw new Error("unknown command " + I);
                x && x.push(x[0].clone());
              }
            }
            return x && $.push(x), $;
          }, c.prototype.bbox = function() {
            var _ = this._pbf;
            _.pos = this._geometry;
            for (var x = _.readVarint() + _.pos, T = 1, I = 0, B = 0, N = 0, z = 1 / 0, $ = -1 / 0, J = 1 / 0, te = -1 / 0; _.pos < x; ) {
              if (I <= 0) {
                var ne = _.readVarint();
                T = 7 & ne, I = ne >> 3;
              }
              if (I--, T === 1 || T === 2) (B += _.readSVarint()) < z && (z = B), B > $ && ($ = B), (N += _.readSVarint()) < J && (J = N), N > te && (te = N);
              else if (T !== 7) throw new Error("unknown command " + T);
            }
            return [z, J, $, te];
          }, c.prototype.toGeoJSON = function(_, x, T) {
            var I, B, N = this.extent * Math.pow(2, T), z = this.extent * _, $ = this.extent * x, J = this.loadGeometry(), te = c.types[this.type];
            function ne(Ee) {
              for (var Je = 0; Je < Ee.length; Je++) {
                var ze = Ee[Je];
                Ee[Je] = [360 * (ze.x + z) / N - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (ze.y + $) / N) * Math.PI / 180)) - 90];
              }
            }
            switch (this.type) {
              case 1:
                var ue = [];
                for (I = 0; I < J.length; I++) ue[I] = J[I][0];
                ne(J = ue);
                break;
              case 2:
                for (I = 0; I < J.length; I++) ne(J[I]);
                break;
              case 3:
                for (J = function(Ee) {
                  var Je = Ee.length;
                  if (Je <= 1) return [Ee];
                  for (var ze, ee, ve = [], qe = 0; qe < Je; qe++) {
                    var _t = p(Ee[qe]);
                    _t !== 0 && (ee === void 0 && (ee = _t < 0), ee === _t < 0 ? (ze && ve.push(ze), ze = [Ee[qe]]) : ze.push(Ee[qe]));
                  }
                  return ze && ve.push(ze), ve;
                }(J), I = 0; I < J.length; I++) for (B = 0; B < J[I].length; B++) ne(J[I][B]);
            }
            J.length === 1 ? J = J[0] : te = "Multi" + te;
            var Se = { type: "Feature", geometry: { type: te, coordinates: J }, properties: this.properties };
            return "id" in this && (Se.id = this.id), Se;
          }, _0;
        }
        function sw() {
          if (tw) return y0;
          tw = 1;
          var f = iw();
          function c(p, _) {
            this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = p, this._keys = [], this._values = [], this._features = [], p.readFields(u, this, _), this.length = this._features.length;
          }
          function u(p, _, x) {
            p === 15 ? _.version = x.readVarint() : p === 1 ? _.name = x.readString() : p === 5 ? _.extent = x.readVarint() : p === 2 ? _._features.push(x.pos) : p === 3 ? _._keys.push(x.readString()) : p === 4 && _._values.push(function(T) {
              for (var I = null, B = T.readVarint() + T.pos; T.pos < B; ) {
                var N = T.readVarint() >> 3;
                I = N === 1 ? T.readString() : N === 2 ? T.readFloat() : N === 3 ? T.readDouble() : N === 4 ? T.readVarint64() : N === 5 ? T.readVarint() : N === 6 ? T.readSVarint() : N === 7 ? T.readBoolean() : null;
              }
              return I;
            }(x));
          }
          return y0 = c, c.prototype.feature = function(p) {
            if (p < 0 || p >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[p];
            var _ = this._pbf.readVarint() + this._pbf.pos;
            return new f(this._pbf, _, this.extent, this._keys, this._values);
          }, y0;
        }
        function ow() {
          return nw || (nw = 1, lm.VectorTile = function() {
            if (rw) return b0;
            rw = 1;
            var f = sw();
            function c(u, p, _) {
              if (u === 3) {
                var x = new f(_, _.readVarint() + _.pos);
                x.length && (p[x.name] = x);
              }
            }
            return b0 = function(u, p) {
              this.layers = u.readFields(c, {}, p);
            }, b0;
          }(), lm.VectorTileFeature = iw(), lm.VectorTileLayer = sw()), lm;
        }
        var Np = d(ow());
        const eR = Np.VectorTileFeature.types, v0 = Math.pow(2, 13);
        function Dp(f, c, u, p, _, x, T, I) {
          f.emplaceBack(c, u, 2 * Math.floor(p * v0) + T, _ * v0 * 2, x * v0 * 2, Math.round(I));
        }
        class x0 {
          constructor(c) {
            this.zoom = c.zoom, this.globalState = c.globalState, this.overscaling = c.overscaling, this.layers = c.layers, this.layerIds = this.layers.map((u) => u.id), this.index = c.index, this.hasPattern = !1, this.layoutVertexArray = new ir(), this.centroidVertexArray = new dt(), this.indexArray = new In(), this.programConfigurations = new iu(c.layers, c.zoom), this.segments = new yn(), this.stateDependentLayerIds = this.layers.filter((u) => u.isStateDependent()).map((u) => u.id);
          }
          populate(c, u, p) {
            this.features = [], this.hasPattern = f0("fill-extrusion", this.layers, u);
            for (const { feature: _, id: x, index: T, sourceLayerIndex: I } of c) {
              const B = this.layers[0]._featureFilter.needGeometry, N = uf(_, B);
              if (!this.layers[0]._featureFilter.filter(new Br(this.zoom, { globalState: this.globalState }), N, p)) continue;
              const z = { id: x, sourceLayerIndex: I, index: T, geometry: B ? N.geometry : cf(_), properties: _.properties, type: _.type, patterns: {} };
              this.hasPattern ? this.features.push(d0("fill-extrusion", this.layers, z, this.zoom, u)) : this.addFeature(z, z.geometry, T, p, {}, u.subdivisionGranularity), u.featureIndex.insert(_, z.geometry, T, I, this.index, !0);
            }
          }
          addFeatures(c, u, p) {
            for (const _ of this.features) {
              const { geometry: x } = _;
              this.addFeature(_, x, _.index, u, p, c.subdivisionGranularity);
            }
          }
          update(c, u, p) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(c, u, this.stateDependentLayers, p);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(c) {
            this.uploaded || (this.layoutVertexBuffer = c.createVertexBuffer(this.layoutVertexArray, QP), this.centroidVertexBuffer = c.createVertexBuffer(this.centroidVertexArray, JP.members, !0), this.indexBuffer = c.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(c), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
          }
          addFeature(c, u, p, _, x, T) {
            for (const I of El(u, 500)) {
              const B = { x: 0, y: 0, sampleCount: 0 }, N = this.layoutVertexArray.length;
              this.processPolygon(B, _, c, I, T);
              const z = this.layoutVertexArray.length - N, $ = Math.floor(B.x / B.sampleCount), J = Math.floor(B.y / B.sampleCount);
              for (let te = 0; te < z; te++) this.centroidVertexArray.emplaceBack($, J);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, c, p, x, _);
          }
          processPolygon(c, u, p, _, x) {
            if (_.length < 1 || aw(_[0])) return;
            for (const $ of _) $.length !== 0 && tR(c, $);
            const T = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, I = x.fill.getGranularityForZoomLevel(u.z), B = eR[p.type] === "Polygon";
            for (const $ of _) {
              if ($.length === 0 || aw($)) continue;
              const J = ff($, I, B);
              this._generateSideFaces(J, T);
            }
            if (!B) return;
            const N = Yx(_, u, I, !1), z = this.layoutVertexArray;
            Kx(($, J) => {
              Dp(z, $, J, 0, 0, 1, 1, 0);
            }, this.segments, this.layoutVertexArray, this.indexArray, N.verticesFlattened, N.indicesTriangles);
          }
          _generateSideFaces(c, u) {
            let p = 0;
            for (let _ = 1; _ < c.length; _++) {
              const x = c[_], T = c[_ - 1];
              if (rR(x, T)) continue;
              u.segment.vertexLength + 4 > yn.MAX_VERTEX_ARRAY_LENGTH && (u.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const I = x.sub(T)._perp()._unit(), B = T.dist(x);
              p + B > 32768 && (p = 0), Dp(this.layoutVertexArray, x.x, x.y, I.x, I.y, 0, 0, p), Dp(this.layoutVertexArray, x.x, x.y, I.x, I.y, 0, 1, p), p += B, Dp(this.layoutVertexArray, T.x, T.y, I.x, I.y, 0, 0, p), Dp(this.layoutVertexArray, T.x, T.y, I.x, I.y, 0, 1, p);
              const N = u.segment.vertexLength;
              this.indexArray.emplaceBack(N, N + 2, N + 1), this.indexArray.emplaceBack(N + 1, N + 2, N + 3), u.segment.vertexLength += 4, u.segment.primitiveLength += 2;
            }
          }
        }
        function tR(f, c) {
          for (let u = 0; u < c.length; u++) {
            const p = c[u];
            u === c.length - 1 && c[0].x === p.x && c[0].y === p.y || (f.x += p.x, f.y += p.y, f.sampleCount++);
          }
        }
        function rR(f, c) {
          return f.x === c.x && (f.x < 0 || f.x > ce) || f.y === c.y && (f.y < 0 || f.y > ce);
        }
        function aw(f) {
          return f.every((c) => c.x < 0) || f.every((c) => c.x > ce) || f.every((c) => c.y < 0) || f.every((c) => c.y > ce);
        }
        let lw;
        Re("FillExtrusionBucket", x0, { omit: ["layers", "features"] });
        var nR = { get paint() {
          return lw = lw || new Ei({ "fill-extrusion-opacity": new fr(Ge["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Ir(Ge["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new fr(Ge["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new fr(Ge["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Ys(Ge["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Ir(Ge["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Ir(Ge["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new fr(Ge["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
        } };
        class iR extends ki {
          constructor(c) {
            super(c, nR);
          }
          createBucket(c) {
            return new x0(c);
          }
          queryRadius() {
            return nm(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return !0;
          }
          queryIntersectsFeature(c) {
            let { queryGeometry: u, feature: p, featureState: _, geometry: x, transform: T, pixelsToTileUnits: I, pixelPosMatrix: B } = c;
            const N = im(u, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -T.bearingInRadians, I), z = this.paint.get("fill-extrusion-height").evaluate(p, _), $ = this.paint.get("fill-extrusion-base").evaluate(p, _), J = function(ne, ue) {
              const Se = [];
              for (const Ee of ne) {
                const Je = [Ee.x, Ee.y, 0, 1];
                Lt(Je, Je, ue), Se.push(new k(Je[0] / Je[3], Je[1] / Je[3]));
              }
              return Se;
            }(N, B), te = function(ne, ue, Se, Ee) {
              const Je = [], ze = [], ee = Ee[8] * ue, ve = Ee[9] * ue, qe = Ee[10] * ue, _t = Ee[11] * ue, $t = Ee[8] * Se, Rt = Ee[9] * Se, Ot = Ee[10] * Se, Qt = Ee[11] * Se;
              for (const Wt of ne) {
                const nr = [], Ft = [];
                for (const Pr of Wt) {
                  const jr = Pr.x, kr = Pr.y, Rr = Ee[0] * jr + Ee[4] * kr + Ee[12], Tn = Ee[1] * jr + Ee[5] * kr + Ee[13], Ui = Ee[2] * jr + Ee[6] * kr + Ee[14], ls = Ee[3] * jr + Ee[7] * kr + Ee[15], qo = Ui + qe, ma = ls + _t, _a = Rr + $t, Js = Tn + Rt, qi = Ui + Ot, Ts = ls + Qt, Qs = new k((Rr + ee) / ma, (Tn + ve) / ma);
                  Qs.z = qo / ma, nr.push(Qs);
                  const cs = new k(_a / Ts, Js / Ts);
                  cs.z = qi / Ts, Ft.push(cs);
                }
                Je.push(nr), ze.push(Ft);
              }
              return [Je, ze];
            }(x, $, z, B);
            return function(ne, ue, Se) {
              let Ee = 1 / 0;
              Rx(Se, ue) && (Ee = cw(Se, ue[0]));
              for (let Je = 0; Je < ue.length; Je++) {
                const ze = ue[Je], ee = ne[Je];
                for (let ve = 0; ve < ze.length - 1; ve++) {
                  const qe = ze[ve], _t = [qe, ze[ve + 1], ee[ve + 1], ee[ve], qe];
                  Px(Se, _t) && (Ee = Math.min(Ee, cw(Se, _t)));
                }
              }
              return Ee !== 1 / 0 && Ee;
            }(te[0], te[1], J);
          }
        }
        function Fp(f, c) {
          return f.x * c.x + f.y * c.y;
        }
        function cw(f, c) {
          if (f.length === 1) {
            let u = 0;
            const p = c[u++];
            let _;
            for (; !_ || p.equals(_); ) if (_ = c[u++], !_) return 1 / 0;
            for (; u < c.length; u++) {
              const x = c[u], T = f[0], I = _.sub(p), B = x.sub(p), N = T.sub(p), z = Fp(I, I), $ = Fp(I, B), J = Fp(B, B), te = Fp(N, I), ne = Fp(N, B), ue = z * J - $ * $, Se = (J * te - $ * ne) / ue, Ee = (z * ne - $ * te) / ue, Je = p.z * (1 - Se - Ee) + _.z * Se + x.z * Ee;
              if (isFinite(Je)) return Je;
            }
            return 1 / 0;
          }
          {
            let u = 1 / 0;
            for (const p of c) u = Math.min(u, p.z);
            return u;
          }
        }
        const sR = pi([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: oR } = sR, aR = pi([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: lR } = aR, cR = Np.VectorTileFeature.types, uR = Math.cos(Math.PI / 180 * 37.5), uw = Math.pow(2, 14) / 0.5;
        class w0 {
          constructor(c) {
            this.zoom = c.zoom, this.globalState = c.globalState, this.overscaling = c.overscaling, this.layers = c.layers, this.layerIds = this.layers.map((u) => u.id), this.index = c.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((u) => {
              this.gradients[u.id] = {};
            }), this.layoutVertexArray = new or(), this.layoutVertexArray2 = new Vt(), this.indexArray = new In(), this.programConfigurations = new iu(c.layers, c.zoom), this.segments = new yn(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((u) => u.isStateDependent()).map((u) => u.id);
          }
          populate(c, u, p) {
            this.hasPattern = f0("line", this.layers, u);
            const _ = this.layers[0].layout.get("line-sort-key"), x = !_.isConstant(), T = [];
            for (const { feature: I, id: B, index: N, sourceLayerIndex: z } of c) {
              const $ = this.layers[0]._featureFilter.needGeometry, J = uf(I, $);
              if (!this.layers[0]._featureFilter.filter(new Br(this.zoom, { globalState: this.globalState }), J, p)) continue;
              const te = x ? _.evaluate(J, {}, p) : void 0, ne = { id: B, properties: I.properties, type: I.type, sourceLayerIndex: z, index: N, geometry: $ ? J.geometry : cf(I), patterns: {}, sortKey: te };
              T.push(ne);
            }
            x && T.sort((I, B) => I.sortKey - B.sortKey);
            for (const I of T) {
              const { geometry: B, index: N, sourceLayerIndex: z } = I;
              if (this.hasPattern) {
                const $ = d0("line", this.layers, I, this.zoom, u);
                this.patternFeatures.push($);
              } else this.addFeature(I, B, N, p, {}, u.subdivisionGranularity);
              u.featureIndex.insert(c[N].feature, B, N, z, this.index);
            }
          }
          update(c, u, p) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(c, u, this.stateDependentLayers, p);
          }
          addFeatures(c, u, p) {
            for (const _ of this.patternFeatures) this.addFeature(_, _.geometry, _.index, u, p, c.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(c) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = c.createVertexBuffer(this.layoutVertexArray2, lR)), this.layoutVertexBuffer = c.createVertexBuffer(this.layoutVertexArray, oR), this.indexBuffer = c.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(c), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(c) {
            if (c.properties && Object.prototype.hasOwnProperty.call(c.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(c.properties, "mapbox_clip_end")) return { start: +c.properties.mapbox_clip_start, end: +c.properties.mapbox_clip_end };
          }
          addFeature(c, u, p, _, x, T) {
            const I = this.layers[0].layout, B = I.get("line-join").evaluate(c, {}), N = I.get("line-cap"), z = I.get("line-miter-limit"), $ = I.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(c);
            for (const J of u) this.addLine(J, c, B, N, z, $, _, T);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, c, p, x, _);
          }
          addLine(c, u, p, _, x, T, I, B) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, c = ff(c, I ? B.line.getGranularityForZoomLevel(I.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let ze = 0; ze < c.length - 1; ze++) this.totalDistance += c[ze].dist(c[ze + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const N = cR[u.type] === "Polygon";
            let z = c.length;
            for (; z >= 2 && c[z - 1].equals(c[z - 2]); ) z--;
            let $ = 0;
            for (; $ < z - 1 && c[$].equals(c[$ + 1]); ) $++;
            if (z < (N ? 3 : 2)) return;
            p === "bevel" && (x = 1.05);
            const J = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, te = this.segments.prepareSegment(10 * z, this.layoutVertexArray, this.indexArray);
            let ne, ue, Se, Ee, Je;
            this.e1 = this.e2 = -1, N && (ne = c[z - 2], Je = c[$].sub(ne)._unit()._perp());
            for (let ze = $; ze < z; ze++) {
              if (Se = ze === z - 1 ? N ? c[$ + 1] : void 0 : c[ze + 1], Se && c[ze].equals(Se)) continue;
              Je && (Ee = Je), ne && (ue = ne), ne = c[ze], Je = Se ? Se.sub(ne)._unit()._perp() : Ee, Ee = Ee || Je;
              let ee = Ee.add(Je);
              ee.x === 0 && ee.y === 0 || ee._unit();
              const ve = Ee.x * Je.x + Ee.y * Je.y, qe = ee.x * Je.x + ee.y * Je.y, _t = qe !== 0 ? 1 / qe : 1 / 0, $t = 2 * Math.sqrt(2 - 2 * qe), Rt = qe < uR && ue && Se, Ot = Ee.x * Je.y - Ee.y * Je.x > 0;
              if (Rt && ze > $) {
                const nr = ne.dist(ue);
                if (nr > 2 * J) {
                  const Ft = ne.sub(ne.sub(ue)._mult(J / nr)._round());
                  this.updateDistance(ue, Ft), this.addCurrentVertex(Ft, Ee, 0, 0, te), ue = Ft;
                }
              }
              const Qt = ue && Se;
              let Wt = Qt ? p : N ? "butt" : _;
              if (Qt && Wt === "round" && (_t < T ? Wt = "miter" : _t <= 2 && (Wt = "fakeround")), Wt === "miter" && _t > x && (Wt = "bevel"), Wt === "bevel" && (_t > 2 && (Wt = "flipbevel"), _t < x && (Wt = "miter")), ue && this.updateDistance(ue, ne), Wt === "miter") ee._mult(_t), this.addCurrentVertex(ne, ee, 0, 0, te);
              else if (Wt === "flipbevel") {
                if (_t > 100) ee = Je.mult(-1);
                else {
                  const nr = _t * Ee.add(Je).mag() / Ee.sub(Je).mag();
                  ee._perp()._mult(nr * (Ot ? -1 : 1));
                }
                this.addCurrentVertex(ne, ee, 0, 0, te), this.addCurrentVertex(ne, ee.mult(-1), 0, 0, te);
              } else if (Wt === "bevel" || Wt === "fakeround") {
                const nr = -Math.sqrt(_t * _t - 1), Ft = Ot ? nr : 0, Pr = Ot ? 0 : nr;
                if (ue && this.addCurrentVertex(ne, Ee, Ft, Pr, te), Wt === "fakeround") {
                  const jr = Math.round(180 * $t / Math.PI / 20);
                  for (let kr = 1; kr < jr; kr++) {
                    let Rr = kr / jr;
                    if (Rr !== 0.5) {
                      const Ui = Rr - 0.5;
                      Rr += Rr * Ui * (Rr - 1) * ((1.0904 + ve * (ve * (3.55645 - 1.43519 * ve) - 3.2452)) * Ui * Ui + (0.848013 + ve * (0.215638 * ve - 1.06021)));
                    }
                    const Tn = Je.sub(Ee)._mult(Rr)._add(Ee)._unit()._mult(Ot ? -1 : 1);
                    this.addHalfVertex(ne, Tn.x, Tn.y, !1, Ot, 0, te);
                  }
                }
                Se && this.addCurrentVertex(ne, Je, -Ft, -Pr, te);
              } else if (Wt === "butt") this.addCurrentVertex(ne, ee, 0, 0, te);
              else if (Wt === "square") {
                const nr = ue ? 1 : -1;
                this.addCurrentVertex(ne, ee, nr, nr, te);
              } else Wt === "round" && (ue && (this.addCurrentVertex(ne, Ee, 0, 0, te), this.addCurrentVertex(ne, Ee, 1, 1, te, !0)), Se && (this.addCurrentVertex(ne, Je, -1, -1, te, !0), this.addCurrentVertex(ne, Je, 0, 0, te)));
              if (Rt && ze < z - 1) {
                const nr = ne.dist(Se);
                if (nr > 2 * J) {
                  const Ft = ne.add(Se.sub(ne)._mult(J / nr)._round());
                  this.updateDistance(ne, Ft), this.addCurrentVertex(Ft, Je, 0, 0, te), ne = Ft;
                }
              }
            }
          }
          addCurrentVertex(c, u, p, _, x) {
            let T = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !1;
            const I = u.y * _ - u.x, B = -u.y - u.x * _;
            this.addHalfVertex(c, u.x + u.y * p, u.y - u.x * p, T, !1, p, x), this.addHalfVertex(c, I, B, T, !0, -_, x), this.distance > uw / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(c, u, p, _, x, T));
          }
          addHalfVertex(c, u, p, _, x, T, I) {
            let { x: B, y: N } = c;
            const z = 0.5 * (this.lineClips ? this.scaledDistance * (uw - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((B << 1) + (_ ? 1 : 0), (N << 1) + (x ? 1 : 0), Math.round(63 * u) + 128, Math.round(63 * p) + 128, 1 + (T === 0 ? 0 : T < 0 ? -1 : 1) | (63 & z) << 2, z >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const $ = I.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, $, this.e2), I.primitiveLength++), x ? this.e2 = $ : this.e1 = $;
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
          }
          updateDistance(c, u) {
            this.distance += c.dist(u), this.updateScaledDistance();
          }
        }
        let hw, fw;
        Re("LineBucket", w0, { omit: ["layers", "patternFeatures"] });
        var dw = { get paint() {
          return fw = fw || new Ei({ "line-opacity": new Ir(Ge.paint_line["line-opacity"]), "line-color": new Ir(Ge.paint_line["line-color"]), "line-translate": new fr(Ge.paint_line["line-translate"]), "line-translate-anchor": new fr(Ge.paint_line["line-translate-anchor"]), "line-width": new Ir(Ge.paint_line["line-width"]), "line-gap-width": new Ir(Ge.paint_line["line-gap-width"]), "line-offset": new Ir(Ge.paint_line["line-offset"]), "line-blur": new Ir(Ge.paint_line["line-blur"]), "line-dasharray": new zo(Ge.paint_line["line-dasharray"]), "line-pattern": new Ys(Ge.paint_line["line-pattern"]), "line-gradient": new Oi(Ge.paint_line["line-gradient"]) });
        }, get layout() {
          return hw = hw || new Ei({ "line-cap": new fr(Ge.layout_line["line-cap"]), "line-join": new Ir(Ge.layout_line["line-join"]), "line-miter-limit": new fr(Ge.layout_line["line-miter-limit"]), "line-round-limit": new fr(Ge.layout_line["line-round-limit"]), "line-sort-key": new Ir(Ge.layout_line["line-sort-key"]) });
        } };
        class hR extends Ir {
          possiblyEvaluate(c, u) {
            return u = new Br(Math.floor(u.zoom), { now: u.now, fadeDuration: u.fadeDuration, zoomHistory: u.zoomHistory, transition: u.transition }), super.possiblyEvaluate(c, u);
          }
          evaluate(c, u, p, _) {
            return u = Kt({}, u, { zoom: Math.floor(u.zoom) }), super.evaluate(c, u, p, _);
          }
        }
        let cm;
        class fR extends ki {
          constructor(c) {
            super(c, dw), this.gradientVersion = 0, cm || (cm = new hR(dw.paint.properties["line-width"].specification), cm.useIntegerZoom = !0);
          }
          _handleSpecialPaintPropertyUpdate(c) {
            if (c === "line-gradient") {
              const u = this.gradientExpression();
              this.stepInterpolant = !!function(p) {
                return p._styleExpression !== void 0;
              }(u) && u._styleExpression.expression instanceof Ea, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          recalculate(c, u) {
            super.recalculate(c, u), this.paint._values["line-floorwidth"] = cm.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, c);
          }
          createBucket(c) {
            return new w0(c);
          }
          queryRadius(c) {
            const u = c, p = pw(Ip("line-width", this, u), Ip("line-gap-width", this, u)), _ = Ip("line-offset", this, u);
            return p / 2 + Math.abs(_) + nm(this.paint.get("line-translate"));
          }
          queryIntersectsFeature(c) {
            let { queryGeometry: u, feature: p, featureState: _, geometry: x, transform: T, pixelsToTileUnits: I } = c;
            const B = im(u, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -T.bearingInRadians, I), N = I / 2 * pw(this.paint.get("line-width").evaluate(p, _), this.paint.get("line-gap-width").evaluate(p, _)), z = this.paint.get("line-offset").evaluate(p, _);
            return z && (x = function($, J) {
              const te = [];
              for (let ne = 0; ne < $.length; ne++) {
                const ue = $[ne], Se = [];
                for (let Ee = 0; Ee < ue.length; Ee++) {
                  const Je = ue[Ee - 1], ze = ue[Ee], ee = ue[Ee + 1], ve = Ee === 0 ? new k(0, 0) : ze.sub(Je)._unit()._perp(), qe = Ee === ue.length - 1 ? new k(0, 0) : ee.sub(ze)._unit()._perp(), _t = ve._add(qe)._unit(), $t = _t.x * qe.x + _t.y * qe.y;
                  $t !== 0 && _t._mult(1 / $t), Se.push(_t._mult(J)._add(ze));
                }
                te.push(Se);
              }
              return te;
            }(x, z * I)), function($, J, te) {
              for (let ne = 0; ne < J.length; ne++) {
                const ue = J[ne];
                if ($.length >= 3) {
                  for (let Se = 0; Se < ue.length; Se++) if (od($, ue[Se])) return !0;
                }
                if (SP($, ue, te)) return !0;
              }
              return !1;
            }(B, x, N);
          }
          isTileClipped() {
            return !0;
          }
        }
        function pw(f, c) {
          return c > 0 ? c + 2 * f : f;
        }
        const dR = pi([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), pR = pi([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
        pi([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const gR = pi([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
        pi([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const gw = pi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), mR = pi([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        function _R(f, c, u) {
          return f.sections.forEach((p) => {
            p.text = function(_, x, T) {
              const I = x.layout.get("text-transform").evaluate(T, {});
              return I === "uppercase" ? _ = _.toLocaleUpperCase() : I === "lowercase" && (_ = _.toLocaleLowerCase()), Cn.applyArabicShaping && (_ = Cn.applyArabicShaping(_)), _;
            }(p.text, c, u);
          }), f;
        }
        pi([{ name: "triangle", components: 3, type: "Uint16" }]), pi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), pi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), pi([{ type: "Float32", name: "offsetX" }]), pi([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), pi([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
        const Up = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂" };
        var mw, A0, _w, Ls = 24, T0 = {};
        function yR() {
          return mw || (mw = 1, T0.read = function(f, c, u, p, _) {
            var x, T, I = 8 * _ - p - 1, B = (1 << I) - 1, N = B >> 1, z = -7, $ = u ? _ - 1 : 0, J = u ? -1 : 1, te = f[c + $];
            for ($ += J, x = te & (1 << -z) - 1, te >>= -z, z += I; z > 0; x = 256 * x + f[c + $], $ += J, z -= 8) ;
            for (T = x & (1 << -z) - 1, x >>= -z, z += p; z > 0; T = 256 * T + f[c + $], $ += J, z -= 8) ;
            if (x === 0) x = 1 - N;
            else {
              if (x === B) return T ? NaN : 1 / 0 * (te ? -1 : 1);
              T += Math.pow(2, p), x -= N;
            }
            return (te ? -1 : 1) * T * Math.pow(2, x - p);
          }, T0.write = function(f, c, u, p, _, x) {
            var T, I, B, N = 8 * x - _ - 1, z = (1 << N) - 1, $ = z >> 1, J = _ === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, te = p ? 0 : x - 1, ne = p ? 1 : -1, ue = c < 0 || c === 0 && 1 / c < 0 ? 1 : 0;
            for (c = Math.abs(c), isNaN(c) || c === 1 / 0 ? (I = isNaN(c) ? 1 : 0, T = z) : (T = Math.floor(Math.log(c) / Math.LN2), c * (B = Math.pow(2, -T)) < 1 && (T--, B *= 2), (c += T + $ >= 1 ? J / B : J * Math.pow(2, 1 - $)) * B >= 2 && (T++, B /= 2), T + $ >= z ? (I = 0, T = z) : T + $ >= 1 ? (I = (c * B - 1) * Math.pow(2, _), T += $) : (I = c * Math.pow(2, $ - 1) * Math.pow(2, _), T = 0)); _ >= 8; f[u + te] = 255 & I, te += ne, I /= 256, _ -= 8) ;
            for (T = T << _ | I, N += _; N > 0; f[u + te] = 255 & T, te += ne, T /= 256, N -= 8) ;
            f[u + te - ne] |= 128 * ue;
          }), T0;
        }
        function yw() {
          if (_w) return A0;
          _w = 1, A0 = c;
          var f = yR();
          function c(ee) {
            this.buf = ArrayBuffer.isView && ArrayBuffer.isView(ee) ? ee : new Uint8Array(ee || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
          }
          c.Varint = 0, c.Fixed64 = 1, c.Bytes = 2, c.Fixed32 = 5;
          var u = 4294967296, p = 1 / u, _ = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
          function x(ee) {
            return ee.type === c.Bytes ? ee.readVarint() + ee.pos : ee.pos + 1;
          }
          function T(ee, ve, qe) {
            return qe ? 4294967296 * ve + (ee >>> 0) : 4294967296 * (ve >>> 0) + (ee >>> 0);
          }
          function I(ee, ve, qe) {
            var _t = ve <= 16383 ? 1 : ve <= 2097151 ? 2 : ve <= 268435455 ? 3 : Math.floor(Math.log(ve) / (7 * Math.LN2));
            qe.realloc(_t);
            for (var $t = qe.pos - 1; $t >= ee; $t--) qe.buf[$t + _t] = qe.buf[$t];
          }
          function B(ee, ve) {
            for (var qe = 0; qe < ee.length; qe++) ve.writeVarint(ee[qe]);
          }
          function N(ee, ve) {
            for (var qe = 0; qe < ee.length; qe++) ve.writeSVarint(ee[qe]);
          }
          function z(ee, ve) {
            for (var qe = 0; qe < ee.length; qe++) ve.writeFloat(ee[qe]);
          }
          function $(ee, ve) {
            for (var qe = 0; qe < ee.length; qe++) ve.writeDouble(ee[qe]);
          }
          function J(ee, ve) {
            for (var qe = 0; qe < ee.length; qe++) ve.writeBoolean(ee[qe]);
          }
          function te(ee, ve) {
            for (var qe = 0; qe < ee.length; qe++) ve.writeFixed32(ee[qe]);
          }
          function ne(ee, ve) {
            for (var qe = 0; qe < ee.length; qe++) ve.writeSFixed32(ee[qe]);
          }
          function ue(ee, ve) {
            for (var qe = 0; qe < ee.length; qe++) ve.writeFixed64(ee[qe]);
          }
          function Se(ee, ve) {
            for (var qe = 0; qe < ee.length; qe++) ve.writeSFixed64(ee[qe]);
          }
          function Ee(ee, ve) {
            return (ee[ve] | ee[ve + 1] << 8 | ee[ve + 2] << 16) + 16777216 * ee[ve + 3];
          }
          function Je(ee, ve, qe) {
            ee[qe] = ve, ee[qe + 1] = ve >>> 8, ee[qe + 2] = ve >>> 16, ee[qe + 3] = ve >>> 24;
          }
          function ze(ee, ve) {
            return (ee[ve] | ee[ve + 1] << 8 | ee[ve + 2] << 16) + (ee[ve + 3] << 24);
          }
          return c.prototype = { destroy: function() {
            this.buf = null;
          }, readFields: function(ee, ve, qe) {
            for (qe = qe || this.length; this.pos < qe; ) {
              var _t = this.readVarint(), $t = _t >> 3, Rt = this.pos;
              this.type = 7 & _t, ee($t, ve, this), this.pos === Rt && this.skip(_t);
            }
            return ve;
          }, readMessage: function(ee, ve) {
            return this.readFields(ee, ve, this.readVarint() + this.pos);
          }, readFixed32: function() {
            var ee = Ee(this.buf, this.pos);
            return this.pos += 4, ee;
          }, readSFixed32: function() {
            var ee = ze(this.buf, this.pos);
            return this.pos += 4, ee;
          }, readFixed64: function() {
            var ee = Ee(this.buf, this.pos) + Ee(this.buf, this.pos + 4) * u;
            return this.pos += 8, ee;
          }, readSFixed64: function() {
            var ee = Ee(this.buf, this.pos) + ze(this.buf, this.pos + 4) * u;
            return this.pos += 8, ee;
          }, readFloat: function() {
            var ee = f.read(this.buf, this.pos, !0, 23, 4);
            return this.pos += 4, ee;
          }, readDouble: function() {
            var ee = f.read(this.buf, this.pos, !0, 52, 8);
            return this.pos += 8, ee;
          }, readVarint: function(ee) {
            var ve, qe, _t = this.buf;
            return ve = 127 & (qe = _t[this.pos++]), qe < 128 ? ve : (ve |= (127 & (qe = _t[this.pos++])) << 7, qe < 128 ? ve : (ve |= (127 & (qe = _t[this.pos++])) << 14, qe < 128 ? ve : (ve |= (127 & (qe = _t[this.pos++])) << 21, qe < 128 ? ve : function($t, Rt, Ot) {
              var Qt, Wt, nr = Ot.buf;
              if (Qt = (112 & (Wt = nr[Ot.pos++])) >> 4, Wt < 128 || (Qt |= (127 & (Wt = nr[Ot.pos++])) << 3, Wt < 128) || (Qt |= (127 & (Wt = nr[Ot.pos++])) << 10, Wt < 128) || (Qt |= (127 & (Wt = nr[Ot.pos++])) << 17, Wt < 128) || (Qt |= (127 & (Wt = nr[Ot.pos++])) << 24, Wt < 128) || (Qt |= (1 & (Wt = nr[Ot.pos++])) << 31, Wt < 128)) return T($t, Qt, Rt);
              throw new Error("Expected varint not more than 10 bytes");
            }(ve |= (15 & (qe = _t[this.pos])) << 28, ee, this))));
          }, readVarint64: function() {
            return this.readVarint(!0);
          }, readSVarint: function() {
            var ee = this.readVarint();
            return ee % 2 == 1 ? (ee + 1) / -2 : ee / 2;
          }, readBoolean: function() {
            return !!this.readVarint();
          }, readString: function() {
            var ee = this.readVarint() + this.pos, ve = this.pos;
            return this.pos = ee, ee - ve >= 12 && _ ? function(qe, _t, $t) {
              return _.decode(qe.subarray(_t, $t));
            }(this.buf, ve, ee) : function(qe, _t, $t) {
              for (var Rt = "", Ot = _t; Ot < $t; ) {
                var Qt, Wt, nr, Ft = qe[Ot], Pr = null, jr = Ft > 239 ? 4 : Ft > 223 ? 3 : Ft > 191 ? 2 : 1;
                if (Ot + jr > $t) break;
                jr === 1 ? Ft < 128 && (Pr = Ft) : jr === 2 ? (192 & (Qt = qe[Ot + 1])) == 128 && (Pr = (31 & Ft) << 6 | 63 & Qt) <= 127 && (Pr = null) : jr === 3 ? (Wt = qe[Ot + 2], (192 & (Qt = qe[Ot + 1])) == 128 && (192 & Wt) == 128 && ((Pr = (15 & Ft) << 12 | (63 & Qt) << 6 | 63 & Wt) <= 2047 || Pr >= 55296 && Pr <= 57343) && (Pr = null)) : jr === 4 && (Wt = qe[Ot + 2], nr = qe[Ot + 3], (192 & (Qt = qe[Ot + 1])) == 128 && (192 & Wt) == 128 && (192 & nr) == 128 && ((Pr = (15 & Ft) << 18 | (63 & Qt) << 12 | (63 & Wt) << 6 | 63 & nr) <= 65535 || Pr >= 1114112) && (Pr = null)), Pr === null ? (Pr = 65533, jr = 1) : Pr > 65535 && (Pr -= 65536, Rt += String.fromCharCode(Pr >>> 10 & 1023 | 55296), Pr = 56320 | 1023 & Pr), Rt += String.fromCharCode(Pr), Ot += jr;
              }
              return Rt;
            }(this.buf, ve, ee);
          }, readBytes: function() {
            var ee = this.readVarint() + this.pos, ve = this.buf.subarray(this.pos, ee);
            return this.pos = ee, ve;
          }, readPackedVarint: function(ee, ve) {
            if (this.type !== c.Bytes) return ee.push(this.readVarint(ve));
            var qe = x(this);
            for (ee = ee || []; this.pos < qe; ) ee.push(this.readVarint(ve));
            return ee;
          }, readPackedSVarint: function(ee) {
            if (this.type !== c.Bytes) return ee.push(this.readSVarint());
            var ve = x(this);
            for (ee = ee || []; this.pos < ve; ) ee.push(this.readSVarint());
            return ee;
          }, readPackedBoolean: function(ee) {
            if (this.type !== c.Bytes) return ee.push(this.readBoolean());
            var ve = x(this);
            for (ee = ee || []; this.pos < ve; ) ee.push(this.readBoolean());
            return ee;
          }, readPackedFloat: function(ee) {
            if (this.type !== c.Bytes) return ee.push(this.readFloat());
            var ve = x(this);
            for (ee = ee || []; this.pos < ve; ) ee.push(this.readFloat());
            return ee;
          }, readPackedDouble: function(ee) {
            if (this.type !== c.Bytes) return ee.push(this.readDouble());
            var ve = x(this);
            for (ee = ee || []; this.pos < ve; ) ee.push(this.readDouble());
            return ee;
          }, readPackedFixed32: function(ee) {
            if (this.type !== c.Bytes) return ee.push(this.readFixed32());
            var ve = x(this);
            for (ee = ee || []; this.pos < ve; ) ee.push(this.readFixed32());
            return ee;
          }, readPackedSFixed32: function(ee) {
            if (this.type !== c.Bytes) return ee.push(this.readSFixed32());
            var ve = x(this);
            for (ee = ee || []; this.pos < ve; ) ee.push(this.readSFixed32());
            return ee;
          }, readPackedFixed64: function(ee) {
            if (this.type !== c.Bytes) return ee.push(this.readFixed64());
            var ve = x(this);
            for (ee = ee || []; this.pos < ve; ) ee.push(this.readFixed64());
            return ee;
          }, readPackedSFixed64: function(ee) {
            if (this.type !== c.Bytes) return ee.push(this.readSFixed64());
            var ve = x(this);
            for (ee = ee || []; this.pos < ve; ) ee.push(this.readSFixed64());
            return ee;
          }, skip: function(ee) {
            var ve = 7 & ee;
            if (ve === c.Varint) for (; this.buf[this.pos++] > 127; ) ;
            else if (ve === c.Bytes) this.pos = this.readVarint() + this.pos;
            else if (ve === c.Fixed32) this.pos += 4;
            else {
              if (ve !== c.Fixed64) throw new Error("Unimplemented type: " + ve);
              this.pos += 8;
            }
          }, writeTag: function(ee, ve) {
            this.writeVarint(ee << 3 | ve);
          }, realloc: function(ee) {
            for (var ve = this.length || 16; ve < this.pos + ee; ) ve *= 2;
            if (ve !== this.length) {
              var qe = new Uint8Array(ve);
              qe.set(this.buf), this.buf = qe, this.length = ve;
            }
          }, finish: function() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          }, writeFixed32: function(ee) {
            this.realloc(4), Je(this.buf, ee, this.pos), this.pos += 4;
          }, writeSFixed32: function(ee) {
            this.realloc(4), Je(this.buf, ee, this.pos), this.pos += 4;
          }, writeFixed64: function(ee) {
            this.realloc(8), Je(this.buf, -1 & ee, this.pos), Je(this.buf, Math.floor(ee * p), this.pos + 4), this.pos += 8;
          }, writeSFixed64: function(ee) {
            this.realloc(8), Je(this.buf, -1 & ee, this.pos), Je(this.buf, Math.floor(ee * p), this.pos + 4), this.pos += 8;
          }, writeVarint: function(ee) {
            (ee = +ee || 0) > 268435455 || ee < 0 ? function(ve, qe) {
              var _t, $t;
              if (ve >= 0 ? (_t = ve % 4294967296 | 0, $t = ve / 4294967296 | 0) : ($t = ~(-ve / 4294967296), 4294967295 ^ (_t = ~(-ve % 4294967296)) ? _t = _t + 1 | 0 : (_t = 0, $t = $t + 1 | 0)), ve >= 18446744073709552e3 || ve < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              qe.realloc(10), function(Rt, Ot, Qt) {
                Qt.buf[Qt.pos++] = 127 & Rt | 128, Rt >>>= 7, Qt.buf[Qt.pos++] = 127 & Rt | 128, Rt >>>= 7, Qt.buf[Qt.pos++] = 127 & Rt | 128, Rt >>>= 7, Qt.buf[Qt.pos++] = 127 & Rt | 128, Qt.buf[Qt.pos] = 127 & (Rt >>>= 7);
              }(_t, 0, qe), function(Rt, Ot) {
                var Qt = (7 & Rt) << 4;
                Ot.buf[Ot.pos++] |= Qt | ((Rt >>>= 3) ? 128 : 0), Rt && (Ot.buf[Ot.pos++] = 127 & Rt | ((Rt >>>= 7) ? 128 : 0), Rt && (Ot.buf[Ot.pos++] = 127 & Rt | ((Rt >>>= 7) ? 128 : 0), Rt && (Ot.buf[Ot.pos++] = 127 & Rt | ((Rt >>>= 7) ? 128 : 0), Rt && (Ot.buf[Ot.pos++] = 127 & Rt | ((Rt >>>= 7) ? 128 : 0), Rt && (Ot.buf[Ot.pos++] = 127 & Rt)))));
              }($t, qe);
            }(ee, this) : (this.realloc(4), this.buf[this.pos++] = 127 & ee | (ee > 127 ? 128 : 0), ee <= 127 || (this.buf[this.pos++] = 127 & (ee >>>= 7) | (ee > 127 ? 128 : 0), ee <= 127 || (this.buf[this.pos++] = 127 & (ee >>>= 7) | (ee > 127 ? 128 : 0), ee <= 127 || (this.buf[this.pos++] = ee >>> 7 & 127))));
          }, writeSVarint: function(ee) {
            this.writeVarint(ee < 0 ? 2 * -ee - 1 : 2 * ee);
          }, writeBoolean: function(ee) {
            this.writeVarint(!!ee);
          }, writeString: function(ee) {
            ee = String(ee), this.realloc(4 * ee.length), this.pos++;
            var ve = this.pos;
            this.pos = function(_t, $t, Rt) {
              for (var Ot, Qt, Wt = 0; Wt < $t.length; Wt++) {
                if ((Ot = $t.charCodeAt(Wt)) > 55295 && Ot < 57344) {
                  if (!Qt) {
                    Ot > 56319 || Wt + 1 === $t.length ? (_t[Rt++] = 239, _t[Rt++] = 191, _t[Rt++] = 189) : Qt = Ot;
                    continue;
                  }
                  if (Ot < 56320) {
                    _t[Rt++] = 239, _t[Rt++] = 191, _t[Rt++] = 189, Qt = Ot;
                    continue;
                  }
                  Ot = Qt - 55296 << 10 | Ot - 56320 | 65536, Qt = null;
                } else Qt && (_t[Rt++] = 239, _t[Rt++] = 191, _t[Rt++] = 189, Qt = null);
                Ot < 128 ? _t[Rt++] = Ot : (Ot < 2048 ? _t[Rt++] = Ot >> 6 | 192 : (Ot < 65536 ? _t[Rt++] = Ot >> 12 | 224 : (_t[Rt++] = Ot >> 18 | 240, _t[Rt++] = Ot >> 12 & 63 | 128), _t[Rt++] = Ot >> 6 & 63 | 128), _t[Rt++] = 63 & Ot | 128);
              }
              return Rt;
            }(this.buf, ee, this.pos);
            var qe = this.pos - ve;
            qe >= 128 && I(ve, qe, this), this.pos = ve - 1, this.writeVarint(qe), this.pos += qe;
          }, writeFloat: function(ee) {
            this.realloc(4), f.write(this.buf, ee, this.pos, !0, 23, 4), this.pos += 4;
          }, writeDouble: function(ee) {
            this.realloc(8), f.write(this.buf, ee, this.pos, !0, 52, 8), this.pos += 8;
          }, writeBytes: function(ee) {
            var ve = ee.length;
            this.writeVarint(ve), this.realloc(ve);
            for (var qe = 0; qe < ve; qe++) this.buf[this.pos++] = ee[qe];
          }, writeRawMessage: function(ee, ve) {
            this.pos++;
            var qe = this.pos;
            ee(ve, this);
            var _t = this.pos - qe;
            _t >= 128 && I(qe, _t, this), this.pos = qe - 1, this.writeVarint(_t), this.pos += _t;
          }, writeMessage: function(ee, ve, qe) {
            this.writeTag(ee, c.Bytes), this.writeRawMessage(ve, qe);
          }, writePackedVarint: function(ee, ve) {
            ve.length && this.writeMessage(ee, B, ve);
          }, writePackedSVarint: function(ee, ve) {
            ve.length && this.writeMessage(ee, N, ve);
          }, writePackedBoolean: function(ee, ve) {
            ve.length && this.writeMessage(ee, J, ve);
          }, writePackedFloat: function(ee, ve) {
            ve.length && this.writeMessage(ee, z, ve);
          }, writePackedDouble: function(ee, ve) {
            ve.length && this.writeMessage(ee, $, ve);
          }, writePackedFixed32: function(ee, ve) {
            ve.length && this.writeMessage(ee, te, ve);
          }, writePackedSFixed32: function(ee, ve) {
            ve.length && this.writeMessage(ee, ne, ve);
          }, writePackedFixed64: function(ee, ve) {
            ve.length && this.writeMessage(ee, ue, ve);
          }, writePackedSFixed64: function(ee, ve) {
            ve.length && this.writeMessage(ee, Se, ve);
          }, writeBytesField: function(ee, ve) {
            this.writeTag(ee, c.Bytes), this.writeBytes(ve);
          }, writeFixed32Field: function(ee, ve) {
            this.writeTag(ee, c.Fixed32), this.writeFixed32(ve);
          }, writeSFixed32Field: function(ee, ve) {
            this.writeTag(ee, c.Fixed32), this.writeSFixed32(ve);
          }, writeFixed64Field: function(ee, ve) {
            this.writeTag(ee, c.Fixed64), this.writeFixed64(ve);
          }, writeSFixed64Field: function(ee, ve) {
            this.writeTag(ee, c.Fixed64), this.writeSFixed64(ve);
          }, writeVarintField: function(ee, ve) {
            this.writeTag(ee, c.Varint), this.writeVarint(ve);
          }, writeSVarintField: function(ee, ve) {
            this.writeTag(ee, c.Varint), this.writeSVarint(ve);
          }, writeStringField: function(ee, ve) {
            this.writeTag(ee, c.Bytes), this.writeString(ve);
          }, writeFloatField: function(ee, ve) {
            this.writeTag(ee, c.Fixed32), this.writeFloat(ve);
          }, writeDoubleField: function(ee, ve) {
            this.writeTag(ee, c.Fixed64), this.writeDouble(ve);
          }, writeBooleanField: function(ee, ve) {
            this.writeVarintField(ee, !!ve);
          } }, A0;
        }
        var wh, S0 = d(yw());
        function bR(f, c, u) {
          f === 1 && u.readMessage(vR, c);
        }
        function vR(f, c, u) {
          if (f === 3) {
            const { id: p, bitmap: _, width: x, height: T, left: I, top: B, advance: N } = u.readMessage(xR, {});
            c.push({ id: p, bitmap: new Mp({ width: x + 6, height: T + 6 }, _), metrics: { width: x, height: T, left: I, top: B, advance: N } });
          }
        }
        function xR(f, c, u) {
          f === 1 ? c.id = u.readVarint() : f === 2 ? c.bitmap = u.readBytes() : f === 3 ? c.width = u.readVarint() : f === 4 ? c.height = u.readVarint() : f === 5 ? c.left = u.readSVarint() : f === 6 ? c.top = u.readSVarint() : f === 7 && (c.advance = u.readVarint());
        }
        function bw(f) {
          let c = 0, u = 0;
          for (const T of f) c += T.w * T.h, u = Math.max(u, T.w);
          f.sort((T, I) => I.h - T.h);
          const p = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(c / 0.95)), u), h: 1 / 0 }];
          let _ = 0, x = 0;
          for (const T of f) for (let I = p.length - 1; I >= 0; I--) {
            const B = p[I];
            if (!(T.w > B.w || T.h > B.h)) {
              if (T.x = B.x, T.y = B.y, x = Math.max(x, T.y + T.h), _ = Math.max(_, T.x + T.w), T.w === B.w && T.h === B.h) {
                const N = p.pop();
                I < p.length && (p[I] = N);
              } else T.h === B.h ? (B.x += T.w, B.w -= T.w) : T.w === B.w ? (B.y += T.h, B.h -= T.h) : (p.push({ x: B.x + T.w, y: B.y, w: B.w - T.w, h: T.h }), B.y += T.h, B.h -= T.h);
              break;
            }
          }
          return { w: _, h: x, fill: c / (_ * x) || 0 };
        }
        class E0 {
          constructor(c, u) {
            let { pixelRatio: p, version: _, stretchX: x, stretchY: T, content: I, textFitWidth: B, textFitHeight: N } = u;
            this.paddedRect = c, this.pixelRatio = p, this.stretchX = x, this.stretchY = T, this.content = I, this.version = _, this.textFitWidth = B, this.textFitHeight = N;
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
          }
          get tlbr() {
            return this.tl.concat(this.br);
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
          }
        }
        class vw {
          constructor(c, u) {
            const p = {}, _ = {};
            this.haveRenderCallbacks = [];
            const x = [];
            this.addImages(c, p, x), this.addImages(u, _, x);
            const { w: T, h: I } = bw(x), B = new ga({ width: T || 1, height: I || 1 });
            for (const N in c) {
              const z = c[N], $ = p[N].paddedRect;
              ga.copy(z.data, B, { x: 0, y: 0 }, { x: $.x + 1, y: $.y + 1 }, z.data);
            }
            for (const N in u) {
              const z = u[N], $ = _[N].paddedRect, J = $.x + 1, te = $.y + 1, ne = z.data.width, ue = z.data.height;
              ga.copy(z.data, B, { x: 0, y: 0 }, { x: J, y: te }, z.data), ga.copy(z.data, B, { x: 0, y: ue - 1 }, { x: J, y: te - 1 }, { width: ne, height: 1 }), ga.copy(z.data, B, { x: 0, y: 0 }, { x: J, y: te + ue }, { width: ne, height: 1 }), ga.copy(z.data, B, { x: ne - 1, y: 0 }, { x: J - 1, y: te }, { width: 1, height: ue }), ga.copy(z.data, B, { x: 0, y: 0 }, { x: J + ne, y: te }, { width: 1, height: ue });
            }
            this.image = B, this.iconPositions = p, this.patternPositions = _;
          }
          addImages(c, u, p) {
            for (const _ in c) {
              const x = c[_], T = { x: 0, y: 0, w: x.data.width + 2, h: x.data.height + 2 };
              p.push(T), u[_] = new E0(T, x), x.hasRenderCallback && this.haveRenderCallbacks.push(_);
            }
          }
          patchUpdatedImages(c, u) {
            c.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const p in c.updatedImages) this.patchUpdatedImage(this.iconPositions[p], c.getImage(p), u), this.patchUpdatedImage(this.patternPositions[p], c.getImage(p), u);
          }
          patchUpdatedImage(c, u, p) {
            if (!c || !u || c.version === u.version) return;
            c.version = u.version;
            const [_, x] = c.tl;
            p.update(u.data, void 0, { x: _, y: x });
          }
        }
        Re("ImagePosition", E0), Re("ImageAtlas", vw), l.an = void 0, (wh = l.an || (l.an = {}))[wh.none = 0] = "none", wh[wh.horizontal = 1] = "horizontal", wh[wh.vertical = 2] = "vertical", wh[wh.horizontalOnly = 3] = "horizontalOnly";
        class zp {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom";
          }
          static forText(c, u, p) {
            const _ = new zp();
            return _.scale = c || 1, _.fontStack = u, _.verticalAlign = p || "bottom", _;
          }
          static forImage(c, u) {
            const p = new zp();
            return p.imageName = c, p.verticalAlign = u || "bottom", p;
          }
        }
        class ud {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(c, u) {
            const p = new ud();
            for (let _ = 0; _ < c.sections.length; _++) {
              const x = c.sections[_];
              x.image ? p.addImageSection(x) : p.addTextSection(x, u);
            }
            return p;
          }
          length() {
            return this.text.length;
          }
          getSection(c) {
            return this.sections[this.sectionIndex[c]];
          }
          getSectionIndex(c) {
            return this.sectionIndex[c];
          }
          getCharCode(c) {
            return this.text.charCodeAt(c);
          }
          verticalizePunctuation() {
            this.text = function(c) {
              let u = "";
              for (let p = 0; p < c.length; p++) {
                const _ = c.charCodeAt(p + 1) || null, x = c.charCodeAt(p - 1) || null;
                u += _ && Pn(_) && !Up[c[p + 1]] || x && Pn(x) && !Up[c[p - 1]] || !Up[c[p]] ? c[p] : Up[c[p]];
              }
              return u;
            }(this.text);
          }
          trim() {
            let c = 0;
            for (let p = 0; p < this.text.length && hm[this.text.charCodeAt(p)]; p++) c++;
            let u = this.text.length;
            for (let p = this.text.length - 1; p >= 0 && p >= c && hm[this.text.charCodeAt(p)]; p--) u--;
            this.text = this.text.substring(c, u), this.sectionIndex = this.sectionIndex.slice(c, u);
          }
          substring(c, u) {
            const p = new ud();
            return p.text = this.text.substring(c, u), p.sectionIndex = this.sectionIndex.slice(c, u), p.sections = this.sections, p;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce((c, u) => Math.max(c, this.sections[u].scale), 0);
          }
          getMaxImageSize(c) {
            let u = 0, p = 0;
            for (let _ = 0; _ < this.length(); _++) {
              const x = this.getSection(_);
              if (x.imageName) {
                const T = c[x.imageName];
                if (!T) continue;
                const I = T.displaySize;
                u = Math.max(u, I[0]), p = Math.max(p, I[1]);
              }
            }
            return { maxImageWidth: u, maxImageHeight: p };
          }
          addTextSection(c, u) {
            this.text += c.text, this.sections.push(zp.forText(c.scale, c.fontStack || u, c.verticalAlign));
            const p = this.sections.length - 1;
            for (let _ = 0; _ < c.text.length; ++_) this.sectionIndex.push(p);
          }
          addImageSection(c) {
            const u = c.image ? c.image.name : "";
            if (u.length === 0) return void Dr("Can't add FormattedSection with an empty image.");
            const p = this.getNextImageSectionCharCode();
            p ? (this.text += String.fromCharCode(p), this.sections.push(zp.forImage(u, c.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : Dr("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function um(f, c, u, p, _, x, T, I, B, N, z, $, J, te, ne) {
          const ue = ud.fromFeature(f, _);
          let Se;
          $ === l.an.vertical && ue.verticalizePunctuation();
          const { processBidirectionalText: Ee, processStyledBidirectionalText: Je } = Cn;
          if (Ee && ue.sections.length === 1) {
            Se = [];
            const ve = Ee(ue.toString(), C0(ue, N, x, c, p, te));
            for (const qe of ve) {
              const _t = new ud();
              _t.text = qe, _t.sections = ue.sections;
              for (let $t = 0; $t < qe.length; $t++) _t.sectionIndex.push(0);
              Se.push(_t);
            }
          } else if (Je) {
            Se = [];
            const ve = Je(ue.text, ue.sectionIndex, C0(ue, N, x, c, p, te));
            for (const qe of ve) {
              const _t = new ud();
              _t.text = qe[0], _t.sectionIndex = qe[1], _t.sections = ue.sections, Se.push(_t);
            }
          } else Se = function(ve, qe) {
            const _t = [], $t = ve.text;
            let Rt = 0;
            for (const Ot of qe) _t.push(ve.substring(Rt, Ot)), Rt = Ot;
            return Rt < $t.length && _t.push(ve.substring(Rt, $t.length)), _t;
          }(ue, C0(ue, N, x, c, p, te));
          const ze = [], ee = { positionedLines: ze, text: ue.toString(), top: z[1], bottom: z[1], left: z[0], right: z[0], writingMode: $, iconsInText: !1, verticalizable: !1 };
          return function(ve, qe, _t, $t, Rt, Ot, Qt, Wt, nr, Ft, Pr, jr) {
            let kr = 0, Rr = 0, Tn = 0, Ui = 0;
            const ls = Wt === "right" ? 1 : Wt === "left" ? 0 : 0.5, qo = Ls / jr;
            let ma = 0;
            for (const qi of Rt) {
              qi.trim();
              const Ts = qi.getMaxScale(), Qs = { positionedGlyphs: [], lineOffset: 0 };
              ve.positionedLines[ma] = Qs;
              const cs = Qs.positionedGlyphs;
              let Go = 0;
              if (!qi.length()) {
                Rr += Ot, ++ma;
                continue;
              }
              const ll = SR($t, qi, qo);
              for (let ya = 0; ya < qi.length(); ya++) {
                const Ss = qi.getSection(ya), ks = qi.getSectionIndex(ya), Ns = qi.getCharCode(ya), us = ER(nr, Pr, Ns);
                let mi;
                if (Ss.imageName) {
                  if (ve.iconsInText = !0, Ss.scale = Ss.scale * qo, mi = IR(Ss, us, Ts, ll, $t), !mi) continue;
                  Go = Math.max(Go, mi.imageOffset);
                } else if (mi = CR(Ss, Ns, us, ll, qe, _t), !mi) continue;
                const { rect: cc, metrics: pd, baselineOffset: uc } = mi;
                cs.push({ glyph: Ns, imageName: Ss.imageName, x: kr, y: Rr + uc + -17, vertical: us, scale: Ss.scale, fontStack: Ss.fontStack, sectionIndex: ks, metrics: pd, rect: cc }), us ? (ve.verticalizable = !0, kr += (Ss.imageName ? pd.advance : Ls) * Ss.scale + Ft) : kr += pd.advance * Ss.scale + Ft;
              }
              cs.length !== 0 && (Tn = Math.max(kr - Ft, Tn), MR(cs, 0, cs.length - 1, ls)), kr = 0, Qs.lineOffset = Math.max(Go, (Ts - 1) * Ls);
              const Os = Ot * Ts + Go;
              Rr += Os, Ui = Math.max(Os, Ui), ++ma;
            }
            const { horizontalAlign: _a, verticalAlign: Js } = I0(Qt);
            (function(qi, Ts, Qs, cs, Go, ll, Os, ya, Ss) {
              const ks = (Ts - Qs) * Go;
              let Ns = 0;
              Ns = ll !== Os ? -ya * cs - -17 : -cs * Ss * Os + 0.5 * Os;
              for (const us of qi) for (const mi of us.positionedGlyphs) mi.x += ks, mi.y += Ns;
            })(ve.positionedLines, ls, _a, Js, Tn, Ui, Ot, Rr, Rt.length), ve.top += -Js * Rr, ve.bottom = ve.top + Rr, ve.left += -_a * Tn, ve.right = ve.left + Tn;
          }(ee, c, u, p, Se, T, I, B, $, N, J, ne), !function(ve) {
            for (const qe of ve) if (qe.positionedGlyphs.length !== 0) return !1;
            return !0;
          }(ze) && ee;
        }
        const hm = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, wR = { 10: !0, 32: !0, 38: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 }, AR = { 40: !0 };
        function xw(f, c, u, p, _, x) {
          if (c.imageName) {
            const T = p[c.imageName];
            return T ? T.displaySize[0] * c.scale * Ls / x + _ : 0;
          }
          {
            const T = u[c.fontStack], I = T && T[f];
            return I ? I.metrics.advance * c.scale + _ : 0;
          }
        }
        function ww(f, c, u, p) {
          const _ = Math.pow(f - c, 2);
          return p ? f < c ? _ / 2 : 2 * _ : _ + Math.abs(u) * u;
        }
        function TR(f, c, u) {
          let p = 0;
          return f === 10 && (p -= 1e4), u && (p += 150), f !== 40 && f !== 65288 || (p += 50), c !== 41 && c !== 65289 || (p += 50), p;
        }
        function Aw(f, c, u, p, _, x) {
          let T = null, I = ww(c, u, _, x);
          for (const B of p) {
            const N = ww(c - B.x, u, _, x) + B.badness;
            N <= I && (T = B, I = N);
          }
          return { index: f, x: c, priorBreak: T, badness: I };
        }
        function Tw(f) {
          return f ? Tw(f.priorBreak).concat(f.index) : [];
        }
        function C0(f, c, u, p, _, x) {
          if (!f) return [];
          const T = [], I = function($, J, te, ne, ue, Se) {
            let Ee = 0;
            for (let Je = 0; Je < $.length(); Je++) {
              const ze = $.getSection(Je);
              Ee += xw($.getCharCode(Je), ze, ne, ue, J, Se);
            }
            return Ee / Math.max(1, Math.ceil(Ee / te));
          }(f, c, u, p, _, x), B = f.text.indexOf("​") >= 0;
          let N = 0;
          for (let $ = 0; $ < f.length(); $++) {
            const J = f.getSection($), te = f.getCharCode($);
            if (hm[te] || (N += xw(te, J, p, _, c, x)), $ < f.length() - 1) {
              const ne = !((z = te) < 11904) && (!!Xe["CJK Compatibility Forms"](z) || !!Xe["CJK Compatibility"](z) || !!Xe["CJK Strokes"](z) || !!Xe["CJK Symbols and Punctuation"](z) || !!Xe["Enclosed CJK Letters and Months"](z) || !!Xe["Halfwidth and Fullwidth Forms"](z) || !!Xe["Ideographic Description Characters"](z) || !!Xe["Vertical Forms"](z) || $r.test(String.fromCodePoint(z)));
              (wR[te] || ne || J.imageName || $ !== f.length() - 2 && AR[f.getCharCode($ + 1)]) && T.push(Aw($ + 1, N, I, T, TR(te, f.getCharCode($ + 1), ne && B), !1));
            }
          }
          var z;
          return Tw(Aw(f.length(), N, I, T, 0, !0));
        }
        function I0(f) {
          let c = 0.5, u = 0.5;
          switch (f) {
            case "right":
            case "top-right":
            case "bottom-right":
              c = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              c = 0;
          }
          switch (f) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              u = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              u = 0;
          }
          return { horizontalAlign: c, verticalAlign: u };
        }
        function SR(f, c, u) {
          const p = c.getMaxScale() * Ls, { maxImageWidth: _, maxImageHeight: x } = c.getMaxImageSize(f), T = Math.max(p, x * u);
          return { verticalLineContentWidth: Math.max(p, _ * u), horizontalLineContentHeight: T };
        }
        function Sw(f) {
          switch (f) {
            case "top":
              return 0;
            case "center":
              return 0.5;
            default:
              return 1;
          }
        }
        function ER(f, c, u) {
          return !(f === l.an.horizontal || !c && !br(u) || c && (hm[u] || (p = u, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(p)))));
          var p;
        }
        function CR(f, c, u, p, _, x) {
          const T = x[f.fontStack], I = function(N, z, $, J) {
            if (N && N.rect) return N;
            const te = z[$.fontStack], ne = te && te[J];
            return ne ? { rect: null, metrics: ne.metrics } : null;
          }(T && T[c], _, f, c);
          if (I === null) return null;
          let B;
          if (u) B = p.verticalLineContentWidth - f.scale * Ls;
          else {
            const N = Sw(f.verticalAlign);
            B = (p.horizontalLineContentHeight - f.scale * Ls) * N;
          }
          return { rect: I.rect, metrics: I.metrics, baselineOffset: B };
        }
        function IR(f, c, u, p, _) {
          const x = _[f.imageName];
          if (!x) return null;
          const T = x.paddedRect, I = x.displaySize, B = { width: I[0], height: I[1], left: 1, top: -3, advance: c ? I[1] : I[0] };
          let N;
          if (c) N = p.verticalLineContentWidth - I[1] * f.scale;
          else {
            const z = Sw(f.verticalAlign);
            N = (p.horizontalLineContentHeight - I[1] * f.scale) * z;
          }
          return { rect: T, metrics: B, baselineOffset: N, imageOffset: (c ? I[0] : I[1]) * f.scale - Ls * u };
        }
        function MR(f, c, u, p) {
          if (p === 0) return;
          const _ = f[u], x = (f[u].x + _.metrics.advance * _.scale) * p;
          for (let T = c; T <= u; T++) f[T].x -= x;
        }
        function PR(f, c, u) {
          const { horizontalAlign: p, verticalAlign: _ } = I0(u), x = c[0] - f.displaySize[0] * p, T = c[1] - f.displaySize[1] * _;
          return { image: f, top: T, bottom: T + f.displaySize[1], left: x, right: x + f.displaySize[0] };
        }
        function Ew(f) {
          var c, u;
          let p = f.left, _ = f.top, x = f.right - p, T = f.bottom - _;
          const I = (c = f.image.textFitWidth) !== null && c !== void 0 ? c : "stretchOrShrink", B = (u = f.image.textFitHeight) !== null && u !== void 0 ? u : "stretchOrShrink", N = (f.image.content[2] - f.image.content[0]) / (f.image.content[3] - f.image.content[1]);
          if (B === "proportional") {
            if (I === "stretchOnly" && x / T < N || I === "proportional") {
              const z = Math.ceil(T * N);
              p *= z / x, x = z;
            }
          } else if (I === "proportional" && B === "stretchOnly" && N !== 0 && x / T > N) {
            const z = Math.ceil(x / N);
            _ *= z / T, T = z;
          }
          return { x1: p, y1: _, x2: p + x, y2: _ + T };
        }
        function Cw(f, c, u, p, _, x) {
          const T = f.image;
          let I;
          if (T.content) {
            const Se = T.content, Ee = T.pixelRatio || 1;
            I = [Se[0] / Ee, Se[1] / Ee, T.displaySize[0] - Se[2] / Ee, T.displaySize[1] - Se[3] / Ee];
          }
          const B = c.left * x, N = c.right * x;
          let z, $, J, te;
          u === "width" || u === "both" ? (te = _[0] + B - p[3], $ = _[0] + N + p[1]) : (te = _[0] + (B + N - T.displaySize[0]) / 2, $ = te + T.displaySize[0]);
          const ne = c.top * x, ue = c.bottom * x;
          return u === "height" || u === "both" ? (z = _[1] + ne - p[0], J = _[1] + ue + p[2]) : (z = _[1] + (ne + ue - T.displaySize[1]) / 2, J = z + T.displaySize[1]), { image: T, top: z, right: $, bottom: J, left: te, collisionPadding: I };
        }
        const qu = 128, Ah = 32640;
        function Iw(f, c) {
          const { expression: u } = c;
          if (u.kind === "constant") return { kind: "constant", layoutSize: u.evaluate(new Br(f + 1)) };
          if (u.kind === "source") return { kind: "source" };
          {
            const { zoomStops: p, interpolationType: _ } = u;
            let x = 0;
            for (; x < p.length && p[x] <= f; ) x++;
            x = Math.max(0, x - 1);
            let T = x;
            for (; T < p.length && p[T] < f + 1; ) T++;
            T = Math.min(p.length - 1, T);
            const I = p[x], B = p[T];
            return u.kind === "composite" ? { kind: "composite", minZoom: I, maxZoom: B, interpolationType: _ } : { kind: "camera", minZoom: I, maxZoom: B, minSize: u.evaluate(new Br(I)), maxSize: u.evaluate(new Br(B)), interpolationType: _ };
          }
        }
        function M0(f, c, u) {
          let p = "never";
          const _ = f.get(c);
          return _ ? p = _ : f.get(u) && (p = "always"), p;
        }
        const RR = Np.VectorTileFeature.types, BR = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function fm(f, c, u, p, _, x, T, I, B, N, z, $, J) {
          const te = I ? Math.min(Ah, Math.round(I[0])) : 0, ne = I ? Math.min(Ah, Math.round(I[1])) : 0;
          f.emplaceBack(c, u, Math.round(32 * p), Math.round(32 * _), x, T, (te << 1) + (B ? 1 : 0), ne, 16 * N, 16 * z, 256 * $, 256 * J);
        }
        function P0(f, c, u) {
          f.emplaceBack(c.x, c.y, u), f.emplaceBack(c.x, c.y, u), f.emplaceBack(c.x, c.y, u), f.emplaceBack(c.x, c.y, u);
        }
        function LR(f) {
          for (const c of f.sections) if (Vn(c.text)) return !0;
          return !1;
        }
        class R0 {
          constructor(c) {
            this.layoutVertexArray = new an(), this.indexArray = new In(), this.programConfigurations = c, this.segments = new yn(), this.dynamicLayoutVertexArray = new An(), this.opacityVertexArray = new ni(), this.hasVisibleVertices = !1, this.placedSymbolArray = new Te();
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
          }
          upload(c, u, p, _) {
            this.isEmpty() || (p && (this.layoutVertexBuffer = c.createVertexBuffer(this.layoutVertexArray, dR.members), this.indexBuffer = c.createIndexBuffer(this.indexArray, u), this.dynamicLayoutVertexBuffer = c.createVertexBuffer(this.dynamicLayoutVertexArray, pR.members, !0), this.opacityVertexBuffer = c.createVertexBuffer(this.opacityVertexArray, BR, !0), this.opacityVertexBuffer.itemSize = 1), (p || _) && this.programConfigurations.upload(c));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
          }
        }
        Re("SymbolBuffers", R0);
        class B0 {
          constructor(c, u, p) {
            this.layoutVertexArray = new c(), this.layoutAttributes = u, this.indexArray = new p(), this.segments = new yn(), this.collisionVertexArray = new kn();
          }
          upload(c) {
            this.layoutVertexBuffer = c.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = c.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = c.createVertexBuffer(this.collisionVertexArray, gR.members, !0);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
          }
        }
        Re("CollisionBuffers", B0);
        class hd {
          constructor(c) {
            this.collisionBoxArray = c.collisionBoxArray, this.zoom = c.zoom, this.globalState = c.globalState, this.overscaling = c.overscaling, this.layers = c.layers, this.layerIds = this.layers.map((T) => T.id), this.index = c.index, this.pixelRatio = c.pixelRatio, this.sourceLayerIndex = c.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const u = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = Iw(this.zoom, u["text-size"]), this.iconSizeData = Iw(this.zoom, u["icon-size"]);
            const p = this.layers[0].layout, _ = p.get("symbol-sort-key"), x = p.get("symbol-z-order");
            this.canOverlap = M0(p, "text-overlap", "text-allow-overlap") !== "never" || M0(p, "icon-overlap", "icon-allow-overlap") !== "never" || p.get("text-ignore-placement") || p.get("icon-ignore-placement"), this.sortFeaturesByKey = x !== "viewport-y" && !_.isConstant(), this.sortFeaturesByY = (x === "viewport-y" || x === "auto" && !this.sortFeaturesByKey) && this.canOverlap, p.get("symbol-placement") === "point" && (this.writingModes = p.get("text-writing-mode").map((T) => l.an[T])), this.stateDependentLayerIds = this.layers.filter((T) => T.isStateDependent()).map((T) => T.id), this.sourceID = c.sourceID;
          }
          createArrays() {
            this.text = new R0(new iu(this.layers, this.zoom, (c) => /^text/.test(c))), this.icon = new R0(new iu(this.layers, this.zoom, (c) => /^icon/.test(c))), this.glyphOffsetArray = new De(), this.lineVertexArray = new He(), this.symbolInstances = new Ve(), this.textAnchorOffsets = new Fe();
          }
          calculateGlyphDependencies(c, u, p, _, x) {
            for (let T = 0; T < c.length; T++) if (u[c.charCodeAt(T)] = !0, (p || _) && x) {
              const I = Up[c.charAt(T)];
              I && (u[I.charCodeAt(0)] = !0);
            }
          }
          populate(c, u, p) {
            const _ = this.layers[0], x = _.layout, T = x.get("text-font"), I = x.get("text-field"), B = x.get("icon-image"), N = (I.value.kind !== "constant" || I.value.value instanceof ns && !I.value.value.isEmpty() || I.value.value.toString().length > 0) && (T.value.kind !== "constant" || T.value.value.length > 0), z = B.value.kind !== "constant" || !!B.value.value || Object.keys(B.parameters).length > 0, $ = x.get("symbol-sort-key");
            if (this.features = [], !N && !z) return;
            const J = u.iconDependencies, te = u.glyphDependencies, ne = u.availableImages, ue = new Br(this.zoom, { globalState: this.globalState });
            for (const { feature: Se, id: Ee, index: Je, sourceLayerIndex: ze } of c) {
              const ee = _._featureFilter.needGeometry, ve = uf(Se, ee);
              if (!_._featureFilter.filter(ue, ve, p)) continue;
              let qe, _t;
              if (ee || (ve.geometry = cf(Se)), N) {
                const Rt = _.getValueAndResolveTokens("text-field", ve, p, ne), Ot = ns.factory(Rt), Qt = this.hasRTLText = this.hasRTLText || LR(Ot);
                (!Qt || Cn.getRTLTextPluginStatus() === "unavailable" || Qt && Cn.isParsed()) && (qe = _R(Ot, _, ve));
              }
              if (z) {
                const Rt = _.getValueAndResolveTokens("icon-image", ve, p, ne);
                _t = Rt instanceof Ps ? Rt : Ps.fromString(Rt);
              }
              if (!qe && !_t) continue;
              const $t = this.sortFeaturesByKey ? $.evaluate(ve, {}, p) : void 0;
              if (this.features.push({ id: Ee, text: qe, icon: _t, index: Je, sourceLayerIndex: ze, geometry: ve.geometry, properties: Se.properties, type: RR[Se.type], sortKey: $t }), _t && (J[_t.name] = !0), qe) {
                const Rt = T.evaluate(ve, {}, p).join(","), Ot = x.get("text-rotation-alignment") !== "viewport" && x.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(l.an.vertical) >= 0;
                for (const Qt of qe.sections) if (Qt.image) J[Qt.image.name] = !0;
                else {
                  const Wt = qt(qe.toString()), nr = Qt.fontStack || Rt, Ft = te[nr] = te[nr] || {};
                  this.calculateGlyphDependencies(Qt.text, Ft, Ot, this.allowVerticalPlacement, Wt);
                }
              }
            }
            x.get("symbol-placement") === "line" && (this.features = function(Se) {
              const Ee = {}, Je = {}, ze = [];
              let ee = 0;
              function ve(Rt) {
                ze.push(Se[Rt]), ee++;
              }
              function qe(Rt, Ot, Qt) {
                const Wt = Je[Rt];
                return delete Je[Rt], Je[Ot] = Wt, ze[Wt].geometry[0].pop(), ze[Wt].geometry[0] = ze[Wt].geometry[0].concat(Qt[0]), Wt;
              }
              function _t(Rt, Ot, Qt) {
                const Wt = Ee[Ot];
                return delete Ee[Ot], Ee[Rt] = Wt, ze[Wt].geometry[0].shift(), ze[Wt].geometry[0] = Qt[0].concat(ze[Wt].geometry[0]), Wt;
              }
              function $t(Rt, Ot, Qt) {
                const Wt = Qt ? Ot[0][Ot[0].length - 1] : Ot[0][0];
                return `${Rt}:${Wt.x}:${Wt.y}`;
              }
              for (let Rt = 0; Rt < Se.length; Rt++) {
                const Ot = Se[Rt], Qt = Ot.geometry, Wt = Ot.text ? Ot.text.toString() : null;
                if (!Wt) {
                  ve(Rt);
                  continue;
                }
                const nr = $t(Wt, Qt), Ft = $t(Wt, Qt, !0);
                if (nr in Je && Ft in Ee && Je[nr] !== Ee[Ft]) {
                  const Pr = _t(nr, Ft, Qt), jr = qe(nr, Ft, ze[Pr].geometry);
                  delete Ee[nr], delete Je[Ft], Je[$t(Wt, ze[jr].geometry, !0)] = jr, ze[Pr].geometry = null;
                } else nr in Je ? qe(nr, Ft, Qt) : Ft in Ee ? _t(nr, Ft, Qt) : (ve(Rt), Ee[nr] = ee - 1, Je[Ft] = ee - 1);
              }
              return ze.filter((Rt) => Rt.geometry);
            }(this.features)), this.sortFeaturesByKey && this.features.sort((Se, Ee) => Se.sortKey - Ee.sortKey);
          }
          update(c, u, p) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(c, u, this.layers, p), this.icon.programConfigurations.updatePaintArrays(c, u, this.layers, p));
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(c) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(c), this.iconCollisionBox.upload(c)), this.text.upload(c, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(c, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(c, u) {
            const p = this.lineVertexArray.length;
            if (c.segment !== void 0) {
              let _ = c.dist(u[c.segment + 1]), x = c.dist(u[c.segment]);
              const T = {};
              for (let I = c.segment + 1; I < u.length; I++) T[I] = { x: u[I].x, y: u[I].y, tileUnitDistanceFromAnchor: _ }, I < u.length - 1 && (_ += u[I + 1].dist(u[I]));
              for (let I = c.segment || 0; I >= 0; I--) T[I] = { x: u[I].x, y: u[I].y, tileUnitDistanceFromAnchor: x }, I > 0 && (x += u[I - 1].dist(u[I]));
              for (let I = 0; I < u.length; I++) {
                const B = T[I];
                this.lineVertexArray.emplaceBack(B.x, B.y, B.tileUnitDistanceFromAnchor);
              }
            }
            return { lineStartIndex: p, lineLength: this.lineVertexArray.length - p };
          }
          addSymbols(c, u, p, _, x, T, I, B, N, z, $, J) {
            const te = c.indexArray, ne = c.layoutVertexArray, ue = c.segments.prepareSegment(4 * u.length, ne, te, this.canOverlap ? T.sortKey : void 0), Se = this.glyphOffsetArray.length, Ee = ue.vertexLength, Je = this.allowVerticalPlacement && I === l.an.vertical ? Math.PI / 2 : 0, ze = T.text && T.text.sections;
            for (let ee = 0; ee < u.length; ee++) {
              const { tl: ve, tr: qe, bl: _t, br: $t, tex: Rt, pixelOffsetTL: Ot, pixelOffsetBR: Qt, minFontScaleX: Wt, minFontScaleY: nr, glyphOffset: Ft, isSDF: Pr, sectionIndex: jr } = u[ee], kr = ue.vertexLength, Rr = Ft[1];
              fm(ne, B.x, B.y, ve.x, Rr + ve.y, Rt.x, Rt.y, p, Pr, Ot.x, Ot.y, Wt, nr), fm(ne, B.x, B.y, qe.x, Rr + qe.y, Rt.x + Rt.w, Rt.y, p, Pr, Qt.x, Ot.y, Wt, nr), fm(ne, B.x, B.y, _t.x, Rr + _t.y, Rt.x, Rt.y + Rt.h, p, Pr, Ot.x, Qt.y, Wt, nr), fm(ne, B.x, B.y, $t.x, Rr + $t.y, Rt.x + Rt.w, Rt.y + Rt.h, p, Pr, Qt.x, Qt.y, Wt, nr), P0(c.dynamicLayoutVertexArray, B, Je), te.emplaceBack(kr, kr + 2, kr + 1), te.emplaceBack(kr + 1, kr + 2, kr + 3), ue.vertexLength += 4, ue.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(Ft[0]), ee !== u.length - 1 && jr === u[ee + 1].sectionIndex || c.programConfigurations.populatePaintArrays(ne.length, T, T.index, {}, J, ze && ze[jr]);
            }
            c.placedSymbolArray.emplaceBack(B.x, B.y, Se, this.glyphOffsetArray.length - Se, Ee, N, z, B.segment, p ? p[0] : 0, p ? p[1] : 0, _[0], _[1], I, 0, !1, 0, $);
          }
          _addCollisionDebugVertex(c, u, p, _, x, T) {
            return u.emplaceBack(0, 0), c.emplaceBack(p.x, p.y, _, x, Math.round(T.x), Math.round(T.y));
          }
          addCollisionDebugVertices(c, u, p, _, x, T, I) {
            const B = x.segments.prepareSegment(4, x.layoutVertexArray, x.indexArray), N = B.vertexLength, z = x.layoutVertexArray, $ = x.collisionVertexArray, J = I.anchorX, te = I.anchorY;
            this._addCollisionDebugVertex(z, $, T, J, te, new k(c, u)), this._addCollisionDebugVertex(z, $, T, J, te, new k(p, u)), this._addCollisionDebugVertex(z, $, T, J, te, new k(p, _)), this._addCollisionDebugVertex(z, $, T, J, te, new k(c, _)), B.vertexLength += 4;
            const ne = x.indexArray;
            ne.emplaceBack(N, N + 1), ne.emplaceBack(N + 1, N + 2), ne.emplaceBack(N + 2, N + 3), ne.emplaceBack(N + 3, N), B.primitiveLength += 4;
          }
          addDebugCollisionBoxes(c, u, p, _) {
            for (let x = c; x < u; x++) {
              const T = this.collisionBoxArray.get(x);
              this.addCollisionDebugVertices(T.x1, T.y1, T.x2, T.y2, _ ? this.textCollisionBox : this.iconCollisionBox, T.anchorPoint, p);
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new B0(On, gw.members, En), this.iconCollisionBox = new B0(On, gw.members, En);
            for (let c = 0; c < this.symbolInstances.length; c++) {
              const u = this.symbolInstances.get(c);
              this.addDebugCollisionBoxes(u.textBoxStartIndex, u.textBoxEndIndex, u, !0), this.addDebugCollisionBoxes(u.verticalTextBoxStartIndex, u.verticalTextBoxEndIndex, u, !0), this.addDebugCollisionBoxes(u.iconBoxStartIndex, u.iconBoxEndIndex, u, !1), this.addDebugCollisionBoxes(u.verticalIconBoxStartIndex, u.verticalIconBoxEndIndex, u, !1);
            }
          }
          _deserializeCollisionBoxesForSymbol(c, u, p, _, x, T, I, B, N) {
            const z = {};
            for (let $ = u; $ < p; $++) {
              const J = c.get($);
              z.textBox = { x1: J.x1, y1: J.y1, x2: J.x2, y2: J.y2, anchorPointX: J.anchorPointX, anchorPointY: J.anchorPointY }, z.textFeatureIndex = J.featureIndex;
              break;
            }
            for (let $ = _; $ < x; $++) {
              const J = c.get($);
              z.verticalTextBox = { x1: J.x1, y1: J.y1, x2: J.x2, y2: J.y2, anchorPointX: J.anchorPointX, anchorPointY: J.anchorPointY }, z.verticalTextFeatureIndex = J.featureIndex;
              break;
            }
            for (let $ = T; $ < I; $++) {
              const J = c.get($);
              z.iconBox = { x1: J.x1, y1: J.y1, x2: J.x2, y2: J.y2, anchorPointX: J.anchorPointX, anchorPointY: J.anchorPointY }, z.iconFeatureIndex = J.featureIndex;
              break;
            }
            for (let $ = B; $ < N; $++) {
              const J = c.get($);
              z.verticalIconBox = { x1: J.x1, y1: J.y1, x2: J.x2, y2: J.y2, anchorPointX: J.anchorPointX, anchorPointY: J.anchorPointY }, z.verticalIconFeatureIndex = J.featureIndex;
              break;
            }
            return z;
          }
          deserializeCollisionBoxes(c) {
            this.collisionArrays = [];
            for (let u = 0; u < this.symbolInstances.length; u++) {
              const p = this.symbolInstances.get(u);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(c, p.textBoxStartIndex, p.textBoxEndIndex, p.verticalTextBoxStartIndex, p.verticalTextBoxEndIndex, p.iconBoxStartIndex, p.iconBoxEndIndex, p.verticalIconBoxStartIndex, p.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(c, u) {
            const p = c.placedSymbolArray.get(u), _ = p.vertexStartIndex + 4 * p.numGlyphs;
            for (let x = p.vertexStartIndex; x < _; x += 4) c.indexArray.emplaceBack(x, x + 2, x + 1), c.indexArray.emplaceBack(x + 1, x + 2, x + 3);
          }
          getSortedSymbolIndexes(c) {
            if (this.sortedAngle === c && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const u = Math.sin(c), p = Math.cos(c), _ = [], x = [], T = [];
            for (let I = 0; I < this.symbolInstances.length; ++I) {
              T.push(I);
              const B = this.symbolInstances.get(I);
              _.push(0 | Math.round(u * B.anchorX + p * B.anchorY)), x.push(B.featureIndex);
            }
            return T.sort((I, B) => _[I] - _[B] || x[B] - x[I]), T;
          }
          addToSortKeyRanges(c, u) {
            const p = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            p && p.sortKey === u ? p.symbolInstanceEnd = c + 1 : this.sortKeyRanges.push({ sortKey: u, symbolInstanceStart: c, symbolInstanceEnd: c + 1 });
          }
          sortFeatures(c) {
            if (this.sortFeaturesByY && this.sortedAngle !== c && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(c), this.sortedAngle = c, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const u of this.symbolInstanceIndexes) {
                const p = this.symbolInstances.get(u);
                this.featureSortOrder.push(p.featureIndex), [p.rightJustifiedTextSymbolIndex, p.centerJustifiedTextSymbolIndex, p.leftJustifiedTextSymbolIndex].forEach((_, x, T) => {
                  _ >= 0 && T.indexOf(_) === x && this.addIndicesForPlacedSymbol(this.text, _);
                }), p.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, p.verticalPlacedTextSymbolIndex), p.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, p.placedIconSymbolIndex), p.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, p.verticalPlacedIconSymbolIndex);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        let Mw, Pw;
        Re("SymbolBucket", hd, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), hd.MAX_GLYPHS = 65535, hd.addDynamicAttributes = P0;
        var L0 = { get paint() {
          return Pw = Pw || new Ei({ "icon-opacity": new Ir(Ge.paint_symbol["icon-opacity"]), "icon-color": new Ir(Ge.paint_symbol["icon-color"]), "icon-halo-color": new Ir(Ge.paint_symbol["icon-halo-color"]), "icon-halo-width": new Ir(Ge.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Ir(Ge.paint_symbol["icon-halo-blur"]), "icon-translate": new fr(Ge.paint_symbol["icon-translate"]), "icon-translate-anchor": new fr(Ge.paint_symbol["icon-translate-anchor"]), "text-opacity": new Ir(Ge.paint_symbol["text-opacity"]), "text-color": new Ir(Ge.paint_symbol["text-color"], { runtimeType: Hi, getOverride: (f) => f.textColor, hasOverride: (f) => !!f.textColor }), "text-halo-color": new Ir(Ge.paint_symbol["text-halo-color"]), "text-halo-width": new Ir(Ge.paint_symbol["text-halo-width"]), "text-halo-blur": new Ir(Ge.paint_symbol["text-halo-blur"]), "text-translate": new fr(Ge.paint_symbol["text-translate"]), "text-translate-anchor": new fr(Ge.paint_symbol["text-translate-anchor"]) });
        }, get layout() {
          return Mw = Mw || new Ei({ "symbol-placement": new fr(Ge.layout_symbol["symbol-placement"]), "symbol-spacing": new fr(Ge.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new fr(Ge.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Ir(Ge.layout_symbol["symbol-sort-key"]), "symbol-z-order": new fr(Ge.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new fr(Ge.layout_symbol["icon-allow-overlap"]), "icon-overlap": new fr(Ge.layout_symbol["icon-overlap"]), "icon-ignore-placement": new fr(Ge.layout_symbol["icon-ignore-placement"]), "icon-optional": new fr(Ge.layout_symbol["icon-optional"]), "icon-rotation-alignment": new fr(Ge.layout_symbol["icon-rotation-alignment"]), "icon-size": new Ir(Ge.layout_symbol["icon-size"]), "icon-text-fit": new fr(Ge.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new fr(Ge.layout_symbol["icon-text-fit-padding"]), "icon-image": new Ir(Ge.layout_symbol["icon-image"]), "icon-rotate": new Ir(Ge.layout_symbol["icon-rotate"]), "icon-padding": new Ir(Ge.layout_symbol["icon-padding"]), "icon-keep-upright": new fr(Ge.layout_symbol["icon-keep-upright"]), "icon-offset": new Ir(Ge.layout_symbol["icon-offset"]), "icon-anchor": new Ir(Ge.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new fr(Ge.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new fr(Ge.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new fr(Ge.layout_symbol["text-rotation-alignment"]), "text-field": new Ir(Ge.layout_symbol["text-field"]), "text-font": new Ir(Ge.layout_symbol["text-font"]), "text-size": new Ir(Ge.layout_symbol["text-size"]), "text-max-width": new Ir(Ge.layout_symbol["text-max-width"]), "text-line-height": new fr(Ge.layout_symbol["text-line-height"]), "text-letter-spacing": new Ir(Ge.layout_symbol["text-letter-spacing"]), "text-justify": new Ir(Ge.layout_symbol["text-justify"]), "text-radial-offset": new Ir(Ge.layout_symbol["text-radial-offset"]), "text-variable-anchor": new fr(Ge.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new Ir(Ge.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new Ir(Ge.layout_symbol["text-anchor"]), "text-max-angle": new fr(Ge.layout_symbol["text-max-angle"]), "text-writing-mode": new fr(Ge.layout_symbol["text-writing-mode"]), "text-rotate": new Ir(Ge.layout_symbol["text-rotate"]), "text-padding": new fr(Ge.layout_symbol["text-padding"]), "text-keep-upright": new fr(Ge.layout_symbol["text-keep-upright"]), "text-transform": new Ir(Ge.layout_symbol["text-transform"]), "text-offset": new Ir(Ge.layout_symbol["text-offset"]), "text-allow-overlap": new fr(Ge.layout_symbol["text-allow-overlap"]), "text-overlap": new fr(Ge.layout_symbol["text-overlap"]), "text-ignore-placement": new fr(Ge.layout_symbol["text-ignore-placement"]), "text-optional": new fr(Ge.layout_symbol["text-optional"]) });
        } };
        class Rw {
          constructor(c) {
            if (c.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = c.property.overrides ? c.property.overrides.runtimeType : _s, this.defaultValue = c;
          }
          evaluate(c) {
            if (c.formattedSection) {
              const u = this.defaultValue.property.overrides;
              if (u && u.hasOverride(c.formattedSection)) return u.getOverride(c.formattedSection);
            }
            return c.feature && c.featureState ? this.defaultValue.evaluate(c.feature, c.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(c) {
            this.defaultValue.isConstant() || c(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            return null;
          }
        }
        Re("FormatSectionOverride", Rw, { omit: ["defaultValue"] });
        class dm extends ki {
          constructor(c) {
            super(c, L0);
          }
          recalculate(c, u) {
            if (super.recalculate(c, u), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              const p = this.layout.get("text-writing-mode");
              if (p) {
                const _ = [];
                for (const x of p) _.indexOf(x) < 0 && _.push(x);
                this.layout._values["text-writing-mode"] = _;
              } else this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(c, u, p, _) {
            const x = this.layout.get(c).evaluate(u, {}, p, _), T = this._unevaluatedLayout._values[c];
            return T.isDataDriven() || hh(T.value) || !x ? x : function(I, B) {
              return B.replace(/{([^{}]+)}/g, (N, z) => I && z in I ? String(I[z]) : "");
            }(u.properties, x);
          }
          createBucket(c) {
            return new hd(c);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex");
          }
          _setPaintOverrides() {
            for (const c of L0.paint.overridableProperties) {
              if (!dm.hasPaintOverride(this.layout, c)) continue;
              const u = this.paint.get(c), p = new Rw(u), _ = new Hc(p, u.property.specification);
              let x = null;
              x = u.value.kind === "constant" || u.value.kind === "source" ? new Wc("source", _) : new dh("composite", _, u.value.zoomStops), this.paint._values[c] = new Li(u.property, x, u.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(c, u, p) {
            return !(!this.layout || u.isDataDriven() || p.isDataDriven()) && dm.hasPaintOverride(this.layout, c);
          }
          static hasPaintOverride(c, u) {
            const p = c.get("text-field"), _ = L0.paint.properties[u];
            let x = !1;
            const T = (I) => {
              for (const B of I) if (_.overrides && _.overrides.hasOverride(B)) return void (x = !0);
            };
            if (p.value.kind === "constant" && p.value.value instanceof ns) T(p.value.value.sections);
            else if (p.value.kind === "source") {
              const I = (N) => {
                x || (N instanceof Di && Or(N.value) === va ? T(N.value.sections) : N instanceof Fr ? T(N.sections) : N.eachChild(I));
              }, B = p.value;
              B._styleExpression && I(B._styleExpression.expression);
            }
            return x;
          }
        }
        let Bw;
        var OR = { get paint() {
          return Bw = Bw || new Ei({ "background-color": new fr(Ge.paint_background["background-color"]), "background-pattern": new zo(Ge.paint_background["background-pattern"]), "background-opacity": new fr(Ge.paint_background["background-opacity"]) });
        } };
        class kR extends ki {
          constructor(c) {
            super(c, OR);
          }
        }
        let Lw;
        var NR = { get paint() {
          return Lw = Lw || new Ei({ "raster-opacity": new fr(Ge.paint_raster["raster-opacity"]), "raster-hue-rotate": new fr(Ge.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new fr(Ge.paint_raster["raster-brightness-min"]), "raster-brightness-max": new fr(Ge.paint_raster["raster-brightness-max"]), "raster-saturation": new fr(Ge.paint_raster["raster-saturation"]), "raster-contrast": new fr(Ge.paint_raster["raster-contrast"]), "raster-resampling": new fr(Ge.paint_raster["raster-resampling"]), "raster-fade-duration": new fr(Ge.paint_raster["raster-fade-duration"]) });
        } };
        class DR extends ki {
          constructor(c) {
            super(c, NR);
          }
        }
        class FR extends ki {
          constructor(c) {
            super(c, {}), this.onAdd = (u) => {
              this.implementation.onAdd && this.implementation.onAdd(u, u.painter.context.gl);
            }, this.onRemove = (u) => {
              this.implementation.onRemove && this.implementation.onRemove(u, u.painter.context.gl);
            }, this.implementation = c;
          }
          is3D() {
            return this.implementation.renderingMode === "3d";
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0;
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return !1;
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized");
          }
        }
        class UR {
          constructor(c) {
            this._methodToThrottle = c, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = !1, this._methodToThrottle();
            });
          }
          trigger() {
            this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
              this._triggered = !1, this._methodToThrottle();
            }, 0));
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {
            };
          }
        }
        const zR = { once: !0 }, O0 = 63710088e-1;
        class Th {
          constructor(c, u) {
            if (isNaN(c) || isNaN(u)) throw new Error(`Invalid LngLat object: (${c}, ${u})`);
            if (this.lng = +c, this.lat = +u, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new Th(ar(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(c) {
            const u = Math.PI / 180, p = this.lat * u, _ = c.lat * u, x = Math.sin(p) * Math.sin(_) + Math.cos(p) * Math.cos(_) * Math.cos((c.lng - this.lng) * u);
            return O0 * Math.acos(Math.min(x, 1));
          }
          static convert(c) {
            if (c instanceof Th) return c;
            if (Array.isArray(c) && (c.length === 2 || c.length === 3)) return new Th(Number(c[0]), Number(c[1]));
            if (!Array.isArray(c) && typeof c == "object" && c !== null) return new Th(Number("lng" in c ? c.lng : c.lon), Number(c.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        const Ow = 2 * Math.PI * O0;
        function kw(f) {
          return Ow * Math.cos(f * Math.PI / 180);
        }
        function Nw(f) {
          return (180 + f) / 360;
        }
        function Dw(f) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + f * Math.PI / 360))) / 360;
        }
        function Fw(f, c) {
          return f / kw(c);
        }
        function k0(f) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * f) * Math.PI / 180)) - 90;
        }
        function Uw(f, c) {
          return f * kw(k0(c));
        }
        class jp {
          constructor(c, u) {
            let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            this.x = +c, this.y = +u, this.z = +p;
          }
          static fromLngLat(c) {
            let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            const p = Th.convert(c);
            return new jp(Nw(p.lng), Dw(p.lat), Fw(u, p.lat));
          }
          toLngLat() {
            return new Th(360 * this.x - 180, k0(this.y));
          }
          toAltitude() {
            return Uw(this.z, this.y);
          }
          meterInMercatorCoordinateUnits() {
            return 1 / Ow * (c = k0(this.y), 1 / Math.cos(c * Math.PI / 180));
            var c;
          }
        }
        function zw(f, c, u) {
          var p = 2 * Math.PI * 6378137 / 256 / Math.pow(2, u);
          return [f * p - 2 * Math.PI * 6378137 / 2, c * p - 2 * Math.PI * 6378137 / 2];
        }
        class N0 {
          constructor(c, u, p) {
            if (!function(_, x, T) {
              return !(_ < 0 || _ > 25 || T < 0 || T >= Math.pow(2, _) || x < 0 || x >= Math.pow(2, _));
            }(c, u, p)) throw new Error(`x=${u}, y=${p}, z=${c} outside of bounds. 0<=x<${Math.pow(2, c)}, 0<=y<${Math.pow(2, c)} 0<=z<=25 `);
            this.z = c, this.x = u, this.y = p, this.key = fd(0, c, c, u, p);
          }
          equals(c) {
            return this.z === c.z && this.x === c.x && this.y === c.y;
          }
          url(c, u, p) {
            const _ = (T = this.y, I = this.z, B = zw(256 * (x = this.x), 256 * (T = Math.pow(2, I) - T - 1), I), N = zw(256 * (x + 1), 256 * (T + 1), I), B[0] + "," + B[1] + "," + N[0] + "," + N[1]);
            var x, T, I, B, N;
            const z = function($, J, te) {
              let ne, ue = "";
              for (let Se = $; Se > 0; Se--) ne = 1 << Se - 1, ue += (J & ne ? 1 : 0) + (te & ne ? 2 : 0);
              return ue;
            }(this.z, this.x, this.y);
            return c[(this.x + this.y) % c.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(p === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, u > 1 ? "@2x" : "").replace(/{quadkey}/g, z).replace(/{bbox-epsg-3857}/g, _);
          }
          isChildOf(c) {
            const u = this.z - c.z;
            return u > 0 && c.x === this.x >> u && c.y === this.y >> u;
          }
          getTilePoint(c) {
            const u = Math.pow(2, this.z);
            return new k((c.x * u - this.x) * ce, (c.y * u - this.y) * ce);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class jw {
          constructor(c, u) {
            this.wrap = c, this.canonical = u, this.key = fd(c, u.z, u.z, u.x, u.y);
          }
        }
        class al {
          constructor(c, u, p, _, x) {
            if (this.terrainRttPosMatrix32f = null, c < p) throw new Error(`overscaledZ should be >= z; overscaledZ = ${c}; z = ${p}`);
            this.overscaledZ = c, this.wrap = u, this.canonical = new N0(p, +_, +x), this.key = fd(u, c, p, _, x);
          }
          clone() {
            return new al(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          equals(c) {
            return this.overscaledZ === c.overscaledZ && this.wrap === c.wrap && this.canonical.equals(c.canonical);
          }
          scaledTo(c) {
            if (c > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${c}; overscaledZ = ${this.overscaledZ}`);
            const u = this.canonical.z - c;
            return c > this.canonical.z ? new al(c, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new al(c, this.wrap, c, this.canonical.x >> u, this.canonical.y >> u);
          }
          calculateScaledKey(c, u) {
            if (c > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${c}; overscaledZ = ${this.overscaledZ}`);
            const p = this.canonical.z - c;
            return c > this.canonical.z ? fd(this.wrap * +u, c, this.canonical.z, this.canonical.x, this.canonical.y) : fd(this.wrap * +u, c, c, this.canonical.x >> p, this.canonical.y >> p);
          }
          isChildOf(c) {
            if (c.wrap !== this.wrap) return !1;
            const u = this.canonical.z - c.canonical.z;
            return c.overscaledZ === 0 || c.overscaledZ < this.overscaledZ && c.canonical.x === this.canonical.x >> u && c.canonical.y === this.canonical.y >> u;
          }
          children(c) {
            if (this.overscaledZ >= c) return [new al(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const u = this.canonical.z + 1, p = 2 * this.canonical.x, _ = 2 * this.canonical.y;
            return [new al(u, this.wrap, u, p, _), new al(u, this.wrap, u, p + 1, _), new al(u, this.wrap, u, p, _ + 1), new al(u, this.wrap, u, p + 1, _ + 1)];
          }
          isLessThan(c) {
            return this.wrap < c.wrap || !(this.wrap > c.wrap) && (this.overscaledZ < c.overscaledZ || !(this.overscaledZ > c.overscaledZ) && (this.canonical.x < c.canonical.x || !(this.canonical.x > c.canonical.x) && this.canonical.y < c.canonical.y));
          }
          wrapped() {
            return new al(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(c) {
            return new al(this.overscaledZ, c, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new jw(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
          getTilePoint(c) {
            return this.canonical.getTilePoint(new jp(c.x - this.wrap, c.y));
          }
        }
        function fd(f, c, u, p, _) {
          (f *= 2) < 0 && (f = -1 * f - 1);
          const x = 1 << u;
          return (x * x * f + x * _ + p).toString(36) + u.toString(36) + c.toString(36);
        }
        Re("CanonicalTileID", N0), Re("OverscaledTileID", al, { omit: ["terrainRttPosMatrix32f"] });
        class df {
          constructor() {
            this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0;
          }
          extend(c) {
            return this.minX = Math.min(this.minX, c.x), this.minY = Math.min(this.minY, c.y), this.maxX = Math.max(this.maxX, c.x), this.maxY = Math.max(this.maxY, c.y), this;
          }
          expandBy(c) {
            return this.minX -= c, this.minY -= c, this.maxX += c, this.maxY += c, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this;
          }
          shrinkBy(c) {
            return this.expandBy(-c);
          }
          map(c) {
            const u = new df();
            return u.extend(c(new k(this.minX, this.minY))), u.extend(c(new k(this.maxX, this.minY))), u.extend(c(new k(this.minX, this.maxY))), u.extend(c(new k(this.maxX, this.maxY))), u;
          }
          static fromPoints(c) {
            const u = new df();
            for (const p of c) u.extend(p);
            return u;
          }
          contains(c) {
            return c.x >= this.minX && c.x <= this.maxX && c.y >= this.minY && c.y <= this.maxY;
          }
          empty() {
            return this.minX > this.maxX;
          }
          width() {
            return this.maxX - this.minX;
          }
          height() {
            return this.maxY - this.minY;
          }
          covers(c) {
            return !this.empty() && !c.empty() && c.minX >= this.minX && c.maxX <= this.maxX && c.minY >= this.minY && c.maxY <= this.maxY;
          }
          intersects(c) {
            return !this.empty() && !c.empty() && c.minX <= this.maxX && c.maxX >= this.minX && c.minY <= this.maxY && c.maxY >= this.minY;
          }
        }
        class Vw {
          constructor(c) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let u = 0; u < c.length; u++) {
              const p = c[u];
              this._stringToNumber[p] = u, this._numberToString[u] = p;
            }
          }
          encode(c) {
            return this._stringToNumber[c];
          }
          decode(c) {
            if (c >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${c} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[c];
          }
        }
        class $w {
          constructor(c, u, p, _, x) {
            this.type = "Feature", this._vectorTileFeature = c, c._z = u, c._x = p, c._y = _, this.properties = c.properties, this.id = x;
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
          }
          set geometry(c) {
            this._geometry = c;
          }
          toJSON() {
            const c = { geometry: this.geometry };
            for (const u in this) u !== "_geometry" && u !== "_vectorTileFeature" && (c[u] = this[u]);
            return c;
          }
        }
        class qw {
          constructor(c, u) {
            this.tileID = c, this.x = c.canonical.x, this.y = c.canonical.y, this.z = c.canonical.z, this.grid = new xe(ce, 16, 0), this.grid3D = new xe(ce, 16, 0), this.featureIndexArray = new bt(), this.promoteId = u;
          }
          insert(c, u, p, _, x, T) {
            const I = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(p, _, x);
            const B = T ? this.grid3D : this.grid;
            for (let N = 0; N < u.length; N++) {
              const z = u[N], $ = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let J = 0; J < z.length; J++) {
                const te = z[J];
                $[0] = Math.min($[0], te.x), $[1] = Math.min($[1], te.y), $[2] = Math.max($[2], te.x), $[3] = Math.max($[3], te.y);
              }
              $[0] < ce && $[1] < ce && $[2] >= 0 && $[3] >= 0 && B.insert(I, $[0], $[1], $[2], $[3]);
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new Np.VectorTile(new S0(this.rawTileData)).layers, this.sourceLayerCoder = new Vw(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
          }
          query(c, u, p, _) {
            this.loadVTLayers();
            const x = c.params, T = ce / c.tileSize / c.scale, I = Do(x.filter), B = c.queryGeometry, N = c.queryPadding * T, z = df.fromPoints(B), $ = this.grid.query(z.minX - N, z.minY - N, z.maxX + N, z.maxY + N), J = df.fromPoints(c.cameraQueryGeometry).expandBy(N), te = this.grid3D.query(J.minX, J.minY, J.maxX, J.maxY, (Se, Ee, Je, ze) => function(ee, ve, qe, _t, $t) {
              for (const Ot of ee) if (ve <= Ot.x && qe <= Ot.y && _t >= Ot.x && $t >= Ot.y) return !0;
              const Rt = [new k(ve, qe), new k(ve, $t), new k(_t, $t), new k(_t, qe)];
              if (ee.length > 2) {
                for (const Ot of Rt) if (od(ee, Ot)) return !0;
              }
              for (let Ot = 0; Ot < ee.length - 1; Ot++) if (CP(ee[Ot], ee[Ot + 1], Rt)) return !0;
              return !1;
            }(c.cameraQueryGeometry, Se - N, Ee - N, Je + N, ze + N));
            for (const Se of te) $.push(Se);
            $.sort(jR);
            const ne = {};
            let ue;
            for (let Se = 0; Se < $.length; Se++) {
              const Ee = $[Se];
              if (Ee === ue) continue;
              ue = Ee;
              const Je = this.featureIndexArray.get(Ee);
              let ze = null;
              this.loadMatchingFeature(ne, Je.bucketIndex, Je.sourceLayerIndex, Je.featureIndex, I, x.layers, x.availableImages, u, p, _, (ee, ve, qe) => (ze || (ze = cf(ee)), ve.queryIntersectsFeature({ queryGeometry: B, feature: ee, featureState: qe, geometry: ze, zoom: this.z, transform: c.transform, pixelsToTileUnits: T, pixelPosMatrix: c.pixelPosMatrix, unwrappedTileID: this.tileID.toUnwrapped(), getElevation: c.getElevation })));
            }
            return ne;
          }
          loadMatchingFeature(c, u, p, _, x, T, I, B, N, z, $) {
            const J = this.bucketLayerIDs[u];
            if (T && !J.some((Se) => T.has(Se))) return;
            const te = this.sourceLayerCoder.decode(p), ne = this.vtLayers[te].feature(_);
            if (x.needGeometry) {
              const Se = uf(ne, !0);
              if (!x.filter(new Br(this.tileID.overscaledZ), Se, this.tileID.canonical)) return;
            } else if (!x.filter(new Br(this.tileID.overscaledZ), ne)) return;
            const ue = this.getId(ne, te);
            for (let Se = 0; Se < J.length; Se++) {
              const Ee = J[Se];
              if (T && !T.has(Ee)) continue;
              const Je = B[Ee];
              if (!Je) continue;
              let ze = {};
              ue && z && (ze = z.getState(Je.sourceLayer || "_geojsonTileLayer", ue));
              const ee = Kt({}, N[Ee]);
              ee.paint = Gw(ee.paint, Je.paint, ne, ze, I), ee.layout = Gw(ee.layout, Je.layout, ne, ze, I);
              const ve = !$ || $(ne, Je, ze);
              if (!ve) continue;
              const qe = new $w(ne, this.z, this.x, this.y, ue);
              qe.layer = ee;
              let _t = c[Ee];
              _t === void 0 && (_t = c[Ee] = []), _t.push({ featureIndex: _, feature: qe, intersectionZ: ve });
            }
          }
          lookupSymbolFeatures(c, u, p, _, x, T, I, B) {
            const N = {};
            this.loadVTLayers();
            const z = Do(x);
            for (const $ of c) this.loadMatchingFeature(N, p, _, $, z, T, I, B, u);
            return N;
          }
          hasLayer(c) {
            for (const u of this.bucketLayerIDs) for (const p of u) if (c === p) return !0;
            return !1;
          }
          getId(c, u) {
            var p;
            let _ = c.id;
            return this.promoteId && (_ = c.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[u]], typeof _ == "boolean" && (_ = Number(_)), _ === void 0 && (!((p = c.properties) === null || p === void 0) && p.cluster) && this.promoteId && (_ = Number(c.properties.cluster_id))), _;
          }
        }
        function Gw(f, c, u, p, _) {
          return sr(f, (x, T) => {
            const I = c instanceof Fi ? c.get(T) : null;
            return I && I.evaluate ? I.evaluate(u, p, _) : I;
          });
        }
        function jR(f, c) {
          return c - f;
        }
        function Hw(f, c, u, p, _) {
          const x = [];
          for (let T = 0; T < f.length; T++) {
            const I = f[T];
            let B;
            for (let N = 0; N < I.length - 1; N++) {
              let z = I[N], $ = I[N + 1];
              z.x < c && $.x < c || (z.x < c ? z = new k(c, z.y + (c - z.x) / ($.x - z.x) * ($.y - z.y))._round() : $.x < c && ($ = new k(c, z.y + (c - z.x) / ($.x - z.x) * ($.y - z.y))._round()), z.y < u && $.y < u || (z.y < u ? z = new k(z.x + (u - z.y) / ($.y - z.y) * ($.x - z.x), u)._round() : $.y < u && ($ = new k(z.x + (u - z.y) / ($.y - z.y) * ($.x - z.x), u)._round()), z.x >= p && $.x >= p || (z.x >= p ? z = new k(p, z.y + (p - z.x) / ($.x - z.x) * ($.y - z.y))._round() : $.x >= p && ($ = new k(p, z.y + (p - z.x) / ($.x - z.x) * ($.y - z.y))._round()), z.y >= _ && $.y >= _ || (z.y >= _ ? z = new k(z.x + (_ - z.y) / ($.y - z.y) * ($.x - z.x), _)._round() : $.y >= _ && ($ = new k(z.x + (_ - z.y) / ($.y - z.y) * ($.x - z.x), _)._round()), B && z.equals(B[B.length - 1]) || (B = [z], x.push(B)), B.push($)))));
            }
          }
          return x;
        }
        Re("FeatureIndex", qw, { omit: ["rawTileData", "sourceLayerCoder"] });
        class Sh extends k {
          constructor(c, u, p, _) {
            super(c, u), this.angle = p, _ !== void 0 && (this.segment = _);
          }
          clone() {
            return new Sh(this.x, this.y, this.angle, this.segment);
          }
        }
        function Ww(f, c, u, p, _) {
          if (c.segment === void 0 || u === 0) return !0;
          let x = c, T = c.segment + 1, I = 0;
          for (; I > -u / 2; ) {
            if (T--, T < 0) return !1;
            I -= f[T].dist(x), x = f[T];
          }
          I += f[T].dist(f[T + 1]), T++;
          const B = [];
          let N = 0;
          for (; I < u / 2; ) {
            const z = f[T], $ = f[T + 1];
            if (!$) return !1;
            let J = f[T - 1].angleTo(z) - z.angleTo($);
            for (J = Math.abs((J + 3 * Math.PI) % (2 * Math.PI) - Math.PI), B.push({ distance: I, angleDelta: J }), N += J; I - B[0].distance > p; ) N -= B.shift().angleDelta;
            if (N > _) return !1;
            T++, I += z.dist($);
          }
          return !0;
        }
        function Xw(f) {
          let c = 0;
          for (let u = 0; u < f.length - 1; u++) c += f[u].dist(f[u + 1]);
          return c;
        }
        function Zw(f, c, u) {
          return f ? 0.6 * c * u : 0;
        }
        function Yw(f, c) {
          return Math.max(f ? f.right - f.left : 0, c ? c.right - c.left : 0);
        }
        function VR(f, c, u, p, _, x) {
          const T = Zw(u, _, x), I = Yw(u, p) * x;
          let B = 0;
          const N = Xw(f) / 2;
          for (let z = 0; z < f.length - 1; z++) {
            const $ = f[z], J = f[z + 1], te = $.dist(J);
            if (B + te > N) {
              const ne = (N - B) / te, ue = ss.number($.x, J.x, ne), Se = ss.number($.y, J.y, ne), Ee = new Sh(ue, Se, J.angleTo($), z);
              return Ee._round(), !T || Ww(f, Ee, I, T, c) ? Ee : void 0;
            }
            B += te;
          }
        }
        function $R(f, c, u, p, _, x, T, I, B) {
          const N = Zw(p, x, T), z = Yw(p, _), $ = z * T, J = f[0].x === 0 || f[0].x === B || f[0].y === 0 || f[0].y === B;
          return c - $ < c / 4 && (c = $ + c / 4), Kw(f, J ? c / 2 * I % c : (z / 2 + 2 * x) * T * I % c, c, N, u, $, J, !1, B);
        }
        function Kw(f, c, u, p, _, x, T, I, B) {
          const N = x / 2, z = Xw(f);
          let $ = 0, J = c - u, te = [];
          for (let ne = 0; ne < f.length - 1; ne++) {
            const ue = f[ne], Se = f[ne + 1], Ee = ue.dist(Se), Je = Se.angleTo(ue);
            for (; J + u < $ + Ee; ) {
              J += u;
              const ze = (J - $) / Ee, ee = ss.number(ue.x, Se.x, ze), ve = ss.number(ue.y, Se.y, ze);
              if (ee >= 0 && ee < B && ve >= 0 && ve < B && J - N >= 0 && J + N <= z) {
                const qe = new Sh(ee, ve, Je, ne);
                qe._round(), p && !Ww(f, qe, x, p, _) || te.push(qe);
              }
            }
            $ += Ee;
          }
          return I || te.length || T || (te = Kw(f, $ / 2, u, p, _, x, T, !0, B)), te;
        }
        function Jw(f, c, u, p) {
          const _ = [], x = f.image, T = x.pixelRatio, I = x.paddedRect.w - 2, B = x.paddedRect.h - 2;
          let N = { x1: f.left, y1: f.top, x2: f.right, y2: f.bottom };
          const z = x.stretchX || [[0, I]], $ = x.stretchY || [[0, B]], J = (Ft, Pr) => Ft + Pr[1] - Pr[0], te = z.reduce(J, 0), ne = $.reduce(J, 0), ue = I - te, Se = B - ne;
          let Ee = 0, Je = te, ze = 0, ee = ne, ve = 0, qe = ue, _t = 0, $t = Se;
          if (x.content && p) {
            const Ft = x.content, Pr = Ft[2] - Ft[0], jr = Ft[3] - Ft[1];
            (x.textFitWidth || x.textFitHeight) && (N = Ew(f)), Ee = pm(z, 0, Ft[0]), ze = pm($, 0, Ft[1]), Je = pm(z, Ft[0], Ft[2]), ee = pm($, Ft[1], Ft[3]), ve = Ft[0] - Ee, _t = Ft[1] - ze, qe = Pr - Je, $t = jr - ee;
          }
          const Rt = N.x1, Ot = N.y1, Qt = N.x2 - Rt, Wt = N.y2 - Ot, nr = (Ft, Pr, jr, kr) => {
            const Rr = gm(Ft.stretch - Ee, Je, Qt, Rt), Tn = mm(Ft.fixed - ve, qe, Ft.stretch, te), Ui = gm(Pr.stretch - ze, ee, Wt, Ot), ls = mm(Pr.fixed - _t, $t, Pr.stretch, ne), qo = gm(jr.stretch - Ee, Je, Qt, Rt), ma = mm(jr.fixed - ve, qe, jr.stretch, te), _a = gm(kr.stretch - ze, ee, Wt, Ot), Js = mm(kr.fixed - _t, $t, kr.stretch, ne), qi = new k(Rr, Ui), Ts = new k(qo, Ui), Qs = new k(qo, _a), cs = new k(Rr, _a), Go = new k(Tn / T, ls / T), ll = new k(ma / T, Js / T), Os = c * Math.PI / 180;
            if (Os) {
              const ks = Math.sin(Os), Ns = Math.cos(Os), us = [Ns, -ks, ks, Ns];
              qi._matMult(us), Ts._matMult(us), cs._matMult(us), Qs._matMult(us);
            }
            const ya = Ft.stretch + Ft.fixed, Ss = Pr.stretch + Pr.fixed;
            return { tl: qi, tr: Ts, bl: cs, br: Qs, tex: { x: x.paddedRect.x + 1 + ya, y: x.paddedRect.y + 1 + Ss, w: jr.stretch + jr.fixed - ya, h: kr.stretch + kr.fixed - Ss }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: Go, pixelOffsetBR: ll, minFontScaleX: qe / T / Qt, minFontScaleY: $t / T / Wt, isSDF: u };
          };
          if (p && (x.stretchX || x.stretchY)) {
            const Ft = Qw(z, ue, te), Pr = Qw($, Se, ne);
            for (let jr = 0; jr < Ft.length - 1; jr++) {
              const kr = Ft[jr], Rr = Ft[jr + 1];
              for (let Tn = 0; Tn < Pr.length - 1; Tn++) _.push(nr(kr, Pr[Tn], Rr, Pr[Tn + 1]));
            }
          } else _.push(nr({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: I + 1 }, { fixed: 0, stretch: B + 1 }));
          return _;
        }
        function pm(f, c, u) {
          let p = 0;
          for (const _ of f) p += Math.max(c, Math.min(u, _[1])) - Math.max(c, Math.min(u, _[0]));
          return p;
        }
        function Qw(f, c, u) {
          const p = [{ fixed: -1, stretch: 0 }];
          for (const [_, x] of f) {
            const T = p[p.length - 1];
            p.push({ fixed: _ - T.stretch, stretch: T.stretch }), p.push({ fixed: _ - T.stretch, stretch: T.stretch + (x - _) });
          }
          return p.push({ fixed: c + 1, stretch: u }), p;
        }
        function gm(f, c, u, p) {
          return f / c * u + p;
        }
        function mm(f, c, u, p) {
          return f - c * u / p;
        }
        Re("Anchor", Sh);
        class _m {
          constructor(c, u, p, _, x, T, I, B, N, z) {
            var $;
            if (this.boxStartIndex = c.length, N) {
              let J = T.top, te = T.bottom;
              const ne = T.collisionPadding;
              ne && (J -= ne[1], te += ne[3]);
              let ue = te - J;
              ue > 0 && (ue = Math.max(10, ue), this.circleDiameter = ue);
            } else {
              const J = !(($ = T.image) === null || $ === void 0) && $.content && (T.image.textFitWidth || T.image.textFitHeight) ? Ew(T) : { x1: T.left, y1: T.top, x2: T.right, y2: T.bottom };
              J.y1 = J.y1 * I - B[0], J.y2 = J.y2 * I + B[2], J.x1 = J.x1 * I - B[3], J.x2 = J.x2 * I + B[1];
              const te = T.collisionPadding;
              if (te && (J.x1 -= te[0] * I, J.y1 -= te[1] * I, J.x2 += te[2] * I, J.y2 += te[3] * I), z) {
                const ne = new k(J.x1, J.y1), ue = new k(J.x2, J.y1), Se = new k(J.x1, J.y2), Ee = new k(J.x2, J.y2), Je = z * Math.PI / 180;
                ne._rotate(Je), ue._rotate(Je), Se._rotate(Je), Ee._rotate(Je), J.x1 = Math.min(ne.x, ue.x, Se.x, Ee.x), J.x2 = Math.max(ne.x, ue.x, Se.x, Ee.x), J.y1 = Math.min(ne.y, ue.y, Se.y, Ee.y), J.y2 = Math.max(ne.y, ue.y, Se.y, Ee.y);
              }
              c.emplaceBack(u.x, u.y, J.x1, J.y1, J.x2, J.y2, p, _, x);
            }
            this.boxEndIndex = c.length;
          }
        }
        class qR {
          constructor() {
            let c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (p, _) => p < _ ? -1 : p > _ ? 1 : 0;
            if (this.data = c, this.length = this.data.length, this.compare = u, this.length > 0) for (let p = (this.length >> 1) - 1; p >= 0; p--) this._down(p);
          }
          push(c) {
            this.data.push(c), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const c = this.data[0], u = this.data.pop();
            return --this.length > 0 && (this.data[0] = u, this._down(0)), c;
          }
          peek() {
            return this.data[0];
          }
          _up(c) {
            const { data: u, compare: p } = this, _ = u[c];
            for (; c > 0; ) {
              const x = c - 1 >> 1, T = u[x];
              if (p(_, T) >= 0) break;
              u[c] = T, c = x;
            }
            u[c] = _;
          }
          _down(c) {
            const { data: u, compare: p } = this, _ = this.length >> 1, x = u[c];
            for (; c < _; ) {
              let T = 1 + (c << 1);
              const I = T + 1;
              if (I < this.length && p(u[I], u[T]) < 0 && (T = I), p(u[T], x) >= 0) break;
              u[c] = u[T], c = T;
            }
            u[c] = x;
          }
        }
        function GR(f) {
          let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
          const p = df.fromPoints(f[0]), _ = Math.min(p.width(), p.height());
          let x = _ / 2;
          const T = new qR([], HR), { minX: I, minY: B, maxX: N, maxY: z } = p;
          if (_ === 0) return new k(I, B);
          for (let te = I; te < N; te += _) for (let ne = B; ne < z; ne += _) T.push(new dd(te + x, ne + x, x, f));
          let $ = function(te) {
            let ne = 0, ue = 0, Se = 0;
            const Ee = te[0];
            for (let Je = 0, ze = Ee.length, ee = ze - 1; Je < ze; ee = Je++) {
              const ve = Ee[Je], qe = Ee[ee], _t = ve.x * qe.y - qe.x * ve.y;
              ue += (ve.x + qe.x) * _t, Se += (ve.y + qe.y) * _t, ne += 3 * _t;
            }
            return new dd(ue / ne, Se / ne, 0, te);
          }(f), J = T.length;
          for (; T.length; ) {
            const te = T.pop();
            (te.d > $.d || !$.d) && ($ = te, u && console.log("found best %d after %d probes", Math.round(1e4 * te.d) / 1e4, J)), te.max - $.d <= c || (x = te.h / 2, T.push(new dd(te.p.x - x, te.p.y - x, x, f)), T.push(new dd(te.p.x + x, te.p.y - x, x, f)), T.push(new dd(te.p.x - x, te.p.y + x, x, f)), T.push(new dd(te.p.x + x, te.p.y + x, x, f)), J += 4);
          }
          return u && (console.log(`num probes: ${J}`), console.log(`best distance: ${$.d}`)), $.p;
        }
        function HR(f, c) {
          return c.max - f.max;
        }
        function dd(f, c, u, p) {
          this.p = new k(f, c), this.h = u, this.d = function(_, x) {
            let T = !1, I = 1 / 0;
            for (let B = 0; B < x.length; B++) {
              const N = x[B];
              for (let z = 0, $ = N.length, J = $ - 1; z < $; J = z++) {
                const te = N[z], ne = N[J];
                te.y > _.y != ne.y > _.y && _.x < (ne.x - te.x) * (_.y - te.y) / (ne.y - te.y) + te.x && (T = !T), I = Math.min(I, Bx(_, te, ne));
              }
            }
            return (T ? 1 : -1) * Math.sqrt(I);
          }(this.p, p), this.max = this.d + this.h * Math.SQRT2;
        }
        var fo;
        l.aD = void 0, (fo = l.aD || (l.aD = {}))[fo.center = 1] = "center", fo[fo.left = 2] = "left", fo[fo.right = 3] = "right", fo[fo.top = 4] = "top", fo[fo.bottom = 5] = "bottom", fo[fo["top-left"] = 6] = "top-left", fo[fo["top-right"] = 7] = "top-right", fo[fo["bottom-left"] = 8] = "bottom-left", fo[fo["bottom-right"] = 9] = "bottom-right";
        const D0 = Number.POSITIVE_INFINITY;
        function eA(f, c) {
          return c[1] !== D0 ? function(u, p, _) {
            let x = 0, T = 0;
            switch (p = Math.abs(p), _ = Math.abs(_), u) {
              case "top-right":
              case "top-left":
              case "top":
                T = _ - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                T = 7 - _;
            }
            switch (u) {
              case "top-right":
              case "bottom-right":
              case "right":
                x = -p;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                x = p;
            }
            return [x, T];
          }(f, c[0], c[1]) : function(u, p) {
            let _ = 0, x = 0;
            p < 0 && (p = 0);
            const T = p / Math.SQRT2;
            switch (u) {
              case "top-right":
              case "top-left":
                x = T - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                x = 7 - T;
                break;
              case "bottom":
                x = 7 - p;
                break;
              case "top":
                x = p - 7;
            }
            switch (u) {
              case "top-right":
              case "bottom-right":
                _ = -T;
                break;
              case "top-left":
              case "bottom-left":
                _ = T;
                break;
              case "left":
                _ = p;
                break;
              case "right":
                _ = -p;
            }
            return [_, x];
          }(f, c[0]);
        }
        function tA(f, c, u) {
          var p;
          const _ = f.layout, x = (p = _.get("text-variable-anchor-offset")) === null || p === void 0 ? void 0 : p.evaluate(c, {}, u);
          if (x) {
            const I = x.values, B = [];
            for (let N = 0; N < I.length; N += 2) {
              const z = B[N] = I[N], $ = I[N + 1].map((J) => J * Ls);
              z.startsWith("top") ? $[1] -= 7 : z.startsWith("bottom") && ($[1] += 7), B[N + 1] = $;
            }
            return new pn(B);
          }
          const T = _.get("text-variable-anchor");
          if (T) {
            let I;
            I = f._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [_.get("text-radial-offset").evaluate(c, {}, u) * Ls, D0] : _.get("text-offset").evaluate(c, {}, u).map((N) => N * Ls);
            const B = [];
            for (const N of T) B.push(N, eA(N, I));
            return new pn(B);
          }
          return null;
        }
        function F0(f) {
          switch (f) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function WR(f, c, u, p, _, x, T, I, B, N, z, $) {
          let J = x.textMaxSize.evaluate(c, {});
          J === void 0 && (J = T);
          const te = f.layers[0].layout, ne = te.get("icon-offset").evaluate(c, {}, z), ue = nA(u.horizontal), Se = T / 24, Ee = f.tilePixelRatio * Se, Je = f.tilePixelRatio * J / 24, ze = f.tilePixelRatio * I, ee = f.tilePixelRatio * te.get("symbol-spacing"), ve = te.get("text-padding") * f.tilePixelRatio, qe = function(jr, kr, Rr) {
            let Tn = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
            const Ui = jr.get("icon-padding").evaluate(kr, {}, Rr), ls = Ui && Ui.values;
            return [ls[0] * Tn, ls[1] * Tn, ls[2] * Tn, ls[3] * Tn];
          }(te, c, z, f.tilePixelRatio), _t = te.get("text-max-angle") / 180 * Math.PI, $t = te.get("text-rotation-alignment") !== "viewport" && te.get("symbol-placement") !== "point", Rt = te.get("icon-rotation-alignment") === "map" && te.get("symbol-placement") !== "point", Ot = te.get("symbol-placement"), Qt = ee / 2, Wt = te.get("icon-text-fit");
          let nr;
          p && Wt !== "none" && (f.allowVerticalPlacement && u.vertical && (nr = Cw(p, u.vertical, Wt, te.get("icon-text-fit-padding"), ne, Se)), ue && (p = Cw(p, ue, Wt, te.get("icon-text-fit-padding"), ne, Se)));
          const Ft = z ? $.line.getGranularityForZoomLevel(z.z) : 1, Pr = (jr, kr) => {
            kr.x < 0 || kr.x >= ce || kr.y < 0 || kr.y >= ce || function(Rr, Tn, Ui, ls, qo, ma, _a, Js, qi, Ts, Qs, cs, Go, ll, Os, ya, Ss, ks, Ns, us, mi, cc, pd, uc, YR) {
              const gd = Rr.addToLineVertexArray(Tn, Ui);
              let pf, md, _d, yd, aA = 0, lA = 0, cA = 0, uA = 0, H0 = -1, W0 = -1;
              const Gu = {};
              let hA = $o("");
              if (Rr.allowVerticalPlacement && ls.vertical) {
                const Co = Js.layout.get("text-rotate").evaluate(mi, {}, uc) + 90;
                _d = new _m(qi, Tn, Ts, Qs, cs, ls.vertical, Go, ll, Os, Co), _a && (yd = new _m(qi, Tn, Ts, Qs, cs, _a, Ss, ks, Os, Co));
              }
              if (qo) {
                const Co = Js.layout.get("icon-rotate").evaluate(mi, {}), cl = Js.layout.get("icon-text-fit") !== "none", gf = Jw(qo, Co, pd, cl), fc = _a ? Jw(_a, Co, pd, cl) : void 0;
                md = new _m(qi, Tn, Ts, Qs, cs, qo, Ss, ks, !1, Co), aA = 4 * gf.length;
                const mf = Rr.iconSizeData;
                let su = null;
                mf.kind === "source" ? (su = [qu * Js.layout.get("icon-size").evaluate(mi, {})], su[0] > Ah && Dr(`${Rr.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : mf.kind === "composite" && (su = [qu * cc.compositeIconSizes[0].evaluate(mi, {}, uc), qu * cc.compositeIconSizes[1].evaluate(mi, {}, uc)], (su[0] > Ah || su[1] > Ah) && Dr(`${Rr.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), Rr.addSymbols(Rr.icon, gf, su, us, Ns, mi, l.an.none, Tn, gd.lineStartIndex, gd.lineLength, -1, uc), H0 = Rr.icon.placedSymbolArray.length - 1, fc && (lA = 4 * fc.length, Rr.addSymbols(Rr.icon, fc, su, us, Ns, mi, l.an.vertical, Tn, gd.lineStartIndex, gd.lineLength, -1, uc), W0 = Rr.icon.placedSymbolArray.length - 1);
              }
              const fA = Object.keys(ls.horizontal);
              for (const Co of fA) {
                const cl = ls.horizontal[Co];
                if (!pf) {
                  hA = $o(cl.text);
                  const fc = Js.layout.get("text-rotate").evaluate(mi, {}, uc);
                  pf = new _m(qi, Tn, Ts, Qs, cs, cl, Go, ll, Os, fc);
                }
                const gf = cl.positionedLines.length === 1;
                if (cA += rA(Rr, Tn, cl, ma, Js, Os, mi, ya, gd, ls.vertical ? l.an.horizontal : l.an.horizontalOnly, gf ? fA : [Co], Gu, H0, cc, uc), gf) break;
              }
              ls.vertical && (uA += rA(Rr, Tn, ls.vertical, ma, Js, Os, mi, ya, gd, l.an.vertical, ["vertical"], Gu, W0, cc, uc));
              const KR = pf ? pf.boxStartIndex : Rr.collisionBoxArray.length, JR = pf ? pf.boxEndIndex : Rr.collisionBoxArray.length, QR = _d ? _d.boxStartIndex : Rr.collisionBoxArray.length, e4 = _d ? _d.boxEndIndex : Rr.collisionBoxArray.length, t4 = md ? md.boxStartIndex : Rr.collisionBoxArray.length, r4 = md ? md.boxEndIndex : Rr.collisionBoxArray.length, n4 = yd ? yd.boxStartIndex : Rr.collisionBoxArray.length, i4 = yd ? yd.boxEndIndex : Rr.collisionBoxArray.length;
              let hc = -1;
              const bm = (Co, cl) => Co && Co.circleDiameter ? Math.max(Co.circleDiameter, cl) : cl;
              hc = bm(pf, hc), hc = bm(_d, hc), hc = bm(md, hc), hc = bm(yd, hc);
              const dA = hc > -1 ? 1 : 0;
              dA && (hc *= YR / Ls), Rr.glyphOffsetArray.length >= hd.MAX_GLYPHS && Dr("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), mi.sortKey !== void 0 && Rr.addToSortKeyRanges(Rr.symbolInstances.length, mi.sortKey);
              const s4 = tA(Js, mi, uc), [o4, a4] = function(Co, cl) {
                const gf = Co.length, fc = cl == null ? void 0 : cl.values;
                if ((fc == null ? void 0 : fc.length) > 0) for (let mf = 0; mf < fc.length; mf += 2) {
                  const su = fc[mf + 1];
                  Co.emplaceBack(l.aD[fc[mf]], su[0], su[1]);
                }
                return [gf, Co.length];
              }(Rr.textAnchorOffsets, s4);
              Rr.symbolInstances.emplaceBack(Tn.x, Tn.y, Gu.right >= 0 ? Gu.right : -1, Gu.center >= 0 ? Gu.center : -1, Gu.left >= 0 ? Gu.left : -1, Gu.vertical || -1, H0, W0, hA, KR, JR, QR, e4, t4, r4, n4, i4, Ts, cA, uA, aA, lA, dA, 0, Go, hc, o4, a4);
            }(f, kr, jr, u, p, _, nr, f.layers[0], f.collisionBoxArray, c.index, c.sourceLayerIndex, f.index, Ee, [ve, ve, ve, ve], $t, B, ze, qe, Rt, ne, c, x, N, z, T);
          };
          if (Ot === "line") for (const jr of Hw(c.geometry, 0, 0, ce, ce)) {
            const kr = ff(jr, Ft), Rr = $R(kr, ee, _t, u.vertical || ue, p, 24, Je, f.overscaling, ce);
            for (const Tn of Rr) ue && XR(f, ue.text, Qt, Tn) || Pr(kr, Tn);
          }
          else if (Ot === "line-center") {
            for (const jr of c.geometry) if (jr.length > 1) {
              const kr = ff(jr, Ft), Rr = VR(kr, _t, u.vertical || ue, p, 24, Je);
              Rr && Pr(kr, Rr);
            }
          } else if (c.type === "Polygon") for (const jr of El(c.geometry, 0)) {
            const kr = GR(jr, 16);
            Pr(ff(jr[0], Ft, !0), new Sh(kr.x, kr.y, 0));
          }
          else if (c.type === "LineString") for (const jr of c.geometry) {
            const kr = ff(jr, Ft);
            Pr(kr, new Sh(kr[0].x, kr[0].y, 0));
          }
          else if (c.type === "Point") for (const jr of c.geometry) for (const kr of jr) Pr([kr], new Sh(kr.x, kr.y, 0));
        }
        function rA(f, c, u, p, _, x, T, I, B, N, z, $, J, te, ne) {
          const ue = function(Je, ze, ee, ve, qe, _t, $t, Rt) {
            const Ot = ve.layout.get("text-rotate").evaluate(_t, {}) * Math.PI / 180, Qt = [];
            for (const Wt of ze.positionedLines) for (const nr of Wt.positionedGlyphs) {
              if (!nr.rect) continue;
              const Ft = nr.rect || {};
              let Pr = 4, jr = !0, kr = 1, Rr = 0;
              const Tn = (qe || Rt) && nr.vertical, Ui = nr.metrics.advance * nr.scale / 2;
              if (Rt && ze.verticalizable && (Rr = Wt.lineOffset / 2 - (nr.imageName ? -(Ls - nr.metrics.width * nr.scale) / 2 : (nr.scale - 1) * Ls)), nr.imageName) {
                const ks = $t[nr.imageName];
                jr = ks.sdf, kr = ks.pixelRatio, Pr = 1 / kr;
              }
              const ls = qe ? [nr.x + Ui, nr.y] : [0, 0];
              let qo = qe ? [0, 0] : [nr.x + Ui + ee[0], nr.y + ee[1] - Rr], ma = [0, 0];
              Tn && (ma = qo, qo = [0, 0]);
              const _a = nr.metrics.isDoubleResolution ? 2 : 1, Js = (nr.metrics.left - Pr) * nr.scale - Ui + qo[0], qi = (-nr.metrics.top - Pr) * nr.scale + qo[1], Ts = Js + Ft.w / _a * nr.scale / kr, Qs = qi + Ft.h / _a * nr.scale / kr, cs = new k(Js, qi), Go = new k(Ts, qi), ll = new k(Js, Qs), Os = new k(Ts, Qs);
              if (Tn) {
                const ks = new k(-Ui, Ui - -17), Ns = -Math.PI / 2, us = 12 - Ui, mi = new k(22 - us, -(nr.imageName ? us : 0)), cc = new k(...ma);
                cs._rotateAround(Ns, ks)._add(mi)._add(cc), Go._rotateAround(Ns, ks)._add(mi)._add(cc), ll._rotateAround(Ns, ks)._add(mi)._add(cc), Os._rotateAround(Ns, ks)._add(mi)._add(cc);
              }
              if (Ot) {
                const ks = Math.sin(Ot), Ns = Math.cos(Ot), us = [Ns, -ks, ks, Ns];
                cs._matMult(us), Go._matMult(us), ll._matMult(us), Os._matMult(us);
              }
              const ya = new k(0, 0), Ss = new k(0, 0);
              Qt.push({ tl: cs, tr: Go, bl: ll, br: Os, tex: Ft, writingMode: ze.writingMode, glyphOffset: ls, sectionIndex: nr.sectionIndex, isSDF: jr, pixelOffsetTL: ya, pixelOffsetBR: Ss, minFontScaleX: 0, minFontScaleY: 0 });
            }
            return Qt;
          }(0, u, I, _, x, T, p, f.allowVerticalPlacement), Se = f.textSizeData;
          let Ee = null;
          Se.kind === "source" ? (Ee = [qu * _.layout.get("text-size").evaluate(T, {})], Ee[0] > Ah && Dr(`${f.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : Se.kind === "composite" && (Ee = [qu * te.compositeTextSizes[0].evaluate(T, {}, ne), qu * te.compositeTextSizes[1].evaluate(T, {}, ne)], (Ee[0] > Ah || Ee[1] > Ah) && Dr(`${f.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), f.addSymbols(f.text, ue, Ee, I, x, T, N, c, B.lineStartIndex, B.lineLength, J, ne);
          for (const Je of z) $[Je] = f.text.placedSymbolArray.length - 1;
          return 4 * ue.length;
        }
        function nA(f) {
          for (const c in f) return f[c];
          return null;
        }
        function XR(f, c, u, p) {
          const _ = f.compareText;
          if (c in _) {
            const x = _[c];
            for (let T = x.length - 1; T >= 0; T--) if (p.dist(x[T]) < u) return !0;
          } else _[c] = [];
          return _[c].push(p), !1;
        }
        const iA = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class U0 {
          static from(c) {
            if (!(c instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [u, p] = new Uint8Array(c, 0, 2);
            if (u !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const _ = p >> 4;
            if (_ !== 1) throw new Error(`Got v${_} data when expected v1.`);
            const x = iA[15 & p];
            if (!x) throw new Error("Unrecognized array type.");
            const [T] = new Uint16Array(c, 2, 1), [I] = new Uint32Array(c, 4, 1);
            return new U0(I, T, x, c);
          }
          constructor(c) {
            let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, _ = arguments.length > 3 ? arguments[3] : void 0;
            if (isNaN(c) || c < 0) throw new Error(`Unpexpected numItems value: ${c}.`);
            this.numItems = +c, this.nodeSize = Math.min(Math.max(+u, 2), 65535), this.ArrayType = p, this.IndexArrayType = c < 65536 ? Uint16Array : Uint32Array;
            const x = iA.indexOf(this.ArrayType), T = 2 * c * this.ArrayType.BYTES_PER_ELEMENT, I = c * this.IndexArrayType.BYTES_PER_ELEMENT, B = (8 - I % 8) % 8;
            if (x < 0) throw new Error(`Unexpected typed array class: ${p}.`);
            _ && _ instanceof ArrayBuffer ? (this.data = _, this.ids = new this.IndexArrayType(this.data, 8, c), this.coords = new this.ArrayType(this.data, 8 + I + B, 2 * c), this._pos = 2 * c, this._finished = !0) : (this.data = new ArrayBuffer(8 + T + I + B), this.ids = new this.IndexArrayType(this.data, 8, c), this.coords = new this.ArrayType(this.data, 8 + I + B, 2 * c), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + x]), new Uint16Array(this.data, 2, 1)[0] = u, new Uint32Array(this.data, 4, 1)[0] = c);
          }
          add(c, u) {
            const p = this._pos >> 1;
            return this.ids[p] = p, this.coords[this._pos++] = c, this.coords[this._pos++] = u, p;
          }
          finish() {
            const c = this._pos >> 1;
            if (c !== this.numItems) throw new Error(`Added ${c} items when expected ${this.numItems}.`);
            return z0(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
          }
          range(c, u, p, _) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: x, coords: T, nodeSize: I } = this, B = [0, x.length - 1, 0], N = [];
            for (; B.length; ) {
              const z = B.pop() || 0, $ = B.pop() || 0, J = B.pop() || 0;
              if ($ - J <= I) {
                for (let Se = J; Se <= $; Se++) {
                  const Ee = T[2 * Se], Je = T[2 * Se + 1];
                  Ee >= c && Ee <= p && Je >= u && Je <= _ && N.push(x[Se]);
                }
                continue;
              }
              const te = J + $ >> 1, ne = T[2 * te], ue = T[2 * te + 1];
              ne >= c && ne <= p && ue >= u && ue <= _ && N.push(x[te]), (z === 0 ? c <= ne : u <= ue) && (B.push(J), B.push(te - 1), B.push(1 - z)), (z === 0 ? p >= ne : _ >= ue) && (B.push(te + 1), B.push($), B.push(1 - z));
            }
            return N;
          }
          within(c, u, p) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: _, coords: x, nodeSize: T } = this, I = [0, _.length - 1, 0], B = [], N = p * p;
            for (; I.length; ) {
              const z = I.pop() || 0, $ = I.pop() || 0, J = I.pop() || 0;
              if ($ - J <= T) {
                for (let Se = J; Se <= $; Se++) oA(x[2 * Se], x[2 * Se + 1], c, u) <= N && B.push(_[Se]);
                continue;
              }
              const te = J + $ >> 1, ne = x[2 * te], ue = x[2 * te + 1];
              oA(ne, ue, c, u) <= N && B.push(_[te]), (z === 0 ? c - p <= ne : u - p <= ue) && (I.push(J), I.push(te - 1), I.push(1 - z)), (z === 0 ? c + p >= ne : u + p >= ue) && (I.push(te + 1), I.push($), I.push(1 - z));
            }
            return B;
          }
        }
        function z0(f, c, u, p, _, x) {
          if (_ - p <= u) return;
          const T = p + _ >> 1;
          sA(f, c, T, p, _, x), z0(f, c, u, p, T - 1, 1 - x), z0(f, c, u, T + 1, _, 1 - x);
        }
        function sA(f, c, u, p, _, x) {
          for (; _ > p; ) {
            if (_ - p > 600) {
              const N = _ - p + 1, z = u - p + 1, $ = Math.log(N), J = 0.5 * Math.exp(2 * $ / 3), te = 0.5 * Math.sqrt($ * J * (N - J) / N) * (z - N / 2 < 0 ? -1 : 1);
              sA(f, c, u, Math.max(p, Math.floor(u - z * J / N + te)), Math.min(_, Math.floor(u + (N - z) * J / N + te)), x);
            }
            const T = c[2 * u + x];
            let I = p, B = _;
            for (Vp(f, c, p, u), c[2 * _ + x] > T && Vp(f, c, p, _); I < B; ) {
              for (Vp(f, c, I, B), I++, B--; c[2 * I + x] < T; ) I++;
              for (; c[2 * B + x] > T; ) B--;
            }
            c[2 * p + x] === T ? Vp(f, c, p, B) : (B++, Vp(f, c, B, _)), B <= u && (p = B + 1), u <= B && (_ = B - 1);
          }
        }
        function Vp(f, c, u, p) {
          j0(f, u, p), j0(c, 2 * u, 2 * p), j0(c, 2 * u + 1, 2 * p + 1);
        }
        function j0(f, c, u) {
          const p = f[c];
          f[c] = f[u], f[u] = p;
        }
        function oA(f, c, u, p) {
          const _ = f - u, x = c - p;
          return _ * _ + x * x;
        }
        var V0;
        l.cw = void 0, (V0 = l.cw || (l.cw = {})).create = "create", V0.load = "load", V0.fullLoad = "fullLoad";
        let ym = null, $p = [];
        const $0 = 1e3 / 60, q0 = "loadTime", G0 = "fullLoadTime", ZR = { mark(f) {
          performance.mark(f);
        }, frame(f) {
          const c = f;
          ym != null && $p.push(c - ym), ym = c;
        }, clearMetrics() {
          ym = null, $p = [], performance.clearMeasures(q0), performance.clearMeasures(G0);
          for (const f in l.cw) performance.clearMarks(l.cw[f]);
        }, getPerformanceMetrics() {
          performance.measure(q0, l.cw.create, l.cw.load), performance.measure(G0, l.cw.create, l.cw.fullLoad);
          const f = performance.getEntriesByName(q0)[0].duration, c = performance.getEntriesByName(G0)[0].duration, u = $p.length, p = 1 / ($p.reduce((x, T) => x + T, 0) / u / 1e3), _ = $p.filter((x) => x > $0).reduce((x, T) => x + (T - $0) / $0, 0);
          return { loadTime: f, fullLoadTime: c, fps: p, percentDroppedFrames: _ / (u + _) * 100, totalFrames: u };
        } };
        l.$ = ce, l.A = ie, l.B = function(f) {
          let [c, u, p] = f;
          return u += 90, u *= Math.PI / 180, p *= Math.PI / 180, { x: c * Math.cos(u) * Math.sin(p), y: c * Math.sin(u) * Math.sin(p), z: c * Math.cos(p) };
        }, l.C = ss, l.D = fr, l.E = ft, l.F = Br, l.G = se, l.H = function(f) {
          if (pr == null) {
            const c = f.navigator ? f.navigator.userAgent : null;
            pr = !!f.safari || !(!c || !(/\b(iPad|iPhone|iPod)\b/.test(c) || c.match("Safari") && !c.match("Chrome")));
          }
          return pr;
        }, l.I = E0, l.J = class {
          constructor(f, c) {
            this.target = f, this.mapId = c, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new UR(() => this.process()), this.subscription = en(this.target, "message", (u) => this.receive(u), !1), this.globalScope = Yt(self) ? f : window;
          }
          registerMessageHandler(f, c) {
            this.messageHandlers[f] = c;
          }
          sendAsync(f, c) {
            return new Promise((u, p) => {
              const _ = Math.round(1e18 * Math.random()).toString(36).substring(0, 10), x = c ? en(c.signal, "abort", () => {
                x == null || x.unsubscribe(), delete this.resolveRejects[_];
                const B = { id: _, type: "<cancel>", origin: location.origin, targetMapId: f.targetMapId, sourceMapId: this.mapId };
                this.target.postMessage(B);
              }, zR) : null;
              this.resolveRejects[_] = { resolve: (B) => {
                x == null || x.unsubscribe(), u(B);
              }, reject: (B) => {
                x == null || x.unsubscribe(), p(B);
              } };
              const T = [], I = Object.assign(Object.assign({}, f), { id: _, sourceMapId: this.mapId, origin: location.origin, data: Gt(f.data, T) });
              this.target.postMessage(I, { transfer: T });
            });
          }
          receive(f) {
            const c = f.data, u = c.id;
            if (!(c.origin !== "file://" && location.origin !== "file://" && c.origin !== "resource://android" && location.origin !== "resource://android" && c.origin !== location.origin || c.targetMapId && this.mapId !== c.targetMapId)) {
              if (c.type === "<cancel>") {
                delete this.tasks[u];
                const p = this.abortControllers[u];
                return delete this.abortControllers[u], void (p && p.abort());
              }
              if (Yt(self) || c.mustQueue) return this.tasks[u] = c, this.taskQueue.push(u), void this.invoker.trigger();
              this.processTask(u, c);
            }
          }
          process() {
            if (this.taskQueue.length === 0) return;
            const f = this.taskQueue.shift(), c = this.tasks[f];
            delete this.tasks[f], this.taskQueue.length > 0 && this.invoker.trigger(), c && this.processTask(f, c);
          }
          processTask(f, c) {
            return o(this, void 0, void 0, function* () {
              if (c.type === "<response>") {
                const _ = this.resolveRejects[f];
                return delete this.resolveRejects[f], _ ? void (c.error ? _.reject(kt(c.error)) : _.resolve(kt(c.data))) : void 0;
              }
              if (!this.messageHandlers[c.type]) return void this.completeTask(f, new Error(`Could not find a registered handler for ${c.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const u = kt(c.data), p = new AbortController();
              this.abortControllers[f] = p;
              try {
                const _ = yield this.messageHandlers[c.type](c.sourceMapId, u, p);
                this.completeTask(f, null, _);
              } catch (_) {
                this.completeTask(f, _);
              }
            });
          }
          completeTask(f, c, u) {
            const p = [];
            delete this.abortControllers[f];
            const _ = { id: f, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: c ? Gt(c) : null, data: Gt(u, p) };
            this.target.postMessage(_, { transfer: p });
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe();
          }
        }, l.K = ye, l.L = function() {
          var f = new ie(16);
          return ie != Float32Array && (f[1] = 0, f[2] = 0, f[3] = 0, f[4] = 0, f[6] = 0, f[7] = 0, f[8] = 0, f[9] = 0, f[11] = 0, f[12] = 0, f[13] = 0, f[14] = 0), f[0] = 1, f[5] = 1, f[10] = 1, f[15] = 1, f;
        }, l.M = function(f, c, u) {
          var p, _, x, T, I, B, N, z, $, J, te, ne, ue = u[0], Se = u[1], Ee = u[2];
          return c === f ? (f[12] = c[0] * ue + c[4] * Se + c[8] * Ee + c[12], f[13] = c[1] * ue + c[5] * Se + c[9] * Ee + c[13], f[14] = c[2] * ue + c[6] * Se + c[10] * Ee + c[14], f[15] = c[3] * ue + c[7] * Se + c[11] * Ee + c[15]) : (_ = c[1], x = c[2], T = c[3], I = c[4], B = c[5], N = c[6], z = c[7], $ = c[8], J = c[9], te = c[10], ne = c[11], f[0] = p = c[0], f[1] = _, f[2] = x, f[3] = T, f[4] = I, f[5] = B, f[6] = N, f[7] = z, f[8] = $, f[9] = J, f[10] = te, f[11] = ne, f[12] = p * ue + I * Se + $ * Ee + c[12], f[13] = _ * ue + B * Se + J * Ee + c[13], f[14] = x * ue + N * Se + te * Ee + c[14], f[15] = T * ue + z * Se + ne * Ee + c[15]), f;
        }, l.N = function(f, c, u) {
          var p = u[0], _ = u[1], x = u[2];
          return f[0] = c[0] * p, f[1] = c[1] * p, f[2] = c[2] * p, f[3] = c[3] * p, f[4] = c[4] * _, f[5] = c[5] * _, f[6] = c[6] * _, f[7] = c[7] * _, f[8] = c[8] * x, f[9] = c[9] * x, f[10] = c[10] * x, f[11] = c[11] * x, f[12] = c[12], f[13] = c[13], f[14] = c[14], f[15] = c[15], f;
        }, l.O = function(f, c, u) {
          var p = c[0], _ = c[1], x = c[2], T = c[3], I = c[4], B = c[5], N = c[6], z = c[7], $ = c[8], J = c[9], te = c[10], ne = c[11], ue = c[12], Se = c[13], Ee = c[14], Je = c[15], ze = u[0], ee = u[1], ve = u[2], qe = u[3];
          return f[0] = ze * p + ee * I + ve * $ + qe * ue, f[1] = ze * _ + ee * B + ve * J + qe * Se, f[2] = ze * x + ee * N + ve * te + qe * Ee, f[3] = ze * T + ee * z + ve * ne + qe * Je, f[4] = (ze = u[4]) * p + (ee = u[5]) * I + (ve = u[6]) * $ + (qe = u[7]) * ue, f[5] = ze * _ + ee * B + ve * J + qe * Se, f[6] = ze * x + ee * N + ve * te + qe * Ee, f[7] = ze * T + ee * z + ve * ne + qe * Je, f[8] = (ze = u[8]) * p + (ee = u[9]) * I + (ve = u[10]) * $ + (qe = u[11]) * ue, f[9] = ze * _ + ee * B + ve * J + qe * Se, f[10] = ze * x + ee * N + ve * te + qe * Ee, f[11] = ze * T + ee * z + ve * ne + qe * Je, f[12] = (ze = u[12]) * p + (ee = u[13]) * I + (ve = u[14]) * $ + (qe = u[15]) * ue, f[13] = ze * _ + ee * B + ve * J + qe * Se, f[14] = ze * x + ee * N + ve * te + qe * Ee, f[15] = ze * T + ee * z + ve * ne + qe * Je, f;
        }, l.P = k, l.Q = function(f, c) {
          const u = {};
          for (let p = 0; p < c.length; p++) {
            const _ = c[p];
            _ in f && (u[_] = f[_]);
          }
          return u;
        }, l.R = ga, l.S = Th, l.T = h0, l.U = Dw, l.V = Nw, l.W = re, l.X = Z, l.Y = Lr, l.Z = al, l._ = o, l.a = oe, l.a$ = function(f, c, u) {
          return f[0] = c[0] * u, f[1] = c[1] * u, f[2] = c[2] * u, f[3] = c[3] * u, f;
        }, l.a0 = jp, l.a1 = df, l.a2 = 25, l.a3 = N0, l.a4 = (f) => {
          const c = window.document.createElement("video");
          return c.muted = !0, new Promise((u) => {
            c.onloadstart = () => {
              u(c);
            };
            for (const p of f) {
              const _ = window.document.createElement("source");
              gt(p) || (c.crossOrigin = "Anonymous"), _.src = p, c.appendChild(_);
            }
          });
        }, l.a5 = er, l.a6 = function() {
          return vr++;
        }, l.a7 = Ae, l.a8 = hd, l.a9 = Do, l.aA = Ls, l.aB = Oe, l.aC = function(f, c, u, p) {
          let _ = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
          if (!u[0] && !u[1]) return [0, 0];
          const x = _ ? p === "map" ? -f.bearingInRadians : 0 : p === "viewport" ? f.bearingInRadians : 0;
          if (x) {
            const T = Math.sin(x), I = Math.cos(x);
            u = [u[0] * I - u[1] * T, u[0] * T + u[1] * I];
          }
          return [_ ? u[0] : Oe(c, u[0], f.zoom), _ ? u[1] : Oe(c, u[1], f.zoom)];
        }, l.aE = M0, l.aF = F0, l.aG = I0, l.aH = U0, l.aI = pi, l.aJ = am, l.aK = dt, l.aL = yn, l.aM = In, l.aN = ar, l.aO = vn, l.aP = Uw, l.aQ = je, l.aR = me, l.aS = function(f) {
          var c = new ie(3);
          return c[0] = f[0], c[1] = f[1], c[2] = f[2], c;
        }, l.aT = function(f, c, u) {
          return f[0] = c[0] - u[0], f[1] = c[1] - u[1], f[2] = c[2] - u[2], f;
        }, l.aU = function(f, c) {
          var u = c[0], p = c[1], _ = c[2], x = u * u + p * p + _ * _;
          return x > 0 && (x = 1 / Math.sqrt(x)), f[0] = c[0] * x, f[1] = c[1] * x, f[2] = c[2] * x, f;
        }, l.aV = Pe, l.aW = function(f, c) {
          return f[0] * c[0] + f[1] * c[1] + f[2] * c[2];
        }, l.aX = function(f, c, u) {
          return f[0] = c[0] * u[0], f[1] = c[1] * u[1], f[2] = c[2] * u[2], f[3] = c[3] * u[3], f;
        }, l.aY = ke, l.aZ = function(f, c, u) {
          const p = c[0] * u[0] + c[1] * u[1] + c[2] * u[2];
          return p === 0 ? null : (-(f[0] * u[0] + f[1] * u[1] + f[2] * u[2]) - u[3]) / p;
        }, l.a_ = Mt, l.aa = uf, l.ab = $w, l.ac = function(f) {
          const c = {};
          if (f.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (u, p, _, x) => {
            const T = _ || x;
            return c[p] = !T || T.toLowerCase(), "";
          }), c["max-age"]) {
            const u = parseInt(c["max-age"], 10);
            isNaN(u) ? delete c["max-age"] : c["max-age"] = u;
          }
          return c;
        }, l.ad = nn, l.ae = function(f) {
          return Math.pow(2, f);
        }, l.af = he, l.ag = yt, l.ah = 85.051129, l.ai = Fw, l.aj = function(f) {
          return Math.log(f) / Math.LN2;
        }, l.ak = function(f) {
          var c = f[0], u = f[1];
          return c * c + u * u;
        }, l.al = function(f, c) {
          const u = [];
          for (const p in f) p in c || u.push(p);
          return u;
        }, l.am = function(f, c) {
          let u = 0, p = 0;
          if (f.kind === "constant") p = f.layoutSize;
          else if (f.kind !== "source") {
            const { interpolationType: _, minZoom: x, maxZoom: T } = f, I = _ ? yt(is.interpolationFactor(_, c, x, T), 0, 1) : 0;
            f.kind === "camera" ? p = ss.number(f.minSize, f.maxSize, I) : u = I;
          }
          return { uSizeT: u, uSize: p };
        }, l.ao = function(f, c, u) {
          let { uSize: p, uSizeT: _ } = c, { lowerSize: x, upperSize: T } = u;
          return f.kind === "source" ? x / qu : f.kind === "composite" ? ss.number(x / qu, T / qu, _) : p;
        }, l.ap = function(f, c) {
          var u = c[0], p = c[1], _ = c[2], x = c[3], T = c[4], I = c[5], B = c[6], N = c[7], z = c[8], $ = c[9], J = c[10], te = c[11], ne = c[12], ue = c[13], Se = c[14], Ee = c[15], Je = u * I - p * T, ze = u * B - _ * T, ee = u * N - x * T, ve = p * B - _ * I, qe = p * N - x * I, _t = _ * N - x * B, $t = z * ue - $ * ne, Rt = z * Se - J * ne, Ot = z * Ee - te * ne, Qt = $ * Se - J * ue, Wt = $ * Ee - te * ue, nr = J * Ee - te * Se, Ft = Je * nr - ze * Wt + ee * Qt + ve * Ot - qe * Rt + _t * $t;
          return Ft ? (f[0] = (I * nr - B * Wt + N * Qt) * (Ft = 1 / Ft), f[1] = (_ * Wt - p * nr - x * Qt) * Ft, f[2] = (ue * _t - Se * qe + Ee * ve) * Ft, f[3] = (J * qe - $ * _t - te * ve) * Ft, f[4] = (B * Ot - T * nr - N * Rt) * Ft, f[5] = (u * nr - _ * Ot + x * Rt) * Ft, f[6] = (Se * ee - ne * _t - Ee * ze) * Ft, f[7] = (z * _t - J * ee + te * ze) * Ft, f[8] = (T * Wt - I * Ot + N * $t) * Ft, f[9] = (p * Ot - u * Wt - x * $t) * Ft, f[10] = (ne * qe - ue * ee + Ee * Je) * Ft, f[11] = ($ * ee - z * qe - te * Je) * Ft, f[12] = (I * Rt - T * Qt - B * $t) * Ft, f[13] = (u * Qt - p * Rt + _ * $t) * Ft, f[14] = (ue * ze - ne * ve - Se * Je) * Ft, f[15] = (z * ve - $ * ze + J * Je) * Ft, f) : null;
        }, l.aq = Dt, l.ar = function(f) {
          return Math.hypot(f[0], f[1]);
        }, l.as = function(f) {
          return f[0] = 0, f[1] = 0, f;
        }, l.at = function(f, c, u) {
          return f[0] = c[0] * u, f[1] = c[1] * u, f;
        }, l.au = P0, l.av = Lt, l.aw = function(f, c, u, p) {
          const _ = c.y - f.y, x = c.x - f.x, T = p.y - u.y, I = p.x - u.x, B = T * x - I * _;
          if (B === 0) return null;
          const N = (I * (f.y - u.y) - T * (f.x - u.x)) / B;
          return new k(f.x + N * x, f.y + N * _);
        }, l.ax = Hw, l.ay = Px, l.az = function(f) {
          let c = 1 / 0, u = 1 / 0, p = -1 / 0, _ = -1 / 0;
          for (const x of f) c = Math.min(c, x.x), u = Math.min(u, x.y), p = Math.max(p, x.x), _ = Math.max(_, x.y);
          return [c, u, p, _];
        }, l.b = mr, l.b$ = mR, l.b0 = function(f, c) {
          return f[0] * c[0] + f[1] * c[1] + f[2] * c[2] + f[3];
        }, l.b1 = jw, l.b2 = fd, l.b3 = function(f, c, u, p, _) {
          var x, T = 1 / Math.tan(c / 2);
          return f[0] = T / u, f[1] = 0, f[2] = 0, f[3] = 0, f[4] = 0, f[5] = T, f[6] = 0, f[7] = 0, f[8] = 0, f[9] = 0, f[11] = -1, f[12] = 0, f[13] = 0, f[15] = 0, _ != null && _ !== 1 / 0 ? (f[10] = (_ + p) * (x = 1 / (p - _)), f[14] = 2 * _ * p * x) : (f[10] = -1, f[14] = -2 * p), f;
        }, l.b4 = function(f) {
          var c = new ie(16);
          return c[0] = f[0], c[1] = f[1], c[2] = f[2], c[3] = f[3], c[4] = f[4], c[5] = f[5], c[6] = f[6], c[7] = f[7], c[8] = f[8], c[9] = f[9], c[10] = f[10], c[11] = f[11], c[12] = f[12], c[13] = f[13], c[14] = f[14], c[15] = f[15], c;
        }, l.b5 = function(f, c, u) {
          var p = Math.sin(u), _ = Math.cos(u), x = c[0], T = c[1], I = c[2], B = c[3], N = c[4], z = c[5], $ = c[6], J = c[7];
          return c !== f && (f[8] = c[8], f[9] = c[9], f[10] = c[10], f[11] = c[11], f[12] = c[12], f[13] = c[13], f[14] = c[14], f[15] = c[15]), f[0] = x * _ + N * p, f[1] = T * _ + z * p, f[2] = I * _ + $ * p, f[3] = B * _ + J * p, f[4] = N * _ - x * p, f[5] = z * _ - T * p, f[6] = $ * _ - I * p, f[7] = J * _ - B * p, f;
        }, l.b6 = function(f, c, u) {
          var p = Math.sin(u), _ = Math.cos(u), x = c[4], T = c[5], I = c[6], B = c[7], N = c[8], z = c[9], $ = c[10], J = c[11];
          return c !== f && (f[0] = c[0], f[1] = c[1], f[2] = c[2], f[3] = c[3], f[12] = c[12], f[13] = c[13], f[14] = c[14], f[15] = c[15]), f[4] = x * _ + N * p, f[5] = T * _ + z * p, f[6] = I * _ + $ * p, f[7] = B * _ + J * p, f[8] = N * _ - x * p, f[9] = z * _ - T * p, f[10] = $ * _ - I * p, f[11] = J * _ - B * p, f;
        }, l.b7 = function() {
          const f = new Float32Array(16);
          return he(f), f;
        }, l.b8 = function() {
          const f = new Float64Array(16);
          return he(f), f;
        }, l.b9 = function() {
          return new Float64Array(16);
        }, l.bA = function(f) {
          return f[0] = 0, f[1] = 0, f[2] = 0, f;
        }, l.bB = function(f, c, u, p) {
          const _ = Math.sqrt(f * f + c * c), x = Math.sqrt(u * u + p * p);
          f /= _, c /= _, u /= x, p /= x;
          const T = Math.acos(f * u + c * p);
          return -c * u + f * p > 0 ? T : -T;
        }, l.bC = function(f, c) {
          const u = $e(f, 2 * Math.PI), p = $e(c, 2 * Math.PI);
          return Math.min(Math.abs(u - p), Math.abs(u - p + 2 * Math.PI), Math.abs(u - p - 2 * Math.PI));
        }, l.bD = function() {
          const f = {}, c = Ge.$version;
          for (const u in Ge.$root) {
            const p = Ge.$root[u];
            if (p.required) {
              let _ = null;
              _ = u === "version" ? c : p.type === "array" ? [] : {}, _ != null && (f[u] = _);
            }
          }
          return f;
        }, l.bE = rt, l.bF = Ye, l.bG = function f(c, u) {
          if (Array.isArray(c)) {
            if (!Array.isArray(u) || c.length !== u.length) return !1;
            for (let p = 0; p < c.length; p++) if (!f(c[p], u[p])) return !1;
            return !0;
          }
          if (typeof c == "object" && c !== null && u !== null) {
            if (typeof u != "object" || Object.keys(c).length !== Object.keys(u).length) return !1;
            for (const p in c) if (!f(c[p], u[p])) return !1;
            return !0;
          }
          return c === u;
        }, l.bH = function(f) {
          f = f.slice();
          const c = /* @__PURE__ */ Object.create(null);
          for (let u = 0; u < f.length; u++) c[f[u].id] = f[u];
          for (let u = 0; u < f.length; u++) "ref" in f[u] && (f[u] = Sr(f[u], c[f[u].ref]));
          return f;
        }, l.bI = function(f) {
          if (f.type === "custom") return new FR(f);
          switch (f.type) {
            case "background":
              return new kR(f);
            case "circle":
              return new MP(f);
            case "color-relief":
              return new kP(f);
            case "fill":
              return new YP(f);
            case "fill-extrusion":
              return new iR(f);
            case "heatmap":
              return new RP(f);
            case "hillshade":
              return new LP(f);
            case "line":
              return new fR(f);
            case "raster":
              return new DR(f);
            case "symbol":
              return new dm(f);
          }
        }, l.bJ = Nt, l.bK = function(f, c) {
          if (!f) return [{ command: "setStyle", args: [c] }];
          let u = [];
          try {
            if (!lr(f.version, c.version)) return [{ command: "setStyle", args: [c] }];
            lr(f.center, c.center) || u.push({ command: "setCenter", args: [c.center] }), lr(f.state, c.state) || u.push({ command: "setGlobalState", args: [c.state] }), lr(f.centerAltitude, c.centerAltitude) || u.push({ command: "setCenterAltitude", args: [c.centerAltitude] }), lr(f.zoom, c.zoom) || u.push({ command: "setZoom", args: [c.zoom] }), lr(f.bearing, c.bearing) || u.push({ command: "setBearing", args: [c.bearing] }), lr(f.pitch, c.pitch) || u.push({ command: "setPitch", args: [c.pitch] }), lr(f.roll, c.roll) || u.push({ command: "setRoll", args: [c.roll] }), lr(f.sprite, c.sprite) || u.push({ command: "setSprite", args: [c.sprite] }), lr(f.glyphs, c.glyphs) || u.push({ command: "setGlyphs", args: [c.glyphs] }), lr(f.transition, c.transition) || u.push({ command: "setTransition", args: [c.transition] }), lr(f.light, c.light) || u.push({ command: "setLight", args: [c.light] }), lr(f.terrain, c.terrain) || u.push({ command: "setTerrain", args: [c.terrain] }), lr(f.sky, c.sky) || u.push({ command: "setSky", args: [c.sky] }), lr(f.projection, c.projection) || u.push({ command: "setProjection", args: [c.projection] });
            const p = {}, _ = [];
            (function(T, I, B, N) {
              let z;
              for (z in I = I || {}, T = T || {}) Object.prototype.hasOwnProperty.call(T, z) && (Object.prototype.hasOwnProperty.call(I, z) || xn(z, B, N));
              for (z in I) Object.prototype.hasOwnProperty.call(I, z) && (Object.prototype.hasOwnProperty.call(T, z) ? lr(T[z], I[z]) || (T[z].type === "geojson" && I[z].type === "geojson" && Jr(T, I, z) ? Er(B, { command: "setGeoJSONSourceData", args: [z, I[z].data] }) : dn(z, I, B, N)) : tr(z, I, B));
            })(f.sources, c.sources, _, p);
            const x = [];
            f.layers && f.layers.forEach((T) => {
              "source" in T && p[T.source] ? u.push({ command: "removeLayer", args: [T.id] }) : x.push(T);
            }), u = u.concat(_), function(T, I, B) {
              I = I || [];
              const N = (T = T || []).map(zr), z = I.map(zr), $ = T.reduce(Dn, {}), J = I.reduce(Dn, {}), te = N.slice(), ne = /* @__PURE__ */ Object.create(null);
              let ue, Se, Ee, Je, ze;
              for (let ee = 0, ve = 0; ee < N.length; ee++) ue = N[ee], Object.prototype.hasOwnProperty.call(J, ue) ? ve++ : (Er(B, { command: "removeLayer", args: [ue] }), te.splice(te.indexOf(ue, ve), 1));
              for (let ee = 0, ve = 0; ee < z.length; ee++) ue = z[z.length - 1 - ee], te[te.length - 1 - ee] !== ue && (Object.prototype.hasOwnProperty.call($, ue) ? (Er(B, { command: "removeLayer", args: [ue] }), te.splice(te.lastIndexOf(ue, te.length - ve), 1)) : ve++, Je = te[te.length - ee], Er(B, { command: "addLayer", args: [J[ue], Je] }), te.splice(te.length - ee, 0, ue), ne[ue] = !0);
              for (let ee = 0; ee < z.length; ee++) if (ue = z[ee], Se = $[ue], Ee = J[ue], !ne[ue] && !lr(Se, Ee)) if (lr(Se.source, Ee.source) && lr(Se["source-layer"], Ee["source-layer"]) && lr(Se.type, Ee.type)) {
                for (ze in Cr(Se.layout, Ee.layout, B, ue, null, "setLayoutProperty"), Cr(Se.paint, Ee.paint, B, ue, null, "setPaintProperty"), lr(Se.filter, Ee.filter) || Er(B, { command: "setFilter", args: [ue, Ee.filter] }), lr(Se.minzoom, Ee.minzoom) && lr(Se.maxzoom, Ee.maxzoom) || Er(B, { command: "setLayerZoomRange", args: [ue, Ee.minzoom, Ee.maxzoom] }), Se) Object.prototype.hasOwnProperty.call(Se, ze) && ze !== "layout" && ze !== "paint" && ze !== "filter" && ze !== "metadata" && ze !== "minzoom" && ze !== "maxzoom" && (ze.indexOf("paint.") === 0 ? Cr(Se[ze], Ee[ze], B, ue, ze.slice(6), "setPaintProperty") : lr(Se[ze], Ee[ze]) || Er(B, { command: "setLayerProperty", args: [ue, ze, Ee[ze]] }));
                for (ze in Ee) Object.prototype.hasOwnProperty.call(Ee, ze) && !Object.prototype.hasOwnProperty.call(Se, ze) && ze !== "layout" && ze !== "paint" && ze !== "filter" && ze !== "metadata" && ze !== "minzoom" && ze !== "maxzoom" && (ze.indexOf("paint.") === 0 ? Cr(Se[ze], Ee[ze], B, ue, ze.slice(6), "setPaintProperty") : lr(Se[ze], Ee[ze]) || Er(B, { command: "setLayerProperty", args: [ue, ze, Ee[ze]] }));
              } else Er(B, { command: "removeLayer", args: [ue] }), Je = te[te.lastIndexOf(ue) + 1], Er(B, { command: "addLayer", args: [Ee, Je] });
            }(x, c.layers, u);
          } catch (p) {
            console.warn("Unable to compute style diff:", p), u = [{ command: "setStyle", args: [c] }];
          }
          return u;
        }, l.bL = function(f) {
          const c = [], u = f.id;
          return u === void 0 && c.push({ message: `layers.${u}: missing required property "id"` }), f.render === void 0 && c.push({ message: `layers.${u}: missing required method "render"` }), f.renderingMode && f.renderingMode !== "2d" && f.renderingMode !== "3d" && c.push({ message: `layers.${u}: property "renderingMode" must be either "2d" or "3d"` }), c;
        }, l.bM = sr, l.bN = Ur, l.bO = class extends gi {
          constructor(f, c) {
            super(f, c), this.current = 0;
          }
          set(f) {
            this.current !== f && (this.current = f, this.gl.uniform1i(this.location, f));
          }
        }, l.bP = rm, l.bQ = class extends gi {
          constructor(f, c) {
            super(f, c), this.current = i0;
          }
          set(f) {
            if (f[12] !== this.current[12] || f[0] !== this.current[0]) return this.current = f, void this.gl.uniformMatrix4fv(this.location, !1, f);
            for (let c = 1; c < 16; c++) if (f[c] !== this.current[c]) {
              this.current = f, this.gl.uniformMatrix4fv(this.location, !1, f);
              break;
            }
          }
        }, l.bR = As, l.bS = class extends gi {
          constructor(f, c) {
            super(f, c), this.current = [0, 0, 0];
          }
          set(f) {
            f[0] === this.current[0] && f[1] === this.current[1] && f[2] === this.current[2] || (this.current = f, this.gl.uniform3f(this.location, f[0], f[1], f[2]));
          }
        }, l.bT = class extends gi {
          constructor(f, c) {
            super(f, c), this.current = [0, 0];
          }
          set(f) {
            f[0] === this.current[0] && f[1] === this.current[1] || (this.current = f, this.gl.uniform2f(this.location, f[0], f[1]));
          }
        }, l.bU = be, l.bV = function(f, c) {
          var u = Math.sin(c), p = Math.cos(c);
          return f[0] = p, f[1] = u, f[2] = 0, f[3] = -u, f[4] = p, f[5] = 0, f[6] = 0, f[7] = 0, f[8] = 1, f;
        }, l.bW = function(f, c, u) {
          var p = c[0], _ = c[1], x = c[2];
          return f[0] = p * u[0] + _ * u[3] + x * u[6], f[1] = p * u[1] + _ * u[4] + x * u[7], f[2] = p * u[2] + _ * u[5] + x * u[8], f;
        }, l.bX = function(f, c, u, p, _, x, T) {
          var I = 1 / (c - u), B = 1 / (p - _), N = 1 / (x - T);
          return f[0] = -2 * I, f[1] = 0, f[2] = 0, f[3] = 0, f[4] = 0, f[5] = -2 * B, f[6] = 0, f[7] = 0, f[8] = 0, f[9] = 0, f[10] = 2 * N, f[11] = 0, f[12] = (c + u) * I, f[13] = (_ + p) * B, f[14] = (T + x) * N, f[15] = 1, f;
        }, l.bY = class extends gi {
          constructor(f, c) {
            super(f, c), this.current = new Array();
          }
          set(f) {
            if (f != this.current) {
              this.current = f;
              const c = new Float32Array(4 * f.length);
              for (let u = 0; u < f.length; u++) c[4 * u] = f[u].r, c[4 * u + 1] = f[u].g, c[4 * u + 2] = f[u].b, c[4 * u + 3] = f[u].a;
              this.gl.uniform4fv(this.location, c);
            }
          }
        }, l.bZ = class extends gi {
          constructor(f, c) {
            super(f, c), this.current = new Array();
          }
          set(f) {
            if (f != this.current) {
              this.current = f;
              const c = new Float32Array(f);
              this.gl.uniform1fv(this.location, c);
            }
          }
        }, l.b_ = class extends g {
        }, l.ba = function(f, c, u) {
          const p = new Float64Array(4);
          return zt(p, f, c - 90, u), p;
        }, l.bb = function(f, c, u, p) {
          var _, x, T, I, B, N = c[0], z = c[1], $ = c[2], J = c[3], te = u[0], ne = u[1], ue = u[2], Se = u[3];
          return (x = N * te + z * ne + $ * ue + J * Se) < 0 && (x = -x, te = -te, ne = -ne, ue = -ue, Se = -Se), 1 - x > K ? (_ = Math.acos(x), T = Math.sin(_), I = Math.sin((1 - p) * _) / T, B = Math.sin(p * _) / T) : (I = 1 - p, B = p), f[0] = I * N + B * te, f[1] = I * z + B * ne, f[2] = I * $ + B * ue, f[3] = I * J + B * Se, f;
        }, l.bc = function(f) {
          const c = new Float64Array(9);
          var u, p, _, x, T, I, B, N, z, $, J, te, ne, ue, Se, Ee, Je, ze;
          $ = (_ = (p = f)[0]) * (B = _ + _), J = (x = p[1]) * B, ne = (T = p[2]) * B, ue = T * (N = x + x), Ee = (I = p[3]) * B, Je = I * N, ze = I * (z = T + T), (u = c)[0] = 1 - (te = x * N) - (Se = T * z), u[3] = J - ze, u[6] = ne + Je, u[1] = J + ze, u[4] = 1 - $ - Se, u[7] = ue - Ee, u[2] = ne - Je, u[5] = ue + Ee, u[8] = 1 - $ - te;
          const ee = vn(-Math.asin(yt(c[2], -1, 1)));
          let ve, qe;
          return Math.hypot(c[5], c[8]) < 1e-3 ? (ve = 0, qe = -vn(Math.atan2(c[3], c[4]))) : (ve = vn(c[5] === 0 && c[8] === 0 ? 0 : Math.atan2(c[5], c[8])), qe = vn(c[1] === 0 && c[0] === 0 ? 0 : Math.atan2(c[1], c[0]))), { roll: ve, pitch: ee + 90, bearing: qe };
        }, l.bd = function(f, c) {
          return f.roll == c.roll && f.pitch == c.pitch && f.bearing == c.bearing;
        }, l.be = hn, l.bf = Eo, l.bg = cd, l.bh = Op, l.bi = ld, l.bj = et, l.bk = ot, l.bl = Wr, l.bm = function(f, c, u, p, _) {
          return et(p, _, yt((f - c) / (u - c), 0, 1));
        }, l.bn = $e, l.bo = function() {
          return new Float64Array(3);
        }, l.bp = function(f, c, u, p) {
          return f[0] = c[0] + u[0] * p, f[1] = c[1] + u[1] * p, f[2] = c[2] + u[2] * p, f;
        }, l.bq = zt, l.br = function(f, c, u) {
          var p = u[0], _ = u[1], x = u[2], T = c[0], I = c[1], B = c[2], N = _ * B - x * I, z = x * T - p * B, $ = p * I - _ * T, J = _ * $ - x * z, te = x * N - p * $, ne = p * z - _ * N, ue = 2 * u[3];
          return z *= ue, $ *= ue, te *= 2, ne *= 2, f[0] = T + (N *= ue) + (J *= 2), f[1] = I + z + te, f[2] = B + $ + ne, f;
        }, l.bs = function(f, c, u) {
          const p = (_ = [f[0], f[1], f[2], c[0], c[1], c[2], u[0], u[1], u[2]])[0] * ((z = _[8]) * (T = _[4]) - (I = _[5]) * (N = _[7])) + _[1] * (-z * (x = _[3]) + I * (B = _[6])) + _[2] * (N * x - T * B);
          var _, x, T, I, B, N, z;
          if (p === 0) return null;
          const $ = Pe([], [c[0], c[1], c[2]], [u[0], u[1], u[2]]), J = Pe([], [u[0], u[1], u[2]], [f[0], f[1], f[2]]), te = Pe([], [f[0], f[1], f[2]], [c[0], c[1], c[2]]), ne = je([], $, -f[3]);
          return me(ne, ne, je([], J, -c[3])), me(ne, ne, je([], te, -u[3])), je(ne, ne, 1 / p), ne;
        }, l.bt = O0, l.bu = function() {
          return new Float64Array(4);
        }, l.bv = function(f, c, u, p) {
          var _ = [], x = [];
          return _[0] = c[0] - u[0], _[1] = c[1] - u[1], _[2] = c[2] - u[2], x[0] = _[0] * Math.cos(p) - _[1] * Math.sin(p), x[1] = _[0] * Math.sin(p) + _[1] * Math.cos(p), x[2] = _[2], f[0] = x[0] + u[0], f[1] = x[1] + u[1], f[2] = x[2] + u[2], f;
        }, l.bw = function(f, c, u, p) {
          var _ = [], x = [];
          return _[0] = c[0] - u[0], _[1] = c[1] - u[1], _[2] = c[2] - u[2], x[0] = _[0], x[1] = _[1] * Math.cos(p) - _[2] * Math.sin(p), x[2] = _[1] * Math.sin(p) + _[2] * Math.cos(p), f[0] = x[0] + u[0], f[1] = x[1] + u[1], f[2] = x[2] + u[2], f;
        }, l.bx = function(f, c, u, p) {
          var _ = [], x = [];
          return _[0] = c[0] - u[0], _[1] = c[1] - u[1], _[2] = c[2] - u[2], x[0] = _[2] * Math.sin(p) + _[0] * Math.cos(p), x[1] = _[1], x[2] = _[2] * Math.cos(p) - _[0] * Math.sin(p), f[0] = x[0] + u[0], f[1] = x[1] + u[1], f[2] = x[2] + u[2], f;
        }, l.by = function(f, c, u) {
          var p = Math.sin(u), _ = Math.cos(u), x = c[0], T = c[1], I = c[2], B = c[3], N = c[8], z = c[9], $ = c[10], J = c[11];
          return c !== f && (f[4] = c[4], f[5] = c[5], f[6] = c[6], f[7] = c[7], f[12] = c[12], f[13] = c[13], f[14] = c[14], f[15] = c[15]), f[0] = x * _ - N * p, f[1] = T * _ - z * p, f[2] = I * _ - $ * p, f[3] = B * _ - J * p, f[8] = x * p + N * _, f[9] = T * p + z * _, f[10] = I * p + $ * _, f[11] = B * p + J * _, f;
        }, l.bz = function(f, c) {
          const u = $e(f, 360), p = $e(c, 360), _ = p - u, x = p > u ? _ - 360 : _ + 360;
          return Math.abs(_) < Math.abs(x) ? _ : x;
        }, l.c = nt, l.c0 = class extends w {
        }, l.c1 = u0, l.c2 = function(f) {
          return f <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(f) / Math.LN2));
        }, l.c3 = zx, l.c4 = function(f, c, u) {
          var p = c[0], _ = c[1], x = c[2], T = u[3] * p + u[7] * _ + u[11] * x + u[15];
          return f[0] = (u[0] * p + u[4] * _ + u[8] * x + u[12]) / (T = T || 1), f[1] = (u[1] * p + u[5] * _ + u[9] * x + u[13]) / T, f[2] = (u[2] * p + u[6] * _ + u[10] * x + u[14]) / T, f;
        }, l.c5 = class extends eu {
        }, l.c6 = class extends G {
        }, l.c7 = function(f, c) {
          return f[0] === c[0] && f[1] === c[1] && f[2] === c[2] && f[3] === c[3] && f[4] === c[4] && f[5] === c[5] && f[6] === c[6] && f[7] === c[7] && f[8] === c[8] && f[9] === c[9] && f[10] === c[10] && f[11] === c[11] && f[12] === c[12] && f[13] === c[13] && f[14] === c[14] && f[15] === c[15];
        }, l.c8 = function(f, c) {
          var u = f[0], p = f[1], _ = f[2], x = f[3], T = f[4], I = f[5], B = f[6], N = f[7], z = f[8], $ = f[9], J = f[10], te = f[11], ne = f[12], ue = f[13], Se = f[14], Ee = f[15], Je = c[0], ze = c[1], ee = c[2], ve = c[3], qe = c[4], _t = c[5], $t = c[6], Rt = c[7], Ot = c[8], Qt = c[9], Wt = c[10], nr = c[11], Ft = c[12], Pr = c[13], jr = c[14], kr = c[15];
          return Math.abs(u - Je) <= K * Math.max(1, Math.abs(u), Math.abs(Je)) && Math.abs(p - ze) <= K * Math.max(1, Math.abs(p), Math.abs(ze)) && Math.abs(_ - ee) <= K * Math.max(1, Math.abs(_), Math.abs(ee)) && Math.abs(x - ve) <= K * Math.max(1, Math.abs(x), Math.abs(ve)) && Math.abs(T - qe) <= K * Math.max(1, Math.abs(T), Math.abs(qe)) && Math.abs(I - _t) <= K * Math.max(1, Math.abs(I), Math.abs(_t)) && Math.abs(B - $t) <= K * Math.max(1, Math.abs(B), Math.abs($t)) && Math.abs(N - Rt) <= K * Math.max(1, Math.abs(N), Math.abs(Rt)) && Math.abs(z - Ot) <= K * Math.max(1, Math.abs(z), Math.abs(Ot)) && Math.abs($ - Qt) <= K * Math.max(1, Math.abs($), Math.abs(Qt)) && Math.abs(J - Wt) <= K * Math.max(1, Math.abs(J), Math.abs(Wt)) && Math.abs(te - nr) <= K * Math.max(1, Math.abs(te), Math.abs(nr)) && Math.abs(ne - Ft) <= K * Math.max(1, Math.abs(ne), Math.abs(Ft)) && Math.abs(ue - Pr) <= K * Math.max(1, Math.abs(ue), Math.abs(Pr)) && Math.abs(Se - jr) <= K * Math.max(1, Math.abs(Se), Math.abs(jr)) && Math.abs(Ee - kr) <= K * Math.max(1, Math.abs(Ee), Math.abs(kr));
        }, l.c9 = function(f, c) {
          return f[0] = c[0], f[1] = c[1], f[2] = c[2], f[3] = c[3], f[4] = c[4], f[5] = c[5], f[6] = c[6], f[7] = c[7], f[8] = c[8], f[9] = c[9], f[10] = c[10], f[11] = c[11], f[12] = c[12], f[13] = c[13], f[14] = c[14], f[15] = c[15], f;
        }, l.cA = function(f) {
          delete oe.REGISTERED_PROTOCOLS[f];
        }, l.cB = function(f, c) {
          const u = {};
          for (let _ = 0; _ < f.length; _++) {
            const x = c && c[f[_].id] || uo(f[_]);
            c && (c[f[_].id] = x);
            let T = u[x];
            T || (T = u[x] = []), T.push(f[_]);
          }
          const p = [];
          for (const _ in u) p.push(u[_]);
          return p;
        }, l.cC = Re, l.cD = Vw, l.cE = qw, l.cF = vw, l.cG = function(f) {
          f.bucket.createArrays(), f.bucket.tilePixelRatio = ce / (512 * f.bucket.overscaling), f.bucket.compareText = {}, f.bucket.iconsNeedLinear = !1;
          const c = f.bucket.layers[0], u = c.layout, p = c._unevaluatedLayout._values, _ = { layoutIconSize: p["icon-size"].possiblyEvaluate(new Br(f.bucket.zoom + 1), f.canonical), layoutTextSize: p["text-size"].possiblyEvaluate(new Br(f.bucket.zoom + 1), f.canonical), textMaxSize: p["text-size"].possiblyEvaluate(new Br(18)) };
          if (f.bucket.textSizeData.kind === "composite") {
            const { minZoom: N, maxZoom: z } = f.bucket.textSizeData;
            _.compositeTextSizes = [p["text-size"].possiblyEvaluate(new Br(N), f.canonical), p["text-size"].possiblyEvaluate(new Br(z), f.canonical)];
          }
          if (f.bucket.iconSizeData.kind === "composite") {
            const { minZoom: N, maxZoom: z } = f.bucket.iconSizeData;
            _.compositeIconSizes = [p["icon-size"].possiblyEvaluate(new Br(N), f.canonical), p["icon-size"].possiblyEvaluate(new Br(z), f.canonical)];
          }
          const x = u.get("text-line-height") * Ls, T = u.get("text-rotation-alignment") !== "viewport" && u.get("symbol-placement") !== "point", I = u.get("text-keep-upright"), B = u.get("text-size");
          for (const N of f.bucket.features) {
            const z = u.get("text-font").evaluate(N, {}, f.canonical).join(","), $ = B.evaluate(N, {}, f.canonical), J = _.layoutTextSize.evaluate(N, {}, f.canonical), te = _.layoutIconSize.evaluate(N, {}, f.canonical), ne = { horizontal: {}, vertical: void 0 }, ue = N.text;
            let Se, Ee = [0, 0];
            if (ue) {
              const ee = ue.toString(), ve = u.get("text-letter-spacing").evaluate(N, {}, f.canonical) * Ls, qe = Zt(ee) ? ve : 0, _t = u.get("text-anchor").evaluate(N, {}, f.canonical), $t = tA(c, N, f.canonical);
              if (!$t) {
                const Wt = u.get("text-radial-offset").evaluate(N, {}, f.canonical);
                Ee = Wt ? eA(_t, [Wt * Ls, D0]) : u.get("text-offset").evaluate(N, {}, f.canonical).map((nr) => nr * Ls);
              }
              let Rt = T ? "center" : u.get("text-justify").evaluate(N, {}, f.canonical);
              const Ot = u.get("symbol-placement") === "point" ? u.get("text-max-width").evaluate(N, {}, f.canonical) * Ls : 1 / 0, Qt = () => {
                f.bucket.allowVerticalPlacement && qt(ee) && (ne.vertical = um(ue, f.glyphMap, f.glyphPositions, f.imagePositions, z, Ot, x, _t, "left", qe, Ee, l.an.vertical, !0, J, $));
              };
              if (!T && $t) {
                const Wt = /* @__PURE__ */ new Set();
                if (Rt === "auto") for (let Ft = 0; Ft < $t.values.length; Ft += 2) Wt.add(F0($t.values[Ft]));
                else Wt.add(Rt);
                let nr = !1;
                for (const Ft of Wt) if (!ne.horizontal[Ft]) if (nr) ne.horizontal[Ft] = ne.horizontal[0];
                else {
                  const Pr = um(ue, f.glyphMap, f.glyphPositions, f.imagePositions, z, Ot, x, "center", Ft, qe, Ee, l.an.horizontal, !1, J, $);
                  Pr && (ne.horizontal[Ft] = Pr, nr = Pr.positionedLines.length === 1);
                }
                Qt();
              } else {
                Rt === "auto" && (Rt = F0(_t));
                const Wt = um(ue, f.glyphMap, f.glyphPositions, f.imagePositions, z, Ot, x, _t, Rt, qe, Ee, l.an.horizontal, !1, J, $);
                Wt && (ne.horizontal[Rt] = Wt), Qt(), qt(ee) && T && I && (ne.vertical = um(ue, f.glyphMap, f.glyphPositions, f.imagePositions, z, Ot, x, _t, Rt, qe, Ee, l.an.vertical, !1, J, $));
              }
            }
            let Je = !1;
            if (N.icon && N.icon.name) {
              const ee = f.imageMap[N.icon.name];
              ee && (Se = PR(f.imagePositions[N.icon.name], u.get("icon-offset").evaluate(N, {}, f.canonical), u.get("icon-anchor").evaluate(N, {}, f.canonical)), Je = !!ee.sdf, f.bucket.sdfIcons === void 0 ? f.bucket.sdfIcons = Je : f.bucket.sdfIcons !== Je && Dr("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (ee.pixelRatio !== f.bucket.pixelRatio || u.get("icon-rotate").constantOr(1) !== 0) && (f.bucket.iconsNeedLinear = !0));
            }
            const ze = nA(ne.horizontal) || ne.vertical;
            f.bucket.iconsInText = !!ze && ze.iconsInText, (ze || Se) && WR(f.bucket, N, ne, Se, f.imageMap, _, J, te, Ee, Je, f.canonical, f.subdivisionGranularity);
          }
          f.showCollisionBoxes && f.bucket.generateCollisionDebugBuffers();
        }, l.cH = w0, l.cI = m0, l.cJ = x0, l.cK = Np, l.cL = S0, l.cM = class {
          constructor(f) {
            this._marks = { start: [f.url, "start"].join("#"), end: [f.url, "end"].join("#"), measure: f.url.toString() }, performance.mark(this._marks.start);
          }
          finish() {
            performance.mark(this._marks.end);
            let f = performance.getEntriesByName(this._marks.measure);
            return f.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), f = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), f;
          }
        }, l.cN = function(f, c, u, p, _) {
          return o(this, void 0, void 0, function* () {
            if (Z()) try {
              return yield Lr(f, c, u, p, _);
            } catch {
            }
            return function(x, T, I, B, N) {
              const z = x.width, $ = x.height;
              qr && Kr || (qr = new OffscreenCanvas(z, $), Kr = qr.getContext("2d", { willReadFrequently: !0 })), qr.width = z, qr.height = $, Kr.drawImage(x, 0, 0, z, $);
              const J = Kr.getImageData(T, I, B, N);
              return Kr.clearRect(0, 0, z, $), J.data;
            }(f, c, u, p, _);
          });
        }, l.cO = $x, l.cP = d, l.cQ = A, l.cR = ow, l.cS = yw, l.cT = fh, l.cU = Cn, l.ca = (f) => f.type === "symbol", l.cb = (f) => f.type === "circle", l.cc = (f) => f.type === "heatmap", l.cd = (f) => f.type === "line", l.ce = (f) => f.type === "fill", l.cf = (f) => f.type === "fill-extrusion", l.cg = (f) => f.type === "hillshade", l.ch = (f) => f.type === "color-relief", l.ci = (f) => f.type === "raster", l.cj = (f) => f.type === "background", l.ck = (f) => f.type === "custom", l.cl = ht, l.cm = function(f, c, u) {
          const p = hr(c.x - u.x, c.y - u.y), _ = hr(f.x - u.x, f.y - u.y);
          var x, T;
          return vn(Math.atan2(p[0] * _[1] - p[1] * _[0], (x = p)[0] * (T = _)[0] + x[1] * T[1]));
        }, l.cn = It, l.co = function(f, c) {
          return fn[c] && (f instanceof MouseEvent || f instanceof WheelEvent);
        }, l.cp = function(f, c) {
          return Hr[c] && "touches" in f;
        }, l.cq = function(f) {
          return Hr[f] || fn[f];
        }, l.cr = function(f, c, u) {
          var p = c[0], _ = c[1];
          return f[0] = u[0] * p + u[4] * _ + u[12], f[1] = u[1] * p + u[5] * _ + u[13], f;
        }, l.cs = function(f, c) {
          const { x: u, y: p } = jp.fromLngLat(c);
          return !(f < 0 || f > 25 || p < 0 || p >= 1 || u < 0 || u >= 1);
        }, l.ct = function(f, c) {
          return f[0] = c[0], f[1] = 0, f[2] = 0, f[3] = 0, f[4] = 0, f[5] = c[1], f[6] = 0, f[7] = 0, f[8] = 0, f[9] = 0, f[10] = c[2], f[11] = 0, f[12] = 0, f[13] = 0, f[14] = 0, f[15] = 1, f;
        }, l.cu = class extends jo {
        }, l.cv = ZR, l.cx = function(f) {
          return f.message === gr;
        }, l.cy = Le, l.cz = function(f, c) {
          oe.REGISTERED_PROTOCOLS[f] = c;
        }, l.d = gt, l.e = Kt, l.f = (f) => o(void 0, void 0, void 0, function* () {
          if (f.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
          const c = new Blob([new Uint8Array(f)], { type: "image/png" });
          try {
            return createImageBitmap(c);
          } catch (u) {
            throw new Error(`Could not load image because of ${u.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
          }
        }), l.g = fe, l.h = (f) => new Promise((c, u) => {
          const p = new Image();
          p.onload = () => {
            c(p), URL.revokeObjectURL(p.src), p.onload = null, window.requestAnimationFrame(() => {
              p.src = _r;
            });
          }, p.onerror = () => u(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const _ = new Blob([new Uint8Array(f)], { type: "image/png" });
          p.src = f.byteLength ? URL.createObjectURL(_) : _r;
        }), l.i = Yt, l.j = (f, c) => Qe(Kt(f, { type: "json" }), c), l.k = st, l.l = Pt, l.m = Qe, l.n = (f, c) => Qe(Kt(f, { type: "arrayBuffer" }), c), l.o = function(f) {
          return new S0(f).readFields(bR, []);
        }, l.p = bw, l.q = Mp, l.r = Ei, l.s = en, l.t = Bi, l.u = Xe, l.v = Ge, l.w = Dr, l.x = W, l.y = _e, l.z = D;
      }), i("worker", ["./shared"], function(l) {
        class o {
          constructor(oe) {
            this.keyCache = {}, oe && this.replace(oe);
          }
          replace(oe) {
            this._layerConfigs = {}, this._layers = {}, this.update(oe, []);
          }
          update(oe, fe) {
            for (const Le of oe) {
              this._layerConfigs[Le.id] = Le;
              const Ye = this._layers[Le.id] = l.bI(Le);
              Ye._featureFilter = l.a9(Ye.filter), this.keyCache[Le.id] && delete this.keyCache[Le.id];
            }
            for (const Le of fe) delete this.keyCache[Le], delete this._layerConfigs[Le], delete this._layers[Le];
            this.familiesBySource = {};
            const ye = l.cB(Object.values(this._layerConfigs), this.keyCache);
            for (const Le of ye) {
              const Ye = Le.map((st) => this._layers[st.id]), Qe = Ye[0];
              if (Qe.visibility === "none") continue;
              const gt = Qe.source || "";
              let Ke = this.familiesBySource[gt];
              Ke || (Ke = this.familiesBySource[gt] = {});
              const Bt = Qe.sourceLayer || "_geojsonTileLayer";
              let Pt = Ke[Bt];
              Pt || (Pt = Ke[Bt] = []), Pt.push(Ye);
            }
          }
        }
        class d {
          constructor(oe) {
            const fe = {}, ye = [];
            for (const gt in oe) {
              const Ke = oe[gt], Bt = fe[gt] = {};
              for (const Pt in Ke) {
                const st = Ke[+Pt];
                if (!st || st.bitmap.width === 0 || st.bitmap.height === 0) continue;
                const ft = { x: 0, y: 0, w: st.bitmap.width + 2, h: st.bitmap.height + 2 };
                ye.push(ft), Bt[Pt] = { rect: ft, metrics: st.metrics };
              }
            }
            const { w: Le, h: Ye } = l.p(ye), Qe = new l.q({ width: Le || 1, height: Ye || 1 });
            for (const gt in oe) {
              const Ke = oe[gt];
              for (const Bt in Ke) {
                const Pt = Ke[+Bt];
                if (!Pt || Pt.bitmap.width === 0 || Pt.bitmap.height === 0) continue;
                const st = fe[gt][Bt].rect;
                l.q.copy(Pt.bitmap, Qe, { x: 0, y: 0 }, { x: st.x + 1, y: st.y + 1 }, Pt.bitmap);
              }
            }
            this.image = Qe, this.positions = fe;
          }
        }
        l.cC("GlyphAtlas", d);
        class m {
          constructor(oe) {
            this.tileID = new l.Z(oe.tileID.overscaledZ, oe.tileID.wrap, oe.tileID.canonical.z, oe.tileID.canonical.x, oe.tileID.canonical.y), this.uid = oe.uid, this.zoom = oe.zoom, this.pixelRatio = oe.pixelRatio, this.tileSize = oe.tileSize, this.source = oe.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = oe.showCollisionBoxes, this.collectResourceTiming = !!oe.collectResourceTiming, this.returnDependencies = !!oe.returnDependencies, this.promoteId = oe.promoteId, this.inFlightDependencies = [], this.globalState = oe.globalState;
          }
          parse(oe, fe, ye, Le, Ye) {
            return l._(this, void 0, void 0, function* () {
              this.status = "parsing", this.data = oe, this.collisionBoxArray = new l.a7();
              const Qe = new l.cD(Object.keys(oe.layers).sort()), gt = new l.cE(this.tileID, this.promoteId);
              gt.bucketLayerIDs = [];
              const Ke = {}, Bt = { featureIndex: gt, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: ye, subdivisionGranularity: Ye }, Pt = fe.familiesBySource[this.source];
              for (const Cr in Pt) {
                const zr = oe.layers[Cr];
                if (!zr) continue;
                zr.version === 1 && l.w(`Vector tile source "${this.source}" layer "${Cr}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const Dn = Qe.encode(Cr), er = [];
                for (let oi = 0; oi < zr.length; oi++) {
                  const Mn = zr.feature(oi), rs = gt.getId(Mn, Cr);
                  er.push({ feature: Mn, id: rs, index: oi, sourceLayerIndex: Dn });
                }
                for (const oi of Pt[Cr]) {
                  const Mn = oi[0];
                  Mn.source !== this.source && l.w(`layer.source = ${Mn.source} does not equal this.source = ${this.source}`), Mn.minzoom && this.zoom < Math.floor(Mn.minzoom) || Mn.maxzoom && this.zoom >= Mn.maxzoom || Mn.visibility !== "none" && (b(oi, this.zoom, ye), (Ke[Mn.id] = Mn.createBucket({ index: gt.bucketLayerIDs.length, layers: oi, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: Dn, sourceID: this.source, globalState: this.globalState })).populate(er, Bt, this.tileID.canonical), gt.bucketLayerIDs.push(oi.map((rs) => rs.id)));
                }
              }
              const st = l.bM(Bt.glyphDependencies, (Cr) => Object.keys(Cr).map(Number));
              this.inFlightDependencies.forEach((Cr) => Cr == null ? void 0 : Cr.abort()), this.inFlightDependencies = [];
              let ft = Promise.resolve({});
              if (Object.keys(st).length) {
                const Cr = new AbortController();
                this.inFlightDependencies.push(Cr), ft = Le.sendAsync({ type: "GG", data: { stacks: st, source: this.source, tileID: this.tileID, type: "glyphs" } }, Cr);
              }
              const Ge = Object.keys(Bt.iconDependencies);
              let ur = Promise.resolve({});
              if (Ge.length) {
                const Cr = new AbortController();
                this.inFlightDependencies.push(Cr), ur = Le.sendAsync({ type: "GI", data: { icons: Ge, source: this.source, tileID: this.tileID, type: "icons" } }, Cr);
              }
              const Sr = Object.keys(Bt.patternDependencies);
              let lr = Promise.resolve({});
              if (Sr.length) {
                const Cr = new AbortController();
                this.inFlightDependencies.push(Cr), lr = Le.sendAsync({ type: "GI", data: { icons: Sr, source: this.source, tileID: this.tileID, type: "patterns" } }, Cr);
              }
              const [Er, tr, xn] = yield Promise.all([ft, ur, lr]), dn = new d(Er), Jr = new l.cF(tr, xn);
              for (const Cr in Ke) {
                const zr = Ke[Cr];
                zr instanceof l.a8 ? (b(zr.layers, this.zoom, ye), l.cG({ bucket: zr, glyphMap: Er, glyphPositions: dn.positions, imageMap: tr, imagePositions: Jr.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical, subdivisionGranularity: Bt.subdivisionGranularity })) : zr.hasPattern && (zr instanceof l.cH || zr instanceof l.cI || zr instanceof l.cJ) && (b(zr.layers, this.zoom, ye), zr.addFeatures(Bt, this.tileID.canonical, Jr.patternPositions));
              }
              return this.status = "done", { buckets: Object.values(Ke).filter((Cr) => !Cr.isEmpty()), featureIndex: gt, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: dn.image, imageAtlas: Jr, glyphMap: this.returnDependencies ? Er : null, iconMap: this.returnDependencies ? tr : null, glyphPositions: this.returnDependencies ? dn.positions : null };
            });
          }
        }
        function b(nt, oe, fe) {
          const ye = new l.F(oe);
          for (const Le of nt) Le.recalculate(ye, fe);
        }
        class A {
          constructor(oe, fe, ye) {
            this.actor = oe, this.layerIndex = fe, this.availableImages = ye, this.fetching = {}, this.loading = {}, this.loaded = {};
          }
          loadVectorTile(oe, fe) {
            return l._(this, void 0, void 0, function* () {
              const ye = yield l.n(oe.request, fe);
              try {
                return { vectorTile: new l.cK.VectorTile(new l.cL(ye.data)), rawData: ye.data, cacheControl: ye.cacheControl, expires: ye.expires };
              } catch (Le) {
                const Ye = new Uint8Array(ye.data);
                let Qe = `Unable to parse the tile at ${oe.request.url}, `;
                throw Qe += Ye[0] === 31 && Ye[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${Le.message}`, new Error(Qe);
              }
            });
          }
          loadTile(oe) {
            return l._(this, void 0, void 0, function* () {
              const fe = oe.uid, ye = !!(oe && oe.request && oe.request.collectResourceTiming) && new l.cM(oe.request), Le = new m(oe);
              this.loading[fe] = Le;
              const Ye = new AbortController();
              Le.abort = Ye;
              try {
                const Qe = yield this.loadVectorTile(oe, Ye);
                if (delete this.loading[fe], !Qe) return null;
                const gt = Qe.rawData, Ke = {};
                Qe.expires && (Ke.expires = Qe.expires), Qe.cacheControl && (Ke.cacheControl = Qe.cacheControl);
                const Bt = {};
                if (ye) {
                  const st = ye.finish();
                  st && (Bt.resourceTiming = JSON.parse(JSON.stringify(st)));
                }
                Le.vectorTile = Qe.vectorTile;
                const Pt = Le.parse(Qe.vectorTile, this.layerIndex, this.availableImages, this.actor, oe.subdivisionGranularity);
                this.loaded[fe] = Le, this.fetching[fe] = { rawTileData: gt, cacheControl: Ke, resourceTiming: Bt };
                try {
                  const st = yield Pt;
                  return l.e({ rawTileData: gt.slice(0) }, st, Ke, Bt);
                } finally {
                  delete this.fetching[fe];
                }
              } catch (Qe) {
                throw delete this.loading[fe], Le.status = "done", this.loaded[fe] = Le, Qe;
              }
            });
          }
          reloadTile(oe) {
            return l._(this, void 0, void 0, function* () {
              const fe = oe.uid;
              if (!this.loaded || !this.loaded[fe]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const ye = this.loaded[fe];
              if (ye.showCollisionBoxes = oe.showCollisionBoxes, ye.globalState = oe.globalState, ye.status === "parsing") {
                const Le = yield ye.parse(ye.vectorTile, this.layerIndex, this.availableImages, this.actor, oe.subdivisionGranularity);
                let Ye;
                if (this.fetching[fe]) {
                  const { rawTileData: Qe, cacheControl: gt, resourceTiming: Ke } = this.fetching[fe];
                  delete this.fetching[fe], Ye = l.e({ rawTileData: Qe.slice(0) }, Le, gt, Ke);
                } else Ye = Le;
                return Ye;
              }
              if (ye.status === "done" && ye.vectorTile) return ye.parse(ye.vectorTile, this.layerIndex, this.availableImages, this.actor, oe.subdivisionGranularity);
            });
          }
          abortTile(oe) {
            return l._(this, void 0, void 0, function* () {
              const fe = this.loading, ye = oe.uid;
              fe && fe[ye] && fe[ye].abort && (fe[ye].abort.abort(), delete fe[ye]);
            });
          }
          removeTile(oe) {
            return l._(this, void 0, void 0, function* () {
              this.loaded && this.loaded[oe.uid] && delete this.loaded[oe.uid];
            });
          }
        }
        class M {
          constructor() {
            this.loaded = {};
          }
          loadTile(oe) {
            return l._(this, void 0, void 0, function* () {
              const { uid: fe, encoding: ye, rawImageData: Le, redFactor: Ye, greenFactor: Qe, blueFactor: gt, baseShift: Ke } = oe, Bt = Le.width + 2, Pt = Le.height + 2, st = l.b(Le) ? new l.R({ width: Bt, height: Pt }, yield l.cN(Le, -1, -1, Bt, Pt)) : Le, ft = new l.cO(fe, st, ye, Ye, Qe, gt, Ke);
              return this.loaded = this.loaded || {}, this.loaded[fe] = ft, ft;
            });
          }
          removeTile(oe) {
            const fe = this.loaded, ye = oe.uid;
            fe && fe[ye] && delete fe[ye];
          }
        }
        var E, k, U = function() {
          if (k) return E;
          function nt(fe, ye) {
            if (fe.length !== 0) {
              oe(fe[0], ye);
              for (var Le = 1; Le < fe.length; Le++) oe(fe[Le], !ye);
            }
          }
          function oe(fe, ye) {
            for (var Le = 0, Ye = 0, Qe = 0, gt = fe.length, Ke = gt - 1; Qe < gt; Ke = Qe++) {
              var Bt = (fe[Qe][0] - fe[Ke][0]) * (fe[Ke][1] + fe[Qe][1]), Pt = Le + Bt;
              Ye += Math.abs(Le) >= Math.abs(Bt) ? Le - Pt + Bt : Bt - Pt + Le, Le = Pt;
            }
            Le + Ye >= 0 != !!ye && fe.reverse();
          }
          return k = 1, E = function fe(ye, Le) {
            var Ye, Qe = ye && ye.type;
            if (Qe === "FeatureCollection") for (Ye = 0; Ye < ye.features.length; Ye++) fe(ye.features[Ye], Le);
            else if (Qe === "GeometryCollection") for (Ye = 0; Ye < ye.geometries.length; Ye++) fe(ye.geometries[Ye], Le);
            else if (Qe === "Feature") fe(ye.geometry, Le);
            else if (Qe === "Polygon") nt(ye.coordinates, Le);
            else if (Qe === "MultiPolygon") for (Ye = 0; Ye < ye.coordinates.length; Ye++) nt(ye.coordinates[Ye], Le);
            return ye;
          };
        }(), V = l.cP(U);
        const q = l.cK.VectorTileFeature.prototype.toGeoJSON;
        class Y {
          constructor(oe) {
            this._feature = oe, this.extent = l.$, this.type = oe.type, this.properties = oe.tags, "id" in oe && !isNaN(oe.id) && (this.id = parseInt(oe.id, 10));
          }
          loadGeometry() {
            if (this._feature.type === 1) {
              const oe = [];
              for (const fe of this._feature.geometry) oe.push([new l.P(fe[0], fe[1])]);
              return oe;
            }
            {
              const oe = [];
              for (const fe of this._feature.geometry) {
                const ye = [];
                for (const Le of fe) ye.push(new l.P(Le[0], Le[1]));
                oe.push(ye);
              }
              return oe;
            }
          }
          toGeoJSON(oe, fe, ye) {
            return q.call(this, oe, fe, ye);
          }
        }
        class re {
          constructor(oe) {
            this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = l.$, this.length = oe.length, this._features = oe;
          }
          feature(oe) {
            return new Y(this._features[oe]);
          }
        }
        var Z, K, ie, be = { exports: {} }, he = function() {
          if (ie) return be.exports;
          ie = 1;
          var nt = l.cS(), oe = function() {
            if (K) return Z;
            K = 1;
            var Pt = l.cQ(), st = l.cR().VectorTileFeature;
            function ft(ur, Sr) {
              this.options = Sr || {}, this.features = ur, this.length = ur.length;
            }
            function Ge(ur, Sr) {
              this.id = typeof ur.id == "number" ? ur.id : void 0, this.type = ur.type, this.rawGeometry = ur.type === 1 ? [ur.geometry] : ur.geometry, this.properties = ur.tags, this.extent = Sr || 4096;
            }
            return Z = ft, ft.prototype.feature = function(ur) {
              return new Ge(this.features[ur], this.options.extent);
            }, Ge.prototype.loadGeometry = function() {
              var ur = this.rawGeometry;
              this.geometry = [];
              for (var Sr = 0; Sr < ur.length; Sr++) {
                for (var lr = ur[Sr], Er = [], tr = 0; tr < lr.length; tr++) Er.push(new Pt(lr[tr][0], lr[tr][1]));
                this.geometry.push(Er);
              }
              return this.geometry;
            }, Ge.prototype.bbox = function() {
              this.geometry || this.loadGeometry();
              for (var ur = this.geometry, Sr = 1 / 0, lr = -1 / 0, Er = 1 / 0, tr = -1 / 0, xn = 0; xn < ur.length; xn++) for (var dn = ur[xn], Jr = 0; Jr < dn.length; Jr++) {
                var Cr = dn[Jr];
                Sr = Math.min(Sr, Cr.x), lr = Math.max(lr, Cr.x), Er = Math.min(Er, Cr.y), tr = Math.max(tr, Cr.y);
              }
              return [Sr, Er, lr, tr];
            }, Ge.prototype.toGeoJSON = st.prototype.toGeoJSON, Z;
          }();
          function fe(Pt) {
            var st = new nt();
            return function(ft, Ge) {
              for (var ur in ft.layers) Ge.writeMessage(3, ye, ft.layers[ur]);
            }(Pt, st), st.finish();
          }
          function ye(Pt, st) {
            var ft;
            st.writeVarintField(15, Pt.version || 1), st.writeStringField(1, Pt.name || ""), st.writeVarintField(5, Pt.extent || 4096);
            var Ge = { keys: [], values: [], keycache: {}, valuecache: {} };
            for (ft = 0; ft < Pt.length; ft++) Ge.feature = Pt.feature(ft), st.writeMessage(2, Le, Ge);
            var ur = Ge.keys;
            for (ft = 0; ft < ur.length; ft++) st.writeStringField(3, ur[ft]);
            var Sr = Ge.values;
            for (ft = 0; ft < Sr.length; ft++) st.writeMessage(4, Bt, Sr[ft]);
          }
          function Le(Pt, st) {
            var ft = Pt.feature;
            ft.id !== void 0 && st.writeVarintField(1, ft.id), st.writeMessage(2, Ye, Pt), st.writeVarintField(3, ft.type), st.writeMessage(4, Ke, ft);
          }
          function Ye(Pt, st) {
            var ft = Pt.feature, Ge = Pt.keys, ur = Pt.values, Sr = Pt.keycache, lr = Pt.valuecache;
            for (var Er in ft.properties) {
              var tr = ft.properties[Er], xn = Sr[Er];
              if (tr !== null) {
                xn === void 0 && (Ge.push(Er), Sr[Er] = xn = Ge.length - 1), st.writeVarint(xn);
                var dn = typeof tr;
                dn !== "string" && dn !== "boolean" && dn !== "number" && (tr = JSON.stringify(tr));
                var Jr = dn + ":" + tr, Cr = lr[Jr];
                Cr === void 0 && (ur.push(tr), lr[Jr] = Cr = ur.length - 1), st.writeVarint(Cr);
              }
            }
          }
          function Qe(Pt, st) {
            return (st << 3) + (7 & Pt);
          }
          function gt(Pt) {
            return Pt << 1 ^ Pt >> 31;
          }
          function Ke(Pt, st) {
            for (var ft = Pt.loadGeometry(), Ge = Pt.type, ur = 0, Sr = 0, lr = ft.length, Er = 0; Er < lr; Er++) {
              var tr = ft[Er], xn = 1;
              Ge === 1 && (xn = tr.length), st.writeVarint(Qe(1, xn));
              for (var dn = Ge === 3 ? tr.length - 1 : tr.length, Jr = 0; Jr < dn; Jr++) {
                Jr === 1 && Ge !== 1 && st.writeVarint(Qe(2, dn - 1));
                var Cr = tr[Jr].x - ur, zr = tr[Jr].y - Sr;
                st.writeVarint(gt(Cr)), st.writeVarint(gt(zr)), ur += Cr, Sr += zr;
              }
              Ge === 3 && st.writeVarint(Qe(7, 1));
            }
          }
          function Bt(Pt, st) {
            var ft = typeof Pt;
            ft === "string" ? st.writeStringField(1, Pt) : ft === "boolean" ? st.writeBooleanField(7, Pt) : ft === "number" && (Pt % 1 != 0 ? st.writeDoubleField(3, Pt) : Pt < 0 ? st.writeSVarintField(6, Pt) : st.writeVarintField(5, Pt));
          }
          return be.exports = fe, be.exports.fromVectorTileJs = fe, be.exports.fromGeojsonVt = function(Pt, st) {
            st = st || {};
            var ft = {};
            for (var Ge in Pt) ft[Ge] = new oe(Pt[Ge].features, st), ft[Ge].name = Ge, ft[Ge].version = st.version, ft[Ge].extent = st.extent;
            return fe({ layers: ft });
          }, be.exports.GeoJSONWrapper = oe, be.exports;
        }(), Be = l.cP(he);
        const ke = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: (nt) => nt }, pe = Math.fround || (me = new Float32Array(1), (nt) => (me[0] = +nt, me[0]));
        var me;
        class je {
          constructor(oe) {
            this.options = Object.assign(Object.create(ke), oe), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(oe) {
            const { log: fe, minZoom: ye, maxZoom: Le } = this.options;
            fe && console.time("total time");
            const Ye = `prepare ${oe.length} points`;
            fe && console.time(Ye), this.points = oe;
            const Qe = [];
            for (let Ke = 0; Ke < oe.length; Ke++) {
              const Bt = oe[Ke];
              if (!Bt.geometry) continue;
              const [Pt, st] = Bt.geometry.coordinates, ft = pe(Mt(Pt)), Ge = pe(Lt(st));
              Qe.push(ft, Ge, 1 / 0, Ke, -1, 1), this.options.reduce && Qe.push(0);
            }
            let gt = this.trees[Le + 1] = this._createTree(Qe);
            fe && console.timeEnd(Ye);
            for (let Ke = Le; Ke >= ye; Ke--) {
              const Bt = +Date.now();
              gt = this.trees[Ke] = this._createTree(this._cluster(gt, Ke)), fe && console.log("z%d: %d clusters in %dms", Ke, gt.numItems, +Date.now() - Bt);
            }
            return fe && console.timeEnd("total time"), this;
          }
          getClusters(oe, fe) {
            let ye = ((oe[0] + 180) % 360 + 360) % 360 - 180;
            const Le = Math.max(-90, Math.min(90, oe[1]));
            let Ye = oe[2] === 180 ? 180 : ((oe[2] + 180) % 360 + 360) % 360 - 180;
            const Qe = Math.max(-90, Math.min(90, oe[3]));
            if (oe[2] - oe[0] >= 360) ye = -180, Ye = 180;
            else if (ye > Ye) {
              const st = this.getClusters([ye, Le, 180, Qe], fe), ft = this.getClusters([-180, Le, Ye, Qe], fe);
              return st.concat(ft);
            }
            const gt = this.trees[this._limitZoom(fe)], Ke = gt.range(Mt(ye), Lt(Qe), Mt(Ye), Lt(Le)), Bt = gt.data, Pt = [];
            for (const st of Ke) {
              const ft = this.stride * st;
              Pt.push(Bt[ft + 5] > 1 ? Pe(Bt, ft, this.clusterProps) : this.points[Bt[ft + 3]]);
            }
            return Pt;
          }
          getChildren(oe) {
            const fe = this._getOriginId(oe), ye = this._getOriginZoom(oe), Le = "No cluster with the specified id.", Ye = this.trees[ye];
            if (!Ye) throw new Error(Le);
            const Qe = Ye.data;
            if (fe * this.stride >= Qe.length) throw new Error(Le);
            const gt = this.options.radius / (this.options.extent * Math.pow(2, ye - 1)), Ke = Ye.within(Qe[fe * this.stride], Qe[fe * this.stride + 1], gt), Bt = [];
            for (const Pt of Ke) {
              const st = Pt * this.stride;
              Qe[st + 4] === oe && Bt.push(Qe[st + 5] > 1 ? Pe(Qe, st, this.clusterProps) : this.points[Qe[st + 3]]);
            }
            if (Bt.length === 0) throw new Error(Le);
            return Bt;
          }
          getLeaves(oe, fe, ye) {
            const Le = [];
            return this._appendLeaves(Le, oe, fe = fe || 10, ye = ye || 0, 0), Le;
          }
          getTile(oe, fe, ye) {
            const Le = this.trees[this._limitZoom(oe)], Ye = Math.pow(2, oe), { extent: Qe, radius: gt } = this.options, Ke = gt / Qe, Bt = (ye - Ke) / Ye, Pt = (ye + 1 + Ke) / Ye, st = { features: [] };
            return this._addTileFeatures(Le.range((fe - Ke) / Ye, Bt, (fe + 1 + Ke) / Ye, Pt), Le.data, fe, ye, Ye, st), fe === 0 && this._addTileFeatures(Le.range(1 - Ke / Ye, Bt, 1, Pt), Le.data, Ye, ye, Ye, st), fe === Ye - 1 && this._addTileFeatures(Le.range(0, Bt, Ke / Ye, Pt), Le.data, -1, ye, Ye, st), st.features.length ? st : null;
          }
          getClusterExpansionZoom(oe) {
            let fe = this._getOriginZoom(oe) - 1;
            for (; fe <= this.options.maxZoom; ) {
              const ye = this.getChildren(oe);
              if (fe++, ye.length !== 1) break;
              oe = ye[0].properties.cluster_id;
            }
            return fe;
          }
          _appendLeaves(oe, fe, ye, Le, Ye) {
            const Qe = this.getChildren(fe);
            for (const gt of Qe) {
              const Ke = gt.properties;
              if (Ke && Ke.cluster ? Ye + Ke.point_count <= Le ? Ye += Ke.point_count : Ye = this._appendLeaves(oe, Ke.cluster_id, ye, Le, Ye) : Ye < Le ? Ye++ : oe.push(gt), oe.length === ye) break;
            }
            return Ye;
          }
          _createTree(oe) {
            const fe = new l.aH(oe.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let ye = 0; ye < oe.length; ye += this.stride) fe.add(oe[ye], oe[ye + 1]);
            return fe.finish(), fe.data = oe, fe;
          }
          _addTileFeatures(oe, fe, ye, Le, Ye, Qe) {
            for (const gt of oe) {
              const Ke = gt * this.stride, Bt = fe[Ke + 5] > 1;
              let Pt, st, ft;
              if (Bt) Pt = St(fe, Ke, this.clusterProps), st = fe[Ke], ft = fe[Ke + 1];
              else {
                const Sr = this.points[fe[Ke + 3]];
                Pt = Sr.properties;
                const [lr, Er] = Sr.geometry.coordinates;
                st = Mt(lr), ft = Lt(Er);
              }
              const Ge = { type: 1, geometry: [[Math.round(this.options.extent * (st * Ye - ye)), Math.round(this.options.extent * (ft * Ye - Le))]], tags: Pt };
              let ur;
              ur = Bt || this.options.generateId ? fe[Ke + 3] : this.points[fe[Ke + 3]].id, ur !== void 0 && (Ge.id = ur), Qe.features.push(Ge);
            }
          }
          _limitZoom(oe) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+oe), this.options.maxZoom + 1));
          }
          _cluster(oe, fe) {
            const { radius: ye, extent: Le, reduce: Ye, minPoints: Qe } = this.options, gt = ye / (Le * Math.pow(2, fe)), Ke = oe.data, Bt = [], Pt = this.stride;
            for (let st = 0; st < Ke.length; st += Pt) {
              if (Ke[st + 2] <= fe) continue;
              Ke[st + 2] = fe;
              const ft = Ke[st], Ge = Ke[st + 1], ur = oe.within(Ke[st], Ke[st + 1], gt), Sr = Ke[st + 5];
              let lr = Sr;
              for (const Er of ur) {
                const tr = Er * Pt;
                Ke[tr + 2] > fe && (lr += Ke[tr + 5]);
              }
              if (lr > Sr && lr >= Qe) {
                let Er, tr = ft * Sr, xn = Ge * Sr, dn = -1;
                const Jr = (st / Pt << 5) + (fe + 1) + this.points.length;
                for (const Cr of ur) {
                  const zr = Cr * Pt;
                  if (Ke[zr + 2] <= fe) continue;
                  Ke[zr + 2] = fe;
                  const Dn = Ke[zr + 5];
                  tr += Ke[zr] * Dn, xn += Ke[zr + 1] * Dn, Ke[zr + 4] = Jr, Ye && (Er || (Er = this._map(Ke, st, !0), dn = this.clusterProps.length, this.clusterProps.push(Er)), Ye(Er, this._map(Ke, zr)));
                }
                Ke[st + 4] = Jr, Bt.push(tr / lr, xn / lr, 1 / 0, Jr, -1, lr), Ye && Bt.push(dn);
              } else {
                for (let Er = 0; Er < Pt; Er++) Bt.push(Ke[st + Er]);
                if (lr > 1) for (const Er of ur) {
                  const tr = Er * Pt;
                  if (!(Ke[tr + 2] <= fe)) {
                    Ke[tr + 2] = fe;
                    for (let xn = 0; xn < Pt; xn++) Bt.push(Ke[tr + xn]);
                  }
                }
              }
            }
            return Bt;
          }
          _getOriginId(oe) {
            return oe - this.points.length >> 5;
          }
          _getOriginZoom(oe) {
            return (oe - this.points.length) % 32;
          }
          _map(oe, fe, ye) {
            if (oe[fe + 5] > 1) {
              const Qe = this.clusterProps[oe[fe + 6]];
              return ye ? Object.assign({}, Qe) : Qe;
            }
            const Le = this.points[oe[fe + 3]].properties, Ye = this.options.map(Le);
            return ye && Ye === Le ? Object.assign({}, Ye) : Ye;
          }
        }
        function Pe(nt, oe, fe) {
          return { type: "Feature", id: nt[oe + 3], properties: St(nt, oe, fe), geometry: { type: "Point", coordinates: [(ye = nt[oe], 360 * (ye - 0.5)), xt(nt[oe + 1])] } };
          var ye;
        }
        function St(nt, oe, fe) {
          const ye = nt[oe + 5], Le = ye >= 1e4 ? `${Math.round(ye / 1e3)}k` : ye >= 1e3 ? Math.round(ye / 100) / 10 + "k" : ye, Ye = nt[oe + 6], Qe = Ye === -1 ? {} : Object.assign({}, fe[Ye]);
          return Object.assign(Qe, { cluster: !0, cluster_id: nt[oe + 3], point_count: ye, point_count_abbreviated: Le });
        }
        function Mt(nt) {
          return nt / 360 + 0.5;
        }
        function Lt(nt) {
          const oe = Math.sin(nt * Math.PI / 180), fe = 0.5 - 0.25 * Math.log((1 + oe) / (1 - oe)) / Math.PI;
          return fe < 0 ? 0 : fe > 1 ? 1 : fe;
        }
        function xt(nt) {
          const oe = (180 - 360 * nt) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(oe)) / Math.PI - 90;
        }
        function zt(nt, oe, fe, ye) {
          let Le = ye;
          const Ye = oe + (fe - oe >> 1);
          let Qe, gt = fe - oe;
          const Ke = nt[oe], Bt = nt[oe + 1], Pt = nt[fe], st = nt[fe + 1];
          for (let ft = oe + 3; ft < fe; ft += 3) {
            const Ge = Dt(nt[ft], nt[ft + 1], Ke, Bt, Pt, st);
            if (Ge > Le) Qe = ft, Le = Ge;
            else if (Ge === Le) {
              const ur = Math.abs(ft - Ye);
              ur < gt && (Qe = ft, gt = ur);
            }
          }
          Le > ye && (Qe - oe > 3 && zt(nt, oe, Qe, ye), nt[Qe + 2] = Le, fe - Qe > 3 && zt(nt, Qe, fe, ye));
        }
        function Dt(nt, oe, fe, ye, Le, Ye) {
          let Qe = Le - fe, gt = Ye - ye;
          if (Qe !== 0 || gt !== 0) {
            const Ke = ((nt - fe) * Qe + (oe - ye) * gt) / (Qe * Qe + gt * gt);
            Ke > 1 ? (fe = Le, ye = Ye) : Ke > 0 && (fe += Qe * Ke, ye += gt * Ke);
          }
          return Qe = nt - fe, gt = oe - ye, Qe * Qe + gt * gt;
        }
        function hr(nt, oe, fe, ye) {
          const Le = { id: nt ?? null, type: oe, geometry: fe, tags: ye, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          if (oe === "Point" || oe === "MultiPoint" || oe === "LineString") ce(Le, fe);
          else if (oe === "Polygon") ce(Le, fe[0]);
          else if (oe === "MultiLineString") for (const Ye of fe) ce(Le, Ye);
          else if (oe === "MultiPolygon") for (const Ye of fe) ce(Le, Ye[0]);
          return Le;
        }
        function ce(nt, oe) {
          for (let fe = 0; fe < oe.length; fe += 3) nt.minX = Math.min(nt.minX, oe[fe]), nt.minY = Math.min(nt.minY, oe[fe + 1]), nt.maxX = Math.max(nt.maxX, oe[fe]), nt.maxY = Math.max(nt.maxY, oe[fe + 1]);
        }
        function Oe(nt, oe, fe, ye) {
          if (!oe.geometry) return;
          const Le = oe.geometry.coordinates;
          if (Le && Le.length === 0) return;
          const Ye = oe.geometry.type, Qe = Math.pow(fe.tolerance / ((1 << fe.maxZoom) * fe.extent), 2);
          let gt = [], Ke = oe.id;
          if (fe.promoteId ? Ke = oe.properties[fe.promoteId] : fe.generateId && (Ke = ye || 0), Ye === "Point") $e(Le, gt);
          else if (Ye === "MultiPoint") for (const Bt of Le) $e(Bt, gt);
          else if (Ye === "LineString") et(Le, gt, Qe, !1);
          else if (Ye === "MultiLineString") {
            if (fe.lineMetrics) {
              for (const Bt of Le) gt = [], et(Bt, gt, Qe, !1), nt.push(hr(Ke, "LineString", gt, oe.properties));
              return;
            }
            ot(Le, gt, Qe, !1);
          } else if (Ye === "Polygon") ot(Le, gt, Qe, !0);
          else {
            if (Ye !== "MultiPolygon") {
              if (Ye === "GeometryCollection") {
                for (const Bt of oe.geometry.geometries) Oe(nt, { id: Ke, geometry: Bt, properties: oe.properties }, fe, ye);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (const Bt of Le) {
              const Pt = [];
              ot(Bt, Pt, Qe, !0), gt.push(Pt);
            }
          }
          nt.push(hr(Ke, Ye, gt, oe.properties));
        }
        function $e(nt, oe) {
          oe.push(ht(nt[0]), It(nt[1]), 0);
        }
        function et(nt, oe, fe, ye) {
          let Le, Ye, Qe = 0;
          for (let Ke = 0; Ke < nt.length; Ke++) {
            const Bt = ht(nt[Ke][0]), Pt = It(nt[Ke][1]);
            oe.push(Bt, Pt, 0), Ke > 0 && (Qe += ye ? (Le * Pt - Bt * Ye) / 2 : Math.sqrt(Math.pow(Bt - Le, 2) + Math.pow(Pt - Ye, 2))), Le = Bt, Ye = Pt;
          }
          const gt = oe.length - 3;
          oe[2] = 1, zt(oe, 0, gt, fe), oe[gt + 2] = 1, oe.size = Math.abs(Qe), oe.start = 0, oe.end = oe.size;
        }
        function ot(nt, oe, fe, ye) {
          for (let Le = 0; Le < nt.length; Le++) {
            const Ye = [];
            et(nt[Le], Ye, fe, ye), oe.push(Ye);
          }
        }
        function ht(nt) {
          return nt / 360 + 0.5;
        }
        function It(nt) {
          const oe = Math.sin(nt * Math.PI / 180), fe = 0.5 - 0.25 * Math.log((1 + oe) / (1 - oe)) / Math.PI;
          return fe < 0 ? 0 : fe > 1 ? 1 : fe;
        }
        function yt(nt, oe, fe, ye, Le, Ye, Qe, gt) {
          if (ye /= oe, Ye >= (fe /= oe) && Qe < ye) return nt;
          if (Qe < fe || Ye >= ye) return null;
          const Ke = [];
          for (const Bt of nt) {
            const Pt = Bt.geometry;
            let st = Bt.type;
            const ft = Le === 0 ? Bt.minX : Bt.minY, Ge = Le === 0 ? Bt.maxX : Bt.maxY;
            if (ft >= fe && Ge < ye) {
              Ke.push(Bt);
              continue;
            }
            if (Ge < fe || ft >= ye) continue;
            let ur = [];
            if (st === "Point" || st === "MultiPoint") ar(Pt, ur, fe, ye, Le);
            else if (st === "LineString") Kt(Pt, ur, fe, ye, Le, !1, gt.lineMetrics);
            else if (st === "MultiLineString") sr(Pt, ur, fe, ye, Le, !1);
            else if (st === "Polygon") sr(Pt, ur, fe, ye, Le, !0);
            else if (st === "MultiPolygon") for (const Sr of Pt) {
              const lr = [];
              sr(Sr, lr, fe, ye, Le, !0), lr.length && ur.push(lr);
            }
            if (ur.length) {
              if (gt.lineMetrics && st === "LineString") {
                for (const Sr of ur) Ke.push(hr(Bt.id, st, Sr, Bt.tags));
                continue;
              }
              st !== "LineString" && st !== "MultiLineString" || (ur.length === 1 ? (st = "LineString", ur = ur[0]) : st = "MultiLineString"), st !== "Point" && st !== "MultiPoint" || (st = ur.length === 3 ? "Point" : "MultiPoint"), Ke.push(hr(Bt.id, st, ur, Bt.tags));
            }
          }
          return Ke.length ? Ke : null;
        }
        function ar(nt, oe, fe, ye, Le) {
          for (let Ye = 0; Ye < nt.length; Ye += 3) {
            const Qe = nt[Ye + Le];
            Qe >= fe && Qe <= ye && Ur(oe, nt[Ye], nt[Ye + 1], nt[Ye + 2]);
          }
        }
        function Kt(nt, oe, fe, ye, Le, Ye, Qe) {
          let gt = vr(nt);
          const Ke = Le === 0 ? Nt : We;
          let Bt, Pt, st = nt.start;
          for (let lr = 0; lr < nt.length - 3; lr += 3) {
            const Er = nt[lr], tr = nt[lr + 1], xn = nt[lr + 2], dn = nt[lr + 3], Jr = nt[lr + 4], Cr = Le === 0 ? Er : tr, zr = Le === 0 ? dn : Jr;
            let Dn = !1;
            Qe && (Bt = Math.sqrt(Math.pow(Er - dn, 2) + Math.pow(tr - Jr, 2))), Cr < fe ? zr > fe && (Pt = Ke(gt, Er, tr, dn, Jr, fe), Qe && (gt.start = st + Bt * Pt)) : Cr > ye ? zr < ye && (Pt = Ke(gt, Er, tr, dn, Jr, ye), Qe && (gt.start = st + Bt * Pt)) : Ur(gt, Er, tr, xn), zr < fe && Cr >= fe && (Pt = Ke(gt, Er, tr, dn, Jr, fe), Dn = !0), zr > ye && Cr <= ye && (Pt = Ke(gt, Er, tr, dn, Jr, ye), Dn = !0), !Ye && Dn && (Qe && (gt.end = st + Bt * Pt), oe.push(gt), gt = vr(nt)), Qe && (st += Bt);
          }
          let ft = nt.length - 3;
          const Ge = nt[ft], ur = nt[ft + 1], Sr = Le === 0 ? Ge : ur;
          Sr >= fe && Sr <= ye && Ur(gt, Ge, ur, nt[ft + 2]), ft = gt.length - 3, Ye && ft >= 3 && (gt[ft] !== gt[0] || gt[ft + 1] !== gt[1]) && Ur(gt, gt[0], gt[1], gt[2]), gt.length && oe.push(gt);
        }
        function vr(nt) {
          const oe = [];
          return oe.size = nt.size, oe.start = nt.start, oe.end = nt.end, oe;
        }
        function sr(nt, oe, fe, ye, Le, Ye) {
          for (const Qe of nt) Kt(Qe, oe, fe, ye, Le, Ye, !1);
        }
        function Ur(nt, oe, fe, ye) {
          nt.push(oe, fe, ye);
        }
        function Nt(nt, oe, fe, ye, Le, Ye) {
          const Qe = (Ye - oe) / (ye - oe);
          return Ur(nt, Ye, fe + (Le - fe) * Qe, 1), Qe;
        }
        function We(nt, oe, fe, ye, Le, Ye) {
          const Qe = (Ye - fe) / (Le - fe);
          return Ur(nt, oe + (ye - oe) * Qe, Ye, 1), Qe;
        }
        function Dr(nt, oe) {
          const fe = [];
          for (let ye = 0; ye < nt.length; ye++) {
            const Le = nt[ye], Ye = Le.type;
            let Qe;
            if (Ye === "Point" || Ye === "MultiPoint" || Ye === "LineString") Qe = Tr(Le.geometry, oe);
            else if (Ye === "MultiLineString" || Ye === "Polygon") {
              Qe = [];
              for (const gt of Le.geometry) Qe.push(Tr(gt, oe));
            } else if (Ye === "MultiPolygon") {
              Qe = [];
              for (const gt of Le.geometry) {
                const Ke = [];
                for (const Bt of gt) Ke.push(Tr(Bt, oe));
                Qe.push(Ke);
              }
            }
            fe.push(hr(Le.id, Ye, Qe, Le.tags));
          }
          return fe;
        }
        function Tr(nt, oe) {
          const fe = [];
          fe.size = nt.size, nt.start !== void 0 && (fe.start = nt.start, fe.end = nt.end);
          for (let ye = 0; ye < nt.length; ye += 3) fe.push(nt[ye] + oe, nt[ye + 1], nt[ye + 2]);
          return fe;
        }
        function Yt(nt, oe) {
          if (nt.transformed) return nt;
          const fe = 1 << nt.z, ye = nt.x, Le = nt.y;
          for (const Ye of nt.features) {
            const Qe = Ye.geometry, gt = Ye.type;
            if (Ye.geometry = [], gt === 1) for (let Ke = 0; Ke < Qe.length; Ke += 2) Ye.geometry.push(pr(Qe[Ke], Qe[Ke + 1], oe, fe, ye, Le));
            else for (let Ke = 0; Ke < Qe.length; Ke++) {
              const Bt = [];
              for (let Pt = 0; Pt < Qe[Ke].length; Pt += 2) Bt.push(pr(Qe[Ke][Pt], Qe[Ke][Pt + 1], oe, fe, ye, Le));
              Ye.geometry.push(Bt);
            }
          }
          return nt.transformed = !0, nt;
        }
        function pr(nt, oe, fe, ye, Le, Ye) {
          return [Math.round(fe * (nt * ye - Le)), Math.round(fe * (oe * ye - Ye))];
        }
        function mr(nt, oe, fe, ye, Le) {
          const Ye = oe === Le.maxZoom ? 0 : Le.tolerance / ((1 << oe) * Le.extent), Qe = { features: [], numPoints: 0, numSimplified: 0, numFeatures: nt.length, source: null, x: fe, y: ye, z: oe, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 };
          for (const gt of nt) _r(Qe, gt, Ye, Le);
          return Qe;
        }
        function _r(nt, oe, fe, ye) {
          const Le = oe.geometry, Ye = oe.type, Qe = [];
          if (nt.minX = Math.min(nt.minX, oe.minX), nt.minY = Math.min(nt.minY, oe.minY), nt.maxX = Math.max(nt.maxX, oe.maxX), nt.maxY = Math.max(nt.maxY, oe.maxY), Ye === "Point" || Ye === "MultiPoint") for (let gt = 0; gt < Le.length; gt += 3) Qe.push(Le[gt], Le[gt + 1]), nt.numPoints++, nt.numSimplified++;
          else if (Ye === "LineString") Lr(Qe, Le, nt, fe, !1, !1);
          else if (Ye === "MultiLineString" || Ye === "Polygon") for (let gt = 0; gt < Le.length; gt++) Lr(Qe, Le[gt], nt, fe, Ye === "Polygon", gt === 0);
          else if (Ye === "MultiPolygon") for (let gt = 0; gt < Le.length; gt++) {
            const Ke = Le[gt];
            for (let Bt = 0; Bt < Ke.length; Bt++) Lr(Qe, Ke[Bt], nt, fe, !0, Bt === 0);
          }
          if (Qe.length) {
            let gt = oe.tags || null;
            if (Ye === "LineString" && ye.lineMetrics) {
              gt = {};
              for (const Bt in oe.tags) gt[Bt] = oe.tags[Bt];
              gt.mapbox_clip_start = Le.start / Le.size, gt.mapbox_clip_end = Le.end / Le.size;
            }
            const Ke = { geometry: Qe, type: Ye === "Polygon" || Ye === "MultiPolygon" ? 3 : Ye === "LineString" || Ye === "MultiLineString" ? 2 : 1, tags: gt };
            oe.id !== null && (Ke.id = oe.id), nt.features.push(Ke);
          }
        }
        function Lr(nt, oe, fe, ye, Le, Ye) {
          const Qe = ye * ye;
          if (ye > 0 && oe.size < (Le ? Qe : ye)) return void (fe.numPoints += oe.length / 3);
          const gt = [];
          for (let Ke = 0; Ke < oe.length; Ke += 3) (ye === 0 || oe[Ke + 2] > Qe) && (fe.numSimplified++, gt.push(oe[Ke], oe[Ke + 1])), fe.numPoints++;
          Le && function(Ke, Bt) {
            let Pt = 0;
            for (let st = 0, ft = Ke.length, Ge = ft - 2; st < ft; Ge = st, st += 2) Pt += (Ke[st] - Ke[Ge]) * (Ke[st + 1] + Ke[Ge + 1]);
            if (Pt > 0 === Bt) for (let st = 0, ft = Ke.length; st < ft / 2; st += 2) {
              const Ge = Ke[st], ur = Ke[st + 1];
              Ke[st] = Ke[ft - 2 - st], Ke[st + 1] = Ke[ft - 1 - st], Ke[ft - 2 - st] = Ge, Ke[ft - 1 - st] = ur;
            }
          }(gt, Ye), nt.push(gt);
        }
        const qr = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 };
        class Kr {
          constructor(oe, fe) {
            const ye = (fe = this.options = function(Ye, Qe) {
              for (const gt in Qe) Ye[gt] = Qe[gt];
              return Ye;
            }(Object.create(qr), fe)).debug;
            if (ye && console.time("preprocess data"), fe.maxZoom < 0 || fe.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (fe.promoteId && fe.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let Le = function(Ye, Qe) {
              const gt = [];
              if (Ye.type === "FeatureCollection") for (let Ke = 0; Ke < Ye.features.length; Ke++) Oe(gt, Ye.features[Ke], Qe, Ke);
              else Oe(gt, Ye.type === "Feature" ? Ye : { geometry: Ye }, Qe);
              return gt;
            }(oe, fe);
            this.tiles = {}, this.tileCoords = [], ye && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", fe.indexMaxZoom, fe.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), Le = function(Ye, Qe) {
              const gt = Qe.buffer / Qe.extent;
              let Ke = Ye;
              const Bt = yt(Ye, 1, -1 - gt, gt, 0, -1, 2, Qe), Pt = yt(Ye, 1, 1 - gt, 2 + gt, 0, -1, 2, Qe);
              return (Bt || Pt) && (Ke = yt(Ye, 1, -gt, 1 + gt, 0, -1, 2, Qe) || [], Bt && (Ke = Dr(Bt, 1).concat(Ke)), Pt && (Ke = Ke.concat(Dr(Pt, -1)))), Ke;
            }(Le, fe), Le.length && this.splitTile(Le, 0, 0, 0), ye && (Le.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          splitTile(oe, fe, ye, Le, Ye, Qe, gt) {
            const Ke = [oe, fe, ye, Le], Bt = this.options, Pt = Bt.debug;
            for (; Ke.length; ) {
              Le = Ke.pop(), ye = Ke.pop(), fe = Ke.pop(), oe = Ke.pop();
              const st = 1 << fe, ft = en(fe, ye, Le);
              let Ge = this.tiles[ft];
              if (!Ge && (Pt > 1 && console.time("creation"), Ge = this.tiles[ft] = mr(oe, fe, ye, Le, Bt), this.tileCoords.push({ z: fe, x: ye, y: Le }), Pt)) {
                Pt > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", fe, ye, Le, Ge.numFeatures, Ge.numPoints, Ge.numSimplified), console.timeEnd("creation"));
                const Dn = `z${fe}`;
                this.stats[Dn] = (this.stats[Dn] || 0) + 1, this.total++;
              }
              if (Ge.source = oe, Ye == null) {
                if (fe === Bt.indexMaxZoom || Ge.numPoints <= Bt.indexMaxPoints) continue;
              } else {
                if (fe === Bt.maxZoom || fe === Ye) continue;
                if (Ye != null) {
                  const Dn = Ye - fe;
                  if (ye !== Qe >> Dn || Le !== gt >> Dn) continue;
                }
              }
              if (Ge.source = null, oe.length === 0) continue;
              Pt > 1 && console.time("clipping");
              const ur = 0.5 * Bt.buffer / Bt.extent, Sr = 0.5 - ur, lr = 0.5 + ur, Er = 1 + ur;
              let tr = null, xn = null, dn = null, Jr = null, Cr = yt(oe, st, ye - ur, ye + lr, 0, Ge.minX, Ge.maxX, Bt), zr = yt(oe, st, ye + Sr, ye + Er, 0, Ge.minX, Ge.maxX, Bt);
              oe = null, Cr && (tr = yt(Cr, st, Le - ur, Le + lr, 1, Ge.minY, Ge.maxY, Bt), xn = yt(Cr, st, Le + Sr, Le + Er, 1, Ge.minY, Ge.maxY, Bt), Cr = null), zr && (dn = yt(zr, st, Le - ur, Le + lr, 1, Ge.minY, Ge.maxY, Bt), Jr = yt(zr, st, Le + Sr, Le + Er, 1, Ge.minY, Ge.maxY, Bt), zr = null), Pt > 1 && console.timeEnd("clipping"), Ke.push(tr || [], fe + 1, 2 * ye, 2 * Le), Ke.push(xn || [], fe + 1, 2 * ye, 2 * Le + 1), Ke.push(dn || [], fe + 1, 2 * ye + 1, 2 * Le), Ke.push(Jr || [], fe + 1, 2 * ye + 1, 2 * Le + 1);
            }
          }
          getTile(oe, fe, ye) {
            oe = +oe, fe = +fe, ye = +ye;
            const Le = this.options, { extent: Ye, debug: Qe } = Le;
            if (oe < 0 || oe > 24) return null;
            const gt = 1 << oe, Ke = en(oe, fe = fe + gt & gt - 1, ye);
            if (this.tiles[Ke]) return Yt(this.tiles[Ke], Ye);
            Qe > 1 && console.log("drilling down to z%d-%d-%d", oe, fe, ye);
            let Bt, Pt = oe, st = fe, ft = ye;
            for (; !Bt && Pt > 0; ) Pt--, st >>= 1, ft >>= 1, Bt = this.tiles[en(Pt, st, ft)];
            return Bt && Bt.source ? (Qe > 1 && (console.log("found parent tile z%d-%d-%d", Pt, st, ft), console.time("drilling down")), this.splitTile(Bt.source, Pt, st, ft, oe, fe, ye), Qe > 1 && console.timeEnd("drilling down"), this.tiles[Ke] ? Yt(this.tiles[Ke], Ye) : null) : null;
          }
        }
        function en(nt, oe, fe) {
          return 32 * ((1 << nt) * fe + oe) + nt;
        }
        function nn(nt, oe) {
          return oe ? nt.properties[oe] : nt.id;
        }
        function vn(nt, oe) {
          if (nt == null) return !0;
          if (nt.type === "Feature") return nn(nt, oe) != null;
          if (nt.type === "FeatureCollection") {
            const fe = /* @__PURE__ */ new Set();
            for (const ye of nt.features) {
              const Le = nn(ye, oe);
              if (Le == null || fe.has(Le)) return !1;
              fe.add(Le);
            }
            return !0;
          }
          return !1;
        }
        function Hr(nt, oe) {
          const fe = /* @__PURE__ */ new Map();
          if (nt != null) if (nt.type === "Feature") fe.set(nn(nt, oe), nt);
          else for (const ye of nt.features) fe.set(nn(ye, oe), ye);
          return fe;
        }
        class fn extends A {
          constructor() {
            super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
          }
          loadVectorTile(oe, fe) {
            return l._(this, void 0, void 0, function* () {
              const ye = oe.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const Le = this._geoJSONIndex.getTile(ye.z, ye.x, ye.y);
              if (!Le) return null;
              const Ye = new re(Le.features);
              let Qe = Be(Ye);
              return Qe.byteOffset === 0 && Qe.byteLength === Qe.buffer.byteLength || (Qe = new Uint8Array(Qe)), { vectorTile: Ye, rawData: Qe.buffer };
            });
          }
          loadData(oe) {
            return l._(this, void 0, void 0, function* () {
              var fe;
              (fe = this._pendingRequest) === null || fe === void 0 || fe.abort();
              const ye = !!(oe && oe.request && oe.request.collectResourceTiming) && new l.cM(oe.request);
              this._pendingRequest = new AbortController();
              try {
                this._pendingData = this.loadAndProcessGeoJSON(oe, this._pendingRequest), this._geoJSONIndex = oe.cluster ? new je(function(Qe) {
                  let { superclusterOptions: gt, clusterProperties: Ke } = Qe;
                  if (!Ke || !gt) return gt;
                  const Bt = {}, Pt = {}, st = { accumulated: null, zoom: 0 }, ft = { properties: null }, Ge = Object.keys(Ke);
                  for (const ur of Ge) {
                    const [Sr, lr] = Ke[ur], Er = l.cT(lr), tr = l.cT(typeof Sr == "string" ? [Sr, ["accumulated"], ["get", ur]] : Sr);
                    Bt[ur] = Er.value, Pt[ur] = tr.value;
                  }
                  return gt.map = (ur) => {
                    ft.properties = ur;
                    const Sr = {};
                    for (const lr of Ge) Sr[lr] = Bt[lr].evaluate(st, ft);
                    return Sr;
                  }, gt.reduce = (ur, Sr) => {
                    ft.properties = Sr;
                    for (const lr of Ge) st.accumulated = ur[lr], ur[lr] = Pt[lr].evaluate(st, ft);
                  }, gt;
                }(oe)).load((yield this._pendingData).features) : (Le = yield this._pendingData, new Kr(Le, oe.geojsonVtOptions)), this.loaded = {};
                const Ye = {};
                if (ye) {
                  const Qe = ye.finish();
                  Qe && (Ye.resourceTiming = {}, Ye.resourceTiming[oe.source] = JSON.parse(JSON.stringify(Qe)));
                }
                return Ye;
              } catch (Ye) {
                if (delete this._pendingRequest, l.cx(Ye)) return { abandoned: !0 };
                throw Ye;
              }
              var Le;
            });
          }
          getData() {
            return l._(this, void 0, void 0, function* () {
              return this._pendingData;
            });
          }
          reloadTile(oe) {
            const fe = this.loaded;
            return fe && fe[oe.uid] ? super.reloadTile(oe) : this.loadTile(oe);
          }
          loadAndProcessGeoJSON(oe, fe) {
            return l._(this, void 0, void 0, function* () {
              let ye = yield this.loadGeoJSON(oe, fe);
              if (delete this._pendingRequest, typeof ye != "object") throw new Error(`Input data given to '${oe.source}' is not a valid GeoJSON object.`);
              if (V(ye, !0), oe.filter) {
                const Le = l.cT(oe.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
                if (Le.result === "error") throw new Error(Le.value.map((Qe) => `${Qe.key}: ${Qe.message}`).join(", "));
                ye = { type: "FeatureCollection", features: ye.features.filter((Qe) => Le.value.evaluate({ zoom: 0 }, Qe)) };
              }
              return ye;
            });
          }
          loadGeoJSON(oe, fe) {
            return l._(this, void 0, void 0, function* () {
              const { promoteId: ye } = oe;
              if (oe.request) {
                const Le = yield l.j(oe.request, fe);
                return this._dataUpdateable = vn(Le.data, ye) ? Hr(Le.data, ye) : void 0, Le.data;
              }
              if (typeof oe.data == "string") try {
                const Le = JSON.parse(oe.data);
                return this._dataUpdateable = vn(Le, ye) ? Hr(Le, ye) : void 0, Le;
              } catch {
                throw new Error(`Input data given to '${oe.source}' is not a valid GeoJSON object.`);
              }
              if (!oe.dataDiff) throw new Error(`Input data given to '${oe.source}' is not a valid GeoJSON object.`);
              if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${oe.source}`);
              return function(Le, Ye, Qe) {
                var gt, Ke, Bt, Pt;
                if (Ye.removeAll && Le.clear(), Ye.remove) for (const st of Ye.remove) Le.delete(st);
                if (Ye.add) for (const st of Ye.add) {
                  const ft = nn(st, Qe);
                  ft != null && Le.set(ft, st);
                }
                if (Ye.update) for (const st of Ye.update) {
                  let ft = Le.get(st.id);
                  if (ft == null) continue;
                  const Ge = !st.removeAllProperties && (((gt = st.removeProperties) === null || gt === void 0 ? void 0 : gt.length) > 0 || ((Ke = st.addOrUpdateProperties) === null || Ke === void 0 ? void 0 : Ke.length) > 0);
                  if ((st.newGeometry || st.removeAllProperties || Ge) && (ft = Object.assign({}, ft), Le.set(st.id, ft), Ge && (ft.properties = Object.assign({}, ft.properties))), st.newGeometry && (ft.geometry = st.newGeometry), st.removeAllProperties) ft.properties = {};
                  else if (((Bt = st.removeProperties) === null || Bt === void 0 ? void 0 : Bt.length) > 0) for (const ur of st.removeProperties) Object.prototype.hasOwnProperty.call(ft.properties, ur) && delete ft.properties[ur];
                  if (((Pt = st.addOrUpdateProperties) === null || Pt === void 0 ? void 0 : Pt.length) > 0) for (const { key: ur, value: Sr } of st.addOrUpdateProperties) ft.properties[ur] = Sr;
                }
              }(this._dataUpdateable, oe.dataDiff, ye), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
            });
          }
          removeSource(oe) {
            return l._(this, void 0, void 0, function* () {
              this._pendingRequest && this._pendingRequest.abort();
            });
          }
          getClusterExpansionZoom(oe) {
            return this._geoJSONIndex.getClusterExpansionZoom(oe.clusterId);
          }
          getClusterChildren(oe) {
            return this._geoJSONIndex.getChildren(oe.clusterId);
          }
          getClusterLeaves(oe) {
            return this._geoJSONIndex.getLeaves(oe.clusterId, oe.limit, oe.offset);
          }
        }
        class gr {
          constructor(oe) {
            this.self = oe, this.actor = new l.J(oe), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (fe, ye) => {
              if (this.externalWorkerSourceTypes[fe]) throw new Error(`Worker source with name "${fe}" already registered.`);
              this.externalWorkerSourceTypes[fe] = ye;
            }, this.self.addProtocol = l.cz, this.self.removeProtocol = l.cA, this.self.registerRTLTextPlugin = (fe) => {
              l.cU.setMethods(fe);
            }, this.actor.registerMessageHandler("LDT", (fe, ye) => this._getDEMWorkerSource(fe, ye.source).loadTile(ye)), this.actor.registerMessageHandler("RDT", (fe, ye) => l._(this, void 0, void 0, function* () {
              this._getDEMWorkerSource(fe, ye.source).removeTile(ye);
            })), this.actor.registerMessageHandler("GCEZ", (fe, ye) => l._(this, void 0, void 0, function* () {
              return this._getWorkerSource(fe, ye.type, ye.source).getClusterExpansionZoom(ye);
            })), this.actor.registerMessageHandler("GCC", (fe, ye) => l._(this, void 0, void 0, function* () {
              return this._getWorkerSource(fe, ye.type, ye.source).getClusterChildren(ye);
            })), this.actor.registerMessageHandler("GCL", (fe, ye) => l._(this, void 0, void 0, function* () {
              return this._getWorkerSource(fe, ye.type, ye.source).getClusterLeaves(ye);
            })), this.actor.registerMessageHandler("LD", (fe, ye) => this._getWorkerSource(fe, ye.type, ye.source).loadData(ye)), this.actor.registerMessageHandler("GD", (fe, ye) => this._getWorkerSource(fe, ye.type, ye.source).getData()), this.actor.registerMessageHandler("LT", (fe, ye) => this._getWorkerSource(fe, ye.type, ye.source).loadTile(ye)), this.actor.registerMessageHandler("RT", (fe, ye) => this._getWorkerSource(fe, ye.type, ye.source).reloadTile(ye)), this.actor.registerMessageHandler("AT", (fe, ye) => this._getWorkerSource(fe, ye.type, ye.source).abortTile(ye)), this.actor.registerMessageHandler("RMT", (fe, ye) => this._getWorkerSource(fe, ye.type, ye.source).removeTile(ye)), this.actor.registerMessageHandler("RS", (fe, ye) => l._(this, void 0, void 0, function* () {
              if (!this.workerSources[fe] || !this.workerSources[fe][ye.type] || !this.workerSources[fe][ye.type][ye.source]) return;
              const Le = this.workerSources[fe][ye.type][ye.source];
              delete this.workerSources[fe][ye.type][ye.source], Le.removeSource !== void 0 && Le.removeSource(ye);
            })), this.actor.registerMessageHandler("RM", (fe) => l._(this, void 0, void 0, function* () {
              delete this.layerIndexes[fe], delete this.availableImages[fe], delete this.workerSources[fe], delete this.demWorkerSources[fe];
            })), this.actor.registerMessageHandler("SR", (fe, ye) => l._(this, void 0, void 0, function* () {
              this.referrer = ye;
            })), this.actor.registerMessageHandler("SRPS", (fe, ye) => this._syncRTLPluginState(fe, ye)), this.actor.registerMessageHandler("IS", (fe, ye) => l._(this, void 0, void 0, function* () {
              this.self.importScripts(ye);
            })), this.actor.registerMessageHandler("SI", (fe, ye) => this._setImages(fe, ye)), this.actor.registerMessageHandler("UL", (fe, ye) => l._(this, void 0, void 0, function* () {
              this._getLayerIndex(fe).update(ye.layers, ye.removedIds);
            })), this.actor.registerMessageHandler("SL", (fe, ye) => l._(this, void 0, void 0, function* () {
              this._getLayerIndex(fe).replace(ye);
            }));
          }
          _setImages(oe, fe) {
            return l._(this, void 0, void 0, function* () {
              this.availableImages[oe] = fe;
              for (const ye in this.workerSources[oe]) {
                const Le = this.workerSources[oe][ye];
                for (const Ye in Le) Le[Ye].availableImages = fe;
              }
            });
          }
          _syncRTLPluginState(oe, fe) {
            return l._(this, void 0, void 0, function* () {
              return yield l.cU.syncState(fe, this.self.importScripts);
            });
          }
          _getAvailableImages(oe) {
            let fe = this.availableImages[oe];
            return fe || (fe = []), fe;
          }
          _getLayerIndex(oe) {
            let fe = this.layerIndexes[oe];
            return fe || (fe = this.layerIndexes[oe] = new o()), fe;
          }
          _getWorkerSource(oe, fe, ye) {
            if (this.workerSources[oe] || (this.workerSources[oe] = {}), this.workerSources[oe][fe] || (this.workerSources[oe][fe] = {}), !this.workerSources[oe][fe][ye]) {
              const Le = { sendAsync: (Ye, Qe) => (Ye.targetMapId = oe, this.actor.sendAsync(Ye, Qe)) };
              switch (fe) {
                case "vector":
                  this.workerSources[oe][fe][ye] = new A(Le, this._getLayerIndex(oe), this._getAvailableImages(oe));
                  break;
                case "geojson":
                  this.workerSources[oe][fe][ye] = new fn(Le, this._getLayerIndex(oe), this._getAvailableImages(oe));
                  break;
                default:
                  this.workerSources[oe][fe][ye] = new this.externalWorkerSourceTypes[fe](Le, this._getLayerIndex(oe), this._getAvailableImages(oe));
              }
            }
            return this.workerSources[oe][fe][ye];
          }
          _getDEMWorkerSource(oe, fe) {
            return this.demWorkerSources[oe] || (this.demWorkerSources[oe] = {}), this.demWorkerSources[oe][fe] || (this.demWorkerSources[oe][fe] = new M()), this.demWorkerSources[oe][fe];
          }
        }
        return l.i(self) && (self.worker = new gr(self)), gr;
      }), i("index", ["exports", "./shared"], function(l, o) {
        var d = "5.6.0";
        function m() {
          var v = new o.A(4);
          return o.A != Float32Array && (v[1] = 0, v[2] = 0), v[0] = 1, v[3] = 1, v;
        }
        let b, A;
        const M = { now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frame(v, a, h) {
          const g = requestAnimationFrame((w) => {
            y(), a(w);
          }), { unsubscribe: y } = o.s(v.signal, "abort", () => {
            y(), cancelAnimationFrame(g), h(o.c());
          }, !1);
        }, frameAsync(v) {
          return new Promise((a, h) => {
            this.frame(v, a, h);
          });
        }, getImageData(v) {
          let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          return this.getImageCanvasContext(v).getImageData(-a, -a, v.width + 2 * a, v.height + 2 * a);
        }, getImageCanvasContext(v) {
          const a = window.document.createElement("canvas"), h = a.getContext("2d", { willReadFrequently: !0 });
          if (!h) throw new Error("failed to create canvas 2d context");
          return a.width = v.width, a.height = v.height, h.drawImage(v, 0, 0, v.width, v.height), h;
        }, resolveURL: (v) => (b || (b = document.createElement("a")), b.href = v, b.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
          return !!matchMedia && (A == null && (A = matchMedia("(prefers-reduced-motion: reduce)")), A.matches);
        } };
        class E {
          static testProp(a) {
            if (!E.docStyle) return a[0];
            for (let h = 0; h < a.length; h++) if (a[h] in E.docStyle) return a[h];
            return a[0];
          }
          static create(a, h, g) {
            const y = window.document.createElement(a);
            return h !== void 0 && (y.className = h), g && g.appendChild(y), y;
          }
          static createNS(a, h) {
            return window.document.createElementNS(a, h);
          }
          static disableDrag() {
            E.docStyle && E.selectProp && (E.userSelect = E.docStyle[E.selectProp], E.docStyle[E.selectProp] = "none");
          }
          static enableDrag() {
            E.docStyle && E.selectProp && (E.docStyle[E.selectProp] = E.userSelect);
          }
          static setTransform(a, h) {
            a.style[E.transformProp] = h;
          }
          static addEventListener(a, h, g) {
            let y = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            a.addEventListener(h, g, "passive" in y ? y : y.capture);
          }
          static removeEventListener(a, h, g) {
            let y = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            a.removeEventListener(h, g, "passive" in y ? y : y.capture);
          }
          static suppressClickInternal(a) {
            a.preventDefault(), a.stopPropagation(), window.removeEventListener("click", E.suppressClickInternal, !0);
          }
          static suppressClick() {
            window.addEventListener("click", E.suppressClickInternal, !0), window.setTimeout(() => {
              window.removeEventListener("click", E.suppressClickInternal, !0);
            }, 0);
          }
          static getScale(a) {
            const h = a.getBoundingClientRect();
            return { x: h.width / a.offsetWidth || 1, y: h.height / a.offsetHeight || 1, boundingClientRect: h };
          }
          static getPoint(a, h, g) {
            const y = h.boundingClientRect;
            return new o.P((g.clientX - y.left) / h.x - a.clientLeft, (g.clientY - y.top) / h.y - a.clientTop);
          }
          static mousePos(a, h) {
            const g = E.getScale(a);
            return E.getPoint(a, g, h);
          }
          static touchPos(a, h) {
            const g = [], y = E.getScale(a);
            for (let w = 0; w < h.length; w++) g.push(E.getPoint(a, y, h[w]));
            return g;
          }
          static mouseButton(a) {
            return a.button;
          }
          static remove(a) {
            a.parentNode && a.parentNode.removeChild(a);
          }
          static sanitize(a) {
            const h = new DOMParser().parseFromString(a, "text/html").body || document.createElement("body"), g = h.querySelectorAll("script");
            for (const y of g) y.remove();
            return E.clean(h), h.innerHTML;
          }
          static isPossiblyDangerous(a, h) {
            const g = h.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(a) || !g.includes("javascript:") && !g.includes("data:")) || !!a.startsWith("on") || void 0;
          }
          static clean(a) {
            const h = a.children;
            for (const g of h) E.removeAttributes(g), E.clean(g);
          }
          static removeAttributes(a) {
            for (const { name: h, value: g } of a.attributes) E.isPossiblyDangerous(h, g) && a.removeAttribute(h);
          }
        }
        E.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, E.selectProp = E.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), E.transformProp = E.testProp(["transform", "WebkitTransform"]);
        const k = { supported: !1, testSupport: function(v) {
          !q && V && (Y ? re(v) : U = v);
        } };
        let U, V, q = !1, Y = !1;
        function re(v) {
          const a = v.createTexture();
          v.bindTexture(v.TEXTURE_2D, a);
          try {
            if (v.texImage2D(v.TEXTURE_2D, 0, v.RGBA, v.RGBA, v.UNSIGNED_BYTE, V), v.isContextLost()) return;
            k.supported = !0;
          } catch {
          }
          v.deleteTexture(a), q = !0;
        }
        var Z;
        typeof document < "u" && (V = document.createElement("img"), V.onload = () => {
          U && re(U), U = null, Y = !0;
        }, V.onerror = () => {
          q = !0, U = null;
        }, V.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(v) {
          let a, h, g, y;
          v.resetRequestQueue = () => {
            a = [], h = 0, g = 0, y = {};
          }, v.addThrottleControl = (L) => {
            const F = g++;
            return y[F] = L, F;
          }, v.removeThrottleControl = (L) => {
            delete y[L], C();
          }, v.getImage = function(L, F) {
            let j = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
            return new Promise((X, G) => {
              k.supported && (L.headers || (L.headers = {}), L.headers.accept = "image/webp,*/*"), o.e(L, { type: "image" }), a.push({ abortController: F, requestParameters: L, supportImageRefresh: j, state: "queued", onError: (Q) => {
                G(Q);
              }, onSuccess: (Q) => {
                X(Q);
              } }), C();
            });
          };
          const w = (L) => o._(this, void 0, void 0, function* () {
            L.state = "running";
            const { requestParameters: F, supportImageRefresh: j, onError: X, onSuccess: G, abortController: Q } = L, le = j === !1 && !o.i(self) && !o.g(F.url) && (!F.headers || Object.keys(F.headers).reduce((Te, Me) => Te && Me === "accept", !0));
            h++;
            const Ae = le ? P(F, Q) : o.m(F, Q);
            try {
              const Te = yield Ae;
              delete L.abortController, L.state = "completed", Te.data instanceof HTMLImageElement || o.b(Te.data) ? G(Te) : Te.data && G({ data: yield (we = Te.data, typeof createImageBitmap == "function" ? o.f(we) : o.h(we)), cacheControl: Te.cacheControl, expires: Te.expires });
            } catch (Te) {
              delete L.abortController, X(Te);
            } finally {
              h--, C();
            }
            var we;
          }), C = () => {
            const L = (() => {
              for (const F of Object.keys(y)) if (y[F]()) return !0;
              return !1;
            })() ? o.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : o.a.MAX_PARALLEL_IMAGE_REQUESTS;
            for (let F = h; F < L && a.length > 0; F++) {
              const j = a.shift();
              j.abortController.signal.aborted ? F-- : w(j);
            }
          }, P = (L, F) => new Promise((j, X) => {
            const G = new Image(), Q = L.url, le = L.credentials;
            le && le === "include" ? G.crossOrigin = "use-credentials" : (le && le === "same-origin" || !o.d(Q)) && (G.crossOrigin = "anonymous"), F.signal.addEventListener("abort", () => {
              G.src = "", X(o.c());
            }), G.fetchPriority = "high", G.onload = () => {
              G.onerror = G.onload = null, j({ data: G });
            }, G.onerror = () => {
              G.onerror = G.onload = null, F.signal.aborted || X(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            }, G.src = Q;
          });
        }(Z || (Z = {})), Z.resetRequestQueue();
        class K {
          constructor(a) {
            this._transformRequestFn = a;
          }
          transformRequest(a, h) {
            return this._transformRequestFn && this._transformRequestFn(a, h) || { url: a };
          }
          setTransformRequest(a) {
            this._transformRequestFn = a;
          }
        }
        function ie(v) {
          const a = [];
          if (typeof v == "string") a.push({ id: "default", url: v });
          else if (v && v.length > 0) {
            const h = [];
            for (const { id: g, url: y } of v) {
              const w = `${g}${y}`;
              h.indexOf(w) === -1 && (h.push(w), a.push({ id: g, url: y }));
            }
          }
          return a;
        }
        function be(v, a, h) {
          try {
            const g = new URL(v);
            return g.pathname += `${a}${h}`, g.toString();
          } catch {
            throw new Error(`Invalid sprite URL "${v}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
          }
        }
        function he(v) {
          const { userImage: a } = v;
          return !!(a && a.render && a.render()) && (v.data.replace(new Uint8Array(a.data.buffer)), !0);
        }
        class Be extends o.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new o.R({ width: 1, height: 1 }), this.dirty = !0;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(a) {
            if (this.loaded !== a && (this.loaded = a, a)) {
              for (const { ids: h, promiseResolve: g } of this.requestors) g(this._getImagesForIds(h));
              this.requestors = [];
            }
          }
          getImage(a) {
            const h = this.images[a];
            if (h && !h.data && h.spriteData) {
              const g = h.spriteData;
              h.data = new o.R({ width: g.width, height: g.height }, g.context.getImageData(g.x, g.y, g.width, g.height).data), h.spriteData = null;
            }
            return h;
          }
          addImage(a, h) {
            if (this.images[a]) throw new Error(`Image id ${a} already exist, use updateImage instead`);
            this._validate(a, h) && (this.images[a] = h);
          }
          _validate(a, h) {
            let g = !0;
            const y = h.data || h.spriteData;
            return this._validateStretch(h.stretchX, y && y.width) || (this.fire(new o.k(new Error(`Image "${a}" has invalid "stretchX" value`))), g = !1), this._validateStretch(h.stretchY, y && y.height) || (this.fire(new o.k(new Error(`Image "${a}" has invalid "stretchY" value`))), g = !1), this._validateContent(h.content, h) || (this.fire(new o.k(new Error(`Image "${a}" has invalid "content" value`))), g = !1), g;
          }
          _validateStretch(a, h) {
            if (!a) return !0;
            let g = 0;
            for (const y of a) {
              if (y[0] < g || y[1] < y[0] || h < y[1]) return !1;
              g = y[1];
            }
            return !0;
          }
          _validateContent(a, h) {
            if (!a) return !0;
            if (a.length !== 4) return !1;
            const g = h.spriteData, y = g && g.width || h.data.width, w = g && g.height || h.data.height;
            return !(a[0] < 0 || y < a[0] || a[1] < 0 || w < a[1] || a[2] < 0 || y < a[2] || a[3] < 0 || w < a[3] || a[2] < a[0] || a[3] < a[1]);
          }
          updateImage(a, h) {
            let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
            const y = this.getImage(a);
            if (g && (y.data.width !== h.data.width || y.data.height !== h.data.height)) throw new Error(`size mismatch between old image (${y.data.width}x${y.data.height}) and new image (${h.data.width}x${h.data.height}).`);
            h.version = y.version + 1, this.images[a] = h, this.updatedImages[a] = !0;
          }
          removeImage(a) {
            const h = this.images[a];
            delete this.images[a], delete this.patterns[a], h.userImage && h.userImage.onRemove && h.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(a) {
            return new Promise((h, g) => {
              let y = !0;
              if (!this.isLoaded()) for (const w of a) this.images[w] || (y = !1);
              this.isLoaded() || y ? h(this._getImagesForIds(a)) : this.requestors.push({ ids: a, promiseResolve: h });
            });
          }
          _getImagesForIds(a) {
            const h = {};
            for (const g of a) {
              let y = this.getImage(g);
              y || (this.fire(new o.l("styleimagemissing", { id: g })), y = this.getImage(g)), y ? h[g] = { data: y.data.clone(), pixelRatio: y.pixelRatio, sdf: y.sdf, version: y.version, stretchX: y.stretchX, stretchY: y.stretchY, content: y.content, textFitWidth: y.textFitWidth, textFitHeight: y.textFitHeight, hasRenderCallback: !!(y.userImage && y.userImage.render) } : o.w(`Image "${g}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            return h;
          }
          getPixelSize() {
            const { width: a, height: h } = this.atlasImage;
            return { width: a, height: h };
          }
          getPattern(a) {
            const h = this.patterns[a], g = this.getImage(a);
            if (!g) return null;
            if (h && h.position.version === g.version) return h.position;
            if (h) h.position.version = g.version;
            else {
              const y = { w: g.data.width + 2, h: g.data.height + 2, x: 0, y: 0 }, w = new o.I(y, g);
              this.patterns[a] = { bin: y, position: w };
            }
            return this._updatePatternAtlas(), this.patterns[a].position;
          }
          bind(a) {
            const h = a.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new o.T(a, this.atlasImage, h.RGBA), this.atlasTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const a = [];
            for (const w in this.patterns) a.push(this.patterns[w].bin);
            const { w: h, h: g } = o.p(a), y = this.atlasImage;
            y.resize({ width: h || 1, height: g || 1 });
            for (const w in this.patterns) {
              const { bin: C } = this.patterns[w], P = C.x + 1, L = C.y + 1, F = this.getImage(w).data, j = F.width, X = F.height;
              o.R.copy(F, y, { x: 0, y: 0 }, { x: P, y: L }, { width: j, height: X }), o.R.copy(F, y, { x: 0, y: X - 1 }, { x: P, y: L - 1 }, { width: j, height: 1 }), o.R.copy(F, y, { x: 0, y: 0 }, { x: P, y: L + X }, { width: j, height: 1 }), o.R.copy(F, y, { x: j - 1, y: 0 }, { x: P - 1, y: L }, { width: 1, height: X }), o.R.copy(F, y, { x: 0, y: 0 }, { x: P + j, y: L }, { width: 1, height: X });
            }
            this.dirty = !0;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(a) {
            for (const h of a) {
              if (this.callbackDispatchedThisFrame[h]) continue;
              this.callbackDispatchedThisFrame[h] = !0;
              const g = this.getImage(h);
              g || o.w(`Image with ID: "${h}" was not found`), he(g) && this.updateImage(h, g);
            }
          }
        }
        const ke = 1e20;
        function pe(v, a, h, g, y, w, C, P, L) {
          for (let F = a; F < a + g; F++) me(v, h * w + F, w, y, C, P, L);
          for (let F = h; F < h + y; F++) me(v, F * w + a, 1, g, C, P, L);
        }
        function me(v, a, h, g, y, w, C) {
          w[0] = 0, C[0] = -1e20, C[1] = ke, y[0] = v[a];
          for (let P = 1, L = 0, F = 0; P < g; P++) {
            y[P] = v[a + P * h];
            const j = P * P;
            do {
              const X = w[L];
              F = (y[P] - y[X] + j - X * X) / (P - X) / 2;
            } while (F <= C[L] && --L > -1);
            L++, w[L] = P, C[L] = F, C[L + 1] = ke;
          }
          for (let P = 0, L = 0; P < g; P++) {
            for (; C[L + 1] < P; ) L++;
            const F = w[L], j = P - F;
            v[a + P * h] = y[F] + j * j;
          }
        }
        class je {
          constructor(a, h) {
            this.requestManager = a, this.localIdeographFontFamily = h, this.entries = {};
          }
          setURL(a) {
            this.url = a;
          }
          getGlyphs(a) {
            return o._(this, void 0, void 0, function* () {
              const h = [];
              for (const w in a) for (const C of a[w]) h.push(this._getAndCacheGlyphsPromise(w, C));
              const g = yield Promise.all(h), y = {};
              for (const { stack: w, id: C, glyph: P } of g) y[w] || (y[w] = {}), y[w][C] = P && { id: P.id, bitmap: P.bitmap.clone(), metrics: P.metrics };
              return y;
            });
          }
          _getAndCacheGlyphsPromise(a, h) {
            return o._(this, void 0, void 0, function* () {
              let g = this.entries[a];
              g || (g = this.entries[a] = { glyphs: {}, requests: {}, ranges: {} });
              let y = g.glyphs[h];
              if (y !== void 0) return { stack: a, id: h, glyph: y };
              if (y = this._tinySDF(g, a, h), y) return g.glyphs[h] = y, { stack: a, id: h, glyph: y };
              const w = Math.floor(h / 256);
              if (256 * w > 65535) throw new Error("glyphs > 65535 not supported");
              if (g.ranges[w]) return { stack: a, id: h, glyph: y };
              if (!this.url) throw new Error("glyphsUrl is not set");
              if (!g.requests[w]) {
                const P = je.loadGlyphRange(a, w, this.url, this.requestManager);
                g.requests[w] = P;
              }
              const C = yield g.requests[w];
              for (const P in C) this._doesCharSupportLocalGlyph(+P) || (g.glyphs[+P] = C[+P]);
              return g.ranges[w] = !0, { stack: a, id: h, glyph: C[h] || null };
            });
          }
          _doesCharSupportLocalGlyph(a) {
            return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(a)) || o.u["CJK Unified Ideographs"](a) || o.u["Hangul Syllables"](a) || o.u.Hiragana(a) || o.u.Katakana(a) || o.u["CJK Symbols and Punctuation"](a) || o.u["Halfwidth and Fullwidth Forms"](a));
          }
          _tinySDF(a, h, g) {
            const y = this.localIdeographFontFamily;
            if (!y || !this._doesCharSupportLocalGlyph(g)) return;
            let w = a.tinySDF;
            if (!w) {
              let P = "400";
              /bold/i.test(h) ? P = "900" : /medium/i.test(h) ? P = "500" : /light/i.test(h) && (P = "200"), w = a.tinySDF = new je.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: y, fontWeight: P });
            }
            const C = w.draw(String.fromCharCode(g));
            return { id: g, bitmap: new o.q({ width: C.width || 60, height: C.height || 60 }, C.data), metrics: { width: C.glyphWidth / 2 || 24, height: C.glyphHeight / 2 || 24, left: C.glyphLeft / 2 + 0.5 || 0, top: C.glyphTop / 2 - 27.5 || -8, advance: C.glyphAdvance / 2 || 24, isDoubleResolution: !0 } };
          }
        }
        je.loadGlyphRange = function(v, a, h, g) {
          return o._(this, void 0, void 0, function* () {
            const y = 256 * a, w = y + 255, C = g.transformRequest(h.replace("{fontstack}", v).replace("{range}", `${y}-${w}`), "Glyphs"), P = yield o.n(C, new AbortController());
            if (!P || !P.data) throw new Error(`Could not load glyph range. range: ${a}, ${y}-${w}`);
            const L = {};
            for (const F of o.o(P.data)) L[F.id] = F;
            return L;
          });
        }, je.TinySDF = class {
          constructor() {
            let { fontSize: v = 24, buffer: a = 3, radius: h = 8, cutoff: g = 0.25, fontFamily: y = "sans-serif", fontWeight: w = "normal", fontStyle: C = "normal" } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            this.buffer = a, this.cutoff = g, this.radius = h;
            const P = this.size = v + 4 * a, L = this._createCanvas(P), F = this.ctx = L.getContext("2d", { willReadFrequently: !0 });
            F.font = `${C} ${w} ${v}px ${y}`, F.textBaseline = "alphabetic", F.textAlign = "left", F.fillStyle = "black", this.gridOuter = new Float64Array(P * P), this.gridInner = new Float64Array(P * P), this.f = new Float64Array(P), this.z = new Float64Array(P + 1), this.v = new Uint16Array(P);
          }
          _createCanvas(v) {
            const a = document.createElement("canvas");
            return a.width = a.height = v, a;
          }
          draw(v) {
            const { width: a, actualBoundingBoxAscent: h, actualBoundingBoxDescent: g, actualBoundingBoxLeft: y, actualBoundingBoxRight: w } = this.ctx.measureText(v), C = Math.ceil(h), P = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(w - y))), L = Math.min(this.size - this.buffer, C + Math.ceil(g)), F = P + 2 * this.buffer, j = L + 2 * this.buffer, X = Math.max(F * j, 0), G = new Uint8ClampedArray(X), Q = { data: G, width: F, height: j, glyphWidth: P, glyphHeight: L, glyphTop: C, glyphLeft: 0, glyphAdvance: a };
            if (P === 0 || L === 0) return Q;
            const { ctx: le, buffer: Ae, gridInner: we, gridOuter: Te } = this;
            le.clearRect(Ae, Ae, P, L), le.fillText(v, Ae, Ae + C);
            const Me = le.getImageData(Ae, Ae, P, L);
            Te.fill(ke, 0, X), we.fill(0, 0, X);
            for (let Ve = 0; Ve < L; Ve++) for (let De = 0; De < P; De++) {
              const He = Me.data[4 * (Ve * P + De) + 3] / 255;
              if (He === 0) continue;
              const Ze = (Ve + Ae) * F + De + Ae;
              if (He === 1) Te[Ze] = 0, we[Ze] = ke;
              else {
                const Fe = 0.5 - He;
                Te[Ze] = Fe > 0 ? Fe * Fe : 0, we[Ze] = Fe < 0 ? Fe * Fe : 0;
              }
            }
            pe(Te, 0, 0, F, j, F, this.f, this.v, this.z), pe(we, Ae, Ae, P, L, F, this.f, this.v, this.z);
            for (let Ve = 0; Ve < X; Ve++) {
              const De = Math.sqrt(Te[Ve]) - Math.sqrt(we[Ve]);
              G[Ve] = Math.round(255 - 255 * (De / this.radius + this.cutoff));
            }
            return Q;
          }
        };
        class Pe {
          constructor() {
            this.specification = o.v.light.position;
          }
          possiblyEvaluate(a, h) {
            return o.B(a.expression.evaluate(h));
          }
          interpolate(a, h, g) {
            return { x: o.C.number(a.x, h.x, g), y: o.C.number(a.y, h.y, g), z: o.C.number(a.z, h.z, g) };
          }
        }
        let St;
        class Mt extends o.E {
          constructor(a) {
            super(), St = St || new o.r({ anchor: new o.D(o.v.light.anchor), position: new Pe(), color: new o.D(o.v.light.color), intensity: new o.D(o.v.light.intensity) }), this._transitionable = new o.t(St), this.setLight(a), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(a) {
            let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (!this._validate(o.x, a, h)) for (const g in a) {
              const y = a[g];
              g.endsWith("-transition") ? this._transitionable.setTransition(g.slice(0, -11), y) : this._transitionable.setValue(g, y);
            }
          }
          updateTransitions(a) {
            this._transitioning = this._transitionable.transitioned(a, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(a) {
            this.properties = this._transitioning.possiblyEvaluate(a);
          }
          _validate(a, h, g) {
            return (!g || g.validate !== !1) && o.y(this, a.call(o.z, { value: h, style: { glyphs: !0, sprite: !0 }, styleSpec: o.v }));
          }
        }
        const Lt = new o.r({ "sky-color": new o.D(o.v.sky["sky-color"]), "horizon-color": new o.D(o.v.sky["horizon-color"]), "fog-color": new o.D(o.v.sky["fog-color"]), "fog-ground-blend": new o.D(o.v.sky["fog-ground-blend"]), "horizon-fog-blend": new o.D(o.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new o.D(o.v.sky["sky-horizon-blend"]), "atmosphere-blend": new o.D(o.v.sky["atmosphere-blend"]) });
        class xt extends o.E {
          constructor(a) {
            super(), this._transitionable = new o.t(Lt), this.setSky(a), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new o.F(0));
          }
          setSky(a) {
            let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (!this._validate(o.G, a, h)) {
              a || (a = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
              for (const g in a) {
                const y = a[g];
                g.endsWith("-transition") ? this._transitionable.setTransition(g.slice(0, -11), y) : this._transitionable.setValue(g, y);
              }
            }
          }
          getSky() {
            return this._transitionable.serialize();
          }
          updateTransitions(a) {
            this._transitioning = this._transitionable.transitioned(a, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(a) {
            this.properties = this._transitioning.possiblyEvaluate(a);
          }
          _validate(a, h) {
            let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return (g == null ? void 0 : g.validate) !== !1 && o.y(this, a.call(o.z, o.e({ value: h, style: { glyphs: !0, sprite: !0 }, styleSpec: o.v })));
          }
          calculateFogBlendOpacity(a) {
            return a < 60 ? 0 : a < 70 ? (a - 60) / 10 : 1;
          }
        }
        class zt {
          constructor(a, h) {
            this.width = a, this.height = h, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
          }
          getDash(a, h) {
            const g = a.join(",") + String(h);
            return this.dashEntry[g] || (this.dashEntry[g] = this.addDash(a, h)), this.dashEntry[g];
          }
          getDashRanges(a, h, g) {
            const y = [];
            let w = a.length % 2 == 1 ? -a[a.length - 1] * g : 0, C = a[0] * g, P = !0;
            y.push({ left: w, right: C, isDash: P, zeroLength: a[0] === 0 });
            let L = a[0];
            for (let F = 1; F < a.length; F++) {
              P = !P;
              const j = a[F];
              w = L * g, L += j, C = L * g, y.push({ left: w, right: C, isDash: P, zeroLength: j === 0 });
            }
            return y;
          }
          addRoundDash(a, h, g) {
            const y = h / 2;
            for (let w = -g; w <= g; w++) {
              const C = this.width * (this.nextRow + g + w);
              let P = 0, L = a[P];
              for (let F = 0; F < this.width; F++) {
                F / L.right > 1 && (L = a[++P]);
                const j = Math.abs(F - L.left), X = Math.abs(F - L.right), G = Math.min(j, X);
                let Q;
                const le = w / g * (y + 1);
                if (L.isDash) {
                  const Ae = y - Math.abs(le);
                  Q = Math.sqrt(G * G + Ae * Ae);
                } else Q = y - Math.sqrt(G * G + le * le);
                this.data[C + F] = Math.max(0, Math.min(255, Q + 128));
              }
            }
          }
          addRegularDash(a) {
            for (let P = a.length - 1; P >= 0; --P) {
              const L = a[P], F = a[P + 1];
              L.zeroLength ? a.splice(P, 1) : F && F.isDash === L.isDash && (F.left = L.left, a.splice(P, 1));
            }
            const h = a[0], g = a[a.length - 1];
            h.isDash === g.isDash && (h.left = g.left - this.width, g.right = h.right + this.width);
            const y = this.width * this.nextRow;
            let w = 0, C = a[w];
            for (let P = 0; P < this.width; P++) {
              P / C.right > 1 && (C = a[++w]);
              const L = Math.abs(P - C.left), F = Math.abs(P - C.right), j = Math.min(L, F);
              this.data[y + P] = Math.max(0, Math.min(255, (C.isDash ? j : -j) + 128));
            }
          }
          addDash(a, h) {
            const g = h ? 7 : 0, y = 2 * g + 1;
            if (this.nextRow + y > this.height) return o.w("LineAtlas out of space"), null;
            let w = 0;
            for (let P = 0; P < a.length; P++) w += a[P];
            if (w !== 0) {
              const P = this.width / w, L = this.getDashRanges(a, this.width, P);
              h ? this.addRoundDash(L, P, g) : this.addRegularDash(L);
            }
            const C = { y: (this.nextRow + g + 0.5) / this.height, height: 2 * g / this.height, width: w };
            return this.nextRow += y, this.dirty = !0, C;
          }
          bind(a) {
            const h = a.gl;
            this.texture ? (h.bindTexture(h.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, h.texSubImage2D(h.TEXTURE_2D, 0, 0, 0, this.width, this.height, h.ALPHA, h.UNSIGNED_BYTE, this.data))) : (this.texture = h.createTexture(), h.bindTexture(h.TEXTURE_2D, this.texture), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, h.REPEAT), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, h.REPEAT), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, h.LINEAR), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, h.LINEAR), h.texImage2D(h.TEXTURE_2D, 0, h.ALPHA, this.width, this.height, 0, h.ALPHA, h.UNSIGNED_BYTE, this.data));
          }
        }
        const Dt = "maplibre_preloaded_worker_pool";
        class hr {
          constructor() {
            this.active = {};
          }
          acquire(a) {
            if (!this.workers) for (this.workers = []; this.workers.length < hr.workerCount; ) this.workers.push(new Worker(o.a.WORKER_URL));
            return this.active[a] = !0, this.workers.slice();
          }
          release(a) {
            delete this.active[a], this.numActive() === 0 && (this.workers.forEach((h) => {
              h.terminate();
            }), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[Dt];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        const ce = Math.floor(M.hardwareConcurrency / 2);
        let Oe, $e;
        function et() {
          return Oe || (Oe = new hr()), Oe;
        }
        hr.workerCount = o.H(globalThis) ? Math.max(Math.min(ce, 3), 1) : 1;
        class ot {
          constructor(a, h) {
            this.workerPool = a, this.actors = [], this.currentActor = 0, this.id = h;
            const g = this.workerPool.acquire(h);
            for (let y = 0; y < g.length; y++) {
              const w = new o.J(g[y], h);
              w.name = `Worker ${y}`, this.actors.push(w);
            }
            if (!this.actors.length) throw new Error("No actors found");
          }
          broadcast(a, h) {
            const g = [];
            for (const y of this.actors) g.push(y.sendAsync({ type: a, data: h }));
            return Promise.all(g);
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove() {
            let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
            this.actors.forEach((h) => {
              h.remove();
            }), this.actors = [], a && this.workerPool.release(this.id);
          }
          registerMessageHandler(a, h) {
            for (const g of this.actors) g.registerMessageHandler(a, h);
          }
        }
        function ht() {
          return $e || ($e = new ot(et(), o.K), $e.registerMessageHandler("GR", (v, a, h) => o.m(a, h))), $e;
        }
        function It(v, a) {
          const h = o.L();
          return o.M(h, h, [1, 1, 0]), o.N(h, h, [0.5 * v.width, 0.5 * v.height, 1]), v.calculatePosMatrix ? o.O(h, h, v.calculatePosMatrix(a.toUnwrapped())) : h;
        }
        function yt(v, a, h, g, y, w, C) {
          var P;
          const L = function(G, Q, le) {
            if (G) for (const Ae of G) {
              const we = Q[Ae];
              if (we && we.source === le && we.type === "fill-extrusion") return !0;
            }
            else for (const Ae in Q) {
              const we = Q[Ae];
              if (we.source === le && we.type === "fill-extrusion") return !0;
            }
            return !1;
          }((P = y == null ? void 0 : y.layers) !== null && P !== void 0 ? P : null, a, v.id), F = w.maxPitchScaleFactor(), j = v.tilesIn(g, F, L);
          j.sort(ar);
          const X = [];
          for (const G of j) X.push({ wrappedTileID: G.tileID.wrapped().key, queryResults: G.tile.queryRenderedFeatures(a, h, v._state, G.queryGeometry, G.cameraQueryGeometry, G.scale, y, w, F, It(v.transform, G.tileID), C ? (Q, le) => C(G.tileID, Q, le) : void 0) });
          return function(G, Q) {
            for (const le in G) for (const Ae of G[le]) Kt(Ae, Q);
            return G;
          }(function(G) {
            const Q = {}, le = {};
            for (const Ae of G) {
              const we = Ae.queryResults, Te = Ae.wrappedTileID, Me = le[Te] = le[Te] || {};
              for (const Ve in we) {
                const De = we[Ve], He = Me[Ve] = Me[Ve] || {}, Ze = Q[Ve] = Q[Ve] || [];
                for (const Fe of De) He[Fe.featureIndex] || (He[Fe.featureIndex] = !0, Ze.push(Fe));
              }
            }
            return Q;
          }(X), v);
        }
        function ar(v, a) {
          const h = v.tileID, g = a.tileID;
          return h.overscaledZ - g.overscaledZ || h.canonical.y - g.canonical.y || h.wrap - g.wrap || h.canonical.x - g.canonical.x;
        }
        function Kt(v, a) {
          const h = v.feature, g = a.getFeatureState(h.layer["source-layer"], h.id);
          h.source = h.layer.source, h.layer["source-layer"] && (h.sourceLayer = h.layer["source-layer"]), h.state = g;
        }
        function vr(v, a, h) {
          return o._(this, void 0, void 0, function* () {
            let g = v;
            if (v.url ? g = (yield o.j(a.transformRequest(v.url, "Source"), h)).data : yield M.frameAsync(h), !g) return null;
            const y = o.Q(o.e(g, v), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in g && g.vector_layers && (y.vectorLayerIds = g.vector_layers.map((w) => w.id)), y;
          });
        }
        class sr {
          constructor(a, h) {
            a && (h ? this.setSouthWest(a).setNorthEast(h) : Array.isArray(a) && (a.length === 4 ? this.setSouthWest([a[0], a[1]]).setNorthEast([a[2], a[3]]) : this.setSouthWest(a[0]).setNorthEast(a[1])));
          }
          setNorthEast(a) {
            return this._ne = a instanceof o.S ? new o.S(a.lng, a.lat) : o.S.convert(a), this;
          }
          setSouthWest(a) {
            return this._sw = a instanceof o.S ? new o.S(a.lng, a.lat) : o.S.convert(a), this;
          }
          extend(a) {
            const h = this._sw, g = this._ne;
            let y, w;
            if (a instanceof o.S) y = a, w = a;
            else {
              if (!(a instanceof sr)) return Array.isArray(a) ? a.length === 4 || a.every(Array.isArray) ? this.extend(sr.convert(a)) : this.extend(o.S.convert(a)) : a && ("lng" in a || "lon" in a) && "lat" in a ? this.extend(o.S.convert(a)) : this;
              if (y = a._sw, w = a._ne, !y || !w) return this;
            }
            return h || g ? (h.lng = Math.min(y.lng, h.lng), h.lat = Math.min(y.lat, h.lat), g.lng = Math.max(w.lng, g.lng), g.lat = Math.max(w.lat, g.lat)) : (this._sw = new o.S(y.lng, y.lat), this._ne = new o.S(w.lng, w.lat)), this;
          }
          getCenter() {
            return new o.S((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new o.S(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new o.S(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(a) {
            const { lng: h, lat: g } = o.S.convert(a);
            let y = this._sw.lng <= h && h <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (y = this._sw.lng >= h && h >= this._ne.lng), this._sw.lat <= g && g <= this._ne.lat && y;
          }
          static convert(a) {
            return a instanceof sr ? a : a && new sr(a);
          }
          static fromLngLat(a) {
            const g = 360 * (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0) / 40075017, y = g / Math.cos(Math.PI / 180 * a.lat);
            return new sr(new o.S(a.lng - y, a.lat - g), new o.S(a.lng + y, a.lat + g));
          }
          adjustAntiMeridian() {
            const a = new o.S(this._sw.lng, this._sw.lat), h = new o.S(this._ne.lng, this._ne.lat);
            return new sr(a, a.lng > h.lng ? new o.S(h.lng + 360, h.lat) : h);
          }
        }
        class Ur {
          constructor(a, h, g) {
            this.bounds = sr.convert(this.validateBounds(a)), this.minzoom = h || 0, this.maxzoom = g || 24;
          }
          validateBounds(a) {
            return Array.isArray(a) && a.length === 4 ? [Math.max(-180, a[0]), Math.max(-90, a[1]), Math.min(180, a[2]), Math.min(90, a[3])] : [-180, -90, 180, 90];
          }
          contains(a) {
            const h = Math.pow(2, a.z), g = Math.floor(o.V(this.bounds.getWest()) * h), y = Math.floor(o.U(this.bounds.getNorth()) * h), w = Math.ceil(o.V(this.bounds.getEast()) * h), C = Math.ceil(o.U(this.bounds.getSouth()) * h);
            return a.x >= g && a.x < w && a.y >= y && a.y < C;
          }
        }
        class Nt extends o.E {
          constructor(a, h, g, y) {
            if (super(), this.id = a, this.dispatcher = g, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, o.e(this, o.Q(h, ["url", "scheme", "tileSize", "promoteId"])), this._options = o.e({ type: "vector" }, h), this._collectResourceTiming = h.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(y);
          }
          load() {
            return o._(this, void 0, void 0, function* () {
              this._loaded = !1, this.fire(new o.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const a = yield vr(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), a && (o.e(this, a), a.bounds && (this.tileBounds = new Ur(a.bounds, this.minzoom, this.maxzoom)), this.fire(new o.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new o.l("data", { dataType: "source", sourceDataType: "content" })));
              } catch (a) {
                this._tileJSONRequest = null, this.fire(new o.k(a));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          hasTile(a) {
            return !this.tileBounds || this.tileBounds.contains(a.canonical);
          }
          onAdd(a) {
            this.map = a, this.load();
          }
          setSourceProperty(a) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), a(), this.load();
          }
          setTiles(a) {
            return this.setSourceProperty(() => {
              this._options.tiles = a;
            }), this;
          }
          setUrl(a) {
            return this.setSourceProperty(() => {
              this.url = a, this._options.url = a;
            }), this;
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          serialize() {
            return o.e({}, this._options);
          }
          loadTile(a) {
            return o._(this, void 0, void 0, function* () {
              const h = a.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), g = { request: this.map._requestManager.transformRequest(h, "Tile"), uid: a.uid, tileID: a.tileID, zoom: a.tileID.overscaledZ, tileSize: this.tileSize * a.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity, globalState: this.map.getGlobalState() };
              g.request.collectResourceTiming = this._collectResourceTiming;
              let y = "RT";
              if (a.actor && a.state !== "expired") {
                if (a.state === "loading") return new Promise((w, C) => {
                  a.reloadPromise = { resolve: w, reject: C };
                });
              } else a.actor = this.dispatcher.getActor(), y = "LT";
              a.abortController = new AbortController();
              try {
                const w = yield a.actor.sendAsync({ type: y, data: g }, a.abortController);
                if (delete a.abortController, a.aborted) return;
                this._afterTileLoadWorkerResponse(a, w);
              } catch (w) {
                if (delete a.abortController, a.aborted) return;
                if (w && w.status !== 404) throw w;
                this._afterTileLoadWorkerResponse(a, null);
              }
            });
          }
          _afterTileLoadWorkerResponse(a, h) {
            if (h && h.resourceTiming && (a.resourceTiming = h.resourceTiming), h && this.map._refreshExpiredTiles && a.setExpiryData(h), a.loadVectorData(h, this.map.painter), a.reloadPromise) {
              const g = a.reloadPromise;
              a.reloadPromise = null, this.loadTile(a).then(g.resolve).catch(g.reject);
            }
          }
          abortTile(a) {
            return o._(this, void 0, void 0, function* () {
              a.abortController && (a.abortController.abort(), delete a.abortController), a.actor && (yield a.actor.sendAsync({ type: "AT", data: { uid: a.uid, type: this.type, source: this.id } }));
            });
          }
          unloadTile(a) {
            return o._(this, void 0, void 0, function* () {
              a.unloadVectorData(), a.actor && (yield a.actor.sendAsync({ type: "RMT", data: { uid: a.uid, type: this.type, source: this.id } }));
            });
          }
          hasTransition() {
            return !1;
          }
        }
        class We extends o.E {
          constructor(a, h, g, y) {
            super(), this.id = a, this.dispatcher = g, this.setEventedParent(y), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = o.e({ type: "raster" }, h), o.e(this, o.Q(h, ["url", "scheme", "tileSize"]));
          }
          load() {
            return o._(this, arguments, void 0, function() {
              var a = this;
              let h = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
              return function* () {
                a._loaded = !1, a.fire(new o.l("dataloading", { dataType: "source" })), a._tileJSONRequest = new AbortController();
                try {
                  const g = yield vr(a._options, a.map._requestManager, a._tileJSONRequest);
                  a._tileJSONRequest = null, a._loaded = !0, g && (o.e(a, g), g.bounds && (a.tileBounds = new Ur(g.bounds, a.minzoom, a.maxzoom)), a.fire(new o.l("data", { dataType: "source", sourceDataType: "metadata" })), a.fire(new o.l("data", { dataType: "source", sourceDataType: "content", sourceDataChanged: h })));
                } catch (g) {
                  a._tileJSONRequest = null, a.fire(new o.k(g));
                }
              }();
            });
          }
          loaded() {
            return this._loaded;
          }
          onAdd(a) {
            this.map = a, this.load();
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          setSourceProperty(a) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), a(), this.load(!0);
          }
          setTiles(a) {
            return this.setSourceProperty(() => {
              this._options.tiles = a;
            }), this;
          }
          setUrl(a) {
            return this.setSourceProperty(() => {
              this.url = a, this._options.url = a;
            }), this;
          }
          serialize() {
            return o.e({}, this._options);
          }
          hasTile(a) {
            return !this.tileBounds || this.tileBounds.contains(a.canonical);
          }
          loadTile(a) {
            return o._(this, void 0, void 0, function* () {
              const h = a.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              a.abortController = new AbortController();
              try {
                const g = yield Z.getImage(this.map._requestManager.transformRequest(h, "Tile"), a.abortController, this.map._refreshExpiredTiles);
                if (delete a.abortController, a.aborted) return void (a.state = "unloaded");
                if (g && g.data) {
                  this.map._refreshExpiredTiles && (g.cacheControl || g.expires) && a.setExpiryData({ cacheControl: g.cacheControl, expires: g.expires });
                  const y = this.map.painter.context, w = y.gl, C = g.data;
                  a.texture = this.map.painter.getTileTexture(C.width), a.texture ? a.texture.update(C, { useMipmap: !0 }) : (a.texture = new o.T(y, C, w.RGBA, { useMipmap: !0 }), a.texture.bind(w.LINEAR, w.CLAMP_TO_EDGE, w.LINEAR_MIPMAP_NEAREST)), a.state = "loaded";
                }
              } catch (g) {
                if (delete a.abortController, a.aborted) a.state = "unloaded";
                else if (g) throw a.state = "errored", g;
              }
            });
          }
          abortTile(a) {
            return o._(this, void 0, void 0, function* () {
              a.abortController && (a.abortController.abort(), delete a.abortController);
            });
          }
          unloadTile(a) {
            return o._(this, void 0, void 0, function* () {
              a.texture && this.map.painter.saveTileTexture(a.texture);
            });
          }
          hasTransition() {
            return !1;
          }
        }
        class Dr extends We {
          constructor(a, h, g, y) {
            super(a, h, g, y), this.type = "raster-dem", this.maxzoom = 22, this._options = o.e({ type: "raster-dem" }, h), this.encoding = h.encoding || "mapbox", this.redFactor = h.redFactor, this.greenFactor = h.greenFactor, this.blueFactor = h.blueFactor, this.baseShift = h.baseShift;
          }
          loadTile(a) {
            return o._(this, void 0, void 0, function* () {
              const h = a.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), g = this.map._requestManager.transformRequest(h, "Tile");
              a.neighboringTiles = this._getNeighboringTiles(a.tileID), a.abortController = new AbortController();
              try {
                const y = yield Z.getImage(g, a.abortController, this.map._refreshExpiredTiles);
                if (delete a.abortController, a.aborted) return void (a.state = "unloaded");
                if (y && y.data) {
                  const w = y.data;
                  this.map._refreshExpiredTiles && (y.cacheControl || y.expires) && a.setExpiryData({ cacheControl: y.cacheControl, expires: y.expires });
                  const C = o.b(w) && o.W() ? w : yield this.readImageNow(w), P = { type: this.type, uid: a.uid, source: this.id, rawImageData: C, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                  if (!a.actor || a.state === "expired") {
                    a.actor = this.dispatcher.getActor();
                    const L = yield a.actor.sendAsync({ type: "LDT", data: P });
                    a.dem = L, a.needsHillshadePrepare = !0, a.needsTerrainPrepare = !0, a.state = "loaded";
                  }
                }
              } catch (y) {
                if (delete a.abortController, a.aborted) a.state = "unloaded";
                else if (y) throw a.state = "errored", y;
              }
            });
          }
          readImageNow(a) {
            return o._(this, void 0, void 0, function* () {
              if (typeof VideoFrame < "u" && o.X()) {
                const h = a.width + 2, g = a.height + 2;
                try {
                  return new o.R({ width: h, height: g }, yield o.Y(a, -1, -1, h, g));
                } catch {
                }
              }
              return M.getImageData(a, 1);
            });
          }
          _getNeighboringTiles(a) {
            const h = a.canonical, g = Math.pow(2, h.z), y = (h.x - 1 + g) % g, w = h.x === 0 ? a.wrap - 1 : a.wrap, C = (h.x + 1 + g) % g, P = h.x + 1 === g ? a.wrap + 1 : a.wrap, L = {};
            return L[new o.Z(a.overscaledZ, w, h.z, y, h.y).key] = { backfilled: !1 }, L[new o.Z(a.overscaledZ, P, h.z, C, h.y).key] = { backfilled: !1 }, h.y > 0 && (L[new o.Z(a.overscaledZ, w, h.z, y, h.y - 1).key] = { backfilled: !1 }, L[new o.Z(a.overscaledZ, a.wrap, h.z, h.x, h.y - 1).key] = { backfilled: !1 }, L[new o.Z(a.overscaledZ, P, h.z, C, h.y - 1).key] = { backfilled: !1 }), h.y + 1 < g && (L[new o.Z(a.overscaledZ, w, h.z, y, h.y + 1).key] = { backfilled: !1 }, L[new o.Z(a.overscaledZ, a.wrap, h.z, h.x, h.y + 1).key] = { backfilled: !1 }, L[new o.Z(a.overscaledZ, P, h.z, C, h.y + 1).key] = { backfilled: !1 }), L;
          }
          unloadTile(a) {
            return o._(this, void 0, void 0, function* () {
              a.demTexture && this.map.painter.saveTileTexture(a.demTexture), a.fbo && (a.fbo.destroy(), delete a.fbo), a.dem && delete a.dem, delete a.neighboringTiles, a.state = "unloaded", a.actor && (yield a.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: a.uid, source: this.id } }));
            });
          }
        }
        class Tr extends o.E {
          constructor(a, h, g, y) {
            super(), this.id = a, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._pendingLoads = 0, this.actor = g.getActor(), this.setEventedParent(y), this._data = h.data, this._options = o.e({}, h), this._collectResourceTiming = h.collectResourceTiming, h.maxzoom !== void 0 && (this.maxzoom = h.maxzoom), h.type && (this.type = h.type), h.attribution && (this.attribution = h.attribution), this.promoteId = h.promoteId, h.clusterMaxZoom !== void 0 && this.maxzoom <= h.clusterMaxZoom && o.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${h.clusterMaxZoom}".`), this.workerOptions = o.e({ source: this.id, cluster: h.cluster || !1, geojsonVtOptions: { buffer: this._pixelsToTileUnits(h.buffer !== void 0 ? h.buffer : 128), tolerance: this._pixelsToTileUnits(h.tolerance !== void 0 ? h.tolerance : 0.375), extent: o.$, maxZoom: this.maxzoom, lineMetrics: h.lineMetrics || !1, generateId: h.generateId || !1 }, superclusterOptions: { maxZoom: this._getClusterMaxZoom(h.clusterMaxZoom), minPoints: Math.max(2, h.clusterMinPoints || 2), extent: o.$, radius: this._pixelsToTileUnits(h.clusterRadius || 50), log: !1, generateId: h.generateId || !1 }, clusterProperties: h.clusterProperties, filter: h.filter }, h.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
          }
          _pixelsToTileUnits(a) {
            return a * (o.$ / this.tileSize);
          }
          _getClusterMaxZoom(a) {
            const h = a ? Math.round(a) : this.maxzoom - 1;
            return Number.isInteger(a) || a === void 0 || o.w(`Integer expected for option 'clusterMaxZoom': provided value "${a}" rounded to "${h}"`), h;
          }
          load() {
            return o._(this, void 0, void 0, function* () {
              yield this._updateWorkerData();
            });
          }
          onAdd(a) {
            this.map = a, this.load();
          }
          setData(a) {
            return this._data = a, this._updateWorkerData(), this;
          }
          updateData(a) {
            return this._updateWorkerData(a), this;
          }
          getData() {
            return o._(this, void 0, void 0, function* () {
              const a = o.e({ type: this.type }, this.workerOptions);
              return this.actor.sendAsync({ type: "GD", data: a });
            });
          }
          getCoordinatesFromGeometry(a) {
            return a.type === "GeometryCollection" ? a.geometries.map((h) => h.coordinates).flat(1 / 0) : a.coordinates.flat(1 / 0);
          }
          getBounds() {
            return o._(this, void 0, void 0, function* () {
              const a = new sr(), h = yield this.getData();
              let g;
              switch (h.type) {
                case "FeatureCollection":
                  g = h.features.map((y) => this.getCoordinatesFromGeometry(y.geometry)).flat(1 / 0);
                  break;
                case "Feature":
                  g = this.getCoordinatesFromGeometry(h.geometry);
                  break;
                default:
                  g = this.getCoordinatesFromGeometry(h);
              }
              if (g.length == 0) return a;
              for (let y = 0; y < g.length - 1; y += 2) a.extend([g[y], g[y + 1]]);
              return a;
            });
          }
          setClusterOptions(a) {
            return this.workerOptions.cluster = a.cluster, a && (a.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(a.clusterRadius)), a.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(a.clusterMaxZoom))), this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(a) {
            return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: a, source: this.id } });
          }
          getClusterChildren(a) {
            return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: a, source: this.id } });
          }
          getClusterLeaves(a, h, g) {
            return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: a, limit: h, offset: g } });
          }
          _updateWorkerData(a) {
            return o._(this, void 0, void 0, function* () {
              const h = o.e({ type: this.type }, this.workerOptions);
              a ? h.dataDiff = a : typeof this._data == "string" ? (h.request = this.map._requestManager.transformRequest(M.resolveURL(this._data), "Source"), h.request.collectResourceTiming = this._collectResourceTiming) : h.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new o.l("dataloading", { dataType: "source" }));
              try {
                const g = yield this.actor.sendAsync({ type: "LD", data: h });
                if (this._pendingLoads--, this._removed || g.abandoned) return void this.fire(new o.l("dataabort", { dataType: "source" }));
                let y = null;
                g.resourceTiming && g.resourceTiming[this.id] && (y = g.resourceTiming[this.id].slice(0));
                const w = { dataType: "source" };
                this._collectResourceTiming && y && y.length > 0 && o.e(w, { resourceTiming: y }), this.fire(new o.l("data", Object.assign(Object.assign({}, w), { sourceDataType: "metadata" }))), this.fire(new o.l("data", Object.assign(Object.assign({}, w), { sourceDataType: "content" })));
              } catch (g) {
                if (this._pendingLoads--, this._removed) return void this.fire(new o.l("dataabort", { dataType: "source" }));
                this.fire(new o.k(g));
              }
            });
          }
          loaded() {
            return this._pendingLoads === 0;
          }
          loadTile(a) {
            return o._(this, void 0, void 0, function* () {
              const h = a.actor ? "RT" : "LT";
              a.actor = this.actor;
              const g = { type: this.type, uid: a.uid, tileID: a.tileID, zoom: a.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity, globalState: this.map.getGlobalState() };
              a.abortController = new AbortController();
              const y = yield this.actor.sendAsync({ type: h, data: g }, a.abortController);
              delete a.abortController, a.unloadVectorData(), a.aborted || a.loadVectorData(y, this.map.painter, h === "RT");
            });
          }
          abortTile(a) {
            return o._(this, void 0, void 0, function* () {
              a.abortController && (a.abortController.abort(), delete a.abortController), a.aborted = !0;
            });
          }
          unloadTile(a) {
            return o._(this, void 0, void 0, function* () {
              a.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: a.uid, type: this.type, source: this.id } });
            });
          }
          onRemove() {
            this._removed = !0, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
          }
          serialize() {
            return o.e({}, this._options, { type: this.type, data: this._data });
          }
          hasTransition() {
            return !1;
          }
        }
        class Yt extends o.E {
          constructor(a, h, g, y) {
            super(), this.flippedWindingOrder = !1, this.id = a, this.dispatcher = g, this.coordinates = h.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(y), this.options = h;
          }
          load(a) {
            return o._(this, void 0, void 0, function* () {
              this._loaded = !1, this.fire(new o.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
              try {
                const h = yield Z.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = !0, h && h.data && (this.image = h.data, a && (this.coordinates = a), this._finishLoading());
              } catch (h) {
                this._request = null, this._loaded = !0, this.fire(new o.k(h));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          updateImage(a) {
            return a.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = a.url, this.load(a.coordinates).finally(() => {
              this.texture = null;
            }), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new o.l("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(a) {
            this.map = a, this.load();
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null);
          }
          setCoordinates(a) {
            this.coordinates = a;
            const h = a.map(o.a0.fromLngLat);
            var g;
            return this.tileID = function(y) {
              const w = o.a1.fromPoints(y), C = w.width(), P = w.height(), L = Math.max(C, P), F = Math.max(0, Math.floor(-Math.log(L) / Math.LN2)), j = Math.pow(2, F);
              return new o.a3(F, Math.floor((w.minX + w.maxX) / 2 * j), Math.floor((w.minY + w.maxY) / 2 * j));
            }(h), this.terrainTileRanges = this._getOverlappingTileRanges(h), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = h.map((y) => this.tileID.getTilePoint(y)._round()), this.flippedWindingOrder = ((g = this.tileCoords)[1].x - g[0].x) * (g[2].y - g[0].y) - (g[1].y - g[0].y) * (g[2].x - g[0].x) < 0, this.fire(new o.l("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image) return;
            const a = this.map.painter.context, h = a.gl;
            this.texture || (this.texture = new o.T(a, this.image, h.RGBA), this.texture.bind(h.LINEAR, h.CLAMP_TO_EDGE));
            let g = !1;
            for (const y in this.tiles) {
              const w = this.tiles[y];
              w.state !== "loaded" && (w.state = "loaded", w.texture = this.texture, g = !0);
            }
            g && this.fire(new o.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          loadTile(a) {
            return o._(this, void 0, void 0, function* () {
              this.tileID && this.tileID.equals(a.tileID.canonical) ? (this.tiles[String(a.tileID.wrap)] = a, a.buckets = {}) : a.state = "errored";
            });
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return !1;
          }
          _getOverlappingTileRanges(a) {
            const { minX: h, minY: g, maxX: y, maxY: w } = o.a1.fromPoints(a), C = {};
            for (let P = 0; P <= o.a2; P++) {
              const L = Math.pow(2, P), F = Math.floor(h * L), j = Math.floor(g * L), X = Math.floor(y * L), G = Math.floor(w * L);
              C[P] = { minTileX: F, minTileY: j, maxTileX: X, maxTileY: G };
            }
            return C;
          }
        }
        class pr extends Yt {
          constructor(a, h, g, y) {
            super(a, h, g, y), this.roundZoom = !0, this.type = "video", this.options = h;
          }
          load() {
            return o._(this, void 0, void 0, function* () {
              this._loaded = !1;
              const a = this.options;
              this.urls = [];
              for (const h of a.urls) this.urls.push(this.map._requestManager.transformRequest(h, "Source").url);
              try {
                const h = yield o.a4(this.urls);
                if (this._loaded = !0, !h) return;
                this.video = h, this.video.loop = !0, this.video.addEventListener("playing", () => {
                  this.map.triggerRepaint();
                }), this.map && this.video.play(), this._finishLoading();
              } catch (h) {
                this.fire(new o.k(h));
              }
            });
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(a) {
            if (this.video) {
              const h = this.video.seekable;
              a < h.start(0) || a > h.end(0) ? this.fire(new o.k(new o.a5(`sources.${this.id}`, null, `Playback for this video can be set only between the ${h.start(0)} and ${h.end(0)}-second mark.`))) : this.video.currentTime = a;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(a) {
            this.map || (this.map = a, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const a = this.map.painter.context, h = a.gl;
            this.texture ? this.video.paused || (this.texture.bind(h.LINEAR, h.CLAMP_TO_EDGE), h.texSubImage2D(h.TEXTURE_2D, 0, 0, 0, h.RGBA, h.UNSIGNED_BYTE, this.video)) : (this.texture = new o.T(a, this.video, h.RGBA), this.texture.bind(h.LINEAR, h.CLAMP_TO_EDGE));
            let g = !1;
            for (const y in this.tiles) {
              const w = this.tiles[y];
              w.state !== "loaded" && (w.state = "loaded", w.texture = this.texture, g = !0);
            }
            g && this.fire(new o.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }
        class mr extends Yt {
          constructor(a, h, g, y) {
            super(a, h, g, y), h.coordinates ? Array.isArray(h.coordinates) && h.coordinates.length === 4 && !h.coordinates.some((w) => !Array.isArray(w) || w.length !== 2 || w.some((C) => typeof C != "number")) || this.fire(new o.k(new o.a5(`sources.${a}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new o.k(new o.a5(`sources.${a}`, null, 'missing required property "coordinates"'))), h.animate && typeof h.animate != "boolean" && this.fire(new o.k(new o.a5(`sources.${a}`, null, 'optional "animate" property must be a boolean value'))), h.canvas ? typeof h.canvas == "string" || h.canvas instanceof HTMLCanvasElement || this.fire(new o.k(new o.a5(`sources.${a}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new o.k(new o.a5(`sources.${a}`, null, 'missing required property "canvas"'))), this.options = h, this.animate = h.animate === void 0 || h.animate;
          }
          load() {
            return o._(this, void 0, void 0, function* () {
              this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new o.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = !0, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = !1);
              }, this._finishLoading());
            });
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(a) {
            this.map = a, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let a = !1;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, a = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, a = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const h = this.map.painter.context, g = h.gl;
            this.texture ? (a || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new o.T(h, this.canvas, g.RGBA, { premultiply: !0 });
            let y = !1;
            for (const w in this.tiles) {
              const C = this.tiles[w];
              C.state !== "loaded" && (C.state = "loaded", C.texture = this.texture, y = !0);
            }
            y && this.fire(new o.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "canvas", coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const a of [this.canvas.width, this.canvas.height]) if (isNaN(a) || a <= 0) return !0;
            return !1;
          }
        }
        const _r = {}, Lr = (v) => {
          switch (v) {
            case "geojson":
              return Tr;
            case "image":
              return Yt;
            case "raster":
              return We;
            case "raster-dem":
              return Dr;
            case "vector":
              return Nt;
            case "video":
              return pr;
            case "canvas":
              return mr;
          }
          return _r[v];
        }, qr = "RTLPluginLoaded";
        class Kr extends o.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = ht();
          }
          _syncState(a) {
            return this.status = a, this.dispatcher.broadcast("SRPS", { pluginStatus: a, pluginURL: this.url }).catch((h) => {
              throw this.status = "error", h;
            });
          }
          getRTLTextPluginStatus() {
            return this.status;
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null;
          }
          setRTLTextPlugin(a) {
            return o._(this, arguments, void 0, function(h) {
              var g = this;
              let y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
              return function* () {
                if (g.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
                if (g.url = M.resolveURL(h), !g.url) throw new Error(`requested url ${h} is invalid`);
                if (g.status === "unavailable") {
                  if (!y) return g._requestImport();
                  g.status = "deferred", g._syncState(g.status);
                } else if (g.status === "requested") return g._requestImport();
              }();
            });
          }
          _requestImport() {
            return o._(this, void 0, void 0, function* () {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new o.l(qr));
            });
          }
          lazyLoad() {
            this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
          }
        }
        let en = null;
        function nn() {
          return en || (en = new Kr()), en;
        }
        class vn {
          constructor(a, h) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = a, this.uid = o.a6(), this.uses = 0, this.tileSize = h, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
          }
          registerFadeDuration(a) {
            const h = a + this.timeAdded;
            h < this.fadeEndTime || (this.fadeEndTime = h);
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
          }
          clearTextures(a) {
            this.demTexture && a.saveTileTexture(this.demTexture), this.demTexture = null;
          }
          loadVectorData(a, h, g) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", a) {
              a.featureIndex && (this.latestFeatureIndex = a.featureIndex, a.rawTileData ? (this.latestRawTileData = a.rawTileData, this.latestFeatureIndex.rawTileData = a.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = a.collisionBoxArray, this.buckets = function(y, w) {
                const C = {};
                if (!w) return C;
                for (const P of y) {
                  const L = P.layerIds.map((F) => w.getLayer(F)).filter(Boolean);
                  if (L.length !== 0) {
                    P.layers = L, P.stateDependentLayerIds && (P.stateDependentLayers = P.stateDependentLayerIds.map((F) => L.filter((j) => j.id === F)[0]));
                    for (const F of L) C[F.id] = P;
                  }
                }
                return C;
              }(a.buckets, h == null ? void 0 : h.style), this.hasSymbolBuckets = !1;
              for (const y in this.buckets) {
                const w = this.buckets[y];
                if (w instanceof o.a8) {
                  if (this.hasSymbolBuckets = !0, !g) break;
                  w.justReloaded = !0;
                }
              }
              if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const y in this.buckets) {
                const w = this.buckets[y];
                if (w instanceof o.a8 && w.hasRTLText) {
                  this.hasRTLText = !0, nn().lazyLoad();
                  break;
                }
              }
              this.queryPadding = 0;
              for (const y in this.buckets) {
                const w = this.buckets[y];
                this.queryPadding = Math.max(this.queryPadding, h.style.getLayer(y).queryRadius(w));
              }
              a.imageAtlas && (this.imageAtlas = a.imageAtlas), a.glyphAtlasImage && (this.glyphAtlasImage = a.glyphAtlasImage);
            } else this.collisionBoxArray = new o.a7();
          }
          unloadVectorData() {
            for (const a in this.buckets) this.buckets[a].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
          }
          getBucket(a) {
            return this.buckets[a.id];
          }
          upload(a) {
            for (const g in this.buckets) {
              const y = this.buckets[g];
              y.uploadPending() && y.upload(a);
            }
            const h = a.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new o.T(a, this.imageAtlas.image, h.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new o.T(a, this.glyphAtlasImage, h.ALPHA), this.glyphAtlasImage = null);
          }
          prepare(a) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(a, this.imageAtlasTexture);
          }
          queryRenderedFeatures(a, h, g, y, w, C, P, L, F, j, X) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: y, cameraQueryGeometry: w, scale: C, tileSize: this.tileSize, pixelPosMatrix: j, transform: L, params: P, queryPadding: this.queryPadding * F, getElevation: X }, a, h, g) : {};
          }
          querySourceFeatures(a, h) {
            const g = this.latestFeatureIndex;
            if (!g || !g.rawTileData) return;
            const y = g.loadVTLayers(), w = h && h.sourceLayer ? h.sourceLayer : "", C = y._geojsonTileLayer || y[w];
            if (!C) return;
            const P = o.a9(h && h.filter), { z: L, x: F, y: j } = this.tileID.canonical, X = { z: L, x: F, y: j };
            for (let G = 0; G < C.length; G++) {
              const Q = C.feature(G);
              if (P.needGeometry) {
                const we = o.aa(Q, !0);
                if (!P.filter(new o.F(this.tileID.overscaledZ), we, this.tileID.canonical)) continue;
              } else if (!P.filter(new o.F(this.tileID.overscaledZ), Q)) continue;
              const le = g.getId(Q, w), Ae = new o.ab(Q, L, F, j, le);
              Ae.tile = X, a.push(Ae);
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(a) {
            const h = this.expirationTime;
            if (a.cacheControl) {
              const g = o.ac(a.cacheControl);
              g["max-age"] && (this.expirationTime = Date.now() + 1e3 * g["max-age"]);
            } else a.expires && (this.expirationTime = new Date(a.expires).getTime());
            if (this.expirationTime) {
              const g = Date.now();
              let y = !1;
              if (this.expirationTime > g) y = !1;
              else if (h)
                if (this.expirationTime < h) y = !0;
                else {
                  const w = this.expirationTime - h;
                  w ? this.expirationTime = g + Math.max(w, 3e4) : y = !0;
                }
              else y = !0;
              y ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(a, h) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(a).length === 0) return;
            const g = this.latestFeatureIndex.loadVTLayers();
            for (const y in this.buckets) {
              if (!h.style.hasLayer(y)) continue;
              const w = this.buckets[y], C = w.layers[0].sourceLayer || "_geojsonTileLayer", P = g[C], L = a[C];
              if (!P || !L || Object.keys(L).length === 0) continue;
              w.update(L, P, this.imageAtlas && this.imageAtlas.patternPositions || {});
              const F = h && h.style && h.style.getLayer(y);
              F && (this.queryPadding = Math.max(this.queryPadding, F.queryRadius(w)));
            }
          }
          holdingForFade() {
            return this.symbolFadeHoldUntil !== void 0;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < M.now();
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(a) {
            this.symbolFadeHoldUntil = M.now() + a;
          }
          setDependencies(a, h) {
            const g = {};
            for (const y of h) g[y] = !0;
            this.dependencies[a] = g;
          }
          hasDependency(a, h) {
            for (const g of a) {
              const y = this.dependencies[g];
              if (y) {
                for (const w of h) if (y[w]) return !0;
              }
            }
            return !1;
          }
        }
        class Hr {
          constructor(a, h) {
            this.max = a, this.onRemove = h, this.reset();
          }
          reset() {
            for (const a in this.data) for (const h of this.data[a]) h.timeout && clearTimeout(h.timeout), this.onRemove(h.value);
            return this.data = {}, this.order = [], this;
          }
          add(a, h, g) {
            const y = a.wrapped().key;
            this.data[y] === void 0 && (this.data[y] = []);
            const w = { value: h, timeout: void 0 };
            if (g !== void 0 && (w.timeout = setTimeout(() => {
              this.remove(a, w);
            }, g)), this.data[y].push(w), this.order.push(y), this.order.length > this.max) {
              const C = this._getAndRemoveByKey(this.order[0]);
              C && this.onRemove(C);
            }
            return this;
          }
          has(a) {
            return a.wrapped().key in this.data;
          }
          getAndRemove(a) {
            return this.has(a) ? this._getAndRemoveByKey(a.wrapped().key) : null;
          }
          _getAndRemoveByKey(a) {
            const h = this.data[a].shift();
            return h.timeout && clearTimeout(h.timeout), this.data[a].length === 0 && delete this.data[a], this.order.splice(this.order.indexOf(a), 1), h.value;
          }
          getByKey(a) {
            const h = this.data[a];
            return h ? h[0].value : null;
          }
          get(a) {
            return this.has(a) ? this.data[a.wrapped().key][0].value : null;
          }
          remove(a, h) {
            if (!this.has(a)) return this;
            const g = a.wrapped().key, y = h === void 0 ? 0 : this.data[g].indexOf(h), w = this.data[g][y];
            return this.data[g].splice(y, 1), w.timeout && clearTimeout(w.timeout), this.data[g].length === 0 && delete this.data[g], this.onRemove(w.value), this.order.splice(this.order.indexOf(g), 1), this;
          }
          setMaxSize(a) {
            for (this.max = a; this.order.length > this.max; ) {
              const h = this._getAndRemoveByKey(this.order[0]);
              h && this.onRemove(h);
            }
            return this;
          }
          filter(a) {
            const h = [];
            for (const g in this.data) for (const y of this.data[g]) a(y.value) || h.push(y);
            for (const g of h) this.remove(g.value.tileID, g);
          }
        }
        class fn {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(a, h, g) {
            const y = String(h);
            if (this.stateChanges[a] = this.stateChanges[a] || {}, this.stateChanges[a][y] = this.stateChanges[a][y] || {}, o.e(this.stateChanges[a][y], g), this.deletedStates[a] === null) {
              this.deletedStates[a] = {};
              for (const w in this.state[a]) w !== y && (this.deletedStates[a][w] = null);
            } else if (this.deletedStates[a] && this.deletedStates[a][y] === null) {
              this.deletedStates[a][y] = {};
              for (const w in this.state[a][y]) g[w] || (this.deletedStates[a][y][w] = null);
            } else for (const w in g) this.deletedStates[a] && this.deletedStates[a][y] && this.deletedStates[a][y][w] === null && delete this.deletedStates[a][y][w];
          }
          removeFeatureState(a, h, g) {
            if (this.deletedStates[a] === null) return;
            const y = String(h);
            if (this.deletedStates[a] = this.deletedStates[a] || {}, g && h !== void 0) this.deletedStates[a][y] !== null && (this.deletedStates[a][y] = this.deletedStates[a][y] || {}, this.deletedStates[a][y][g] = null);
            else if (h !== void 0)
              if (this.stateChanges[a] && this.stateChanges[a][y]) for (g in this.deletedStates[a][y] = {}, this.stateChanges[a][y]) this.deletedStates[a][y][g] = null;
              else this.deletedStates[a][y] = null;
            else this.deletedStates[a] = null;
          }
          getState(a, h) {
            const g = String(h), y = o.e({}, (this.state[a] || {})[g], (this.stateChanges[a] || {})[g]);
            if (this.deletedStates[a] === null) return {};
            if (this.deletedStates[a]) {
              const w = this.deletedStates[a][h];
              if (w === null) return {};
              for (const C in w) delete y[C];
            }
            return y;
          }
          initializeTileState(a, h) {
            a.setFeatureState(this.state, h);
          }
          coalesceChanges(a, h) {
            const g = {};
            for (const y in this.stateChanges) {
              this.state[y] = this.state[y] || {};
              const w = {};
              for (const C in this.stateChanges[y]) this.state[y][C] || (this.state[y][C] = {}), o.e(this.state[y][C], this.stateChanges[y][C]), w[C] = this.state[y][C];
              g[y] = w;
            }
            for (const y in this.deletedStates) {
              this.state[y] = this.state[y] || {};
              const w = {};
              if (this.deletedStates[y] === null) for (const C in this.state[y]) w[C] = {}, this.state[y][C] = {};
              else for (const C in this.deletedStates[y]) {
                if (this.deletedStates[y][C] === null) this.state[y][C] = {};
                else for (const P of Object.keys(this.deletedStates[y][C])) delete this.state[y][C][P];
                w[C] = this.state[y][C];
              }
              g[y] = g[y] || {}, o.e(g[y], w);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(g).length !== 0) for (const y in a) a[y].setFeatureState(g, h);
          }
        }
        const gr = 89.25;
        function nt(v, a) {
          const h = o.ag(a.lat, -85.051129, o.ah);
          return new o.P(o.V(a.lng) * v, o.U(h) * v);
        }
        function oe(v, a) {
          return new o.a0(a.x / v, a.y / v).toLngLat();
        }
        function fe(v) {
          return v.cameraToCenterDistance * Math.min(0.85 * Math.tan(o.ad(90 - v.pitch)), Math.tan(o.ad(gr - v.pitch)));
        }
        function ye(v, a) {
          const h = v.canonical, g = a / o.ae(h.z), y = h.x + Math.pow(2, h.z) * v.wrap, w = o.af(new Float64Array(16));
          return o.M(w, w, [y * g, h.y * g, 0]), o.N(w, w, [g / o.$, g / o.$, 1]), w;
        }
        function Le(v, a, h, g, y) {
          const w = o.a0.fromLngLat(v, a), C = y * o.ai(1, v.lat), P = C * Math.cos(o.ad(h)), L = Math.sqrt(C * C - P * P), F = L * Math.sin(o.ad(-g)), j = L * Math.cos(o.ad(-g));
          return new o.a0(w.x + F, w.y + j, w.z + P);
        }
        function Ye(v, a, h) {
          const g = a.intersectsFrustum(v);
          if (!h || g === 0) return g;
          const y = a.intersectsPlane(h);
          return y === 0 ? 0 : g === 2 && y === 2 ? 2 : 1;
        }
        function Qe(v, a, h) {
          let g = 0;
          const y = (h - a) / 10;
          for (let w = 0; w < 10; w++) g += y * Math.pow(Math.cos(a + (w + 0.5) / 10 * (h - a)), v);
          return g;
        }
        function gt(v, a) {
          return function(h, g, y, w, C) {
            const P = 2 * ((v - 1) / o.aj(Math.cos(o.ad(gr - C)) / Math.cos(o.ad(gr))) - 1), L = Math.acos(y / w), F = 2 * Qe(P - 1, 0, o.ad(C / 2)), j = Math.min(o.ad(gr), L + o.ad(C / 2)), X = Qe(P - 1, Math.min(j, L - o.ad(C / 2)), j), G = Math.atan(g / y), Q = Math.hypot(g, y);
            let le = h;
            return le += o.aj(w / Q / Math.max(0.5, Math.cos(o.ad(C / 2)))), le += P * o.aj(Math.cos(G)) / 2, le -= o.aj(Math.max(1, X / F / a)) / 2, le;
          };
        }
        const Ke = gt(9.314, 3);
        function Bt(v, a) {
          const h = (a.roundZoom ? Math.round : Math.floor)(v.zoom + o.aj(v.tileSize / a.tileSize));
          return Math.max(0, h);
        }
        function Pt(v, a) {
          const h = v.getCameraFrustum(), g = v.getClippingPlane(), y = v.screenPointToMercatorCoordinate(v.getCameraPoint()), w = o.a0.fromLngLat(v.center, v.elevation);
          y.z = w.z + Math.cos(v.pitchInRadians) * v.cameraToCenterDistance / v.worldSize;
          const C = v.getCoveringTilesDetailsProvider(), P = C.allowVariableZoom(v, a), L = Bt(v, a), F = a.minzoom || 0, j = a.maxzoom !== void 0 ? a.maxzoom : v.maxZoom, X = Math.min(Math.max(0, L), j), G = Math.pow(2, X), Q = [G * y.x, G * y.y, 0], le = [G * w.x, G * w.y, 0], Ae = Math.hypot(w.x - y.x, w.y - y.y), we = Math.abs(w.z - y.z), Te = Math.hypot(Ae, we), Me = (He) => ({ zoom: 0, x: 0, y: 0, wrap: He, fullyVisible: !1 }), Ve = [], De = [];
          if (v.renderWorldCopies && C.allowWorldCopies()) for (let He = 1; He <= 3; He++) Ve.push(Me(-He)), Ve.push(Me(He));
          for (Ve.push(Me(0)); Ve.length > 0; ) {
            const He = Ve.pop(), Ze = He.x, Fe = He.y;
            let it = He.fullyVisible;
            const bt = { x: Ze, y: Fe, z: He.zoom }, dt = C.getTileBoundingVolume(bt, He.wrap, v.elevation, a);
            if (!it) {
              const or = Ye(h, dt, g);
              if (or === 0) continue;
              it = or === 2;
            }
            const Tt = C.distanceToTile2d(y.x, y.y, bt, dt);
            let wt = L;
            P && (wt = (a.calculateTileZoom || Ke)(v.zoom + o.aj(v.tileSize / a.tileSize), Tt, we, Te, v.fov)), wt = (a.roundZoom ? Math.round : Math.floor)(wt), wt = Math.max(0, wt);
            const ir = Math.min(wt, j);
            if (He.wrap = C.getWrap(w, bt, He.wrap), He.zoom >= ir) {
              if (He.zoom < F) continue;
              const or = X - He.zoom, Vt = Q[0] - 0.5 - (Ze << or), xr = Q[1] - 0.5 - (Fe << or), an = a.reparseOverscaled ? Math.max(He.zoom, wt) : He.zoom;
              De.push({ tileID: new o.Z(He.zoom === j ? an : He.zoom, He.wrap, He.zoom, Ze, Fe), distanceSq: o.ak([le[0] - 0.5 - Ze, le[1] - 0.5 - Fe]), tileDistanceToCamera: Math.sqrt(Vt * Vt + xr * xr) });
            } else for (let or = 0; or < 4; or++) Ve.push({ zoom: He.zoom + 1, x: (Ze << 1) + or % 2, y: (Fe << 1) + (or >> 1), wrap: He.wrap, fullyVisible: it });
          }
          return De.sort((He, Ze) => He.distanceSq - Ze.distanceSq).map((He) => He.tileID);
        }
        const st = o.a1.fromPoints([new o.P(0, 0), new o.P(o.$, o.$)]);
        class ft extends o.E {
          constructor(a, h, g) {
            super(), this.id = a, this.dispatcher = g, this.on("data", (y) => this._dataHandler(y)), this.on("dataloading", () => {
              this._sourceErrored = !1;
            }), this.on("error", () => {
              this._sourceErrored = this._source.loaded();
            }), this._source = ((y, w, C, P) => {
              const L = new (Lr(w.type))(y, w, C, P);
              if (L.id !== y) throw new Error(`Expected Source id to be ${y} instead of ${L.id}`);
              return L;
            })(a, h, g, this), this._tiles = {}, this._cache = new Hr(0, (y) => this._unloadTile(y)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new fn(), this._didEmitContent = !1, this._updated = !1;
          }
          onAdd(a) {
            this.map = a, this._maxTileCacheSize = a ? a._maxTileCacheSize : null, this._maxTileCacheZoomLevels = a ? a._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(a);
          }
          onRemove(a) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(a);
          }
          loaded() {
            if (this._sourceErrored) return !0;
            if (!this._sourceLoaded || !this._source.loaded()) return !1;
            if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
            if (!this._updated) return !1;
            for (const a in this._tiles) {
              const h = this._tiles[a];
              if (h.state !== "loaded" && h.state !== "errored") return !1;
            }
            return !0;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = !0;
          }
          resume() {
            if (!this._paused) return;
            const a = this._shouldReloadOnResume;
            this._paused = !1, this._shouldReloadOnResume = !1, a && this.reload(), this.transform && this.update(this.transform, this.terrain);
          }
          _loadTile(a, h, g) {
            return o._(this, void 0, void 0, function* () {
              try {
                yield this._source.loadTile(a), this._tileLoaded(a, h, g);
              } catch (y) {
                a.state = "errored", y.status !== 404 ? this._source.fire(new o.k(y, { tile: a })) : this.update(this.transform, this.terrain);
              }
            });
          }
          _unloadTile(a) {
            this._source.unloadTile && this._source.unloadTile(a);
          }
          _abortTile(a) {
            this._source.abortTile && this._source.abortTile(a), this._source.fire(new o.l("dataabort", { tile: a, coord: a.tileID, dataType: "source" }));
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(a) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const h in this._tiles) {
              const g = this._tiles[h];
              g.upload(a), g.prepare(this.map.style.imageManager);
            }
          }
          getIds() {
            return Object.values(this._tiles).map((a) => a.tileID).sort(Ge).map((a) => a.key);
          }
          getRenderableIds(a) {
            const h = [];
            for (const g in this._tiles) this._isIdRenderable(g, a) && h.push(this._tiles[g]);
            return a ? h.sort((g, y) => {
              const w = g.tileID, C = y.tileID, P = new o.P(w.canonical.x, w.canonical.y)._rotate(-this.transform.bearingInRadians), L = new o.P(C.canonical.x, C.canonical.y)._rotate(-this.transform.bearingInRadians);
              return w.overscaledZ - C.overscaledZ || L.y - P.y || L.x - P.x;
            }).map((g) => g.tileID.key) : h.map((g) => g.tileID).sort(Ge).map((g) => g.key);
          }
          hasRenderableParent(a) {
            const h = this.findLoadedParent(a, 0);
            return !!h && this._isIdRenderable(h.tileID.key);
          }
          _isIdRenderable(a, h) {
            return this._tiles[a] && this._tiles[a].hasData() && !this._coveredTiles[a] && (h || !this._tiles[a].holdingForFade());
          }
          reload(a) {
            if (this._paused) this._shouldReloadOnResume = !0;
            else {
              this._cache.reset();
              for (const h in this._tiles) a ? this._reloadTile(h, "expired") : this._tiles[h].state !== "errored" && this._reloadTile(h, "reloading");
            }
          }
          _reloadTile(a, h) {
            return o._(this, void 0, void 0, function* () {
              const g = this._tiles[a];
              g && (g.state !== "loading" && (g.state = h), yield this._loadTile(g, a, h));
            });
          }
          _tileLoaded(a, h, g) {
            a.timeAdded = M.now(), g === "expired" && (a.refreshedUponExpiration = !0), this._setTileReloadTimer(h, a), this.getSource().type === "raster-dem" && a.dem && this._backfillDEM(a), this._state.initializeTileState(a, this.map ? this.map.painter : null), a.aborted || this._source.fire(new o.l("data", { dataType: "source", tile: a, coord: a.tileID }));
          }
          _backfillDEM(a) {
            const h = this.getRenderableIds();
            for (let y = 0; y < h.length; y++) {
              const w = h[y];
              if (a.neighboringTiles && a.neighboringTiles[w]) {
                const C = this.getTileByID(w);
                g(a, C), g(C, a);
              }
            }
            function g(y, w) {
              y.needsHillshadePrepare = !0, y.needsTerrainPrepare = !0;
              let C = w.tileID.canonical.x - y.tileID.canonical.x;
              const P = w.tileID.canonical.y - y.tileID.canonical.y, L = Math.pow(2, y.tileID.canonical.z), F = w.tileID.key;
              C === 0 && P === 0 || Math.abs(P) > 1 || (Math.abs(C) > 1 && (Math.abs(C + L) === 1 ? C += L : Math.abs(C - L) === 1 && (C -= L)), w.dem && y.dem && (y.dem.backfillBorder(w.dem, C, P), y.neighboringTiles && y.neighboringTiles[F] && (y.neighboringTiles[F].backfilled = !0)));
            }
          }
          getTile(a) {
            return this.getTileByID(a.key);
          }
          getTileByID(a) {
            return this._tiles[a];
          }
          _retainLoadedChildren(a, h, g, y) {
            for (const w in this._tiles) {
              let C = this._tiles[w];
              if (y[w] || !C.hasData() || C.tileID.overscaledZ <= h || C.tileID.overscaledZ > g) continue;
              let P = C.tileID;
              for (; C && C.tileID.overscaledZ > h + 1; ) {
                const F = C.tileID.scaledTo(C.tileID.overscaledZ - 1);
                C = this._tiles[F.key], C && C.hasData() && (P = F);
              }
              let L = P;
              for (; L.overscaledZ > h; ) if (L = L.scaledTo(L.overscaledZ - 1), a[L.key] || a[L.canonical.key]) {
                y[P.key] = P;
                break;
              }
            }
          }
          findLoadedParent(a, h) {
            if (a.key in this._loadedParentTiles) {
              const g = this._loadedParentTiles[a.key];
              return g && g.tileID.overscaledZ >= h ? g : null;
            }
            for (let g = a.overscaledZ - 1; g >= h; g--) {
              const y = a.scaledTo(g), w = this._getLoadedTile(y);
              if (w) return w;
            }
          }
          findLoadedSibling(a) {
            return this._getLoadedTile(a);
          }
          _getLoadedTile(a) {
            const h = this._tiles[a.key];
            return h && h.hasData() ? h : this._cache.getByKey(a.wrapped().key);
          }
          updateCacheSize(a) {
            const h = Math.ceil(a.width / this._source.tileSize) + 1, g = Math.ceil(a.height / this._source.tileSize) + 1, y = Math.floor(h * g * (this._maxTileCacheZoomLevels === null ? o.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), w = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, y) : y;
            this._cache.setMaxSize(w);
          }
          handleWrapJump(a) {
            const h = Math.round((a - (this._prevLng === void 0 ? a : this._prevLng)) / 360);
            if (this._prevLng = a, h) {
              const g = {};
              for (const y in this._tiles) {
                const w = this._tiles[y];
                w.tileID = w.tileID.unwrapTo(w.tileID.wrap + h), g[w.tileID.key] = w;
              }
              this._tiles = g;
              for (const y in this._timers) clearTimeout(this._timers[y]), delete this._timers[y];
              for (const y in this._tiles) this._setTileReloadTimer(y, this._tiles[y]);
            }
          }
          _updateCoveredAndRetainedTiles(a, h, g, y, w, C) {
            const P = {}, L = {}, F = Object.keys(a), j = M.now();
            for (const X of F) {
              const G = a[X], Q = this._tiles[X];
              if (!Q || Q.fadeEndTime !== 0 && Q.fadeEndTime <= j) continue;
              const le = this.findLoadedParent(G, h), Ae = this.findLoadedSibling(G), we = le || Ae || null;
              we && (this._addTile(we.tileID), P[we.tileID.key] = we.tileID), L[X] = G;
            }
            this._retainLoadedChildren(L, y, g, a);
            for (const X in P) a[X] || (this._coveredTiles[X] = !0, a[X] = P[X]);
            if (C) {
              const X = {}, G = {};
              for (const Q of w) this._tiles[Q.key].hasData() ? X[Q.key] = Q : G[Q.key] = Q;
              for (const Q in G) {
                const le = G[Q].children(this._source.maxzoom);
                this._tiles[le[0].key] && this._tiles[le[1].key] && this._tiles[le[2].key] && this._tiles[le[3].key] && (X[le[0].key] = a[le[0].key] = le[0], X[le[1].key] = a[le[1].key] = le[1], X[le[2].key] = a[le[2].key] = le[2], X[le[3].key] = a[le[3].key] = le[3], delete G[Q]);
              }
              for (const Q in G) {
                const le = G[Q], Ae = this.findLoadedParent(le, this._source.minzoom), we = this.findLoadedSibling(le), Te = Ae || we || null;
                if (Te) {
                  X[Te.tileID.key] = a[Te.tileID.key] = Te.tileID;
                  for (const Me in X) X[Me].isChildOf(Te.tileID) && delete X[Me];
                }
              }
              for (const Q in this._tiles) X[Q] || (this._coveredTiles[Q] = !0);
            }
          }
          update(a, h) {
            if (!this._sourceLoaded || this._paused) return;
            let g;
            this.transform = a, this.terrain = h, this.updateCacheSize(a), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? g = a.getVisibleUnwrappedCoordinates(this._source.tileID).map((j) => new o.Z(j.canonical.z, j.wrap, j.canonical.z, j.canonical.x, j.canonical.y)) : (g = Pt(a, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: h, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (g = g.filter((j) => this._source.hasTile(j)))) : g = [];
            const y = Bt(a, this._source), w = Math.max(y - ft.maxOverzooming, this._source.minzoom), C = Math.max(y + ft.maxUnderzooming, this._source.minzoom);
            if (this.usedForTerrain) {
              const j = {};
              for (const X of g) if (X.canonical.z > this._source.minzoom) {
                const G = X.scaledTo(X.canonical.z - 1);
                j[G.key] = G;
                const Q = X.scaledTo(Math.max(this._source.minzoom, Math.min(X.canonical.z, 5)));
                j[Q.key] = Q;
              }
              g = g.concat(Object.values(j));
            }
            const P = g.length === 0 && !this._updated && this._didEmitContent;
            this._updated = !0, P && this.fire(new o.l("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
            const L = this._updateRetainedTiles(g, y);
            ur(this._source.type) && this._updateCoveredAndRetainedTiles(L, w, C, y, g, h);
            for (const j in L) this._tiles[j].clearFadeHold();
            const F = o.al(this._tiles, L);
            for (const j of F) {
              const X = this._tiles[j];
              X.hasSymbolBuckets && !X.holdingForFade() ? X.setHoldDuration(this.map._fadeDuration) : X.hasSymbolBuckets && !X.symbolFadeFinished() || this._removeTile(j);
            }
            this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
          }
          releaseSymbolFadeTiles() {
            for (const a in this._tiles) this._tiles[a].holdingForFade() && this._removeTile(a);
          }
          _updateRetainedTiles(a, h) {
            var g;
            const y = {}, w = {}, C = Math.max(h - ft.maxOverzooming, this._source.minzoom), P = Math.max(h + ft.maxUnderzooming, this._source.minzoom), L = {};
            for (const F of a) {
              const j = this._addTile(F);
              y[F.key] = F, j.hasData() || h < this._source.maxzoom && (L[F.key] = F);
            }
            this._retainLoadedChildren(L, h, P, y);
            for (const F of a) {
              let j = this._tiles[F.key];
              if (j.hasData()) continue;
              if (h + 1 > this._source.maxzoom) {
                const G = F.children(this._source.maxzoom)[0], Q = this.getTile(G);
                if (Q && Q.hasData()) {
                  y[G.key] = G;
                  continue;
                }
              } else {
                const G = F.children(this._source.maxzoom);
                if (y[G[0].key] && y[G[1].key] && y[G[2].key] && y[G[3].key]) continue;
              }
              let X = j.wasRequested();
              for (let G = F.overscaledZ - 1; G >= C; --G) {
                const Q = F.scaledTo(G);
                if (w[Q.key]) break;
                if (w[Q.key] = !0, j = this.getTile(Q), !j && X && (j = this._addTile(Q)), j) {
                  const le = j.hasData();
                  if ((le || !(!((g = this.map) === null || g === void 0) && g.cancelPendingTileRequestsWhileZooming) || X) && (y[Q.key] = Q), X = j.wasRequested(), le) break;
                }
              }
            }
            return y;
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const a in this._tiles) {
              const h = [];
              let g, y = this._tiles[a].tileID;
              for (; y.overscaledZ > 0; ) {
                if (y.key in this._loadedParentTiles) {
                  g = this._loadedParentTiles[y.key];
                  break;
                }
                h.push(y.key);
                const w = y.scaledTo(y.overscaledZ - 1);
                if (g = this._getLoadedTile(w), g) break;
                y = w;
              }
              for (const w of h) this._loadedParentTiles[w] = g;
            }
          }
          _updateLoadedSiblingTileCache() {
            this._loadedSiblingTiles = {};
            for (const a in this._tiles) {
              const h = this._tiles[a].tileID, g = this._getLoadedTile(h);
              this._loadedSiblingTiles[h.key] = g;
            }
          }
          _addTile(a) {
            let h = this._tiles[a.key];
            if (h) return h;
            h = this._cache.getAndRemove(a), h && (this._setTileReloadTimer(a.key, h), h.tileID = a, this._state.initializeTileState(h, this.map ? this.map.painter : null), this._cacheTimers[a.key] && (clearTimeout(this._cacheTimers[a.key]), delete this._cacheTimers[a.key], this._setTileReloadTimer(a.key, h)));
            const g = h;
            return h || (h = new vn(a, this._source.tileSize * a.overscaleFactor()), this._loadTile(h, a.key, h.state)), h.uses++, this._tiles[a.key] = h, g || this._source.fire(new o.l("dataloading", { tile: h, coord: h.tileID, dataType: "source" })), h;
          }
          _setTileReloadTimer(a, h) {
            a in this._timers && (clearTimeout(this._timers[a]), delete this._timers[a]);
            const g = h.getExpiryTimeout();
            g && (this._timers[a] = setTimeout(() => {
              this._reloadTile(a, "expired"), delete this._timers[a];
            }, g));
          }
          refreshTiles(a) {
            for (const h in this._tiles) (this._isIdRenderable(h) || this._tiles[h].state == "errored") && a.some((g) => g.equals(this._tiles[h].tileID.canonical)) && this._reloadTile(h, "expired");
          }
          _removeTile(a) {
            const h = this._tiles[a];
            h && (h.uses--, delete this._tiles[a], this._timers[a] && (clearTimeout(this._timers[a]), delete this._timers[a]), h.uses > 0 || (h.hasData() && h.state !== "reloading" ? this._cache.add(h.tileID, h, h.getExpiryTimeout()) : (h.aborted = !0, this._abortTile(h), this._unloadTile(h))));
          }
          _dataHandler(a) {
            const h = a.sourceDataType;
            a.dataType === "source" && h === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && a.dataType === "source" && h === "content" && (this.reload(a.sourceDataChanged), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0);
          }
          clearTiles() {
            this._shouldReloadOnResume = !1, this._paused = !1;
            for (const a in this._tiles) this._removeTile(a);
            this._cache.reset();
          }
          tilesIn(a, h, g) {
            const y = [], w = this.transform;
            if (!w) return y;
            const C = w.getCoveringTilesDetailsProvider().allowWorldCopies(), P = g ? w.getCameraQueryGeometry(a) : a, L = (Q) => w.screenPointToMercatorCoordinate(Q, this.terrain), F = this.transformBbox(a, L, !C), j = this.transformBbox(P, L, !C), X = this.getIds(), G = o.a1.fromPoints(j);
            for (let Q = 0; Q < X.length; Q++) {
              const le = this._tiles[X[Q]];
              if (le.holdingForFade()) continue;
              const Ae = C ? [le.tileID] : [le.tileID.unwrapTo(-1), le.tileID.unwrapTo(0)], we = Math.pow(2, w.zoom - le.tileID.overscaledZ), Te = h * le.queryPadding * o.$ / le.tileSize / we;
              for (const Me of Ae) {
                const Ve = G.map((De) => Me.getTilePoint(new o.a0(De.x, De.y)));
                if (Ve.expandBy(Te), Ve.intersects(st)) {
                  const De = F.map((Ze) => Me.getTilePoint(Ze)), He = j.map((Ze) => Me.getTilePoint(Ze));
                  y.push({ tile: le, tileID: C ? Me : Me.unwrapTo(0), queryGeometry: De, cameraQueryGeometry: He, scale: we });
                }
              }
            }
            return y;
          }
          transformBbox(a, h, g) {
            let y = a.map(h);
            if (g) {
              const w = o.a1.fromPoints(a);
              w.shrinkBy(1e-3 * Math.min(w.width(), w.height()));
              const C = w.map(h);
              o.a1.fromPoints(y).covers(C) || (y = y.map((P) => P.x > 0.5 ? new o.a0(P.x - 1, P.y, P.z) : P));
            }
            return y;
          }
          getVisibleCoordinates(a) {
            const h = this.getRenderableIds(a).map((g) => this._tiles[g].tileID);
            return this.transform && this.transform.populateCache(h), h;
          }
          hasTransition() {
            if (this._source.hasTransition()) return !0;
            if (ur(this._source.type)) {
              const a = M.now();
              for (const h in this._tiles) if (this._tiles[h].fadeEndTime >= a) return !0;
            }
            return !1;
          }
          setFeatureState(a, h, g) {
            this._state.updateState(a = a || "_geojsonTileLayer", h, g);
          }
          removeFeatureState(a, h, g) {
            this._state.removeFeatureState(a = a || "_geojsonTileLayer", h, g);
          }
          getFeatureState(a, h) {
            return this._state.getState(a = a || "_geojsonTileLayer", h);
          }
          setDependencies(a, h, g) {
            const y = this._tiles[a];
            y && y.setDependencies(h, g);
          }
          reloadTilesForDependencies(a, h) {
            for (const g in this._tiles) this._tiles[g].hasDependency(a, h) && this._reloadTile(g, "reloading");
            this._cache.filter((g) => !g.hasDependency(a, h));
          }
        }
        function Ge(v, a) {
          const h = Math.abs(2 * v.wrap) - +(v.wrap < 0), g = Math.abs(2 * a.wrap) - +(a.wrap < 0);
          return v.overscaledZ - a.overscaledZ || g - h || a.canonical.y - v.canonical.y || a.canonical.x - v.canonical.x;
        }
        function ur(v) {
          return v === "raster" || v === "image" || v === "video";
        }
        ft.maxOverzooming = 10, ft.maxUnderzooming = 3;
        class Sr {
          constructor(a, h) {
            this.reset(a, h);
          }
          reset(a, h) {
            this.points = a || [], this._distances = [0];
            for (let g = 1; g < this.points.length; g++) this._distances[g] = this._distances[g - 1] + this.points[g].dist(this.points[g - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(h || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(a) {
            if (this.points.length === 1) return this.points[0];
            a = o.ag(a, 0, 1);
            let h = 1, g = this._distances[h];
            const y = a * this.paddedLength + this.padding;
            for (; g < y && h < this._distances.length; ) g = this._distances[++h];
            const w = h - 1, C = this._distances[w], P = g - C, L = P > 0 ? (y - C) / P : 0;
            return this.points[w].mult(1 - L).add(this.points[h].mult(L));
          }
        }
        function lr(v, a) {
          let h = !0;
          return v === "always" || v !== "never" && a !== "never" || (h = !1), h;
        }
        class Er {
          constructor(a, h, g) {
            const y = this.boxCells = [], w = this.circleCells = [];
            this.xCellCount = Math.ceil(a / g), this.yCellCount = Math.ceil(h / g);
            for (let C = 0; C < this.xCellCount * this.yCellCount; C++) y.push([]), w.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = a, this.height = h, this.xScale = this.xCellCount / a, this.yScale = this.yCellCount / h, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(a, h, g, y, w) {
            this._forEachCell(h, g, y, w, this._insertBoxCell, this.boxUid++), this.boxKeys.push(a), this.bboxes.push(h), this.bboxes.push(g), this.bboxes.push(y), this.bboxes.push(w);
          }
          insertCircle(a, h, g, y) {
            this._forEachCell(h - y, g - y, h + y, g + y, this._insertCircleCell, this.circleUid++), this.circleKeys.push(a), this.circles.push(h), this.circles.push(g), this.circles.push(y);
          }
          _insertBoxCell(a, h, g, y, w, C) {
            this.boxCells[w].push(C);
          }
          _insertCircleCell(a, h, g, y, w, C) {
            this.circleCells[w].push(C);
          }
          _query(a, h, g, y, w, C, P) {
            if (g < 0 || a > this.width || y < 0 || h > this.height) return [];
            const L = [];
            if (a <= 0 && h <= 0 && this.width <= g && this.height <= y) {
              if (w) return [{ key: null, x1: a, y1: h, x2: g, y2: y }];
              for (let F = 0; F < this.boxKeys.length; F++) L.push({ key: this.boxKeys[F], x1: this.bboxes[4 * F], y1: this.bboxes[4 * F + 1], x2: this.bboxes[4 * F + 2], y2: this.bboxes[4 * F + 3] });
              for (let F = 0; F < this.circleKeys.length; F++) {
                const j = this.circles[3 * F], X = this.circles[3 * F + 1], G = this.circles[3 * F + 2];
                L.push({ key: this.circleKeys[F], x1: j - G, y1: X - G, x2: j + G, y2: X + G });
              }
            } else this._forEachCell(a, h, g, y, this._queryCell, L, { hitTest: w, overlapMode: C, seenUids: { box: {}, circle: {} } }, P);
            return L;
          }
          query(a, h, g, y) {
            return this._query(a, h, g, y, !1, null);
          }
          hitTest(a, h, g, y, w, C) {
            return this._query(a, h, g, y, !0, w, C).length > 0;
          }
          hitTestCircle(a, h, g, y, w) {
            const C = a - g, P = a + g, L = h - g, F = h + g;
            if (P < 0 || C > this.width || F < 0 || L > this.height) return !1;
            const j = [];
            return this._forEachCell(C, L, P, F, this._queryCellCircle, j, { hitTest: !0, overlapMode: y, circle: { x: a, y: h, radius: g }, seenUids: { box: {}, circle: {} } }, w), j.length > 0;
          }
          _queryCell(a, h, g, y, w, C, P, L) {
            const { seenUids: F, hitTest: j, overlapMode: X } = P, G = this.boxCells[w];
            if (G !== null) {
              const le = this.bboxes;
              for (const Ae of G) if (!F.box[Ae]) {
                F.box[Ae] = !0;
                const we = 4 * Ae, Te = this.boxKeys[Ae];
                if (a <= le[we + 2] && h <= le[we + 3] && g >= le[we + 0] && y >= le[we + 1] && (!L || L(Te)) && (!j || !lr(X, Te.overlapMode)) && (C.push({ key: Te, x1: le[we], y1: le[we + 1], x2: le[we + 2], y2: le[we + 3] }), j)) return !0;
              }
            }
            const Q = this.circleCells[w];
            if (Q !== null) {
              const le = this.circles;
              for (const Ae of Q) if (!F.circle[Ae]) {
                F.circle[Ae] = !0;
                const we = 3 * Ae, Te = this.circleKeys[Ae];
                if (this._circleAndRectCollide(le[we], le[we + 1], le[we + 2], a, h, g, y) && (!L || L(Te)) && (!j || !lr(X, Te.overlapMode))) {
                  const Me = le[we], Ve = le[we + 1], De = le[we + 2];
                  if (C.push({ key: Te, x1: Me - De, y1: Ve - De, x2: Me + De, y2: Ve + De }), j) return !0;
                }
              }
            }
            return !1;
          }
          _queryCellCircle(a, h, g, y, w, C, P, L) {
            const { circle: F, seenUids: j, overlapMode: X } = P, G = this.boxCells[w];
            if (G !== null) {
              const le = this.bboxes;
              for (const Ae of G) if (!j.box[Ae]) {
                j.box[Ae] = !0;
                const we = 4 * Ae, Te = this.boxKeys[Ae];
                if (this._circleAndRectCollide(F.x, F.y, F.radius, le[we + 0], le[we + 1], le[we + 2], le[we + 3]) && (!L || L(Te)) && !lr(X, Te.overlapMode)) return C.push(!0), !0;
              }
            }
            const Q = this.circleCells[w];
            if (Q !== null) {
              const le = this.circles;
              for (const Ae of Q) if (!j.circle[Ae]) {
                j.circle[Ae] = !0;
                const we = 3 * Ae, Te = this.circleKeys[Ae];
                if (this._circlesCollide(le[we], le[we + 1], le[we + 2], F.x, F.y, F.radius) && (!L || L(Te)) && !lr(X, Te.overlapMode)) return C.push(!0), !0;
              }
            }
          }
          _forEachCell(a, h, g, y, w, C, P, L) {
            const F = this._convertToXCellCoord(a), j = this._convertToYCellCoord(h), X = this._convertToXCellCoord(g), G = this._convertToYCellCoord(y);
            for (let Q = F; Q <= X; Q++) for (let le = j; le <= G; le++) if (w.call(this, a, h, g, y, this.xCellCount * le + Q, C, P, L)) return;
          }
          _convertToXCellCoord(a) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(a * this.xScale)));
          }
          _convertToYCellCoord(a) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(a * this.yScale)));
          }
          _circlesCollide(a, h, g, y, w, C) {
            const P = y - a, L = w - h, F = g + C;
            return F * F > P * P + L * L;
          }
          _circleAndRectCollide(a, h, g, y, w, C, P) {
            const L = (C - y) / 2, F = Math.abs(a - (y + L));
            if (F > L + g) return !1;
            const j = (P - w) / 2, X = Math.abs(h - (w + j));
            if (X > j + g) return !1;
            if (F <= L || X <= j) return !0;
            const G = F - L, Q = X - j;
            return G * G + Q * Q <= g * g;
          }
        }
        function tr(v, a, h) {
          const g = o.L();
          if (!v) {
            const { vecSouth: X, vecEast: G } = dn(a), Q = m();
            Q[0] = G[0], Q[1] = G[1], Q[2] = X[0], Q[3] = X[1], y = Q, (j = (C = (w = Q)[0]) * (F = w[3]) - (L = w[2]) * (P = w[1])) && (y[0] = F * (j = 1 / j), y[1] = -P * j, y[2] = -L * j, y[3] = C * j), g[0] = Q[0], g[1] = Q[1], g[4] = Q[2], g[5] = Q[3];
          }
          var y, w, C, P, L, F, j;
          return o.N(g, g, [1 / h, 1 / h, 1]), g;
        }
        function xn(v, a, h, g) {
          if (v) {
            const y = o.L();
            if (!a) {
              const { vecSouth: w, vecEast: C } = dn(h);
              y[0] = C[0], y[1] = C[1], y[4] = w[0], y[5] = w[1];
            }
            return o.N(y, y, [g, g, 1]), y;
          }
          return h.pixelsToClipSpaceMatrix;
        }
        function dn(v) {
          const a = Math.cos(v.rollInRadians), h = Math.sin(v.rollInRadians), g = Math.cos(v.pitchInRadians), y = Math.cos(v.bearingInRadians), w = Math.sin(v.bearingInRadians), C = o.aq();
          C[0] = -y * g * h - w * a, C[1] = -w * g * h + y * a;
          const P = o.ar(C);
          P < 1e-9 ? o.as(C) : o.at(C, C, 1 / P);
          const L = o.aq();
          L[0] = y * g * a - w * h, L[1] = w * g * a + y * h;
          const F = o.ar(L);
          return F < 1e-9 ? o.as(L) : o.at(L, L, 1 / F), { vecEast: L, vecSouth: C };
        }
        function Jr(v, a, h, g) {
          let y;
          g ? (y = [v, a, g(v, a), 1], o.av(y, y, h)) : (y = [v, a, 0, 1], va(y, y, h));
          const w = y[3];
          return { point: new o.P(y[0] / w, y[1] / w), signedDistanceFromCamera: w, isOccluded: !1 };
        }
        function Cr(v, a) {
          return 0.5 + v / a * 0.5;
        }
        function zr(v, a) {
          return v.x >= -a[0] && v.x <= a[0] && v.y >= -a[1] && v.y <= a[1];
        }
        function Dn(v, a, h, g, y, w, C, P, L, F, j, X, G) {
          const Q = h ? v.textSizeData : v.iconSizeData, le = o.am(Q, a.transform.zoom), Ae = [256 / a.width * 2 + 1, 256 / a.height * 2 + 1], we = h ? v.text.dynamicLayoutVertexArray : v.icon.dynamicLayoutVertexArray;
          we.clear();
          const Te = v.lineVertexArray, Me = h ? v.text.placedSymbolArray : v.icon.placedSymbolArray, Ve = a.transform.width / a.transform.height;
          let De = !1;
          for (let He = 0; He < Me.length; He++) {
            const Ze = Me.get(He);
            if (Ze.hidden || Ze.writingMode === o.an.vertical && !De) {
              io(Ze.numGlyphs, we);
              continue;
            }
            De = !1;
            const Fe = new o.P(Ze.anchorX, Ze.anchorY), it = { getElevation: G, pitchedLabelPlaneMatrix: g, lineVertexArray: Te, pitchWithMap: w, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: a.transform, tileAnchorPoint: Fe, unwrappedTileID: L, width: F, height: j, translation: X }, bt = Gr(Ze.anchorX, Ze.anchorY, it);
            if (!zr(bt.point, Ae)) {
              io(Ze.numGlyphs, we);
              continue;
            }
            const dt = Cr(a.transform.cameraToCenterDistance, bt.signedDistanceFromCamera), Tt = o.ao(Q, le, Ze), wt = w ? Tt * a.transform.getPitchedTextCorrection(Ze.anchorX, Ze.anchorY, L) / dt : Tt * dt, ir = Mn({ projectionContext: it, pitchedLabelPlaneMatrixInverse: y, symbol: Ze, fontSize: wt, flip: !1, keepUpright: C, glyphOffsetArray: v.glyphOffsetArray, dynamicLayoutVertexArray: we, aspectRatio: Ve, rotateToLine: P });
            De = ir.useVertical, (ir.notEnoughRoom || De || ir.needsFlipping && Mn({ projectionContext: it, pitchedLabelPlaneMatrixInverse: y, symbol: Ze, fontSize: wt, flip: !0, keepUpright: C, glyphOffsetArray: v.glyphOffsetArray, dynamicLayoutVertexArray: we, aspectRatio: Ve, rotateToLine: P }).notEnoughRoom) && io(Ze.numGlyphs, we);
          }
          h ? v.text.dynamicLayoutVertexBuffer.updateData(we) : v.icon.dynamicLayoutVertexBuffer.updateData(we);
        }
        function er(v, a, h, g, y, w, C, P) {
          const L = w.glyphStartIndex + w.numGlyphs, F = w.lineStartIndex, j = w.lineStartIndex + w.lineLength, X = a.getoffsetX(w.glyphStartIndex), G = a.getoffsetX(L - 1), Q = Vs(v * X, h, g, y, w.segment, F, j, P, C);
          if (!Q) return null;
          const le = Vs(v * G, h, g, y, w.segment, F, j, P, C);
          return le ? P.projectionCache.anyProjectionOccluded ? null : { first: Q, last: le } : null;
        }
        function oi(v, a, h, g) {
          return v === o.an.horizontal && Math.abs(h.y - a.y) > Math.abs(h.x - a.x) * g ? { useVertical: !0 } : (v === o.an.vertical ? a.y < h.y : a.x > h.x) ? { needsFlipping: !0 } : null;
        }
        function Mn(v) {
          const { projectionContext: a, pitchedLabelPlaneMatrixInverse: h, symbol: g, fontSize: y, flip: w, keepUpright: C, glyphOffsetArray: P, dynamicLayoutVertexArray: L, aspectRatio: F, rotateToLine: j } = v, X = y / 24, G = g.lineOffsetX * X, Q = g.lineOffsetY * X;
          let le;
          if (g.numGlyphs > 1) {
            const Ae = g.glyphStartIndex + g.numGlyphs, we = g.lineStartIndex, Te = g.lineStartIndex + g.lineLength, Me = er(X, P, G, Q, w, g, j, a);
            if (!Me) return { notEnoughRoom: !0 };
            const Ve = Vr(Me.first.point.x, Me.first.point.y, a, h), De = Vr(Me.last.point.x, Me.last.point.y, a, h);
            if (C && !w) {
              const He = oi(g.writingMode, Ve, De, F);
              if (He) return He;
            }
            le = [Me.first];
            for (let He = g.glyphStartIndex + 1; He < Ae - 1; He++) {
              const Ze = Vs(X * P.getoffsetX(He), G, Q, w, g.segment, we, Te, a, j);
              if (!Ze) return { notEnoughRoom: !0 };
              le.push(Ze);
            }
            le.push(Me.last);
          } else {
            if (C && !w) {
              const we = rr(a.tileAnchorPoint.x, a.tileAnchorPoint.y, a).point, Te = g.lineStartIndex + g.segment + 1, Me = new o.P(a.lineVertexArray.getx(Te), a.lineVertexArray.gety(Te)), Ve = rr(Me.x, Me.y, a), De = Ve.signedDistanceFromCamera > 0 ? Ve.point : rs(a.tileAnchorPoint, Me, we, 1, a), He = Vr(we.x, we.y, a, h), Ze = Vr(De.x, De.y, a, h), Fe = oi(g.writingMode, He, Ze, F);
              if (Fe) return Fe;
            }
            const Ae = Vs(X * P.getoffsetX(g.glyphStartIndex), G, Q, w, g.segment, g.lineStartIndex, g.lineStartIndex + g.lineLength, a, j);
            if (!Ae || a.projectionCache.anyProjectionOccluded) return { notEnoughRoom: !0 };
            le = [Ae];
          }
          for (const Ae of le) o.au(L, Ae.point, Ae.angle);
          return {};
        }
        function rs(v, a, h, g, y) {
          const w = v.add(v.sub(a)._unit()), C = rr(w.x, w.y, y).point, P = h.sub(C);
          return h.add(P._mult(g / P.mag()));
        }
        function _s(v, a, h) {
          const g = a.projectionCache;
          if (g.projections[v]) return g.projections[v];
          const y = new o.P(a.lineVertexArray.getx(v), a.lineVertexArray.gety(v)), w = rr(y.x, y.y, a);
          if (w.signedDistanceFromCamera > 0) return g.projections[v] = w.point, g.anyProjectionOccluded = g.anyProjectionOccluded || w.isOccluded, w.point;
          const C = v - h.direction;
          return rs(h.distanceFromAnchor === 0 ? a.tileAnchorPoint : new o.P(a.lineVertexArray.getx(C), a.lineVertexArray.gety(C)), y, h.previousVertex, h.absOffsetX - h.distanceFromAnchor + 1, a);
        }
        function rr(v, a, h) {
          const g = v + h.translation[0], y = a + h.translation[1];
          let w;
          return h.pitchWithMap ? (w = Jr(g, y, h.pitchedLabelPlaneMatrix, h.getElevation), w.isOccluded = !1) : (w = h.transform.projectTileCoordinates(g, y, h.unwrappedTileID, h.getElevation), w.point.x = (0.5 * w.point.x + 0.5) * h.width, w.point.y = (0.5 * -w.point.y + 0.5) * h.height), w;
        }
        function Vr(v, a, h, g) {
          if (h.pitchWithMap) {
            const y = [v, a, 0, 1];
            return o.av(y, y, g), h.transform.projectTileCoordinates(y[0] / y[3], y[1] / y[3], h.unwrappedTileID, h.getElevation).point;
          }
          return { x: v / h.width * 2 - 1, y: a / h.height * 2 - 1 };
        }
        function Gr(v, a, h) {
          return h.transform.projectTileCoordinates(v, a, h.unwrappedTileID, h.getElevation);
        }
        function Hi(v, a, h) {
          return v._unit()._perp()._mult(a * h);
        }
        function Ga(v, a, h, g, y, w, C, P, L) {
          if (P.projectionCache.offsets[v]) return P.projectionCache.offsets[v];
          const F = h.add(a);
          if (v + L.direction < g || v + L.direction >= y) return P.projectionCache.offsets[v] = F, F;
          const j = _s(v + L.direction, P, L), X = Hi(j.sub(h), C, L.direction), G = h.add(X), Q = j.add(X);
          return P.projectionCache.offsets[v] = o.aw(w, F, G, Q) || F, P.projectionCache.offsets[v];
        }
        function Vs(v, a, h, g, y, w, C, P, L) {
          const F = g ? v - a : v + a;
          let j = F > 0 ? 1 : -1, X = 0;
          g && (j *= -1, X = Math.PI), j < 0 && (X += Math.PI);
          let G, Q = j > 0 ? w + y : w + y + 1;
          P.projectionCache.cachedAnchorPoint ? G = P.projectionCache.cachedAnchorPoint : (G = rr(P.tileAnchorPoint.x, P.tileAnchorPoint.y, P).point, P.projectionCache.cachedAnchorPoint = G);
          let le, Ae, we = G, Te = G, Me = 0, Ve = 0;
          const De = Math.abs(F), He = [];
          let Ze;
          for (; Me + Ve <= De; ) {
            if (Q += j, Q < w || Q >= C) return null;
            Me += Ve, Te = we, Ae = le;
            const bt = { absOffsetX: De, direction: j, distanceFromAnchor: Me, previousVertex: Te };
            if (we = _s(Q, P, bt), h === 0) He.push(Te), Ze = we.sub(Te);
            else {
              let dt;
              const Tt = we.sub(Te);
              dt = Tt.mag() === 0 ? Hi(_s(Q + j, P, bt).sub(we), h, j) : Hi(Tt, h, j), Ae || (Ae = Te.add(dt)), le = Ga(Q, dt, we, w, C, Ae, h, P, bt), He.push(Ae), Ze = le.sub(Ae);
            }
            Ve = Ze.mag();
          }
          const Fe = Ze._mult((De - Me) / Ve)._add(Ae || Te), it = X + Math.atan2(we.y - Te.y, we.x - Te.x);
          return He.push(Fe), { point: Fe, angle: L ? it : 0, path: He };
        }
        const Xr = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function io(v, a) {
          for (let h = 0; h < v; h++) {
            const g = a.length;
            a.resize(g + 4), a.float32.set(Xr, 3 * g);
          }
        }
        function va(v, a, h) {
          const g = a[0], y = a[1];
          return v[0] = h[0] * g + h[4] * y + h[12], v[1] = h[1] * g + h[5] * y + h[13], v[3] = h[3] * g + h[7] * y + h[15], v;
        }
        const bi = 100;
        class Vl {
          constructor(a) {
            let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Er(a.width + 200, a.height + 200, 25), g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Er(a.width + 200, a.height + 200, 25);
            this.transform = a, this.grid = h, this.ignoredGrid = g, this.pitchFactor = Math.cos(a.pitch * Math.PI / 180) * a.cameraToCenterDistance, this.screenRightBoundary = a.width + bi, this.screenBottomBoundary = a.height + bi, this.gridRightBoundary = a.width + 200, this.gridBottomBoundary = a.height + 200, this.perspectiveRatioCutoff = 0.6;
          }
          placeCollisionBox(a, h, g, y, w, C, P, L, F, j, X, G) {
            const Q = this.projectAndGetPerspectiveRatio(a.anchorPointX + L[0], a.anchorPointY + L[1], w, j, G), le = g * Q.perspectiveRatio;
            let Ae;
            if (C || P) Ae = this._projectCollisionBox(a, le, y, w, C, P, L, Q, j, X, G);
            else {
              const Ze = Q.x + (X ? X.x * le : 0), Fe = Q.y + (X ? X.y * le : 0);
              Ae = { allPointsOccluded: !1, box: [Ze + a.x1 * le, Fe + a.y1 * le, Ze + a.x2 * le, Fe + a.y2 * le] };
            }
            const [we, Te, Me, Ve] = Ae.box, De = C ? Ae.allPointsOccluded : Q.isOccluded;
            let He = De;
            return He || (He = Q.perspectiveRatio < this.perspectiveRatioCutoff), He || (He = !this.isInsideGrid(we, Te, Me, Ve)), He || h !== "always" && this.grid.hitTest(we, Te, Me, Ve, h, F) ? { box: [we, Te, Me, Ve], placeable: !1, offscreen: !1, occluded: De } : { box: [we, Te, Me, Ve], placeable: !0, offscreen: this.isOffscreen(we, Te, Me, Ve), occluded: De };
          }
          placeCollisionCircles(a, h, g, y, w, C, P, L, F, j, X, G, Q, le) {
            const Ae = [], we = new o.P(h.anchorX, h.anchorY), Te = this.getPerspectiveRatio(we.x, we.y, C, le), Me = (F ? w * this.transform.getPitchedTextCorrection(h.anchorX, h.anchorY, C) / Te : w * Te) / o.aA, Ve = { getElevation: le, pitchedLabelPlaneMatrix: P, lineVertexArray: g, pitchWithMap: F, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: this.transform, tileAnchorPoint: we, unwrappedTileID: C, width: this.transform.width, height: this.transform.height, translation: Q }, De = er(Me, y, h.lineOffsetX * Me, h.lineOffsetY * Me, !1, h, !1, Ve);
            let He = !1, Ze = !1, Fe = !0;
            if (De) {
              const it = 0.5 * X * Te + G, bt = new o.P(-100, -100), dt = new o.P(this.screenRightBoundary, this.screenBottomBoundary), Tt = new Sr(), wt = De.first, ir = De.last;
              let or = [];
              for (let an = wt.path.length - 1; an >= 1; an--) or.push(wt.path[an]);
              for (let an = 1; an < ir.path.length; an++) or.push(ir.path[an]);
              const Vt = 2.5 * it;
              if (F) {
                const an = this.projectPathToScreenSpace(or, Ve);
                or = an.some((An) => An.signedDistanceFromCamera <= 0) ? [] : an.map((An) => An.point);
              }
              let xr = [];
              if (or.length > 0) {
                const an = or[0].clone(), An = or[0].clone();
                for (let ni = 1; ni < or.length; ni++) an.x = Math.min(an.x, or[ni].x), an.y = Math.min(an.y, or[ni].y), An.x = Math.max(An.x, or[ni].x), An.y = Math.max(An.y, or[ni].y);
                xr = an.x >= bt.x && An.x <= dt.x && an.y >= bt.y && An.y <= dt.y ? [or] : An.x < bt.x || an.x > dt.x || An.y < bt.y || an.y > dt.y ? [] : o.ax([or], bt.x, bt.y, dt.x, dt.y);
              }
              for (const an of xr) {
                Tt.reset(an, 0.25 * it);
                let An = 0;
                An = Tt.length <= 0.5 * it ? 1 : Math.ceil(Tt.paddedLength / Vt) + 1;
                for (let ni = 0; ni < An; ni++) {
                  const On = ni / Math.max(An - 1, 1), kn = Tt.lerp(On), In = kn.x + bi, En = kn.y + bi;
                  Ae.push(In, En, it, 0);
                  const Nn = In - it, Ji = En - it, yn = In + it, as = En + it;
                  if (Fe = Fe && this.isOffscreen(Nn, Ji, yn, as), Ze = Ze || this.isInsideGrid(Nn, Ji, yn, as), a !== "always" && this.grid.hitTestCircle(In, En, it, a, j) && (He = !0, !L)) return { circles: [], offscreen: !1, collisionDetected: He };
                }
              }
            }
            return { circles: !L && He || !Ze || Te < this.perspectiveRatioCutoff ? [] : Ae, offscreen: Fe, collisionDetected: He };
          }
          projectPathToScreenSpace(a, h) {
            const g = function(y, w) {
              const C = o.L();
              return o.ap(C, w.pitchedLabelPlaneMatrix), y.map((P) => {
                const L = Jr(P.x, P.y, C, w.getElevation), F = w.transform.projectTileCoordinates(L.point.x, L.point.y, w.unwrappedTileID, w.getElevation);
                return F.point.x = (0.5 * F.point.x + 0.5) * w.width, F.point.y = (0.5 * -F.point.y + 0.5) * w.height, F;
              });
            }(a, h);
            return function(y) {
              let w = 0, C = 0, P = 0, L = 0;
              for (let F = 0; F < y.length; F++) y[F].isOccluded ? (P = F + 1, L = 0) : (L++, L > C && (C = L, w = P));
              return y.slice(w, w + C);
            }(g);
          }
          queryRenderedSymbols(a) {
            if (a.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const h = [], g = new o.a1();
            for (const X of a) {
              const G = new o.P(X.x + bi, X.y + bi);
              g.extend(G), h.push(G);
            }
            const { minX: y, minY: w, maxX: C, maxY: P } = g, L = this.grid.query(y, w, C, P).concat(this.ignoredGrid.query(y, w, C, P)), F = {}, j = {};
            for (const X of L) {
              const G = X.key;
              if (F[G.bucketInstanceId] === void 0 && (F[G.bucketInstanceId] = {}), F[G.bucketInstanceId][G.featureIndex]) continue;
              const Q = [new o.P(X.x1, X.y1), new o.P(X.x2, X.y1), new o.P(X.x2, X.y2), new o.P(X.x1, X.y2)];
              o.ay(h, Q) && (F[G.bucketInstanceId][G.featureIndex] = !0, j[G.bucketInstanceId] === void 0 && (j[G.bucketInstanceId] = []), j[G.bucketInstanceId].push(G.featureIndex));
            }
            return j;
          }
          insertCollisionBox(a, h, g, y, w, C) {
            (g ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: y, featureIndex: w, collisionGroupID: C, overlapMode: h }, a[0], a[1], a[2], a[3]);
          }
          insertCollisionCircles(a, h, g, y, w, C) {
            const P = g ? this.ignoredGrid : this.grid, L = { bucketInstanceId: y, featureIndex: w, collisionGroupID: C, overlapMode: h };
            for (let F = 0; F < a.length; F += 4) P.insertCircle(L, a[F], a[F + 1], a[F + 2]);
          }
          projectAndGetPerspectiveRatio(a, h, g, y, w) {
            if (w) {
              let C;
              y ? (C = [a, h, y(a, h), 1], o.av(C, C, w)) : (C = [a, h, 0, 1], va(C, C, w));
              const P = C[3];
              return { x: (C[0] / P + 1) / 2 * this.transform.width + bi, y: (-C[1] / P + 1) / 2 * this.transform.height + bi, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / P * 0.5, isOccluded: !1, signedDistanceFromCamera: P };
            }
            {
              const C = this.transform.projectTileCoordinates(a, h, g, y);
              return { x: (C.point.x + 1) / 2 * this.transform.width + bi, y: (1 - C.point.y) / 2 * this.transform.height + bi, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / C.signedDistanceFromCamera * 0.5, isOccluded: C.isOccluded, signedDistanceFromCamera: C.signedDistanceFromCamera };
            }
          }
          getPerspectiveRatio(a, h, g, y) {
            const w = this.transform.projectTileCoordinates(a, h, g, y);
            return 0.5 + this.transform.cameraToCenterDistance / w.signedDistanceFromCamera * 0.5;
          }
          isOffscreen(a, h, g, y) {
            return g < bi || a >= this.screenRightBoundary || y < bi || h > this.screenBottomBoundary;
          }
          isInsideGrid(a, h, g, y) {
            return g >= 0 && a < this.gridRightBoundary && y >= 0 && h < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const a = o.af([]);
            return o.M(a, a, [-100, -100, 0]), a;
          }
          _projectCollisionBox(a, h, g, y, w, C, P, L, F, j, X) {
            let G = 1, Q = 0, le = 0, Ae = 1;
            const we = a.anchorPointX + P[0], Te = a.anchorPointY + P[1];
            if (C && !w) {
              const or = this.projectAndGetPerspectiveRatio(we + 1, Te, y, F, X), Vt = or.x - L.x, xr = Math.atan((or.y - L.y) / Vt) + (Vt < 0 ? Math.PI : 0), an = Math.sin(xr), An = Math.cos(xr);
              G = An, Q = an, le = -an, Ae = An;
            } else if (!C && w) {
              const or = dn(this.transform);
              G = or.vecEast[0], Q = or.vecEast[1], le = or.vecSouth[0], Ae = or.vecSouth[1];
            }
            let Me = L.x, Ve = L.y, De = h;
            w && (Me = we, Ve = Te, De = Math.pow(2, -(this.transform.zoom - g.overscaledZ)), De *= this.transform.getPitchedTextCorrection(we, Te, y), j || (De *= o.ag(0.5 + L.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4))), j && (Me += G * j.x * De + le * j.y * De, Ve += Q * j.x * De + Ae * j.y * De);
            const He = a.x1 * De, Ze = a.x2 * De, Fe = (He + Ze) / 2, it = a.y1 * De, bt = a.y2 * De, dt = (it + bt) / 2, Tt = [{ offsetX: He, offsetY: it }, { offsetX: Fe, offsetY: it }, { offsetX: Ze, offsetY: it }, { offsetX: Ze, offsetY: dt }, { offsetX: Ze, offsetY: bt }, { offsetX: Fe, offsetY: bt }, { offsetX: He, offsetY: bt }, { offsetX: He, offsetY: dt }];
            let wt = [];
            for (const { offsetX: or, offsetY: Vt } of Tt) wt.push(new o.P(Me + G * or + le * Vt, Ve + Q * or + Ae * Vt));
            let ir = !1;
            if (w) {
              const or = wt.map((Vt) => this.projectAndGetPerspectiveRatio(Vt.x, Vt.y, y, F, X));
              ir = or.some((Vt) => !Vt.isOccluded), wt = or.map((Vt) => new o.P(Vt.x, Vt.y));
            } else ir = !0;
            return { box: o.az(wt), allPointsOccluded: !ir };
          }
        }
        class xa {
          constructor(a, h, g, y) {
            this.opacity = a ? Math.max(0, Math.min(1, a.opacity + (a.placed ? h : -h))) : y && g ? 1 : 0, this.placed = g;
          }
          isHidden() {
            return this.opacity === 0 && !this.placed;
          }
        }
        class Po {
          constructor(a, h, g, y, w) {
            this.text = new xa(a ? a.text : null, h, g, w), this.icon = new xa(a ? a.icon : null, h, y, w);
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class $l {
          constructor(a, h, g) {
            this.text = a, this.icon = h, this.skipFade = g;
          }
        }
        class ys {
          constructor(a, h, g, y, w) {
            this.bucketInstanceId = a, this.featureIndex = h, this.sourceLayerIndex = g, this.bucketIndex = y, this.tileID = w;
          }
        }
        class ti {
          constructor(a) {
            this.crossSourceCollisions = a, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(a) {
            if (this.crossSourceCollisions) return { ID: 0, predicate: null };
            if (!this.collisionGroups[a]) {
              const h = ++this.maxGroupID;
              this.collisionGroups[a] = { ID: h, predicate: (g) => g.collisionGroupID === h };
            }
            return this.collisionGroups[a];
          }
        }
        function vu(v, a, h, g, y) {
          const { horizontalAlign: w, verticalAlign: C } = o.aG(v);
          return new o.P(-(w - 0.5) * a + g[0] * y, -(C - 0.5) * h + g[1] * y);
        }
        class ql {
          constructor(a, h, g, y, w) {
            this.transform = a.clone(), this.terrain = h, this.collisionIndex = new Vl(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = g, this.retainedQueryData = {}, this.collisionGroups = new ti(y), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = w, w && (w.prevPlacement = void 0), this.placedOrientations = {};
          }
          _getTerrainElevationFunc(a) {
            const h = this.terrain;
            return h ? (g, y) => h.getElevation(a, g, y) : null;
          }
          getBucketParts(a, h, g, y) {
            const w = g.getBucket(h), C = g.latestFeatureIndex;
            if (!w || !C || h.id !== w.layerIds[0]) return;
            const P = g.collisionBoxArray, L = w.layers[0].layout, F = w.layers[0].paint, j = Math.pow(2, this.transform.zoom - g.tileID.overscaledZ), X = g.tileSize / o.$, G = g.tileID.toUnwrapped(), Q = L.get("text-rotation-alignment") === "map", le = o.aB(g, 1, this.transform.zoom), Ae = o.aC(this.collisionIndex.transform, g, F.get("text-translate"), F.get("text-translate-anchor")), we = o.aC(this.collisionIndex.transform, g, F.get("icon-translate"), F.get("icon-translate-anchor")), Te = tr(Q, this.transform, le);
            this.retainedQueryData[w.bucketInstanceId] = new ys(w.bucketInstanceId, C, w.sourceLayerIndex, w.index, g.tileID);
            const Me = { bucket: w, layout: L, translationText: Ae, translationIcon: we, unwrappedTileID: G, pitchedLabelPlaneMatrix: Te, scale: j, textPixelRatio: X, holdingForFade: g.holdingForFade(), collisionBoxArray: P, partiallyEvaluatedTextSize: o.am(w.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(w.sourceID) };
            if (y) for (const Ve of w.sortKeyRanges) {
              const { sortKey: De, symbolInstanceStart: He, symbolInstanceEnd: Ze } = Ve;
              a.push({ sortKey: De, symbolInstanceStart: He, symbolInstanceEnd: Ze, parameters: Me });
            }
            else a.push({ symbolInstanceStart: 0, symbolInstanceEnd: w.symbolInstances.length, parameters: Me });
          }
          attemptAnchorPlacement(a, h, g, y, w, C, P, L, F, j, X, G, Q, le, Ae, we, Te, Me, Ve, De) {
            const He = o.aD[a.textAnchor], Ze = [a.textOffset0, a.textOffset1], Fe = vu(He, g, y, Ze, w), it = this.collisionIndex.placeCollisionBox(h, G, L, F, j, P, C, we, X.predicate, Ve, Fe, De);
            if ((!Me || this.collisionIndex.placeCollisionBox(Me, G, L, F, j, P, C, Te, X.predicate, Ve, Fe, De).placeable) && it.placeable) {
              let bt;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[Q.crossTileID] && this.prevPlacement.placements[Q.crossTileID] && this.prevPlacement.placements[Q.crossTileID].text && (bt = this.prevPlacement.variableOffsets[Q.crossTileID].anchor), Q.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[Q.crossTileID] = { textOffset: Ze, width: g, height: y, anchor: He, textBoxScale: w, prevAnchor: bt }, this.markUsedJustification(le, He, Q, Ae), le.allowVerticalPlacement && (this.markUsedOrientation(le, Ae, Q), this.placedOrientations[Q.crossTileID] = Ae), { shift: Fe, placedGlyphBoxes: it };
            }
          }
          placeLayerBucketPart(a, h, g) {
            const { bucket: y, layout: w, translationText: C, translationIcon: P, unwrappedTileID: L, pitchedLabelPlaneMatrix: F, textPixelRatio: j, holdingForFade: X, collisionBoxArray: G, partiallyEvaluatedTextSize: Q, collisionGroup: le } = a.parameters, Ae = w.get("text-optional"), we = w.get("icon-optional"), Te = o.aE(w, "text-overlap", "text-allow-overlap"), Me = Te === "always", Ve = o.aE(w, "icon-overlap", "icon-allow-overlap"), De = Ve === "always", He = w.get("text-rotation-alignment") === "map", Ze = w.get("text-pitch-alignment") === "map", Fe = w.get("icon-text-fit") !== "none", it = w.get("symbol-z-order") === "viewport-y", bt = Me && (De || !y.hasIconData() || we), dt = De && (Me || !y.hasTextData() || Ae);
            !y.collisionArrays && G && y.deserializeCollisionBoxes(G);
            const Tt = this.retainedQueryData[y.bucketInstanceId].tileID, wt = this._getTerrainElevationFunc(Tt), ir = this.transform.getFastPathSimpleProjectionMatrix(Tt), or = (Vt, xr, an) => {
              var An, ni;
              if (h[Vt.crossTileID]) return;
              if (X) return void (this.placements[Vt.crossTileID] = new $l(!1, !1, !1));
              let On = !1, kn = !1, In = !0, En = null, Nn = { box: null, placeable: !1, offscreen: null, occluded: !1 }, Ji = { placeable: !1 }, yn = null, as = null, Qi = null, Na = 0, tu = 0, ru = 0;
              xr.textFeatureIndex ? Na = xr.textFeatureIndex : Vt.useRuntimeCollisionCircles && (Na = Vt.featureIndex), xr.verticalTextFeatureIndex && (tu = xr.verticalTextFeatureIndex);
              const Rl = xr.textBox;
              if (Rl) {
                const $o = ($i) => {
                  let gi = o.an.horizontal;
                  if (y.allowVerticalPlacement && !$i && this.prevPlacement) {
                    const Eo = this.prevPlacement.placedOrientations[Vt.crossTileID];
                    Eo && (this.placedOrientations[Vt.crossTileID] = Eo, gi = Eo, this.markUsedOrientation(y, gi, Vt));
                  }
                  return gi;
                }, ol = ($i, gi) => {
                  if (y.allowVerticalPlacement && Vt.numVerticalGlyphVertices > 0 && xr.verticalTextBox) {
                    for (const Eo of y.writingModes) if (Eo === o.an.vertical ? (Nn = gi(), Ji = Nn) : Nn = $i(), Nn && Nn.placeable) break;
                  } else Nn = $i();
                }, nu = Vt.textAnchorOffsetStartIndex, $u = Vt.textAnchorOffsetEndIndex;
                if ($u === nu) {
                  const $i = (gi, Eo) => {
                    const As = this.collisionIndex.placeCollisionBox(gi, Te, j, Tt, L, Ze, He, C, le.predicate, wt, void 0, ir);
                    return As && As.placeable && (this.markUsedOrientation(y, Eo, Vt), this.placedOrientations[Vt.crossTileID] = Eo), As;
                  };
                  ol(() => $i(Rl, o.an.horizontal), () => {
                    const gi = xr.verticalTextBox;
                    return y.allowVerticalPlacement && Vt.numVerticalGlyphVertices > 0 && gi ? $i(gi, o.an.vertical) : { box: null, offscreen: null };
                  }), $o(Nn && Nn.placeable);
                } else {
                  let $i = o.aD[(ni = (An = this.prevPlacement) === null || An === void 0 ? void 0 : An.variableOffsets[Vt.crossTileID]) === null || ni === void 0 ? void 0 : ni.anchor];
                  const gi = (As, rm, i0) => {
                    const Tp = As.x2 - As.x1, af = As.y2 - As.y1, xh = Vt.textBoxScale, ac = Fe && Ve === "never" ? rm : null;
                    let Ks = null, lc = Te === "never" ? 1 : 2, Sp = "never";
                    $i && lc++;
                    for (let iu = 0; iu < lc; iu++) {
                      for (let Ep = nu; Ep < $u; Ep++) {
                        const Cp = y.textAnchorOffsets.get(Ep);
                        if ($i && Cp.textAnchor !== $i) continue;
                        const lf = this.attemptAnchorPlacement(Cp, As, Tp, af, xh, He, Ze, j, Tt, L, le, Sp, Vt, y, i0, C, P, ac, wt);
                        if (lf && (Ks = lf.placedGlyphBoxes, Ks && Ks.placeable)) return On = !0, En = lf.shift, Ks;
                      }
                      $i ? $i = null : Sp = Te;
                    }
                    return g && !Ks && (Ks = { box: this.collisionIndex.placeCollisionBox(Rl, "always", j, Tt, L, Ze, He, C, le.predicate, wt, void 0, ir).box, offscreen: !1, placeable: !1, occluded: !1 }), Ks;
                  };
                  ol(() => gi(Rl, xr.iconBox, o.an.horizontal), () => {
                    const As = xr.verticalTextBox;
                    return y.allowVerticalPlacement && (!Nn || !Nn.placeable) && Vt.numVerticalGlyphVertices > 0 && As ? gi(As, xr.verticalIconBox, o.an.vertical) : { box: null, occluded: !0, offscreen: null };
                  }), Nn && (On = Nn.placeable, In = Nn.offscreen);
                  const Eo = $o(Nn && Nn.placeable);
                  if (!On && this.prevPlacement) {
                    const As = this.prevPlacement.variableOffsets[Vt.crossTileID];
                    As && (this.variableOffsets[Vt.crossTileID] = As, this.markUsedJustification(y, As.anchor, Vt, Eo));
                  }
                }
              }
              if (yn = Nn, On = yn && yn.placeable, In = yn && yn.offscreen, Vt.useRuntimeCollisionCircles) {
                const $o = y.text.placedSymbolArray.get(Vt.centerJustifiedTextSymbolIndex), ol = o.ao(y.textSizeData, Q, $o), nu = w.get("text-padding");
                as = this.collisionIndex.placeCollisionCircles(Te, $o, y.lineVertexArray, y.glyphOffsetArray, ol, L, F, g, Ze, le.predicate, Vt.collisionCircleDiameter, nu, C, wt), as.circles.length && as.collisionDetected && !g && o.w("Collisions detected, but collision boxes are not shown"), On = Me || as.circles.length > 0 && !as.collisionDetected, In = In && as.offscreen;
              }
              if (xr.iconFeatureIndex && (ru = xr.iconFeatureIndex), xr.iconBox) {
                const $o = (ol) => this.collisionIndex.placeCollisionBox(ol, Ve, j, Tt, L, Ze, He, P, le.predicate, wt, Fe && En ? En : void 0, ir);
                Ji && Ji.placeable && xr.verticalIconBox ? (Qi = $o(xr.verticalIconBox), kn = Qi.placeable) : (Qi = $o(xr.iconBox), kn = Qi.placeable), In = In && Qi.offscreen;
              }
              const sf = Ae || Vt.numHorizontalGlyphVertices === 0 && Vt.numVerticalGlyphVertices === 0, of = we || Vt.numIconVertices === 0;
              sf || of ? of ? sf || (kn = kn && On) : On = kn && On : kn = On = kn && On;
              const vh = kn && Qi.placeable;
              if (On && yn.placeable && this.collisionIndex.insertCollisionBox(yn.box, Te, w.get("text-ignore-placement"), y.bucketInstanceId, Ji && Ji.placeable && tu ? tu : Na, le.ID), vh && this.collisionIndex.insertCollisionBox(Qi.box, Ve, w.get("icon-ignore-placement"), y.bucketInstanceId, ru, le.ID), as && On && this.collisionIndex.insertCollisionCircles(as.circles, Te, w.get("text-ignore-placement"), y.bucketInstanceId, Na, le.ID), g && this.storeCollisionData(y.bucketInstanceId, an, xr, yn, Qi, as), Vt.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              if (y.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
              this.placements[Vt.crossTileID] = new $l((On || bt) && !(yn != null && yn.occluded), (kn || dt) && !(Qi != null && Qi.occluded), In || y.justReloaded), h[Vt.crossTileID] = !0;
            };
            if (it) {
              if (a.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
              const Vt = y.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let xr = Vt.length - 1; xr >= 0; --xr) {
                const an = Vt[xr];
                or(y.symbolInstances.get(an), y.collisionArrays[an], an);
              }
            } else for (let Vt = a.symbolInstanceStart; Vt < a.symbolInstanceEnd; Vt++) or(y.symbolInstances.get(Vt), y.collisionArrays[Vt], Vt);
            y.justReloaded = !1;
          }
          storeCollisionData(a, h, g, y, w, C) {
            if (g.textBox || g.iconBox) {
              let P, L;
              this.collisionBoxArrays.has(a) ? P = this.collisionBoxArrays.get(a) : (P = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(a, P)), P.has(h) ? L = P.get(h) : (L = { text: null, icon: null }, P.set(h, L)), g.textBox && (L.text = y.box), g.iconBox && (L.icon = w.box);
            }
            if (C) {
              let P = this.collisionCircleArrays[a];
              P === void 0 && (P = this.collisionCircleArrays[a] = []);
              for (let L = 0; L < C.circles.length; L += 4) P.push(C.circles[L + 0] - bi), P.push(C.circles[L + 1] - bi), P.push(C.circles[L + 2]), P.push(C.collisionDetected ? 1 : 0);
            }
          }
          markUsedJustification(a, h, g, y) {
            let w;
            w = y === o.an.vertical ? g.verticalPlacedTextSymbolIndex : { left: g.leftJustifiedTextSymbolIndex, center: g.centerJustifiedTextSymbolIndex, right: g.rightJustifiedTextSymbolIndex }[o.aF(h)];
            const C = [g.leftJustifiedTextSymbolIndex, g.centerJustifiedTextSymbolIndex, g.rightJustifiedTextSymbolIndex, g.verticalPlacedTextSymbolIndex];
            for (const P of C) P >= 0 && (a.text.placedSymbolArray.get(P).crossTileID = w >= 0 && P !== w ? 0 : g.crossTileID);
          }
          markUsedOrientation(a, h, g) {
            const y = h === o.an.horizontal || h === o.an.horizontalOnly ? h : 0, w = h === o.an.vertical ? h : 0, C = [g.leftJustifiedTextSymbolIndex, g.centerJustifiedTextSymbolIndex, g.rightJustifiedTextSymbolIndex];
            for (const P of C) a.text.placedSymbolArray.get(P).placedOrientation = y;
            g.verticalPlacedTextSymbolIndex && (a.text.placedSymbolArray.get(g.verticalPlacedTextSymbolIndex).placedOrientation = w);
          }
          commit(a) {
            this.commitTime = a, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const h = this.prevPlacement;
            let g = !1;
            this.prevZoomAdjustment = h ? h.zoomAdjustment(this.transform.zoom) : 0;
            const y = h ? h.symbolFadeChange(a) : 1, w = h ? h.opacities : {}, C = h ? h.variableOffsets : {}, P = h ? h.placedOrientations : {};
            for (const L in this.placements) {
              const F = this.placements[L], j = w[L];
              j ? (this.opacities[L] = new Po(j, y, F.text, F.icon), g = g || F.text !== j.text.placed || F.icon !== j.icon.placed) : (this.opacities[L] = new Po(null, y, F.text, F.icon, F.skipFade), g = g || F.text || F.icon);
            }
            for (const L in w) {
              const F = w[L];
              if (!this.opacities[L]) {
                const j = new Po(F, y, !1, !1);
                j.isHidden() || (this.opacities[L] = j, g = g || F.text.placed || F.icon.placed);
              }
            }
            for (const L in C) this.variableOffsets[L] || !this.opacities[L] || this.opacities[L].isHidden() || (this.variableOffsets[L] = C[L]);
            for (const L in P) this.placedOrientations[L] || !this.opacities[L] || this.opacities[L].isHidden() || (this.placedOrientations[L] = P[L]);
            if (h && h.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
            g ? this.lastPlacementChangeTime = a : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = h ? h.lastPlacementChangeTime : a);
          }
          updateLayerOpacities(a, h) {
            const g = {};
            for (const y of h) {
              const w = y.getBucket(a);
              w && y.latestFeatureIndex && a.id === w.layerIds[0] && this.updateBucketOpacities(w, y.tileID, g, y.collisionBoxArray);
            }
          }
          updateBucketOpacities(a, h, g, y) {
            a.hasTextData() && (a.text.opacityVertexArray.clear(), a.text.hasVisibleVertices = !1), a.hasIconData() && (a.icon.opacityVertexArray.clear(), a.icon.hasVisibleVertices = !1), a.hasIconCollisionBoxData() && a.iconCollisionBox.collisionVertexArray.clear(), a.hasTextCollisionBoxData() && a.textCollisionBox.collisionVertexArray.clear();
            const w = a.layers[0], C = w.layout, P = new Po(null, 0, !1, !1, !0), L = C.get("text-allow-overlap"), F = C.get("icon-allow-overlap"), j = w._unevaluatedLayout.hasValue("text-variable-anchor") || w._unevaluatedLayout.hasValue("text-variable-anchor-offset"), X = C.get("text-rotation-alignment") === "map", G = C.get("text-pitch-alignment") === "map", Q = C.get("icon-text-fit") !== "none", le = new Po(null, 0, L && (F || !a.hasIconData() || C.get("icon-optional")), F && (L || !a.hasTextData() || C.get("text-optional")), !0);
            !a.collisionArrays && y && (a.hasIconCollisionBoxData() || a.hasTextCollisionBoxData()) && a.deserializeCollisionBoxes(y);
            const Ae = (Te, Me, Ve) => {
              for (let De = 0; De < Me / 4; De++) Te.opacityVertexArray.emplaceBack(Ve);
              Te.hasVisibleVertices = Te.hasVisibleVertices || Ve !== Aa;
            }, we = this.collisionBoxArrays.get(a.bucketInstanceId);
            for (let Te = 0; Te < a.symbolInstances.length; Te++) {
              const Me = a.symbolInstances.get(Te), { numHorizontalGlyphVertices: Ve, numVerticalGlyphVertices: De, crossTileID: He } = Me;
              let Ze = this.opacities[He];
              g[He] ? Ze = P : Ze || (Ze = le, this.opacities[He] = Ze), g[He] = !0;
              const Fe = Me.numIconVertices > 0, it = this.placedOrientations[Me.crossTileID], bt = it === o.an.vertical, dt = it === o.an.horizontal || it === o.an.horizontalOnly;
              if (Ve > 0 || De > 0) {
                const wt = Ro(Ze.text);
                Ae(a.text, Ve, bt ? Aa : wt), Ae(a.text, De, dt ? Aa : wt);
                const ir = Ze.text.isHidden();
                [Me.rightJustifiedTextSymbolIndex, Me.centerJustifiedTextSymbolIndex, Me.leftJustifiedTextSymbolIndex].forEach((xr) => {
                  xr >= 0 && (a.text.placedSymbolArray.get(xr).hidden = ir || bt ? 1 : 0);
                }), Me.verticalPlacedTextSymbolIndex >= 0 && (a.text.placedSymbolArray.get(Me.verticalPlacedTextSymbolIndex).hidden = ir || dt ? 1 : 0);
                const or = this.variableOffsets[Me.crossTileID];
                or && this.markUsedJustification(a, or.anchor, Me, it);
                const Vt = this.placedOrientations[Me.crossTileID];
                Vt && (this.markUsedJustification(a, "left", Me, Vt), this.markUsedOrientation(a, Vt, Me));
              }
              if (Fe) {
                const wt = Ro(Ze.icon), ir = !(Q && Me.verticalPlacedIconSymbolIndex && bt);
                Me.placedIconSymbolIndex >= 0 && (Ae(a.icon, Me.numIconVertices, ir ? wt : Aa), a.icon.placedSymbolArray.get(Me.placedIconSymbolIndex).hidden = Ze.icon.isHidden()), Me.verticalPlacedIconSymbolIndex >= 0 && (Ae(a.icon, Me.numVerticalIconVertices, ir ? Aa : wt), a.icon.placedSymbolArray.get(Me.verticalPlacedIconSymbolIndex).hidden = Ze.icon.isHidden());
              }
              const Tt = we && we.has(Te) ? we.get(Te) : { text: null, icon: null };
              if (a.hasIconCollisionBoxData() || a.hasTextCollisionBoxData()) {
                const wt = a.collisionArrays[Te];
                if (wt) {
                  let ir = new o.P(0, 0);
                  if (wt.textBox || wt.verticalTextBox) {
                    let or = !0;
                    if (j) {
                      const Vt = this.variableOffsets[He];
                      Vt ? (ir = vu(Vt.anchor, Vt.width, Vt.height, Vt.textOffset, Vt.textBoxScale), X && ir._rotate(G ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : or = !1;
                    }
                    if (wt.textBox || wt.verticalTextBox) {
                      let Vt;
                      wt.textBox && (Vt = bt), wt.verticalTextBox && (Vt = dt), Ha(a.textCollisionBox.collisionVertexArray, Ze.text.placed, !or || Vt, Tt.text, ir.x, ir.y);
                    }
                  }
                  if (wt.iconBox || wt.verticalIconBox) {
                    const or = !!(!dt && wt.verticalIconBox);
                    let Vt;
                    wt.iconBox && (Vt = or), wt.verticalIconBox && (Vt = !or), Ha(a.iconCollisionBox.collisionVertexArray, Ze.icon.placed, Vt, Tt.icon, Q ? ir.x : 0, Q ? ir.y : 0);
                  }
                }
              }
            }
            if (a.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[a.bucketInstanceId] && (this.retainedQueryData[a.bucketInstanceId].featureSortOrder = a.featureSortOrder), a.hasTextData() && a.text.opacityVertexBuffer && a.text.opacityVertexBuffer.updateData(a.text.opacityVertexArray), a.hasIconData() && a.icon.opacityVertexBuffer && a.icon.opacityVertexBuffer.updateData(a.icon.opacityVertexArray), a.hasIconCollisionBoxData() && a.iconCollisionBox.collisionVertexBuffer && a.iconCollisionBox.collisionVertexBuffer.updateData(a.iconCollisionBox.collisionVertexArray), a.hasTextCollisionBoxData() && a.textCollisionBox.collisionVertexBuffer && a.textCollisionBox.collisionVertexBuffer.updateData(a.textCollisionBox.collisionVertexArray), a.text.opacityVertexArray.length !== a.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${a.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${a.text.layoutVertexArray.length}) / 4`);
            if (a.icon.opacityVertexArray.length !== a.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${a.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${a.icon.layoutVertexArray.length}) / 4`);
            a.bucketInstanceId in this.collisionCircleArrays && (a.collisionCircleArray = this.collisionCircleArrays[a.bucketInstanceId], delete this.collisionCircleArrays[a.bucketInstanceId]);
          }
          symbolFadeChange(a) {
            return this.fadeDuration === 0 ? 1 : (a - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(a) {
            return Math.max(0, (this.transform.zoom - a) / 1.5);
          }
          hasTransitions(a) {
            return this.stale || a - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(a, h) {
            const g = this.zoomAtLastRecencyCheck === h ? 1 - this.zoomAdjustment(h) : 1;
            return this.zoomAtLastRecencyCheck = h, this.commitTime + this.fadeDuration * g > a;
          }
          setStale() {
            this.stale = !0;
          }
        }
        function Ha(v, a, h, g, y, w) {
          g && g.length !== 0 || (g = [0, 0, 0, 0]);
          const C = g[0] - bi, P = g[1] - bi, L = g[2] - bi, F = g[3] - bi;
          v.emplaceBack(a ? 1 : 0, h ? 1 : 0, y || 0, w || 0, C, P), v.emplaceBack(a ? 1 : 0, h ? 1 : 0, y || 0, w || 0, L, P), v.emplaceBack(a ? 1 : 0, h ? 1 : 0, y || 0, w || 0, L, F), v.emplaceBack(a ? 1 : 0, h ? 1 : 0, y || 0, w || 0, C, F);
        }
        const Wa = Math.pow(2, 25), Hn = Math.pow(2, 24), xu = Math.pow(2, 17), wu = Math.pow(2, 16), Au = Math.pow(2, 9), wa = Math.pow(2, 8), ih = Math.pow(2, 1);
        function Ro(v) {
          if (v.opacity === 0 && !v.placed) return 0;
          if (v.opacity === 1 && v.placed) return 4294967295;
          const a = v.placed ? 1 : 0, h = Math.floor(127 * v.opacity);
          return h * Wa + a * Hn + h * xu + a * wu + h * Au + a * wa + h * ih + a;
        }
        const Aa = 0;
        class so {
          constructor(a) {
            this._sortAcrossTiles = a.layout.get("symbol-z-order") !== "viewport-y" && !a.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          }
          continuePlacement(a, h, g, y, w) {
            const C = this._bucketParts;
            for (; this._currentTileIndex < a.length; ) if (h.getBucketParts(C, y, a[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, w()) return !0;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, C.sort((P, L) => P.sortKey - L.sortKey)); this._currentPartIndex < C.length; ) if (h.placeLayerBucketPart(C[this._currentPartIndex], this._seenCrossTileIDs, g), this._currentPartIndex++, w()) return !0;
            return !1;
          }
        }
        class Dc {
          constructor(a, h, g, y, w, C, P, L) {
            this.placement = new ql(a, h, C, P, L), this._currentPlacementIndex = g.length - 1, this._forceFullPlacement = y, this._showCollisionBoxes = w, this._done = !1;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(a, h, g) {
            const y = M.now(), w = () => !this._forceFullPlacement && M.now() - y > 2;
            for (; this._currentPlacementIndex >= 0; ) {
              const C = h[a[this._currentPlacementIndex]], P = this.placement.collisionIndex.transform.zoom;
              if (C.type === "symbol" && (!C.minzoom || C.minzoom <= P) && (!C.maxzoom || C.maxzoom > P)) {
                if (this._inProgressLayer || (this._inProgressLayer = new so(C)), this._inProgressLayer.continuePlacement(g[C.source], this.placement, this._showCollisionBoxes, C, w)) return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = !0;
          }
          commit(a) {
            return this.placement.commit(a), this.placement;
          }
        }
        const Xa = 512 / o.$ / 2;
        class Tu {
          constructor(a, h, g) {
            this.tileID = a, this.bucketInstanceId = g, this._symbolsByKey = {};
            const y = /* @__PURE__ */ new Map();
            for (let w = 0; w < h.length; w++) {
              const C = h.get(w), P = C.key, L = y.get(P);
              L ? L.push(C) : y.set(P, [C]);
            }
            for (const [w, C] of y) {
              const P = { positions: C.map((L) => ({ x: Math.floor(L.anchorX * Xa), y: Math.floor(L.anchorY * Xa) })), crossTileIDs: C.map((L) => L.crossTileID) };
              if (P.positions.length > 128) {
                const L = new o.aH(P.positions.length, 16, Uint16Array);
                for (const { x: F, y: j } of P.positions) L.add(F, j);
                L.finish(), delete P.positions, P.index = L;
              }
              this._symbolsByKey[w] = P;
            }
          }
          getScaledCoordinates(a, h) {
            const { x: g, y, z: w } = this.tileID.canonical, { x: C, y: P, z: L } = h.canonical, F = Xa / Math.pow(2, L - w), j = (P * o.$ + a.anchorY) * F, X = y * o.$ * Xa;
            return { x: Math.floor((C * o.$ + a.anchorX) * F - g * o.$ * Xa), y: Math.floor(j - X) };
          }
          findMatches(a, h, g) {
            const y = this.tileID.canonical.z < h.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - h.canonical.z);
            for (let w = 0; w < a.length; w++) {
              const C = a.get(w);
              if (C.crossTileID) continue;
              const P = this._symbolsByKey[C.key];
              if (!P) continue;
              const L = this.getScaledCoordinates(C, h);
              if (P.index) {
                const F = P.index.range(L.x - y, L.y - y, L.x + y, L.y + y).sort();
                for (const j of F) {
                  const X = P.crossTileIDs[j];
                  if (!g[X]) {
                    g[X] = !0, C.crossTileID = X;
                    break;
                  }
                }
              } else if (P.positions) for (let F = 0; F < P.positions.length; F++) {
                const j = P.positions[F], X = P.crossTileIDs[F];
                if (Math.abs(j.x - L.x) <= y && Math.abs(j.y - L.y) <= y && !g[X]) {
                  g[X] = !0, C.crossTileID = X;
                  break;
                }
              }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map((a) => {
              let { crossTileIDs: h } = a;
              return h;
            });
          }
        }
        class Fc {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class sh {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(a) {
            const h = Math.round((a - this.lng) / 360);
            if (h !== 0) for (const g in this.indexes) {
              const y = this.indexes[g], w = {};
              for (const C in y) {
                const P = y[C];
                P.tileID = P.tileID.unwrapTo(P.tileID.wrap + h), w[P.tileID.key] = P;
              }
              this.indexes[g] = w;
            }
            this.lng = a;
          }
          addBucket(a, h, g) {
            if (this.indexes[a.overscaledZ] && this.indexes[a.overscaledZ][a.key]) {
              if (this.indexes[a.overscaledZ][a.key].bucketInstanceId === h.bucketInstanceId) return !1;
              this.removeBucketCrossTileIDs(a.overscaledZ, this.indexes[a.overscaledZ][a.key]);
            }
            for (let w = 0; w < h.symbolInstances.length; w++) h.symbolInstances.get(w).crossTileID = 0;
            this.usedCrossTileIDs[a.overscaledZ] || (this.usedCrossTileIDs[a.overscaledZ] = {});
            const y = this.usedCrossTileIDs[a.overscaledZ];
            for (const w in this.indexes) {
              const C = this.indexes[w];
              if (Number(w) > a.overscaledZ) for (const P in C) {
                const L = C[P];
                L.tileID.isChildOf(a) && L.findMatches(h.symbolInstances, a, y);
              }
              else {
                const P = C[a.scaledTo(Number(w)).key];
                P && P.findMatches(h.symbolInstances, a, y);
              }
            }
            for (let w = 0; w < h.symbolInstances.length; w++) {
              const C = h.symbolInstances.get(w);
              C.crossTileID || (C.crossTileID = g.generate(), y[C.crossTileID] = !0);
            }
            return this.indexes[a.overscaledZ] === void 0 && (this.indexes[a.overscaledZ] = {}), this.indexes[a.overscaledZ][a.key] = new Tu(a, h.symbolInstances, h.bucketInstanceId), !0;
          }
          removeBucketCrossTileIDs(a, h) {
            for (const g of h.getCrossTileIDsLists()) for (const y of g) delete this.usedCrossTileIDs[a][y];
          }
          removeStaleBuckets(a) {
            let h = !1;
            for (const g in this.indexes) {
              const y = this.indexes[g];
              for (const w in y) a[y[w].bucketInstanceId] || (this.removeBucketCrossTileIDs(g, y[w]), delete y[w], h = !0);
            }
            return h;
          }
        }
        class Gl {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new Fc(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(a, h, g) {
            let y = this.layerIndexes[a.id];
            y === void 0 && (y = this.layerIndexes[a.id] = new sh());
            let w = !1;
            const C = {};
            y.handleWrapJump(g);
            for (const P of h) {
              const L = P.getBucket(a);
              L && a.id === L.layerIds[0] && (L.bucketInstanceId || (L.bucketInstanceId = ++this.maxBucketInstanceId), y.addBucket(P.tileID, L, this.crossTileIDs) && (w = !0), C[L.bucketInstanceId] = !0);
            }
            return y.removeStaleBuckets(C) && (w = !0), w;
          }
          pruneUnusedLayers(a) {
            const h = {};
            a.forEach((g) => {
              h[g] = !0;
            });
            for (const g in this.layerIndexes) h[g] || delete this.layerIndexes[g];
          }
        }
        var Uc = "void main() {fragColor=vec4(1.0);}";
        const oo = { prelude: un(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`), projectionMercator: un("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"), projectionGlobe: un("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`), background: un(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), backgroundPattern: un(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: un(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: un(Uc, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), heatmap: un(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`), heatmapTexture: un(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: un("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: un("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), colorRelief: un(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(textureSize(u_elevation_stops,0)[0]);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int num_elevation_stops=textureSize(u_elevation_stops,0)[0];int r=(num_elevation_stops-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(textureSize(u_color_stops,0)[0]);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), debug: un("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"), depth: un(Uc, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`), fill: un(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`), fillOutline: un(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillOutlinePattern: un(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillPattern: un(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: un(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: un(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: un(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: un(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;switch(u_method){case BASIC:
basic_hillshade(deriv);break;case COMBINED:
combined_hillshade(deriv);break;case IGOR:
igor_hillshade(deriv);break;case MULTIDIRECTIONAL:
multidirectional_hillshade(deriv);break;case STANDARD:
default:
standard_hillshade(deriv);break;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), line: un(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: un(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: un(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: un(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), raster: un(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`), symbolIcon: un(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: un(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: un(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: un("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: un("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: un("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"), projectionErrorMeasurement: un("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"), atmosphere: un(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"), sky: un("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
        function un(v, a) {
          const h = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, g = a.match(/in ([\w]+) ([\w]+)/g), y = v.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), w = a.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), C = w ? w.concat(y) : y, P = {};
          return { fragmentSource: v = v.replace(h, (L, F, j, X, G) => (P[G] = !0, F === "define" ? `
#ifndef HAS_UNIFORM_u_${G}
in ${j} ${X} ${G};
#else
uniform ${j} ${X} u_${G};
#endif
` : `
#ifdef HAS_UNIFORM_u_${G}
    ${j} ${X} ${G} = u_${G};
#endif
`)), vertexSource: a = a.replace(h, (L, F, j, X, G) => {
            const Q = X === "float" ? "vec2" : "vec4", le = G.match(/color/) ? "color" : Q;
            return P[G] ? F === "define" ? `
#ifndef HAS_UNIFORM_u_${G}
uniform lowp float u_${G}_t;
in ${j} ${Q} a_${G};
out ${j} ${X} ${G};
#else
uniform ${j} ${X} u_${G};
#endif
` : le === "vec4" ? `
#ifndef HAS_UNIFORM_u_${G}
    ${G} = a_${G};
#else
    ${j} ${X} ${G} = u_${G};
#endif
` : `
#ifndef HAS_UNIFORM_u_${G}
    ${G} = unpack_mix_${le}(a_${G}, u_${G}_t);
#else
    ${j} ${X} ${G} = u_${G};
#endif
` : F === "define" ? `
#ifndef HAS_UNIFORM_u_${G}
uniform lowp float u_${G}_t;
in ${j} ${Q} a_${G};
#else
uniform ${j} ${X} u_${G};
#endif
` : le === "vec4" ? `
#ifndef HAS_UNIFORM_u_${G}
    ${j} ${X} ${G} = a_${G};
#else
    ${j} ${X} ${G} = u_${G};
#endif
` : `
#ifndef HAS_UNIFORM_u_${G}
    ${j} ${X} ${G} = unpack_mix_${le}(a_${G}, u_${G}_t);
#else
    ${j} ${X} ${G} = u_${G};
#endif
`;
          }), staticAttributes: g, staticUniforms: C };
        }
        class sa {
          constructor(a, h, g) {
            this.vertexBuffer = a, this.indexBuffer = h, this.segments = g;
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
          }
        }
        var oa = o.aI([{ name: "a_pos", type: "Int16", components: 2 }]);
        const $s = "#define PROJECTION_MERCATOR", bl = "mercator";
        class vl {
          constructor() {
            this._cachedMesh = null;
          }
          get name() {
            return "mercator";
          }
          get useSubdivision() {
            return !1;
          }
          get shaderVariantName() {
            return bl;
          }
          get shaderDefine() {
            return $s;
          }
          get shaderPreludeCode() {
            return oo.projectionMercator;
          }
          get vertexShaderPreludeCode() {
            return oo.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return o.aJ.noSubdivision;
          }
          get useGlobeControls() {
            return !1;
          }
          get transitionState() {
            return 0;
          }
          get latitudeErrorCorrectionRadians() {
            return 0;
          }
          destroy() {
          }
          updateGPUdependent(a) {
          }
          getMeshFromTileID(a, h, g, y, w) {
            if (this._cachedMesh) return this._cachedMesh;
            const C = new o.aK();
            C.emplaceBack(0, 0), C.emplaceBack(o.$, 0), C.emplaceBack(0, o.$), C.emplaceBack(o.$, o.$);
            const P = a.createVertexBuffer(C, oa.members), L = o.aL.simpleSegment(0, 0, 4, 2), F = new o.aM();
            F.emplaceBack(1, 0, 2), F.emplaceBack(1, 2, 3);
            const j = a.createIndexBuffer(F);
            return this._cachedMesh = new sa(P, j, L), this._cachedMesh;
          }
          recalculate() {
          }
          hasTransition() {
            return !1;
          }
          setErrorQueryLatitudeDegrees(a) {
          }
        }
        class qs {
          constructor() {
            let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, y = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
            if (isNaN(a) || a < 0 || isNaN(h) || h < 0 || isNaN(g) || g < 0 || isNaN(y) || y < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = a, this.bottom = h, this.left = g, this.right = y;
          }
          interpolate(a, h, g) {
            return h.top != null && a.top != null && (this.top = o.C.number(a.top, h.top, g)), h.bottom != null && a.bottom != null && (this.bottom = o.C.number(a.bottom, h.bottom, g)), h.left != null && a.left != null && (this.left = o.C.number(a.left, h.left, g)), h.right != null && a.right != null && (this.right = o.C.number(a.right, h.right, g)), this;
          }
          getCenter(a, h) {
            const g = o.ag((this.left + a - this.right) / 2, 0, a), y = o.ag((this.top + h - this.bottom) / 2, 0, h);
            return new o.P(g, y);
          }
          equals(a) {
            return this.top === a.top && this.bottom === a.bottom && this.left === a.left && this.right === a.right;
          }
          clone() {
            return new qs(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        function hi(v, a) {
          if (!v.renderWorldCopies || v.lngRange) return;
          const h = a.lng - v.center.lng;
          a.lng += h > 180 ? -360 : h < -180 ? 360 : 0;
        }
        function hn(v) {
          return Math.max(0, Math.floor(v));
        }
        class xl {
          constructor(a, h, g, y, w, C) {
            this._callbacks = a, this._tileSize = 512, this._renderWorldCopies = C === void 0 || !!C, this._minZoom = h || 0, this._maxZoom = g || 22, this._minPitch = y ?? 0, this._maxPitch = w ?? 60, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new o.S(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = hn(this._zoom), this._scale = o.ae(this._zoom), this._bearingInRadians = 0, this._fovInRadians = 0.6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new qs(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0;
          }
          apply(a, h, g) {
            this._latRange = a.latRange, this._lngRange = a.lngRange, this._width = a.width, this._height = a.height, this._center = a.center, this._elevation = a.elevation, this._minElevationForCurrentTile = a.minElevationForCurrentTile, this._zoom = a.zoom, this._tileZoom = hn(this._zoom), this._scale = o.ae(this._zoom), this._bearingInRadians = a.bearingInRadians, this._fovInRadians = a.fovInRadians, this._pitchInRadians = a.pitchInRadians, this._rollInRadians = a.rollInRadians, this._unmodified = a.unmodified, this._edgeInsets = new qs(a.padding.top, a.padding.bottom, a.padding.left, a.padding.right), this._minZoom = a.minZoom, this._maxZoom = a.maxZoom, this._minPitch = a.minPitch, this._maxPitch = a.maxPitch, this._renderWorldCopies = a.renderWorldCopies, this._cameraToCenterDistance = a.cameraToCenterDistance, this._nearZ = a.nearZ, this._farZ = a.farZ, this._autoCalculateNearFarZ = !g && a.autoCalculateNearFarZ, h && this._constrain(), this._calcMatrices();
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix;
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile;
          }
          setMinElevationForCurrentTile(a) {
            this._minElevationForCurrentTile = a;
          }
          get tileSize() {
            return this._tileSize;
          }
          get tileZoom() {
            return this._tileZoom;
          }
          get scale() {
            return this._scale;
          }
          get width() {
            return this._width;
          }
          get height() {
            return this._height;
          }
          get bearingInRadians() {
            return this._bearingInRadians;
          }
          get lngRange() {
            return this._lngRange;
          }
          get latRange() {
            return this._latRange;
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits;
          }
          get minZoom() {
            return this._minZoom;
          }
          setMinZoom(a) {
            this._minZoom !== a && (this._minZoom = a, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          setMaxZoom(a) {
            this._maxZoom !== a && (this._maxZoom = a, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
          }
          get minPitch() {
            return this._minPitch;
          }
          setMinPitch(a) {
            this._minPitch !== a && (this._minPitch = a, this.setPitch(Math.max(this.pitch, a)));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          setMaxPitch(a) {
            this._maxPitch !== a && (this._maxPitch = a, this.setPitch(Math.min(this.pitch, a)));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies;
          }
          setRenderWorldCopies(a) {
            a === void 0 ? a = !0 : a === null && (a = !1), this._renderWorldCopies = a;
          }
          get worldSize() {
            return this._tileSize * this._scale;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new o.P(this._width, this._height);
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180;
          }
          setBearing(a) {
            const h = o.aN(a, -180, 180) * Math.PI / 180;
            var g, y, w, C, P, L, F, j, X;
            this._bearingInRadians !== h && (this._unmodified = !1, this._bearingInRadians = h, this._calcMatrices(), this._rotationMatrix = m(), g = this._rotationMatrix, w = -this._bearingInRadians, C = (y = this._rotationMatrix)[0], P = y[1], L = y[2], F = y[3], j = Math.sin(w), X = Math.cos(w), g[0] = C * X + L * j, g[1] = P * X + F * j, g[2] = C * -j + L * X, g[3] = P * -j + F * X);
          }
          get rotationMatrix() {
            return this._rotationMatrix;
          }
          get pitchInRadians() {
            return this._pitchInRadians;
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180;
          }
          setPitch(a) {
            const h = o.ag(a, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== h && (this._unmodified = !1, this._pitchInRadians = h, this._calcMatrices());
          }
          get rollInRadians() {
            return this._rollInRadians;
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180;
          }
          setRoll(a) {
            const h = a / 180 * Math.PI;
            this._rollInRadians !== h && (this._unmodified = !1, this._rollInRadians = h, this._calcMatrices());
          }
          get fovInRadians() {
            return this._fovInRadians;
          }
          get fov() {
            return o.aO(this._fovInRadians);
          }
          setFov(a) {
            a = o.ag(a, 0.1, 150), this.fov !== a && (this._unmodified = !1, this._fovInRadians = o.ad(a), this._calcMatrices());
          }
          get zoom() {
            return this._zoom;
          }
          setZoom(a) {
            const h = this.getConstrained(this._center, a).zoom;
            this._zoom !== h && (this._unmodified = !1, this._zoom = h, this._tileZoom = Math.max(0, Math.floor(h)), this._scale = o.ae(h), this._constrain(), this._calcMatrices());
          }
          get center() {
            return this._center;
          }
          setCenter(a) {
            a.lat === this._center.lat && a.lng === this._center.lng || (this._unmodified = !1, this._center = a, this._constrain(), this._calcMatrices());
          }
          get elevation() {
            return this._elevation;
          }
          setElevation(a) {
            a !== this._elevation && (this._elevation = a, this._constrain(), this._calcMatrices());
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          setPadding(a) {
            this._edgeInsets.equals(a) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, a, 1), this._calcMatrices());
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height);
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter;
          }
          get unmodified() {
            return this._unmodified;
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance;
          }
          get nearZ() {
            return this._nearZ;
          }
          get farZ() {
            return this._farZ;
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ;
          }
          overrideNearFarZ(a, h) {
            this._autoCalculateNearFarZ = !1, this._nearZ = a, this._farZ = h, this._calcMatrices();
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = !0, this._calcMatrices();
          }
          isPaddingEqual(a) {
            return this._edgeInsets.equals(a);
          }
          interpolatePadding(a, h, g) {
            this._unmodified = !1, this._edgeInsets.interpolate(a, h, g), this._constrain(), this._calcMatrices();
          }
          resize(a, h) {
            let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
            this._width = a, this._height = h, g && this._constrain(), this._calcMatrices();
          }
          getMaxBounds() {
            return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new sr([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
          }
          setMaxBounds(a) {
            a ? (this._lngRange = [a.getWest(), a.getEast()], this._latRange = [a.getSouth(), a.getNorth()], this._constrain()) : (this._lngRange = null, this._latRange = [-85.051129, o.ah]);
          }
          getConstrained(a, h) {
            return this._callbacks.getConstrained(a, h);
          }
          getCameraQueryGeometry(a, h) {
            if (h.length === 1) return [h[0], a];
            {
              const { minX: g, minY: y, maxX: w, maxY: C } = o.a1.fromPoints(h).extend(a);
              return [new o.P(g, y), new o.P(w, y), new o.P(w, C), new o.P(g, C), new o.P(g, y)];
            }
          }
          _constrain() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = !0;
            const a = this._unmodified, { center: h, zoom: g } = this.getConstrained(this.center, this.zoom);
            this.setCenter(h), this.setZoom(g), this._unmodified = a, this._constraining = !1;
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let a = o.af(new Float64Array(16));
              o.N(a, a, [this._width / 2, -this._height / 2, 1]), o.M(a, a, [1, -1, 0]), this._clipSpaceToPixelsMatrix = a, a = o.af(new Float64Array(16)), o.N(a, a, [1, -1, 1]), o.M(a, a, [-1, -1, 0]), o.N(a, a, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = a, this._cameraToCenterDistance = 0.5 / Math.tan(this.fovInRadians / 2) * this._height;
            }
            this._callbacks.calcMatrices();
          }
          calculateCenterFromCameraLngLatAlt(a, h, g, y) {
            const w = g !== void 0 ? g : this.bearing, C = y = y !== void 0 ? y : this.pitch, P = o.a0.fromLngLat(a, h), L = -Math.cos(o.ad(C)), F = Math.sin(o.ad(C)), j = F * Math.sin(o.ad(w)), X = -F * Math.cos(o.ad(w));
            let G = this.elevation;
            const Q = h - G;
            let le;
            L * Q >= 0 || Math.abs(L) < 0.1 ? (le = 1e4, G = h + le * L) : le = -Q / L;
            let Ae, we, Te = o.aP(1, P.y), Me = 0;
            do {
              if (Me += 1, Me > 10) break;
              we = le / Te, Ae = new o.a0(P.x + j * we, P.y + X * we), Te = 1 / Ae.meterInMercatorCoordinateUnits();
            } while (Math.abs(le - we * Te) > 1e-12);
            return { center: Ae.toLngLat(), elevation: G, zoom: o.aj(this.height / 2 / Math.tan(this.fovInRadians / 2) / we / this.tileSize) };
          }
          recalculateZoomAndCenter(a) {
            if (this.elevation - a == 0) return;
            const h = o.ai(1, this.center.lat) * this.worldSize, g = this.cameraToCenterDistance / h, y = o.a0.fromLngLat(this.center, this.elevation), w = Le(this.center, this.elevation, this.pitch, this.bearing, g);
            this._elevation = a;
            const C = this.calculateCenterFromCameraLngLatAlt(w.toLngLat(), o.aP(w.z, y.y), this.bearing, this.pitch);
            this._elevation = C.elevation, this._center = C.center, this.setZoom(C.zoom);
          }
          getCameraPoint() {
            const a = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new o.P(a * Math.sin(this.rollInRadians), a * Math.cos(this.rollInRadians)));
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
          }
          getCameraLngLat() {
            const a = o.ai(1, this.center.lat) * this.worldSize;
            return Le(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / a).toLngLat();
          }
          getMercatorTileCoordinates(a) {
            if (!a) return [0, 0, 1, 1];
            const h = a.canonical.z >= 0 ? 1 << a.canonical.z : Math.pow(2, a.canonical.z);
            return [a.canonical.x / h, a.canonical.y / h, 1 / h / o.$, 1 / h / o.$];
          }
        }
        class Zr {
          constructor(a, h) {
            this.min = a, this.max = h, this.center = o.aQ([], o.aR([], this.min, this.max), 0.5);
          }
          quadrant(a) {
            const h = [a % 2 == 0, a < 2], g = o.aS(this.min), y = o.aS(this.max);
            for (let w = 0; w < h.length; w++) g[w] = h[w] ? this.min[w] : this.center[w], y[w] = h[w] ? this.center[w] : this.max[w];
            return y[2] = this.max[2], new Zr(g, y);
          }
          distanceX(a) {
            return Math.max(Math.min(this.max[0], a[0]), this.min[0]) - a[0];
          }
          distanceY(a) {
            return Math.max(Math.min(this.max[1], a[1]), this.min[1]) - a[1];
          }
          intersectsFrustum(a) {
            let h = !0;
            for (let g = 0; g < a.planes.length; g++) {
              const y = this.intersectsPlane(a.planes[g]);
              if (y === 0) return 0;
              y === 1 && (h = !1);
            }
            return h ? 2 : a.aabb.min[0] > this.max[0] || a.aabb.min[1] > this.max[1] || a.aabb.min[2] > this.max[2] || a.aabb.max[0] < this.min[0] || a.aabb.max[1] < this.min[1] || a.aabb.max[2] < this.min[2] ? 0 : 1;
          }
          intersectsPlane(a) {
            let h = a[3], g = a[3];
            for (let y = 0; y < 3; y++) a[y] > 0 ? (h += a[y] * this.min[y], g += a[y] * this.max[y]) : (g += a[y] * this.min[y], h += a[y] * this.max[y]);
            return h >= 0 ? 2 : g < 0 ? 0 : 1;
          }
        }
        class Su {
          distanceToTile2d(a, h, g, y) {
            const w = y.distanceX([a, h]), C = y.distanceY([a, h]);
            return Math.hypot(w, C);
          }
          getWrap(a, h, g) {
            return g;
          }
          getTileBoundingVolume(a, h, g, y) {
            var w, C;
            let P = g, L = g;
            if (y != null && y.terrain) {
              const j = new o.Z(a.z, h, a.z, a.x, a.y), X = y.terrain.getMinMaxElevation(j);
              P = (w = X.minElevation) !== null && w !== void 0 ? w : g, L = (C = X.maxElevation) !== null && C !== void 0 ? C : g;
            }
            const F = 1 << a.z;
            return new Zr([h + a.x / F, a.y / F, P], [h + (a.x + 1) / F, (a.y + 1) / F, L]);
          }
          allowVariableZoom(a, h) {
            const g = a.fov * (Math.abs(Math.cos(a.rollInRadians)) * a.height + Math.abs(Math.sin(a.rollInRadians)) * a.width) / a.height, y = o.ag(78.5 - g / 2, 0, 60);
            return !!h.terrain || a.pitch > y;
          }
          allowWorldCopies() {
            return !0;
          }
          prepareNextFrame() {
          }
        }
        class ns {
          constructor(a, h, g) {
            this.points = a, this.planes = h, this.aabb = g;
          }
          static fromInvProjectionMatrix(a) {
            let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, y = arguments.length > 3 ? arguments[3] : void 0, w = arguments.length > 4 ? arguments[4] : void 0;
            const C = w ? [[6, 5, 4], [0, 1, 2], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]] : [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]], P = Math.pow(2, g), L = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((G) => function(Q, le, Ae, we) {
              const Te = o.av([], Q, le), Me = 1 / Te[3] / Ae * we;
              return o.aX(Te, Te, [Me, Me, 1 / Te[3], Me]);
            }(G, a, h, P));
            y && function(G, Q, le, Ae) {
              const we = Ae ? 4 : 0, Te = Ae ? 0 : 4;
              let Me = 0;
              const Ve = [], De = [];
              for (let Fe = 0; Fe < 4; Fe++) {
                const it = o.aT([], G[Fe + Te], G[Fe + we]), bt = o.aY(it);
                o.aQ(it, it, 1 / bt), Ve.push(bt), De.push(it);
              }
              for (let Fe = 0; Fe < 4; Fe++) {
                const it = o.aZ(G[Fe + we], De[Fe], le);
                Me = it !== null && it >= 0 ? Math.max(Me, it) : Math.max(Me, Ve[Fe]);
              }
              const He = function(Fe, it) {
                const bt = o.aT([], Fe[it[0]], Fe[it[1]]), dt = o.aT([], Fe[it[2]], Fe[it[1]]), Tt = [0, 0, 0, 0];
                return o.aU(Tt, o.aV([], bt, dt)), Tt[3] = -o.aW(Tt, Fe[it[0]]), Tt;
              }(G, Q), Ze = function(Fe, it) {
                const bt = o.a_(Fe), dt = o.a$([], Fe, 1 / bt), Tt = o.aT([], it, o.aQ([], dt, o.aW(it, dt))), wt = o.a_(Tt);
                if (wt > 0) {
                  const ir = Math.sqrt(1 - dt[3] * dt[3]), or = o.aQ([], dt, -dt[3]), Vt = o.aR([], or, o.aQ([], Tt, ir / wt));
                  return o.b0(it, Vt);
                }
                return null;
              }(le, He);
              if (Ze !== null) {
                const Fe = Ze / o.aW(De[0], He);
                Me = Math.min(Me, Fe);
              }
              for (let Fe = 0; Fe < 4; Fe++) {
                const it = Math.min(Me, Ve[Fe]);
                G[Fe + Te] = [G[Fe + we][0] + De[Fe][0] * it, G[Fe + we][1] + De[Fe][1] * it, G[Fe + we][2] + De[Fe][2] * it, 1];
              }
            }(L, C[0], y, w);
            const F = C.map((G) => {
              const Q = o.aT([], L[G[0]], L[G[1]]), le = o.aT([], L[G[2]], L[G[1]]), Ae = o.aU([], o.aV([], Q, le)), we = -o.aW(Ae, L[G[1]]);
              return Ae.concat(we);
            }), j = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], X = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const G of L) for (let Q = 0; Q < 3; Q++) j[Q] = Math.min(j[Q], G[Q]), X[Q] = Math.max(X[Q], G[Q]);
            return new ns(L, F, new Zr(j, X));
          }
        }
        class zn {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(a) {
            this._helper.setMinZoom(a);
          }
          setMaxZoom(a) {
            this._helper.setMaxZoom(a);
          }
          setMinPitch(a) {
            this._helper.setMinPitch(a);
          }
          setMaxPitch(a) {
            this._helper.setMaxPitch(a);
          }
          setRenderWorldCopies(a) {
            this._helper.setRenderWorldCopies(a);
          }
          setBearing(a) {
            this._helper.setBearing(a);
          }
          setPitch(a) {
            this._helper.setPitch(a);
          }
          setRoll(a) {
            this._helper.setRoll(a);
          }
          setFov(a) {
            this._helper.setFov(a);
          }
          setZoom(a) {
            this._helper.setZoom(a);
          }
          setCenter(a) {
            this._helper.setCenter(a);
          }
          setElevation(a) {
            this._helper.setElevation(a);
          }
          setMinElevationForCurrentTile(a) {
            this._helper.setMinElevationForCurrentTile(a);
          }
          setPadding(a) {
            this._helper.setPadding(a);
          }
          interpolatePadding(a, h, g) {
            return this._helper.interpolatePadding(a, h, g);
          }
          isPaddingEqual(a) {
            return this._helper.isPaddingEqual(a);
          }
          resize(a, h) {
            let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
            this._helper.resize(a, h, g);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(a) {
            this._helper.setMaxBounds(a);
          }
          overrideNearFarZ(a, h) {
            this._helper.overrideNearFarZ(a, h);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(a) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), a);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(a, h) {
          }
          constructor(a, h, g, y, w) {
            this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this._helper = new xl({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (C, P) => this.getConstrained(C, P) }, a, h, g, y, w), this._coveringTilesDetailsProvider = new Su();
          }
          clone() {
            const a = new zn();
            return a.apply(this), a;
          }
          apply(a, h, g) {
            this._helper.apply(a, h, g);
          }
          get cameraPosition() {
            return this._cameraPosition;
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix;
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix;
          }
          get mercatorMatrix() {
            return this._mercatorMatrix;
          }
          getVisibleUnwrappedCoordinates(a) {
            const h = [new o.b1(0, a)];
            if (this._helper._renderWorldCopies) {
              const g = this.screenPointToMercatorCoordinate(new o.P(0, 0)), y = this.screenPointToMercatorCoordinate(new o.P(this._helper._width, 0)), w = this.screenPointToMercatorCoordinate(new o.P(this._helper._width, this._helper._height)), C = this.screenPointToMercatorCoordinate(new o.P(0, this._helper._height)), P = Math.floor(Math.min(g.x, y.x, w.x, C.x)), L = Math.floor(Math.max(g.x, y.x, w.x, C.x)), F = 1;
              for (let j = P - F; j <= L + F; j++) j !== 0 && h.push(new o.b1(j, a));
            }
            return h;
          }
          getCameraFrustum() {
            return ns.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
          }
          getClippingPlane() {
            return null;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(a) {
            const h = this.screenPointToLocation(this.centerPoint, a), g = a ? a.getElevationForLngLatZoom(h, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(g);
          }
          setLocationAtPoint(a, h) {
            const g = o.ai(this.elevation, this.center.lat), y = this.screenPointToMercatorCoordinateAtZ(h, g), w = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, g), C = o.a0.fromLngLat(a), P = new o.a0(C.x - (y.x - w.x), C.y - (y.y - w.y));
            this.setCenter(P == null ? void 0 : P.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
          }
          locationToScreenPoint(a, h) {
            return h ? this.coordinatePoint(o.a0.fromLngLat(a), h.getElevationForLngLatZoom(a, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(o.a0.fromLngLat(a));
          }
          screenPointToLocation(a, h) {
            var g;
            return (g = this.screenPointToMercatorCoordinate(a, h)) === null || g === void 0 ? void 0 : g.toLngLat();
          }
          screenPointToMercatorCoordinate(a, h) {
            if (h) {
              const g = h.pointCoordinate(a);
              if (g != null) return g;
            }
            return this.screenPointToMercatorCoordinateAtZ(a);
          }
          screenPointToMercatorCoordinateAtZ(a, h) {
            const g = h || 0, y = [a.x, a.y, 0, 1], w = [a.x, a.y, 1, 1];
            o.av(y, y, this._pixelMatrixInverse), o.av(w, w, this._pixelMatrixInverse);
            const C = y[3], P = w[3], L = y[1] / C, F = w[1] / P, j = y[2] / C, X = w[2] / P, G = j === X ? 0 : (g - j) / (X - j);
            return new o.a0(o.C.number(y[0] / C, w[0] / P, G) / this.worldSize, o.C.number(L, F, G) / this.worldSize, g);
          }
          coordinatePoint(a) {
            let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this._pixelMatrix;
            const y = [a.x * this.worldSize, a.y * this.worldSize, h, 1];
            return o.av(y, y, g), new o.P(y[0] / y[3], y[1] / y[3]);
          }
          getBounds() {
            const a = Math.max(0, this._helper._height / 2 - fe(this));
            return new sr().extend(this.screenPointToLocation(new o.P(0, a))).extend(this.screenPointToLocation(new o.P(this._helper._width, a))).extend(this.screenPointToLocation(new o.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new o.P(0, this._helper._height)));
          }
          isPointOnMapSurface(a, h) {
            return h ? h.pointCoordinate(a) != null : a.y > this.height / 2 - fe(this);
          }
          calculatePosMatrix(a) {
            let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, g = arguments.length > 2 ? arguments[2] : void 0;
            var y;
            const w = (y = a.key) !== null && y !== void 0 ? y : o.b2(a.wrap, a.canonical.z, a.canonical.z, a.canonical.x, a.canonical.y), C = h ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (C.has(w)) {
              const F = C.get(w);
              return g ? F.f32 : F.f64;
            }
            const P = ye(a, this.worldSize);
            o.O(P, h ? this._alignedProjMatrix : this._viewProjMatrix, P);
            const L = { f64: P, f32: new Float32Array(P) };
            return C.set(w, L), g ? L.f32 : L.f64;
          }
          calculateFogMatrix(a) {
            const h = a.key, g = this._fogMatrixCacheF32;
            if (g.has(h)) return g.get(h);
            const y = ye(a, this.worldSize);
            return o.O(y, this._fogMatrix, y), g.set(h, new Float32Array(y)), g.get(h);
          }
          getConstrained(a, h) {
            h = o.ag(+h, this.minZoom, this.maxZoom);
            const g = { center: new o.S(a.lng, a.lat), zoom: h };
            let y = this._helper._lngRange;
            this._helper._renderWorldCopies || y !== null || (y = [-179.9999999999, 180 - 1e-10]);
            const w = this.tileSize * o.ae(g.zoom);
            let C = 0, P = w, L = 0, F = w, j = 0, X = 0;
            const { x: G, y: Q } = this.size;
            if (this._helper._latRange) {
              const Ve = this._helper._latRange;
              C = o.U(Ve[1]) * w, P = o.U(Ve[0]) * w, P - C < Q && (j = Q / (P - C));
            }
            y && (L = o.aN(o.V(y[0]) * w, 0, w), F = o.aN(o.V(y[1]) * w, 0, w), F < L && (F += w), F - L < G && (X = G / (F - L)));
            const { x: le, y: Ae } = nt(w, a);
            let we, Te;
            const Me = Math.max(X || 0, j || 0);
            if (Me) {
              const Ve = new o.P(X ? (F + L) / 2 : le, j ? (P + C) / 2 : Ae);
              return g.center = oe(w, Ve).wrap(), g.zoom += o.aj(Me), g;
            }
            if (this._helper._latRange) {
              const Ve = Q / 2;
              Ae - Ve < C && (Te = C + Ve), Ae + Ve > P && (Te = P - Ve);
            }
            if (y) {
              const Ve = (L + F) / 2;
              let De = le;
              this._helper._renderWorldCopies && (De = o.aN(le, Ve - w / 2, Ve + w / 2));
              const He = G / 2;
              De - He < L && (we = L + He), De + He > F && (we = F - He);
            }
            if (we !== void 0 || Te !== void 0) {
              const Ve = new o.P(we ?? le, Te ?? Ae);
              g.center = oe(w, Ve).wrap();
            }
            return g;
          }
          calculateCenterFromCameraLngLatAlt(a, h, g, y) {
            return this._helper.calculateCenterFromCameraLngLatAlt(a, h, g, y);
          }
          _calculateNearFarZIfNeeded(a, h, g) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const y = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), w = a - y * this._helper._pixelPerMeter / Math.cos(h), C = y < 0 ? w : a, P = Math.PI / 2 + this.pitchInRadians, L = o.ad(this.fov) * (Math.abs(Math.cos(o.ad(this.roll))) * this.height + Math.abs(Math.sin(o.ad(this.roll))) * this.width) / this.height * (0.5 + g.y / this.height), F = Math.sin(L) * C / Math.sin(o.ag(Math.PI - P - L, 0.01, Math.PI - 0.01)), j = fe(this), X = Math.atan(j / this._helper.cameraToCenterDistance), G = o.ad(0.75), Q = X > G ? 2 * X * (0.5 + g.y / (2 * j)) : G, le = Math.sin(Q) * C / Math.sin(o.ag(Math.PI - P - Q, 0.01, Math.PI - 0.01)), Ae = Math.min(F, le);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - h) * Ae + C), this._helper._nearZ = this._helper._height / 50;
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const a = this.centerOffset, h = nt(this.worldSize, this.center), g = h.x, y = h.y;
            this._helper._pixelPerMeter = o.ai(1, this.center.lat) * this.worldSize;
            const w = o.ad(Math.min(this.pitch, gr)), C = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(w));
            let P;
            this._calculateNearFarZIfNeeded(C, w, a), P = new Float64Array(16), o.b3(P, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), o.ap(this._invProjMatrix, P), P[8] = 2 * -a.x / this._helper._width, P[9] = 2 * a.y / this._helper._height, this._projectionMatrix = o.b4(P), o.N(P, P, [1, -1, 1]), o.M(P, P, [0, 0, -this._helper.cameraToCenterDistance]), o.b5(P, P, -this.rollInRadians), o.b6(P, P, this.pitchInRadians), o.b5(P, P, -this.bearingInRadians), o.M(P, P, [-g, -y, 0]), this._mercatorMatrix = o.N([], P, [this.worldSize, this.worldSize, this.worldSize]), o.N(P, P, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = o.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, P), o.M(P, P, [0, 0, -this.elevation]), this._viewProjMatrix = P, this._invViewProjMatrix = o.ap([], P);
            const L = [0, 0, -1, 1];
            o.av(L, L, this._invViewProjMatrix), this._cameraPosition = [L[0] / L[3], L[1] / L[3], L[2] / L[3]], this._fogMatrix = new Float64Array(16), o.b3(this._fogMatrix, this.fovInRadians, this.width / this.height, C, this._helper._farZ), this._fogMatrix[8] = 2 * -a.x / this.width, this._fogMatrix[9] = 2 * a.y / this.height, o.N(this._fogMatrix, this._fogMatrix, [1, -1, 1]), o.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), o.b5(this._fogMatrix, this._fogMatrix, -this.rollInRadians), o.b6(this._fogMatrix, this._fogMatrix, this.pitchInRadians), o.b5(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), o.M(this._fogMatrix, this._fogMatrix, [-g, -y, 0]), o.N(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), o.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = o.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, P);
            const F = this._helper._width % 2 / 2, j = this._helper._height % 2 / 2, X = Math.cos(this.bearingInRadians), G = Math.sin(-this.bearingInRadians), Q = g - Math.round(g) + X * F + G * j, le = y - Math.round(y) + X * j + G * F, Ae = new Float64Array(P);
            if (o.M(Ae, Ae, [Q > 0.5 ? Q - 1 : Q, le > 0.5 ? le - 1 : le, 0]), this._alignedProjMatrix = Ae, P = o.ap(new Float64Array(16), this._pixelMatrix), !P) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = P, this._clearMatrixCaches();
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const a = this.screenPointToMercatorCoordinate(new o.P(0, 0)), h = [a.x * this.worldSize, a.y * this.worldSize, 0, 1];
            return o.av(h, h, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            const a = o.ai(1, this.center.lat) * this.worldSize;
            return Le(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / a).toLngLat();
          }
          lngLatToCameraDepth(a, h) {
            const g = o.a0.fromLngLat(a), y = [g.x * this.worldSize, g.y * this.worldSize, h, 1];
            return o.av(y, y, this._viewProjMatrix), y[2] / y[3];
          }
          getProjectionData(a) {
            const { overscaledTileID: h, aligned: g, applyTerrainMatrix: y } = a, w = this._helper.getMercatorTileCoordinates(h), C = h ? this.calculatePosMatrix(h, g, !0) : null;
            let P;
            return P = h && h.terrainRttPosMatrix32f && y ? h.terrainRttPosMatrix32f : C || o.b7(), { mainMatrix: P, tileMercatorCoords: w, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: P };
          }
          isLocationOccluded(a) {
            return !1;
          }
          getPixelScale() {
            return 1;
          }
          getCircleRadiusCorrection() {
            return 1;
          }
          getPitchedTextCorrection(a, h, g) {
            return 1;
          }
          transformLightDirection(a) {
            return o.aS(a);
          }
          getRayDirectionFromPixel(a) {
            throw new Error("Not implemented.");
          }
          projectTileCoordinates(a, h, g, y) {
            const w = this.calculatePosMatrix(g);
            let C;
            y ? (C = [a, h, y(a, h), 1], o.av(C, C, w)) : (C = [a, h, 0, 1], va(C, C, w));
            const P = C[3];
            return { point: new o.P(C[0] / P, C[1] / P), signedDistanceFromCamera: P, isOccluded: !1 };
          }
          populateCache(a) {
            for (const h of a) this.calculatePosMatrix(h);
          }
          getMatrixForModel(a, h) {
            const g = o.a0.fromLngLat(a, h), y = g.meterInMercatorCoordinateUnits(), w = o.b8();
            return o.M(w, w, [g.x, g.y, g.z]), o.b5(w, w, Math.PI), o.b6(w, w, Math.PI / 2), o.N(w, w, [-y, y, y]), w;
          }
          getProjectionDataForCustomLayer() {
            let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
            const h = new o.Z(0, 0, 0, 0, 0), g = this.getProjectionData({ overscaledTileID: h, applyGlobeMatrix: a }), y = ye(h, this.worldSize);
            o.O(y, this._viewProjMatrix, y), g.tileMercatorCoords = [0, 0, 1, 1];
            const w = [o.$, o.$, this.worldSize / this._helper.pixelsPerMeter], C = o.b9();
            return o.N(C, y, w), g.fallbackMatrix = C, g.mainMatrix = C, g;
          }
          getFastPathSimpleProjectionMatrix(a) {
            return this.calculatePosMatrix(a);
          }
        }
        function Wi() {
          o.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
        }
        function Ni(v) {
          if (v.useSlerp)
            if (v.k < 1) {
              const a = o.ba(v.startEulerAngles.roll, v.startEulerAngles.pitch, v.startEulerAngles.bearing), h = o.ba(v.endEulerAngles.roll, v.endEulerAngles.pitch, v.endEulerAngles.bearing), g = new Float64Array(4);
              o.bb(g, a, h, v.k);
              const y = o.bc(g);
              v.tr.setRoll(y.roll), v.tr.setPitch(y.pitch), v.tr.setBearing(y.bearing);
            } else v.tr.setRoll(v.endEulerAngles.roll), v.tr.setPitch(v.endEulerAngles.pitch), v.tr.setBearing(v.endEulerAngles.bearing);
          else v.tr.setRoll(o.C.number(v.startEulerAngles.roll, v.endEulerAngles.roll, v.k)), v.tr.setPitch(o.C.number(v.startEulerAngles.pitch, v.endEulerAngles.pitch, v.k)), v.tr.setBearing(o.C.number(v.startEulerAngles.bearing, v.endEulerAngles.bearing, v.k));
        }
        function jn(v, a, h, g, y) {
          const w = y.padding, C = nt(y.worldSize, h.getNorthWest()), P = nt(y.worldSize, h.getNorthEast()), L = nt(y.worldSize, h.getSouthEast()), F = nt(y.worldSize, h.getSouthWest()), j = o.ad(-g), X = C.rotate(j), G = P.rotate(j), Q = L.rotate(j), le = F.rotate(j), Ae = new o.P(Math.max(X.x, G.x, le.x, Q.x), Math.max(X.y, G.y, le.y, Q.y)), we = new o.P(Math.min(X.x, G.x, le.x, Q.x), Math.min(X.y, G.y, le.y, Q.y)), Te = Ae.sub(we), Me = (y.width - (w.left + w.right + a.left + a.right)) / Te.x, Ve = (y.height - (w.top + w.bottom + a.top + a.bottom)) / Te.y;
          if (Ve < 0 || Me < 0) return void Wi();
          const De = Math.min(o.aj(y.scale * Math.min(Me, Ve)), v.maxZoom), He = o.P.convert(v.offset), Ze = new o.P((a.left - a.right) / 2, (a.top - a.bottom) / 2).rotate(o.ad(g)), Fe = He.add(Ze).mult(y.scale / o.ae(De));
          return { center: oe(y.worldSize, C.add(L).div(2).sub(Fe)), zoom: De, bearing: g };
        }
        class wl {
          get useGlobeControls() {
            return !1;
          }
          handlePanInertia(a, h) {
            return { easingOffset: a, easingCenter: h.center };
          }
          handleMapControlsRollPitchBearingZoom(a, h) {
            a.bearingDelta && h.setBearing(h.bearing + a.bearingDelta), a.pitchDelta && h.setPitch(h.pitch + a.pitchDelta), a.rollDelta && h.setRoll(h.roll + a.rollDelta), a.zoomDelta && h.setZoom(h.zoom + a.zoomDelta);
          }
          handleMapControlsPan(a, h, g) {
            a.around.distSqr(h.centerPoint) < 0.01 || h.setLocationAtPoint(g, a.around);
          }
          cameraForBoxAndBearing(a, h, g, y, w) {
            return jn(a, h, g, y, w);
          }
          handleJumpToCenterZoom(a, h) {
            a.zoom !== (h.zoom !== void 0 ? +h.zoom : a.zoom) && a.setZoom(+h.zoom), h.center !== void 0 && a.setCenter(o.S.convert(h.center));
          }
          handleEaseTo(a, h) {
            const g = a.zoom, y = a.padding, w = { roll: a.roll, pitch: a.pitch, bearing: a.bearing }, C = { roll: h.roll === void 0 ? a.roll : h.roll, pitch: h.pitch === void 0 ? a.pitch : h.pitch, bearing: h.bearing === void 0 ? a.bearing : h.bearing }, P = h.zoom !== void 0, L = !a.isPaddingEqual(h.padding);
            let F = !1;
            const j = P ? +h.zoom : a.zoom;
            let X = a.centerPoint.add(h.offsetAsPoint);
            const G = a.screenPointToLocation(X), { center: Q, zoom: le } = a.getConstrained(o.S.convert(h.center || G), j ?? g);
            hi(a, Q);
            const Ae = nt(a.worldSize, G), we = nt(a.worldSize, Q).sub(Ae), Te = o.ae(le - g);
            return F = le !== g, { easeFunc: (Me) => {
              if (F && a.setZoom(o.C.number(g, le, Me)), o.bd(w, C) || Ni({ startEulerAngles: w, endEulerAngles: C, tr: a, k: Me, useSlerp: w.roll != C.roll }), L && (a.interpolatePadding(y, h.padding, Me), X = a.centerPoint.add(h.offsetAsPoint)), h.around) a.setLocationAtPoint(h.around, h.aroundPoint);
              else {
                const Ve = o.ae(a.zoom - g), De = le > g ? Math.min(2, Te) : Math.max(0.5, Te), He = Math.pow(De, 1 - Me), Ze = oe(a.worldSize, Ae.add(we.mult(Me * He)).mult(Ve));
                a.setLocationAtPoint(a.renderWorldCopies ? Ze.wrap() : Ze, X);
              }
            }, isZooming: F, elevationCenter: Q };
          }
          handleFlyTo(a, h) {
            const g = h.zoom !== void 0, y = a.zoom, w = a.getConstrained(o.S.convert(h.center || h.locationAtOffset), g ? +h.zoom : y), C = w.center, P = w.zoom;
            hi(a, C);
            const L = nt(a.worldSize, h.locationAtOffset), F = nt(a.worldSize, C).sub(L), j = F.mag(), X = o.ae(P - y);
            let G;
            if (h.minZoom !== void 0) {
              const Q = Math.min(+h.minZoom, y, P), le = a.getConstrained(C, Q).zoom;
              G = o.ae(le - y);
            }
            return { easeFunc: (Q, le, Ae, we) => {
              a.setZoom(Q === 1 ? P : y + o.aj(le));
              const Te = Q === 1 ? C : oe(a.worldSize, L.add(F.mult(Ae)).mult(le));
              a.setLocationAtPoint(a.renderWorldCopies ? Te.wrap() : Te, we);
            }, scaleOfZoom: X, targetCenter: C, scaleOfMinZoom: G, pixelPathLength: j };
          }
        }
        class pn {
          constructor(a, h, g) {
            this.blendFunction = a, this.blendColor = h, this.mask = g;
          }
        }
        pn.Replace = [1, 0], pn.disabled = new pn(pn.Replace, o.be.transparent, [!1, !1, !1, !1]), pn.unblended = new pn(pn.Replace, o.be.transparent, [!0, !0, !0, !0]), pn.alphaBlended = new pn([1, 771], o.be.transparent, [!0, !0, !0, !0]);
        const Ps = 2305;
        class Wr {
          constructor(a, h, g) {
            this.enable = a, this.mode = h, this.frontFace = g;
          }
        }
        Wr.disabled = new Wr(!1, 1029, Ps), Wr.backCCW = new Wr(!0, 1029, Ps), Wr.frontCCW = new Wr(!0, 1028, Ps);
        class Yr {
          constructor(a, h, g) {
            this.func = a, this.mask = h, this.range = g;
          }
        }
        Yr.ReadOnly = !1, Yr.ReadWrite = !0, Yr.disabled = new Yr(519, Yr.ReadOnly, [0, 1]);
        const bo = 7680;
        class Or {
          constructor(a, h, g, y, w, C) {
            this.test = a, this.ref = h, this.mask = g, this.fail = y, this.depthFail = w, this.pass = C;
          }
        }
        Or.disabled = new Or({ func: 519, mask: 0 }, 0, 0, bo, bo, bo);
        const Za = /* @__PURE__ */ new WeakMap();
        function Di(v) {
          var a;
          if (Za.has(v)) return Za.get(v);
          {
            const h = (a = v.getParameter(v.VERSION)) === null || a === void 0 ? void 0 : a.startsWith("WebGL 2.0");
            return Za.set(v, h), h;
          }
        }
        class Ta {
          get awaitingQuery() {
            return !!this._readbackQueue;
          }
          constructor(a) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = a;
            const h = a.context, g = h.gl;
            this._texFormat = g.RGBA, this._texType = g.UNSIGNED_BYTE;
            const y = new o.aK();
            y.emplaceBack(-1, -1), y.emplaceBack(2, -1), y.emplaceBack(-1, 2);
            const w = new o.aM();
            w.emplaceBack(0, 1, 2), this._fullscreenTriangle = new sa(h.createVertexBuffer(y, oa.members), h.createIndexBuffer(w), o.aL.simpleSegment(0, 0, y.length, w.length)), this._resultBuffer = new Uint8Array(4), h.activeTexture.set(g.TEXTURE1);
            const C = g.createTexture();
            g.bindTexture(g.TEXTURE_2D, C), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_S, g.CLAMP_TO_EDGE), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_T, g.CLAMP_TO_EDGE), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MIN_FILTER, g.NEAREST), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MAG_FILTER, g.NEAREST), g.texImage2D(g.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = h.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(C), Di(g) && (this._pbo = g.createBuffer(), g.bindBuffer(g.PIXEL_PACK_BUFFER, this._pbo), g.bufferData(g.PIXEL_PACK_BUFFER, 4, g.STREAM_READ), g.bindBuffer(g.PIXEL_PACK_BUFFER, null));
          }
          destroy() {
            const a = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), a.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
          }
          updateErrorLoop(a, h) {
            const g = this._updateCount;
            return this._readbackQueue ? g >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : g >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(a, h), this._updateCount++, this._measuredError;
          }
          _bindFramebuffer() {
            const a = this._cachedRenderContext.context, h = a.gl;
            a.activeTexture.set(h.TEXTURE1), h.bindTexture(h.TEXTURE_2D, this._fbo.colorAttachment.get()), a.bindFramebuffer.set(this._fbo.framebuffer);
          }
          _renderErrorTexture(a, h) {
            const g = this._cachedRenderContext.context, y = g.gl;
            if (this._bindFramebuffer(), g.viewport.set([0, 0, this._texWidth, this._texHeight]), g.clear({ color: o.be.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(g, y.TRIANGLES, Yr.disabled, Or.disabled, pn.unblended, Wr.disabled, /* @__PURE__ */ ((w, C) => ({ u_input: w, u_output_expected: C }))(a, h), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && Di(y)) {
              y.bindBuffer(y.PIXEL_PACK_BUFFER, this._pbo), y.readBuffer(y.COLOR_ATTACHMENT0), y.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), y.bindBuffer(y.PIXEL_PACK_BUFFER, null);
              const w = y.fenceSync(y.SYNC_GPU_COMMANDS_COMPLETE, 0);
              y.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: w };
            } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
          }
          _tryReadback() {
            const a = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && Di(a)) {
              const h = a.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (h === a.WAIT_FAILED) return o.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
              if (h === a.TIMEOUT_EXPIRED) return;
              a.bindBuffer(a.PIXEL_PACK_BUFFER, this._pbo), a.getBufferSubData(a.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), a.bindBuffer(a.PIXEL_PACK_BUFFER, null);
            } else this._bindFramebuffer(), a.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = Ta._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
          }
          static _parseRGBA8float(a) {
            let h = 0;
            return h += a[0] / 256, h += a[1] / 65536, h += a[2] / 16777216, a[3] < 127 && (h = -h), h / 128;
          }
        }
        const bs = o.$ / 128;
        function zc(v, a) {
          const h = v.granularity !== void 0 ? Math.max(v.granularity, 1) : 1, g = h + (v.generateBorders ? 2 : 0), y = h + (v.extendToNorthPole || v.generateBorders ? 1 : 0) + (v.extendToSouthPole || v.generateBorders ? 1 : 0), w = g + 1, C = y + 1, P = v.generateBorders ? -1 : 0, L = v.generateBorders || v.extendToNorthPole ? -1 : 0, F = h + (v.generateBorders ? 1 : 0), j = h + (v.generateBorders || v.extendToSouthPole ? 1 : 0), X = w * C, G = g * y * 6, Q = w * C > 65536;
          if (Q && a === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const le = Q || a === "32bit", Ae = new Int16Array(2 * X);
          let we = 0;
          for (let Ve = L; Ve <= j; Ve++) for (let De = P; De <= F; De++) {
            let He = De / h * o.$;
            De === -1 && (He = -64), De === h + 1 && (He = o.$ + bs);
            let Ze = Ve / h * o.$;
            Ve === -1 && (Ze = v.extendToNorthPole ? o.bg : -64), Ve === h + 1 && (Ze = v.extendToSouthPole ? o.bh : o.$ + bs), Ae[we++] = He, Ae[we++] = Ze;
          }
          const Te = le ? new Uint32Array(G) : new Uint16Array(G);
          let Me = 0;
          for (let Ve = 0; Ve < y; Ve++) for (let De = 0; De < g; De++) {
            const He = De + 1 + Ve * w, Ze = De + (Ve + 1) * w, Fe = De + 1 + (Ve + 1) * w;
            Te[Me++] = De + Ve * w, Te[Me++] = Ze, Te[Me++] = He, Te[Me++] = He, Te[Me++] = Ze, Te[Me++] = Fe;
          }
          return { vertices: Ae.buffer.slice(0), indices: Te.buffer.slice(0), uses32bitIndices: le };
        }
        const vo = new o.aJ({ fill: new o.bi(128, 2), line: new o.bi(512, 0), tile: new o.bi(128, 32), stencil: new o.bi(128, 1), circle: 3 });
        class Eu {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
          }
          get name() {
            return "vertical-perspective";
          }
          get transitionState() {
            return 1;
          }
          get useSubdivision() {
            return !0;
          }
          get shaderVariantName() {
            return "globe";
          }
          get shaderDefine() {
            return "#define GLOBE";
          }
          get shaderPreludeCode() {
            return oo.projectionGlobe;
          }
          get vertexShaderPreludeCode() {
            return oo.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return vo;
          }
          get useGlobeControls() {
            return !0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable;
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy();
          }
          updateGPUdependent(a) {
            this._errorMeasurement || (this._errorMeasurement = new Ta(a));
            const h = o.U(this._errorQueryLatitudeDegrees), g = 2 * Math.atan(Math.exp(Math.PI - h * Math.PI * 2)) - 0.5 * Math.PI, y = this._errorMeasurement.updateErrorLoop(h, g), w = M.now();
            y !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = y, this._errorMeasurementLastChangeTime = w);
            const C = Math.min(Math.max((w - this._errorMeasurementLastChangeTime) / 1e3 / 0.5, 0), 1);
            this._errorCorrectionUsable = o.bj(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, o.bk(C));
          }
          _getMeshKey(a) {
            return `${a.granularity.toString(36)}_${a.generateBorders ? "b" : ""}${a.extendToNorthPole ? "n" : ""}${a.extendToSouthPole ? "s" : ""}`;
          }
          getMeshFromTileID(a, h, g, y, w) {
            const C = (w === "stencil" ? vo.stencil : vo.tile).getGranularityForZoomLevel(h.z);
            return this._getMesh(a, { granularity: C, generateBorders: g, extendToNorthPole: h.y === 0 && y, extendToSouthPole: h.y === (1 << h.z) - 1 && y });
          }
          _getMesh(a, h) {
            const g = this._getMeshKey(h);
            if (g in this._tileMeshCache) return this._tileMeshCache[g];
            const y = function(w, C) {
              const P = zc(C, "16bit"), L = o.aK.deserialize({ arrayBuffer: P.vertices, length: P.vertices.byteLength / 2 / 2 }), F = o.aM.deserialize({ arrayBuffer: P.indices, length: P.indices.byteLength / 2 / 3 });
              return new sa(w.createVertexBuffer(L, oa.members), w.createIndexBuffer(F), o.aL.simpleSegment(0, 0, L.length, F.length));
            }(a, h);
            return this._tileMeshCache[g] = y, y;
          }
          recalculate(a) {
          }
          hasTransition() {
            const a = M.now();
            let h = !1;
            return h = h || (a - this._errorMeasurementLastChangeTime) / 1e3 < 0.7, h = h || this._errorMeasurement && this._errorMeasurement.awaitingQuery, h;
          }
          setErrorQueryLatitudeDegrees(a) {
            this._errorQueryLatitudeDegrees = a;
          }
        }
        const Cu = new o.r({ type: new o.D(o.v.projection.type) });
        class ao extends o.E {
          constructor(a) {
            super(), this._transitionable = new o.t(Cu), this.setProjection(a), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new o.F(0)), this._mercatorProjection = new vl(), this._verticalPerspectiveProjection = new Eu();
          }
          get transitionState() {
            const a = this.properties.get("type");
            if (typeof a == "string" && a === "mercator") return 0;
            if (typeof a == "string" && a === "vertical-perspective") return 1;
            if (a instanceof o.bl) {
              if (a.from === "vertical-perspective" && a.to === "mercator") return 1 - a.transition;
              if (a.from === "mercator" && a.to === "vertical-perspective") return a.transition;
            }
            return 1;
          }
          get useGlobeRendering() {
            return this.transitionState > 0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
          }
          get name() {
            return "globe";
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision;
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName;
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine;
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode;
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode;
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity;
          }
          get useGlobeControls() {
            return this.transitionState > 0;
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
          }
          updateGPUdependent(a) {
            this._mercatorProjection.updateGPUdependent(a), this._verticalPerspectiveProjection.updateGPUdependent(a);
          }
          getMeshFromTileID(a, h, g, y, w) {
            return this.currentProjection.getMeshFromTileID(a, h, g, y, w);
          }
          setProjection(a) {
            this._transitionable.setValue("type", (a == null ? void 0 : a.type) || "mercator");
          }
          updateTransitions(a) {
            this._transitioning = this._transitionable.transitioned(a, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
          }
          recalculate(a) {
            this.properties = this._transitioning.possiblyEvaluate(a);
          }
          setErrorQueryLatitudeDegrees(a) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(a), this._mercatorProjection.setErrorQueryLatitudeDegrees(a);
          }
        }
        function xo(v) {
          const a = Rs(v.worldSize, v.center.lat);
          return 2 * Math.PI * a;
        }
        function wo(v, a, h, g, y) {
          const w = 1 / (1 << y), C = a / o.$ * w + g * w, P = o.bn((v / o.$ * w + h * w) * Math.PI * 2 + Math.PI, 2 * Math.PI), L = 2 * Math.atan(Math.exp(Math.PI - C * Math.PI * 2)) - 0.5 * Math.PI, F = Math.cos(L), j = new Float64Array(3);
          return j[0] = Math.sin(P) * F, j[1] = Math.sin(L), j[2] = Math.cos(P) * F, j;
        }
        function ai(v) {
          return function(a, h) {
            const g = Math.cos(h), y = new Float64Array(3);
            return y[0] = Math.sin(a) * g, y[1] = Math.sin(h), y[2] = Math.cos(a) * g, y;
          }(v.lng * Math.PI / 180, v.lat * Math.PI / 180);
        }
        function Rs(v, a) {
          return v / (2 * Math.PI) / Math.cos(a * Math.PI / 180);
        }
        function Ya(v) {
          const a = Math.asin(v[1]) / Math.PI * 180, h = Math.sqrt(v[0] * v[0] + v[2] * v[2]);
          if (h > 1e-6) {
            const g = v[0] / h, y = Math.acos(v[2] / h), w = (g > 0 ? y : -y) / Math.PI * 180;
            return new o.S(o.aN(w, -180, 180), a);
          }
          return new o.S(0, a);
        }
        function Bo(v) {
          return Math.cos(v * Math.PI / 180);
        }
        function Ri(v, a) {
          const h = Bo(v), g = Bo(a);
          return o.aj(g / h);
        }
        function Sa(v, a) {
          const h = v.rotate(a.bearingInRadians), g = a.zoom + Ri(a.center.lat, 0), y = o.bj(1 / Bo(a.center.lat), 1 / Bo(Math.min(Math.abs(a.center.lat), 60)), o.bm(g, 7, 3, 0, 1)), w = 360 / xo({ worldSize: a.worldSize, center: { lat: a.center.lat } });
          return new o.S(a.center.lng - h.x * w * y, o.ag(a.center.lat + h.y * w, -85.051129, o.ah));
        }
        function Al(v) {
          const a = 0.5 * v, h = Math.sin(a), g = Math.cos(a);
          return Math.log(h + g) - Math.log(g - h);
        }
        function Ea(v, a, h, g) {
          const y = v.lat + h * g;
          if (Math.abs(h) > 1) {
            const w = (Math.sign(v.lat + h) !== Math.sign(v.lat) ? -Math.abs(v.lat) : Math.abs(v.lat)) * Math.PI / 180, C = Math.abs(v.lat + h) * Math.PI / 180, P = Al(w + g * (C - w)), L = Al(w), F = Al(C);
            return new o.S(v.lng + a * ((P - L) / (F - L)), y);
          }
          return new o.S(v.lng + a * g, y);
        }
        class Iu {
          constructor(a) {
            this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = !1, this._boundingVolumeFactory = a;
          }
          swapBuffers() {
            if (!this._hadAnyChanges) return;
            const a = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = a, this._cache.clear(), this._hadAnyChanges = !1;
          }
          getTileBoundingVolume(a, h, g, y) {
            const w = `${a.z}_${a.x}_${a.y}_${y != null && y.terrain ? "t" : ""}`, C = this._cache.get(w);
            if (C) return C;
            const P = this._cachePrevious.get(w);
            if (P) return this._cache.set(w, P), P;
            const L = this._boundingVolumeFactory(a, h, g, y);
            return this._cache.set(w, L), this._hadAnyChanges = !0, L;
          }
        }
        class aa {
          constructor(a, h, g, y) {
            this.min = g, this.max = y, this.points = a, this.planes = h;
          }
          static fromAabb(a, h) {
            const g = [];
            for (let y = 0; y < 8; y++) g.push([1 & ~y ? a[0] : h[0], (y >> 1 & 1) == 1 ? h[1] : a[1], (y >> 2 & 1) == 1 ? h[2] : a[2]]);
            return new aa(g, [[-1, 0, 0, h[0]], [1, 0, 0, -a[0]], [0, -1, 0, h[1]], [0, 1, 0, -a[1]], [0, 0, -1, h[2]], [0, 0, 1, -a[2]]], a, h);
          }
          static fromCenterSizeAngles(a, h, g) {
            const y = o.bq([], g[0], g[1], g[2]), w = o.br([], [h[0], 0, 0], y), C = o.br([], [0, h[1], 0], y), P = o.br([], [0, 0, h[2]], y), L = [...a], F = [...a];
            for (let X = 0; X < 8; X++) for (let G = 0; G < 3; G++) {
              const Q = a[G] + w[G] * (1 & ~X ? -1 : 1) + C[G] * ((X >> 1 & 1) == 1 ? 1 : -1) + P[G] * ((X >> 2 & 1) == 1 ? 1 : -1);
              L[G] = Math.min(L[G], Q), F[G] = Math.max(F[G], Q);
            }
            const j = [];
            for (let X = 0; X < 8; X++) {
              const G = [...a];
              o.aR(G, G, o.aQ([], w, 1 & ~X ? -1 : 1)), o.aR(G, G, o.aQ([], C, (X >> 1 & 1) == 1 ? 1 : -1)), o.aR(G, G, o.aQ([], P, (X >> 2 & 1) == 1 ? 1 : -1)), j.push(G);
            }
            return new aa(j, [[...w, -o.aW(w, j[0])], [...C, -o.aW(C, j[0])], [...P, -o.aW(P, j[0])], [-w[0], -w[1], -w[2], -o.aW(w, j[7])], [-C[0], -C[1], -C[2], -o.aW(C, j[7])], [-P[0], -P[1], -P[2], -o.aW(P, j[7])]], L, F);
          }
          intersectsFrustum(a) {
            let h = !0;
            const g = this.points.length, y = this.planes.length, w = a.planes.length, C = a.points.length;
            for (let P = 0; P < w; P++) {
              const L = a.planes[P];
              let F = 0;
              for (let j = 0; j < g; j++) {
                const X = this.points[j];
                L[0] * X[0] + L[1] * X[1] + L[2] * X[2] + L[3] >= 0 && F++;
              }
              if (F === 0) return 0;
              F < g && (h = !1);
            }
            if (h) return 2;
            for (let P = 0; P < y; P++) {
              const L = this.planes[P];
              let F = 0;
              for (let j = 0; j < C; j++) {
                const X = a.points[j];
                L[0] * X[0] + L[1] * X[1] + L[2] * X[2] + L[3] >= 0 && F++;
              }
              if (F === 0) return 0;
            }
            return 1;
          }
          intersectsPlane(a) {
            const h = this.points.length;
            let g = 0;
            for (let y = 0; y < h; y++) {
              const w = this.points[y];
              a[0] * w[0] + a[1] * w[1] + a[2] * w[2] + a[3] >= 0 && g++;
            }
            return g === h ? 2 : g === 0 ? 0 : 1;
          }
        }
        function Ca(v, a, h) {
          const g = v - a;
          return g < 0 ? -g : Math.max(0, g - h);
        }
        function Hl(v, a, h, g, y) {
          const w = v - h;
          let C;
          return C = w < 0 ? Math.min(-w, 1 + w - y) : w > 1 ? Math.min(Math.max(w - y, 0), 1 - w) : 0, Math.max(C, Ca(a, g, y));
        }
        class Mu {
          constructor() {
            this._boundingVolumeCache = new Iu(this._computeTileBoundingVolume);
          }
          prepareNextFrame() {
            this._boundingVolumeCache.swapBuffers();
          }
          distanceToTile2d(a, h, g, y) {
            const w = 1 << g.z, C = 1 / w, P = g.x / w, L = g.y / w;
            let F = 2;
            return F = Math.min(F, Hl(a, h, P, L, C)), F = Math.min(F, Hl(a, h, P + 0.5, -L - C, C)), F = Math.min(F, Hl(a, h, P + 0.5, 2 - L - C, C)), F;
          }
          getWrap(a, h, g) {
            const y = 1 << h.z, w = 1 / y, C = h.x / y, P = Ca(a.x, C, w), L = Ca(a.x, C - 1, w), F = Ca(a.x, C + 1, w), j = Math.min(P, L, F);
            return j === F ? 1 : j === L ? -1 : 0;
          }
          allowVariableZoom(a, h) {
            return Bt(a, h) > 4;
          }
          allowWorldCopies() {
            return !1;
          }
          getTileBoundingVolume(a, h, g, y) {
            return this._boundingVolumeCache.getTileBoundingVolume(a, h, g, y);
          }
          _computeTileBoundingVolume(a, h, g, y) {
            var w, C;
            let P = g, L = g;
            if (y != null && y.terrain) {
              const F = new o.Z(a.z, h, a.z, a.x, a.y), j = y.terrain.getMinMaxElevation(F);
              P = (w = j.minElevation) !== null && w !== void 0 ? w : g, L = (C = j.maxElevation) !== null && C !== void 0 ? C : g;
            }
            if (P /= o.bt, L /= o.bt, P += 1, L += 1, a.z <= 0) return aa.fromAabb([-L, -L, -L], [L, L, L]);
            if (a.z === 1) return aa.fromAabb([a.x === 0 ? -L : 0, a.y === 0 ? 0 : -L, -L], [a.x === 0 ? 0 : L, a.y === 0 ? L : 0, L]);
            {
              const F = [wo(0, 0, a.x, a.y, a.z), wo(o.$, 0, a.x, a.y, a.z), wo(o.$, o.$, a.x, a.y, a.z), wo(0, o.$, a.x, a.y, a.z)], j = [];
              for (const Tt of F) j.push(o.aQ([], Tt, L));
              if (L !== P) for (const Tt of F) j.push(o.aQ([], Tt, P));
              a.y === 0 && j.push([0, 1, 0]), a.y === (1 << a.z) - 1 && j.push([0, -1, 0]);
              const X = [1, 1, 1], G = [-1, -1, -1];
              for (const Tt of j) for (let wt = 0; wt < 3; wt++) X[wt] = Math.min(X[wt], Tt[wt]), G[wt] = Math.max(G[wt], Tt[wt]);
              const Q = wo(o.$ / 2, o.$ / 2, a.x, a.y, a.z), le = o.aV([], [0, 1, 0], Q);
              o.aU(le, le);
              const Ae = o.aV([], Q, le);
              o.aU(Ae, Ae);
              const we = o.aV([], F[2], F[1]);
              o.aU(we, we);
              const Te = o.aV([], F[0], F[3]);
              o.aU(Te, Te), j.push(o.aQ([], Q, L)), a.y >= (1 << a.z) / 2 && j.push(o.aQ([], wo(o.$ / 2, 0, a.x, a.y, a.z), L)), a.y < (1 << a.z) / 2 && j.push(o.aQ([], wo(o.$ / 2, o.$, a.x, a.y, a.z), L));
              const Me = is(Q, j), Ve = is(Ae, j), De = [-Q[0], -Q[1], -Q[2], Me.max], He = [Q[0], Q[1], Q[2], -Me.min], Ze = [-Ae[0], -Ae[1], -Ae[2], Ve.max], Fe = [Ae[0], Ae[1], Ae[2], -Ve.min], it = [...we, 0], bt = [...Te, 0], dt = [];
              return a.y === 0 ? dt.push(o.bs(bt, it, De), o.bs(bt, it, He)) : dt.push(o.bs(Ze, it, De), o.bs(Ze, it, He), o.bs(Ze, bt, De), o.bs(Ze, bt, He)), a.y === (1 << a.z) - 1 ? dt.push(o.bs(bt, it, De), o.bs(bt, it, He)) : dt.push(o.bs(Fe, it, De), o.bs(Fe, it, He), o.bs(Fe, bt, De), o.bs(Fe, bt, He)), new aa(dt, [De, He, Ze, Fe, it, bt], X, G);
            }
          }
        }
        function is(v, a) {
          let h = 1 / 0, g = -1 / 0;
          for (const y of a) {
            const w = o.aW(v, y);
            h = Math.min(h, w), g = Math.max(g, w);
          }
          return { min: h, max: g };
        }
        class Tl {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(a) {
            this._helper.setMinZoom(a);
          }
          setMaxZoom(a) {
            this._helper.setMaxZoom(a);
          }
          setMinPitch(a) {
            this._helper.setMinPitch(a);
          }
          setMaxPitch(a) {
            this._helper.setMaxPitch(a);
          }
          setRenderWorldCopies(a) {
            this._helper.setRenderWorldCopies(a);
          }
          setBearing(a) {
            this._helper.setBearing(a);
          }
          setPitch(a) {
            this._helper.setPitch(a);
          }
          setRoll(a) {
            this._helper.setRoll(a);
          }
          setFov(a) {
            this._helper.setFov(a);
          }
          setZoom(a) {
            this._helper.setZoom(a);
          }
          setCenter(a) {
            this._helper.setCenter(a);
          }
          setElevation(a) {
            this._helper.setElevation(a);
          }
          setMinElevationForCurrentTile(a) {
            this._helper.setMinElevationForCurrentTile(a);
          }
          setPadding(a) {
            this._helper.setPadding(a);
          }
          interpolatePadding(a, h, g) {
            return this._helper.interpolatePadding(a, h, g);
          }
          isPaddingEqual(a) {
            return this._helper.isPaddingEqual(a);
          }
          resize(a, h) {
            this._helper.resize(a, h);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(a) {
            this._helper.setMaxBounds(a);
          }
          overrideNearFarZ(a, h) {
            this._helper.overrideNearFarZ(a, h);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(a) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), a);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(a) {
          }
          constructor() {
            this._cachedClippingPlane = o.bu(), this._projectionMatrix = o.b8(), this._globeViewProjMatrix32f = o.b7(), this._globeViewProjMatrixNoCorrection = o.b8(), this._globeViewProjMatrixNoCorrectionInverted = o.b8(), this._globeProjMatrixInverted = o.b8(), this._cameraPosition = o.bo(), this._globeLatitudeErrorCorrectionRadians = 0, this._helper = new xl({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (a, h) => this.getConstrained(a, h) }), this._coveringTilesDetailsProvider = new Mu();
          }
          clone() {
            const a = new Tl();
            return a.apply(this), a;
          }
          apply(a, h) {
            this._globeLatitudeErrorCorrectionRadians = h || 0, this._helper.apply(a);
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection;
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted;
          }
          get cameraPosition() {
            const a = o.bo();
            return a[0] = this._cameraPosition[0], a[1] = this._cameraPosition[1], a[2] = this._cameraPosition[2], a;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          getProjectionData(a) {
            const { overscaledTileID: h, applyGlobeMatrix: g } = a, y = this._helper.getMercatorTileCoordinates(h);
            return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: y, clippingPlane: this._cachedClippingPlane, projectionTransition: g ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f };
          }
          _computeClippingPlane(a) {
            const h = this.pitchInRadians, g = this.cameraToCenterDistance / a, y = Math.sin(h) * g, w = Math.cos(h) * g + 1, C = 1 / Math.sqrt(y * y + w * w) * 1;
            let P = -y, L = w;
            const F = Math.sqrt(P * P + L * L);
            P /= F, L /= F;
            const j = [0, P, L];
            o.bv(j, j, [0, 0, 0], -this.bearingInRadians), o.bw(j, j, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), o.bx(j, j, [0, 0, 0], this.center.lng * Math.PI / 180);
            const X = 1 / o.aY(j);
            return o.aQ(j, j, X), [...j, -C * X];
          }
          isLocationOccluded(a) {
            return !this.isSurfacePointVisible(ai(a));
          }
          transformLightDirection(a) {
            const h = this._helper._center.lng * Math.PI / 180, g = this._helper._center.lat * Math.PI / 180, y = Math.cos(g), w = [Math.sin(h) * y, Math.sin(g), Math.cos(h) * y], C = [w[2], 0, -w[0]], P = [0, 0, 0];
            o.aV(P, C, w), o.aU(C, C), o.aU(P, P);
            const L = [0, 0, 0];
            return o.aU(L, [C[0] * a[0] + P[0] * a[1] + w[0] * a[2], C[1] * a[0] + P[1] * a[1] + w[1] * a[2], C[2] * a[0] + P[2] * a[1] + w[2] * a[2]]), L;
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getPitchedTextCorrection(a, h, g) {
            const y = function(P, L, F) {
              const j = 1 / (1 << F.z);
              return new o.a0(P / o.$ * j + F.x * j, L / o.$ * j + F.y * j);
            }(a, h, g.canonical), w = (C = y.y, [o.bn(y.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - C * Math.PI * 2)) - 0.5 * Math.PI]);
            var C;
            return this.getCircleRadiusCorrection() / Math.cos(w[1]);
          }
          projectTileCoordinates(a, h, g, y) {
            const w = g.canonical, C = wo(a, h, w.x, w.y, w.z), P = 1 + (y ? y(a, h) : 0) / o.bt, L = [C[0] * P, C[1] * P, C[2] * P, 1];
            o.av(L, L, this._globeViewProjMatrixNoCorrection);
            const F = this._cachedClippingPlane, j = F[0] * C[0] + F[1] * C[1] + F[2] * C[2] + F[3] < 0;
            return { point: new o.P(L[0] / L[3], L[1] / L[3]), signedDistanceFromCamera: L[3], isOccluded: j };
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const a = Rs(this.worldSize, this.center.lat), h = o.b9(), g = o.b9();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = 0.5, this._helper._farZ = this.cameraToCenterDistance + 2 * a), o.b3(h, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const y = this.centerOffset;
            h[8] = 2 * -y.x / this._helper._width, h[9] = 2 * y.y / this._helper._height, this._projectionMatrix = o.b4(h), this._globeProjMatrixInverted = o.b9(), o.ap(this._globeProjMatrixInverted, h), o.M(h, h, [0, 0, -this.cameraToCenterDistance]), o.b5(h, h, this.rollInRadians), o.b6(h, h, -this.pitchInRadians), o.b5(h, h, this.bearingInRadians), o.M(h, h, [0, 0, -a]);
            const w = o.bo();
            w[0] = a, w[1] = a, w[2] = a, o.b6(g, h, this.center.lat * Math.PI / 180), o.by(g, g, -this.center.lng * Math.PI / 180), o.N(g, g, w), this._globeViewProjMatrixNoCorrection = g, o.b6(h, h, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), o.by(h, h, -this.center.lng * Math.PI / 180), o.N(h, h, w), this._globeViewProjMatrix32f = new Float32Array(h), this._globeViewProjMatrixNoCorrectionInverted = o.b9(), o.ap(this._globeViewProjMatrixNoCorrectionInverted, g);
            const C = o.bo();
            this._cameraPosition = o.bo(), this._cameraPosition[2] = this.cameraToCenterDistance / a, o.bv(this._cameraPosition, this._cameraPosition, C, -this.rollInRadians), o.bw(this._cameraPosition, this._cameraPosition, C, this.pitchInRadians), o.bv(this._cameraPosition, this._cameraPosition, C, -this.bearingInRadians), o.aR(this._cameraPosition, this._cameraPosition, [0, 0, 1]), o.bw(this._cameraPosition, this._cameraPosition, C, -this.center.lat * Math.PI / 180), o.bx(this._cameraPosition, this._cameraPosition, C, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(a);
            const P = o.b4(this._globeViewProjMatrixNoCorrectionInverted);
            o.N(P, P, [1, 1, -1]), this._cachedFrustum = ns.fromInvProjectionMatrix(P, 1, 0, this._cachedClippingPlane, !0);
          }
          calculateFogMatrix(a) {
            o.w("calculateFogMatrix is not supported on globe projection.");
            const h = o.b9();
            return o.af(h), h;
          }
          getVisibleUnwrappedCoordinates(a) {
            return [new o.b1(0, a)];
          }
          getCameraFrustum() {
            return this._cachedFrustum;
          }
          getClippingPlane() {
            return this._cachedClippingPlane;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(a) {
            a && o.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
          }
          maxPitchScaleFactor() {
            return 1;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(a, h) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const g = ai(a);
            o.aQ(g, g, 1 + h / o.bt);
            const y = o.bu();
            return o.av(y, [g[0], g[1], g[2], 1], this._globeViewProjMatrixNoCorrection), y[2] / y[3];
          }
          populateCache(a) {
          }
          getBounds() {
            const a = 0.5 * this.width, h = 0.5 * this.height, g = [new o.P(0, 0), new o.P(a, 0), new o.P(this.width, 0), new o.P(this.width, h), new o.P(this.width, this.height), new o.P(a, this.height), new o.P(0, this.height), new o.P(0, h)], y = [];
            for (const X of g) y.push(this.unprojectScreenPoint(X));
            let w = 0, C = 0, P = 0, L = 0;
            const F = this.center;
            for (const X of y) {
              const G = o.bz(F.lng, X.lng), Q = o.bz(F.lat, X.lat);
              G < C && (C = G), G > w && (w = G), Q < L && (L = Q), Q > P && (P = Q);
            }
            const j = [F.lng + C, F.lat + L, F.lng + w, F.lat + P];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (j[3] = 90, j[0] = -180, j[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (j[1] = -90, j[0] = -180, j[2] = 180), new sr(j);
          }
          getConstrained(a, h) {
            const g = o.ag(a.lat, -85.051129, o.ah), y = o.ag(+h, this.minZoom + Ri(0, g), this.maxZoom);
            return { center: new o.S(a.lng, g), zoom: y };
          }
          calculateCenterFromCameraLngLatAlt(a, h, g, y) {
            return this._helper.calculateCenterFromCameraLngLatAlt(a, h, g, y);
          }
          setLocationAtPoint(a, h) {
            const g = ai(this.unprojectScreenPoint(h)), y = ai(a), w = o.bo();
            o.bA(w);
            const C = o.bo();
            o.bx(C, g, w, -this.center.lng * Math.PI / 180), o.bw(C, C, w, this.center.lat * Math.PI / 180);
            const P = y[0] * y[0] + y[2] * y[2], L = C[0] * C[0];
            if (P < L) return;
            const F = Math.sqrt(P - L), j = -F, X = o.bB(y[0], y[2], C[0], F), G = o.bB(y[0], y[2], C[0], j), Q = o.bo();
            o.bx(Q, y, w, -X);
            const le = o.bB(Q[1], Q[2], C[1], C[2]), Ae = o.bo();
            o.bx(Ae, y, w, -G);
            const we = o.bB(Ae[1], Ae[2], C[1], C[2]), Te = 0.5 * Math.PI, Me = le >= -Te && le <= Te, Ve = we >= -Te && we <= Te;
            let De, He;
            if (Me && Ve) {
              const bt = this.center.lng * Math.PI / 180, dt = this.center.lat * Math.PI / 180;
              o.bC(X, bt) + o.bC(le, dt) < o.bC(G, bt) + o.bC(we, dt) ? (De = X, He = le) : (De = G, He = we);
            } else if (Me) De = X, He = le;
            else {
              if (!Ve) return;
              De = G, He = we;
            }
            const Ze = De / Math.PI * 180, Fe = He / Math.PI * 180, it = this.center.lat;
            this.setCenter(new o.S(Ze, o.ag(Fe, -90, 90))), this.setZoom(this.zoom + Ri(it, this.center.lat));
          }
          locationToScreenPoint(a, h) {
            const g = ai(a);
            if (h) {
              const y = h.getElevationForLngLatZoom(a, this._helper._tileZoom);
              o.aQ(g, g, 1 + y / o.bt);
            }
            return this._projectSurfacePointToScreen(g);
          }
          _projectSurfacePointToScreen(a) {
            const h = o.bu();
            return o.av(h, [...a, 1], this._globeViewProjMatrixNoCorrection), h[0] /= h[3], h[1] /= h[3], new o.P((0.5 * h[0] + 0.5) * this.width, (0.5 * -h[1] + 0.5) * this.height);
          }
          screenPointToMercatorCoordinate(a, h) {
            if (h) {
              const g = h.pointCoordinate(a);
              if (g) return g;
            }
            return o.a0.fromLngLat(this.unprojectScreenPoint(a));
          }
          screenPointToLocation(a, h) {
            var g;
            return (g = this.screenPointToMercatorCoordinate(a, h)) === null || g === void 0 ? void 0 : g.toLngLat();
          }
          isPointOnMapSurface(a, h) {
            const g = this._cameraPosition, y = this.getRayDirectionFromPixel(a);
            return !!this.rayPlanetIntersection(g, y);
          }
          getRayDirectionFromPixel(a) {
            const h = o.bu();
            h[0] = a.x / this.width * 2 - 1, h[1] = -1 * (a.y / this.height * 2 - 1), h[2] = 1, h[3] = 1, o.av(h, h, this._globeViewProjMatrixNoCorrectionInverted), h[0] /= h[3], h[1] /= h[3], h[2] /= h[3];
            const g = o.bo();
            g[0] = h[0] - this._cameraPosition[0], g[1] = h[1] - this._cameraPosition[1], g[2] = h[2] - this._cameraPosition[2];
            const y = o.bo();
            return o.aU(y, g), y;
          }
          isSurfacePointVisible(a) {
            const h = this._cachedClippingPlane;
            return h[0] * a[0] + h[1] * a[1] + h[2] * a[2] + h[3] >= 0;
          }
          isSurfacePointOnScreen(a) {
            if (!this.isSurfacePointVisible(a)) return !1;
            const h = o.bu();
            return o.av(h, [...a, 1], this._globeViewProjMatrixNoCorrection), h[0] /= h[3], h[1] /= h[3], h[2] /= h[3], h[0] > -1 && h[0] < 1 && h[1] > -1 && h[1] < 1 && h[2] > -1 && h[2] < 1;
          }
          rayPlanetIntersection(a, h) {
            const g = o.aW(a, h), y = o.bo(), w = o.bo();
            o.aQ(w, h, g), o.aT(y, a, w);
            const C = 1 - o.aW(y, y);
            if (C < 0) return null;
            const P = o.aW(a, a) - 1, L = -g + (g < 0 ? 1 : -1) * Math.sqrt(C), F = P / L, j = L;
            return { tMin: Math.min(F, j), tMax: Math.max(F, j) };
          }
          unprojectScreenPoint(a) {
            const h = this._cameraPosition, g = this.getRayDirectionFromPixel(a), y = this.rayPlanetIntersection(h, g);
            if (y) {
              const j = o.bo();
              o.aR(j, h, [g[0] * y.tMin, g[1] * y.tMin, g[2] * y.tMin]);
              const X = o.bo();
              return o.aU(X, j), Ya(X);
            }
            const w = this._cachedClippingPlane, C = w[0] * g[0] + w[1] * g[1] + w[2] * g[2], P = -o.b0(w, h) / C, L = o.bo();
            if (P > 0) o.aR(L, h, [g[0] * P, g[1] * P, g[2] * P]);
            else {
              const j = o.bo();
              o.aR(j, h, [2 * g[0], 2 * g[1], 2 * g[2]]);
              const X = o.b0(this._cachedClippingPlane, j);
              o.aT(L, j, [this._cachedClippingPlane[0] * X, this._cachedClippingPlane[1] * X, this._cachedClippingPlane[2] * X]);
            }
            const F = function(j) {
              const X = o.bo();
              return X[0] = j[0] * -j[3], X[1] = j[1] * -j[3], X[2] = j[2] * -j[3], { center: X, radius: Math.sqrt(1 - j[3] * j[3]) };
            }(w);
            return Ya(function(j, X, G) {
              const Q = o.bo();
              o.aT(Q, G, j);
              const le = o.bo();
              return o.bp(le, j, Q, X / o.a_(Q)), le;
            }(F.center, F.radius, L));
          }
          getMatrixForModel(a, h) {
            const g = o.S.convert(a), y = 1 / o.bt, w = o.b8();
            return o.by(w, w, g.lng / 180 * Math.PI), o.b6(w, w, -g.lat / 180 * Math.PI), o.M(w, w, [0, 0, 1 + h / o.bt]), o.b6(w, w, 0.5 * Math.PI), o.N(w, w, [y, y, y]), w;
          }
          getProjectionDataForCustomLayer() {
            let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
            const h = this.getProjectionData({ overscaledTileID: new o.Z(0, 0, 0, 0, 0), applyGlobeMatrix: a });
            return h.tileMercatorCoords = [0, 0, 1, 1], h;
          }
          getFastPathSimpleProjectionMatrix(a) {
          }
        }
        class ss {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(a) {
            this._helper.setMinZoom(a);
          }
          setMaxZoom(a) {
            this._helper.setMaxZoom(a);
          }
          setMinPitch(a) {
            this._helper.setMinPitch(a);
          }
          setMaxPitch(a) {
            this._helper.setMaxPitch(a);
          }
          setRenderWorldCopies(a) {
            this._helper.setRenderWorldCopies(a);
          }
          setBearing(a) {
            this._helper.setBearing(a);
          }
          setPitch(a) {
            this._helper.setPitch(a);
          }
          setRoll(a) {
            this._helper.setRoll(a);
          }
          setFov(a) {
            this._helper.setFov(a);
          }
          setZoom(a) {
            this._helper.setZoom(a);
          }
          setCenter(a) {
            this._helper.setCenter(a);
          }
          setElevation(a) {
            this._helper.setElevation(a);
          }
          setMinElevationForCurrentTile(a) {
            this._helper.setMinElevationForCurrentTile(a);
          }
          setPadding(a) {
            this._helper.setPadding(a);
          }
          interpolatePadding(a, h, g) {
            return this._helper.interpolatePadding(a, h, g);
          }
          isPaddingEqual(a) {
            return this._helper.isPaddingEqual(a);
          }
          resize(a, h) {
            let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
            this._helper.resize(a, h, g);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(a) {
            this._helper.setMaxBounds(a);
          }
          overrideNearFarZ(a, h) {
            this._helper.overrideNearFarZ(a, h);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(a) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), a);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          get isGlobeRendering() {
            return this._globeness > 0;
          }
          setTransitionState(a, h) {
            this._globeness = a, this._globeLatitudeErrorCorrectionRadians = h, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame();
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
          }
          constructor() {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this._helper = new xl({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (a, h) => this.getConstrained(a, h) }), this._globeness = 1, this._mercatorTransform = new zn(), this._verticalPerspectiveTransform = new Tl();
          }
          clone() {
            const a = new ss();
            return a._globeness = this._globeness, a._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, a.apply(this), a;
          }
          apply(a) {
            this._helper.apply(a), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians);
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix;
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix;
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition;
          }
          getProjectionData(a) {
            const h = this._mercatorTransform.getProjectionData(a), g = this._verticalPerspectiveTransform.getProjectionData(a);
            return { mainMatrix: this.isGlobeRendering ? g.mainMatrix : h.mainMatrix, clippingPlane: g.clippingPlane, tileMercatorCoords: g.tileMercatorCoords, projectionTransition: a.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: h.fallbackMatrix };
          }
          isLocationOccluded(a) {
            return this.currentTransform.isLocationOccluded(a);
          }
          transformLightDirection(a) {
            return this.currentTransform.transformLightDirection(a);
          }
          getPixelScale() {
            return o.bj(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
          }
          getCircleRadiusCorrection() {
            return o.bj(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
          }
          getPitchedTextCorrection(a, h, g) {
            const y = this._mercatorTransform.getPitchedTextCorrection(a, h, g), w = this._verticalPerspectiveTransform.getPitchedTextCorrection(a, h, g);
            return o.bj(y, w, this._globeness);
          }
          projectTileCoordinates(a, h, g, y) {
            return this.currentTransform.projectTileCoordinates(a, h, g, y);
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
          }
          calculateFogMatrix(a) {
            return this.currentTransform.calculateFogMatrix(a);
          }
          getVisibleUnwrappedCoordinates(a) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(a);
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum();
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane();
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider();
          }
          recalculateZoomAndCenter(a) {
            this._mercatorTransform.recalculateZoomAndCenter(a), this._verticalPerspectiveTransform.recalculateZoomAndCenter(a);
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor();
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(a, h) {
            return this.currentTransform.lngLatToCameraDepth(a, h);
          }
          populateCache(a) {
            this._mercatorTransform.populateCache(a), this._verticalPerspectiveTransform.populateCache(a);
          }
          getBounds() {
            return this.currentTransform.getBounds();
          }
          getConstrained(a, h) {
            return this.currentTransform.getConstrained(a, h);
          }
          calculateCenterFromCameraLngLatAlt(a, h, g, y) {
            return this._helper.calculateCenterFromCameraLngLatAlt(a, h, g, y);
          }
          setLocationAtPoint(a, h) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(a, h), void this.apply(this._mercatorTransform);
            this._verticalPerspectiveTransform.setLocationAtPoint(a, h), this.apply(this._verticalPerspectiveTransform);
          }
          locationToScreenPoint(a, h) {
            return this.currentTransform.locationToScreenPoint(a, h);
          }
          screenPointToMercatorCoordinate(a, h) {
            return this.currentTransform.screenPointToMercatorCoordinate(a, h);
          }
          screenPointToLocation(a, h) {
            return this.currentTransform.screenPointToLocation(a, h);
          }
          isPointOnMapSurface(a, h) {
            return this.currentTransform.isPointOnMapSurface(a, h);
          }
          getRayDirectionFromPixel(a) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(a);
          }
          getMatrixForModel(a, h) {
            return this.currentTransform.getMatrixForModel(a, h);
          }
          getProjectionDataForCustomLayer() {
            let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
            const h = this._mercatorTransform.getProjectionDataForCustomLayer(a);
            if (!this.isGlobeRendering) return h;
            const g = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(a);
            return g.fallbackMatrix = h.mainMatrix, g;
          }
          getFastPathSimpleProjectionMatrix(a) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(a);
          }
        }
        class ji {
          get useGlobeControls() {
            return !0;
          }
          handlePanInertia(a, h) {
            const g = Sa(a, h);
            return Math.abs(g.lng - h.center.lng) > 180 && (g.lng = h.center.lng + 179.5 * Math.sign(g.lng - h.center.lng)), { easingCenter: g, easingOffset: new o.P(0, 0) };
          }
          handleMapControlsRollPitchBearingZoom(a, h) {
            const g = a.around, y = h.screenPointToLocation(g);
            a.bearingDelta && h.setBearing(h.bearing + a.bearingDelta), a.pitchDelta && h.setPitch(h.pitch + a.pitchDelta), a.rollDelta && h.setRoll(h.roll + a.rollDelta);
            const w = h.zoom;
            a.zoomDelta && h.setZoom(h.zoom + a.zoomDelta);
            const C = h.zoom - w;
            if (C === 0) return;
            const P = o.bz(h.center.lng, y.lng), L = P / (Math.abs(P / 180) + 1), F = o.bz(h.center.lat, y.lat), j = h.getRayDirectionFromPixel(g), X = h.cameraPosition, G = -1 * o.aW(X, j), Q = o.bo();
            o.aR(Q, X, [j[0] * G, j[1] * G, j[2] * G]);
            const le = o.aY(Q) - 1, Ae = Math.exp(0.5 * -Math.max(le - 0.3, 0)), we = Rs(h.worldSize, h.center.lat) / Math.min(h.width, h.height), Te = o.bm(we, 0.9, 0.5, 1, 0.25), Me = (1 - o.ae(-C)) * Math.min(Ae, Te), Ve = h.center.lat, De = h.zoom, He = new o.S(h.center.lng + L * Me, o.ag(h.center.lat + F * Me, -85.051129, o.ah));
            h.setLocationAtPoint(y, g);
            const Ze = h.center, Fe = o.bm(Math.abs(P), 45, 85, 0, 1), it = o.bm(we, 0.75, 0.35, 0, 1), bt = Math.pow(Math.max(Fe, it), 0.25), dt = o.bz(Ze.lng, He.lng), Tt = o.bz(Ze.lat, He.lat);
            h.setCenter(new o.S(Ze.lng + dt * bt, Ze.lat + Tt * bt).wrap()), h.setZoom(De + Ri(Ve, h.center.lat));
          }
          handleMapControlsPan(a, h, g) {
            if (!a.panDelta) return;
            const y = h.center.lat, w = h.zoom;
            h.setCenter(Sa(a.panDelta, h).wrap()), h.setZoom(w + Ri(y, h.center.lat));
          }
          cameraForBoxAndBearing(a, h, g, y, w) {
            const C = jn(a, h, g, y, w), P = h.left / w.width * 2 - 1, L = (w.width - h.right) / w.width * 2 - 1, F = h.top / w.height * -2 + 1, j = (w.height - h.bottom) / w.height * -2 + 1, X = o.bz(g.getWest(), g.getEast()) < 0, G = X ? g.getEast() : g.getWest(), Q = X ? g.getWest() : g.getEast(), le = Math.max(g.getNorth(), g.getSouth()), Ae = Math.min(g.getNorth(), g.getSouth()), we = G + 0.5 * o.bz(G, Q), Te = le + 0.5 * o.bz(le, Ae), Me = w.clone();
            Me.setCenter(C.center), Me.setBearing(C.bearing), Me.setPitch(0), Me.setRoll(0), Me.setZoom(C.zoom);
            const Ve = Me.modelViewProjectionMatrix, De = [ai(g.getNorthWest()), ai(g.getNorthEast()), ai(g.getSouthWest()), ai(g.getSouthEast()), ai(new o.S(Q, Te)), ai(new o.S(G, Te)), ai(new o.S(we, le)), ai(new o.S(we, Ae))], He = ai(C.center);
            let Ze = Number.POSITIVE_INFINITY;
            for (const Fe of De) P < 0 && (Ze = ji.getLesserNonNegativeNonNull(Ze, ji.solveVectorScale(Fe, He, Ve, "x", P))), L > 0 && (Ze = ji.getLesserNonNegativeNonNull(Ze, ji.solveVectorScale(Fe, He, Ve, "x", L))), F > 0 && (Ze = ji.getLesserNonNegativeNonNull(Ze, ji.solveVectorScale(Fe, He, Ve, "y", F))), j < 0 && (Ze = ji.getLesserNonNegativeNonNull(Ze, ji.solveVectorScale(Fe, He, Ve, "y", j)));
            if (Number.isFinite(Ze) && Ze !== 0) return C.zoom = Me.zoom + o.aj(Ze), C;
            Wi();
          }
          handleJumpToCenterZoom(a, h) {
            const g = a.center.lat, y = a.getConstrained(h.center ? o.S.convert(h.center) : a.center, a.zoom).center;
            a.setCenter(y.wrap());
            const w = h.zoom !== void 0 ? +h.zoom : a.zoom + Ri(g, y.lat);
            a.zoom !== w && a.setZoom(w);
          }
          handleEaseTo(a, h) {
            const g = a.zoom, y = a.center, w = a.padding, C = { roll: a.roll, pitch: a.pitch, bearing: a.bearing }, P = { roll: h.roll === void 0 ? a.roll : h.roll, pitch: h.pitch === void 0 ? a.pitch : h.pitch, bearing: h.bearing === void 0 ? a.bearing : h.bearing }, L = h.zoom !== void 0, F = !a.isPaddingEqual(h.padding);
            let j = !1;
            const X = h.center ? o.S.convert(h.center) : y, G = a.getConstrained(X, g).center;
            hi(a, G);
            const Q = a.clone();
            Q.setCenter(G), Q.setZoom(L ? +h.zoom : g + Ri(y.lat, X.lat)), Q.setBearing(h.bearing);
            const le = new o.P(o.ag(a.centerPoint.x + h.offsetAsPoint.x, 0, a.width), o.ag(a.centerPoint.y + h.offsetAsPoint.y, 0, a.height));
            Q.setLocationAtPoint(G, le);
            const Ae = (h.offset && h.offsetAsPoint.mag()) > 0 ? Q.center : G, we = L ? +h.zoom : g + Ri(y.lat, Ae.lat), Te = g + Ri(y.lat, 0), Me = we + Ri(Ae.lat, 0), Ve = o.bz(y.lng, Ae.lng), De = o.bz(y.lat, Ae.lat), He = o.ae(Me - Te);
            return j = we !== g, { easeFunc: (Ze) => {
              if (o.bd(C, P) || Ni({ startEulerAngles: C, endEulerAngles: P, tr: a, k: Ze, useSlerp: C.roll != P.roll }), F && a.interpolatePadding(w, h.padding, Ze), h.around) o.w("Easing around a point is not supported under globe projection."), a.setLocationAtPoint(h.around, h.aroundPoint);
              else {
                const Fe = Me > Te ? Math.min(2, He) : Math.max(0.5, He), it = Math.pow(Fe, 1 - Ze), bt = Ea(y, Ve, De, Ze * it);
                a.setCenter(bt.wrap());
              }
              if (j) {
                const Fe = o.C.number(Te, Me, Ze) + Ri(0, a.center.lat);
                a.setZoom(Fe);
              }
            }, isZooming: j, elevationCenter: Ae };
          }
          handleFlyTo(a, h) {
            const g = h.zoom !== void 0, y = a.center, w = a.zoom, C = a.padding, P = !a.isPaddingEqual(h.padding), L = a.getConstrained(o.S.convert(h.center || h.locationAtOffset), w).center, F = g ? +h.zoom : a.zoom + Ri(a.center.lat, L.lat), j = a.clone();
            j.setCenter(L), j.setZoom(F), j.setBearing(h.bearing);
            const X = new o.P(o.ag(a.centerPoint.x + h.offsetAsPoint.x, 0, a.width), o.ag(a.centerPoint.y + h.offsetAsPoint.y, 0, a.height));
            j.setLocationAtPoint(L, X);
            const G = j.center;
            hi(a, G);
            const Q = function(De, He, Ze) {
              const Fe = ai(He), it = ai(Ze), bt = o.aW(Fe, it), dt = Math.acos(bt), Tt = xo(De);
              return dt / (2 * Math.PI) * Tt;
            }(a, y, G), le = w + Ri(y.lat, 0), Ae = F + Ri(G.lat, 0), we = o.ae(Ae - le);
            let Te;
            if (typeof h.minZoom == "number") {
              const De = +h.minZoom + Ri(G.lat, 0), He = Math.min(De, le, Ae) + Ri(0, G.lat), Ze = a.getConstrained(G, He).zoom + Ri(G.lat, 0);
              Te = o.ae(Ze - le);
            }
            const Me = o.bz(y.lng, G.lng), Ve = o.bz(y.lat, G.lat);
            return { easeFunc: (De, He, Ze, Fe) => {
              const it = Ea(y, Me, Ve, Ze);
              P && a.interpolatePadding(C, h.padding, De);
              const bt = De === 1 ? G : it;
              a.setCenter(bt.wrap());
              const dt = le + o.aj(He);
              a.setZoom(De === 1 ? F : dt + Ri(0, bt.lat));
            }, scaleOfZoom: we, targetCenter: G, scaleOfMinZoom: Te, pixelPathLength: Q };
          }
          static solveVectorScale(a, h, g, y, w) {
            const C = y === "x" ? [g[0], g[4], g[8], g[12]] : [g[1], g[5], g[9], g[13]], P = [g[3], g[7], g[11], g[15]], L = a[0] * C[0] + a[1] * C[1] + a[2] * C[2], F = a[0] * P[0] + a[1] * P[1] + a[2] * P[2], j = h[0] * C[0] + h[1] * C[1] + h[2] * C[2], X = h[0] * P[0] + h[1] * P[1] + h[2] * P[2];
            return j + w * F === L + w * X || P[3] * (L - j) + C[3] * (X - F) + L * X == j * F ? null : (j + C[3] - w * X - w * P[3]) / (j - L - w * X + w * F);
          }
          static getLesserNonNegativeNonNull(a, h) {
            return h !== null && h >= 0 && h < a ? h : a;
          }
        }
        class Wl {
          constructor(a) {
            this._globe = a, this._mercatorCameraHelper = new wl(), this._verticalPerspectiveCameraHelper = new ji();
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering;
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
          }
          handlePanInertia(a, h) {
            return this.currentHelper.handlePanInertia(a, h);
          }
          handleMapControlsRollPitchBearingZoom(a, h) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(a, h);
          }
          handleMapControlsPan(a, h, g) {
            this.currentHelper.handleMapControlsPan(a, h, g);
          }
          cameraForBoxAndBearing(a, h, g, y, w) {
            return this.currentHelper.cameraForBoxAndBearing(a, h, g, y, w);
          }
          handleJumpToCenterZoom(a, h) {
            this.currentHelper.handleJumpToCenterZoom(a, h);
          }
          handleEaseTo(a, h) {
            return this.currentHelper.handleEaseTo(a, h);
          }
          handleFlyTo(a, h) {
            return this.currentHelper.handleFlyTo(a, h);
          }
        }
        const Lo = (v, a) => o.y(v, a && a.filter((h) => h.identifier !== "source.canvas")), Ia = o.bD();
        class O extends o.E {
          constructor(a) {
            let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            super(), this._rtlPluginLoaded = () => {
              for (const g in this.sourceCaches) {
                const y = this.sourceCaches[g].getSource().type;
                y !== "vector" && y !== "geojson" || this.sourceCaches[g].reload();
              }
            }, this.map = a, this.dispatcher = new ot(et(), a._getMapId()), this.dispatcher.registerMessageHandler("GG", (g, y) => this.getGlyphs(g, y)), this.dispatcher.registerMessageHandler("GI", (g, y) => this.getImages(g, y)), this.imageManager = new Be(), this.imageManager.setEventedParent(this), this.glyphManager = new je(a._requestManager, h.localIdeographFontFamily), this.lineAtlas = new zt(256, 512), this.crossTileSymbolIndex = new Gl(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new o.bE(), this._loaded = !1, this._availableImages = [], this._globalState = {}, this._resetUpdates(), this.dispatcher.broadcast("SR", o.bF()), nn().on(qr, this._rtlPluginLoaded), this.on("data", (g) => {
              if (g.dataType !== "source" || g.sourceDataType !== "metadata") return;
              const y = this.sourceCaches[g.sourceId];
              if (!y) return;
              const w = y.getSource();
              if (w && w.vectorLayerIds) for (const C in this._layers) {
                const P = this._layers[C];
                P.source === w.id && this._validateLayer(P);
              }
            });
          }
          setGlobalStateProperty(a, h) {
            var g, y, w;
            this._checkLoaded();
            const C = h === null ? (w = (y = (g = this.stylesheet.state) === null || g === void 0 ? void 0 : g[a]) === null || y === void 0 ? void 0 : y.default) !== null && w !== void 0 ? w : null : h;
            if (o.bG(C, this._globalState[a])) return this;
            this._globalState[a] = C;
            const P = this._findGlobalStateAffectedSources([a]);
            for (const L in this.sourceCaches) P.has(L) && (this._reloadSource(L), this._changed = !0);
          }
          getGlobalState() {
            return this._globalState;
          }
          setGlobalState(a) {
            this._checkLoaded();
            const h = [];
            for (const y in a) !o.bG(this._globalState[y], a[y].default) && (h.push(y), this._globalState[y] = a[y].default);
            const g = this._findGlobalStateAffectedSources(h);
            for (const y in this.sourceCaches) g.has(y) && (this._reloadSource(y), this._changed = !0);
          }
          _findGlobalStateAffectedSources(a) {
            if (a.length === 0) return /* @__PURE__ */ new Set();
            const h = /* @__PURE__ */ new Set();
            for (const g in this._layers) {
              const y = this._layers[g], w = y.getLayoutAffectingGlobalStateRefs();
              for (const C of a) w.has(C) && h.add(y.source);
            }
            return h;
          }
          loadURL(a) {
            let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, g = arguments.length > 2 ? arguments[2] : void 0;
            this.fire(new o.l("dataloading", { dataType: "style" })), h.validate = typeof h.validate != "boolean" || h.validate;
            const y = this.map._requestManager.transformRequest(a, "Style");
            this._loadStyleRequest = new AbortController();
            const w = this._loadStyleRequest;
            o.j(y, this._loadStyleRequest).then((C) => {
              this._loadStyleRequest = null, this._load(C.data, h, g);
            }).catch((C) => {
              this._loadStyleRequest = null, C && !w.signal.aborted && this.fire(new o.k(C));
            });
          }
          loadJSON(a) {
            let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, g = arguments.length > 2 ? arguments[2] : void 0;
            this.fire(new o.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), M.frameAsync(this._frameRequest).then(() => {
              this._frameRequest = null, h.validate = h.validate !== !1, this._load(a, h, g);
            }).catch(() => {
            });
          }
          loadEmpty() {
            this.fire(new o.l("dataloading", { dataType: "style" })), this._load(Ia, { validate: !1 });
          }
          _load(a, h, g) {
            var y, w, C;
            const P = h.transformStyle ? h.transformStyle(g, a) : a;
            if (!h.validate || !Lo(this, o.z(P))) {
              this._loaded = !0, this.stylesheet = P;
              for (const L in P.sources) this.addSource(L, P.sources[L], { validate: !1 });
              P.sprite ? this._loadSprite(P.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(P.glyphs), this._createLayers(), this.light = new Mt(this.stylesheet.light), this._setProjectionInternal(((y = this.stylesheet.projection) === null || y === void 0 ? void 0 : y.type) || "mercator"), this.sky = new xt(this.stylesheet.sky), this.map.setTerrain((w = this.stylesheet.terrain) !== null && w !== void 0 ? w : null), this.setGlobalState((C = this.stylesheet.state) !== null && C !== void 0 ? C : null), this.fire(new o.l("data", { dataType: "style" })), this.fire(new o.l("style.load"));
            }
          }
          _createLayers() {
            const a = o.bH(this.stylesheet.layers);
            this.dispatcher.broadcast("SL", a), this._order = a.map((h) => h.id), this._layers = {}, this._serializedLayers = null;
            for (const h of a) {
              const g = o.bI(h);
              g.setEventedParent(this, { layer: { id: h.id } }), this._layers[h.id] = g;
            }
          }
          _loadSprite(a) {
            let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, y;
            this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController(), function(w, C, P, L) {
              return o._(this, void 0, void 0, function* () {
                const F = ie(w), j = P > 1 ? "@2x" : "", X = {}, G = {};
                for (const { id: Q, url: le } of F) {
                  const Ae = C.transformRequest(be(le, j, ".json"), "SpriteJSON");
                  X[Q] = o.j(Ae, L);
                  const we = C.transformRequest(be(le, j, ".png"), "SpriteImage");
                  G[Q] = Z.getImage(we, L);
                }
                return yield Promise.all([...Object.values(X), ...Object.values(G)]), function(Q, le) {
                  return o._(this, void 0, void 0, function* () {
                    const Ae = {};
                    for (const we in Q) {
                      Ae[we] = {};
                      const Te = M.getImageCanvasContext((yield le[we]).data), Me = (yield Q[we]).data;
                      for (const Ve in Me) {
                        const { width: De, height: He, x: Ze, y: Fe, sdf: it, pixelRatio: bt, stretchX: dt, stretchY: Tt, content: wt, textFitWidth: ir, textFitHeight: or } = Me[Ve];
                        Ae[we][Ve] = { data: null, pixelRatio: bt, sdf: it, stretchX: dt, stretchY: Tt, content: wt, textFitWidth: ir, textFitHeight: or, spriteData: { width: De, height: He, x: Ze, y: Fe, context: Te } };
                      }
                    }
                    return Ae;
                  });
                }(X, G);
              });
            }(a, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((w) => {
              if (this._spriteRequest = null, w) for (const C in w) {
                this._spritesImagesIds[C] = [];
                const P = this._spritesImagesIds[C] ? this._spritesImagesIds[C].filter((L) => !(L in w)) : [];
                for (const L of P) this.imageManager.removeImage(L), this._changedImages[L] = !0;
                for (const L in w[C]) {
                  const F = C === "default" ? L : `${C}:${L}`;
                  this._spritesImagesIds[C].push(F), F in this.imageManager.images ? this.imageManager.updateImage(F, w[C][L], !1) : this.imageManager.addImage(F, w[C][L]), h && (this._changedImages[F] = !0);
                }
              }
            }).catch((w) => {
              this._spriteRequest = null, y = w, this.fire(new o.k(y));
            }).finally(() => {
              this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), h && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.l("data", { dataType: "style" })), g && g(y);
            });
          }
          _unloadSprite() {
            for (const a of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(a), this._changedImages[a] = !0;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.l("data", { dataType: "style" }));
          }
          _validateLayer(a) {
            const h = this.sourceCaches[a.source];
            if (!h) return;
            const g = a.sourceLayer;
            if (!g) return;
            const y = h.getSource();
            (y.type === "geojson" || y.vectorLayerIds && y.vectorLayerIds.indexOf(g) === -1) && this.fire(new o.k(new Error(`Source layer "${g}" does not exist on source "${y.id}" as specified by style layer "${a.id}".`)));
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
            for (const a in this.sourceCaches) if (!this.sourceCaches[a].loaded()) return !1;
            return !!this.imageManager.isLoaded();
          }
          _serializeByIds(a) {
            let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
            const g = this._serializedAllLayers();
            if (!a || a.length === 0) return Object.values(h ? o.bJ(g) : g);
            const y = [];
            for (const w of a) if (g[w]) {
              const C = h ? o.bJ(g[w]) : g[w];
              y.push(C);
            }
            return y;
          }
          _serializedAllLayers() {
            let a = this._serializedLayers;
            if (a) return a;
            a = this._serializedLayers = {};
            const h = Object.keys(this._layers);
            for (const g of h) {
              const y = this._layers[g];
              y.type !== "custom" && (a[g] = y.serialize());
            }
            return a;
          }
          hasTransitions() {
            var a, h, g;
            if (!((a = this.light) === null || a === void 0) && a.hasTransition() || !((h = this.sky) === null || h === void 0) && h.hasTransition() || !((g = this.projection) === null || g === void 0) && g.hasTransition()) return !0;
            for (const y in this.sourceCaches) if (this.sourceCaches[y].hasTransition()) return !0;
            for (const y in this._layers) if (this._layers[y].hasTransition()) return !0;
            return !1;
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.");
          }
          update(a) {
            if (!this._loaded) return;
            const h = this._changed;
            if (h) {
              const y = Object.keys(this._updatedLayers), w = Object.keys(this._removedLayers);
              (y.length || w.length) && this._updateWorkerLayers(y, w);
              for (const C in this._updatedSources) {
                const P = this._updatedSources[C];
                if (P === "reload") this._reloadSource(C);
                else {
                  if (P !== "clear") throw new Error(`Invalid action ${P}`);
                  this._clearSource(C);
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const C in this._updatedPaintProps) this._layers[C].updateTransitions(a);
              this.light.updateTransitions(a), this.sky.updateTransitions(a), this._resetUpdates();
            }
            const g = {};
            for (const y in this.sourceCaches) {
              const w = this.sourceCaches[y];
              g[y] = w.used, w.used = !1;
            }
            for (const y of this._order) {
              const w = this._layers[y];
              w.recalculate(a, this._availableImages), !w.isHidden(a.zoom) && w.source && (this.sourceCaches[w.source].used = !0);
            }
            for (const y in g) {
              const w = this.sourceCaches[y];
              !!g[y] != !!w.used && w.fire(new o.l("data", { sourceDataType: "visibility", dataType: "source", sourceId: y }));
            }
            this.light.recalculate(a), this.sky.recalculate(a), this.projection.recalculate(a), this.z = a.zoom, h && this.fire(new o.l("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const a = Object.keys(this._changedImages);
            if (a.length) {
              for (const h in this.sourceCaches) this.sourceCaches[h].reloadTilesForDependencies(["icons", "patterns"], a);
              this._changedImages = {};
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const a in this.sourceCaches) this.sourceCaches[a].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = !1;
            }
          }
          _updateWorkerLayers(a, h) {
            this.dispatcher.broadcast("UL", { layers: this._serializeByIds(a, !1), removedIds: h });
          }
          _resetUpdates() {
            this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1;
          }
          setState(a) {
            let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var g;
            this._checkLoaded();
            const y = this.serialize();
            if (a = h.transformStyle ? h.transformStyle(y, a) : a, ((g = h.validate) === null || g === void 0 || g) && Lo(this, o.z(a))) return !1;
            (a = o.bJ(a)).layers = o.bH(a.layers);
            const w = o.bK(y, a), C = this._getOperationsToPerform(w);
            if (C.unimplemented.length > 0) throw new Error(`Unimplemented: ${C.unimplemented.join(", ")}.`);
            if (C.operations.length === 0) return !1;
            for (const P of C.operations) P();
            return this.stylesheet = a, this._serializedLayers = null, !0;
          }
          _getOperationsToPerform(a) {
            const h = [], g = [];
            for (const y of a) switch (y.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                h.push(() => this.addLayer.apply(this, y.args));
                break;
              case "removeLayer":
                h.push(() => this.removeLayer.apply(this, y.args));
                break;
              case "setPaintProperty":
                h.push(() => this.setPaintProperty.apply(this, y.args));
                break;
              case "setLayoutProperty":
                h.push(() => this.setLayoutProperty.apply(this, y.args));
                break;
              case "setFilter":
                h.push(() => this.setFilter.apply(this, y.args));
                break;
              case "addSource":
                h.push(() => this.addSource.apply(this, y.args));
                break;
              case "removeSource":
                h.push(() => this.removeSource.apply(this, y.args));
                break;
              case "setLayerZoomRange":
                h.push(() => this.setLayerZoomRange.apply(this, y.args));
                break;
              case "setLight":
                h.push(() => this.setLight.apply(this, y.args));
                break;
              case "setGeoJSONSourceData":
                h.push(() => this.setGeoJSONSourceData.apply(this, y.args));
                break;
              case "setGlyphs":
                h.push(() => this.setGlyphs.apply(this, y.args));
                break;
              case "setSprite":
                h.push(() => this.setSprite.apply(this, y.args));
                break;
              case "setTerrain":
                h.push(() => this.map.setTerrain.apply(this, y.args));
                break;
              case "setSky":
                h.push(() => this.setSky.apply(this, y.args));
                break;
              case "setProjection":
                this.setProjection.apply(this, y.args);
                break;
              case "setGlobalState":
                h.push(() => this.setGlobalState.apply(this, y.args));
                break;
              case "setTransition":
                h.push(() => {
                });
                break;
              default:
                g.push(y.command);
            }
            return { operations: h, unimplemented: g };
          }
          addImage(a, h) {
            if (this.getImage(a)) return this.fire(new o.k(new Error(`An image named "${a}" already exists.`)));
            this.imageManager.addImage(a, h), this._afterImageUpdated(a);
          }
          updateImage(a, h) {
            this.imageManager.updateImage(a, h);
          }
          getImage(a) {
            return this.imageManager.getImage(a);
          }
          removeImage(a) {
            if (!this.getImage(a)) return this.fire(new o.k(new Error(`An image named "${a}" does not exist.`)));
            this.imageManager.removeImage(a), this._afterImageUpdated(a);
          }
          _afterImageUpdated(a) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[a] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.l("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages();
          }
          addSource(a, h) {
            let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            if (this._checkLoaded(), this.sourceCaches[a] !== void 0) throw new Error(`Source "${a}" already exists.`);
            if (!h.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(h).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(h.type) >= 0 && this._validate(o.z.source, `sources.${a}`, h, null, g)) return;
            this.map && this.map._collectResourceTiming && (h.collectResourceTiming = !0);
            const y = this.sourceCaches[a] = new ft(a, h, this.dispatcher);
            y.style = this, y.setEventedParent(this, () => ({ isSourceLoaded: y.loaded(), source: y.serialize(), sourceId: a })), y.onAdd(this.map), this._changed = !0;
          }
          removeSource(a) {
            if (this._checkLoaded(), this.sourceCaches[a] === void 0) throw new Error("There is no source with this ID");
            for (const g in this._layers) if (this._layers[g].source === a) return this.fire(new o.k(new Error(`Source "${a}" cannot be removed while layer "${g}" is using it.`)));
            const h = this.sourceCaches[a];
            delete this.sourceCaches[a], delete this._updatedSources[a], h.fire(new o.l("data", { sourceDataType: "metadata", dataType: "source", sourceId: a })), h.setEventedParent(null), h.onRemove(this.map), this._changed = !0;
          }
          setGeoJSONSourceData(a, h) {
            if (this._checkLoaded(), this.sourceCaches[a] === void 0) throw new Error(`There is no source with this ID=${a}`);
            const g = this.sourceCaches[a].getSource();
            if (g.type !== "geojson") throw new Error(`geojsonSource.type is ${g.type}, which is !== 'geojson`);
            g.setData(h), this._changed = !0;
          }
          getSource(a) {
            return this.sourceCaches[a] && this.sourceCaches[a].getSource();
          }
          addLayer(a, h) {
            let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            this._checkLoaded();
            const y = a.id;
            if (this.getLayer(y)) return void this.fire(new o.k(new Error(`Layer "${y}" already exists on this map.`)));
            let w;
            if (a.type === "custom") {
              if (Lo(this, o.bL(a))) return;
              w = o.bI(a);
            } else {
              if ("source" in a && typeof a.source == "object" && (this.addSource(y, a.source), a = o.bJ(a), a = o.e(a, { source: y })), this._validate(o.z.layer, `layers.${y}`, a, { arrayIndex: -1 }, g)) return;
              w = o.bI(a), this._validateLayer(w), w.setEventedParent(this, { layer: { id: y } });
            }
            const C = h ? this._order.indexOf(h) : this._order.length;
            if (h && C === -1) this.fire(new o.k(new Error(`Cannot add layer "${y}" before non-existing layer "${h}".`)));
            else {
              if (this._order.splice(C, 0, y), this._layerOrderChanged = !0, this._layers[y] = w, this._removedLayers[y] && w.source && w.type !== "custom") {
                const P = this._removedLayers[y];
                delete this._removedLayers[y], P.type !== w.type ? this._updatedSources[w.source] = "clear" : (this._updatedSources[w.source] = "reload", this.sourceCaches[w.source].pause());
              }
              this._updateLayer(w), w.onAdd && w.onAdd(this.map);
            }
          }
          moveLayer(a, h) {
            if (this._checkLoaded(), this._changed = !0, !this._layers[a]) return void this.fire(new o.k(new Error(`The layer '${a}' does not exist in the map's style and cannot be moved.`)));
            if (a === h) return;
            const g = this._order.indexOf(a);
            this._order.splice(g, 1);
            const y = h ? this._order.indexOf(h) : this._order.length;
            h && y === -1 ? this.fire(new o.k(new Error(`Cannot move layer "${a}" before non-existing layer "${h}".`))) : (this._order.splice(y, 0, a), this._layerOrderChanged = !0);
          }
          removeLayer(a) {
            this._checkLoaded();
            const h = this._layers[a];
            if (!h) return void this.fire(new o.k(new Error(`Cannot remove non-existing layer "${a}".`)));
            h.setEventedParent(null);
            const g = this._order.indexOf(a);
            this._order.splice(g, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[a] = h, delete this._layers[a], this._serializedLayers && delete this._serializedLayers[a], delete this._updatedLayers[a], delete this._updatedPaintProps[a], h.onRemove && h.onRemove(this.map);
          }
          getLayer(a) {
            return this._layers[a];
          }
          getLayersOrder() {
            return [...this._order];
          }
          hasLayer(a) {
            return a in this._layers;
          }
          setLayerZoomRange(a, h, g) {
            this._checkLoaded();
            const y = this.getLayer(a);
            y ? y.minzoom === h && y.maxzoom === g || (h != null && (y.minzoom = h), g != null && (y.maxzoom = g), this._updateLayer(y)) : this.fire(new o.k(new Error(`Cannot set the zoom range of non-existing layer "${a}".`)));
          }
          setFilter(a, h) {
            let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            this._checkLoaded();
            const y = this.getLayer(a);
            if (y) {
              if (!o.bG(y.filter, h)) return h == null ? (y.setFilter(void 0), void this._updateLayer(y)) : void (this._validate(o.z.filter, `layers.${y.id}.filter`, h, null, g) || (y.setFilter(o.bJ(h)), this._updateLayer(y)));
            } else this.fire(new o.k(new Error(`Cannot filter non-existing layer "${a}".`)));
          }
          getFilter(a) {
            return o.bJ(this.getLayer(a).filter);
          }
          setLayoutProperty(a, h, g) {
            let y = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            this._checkLoaded();
            const w = this.getLayer(a);
            w ? o.bG(w.getLayoutProperty(h), g) || (w.setLayoutProperty(h, g, y), this._updateLayer(w)) : this.fire(new o.k(new Error(`Cannot style non-existing layer "${a}".`)));
          }
          getLayoutProperty(a, h) {
            const g = this.getLayer(a);
            if (g) return g.getLayoutProperty(h);
            this.fire(new o.k(new Error(`Cannot get style of non-existing layer "${a}".`)));
          }
          setPaintProperty(a, h, g) {
            let y = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            this._checkLoaded();
            const w = this.getLayer(a);
            w ? o.bG(w.getPaintProperty(h), g) || (w.setPaintProperty(h, g, y) && this._updateLayer(w), this._changed = !0, this._updatedPaintProps[a] = !0, this._serializedLayers = null) : this.fire(new o.k(new Error(`Cannot style non-existing layer "${a}".`)));
          }
          getPaintProperty(a, h) {
            return this.getLayer(a).getPaintProperty(h);
          }
          setFeatureState(a, h) {
            this._checkLoaded();
            const g = a.source, y = a.sourceLayer, w = this.sourceCaches[g];
            if (w === void 0) return void this.fire(new o.k(new Error(`The source '${g}' does not exist in the map's style.`)));
            const C = w.getSource().type;
            C === "geojson" && y ? this.fire(new o.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : C !== "vector" || y ? (a.id === void 0 && this.fire(new o.k(new Error("The feature id parameter must be provided."))), w.setFeatureState(y, a.id, h)) : this.fire(new o.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          removeFeatureState(a, h) {
            this._checkLoaded();
            const g = a.source, y = this.sourceCaches[g];
            if (y === void 0) return void this.fire(new o.k(new Error(`The source '${g}' does not exist in the map's style.`)));
            const w = y.getSource().type, C = w === "vector" ? a.sourceLayer : void 0;
            w !== "vector" || C ? h && typeof a.id != "string" && typeof a.id != "number" ? this.fire(new o.k(new Error("A feature id is required to remove its specific state property."))) : y.removeFeatureState(C, a.id, h) : this.fire(new o.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          getFeatureState(a) {
            this._checkLoaded();
            const h = a.source, g = a.sourceLayer, y = this.sourceCaches[h];
            if (y !== void 0) return y.getSource().type !== "vector" || g ? (a.id === void 0 && this.fire(new o.k(new Error("The feature id parameter must be provided."))), y.getFeatureState(g, a.id)) : void this.fire(new o.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new o.k(new Error(`The source '${h}' does not exist in the map's style.`)));
          }
          getTransition() {
            return o.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            if (!this._loaded) return;
            const a = o.bM(this.sourceCaches, (w) => w.serialize()), h = this._serializeByIds(this._order, !0), g = this.map.getTerrain() || void 0, y = this.stylesheet;
            return o.bN({ version: y.version, name: y.name, metadata: y.metadata, light: y.light, sky: y.sky, center: y.center, zoom: y.zoom, bearing: y.bearing, pitch: y.pitch, sprite: y.sprite, glyphs: y.glyphs, transition: y.transition, projection: y.projection, sources: a, layers: h, terrain: g }, (w) => w !== void 0);
          }
          _updateLayer(a) {
            this._updatedLayers[a.id] = !0, a.source && !this._updatedSources[a.source] && this.sourceCaches[a.source].getSource().type !== "raster" && (this._updatedSources[a.source] = "reload", this.sourceCaches[a.source].pause()), this._serializedLayers = null, this._changed = !0;
          }
          _flattenAndSortRenderedFeatures(a) {
            const h = (C) => this._layers[C].type === "fill-extrusion", g = {}, y = [];
            for (let C = this._order.length - 1; C >= 0; C--) {
              const P = this._order[C];
              if (h(P)) {
                g[P] = C;
                for (const L of a) {
                  const F = L[P];
                  if (F) for (const j of F) y.push(j);
                }
              }
            }
            y.sort((C, P) => P.intersectionZ - C.intersectionZ);
            const w = [];
            for (let C = this._order.length - 1; C >= 0; C--) {
              const P = this._order[C];
              if (h(P)) for (let L = y.length - 1; L >= 0; L--) {
                const F = y[L].feature;
                if (g[F.layer.id] < C) break;
                w.push(F), y.pop();
              }
              else for (const L of a) {
                const F = L[P];
                if (F) for (const j of F) w.push(j.feature);
              }
            }
            return w;
          }
          queryRenderedFeatures(a, h, g) {
            h && h.filter && this._validate(o.z.filter, "queryRenderedFeatures.filter", h.filter, null, h);
            const y = {};
            if (h && h.layers) {
              if (!(Array.isArray(h.layers) || h.layers instanceof Set)) return this.fire(new o.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const F of h.layers) {
                const j = this._layers[F];
                if (!j) return this.fire(new o.k(new Error(`The layer '${F}' does not exist in the map's style and cannot be queried for features.`))), [];
                y[j.source] = !0;
              }
            }
            const w = [];
            h.availableImages = this._availableImages;
            const C = this._serializedAllLayers(), P = h.layers instanceof Set ? h.layers : Array.isArray(h.layers) ? new Set(h.layers) : null, L = Object.assign(Object.assign({}, h), { layers: P });
            for (const F in this.sourceCaches) h.layers && !y[F] || w.push(yt(this.sourceCaches[F], this._layers, C, a, L, g, this.map.terrain ? (j, X, G) => this.map.terrain.getElevation(j, X, G) : void 0));
            return this.placement && w.push(function(F, j, X, G, Q, le, Ae) {
              const we = {}, Te = le.queryRenderedSymbols(G), Me = [];
              for (const Ve of Object.keys(Te).map(Number)) Me.push(Ae[Ve]);
              Me.sort(ar);
              for (const Ve of Me) {
                const De = Ve.featureIndex.lookupSymbolFeatures(Te[Ve.bucketInstanceId], j, Ve.bucketIndex, Ve.sourceLayerIndex, Q.filter, Q.layers, Q.availableImages, F);
                for (const He in De) {
                  const Ze = we[He] = we[He] || [], Fe = De[He];
                  Fe.sort((it, bt) => {
                    const dt = Ve.featureSortOrder;
                    if (dt) {
                      const Tt = dt.indexOf(it.featureIndex);
                      return dt.indexOf(bt.featureIndex) - Tt;
                    }
                    return bt.featureIndex - it.featureIndex;
                  });
                  for (const it of Fe) Ze.push(it);
                }
              }
              return function(Ve, De, He) {
                for (const Ze in Ve) for (const Fe of Ve[Ze]) Kt(Fe, He[De[Ze].source]);
                return Ve;
              }(we, F, X);
            }(this._layers, C, this.sourceCaches, a, L, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(w);
          }
          querySourceFeatures(a, h) {
            h && h.filter && this._validate(o.z.filter, "querySourceFeatures.filter", h.filter, null, h);
            const g = this.sourceCaches[a];
            return g ? function(y, w) {
              const C = y.getRenderableIds().map((F) => y.getTileByID(F)), P = [], L = {};
              for (let F = 0; F < C.length; F++) {
                const j = C[F], X = j.tileID.canonical.key;
                L[X] || (L[X] = !0, j.querySourceFeatures(P, w));
              }
              return P;
            }(g, h) : [];
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(a) {
            let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            this._checkLoaded();
            const g = this.light.getLight();
            let y = !1;
            for (const C in a) if (!o.bG(a[C], g[C])) {
              y = !0;
              break;
            }
            if (!y) return;
            const w = { now: M.now(), transition: o.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(a, h), this.light.updateTransitions(w);
          }
          getProjection() {
            var a;
            return (a = this.stylesheet) === null || a === void 0 ? void 0 : a.projection;
          }
          setProjection(a) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === a.type) return;
              this.projection.destroy(), delete this.projection;
            }
            this.stylesheet.projection = a, this._setProjectionInternal(a.type);
          }
          getSky() {
            var a;
            return (a = this.stylesheet) === null || a === void 0 ? void 0 : a.sky;
          }
          setSky(a) {
            let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            this._checkLoaded();
            const g = this.getSky();
            let y = !1;
            if (!a && !g) return;
            if (a && !g) y = !0;
            else if (!a && g) y = !0;
            else for (const C in a) if (!o.bG(a[C], g[C])) {
              y = !0;
              break;
            }
            if (!y) return;
            const w = { now: M.now(), transition: o.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.stylesheet.sky = a, this.sky.setSky(a, h), this.sky.updateTransitions(w);
          }
          _setProjectionInternal(a) {
            const h = function(g) {
              if (Array.isArray(g)) {
                const y = new ao({ type: g });
                return { projection: y, transform: new ss(), cameraHelper: new Wl(y) };
              }
              switch (g) {
                case "mercator":
                  return { projection: new vl(), transform: new zn(), cameraHelper: new wl() };
                case "globe": {
                  const y = new ao({ type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"] });
                  return { projection: y, transform: new ss(), cameraHelper: new Wl(y) };
                }
                case "vertical-perspective":
                  return { projection: new Eu(), transform: new Tl(), cameraHelper: new ji() };
                default:
                  return o.w(`Unknown projection name: ${g}. Falling back to mercator projection.`), { projection: new vl(), transform: new zn(), cameraHelper: new wl() };
              }
            }(a);
            this.projection = h.projection, this.map.migrateProjection(h.transform, h.cameraHelper);
            for (const g in this.sourceCaches) this.sourceCaches[g].reload();
          }
          _validate(a, h, g, y) {
            let w = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
            return (!w || w.validate !== !1) && Lo(this, a.call(o.z, o.e({ key: h, style: this.serialize(), value: g, styleSpec: o.v }, y)));
          }
          _remove() {
            let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), nn().off(qr, this._rtlPluginLoaded);
            for (const h in this._layers) this._layers[h].setEventedParent(null);
            for (const h in this.sourceCaches) {
              const g = this.sourceCaches[h];
              g.setEventedParent(null), g.onRemove(this.map);
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), a && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(a);
          }
          _clearSource(a) {
            this.sourceCaches[a].clearTiles();
          }
          _reloadSource(a) {
            this.sourceCaches[a].resume(), this.sourceCaches[a].reload();
          }
          _updateSources(a) {
            for (const h in this.sourceCaches) this.sourceCaches[h].update(a, this.map.terrain);
          }
          _generateCollisionBoxes() {
            for (const a in this.sourceCaches) this._reloadSource(a);
          }
          _updatePlacement(a, h, g, y) {
            let w = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1, C = !1, P = !1;
            const L = {};
            for (const F of this._order) {
              const j = this._layers[F];
              if (j.type !== "symbol") continue;
              if (!L[j.source]) {
                const G = this.sourceCaches[j.source];
                L[j.source] = G.getRenderableIds(!0).map((Q) => G.getTileByID(Q)).sort((Q, le) => le.tileID.overscaledZ - Q.tileID.overscaledZ || (Q.tileID.isLessThan(le.tileID) ? -1 : 1));
              }
              const X = this.crossTileSymbolIndex.addLayer(j, L[j.source], a.center.lng);
              C = C || X;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((w = w || this._layerOrderChanged || g === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(M.now(), a.zoom)) && (this.pauseablePlacement = new Dc(a, this.map.terrain, this._order, w, h, g, y, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, L), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(M.now()), P = !0), C && this.pauseablePlacement.placement.setStale()), P || C) for (const F of this._order) {
              const j = this._layers[F];
              j.type === "symbol" && this.placement.updateLayerOpacities(j, L[j.source]);
            }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(M.now());
          }
          _releaseSymbolFadeTiles() {
            for (const a in this.sourceCaches) this.sourceCaches[a].releaseSymbolFadeTiles();
          }
          getImages(a, h) {
            return o._(this, void 0, void 0, function* () {
              const g = yield this.imageManager.getImages(h.icons);
              this._updateTilesForChangedImages();
              const y = this.sourceCaches[h.source];
              return y && y.setDependencies(h.tileID.key, h.type, h.icons), g;
            });
          }
          getGlyphs(a, h) {
            return o._(this, void 0, void 0, function* () {
              const g = yield this.glyphManager.getGlyphs(h.stacks), y = this.sourceCaches[h.source];
              return y && y.setDependencies(h.tileID.key, h.type, [""]), g;
            });
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null;
          }
          setGlyphs(a) {
            let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            this._checkLoaded(), a && this._validate(o.z.glyphs, "glyphs", a, null, h) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = a, this.glyphManager.entries = {}, this.glyphManager.setURL(a));
          }
          addSprite(a, h) {
            let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, y = arguments.length > 3 ? arguments[3] : void 0;
            this._checkLoaded();
            const w = [{ id: a, url: h }], C = [...ie(this.stylesheet.sprite), ...w];
            this._validate(o.z.sprite, "sprite", C, null, g) || (this.stylesheet.sprite = C, this._loadSprite(w, !0, y));
          }
          removeSprite(a) {
            this._checkLoaded();
            const h = ie(this.stylesheet.sprite);
            if (h.find((g) => g.id === a)) {
              if (this._spritesImagesIds[a]) for (const g of this._spritesImagesIds[a]) this.imageManager.removeImage(g), this._changedImages[g] = !0;
              h.splice(h.findIndex((g) => g.id === a), 1), this.stylesheet.sprite = h.length > 0 ? h : void 0, delete this._spritesImagesIds[a], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.l("data", { dataType: "style" }));
            } else this.fire(new o.k(new Error(`Sprite "${a}" doesn't exists on this map.`)));
          }
          getSprite() {
            return ie(this.stylesheet.sprite);
          }
          setSprite(a) {
            let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, g = arguments.length > 2 ? arguments[2] : void 0;
            this._checkLoaded(), a && this._validate(o.z.sprite, "sprite", a, null, h) || (this.stylesheet.sprite = a, a ? this._loadSprite(a, !0, g) : (this._unloadSprite(), g && g(null)));
          }
        }
        var ae = o.aI([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        class Ue {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
          }
          bind(a, h, g, y, w, C, P, L, F) {
            this.context = a;
            let j = this.boundPaintVertexBuffers.length !== y.length;
            for (let X = 0; !j && X < y.length; X++) this.boundPaintVertexBuffers[X] !== y[X] && (j = !0);
            !this.vao || this.boundProgram !== h || this.boundLayoutVertexBuffer !== g || j || this.boundIndexBuffer !== w || this.boundVertexOffset !== C || this.boundDynamicVertexBuffer !== P || this.boundDynamicVertexBuffer2 !== L || this.boundDynamicVertexBuffer3 !== F ? this.freshBind(h, g, y, w, C, P, L, F) : (a.bindVertexArray.set(this.vao), P && P.bind(), w && w.dynamicDraw && w.bind(), L && L.bind(), F && F.bind());
          }
          freshBind(a, h, g, y, w, C, P, L) {
            const F = a.numAttributes, j = this.context, X = j.gl;
            this.vao && this.destroy(), this.vao = j.createVertexArray(), j.bindVertexArray.set(this.vao), this.boundProgram = a, this.boundLayoutVertexBuffer = h, this.boundPaintVertexBuffers = g, this.boundIndexBuffer = y, this.boundVertexOffset = w, this.boundDynamicVertexBuffer = C, this.boundDynamicVertexBuffer2 = P, this.boundDynamicVertexBuffer3 = L, h.enableAttributes(X, a);
            for (const G of g) G.enableAttributes(X, a);
            C && C.enableAttributes(X, a), P && P.enableAttributes(X, a), L && L.enableAttributes(X, a), h.bind(), h.setVertexAttribPointers(X, a, w);
            for (const G of g) G.bind(), G.setVertexAttribPointers(X, a, w);
            C && (C.bind(), C.setVertexAttribPointers(X, a, w)), y && y.bind(), P && (P.bind(), P.setVertexAttribPointers(X, a, w)), L && (L.bind(), L.setVertexAttribPointers(X, a, w)), j.currentNumAttributes = F;
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        const tt = (v, a, h, g, y) => ({ u_texture: 0, u_ele_delta: v, u_fog_matrix: a, u_fog_color: h ? h.properties.get("fog-color") : o.be.white, u_fog_ground_blend: h ? h.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: y ? 0 : h ? h.calculateFogBlendOpacity(g) : 0, u_horizon_color: h ? h.properties.get("horizon-color") : o.be.white, u_horizon_fog_blend: h ? h.properties.get("horizon-fog-blend") : 1, u_is_globe_mode: y ? 1 : 0 }), mt = { mainMatrix: "u_projection_matrix", tileMercatorCoords: "u_projection_tile_mercator_coords", clippingPlane: "u_projection_clipping_plane", projectionTransition: "u_projection_transition", fallbackMatrix: "u_projection_fallback_matrix" };
        function jt(v) {
          const a = [];
          for (let h = 0; h < v.length; h++) {
            if (v[h] === null) continue;
            const g = v[h].split(" ");
            a.push(g.pop());
          }
          return a;
        }
        class Jt {
          constructor(a, h, g, y, w, C, P, L) {
            let F = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : [];
            const j = a.gl;
            this.program = j.createProgram();
            const X = jt(h.staticAttributes), G = g ? g.getBinderAttributes() : [], Q = X.concat(G), le = oo.prelude.staticUniforms ? jt(oo.prelude.staticUniforms) : [], Ae = P.staticUniforms ? jt(P.staticUniforms) : [], we = h.staticUniforms ? jt(h.staticUniforms) : [], Te = g ? g.getBinderUniforms() : [], Me = le.concat(Ae).concat(we).concat(Te), Ve = [];
            for (const dt of Me) Ve.indexOf(dt) < 0 && Ve.push(dt);
            const De = g ? g.defines() : [];
            Di(j) && De.unshift("#version 300 es"), w && De.push("#define OVERDRAW_INSPECTOR;"), C && De.push("#define TERRAIN3D;"), L && De.push(L), F && De.push(...F);
            let He = De.concat(oo.prelude.fragmentSource, P.fragmentSource, h.fragmentSource).join(`
`), Ze = De.concat(oo.prelude.vertexSource, P.vertexSource, h.vertexSource).join(`
`);
            Di(j) || (He = function(dt) {
              return dt.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
            }(He), Ze = function(dt) {
              return dt.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
            }(Ze));
            const Fe = j.createShader(j.FRAGMENT_SHADER);
            if (j.isContextLost()) return void (this.failedToCreate = !0);
            if (j.shaderSource(Fe, He), j.compileShader(Fe), !j.getShaderParameter(Fe, j.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${j.getShaderInfoLog(Fe)}`);
            j.attachShader(this.program, Fe);
            const it = j.createShader(j.VERTEX_SHADER);
            if (j.isContextLost()) return void (this.failedToCreate = !0);
            if (j.shaderSource(it, Ze), j.compileShader(it), !j.getShaderParameter(it, j.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${j.getShaderInfoLog(it)}`);
            j.attachShader(this.program, it), this.attributes = {};
            const bt = {};
            this.numAttributes = Q.length;
            for (let dt = 0; dt < this.numAttributes; dt++) Q[dt] && (j.bindAttribLocation(this.program, dt, Q[dt]), this.attributes[Q[dt]] = dt);
            if (j.linkProgram(this.program), !j.getProgramParameter(this.program, j.LINK_STATUS)) throw new Error(`Program failed to link: ${j.getProgramInfoLog(this.program)}`);
            j.deleteShader(it), j.deleteShader(Fe);
            for (let dt = 0; dt < Ve.length; dt++) {
              const Tt = Ve[dt];
              if (Tt && !bt[Tt]) {
                const wt = j.getUniformLocation(this.program, Tt);
                wt && (bt[Tt] = wt);
              }
            }
            this.fixedUniforms = y(a, bt), this.terrainUniforms = ((dt, Tt) => ({ u_depth: new o.bO(dt, Tt.u_depth), u_terrain: new o.bO(dt, Tt.u_terrain), u_terrain_dim: new o.bf(dt, Tt.u_terrain_dim), u_terrain_matrix: new o.bQ(dt, Tt.u_terrain_matrix), u_terrain_unpack: new o.bR(dt, Tt.u_terrain_unpack), u_terrain_exaggeration: new o.bf(dt, Tt.u_terrain_exaggeration) }))(a, bt), this.projectionUniforms = ((dt, Tt) => ({ u_projection_matrix: new o.bQ(dt, Tt.u_projection_matrix), u_projection_tile_mercator_coords: new o.bR(dt, Tt.u_projection_tile_mercator_coords), u_projection_clipping_plane: new o.bR(dt, Tt.u_projection_clipping_plane), u_projection_transition: new o.bf(dt, Tt.u_projection_transition), u_projection_fallback_matrix: new o.bQ(dt, Tt.u_projection_fallback_matrix) }))(a, bt), this.binderUniforms = g ? g.getUniforms(a, bt) : [];
          }
          draw(a, h, g, y, w, C, P, L, F, j, X, G, Q, le, Ae, we, Te, Me, Ve) {
            const De = a.gl;
            if (this.failedToCreate) return;
            if (a.program.set(this.program), a.setDepthMode(g), a.setStencilMode(y), a.setColorMode(w), a.setCullFace(C), L) {
              a.activeTexture.set(De.TEXTURE2), De.bindTexture(De.TEXTURE_2D, L.depthTexture), a.activeTexture.set(De.TEXTURE3), De.bindTexture(De.TEXTURE_2D, L.texture);
              for (const Ze in this.terrainUniforms) this.terrainUniforms[Ze].set(L[Ze]);
            }
            if (F) for (const Ze in F) this.projectionUniforms[mt[Ze]].set(F[Ze]);
            if (P) for (const Ze in this.fixedUniforms) this.fixedUniforms[Ze].set(P[Ze]);
            we && we.setUniforms(a, this.binderUniforms, le, { zoom: Ae });
            let He = 0;
            switch (h) {
              case De.LINES:
                He = 2;
                break;
              case De.TRIANGLES:
                He = 3;
                break;
              case De.LINE_STRIP:
                He = 1;
            }
            for (const Ze of Q.get()) {
              const Fe = Ze.vaos || (Ze.vaos = {});
              (Fe[j] || (Fe[j] = new Ue())).bind(a, this, X, we ? we.getPaintVertexBuffers() : [], G, Ze.vertexOffset, Te, Me, Ve), De.drawElements(h, Ze.primitiveLength * He, De.UNSIGNED_SHORT, Ze.primitiveOffset * He * 2);
            }
          }
        }
        function wr(v, a, h) {
          const g = 1 / o.aB(h, 1, a.transform.tileZoom), y = Math.pow(2, h.tileID.overscaledZ), w = h.tileSize * Math.pow(2, a.transform.tileZoom) / y, C = w * (h.tileID.canonical.x + h.tileID.wrap * y), P = w * h.tileID.canonical.y;
          return { u_image: 0, u_texsize: h.imageAtlasTexture.size, u_scale: [g, v.fromScale, v.toScale], u_fade: v.t, u_pixel_coord_upper: [C >> 16, P >> 16], u_pixel_coord_lower: [65535 & C, 65535 & P] };
        }
        const Fr = (v, a, h, g) => {
          const y = v.style.light, w = y.properties.get("position"), C = [w.x, w.y, w.z], P = o.bU();
          y.properties.get("anchor") === "viewport" && o.bV(P, v.transform.bearingInRadians), o.bW(C, C, P);
          const L = v.transform.transformLightDirection(C), F = y.properties.get("color");
          return { u_lightpos: C, u_lightpos_globe: L, u_lightintensity: y.properties.get("intensity"), u_lightcolor: [F.r, F.g, F.b], u_vertical_gradient: +a, u_opacity: h, u_fill_translate: g };
        }, sn = (v, a, h, g, y, w, C) => o.e(Fr(v, a, h, g), wr(w, v, C), { u_height_factor: -Math.pow(2, y.overscaledZ) / C.tileSize / 8 }), Qr = (v, a, h, g) => o.e(wr(a, v, h), { u_fill_translate: g }), ln = (v, a) => ({ u_world: v, u_fill_translate: a }), vi = (v, a, h, g, y) => o.e(Qr(v, a, h, y), { u_world: g }), xi = (v, a, h, g, y) => {
          const w = v.transform;
          let C, P, L = 0;
          if (h.paint.get("circle-pitch-alignment") === "map") {
            const F = o.aB(a, 1, w.zoom);
            C = !0, P = [F, F], L = F / (o.$ * Math.pow(2, a.tileID.overscaledZ)) * 2 * Math.PI * y;
          } else C = !1, P = w.pixelsToGLUnits;
          return { u_camera_to_center_distance: w.cameraToCenterDistance, u_scale_with_map: +(h.paint.get("circle-pitch-scale") === "map"), u_pitch_with_map: +C, u_device_pixel_ratio: v.pixelRatio, u_extrude_scale: P, u_globe_extrude_scale: L, u_translate: g };
        }, fi = (v) => ({ u_pixel_extrude_scale: [1 / v.width, 1 / v.height] }), Vi = (v) => ({ u_viewport_size: [v.width, v.height] }), Xi = function(v) {
          let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return { u_color: v, u_overlay: 0, u_overlay_scale: a };
        }, Gs = (v, a, h, g) => {
          const y = o.aB(v, 1, a) / (o.$ * Math.pow(2, v.tileID.overscaledZ)) * 2 * Math.PI * g;
          return { u_extrude_scale: o.aB(v, 1, a), u_intensity: h, u_globe_extrude_scale: y };
        }, Ao = (v, a, h, g) => {
          const y = o.L();
          o.bX(y, 0, v.width, v.height, 0, 0, 1);
          const w = v.context.gl;
          return { u_matrix: y, u_world: [w.drawingBufferWidth, w.drawingBufferHeight], u_image: h, u_color_ramp: g, u_opacity: a.paint.get("heatmap-opacity") };
        }, Hs = (v, a, h) => {
          const g = h.paint.get("hillshade-accent-color");
          let y;
          switch (h.paint.get("hillshade-method")) {
            case "basic":
              y = 4;
              break;
            case "combined":
              y = 1;
              break;
            case "igor":
              y = 2;
              break;
            case "multidirectional":
              y = 3;
              break;
            default:
              y = 0;
          }
          const w = h.getIlluminationProperties();
          for (let C = 0; C < w.directionRadians.length; C++) h.paint.get("hillshade-illumination-anchor") === "viewport" && (w.directionRadians[C] += v.transform.bearingInRadians);
          return { u_image: 0, u_latrange: jc(0, a.tileID), u_exaggeration: h.paint.get("hillshade-exaggeration"), u_altitudes: w.altitudeRadians, u_azimuths: w.directionRadians, u_accent: g, u_method: y, u_highlights: w.highlightColor, u_shadows: w.shadowColor };
        }, oh = (v, a) => {
          const h = a.stride, g = o.L();
          return o.bX(g, 0, o.$, -8192, 0, 0, 1), o.M(g, g, [0, -8192, 0]), { u_matrix: g, u_image: 1, u_dimension: [h, h], u_zoom: v.overscaledZ, u_unpack: a.getUnpackVector() };
        };
        function jc(v, a) {
          const h = Math.pow(2, a.canonical.z), g = a.canonical.y;
          return [new o.a0(0, g / h).toLngLat().lat, new o.a0(0, (g + 1) / h).toLngLat().lat];
        }
        const Pu = (v, a) => ({ u_image: 0, u_unpack: a.getUnpackVector(), u_dimension: [a.stride, a.stride], u_elevation_stops: 1, u_color_stops: 4, u_opacity: v.paint.get("color-relief-opacity") }), Ka = (v, a, h, g) => {
          const y = v.transform;
          return { u_translation: Sl(v, a, h), u_ratio: g / o.aB(a, 1, y.zoom), u_device_pixel_ratio: v.pixelRatio, u_units_to_pixels: [1 / y.pixelsToGLUnits[0], 1 / y.pixelsToGLUnits[1]] };
        }, Xl = (v, a, h, g, y) => o.e(Ka(v, a, h, g), { u_image: 0, u_image_height: y }), Vc = (v, a, h, g, y) => {
          const w = v.transform, C = Zi(a, w);
          return { u_translation: Sl(v, a, h), u_texsize: a.imageAtlasTexture.size, u_ratio: g / o.aB(a, 1, w.zoom), u_device_pixel_ratio: v.pixelRatio, u_image: 0, u_scale: [C, y.fromScale, y.toScale], u_fade: y.t, u_units_to_pixels: [1 / w.pixelsToGLUnits[0], 1 / w.pixelsToGLUnits[1]] };
        }, Zl = (v, a, h, g, y, w) => {
          const C = v.lineAtlas, P = Zi(a, v.transform), L = h.layout.get("line-cap") === "round", F = C.getDash(y.from, L), j = C.getDash(y.to, L), X = F.width * w.fromScale, G = j.width * w.toScale;
          return o.e(Ka(v, a, h, g), { u_patternscale_a: [P / X, -F.height / 2], u_patternscale_b: [P / G, -j.height / 2], u_sdfgamma: C.width / (256 * Math.min(X, G) * v.pixelRatio) / 2, u_image: 0, u_tex_y_a: F.y, u_tex_y_b: j.y, u_mix: w.t });
        };
        function Zi(v, a) {
          return 1 / o.aB(v, 1, a.tileZoom);
        }
        function Sl(v, a, h) {
          return o.aC(v.transform, a, h.paint.get("line-translate"), h.paint.get("line-translate-anchor"));
        }
        const Oo = (v, a, h, g, y) => {
          return { u_tl_parent: v, u_scale_parent: a, u_buffer_scale: 1, u_fade_t: h.mix, u_opacity: h.opacity * g.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: g.paint.get("raster-brightness-min"), u_brightness_high: g.paint.get("raster-brightness-max"), u_saturation_factor: (C = g.paint.get("raster-saturation"), C > 0 ? 1 - 1 / (1.001 - C) : -C), u_contrast_factor: (w = g.paint.get("raster-contrast"), w > 0 ? 1 / (1 - w) : 1 + w), u_spin_weights: Yl(g.paint.get("raster-hue-rotate")), u_coords_top: [y[0].x, y[0].y, y[1].x, y[1].y], u_coords_bottom: [y[3].x, y[3].y, y[2].x, y[2].y] };
          var w, C;
        };
        function Yl(v) {
          v *= Math.PI / 180;
          const a = Math.sin(v), h = Math.cos(v);
          return [(2 * h + 1) / 3, (-Math.sqrt(3) * a - h + 1) / 3, (Math.sqrt(3) * a - h + 1) / 3];
        }
        const Kl = (v, a, h, g, y, w, C, P, L, F, j, X, G) => {
          const Q = C.transform;
          return { u_is_size_zoom_constant: +(v === "constant" || v === "source"), u_is_size_feature_constant: +(v === "constant" || v === "camera"), u_size_t: a ? a.uSizeT : 0, u_size: a ? a.uSize : 0, u_camera_to_center_distance: Q.cameraToCenterDistance, u_pitch: Q.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +h, u_aspect_ratio: Q.width / Q.height, u_fade_change: C.options.fadeDuration ? C.symbolFadeChange : 1, u_label_plane_matrix: P, u_coord_matrix: L, u_is_text: +j, u_pitch_with_map: +g, u_is_along_line: y, u_is_variable_anchor: w, u_texsize: X, u_texture: 0, u_translation: F, u_pitched_scale: G };
        }, Yi = (v, a, h, g, y, w, C, P, L, F, j, X, G, Q) => {
          const le = C.transform;
          return o.e(Kl(v, a, h, g, y, w, C, P, L, F, j, X, Q), { u_gamma_scale: g ? Math.cos(le.pitch * Math.PI / 180) * le.cameraToCenterDistance : 1, u_device_pixel_ratio: C.pixelRatio, u_is_halo: 1 });
        }, Jh = (v, a, h, g, y, w, C, P, L, F, j, X, G) => o.e(Yi(v, a, h, g, y, w, C, P, L, F, !0, j, 0, G), { u_texsize_icon: X, u_texture_icon: 1 }), El = (v, a) => ({ u_opacity: v, u_color: a }), ah = (v, a, h, g, y) => o.e(function(w, C, P, L) {
          const F = P.imageManager.getPattern(w.from.toString()), j = P.imageManager.getPattern(w.to.toString()), { width: X, height: G } = P.imageManager.getPixelSize(), Q = Math.pow(2, L.tileID.overscaledZ), le = L.tileSize * Math.pow(2, P.transform.tileZoom) / Q, Ae = le * (L.tileID.canonical.x + L.tileID.wrap * Q), we = le * L.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: F.tl, u_pattern_br_a: F.br, u_pattern_tl_b: j.tl, u_pattern_br_b: j.br, u_texsize: [X, G], u_mix: C.t, u_pattern_size_a: F.displaySize, u_pattern_size_b: j.displaySize, u_scale_a: C.fromScale, u_scale_b: C.toScale, u_tile_units_to_pixels: 1 / o.aB(L, 1, P.transform.tileZoom), u_pixel_coord_upper: [Ae >> 16, we >> 16], u_pixel_coord_lower: [65535 & Ae, 65535 & we] };
        }(h, y, a, g), { u_opacity: v }), To = (v, a) => {
        }, Jl = { fillExtrusion: (v, a) => ({ u_lightpos: new o.bS(v, a.u_lightpos), u_lightpos_globe: new o.bS(v, a.u_lightpos_globe), u_lightintensity: new o.bf(v, a.u_lightintensity), u_lightcolor: new o.bS(v, a.u_lightcolor), u_vertical_gradient: new o.bf(v, a.u_vertical_gradient), u_opacity: new o.bf(v, a.u_opacity), u_fill_translate: new o.bT(v, a.u_fill_translate) }), fillExtrusionPattern: (v, a) => ({ u_lightpos: new o.bS(v, a.u_lightpos), u_lightpos_globe: new o.bS(v, a.u_lightpos_globe), u_lightintensity: new o.bf(v, a.u_lightintensity), u_lightcolor: new o.bS(v, a.u_lightcolor), u_vertical_gradient: new o.bf(v, a.u_vertical_gradient), u_height_factor: new o.bf(v, a.u_height_factor), u_opacity: new o.bf(v, a.u_opacity), u_fill_translate: new o.bT(v, a.u_fill_translate), u_image: new o.bO(v, a.u_image), u_texsize: new o.bT(v, a.u_texsize), u_pixel_coord_upper: new o.bT(v, a.u_pixel_coord_upper), u_pixel_coord_lower: new o.bT(v, a.u_pixel_coord_lower), u_scale: new o.bS(v, a.u_scale), u_fade: new o.bf(v, a.u_fade) }), fill: (v, a) => ({ u_fill_translate: new o.bT(v, a.u_fill_translate) }), fillPattern: (v, a) => ({ u_image: new o.bO(v, a.u_image), u_texsize: new o.bT(v, a.u_texsize), u_pixel_coord_upper: new o.bT(v, a.u_pixel_coord_upper), u_pixel_coord_lower: new o.bT(v, a.u_pixel_coord_lower), u_scale: new o.bS(v, a.u_scale), u_fade: new o.bf(v, a.u_fade), u_fill_translate: new o.bT(v, a.u_fill_translate) }), fillOutline: (v, a) => ({ u_world: new o.bT(v, a.u_world), u_fill_translate: new o.bT(v, a.u_fill_translate) }), fillOutlinePattern: (v, a) => ({ u_world: new o.bT(v, a.u_world), u_image: new o.bO(v, a.u_image), u_texsize: new o.bT(v, a.u_texsize), u_pixel_coord_upper: new o.bT(v, a.u_pixel_coord_upper), u_pixel_coord_lower: new o.bT(v, a.u_pixel_coord_lower), u_scale: new o.bS(v, a.u_scale), u_fade: new o.bf(v, a.u_fade), u_fill_translate: new o.bT(v, a.u_fill_translate) }), circle: (v, a) => ({ u_camera_to_center_distance: new o.bf(v, a.u_camera_to_center_distance), u_scale_with_map: new o.bO(v, a.u_scale_with_map), u_pitch_with_map: new o.bO(v, a.u_pitch_with_map), u_extrude_scale: new o.bT(v, a.u_extrude_scale), u_device_pixel_ratio: new o.bf(v, a.u_device_pixel_ratio), u_globe_extrude_scale: new o.bf(v, a.u_globe_extrude_scale), u_translate: new o.bT(v, a.u_translate) }), collisionBox: (v, a) => ({ u_pixel_extrude_scale: new o.bT(v, a.u_pixel_extrude_scale) }), collisionCircle: (v, a) => ({ u_viewport_size: new o.bT(v, a.u_viewport_size) }), debug: (v, a) => ({ u_color: new o.bP(v, a.u_color), u_overlay: new o.bO(v, a.u_overlay), u_overlay_scale: new o.bf(v, a.u_overlay_scale) }), depth: To, clippingMask: To, heatmap: (v, a) => ({ u_extrude_scale: new o.bf(v, a.u_extrude_scale), u_intensity: new o.bf(v, a.u_intensity), u_globe_extrude_scale: new o.bf(v, a.u_globe_extrude_scale) }), heatmapTexture: (v, a) => ({ u_matrix: new o.bQ(v, a.u_matrix), u_world: new o.bT(v, a.u_world), u_image: new o.bO(v, a.u_image), u_color_ramp: new o.bO(v, a.u_color_ramp), u_opacity: new o.bf(v, a.u_opacity) }), hillshade: (v, a) => ({ u_image: new o.bO(v, a.u_image), u_latrange: new o.bT(v, a.u_latrange), u_exaggeration: new o.bf(v, a.u_exaggeration), u_altitudes: new o.bZ(v, a.u_altitudes), u_azimuths: new o.bZ(v, a.u_azimuths), u_accent: new o.bP(v, a.u_accent), u_method: new o.bO(v, a.u_method), u_shadows: new o.bY(v, a.u_shadows), u_highlights: new o.bY(v, a.u_highlights) }), hillshadePrepare: (v, a) => ({ u_matrix: new o.bQ(v, a.u_matrix), u_image: new o.bO(v, a.u_image), u_dimension: new o.bT(v, a.u_dimension), u_zoom: new o.bf(v, a.u_zoom), u_unpack: new o.bR(v, a.u_unpack) }), colorRelief: (v, a) => ({ u_image: new o.bO(v, a.u_image), u_unpack: new o.bR(v, a.u_unpack), u_dimension: new o.bT(v, a.u_dimension), u_elevation_stops: new o.bO(v, a.u_elevation_stops), u_color_stops: new o.bO(v, a.u_color_stops), u_opacity: new o.bf(v, a.u_opacity) }), line: (v, a) => ({ u_translation: new o.bT(v, a.u_translation), u_ratio: new o.bf(v, a.u_ratio), u_device_pixel_ratio: new o.bf(v, a.u_device_pixel_ratio), u_units_to_pixels: new o.bT(v, a.u_units_to_pixels) }), lineGradient: (v, a) => ({ u_translation: new o.bT(v, a.u_translation), u_ratio: new o.bf(v, a.u_ratio), u_device_pixel_ratio: new o.bf(v, a.u_device_pixel_ratio), u_units_to_pixels: new o.bT(v, a.u_units_to_pixels), u_image: new o.bO(v, a.u_image), u_image_height: new o.bf(v, a.u_image_height) }), linePattern: (v, a) => ({ u_translation: new o.bT(v, a.u_translation), u_texsize: new o.bT(v, a.u_texsize), u_ratio: new o.bf(v, a.u_ratio), u_device_pixel_ratio: new o.bf(v, a.u_device_pixel_ratio), u_image: new o.bO(v, a.u_image), u_units_to_pixels: new o.bT(v, a.u_units_to_pixels), u_scale: new o.bS(v, a.u_scale), u_fade: new o.bf(v, a.u_fade) }), lineSDF: (v, a) => ({ u_translation: new o.bT(v, a.u_translation), u_ratio: new o.bf(v, a.u_ratio), u_device_pixel_ratio: new o.bf(v, a.u_device_pixel_ratio), u_units_to_pixels: new o.bT(v, a.u_units_to_pixels), u_patternscale_a: new o.bT(v, a.u_patternscale_a), u_patternscale_b: new o.bT(v, a.u_patternscale_b), u_sdfgamma: new o.bf(v, a.u_sdfgamma), u_image: new o.bO(v, a.u_image), u_tex_y_a: new o.bf(v, a.u_tex_y_a), u_tex_y_b: new o.bf(v, a.u_tex_y_b), u_mix: new o.bf(v, a.u_mix) }), raster: (v, a) => ({ u_tl_parent: new o.bT(v, a.u_tl_parent), u_scale_parent: new o.bf(v, a.u_scale_parent), u_buffer_scale: new o.bf(v, a.u_buffer_scale), u_fade_t: new o.bf(v, a.u_fade_t), u_opacity: new o.bf(v, a.u_opacity), u_image0: new o.bO(v, a.u_image0), u_image1: new o.bO(v, a.u_image1), u_brightness_low: new o.bf(v, a.u_brightness_low), u_brightness_high: new o.bf(v, a.u_brightness_high), u_saturation_factor: new o.bf(v, a.u_saturation_factor), u_contrast_factor: new o.bf(v, a.u_contrast_factor), u_spin_weights: new o.bS(v, a.u_spin_weights), u_coords_top: new o.bR(v, a.u_coords_top), u_coords_bottom: new o.bR(v, a.u_coords_bottom) }), symbolIcon: (v, a) => ({ u_is_size_zoom_constant: new o.bO(v, a.u_is_size_zoom_constant), u_is_size_feature_constant: new o.bO(v, a.u_is_size_feature_constant), u_size_t: new o.bf(v, a.u_size_t), u_size: new o.bf(v, a.u_size), u_camera_to_center_distance: new o.bf(v, a.u_camera_to_center_distance), u_pitch: new o.bf(v, a.u_pitch), u_rotate_symbol: new o.bO(v, a.u_rotate_symbol), u_aspect_ratio: new o.bf(v, a.u_aspect_ratio), u_fade_change: new o.bf(v, a.u_fade_change), u_label_plane_matrix: new o.bQ(v, a.u_label_plane_matrix), u_coord_matrix: new o.bQ(v, a.u_coord_matrix), u_is_text: new o.bO(v, a.u_is_text), u_pitch_with_map: new o.bO(v, a.u_pitch_with_map), u_is_along_line: new o.bO(v, a.u_is_along_line), u_is_variable_anchor: new o.bO(v, a.u_is_variable_anchor), u_texsize: new o.bT(v, a.u_texsize), u_texture: new o.bO(v, a.u_texture), u_translation: new o.bT(v, a.u_translation), u_pitched_scale: new o.bf(v, a.u_pitched_scale) }), symbolSDF: (v, a) => ({ u_is_size_zoom_constant: new o.bO(v, a.u_is_size_zoom_constant), u_is_size_feature_constant: new o.bO(v, a.u_is_size_feature_constant), u_size_t: new o.bf(v, a.u_size_t), u_size: new o.bf(v, a.u_size), u_camera_to_center_distance: new o.bf(v, a.u_camera_to_center_distance), u_pitch: new o.bf(v, a.u_pitch), u_rotate_symbol: new o.bO(v, a.u_rotate_symbol), u_aspect_ratio: new o.bf(v, a.u_aspect_ratio), u_fade_change: new o.bf(v, a.u_fade_change), u_label_plane_matrix: new o.bQ(v, a.u_label_plane_matrix), u_coord_matrix: new o.bQ(v, a.u_coord_matrix), u_is_text: new o.bO(v, a.u_is_text), u_pitch_with_map: new o.bO(v, a.u_pitch_with_map), u_is_along_line: new o.bO(v, a.u_is_along_line), u_is_variable_anchor: new o.bO(v, a.u_is_variable_anchor), u_texsize: new o.bT(v, a.u_texsize), u_texture: new o.bO(v, a.u_texture), u_gamma_scale: new o.bf(v, a.u_gamma_scale), u_device_pixel_ratio: new o.bf(v, a.u_device_pixel_ratio), u_is_halo: new o.bO(v, a.u_is_halo), u_translation: new o.bT(v, a.u_translation), u_pitched_scale: new o.bf(v, a.u_pitched_scale) }), symbolTextAndIcon: (v, a) => ({ u_is_size_zoom_constant: new o.bO(v, a.u_is_size_zoom_constant), u_is_size_feature_constant: new o.bO(v, a.u_is_size_feature_constant), u_size_t: new o.bf(v, a.u_size_t), u_size: new o.bf(v, a.u_size), u_camera_to_center_distance: new o.bf(v, a.u_camera_to_center_distance), u_pitch: new o.bf(v, a.u_pitch), u_rotate_symbol: new o.bO(v, a.u_rotate_symbol), u_aspect_ratio: new o.bf(v, a.u_aspect_ratio), u_fade_change: new o.bf(v, a.u_fade_change), u_label_plane_matrix: new o.bQ(v, a.u_label_plane_matrix), u_coord_matrix: new o.bQ(v, a.u_coord_matrix), u_is_text: new o.bO(v, a.u_is_text), u_pitch_with_map: new o.bO(v, a.u_pitch_with_map), u_is_along_line: new o.bO(v, a.u_is_along_line), u_is_variable_anchor: new o.bO(v, a.u_is_variable_anchor), u_texsize: new o.bT(v, a.u_texsize), u_texsize_icon: new o.bT(v, a.u_texsize_icon), u_texture: new o.bO(v, a.u_texture), u_texture_icon: new o.bO(v, a.u_texture_icon), u_gamma_scale: new o.bf(v, a.u_gamma_scale), u_device_pixel_ratio: new o.bf(v, a.u_device_pixel_ratio), u_is_halo: new o.bO(v, a.u_is_halo), u_translation: new o.bT(v, a.u_translation), u_pitched_scale: new o.bf(v, a.u_pitched_scale) }), background: (v, a) => ({ u_opacity: new o.bf(v, a.u_opacity), u_color: new o.bP(v, a.u_color) }), backgroundPattern: (v, a) => ({ u_opacity: new o.bf(v, a.u_opacity), u_image: new o.bO(v, a.u_image), u_pattern_tl_a: new o.bT(v, a.u_pattern_tl_a), u_pattern_br_a: new o.bT(v, a.u_pattern_br_a), u_pattern_tl_b: new o.bT(v, a.u_pattern_tl_b), u_pattern_br_b: new o.bT(v, a.u_pattern_br_b), u_texsize: new o.bT(v, a.u_texsize), u_mix: new o.bf(v, a.u_mix), u_pattern_size_a: new o.bT(v, a.u_pattern_size_a), u_pattern_size_b: new o.bT(v, a.u_pattern_size_b), u_scale_a: new o.bf(v, a.u_scale_a), u_scale_b: new o.bf(v, a.u_scale_b), u_pixel_coord_upper: new o.bT(v, a.u_pixel_coord_upper), u_pixel_coord_lower: new o.bT(v, a.u_pixel_coord_lower), u_tile_units_to_pixels: new o.bf(v, a.u_tile_units_to_pixels) }), terrain: (v, a) => ({ u_texture: new o.bO(v, a.u_texture), u_ele_delta: new o.bf(v, a.u_ele_delta), u_fog_matrix: new o.bQ(v, a.u_fog_matrix), u_fog_color: new o.bP(v, a.u_fog_color), u_fog_ground_blend: new o.bf(v, a.u_fog_ground_blend), u_fog_ground_blend_opacity: new o.bf(v, a.u_fog_ground_blend_opacity), u_horizon_color: new o.bP(v, a.u_horizon_color), u_horizon_fog_blend: new o.bf(v, a.u_horizon_fog_blend), u_is_globe_mode: new o.bf(v, a.u_is_globe_mode) }), terrainDepth: (v, a) => ({ u_ele_delta: new o.bf(v, a.u_ele_delta) }), terrainCoords: (v, a) => ({ u_texture: new o.bO(v, a.u_texture), u_terrain_coords_id: new o.bf(v, a.u_terrain_coords_id), u_ele_delta: new o.bf(v, a.u_ele_delta) }), projectionErrorMeasurement: (v, a) => ({ u_input: new o.bf(v, a.u_input), u_output_expected: new o.bf(v, a.u_output_expected) }), atmosphere: (v, a) => ({ u_sun_pos: new o.bS(v, a.u_sun_pos), u_atmosphere_blend: new o.bf(v, a.u_atmosphere_blend), u_globe_position: new o.bS(v, a.u_globe_position), u_globe_radius: new o.bf(v, a.u_globe_radius), u_inv_proj_matrix: new o.bQ(v, a.u_inv_proj_matrix) }), sky: (v, a) => ({ u_sky_color: new o.bP(v, a.u_sky_color), u_horizon_color: new o.bP(v, a.u_horizon_color), u_horizon: new o.bT(v, a.u_horizon), u_horizon_normal: new o.bT(v, a.u_horizon_normal), u_sky_horizon_blend: new o.bf(v, a.u_sky_horizon_blend), u_sky_blend: new o.bf(v, a.u_sky_blend) }) };
        class Ru {
          constructor(a, h, g) {
            this.context = a;
            const y = a.gl;
            this.buffer = y.createBuffer(), this.dynamicDraw = !!g, this.context.unbindVAO(), a.bindElementBuffer.set(this.buffer), y.bufferData(y.ELEMENT_ARRAY_BUFFER, h.arrayBuffer, this.dynamicDraw ? y.DYNAMIC_DRAW : y.STATIC_DRAW), this.dynamicDraw || delete h.arrayBuffer;
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(a) {
            const h = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), h.bufferSubData(h.ELEMENT_ARRAY_BUFFER, 0, a.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const Bu = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class Ma {
          constructor(a, h, g, y) {
            this.length = h.length, this.attributes = g, this.itemSize = h.bytesPerElement, this.dynamicDraw = y, this.context = a;
            const w = a.gl;
            this.buffer = w.createBuffer(), a.bindVertexBuffer.set(this.buffer), w.bufferData(w.ARRAY_BUFFER, h.arrayBuffer, this.dynamicDraw ? w.DYNAMIC_DRAW : w.STATIC_DRAW), this.dynamicDraw || delete h.arrayBuffer;
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(a) {
            if (a.length !== this.length) throw new Error(`Length of new data is ${a.length}, which doesn't match current length of ${this.length}`);
            const h = this.context.gl;
            this.bind(), h.bufferSubData(h.ARRAY_BUFFER, 0, a.arrayBuffer);
          }
          enableAttributes(a, h) {
            for (let g = 0; g < this.attributes.length; g++) {
              const y = h.attributes[this.attributes[g].name];
              y !== void 0 && a.enableVertexAttribArray(y);
            }
          }
          setVertexAttribPointers(a, h, g) {
            for (let y = 0; y < this.attributes.length; y++) {
              const w = this.attributes[y], C = h.attributes[w.name];
              C !== void 0 && a.vertexAttribPointer(C, w.components, a[Bu[w.type]], !1, this.itemSize, w.offset + this.itemSize * (g || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class mn {
          constructor(a) {
            this.gl = a.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
          }
          get() {
            return this.current;
          }
          set(a) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class vs extends mn {
          getDefault() {
            return o.be.transparent;
          }
          set(a) {
            const h = this.current;
            (a.r !== h.r || a.g !== h.g || a.b !== h.b || a.a !== h.a || this.dirty) && (this.gl.clearColor(a.r, a.g, a.b, a.a), this.current = a, this.dirty = !1);
          }
        }
        class wi extends mn {
          getDefault() {
            return 1;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.clearDepth(a), this.current = a, this.dirty = !1);
          }
        }
        class Pa extends mn {
          getDefault() {
            return 0;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.clearStencil(a), this.current = a, this.dirty = !1);
          }
        }
        class la extends mn {
          getDefault() {
            return [!0, !0, !0, !0];
          }
          set(a) {
            const h = this.current;
            (a[0] !== h[0] || a[1] !== h[1] || a[2] !== h[2] || a[3] !== h[3] || this.dirty) && (this.gl.colorMask(a[0], a[1], a[2], a[3]), this.current = a, this.dirty = !1);
          }
        }
        class ca extends mn {
          getDefault() {
            return !0;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.depthMask(a), this.current = a, this.dirty = !1);
          }
        }
        class Ql extends mn {
          getDefault() {
            return 255;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.stencilMask(a), this.current = a, this.dirty = !1);
          }
        }
        class ua extends mn {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(a) {
            const h = this.current;
            (a.func !== h.func || a.ref !== h.ref || a.mask !== h.mask || this.dirty) && (this.gl.stencilFunc(a.func, a.ref, a.mask), this.current = a, this.dirty = !1);
          }
        }
        class Zn extends mn {
          getDefault() {
            const a = this.gl;
            return [a.KEEP, a.KEEP, a.KEEP];
          }
          set(a) {
            const h = this.current;
            (a[0] !== h[0] || a[1] !== h[1] || a[2] !== h[2] || this.dirty) && (this.gl.stencilOp(a[0], a[1], a[2]), this.current = a, this.dirty = !1);
          }
        }
        class ec extends mn {
          getDefault() {
            return !1;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const h = this.gl;
            a ? h.enable(h.STENCIL_TEST) : h.disable(h.STENCIL_TEST), this.current = a, this.dirty = !1;
          }
        }
        class Ws extends mn {
          getDefault() {
            return [0, 1];
          }
          set(a) {
            const h = this.current;
            (a[0] !== h[0] || a[1] !== h[1] || this.dirty) && (this.gl.depthRange(a[0], a[1]), this.current = a, this.dirty = !1);
          }
        }
        class ko extends mn {
          getDefault() {
            return !1;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const h = this.gl;
            a ? h.enable(h.DEPTH_TEST) : h.disable(h.DEPTH_TEST), this.current = a, this.dirty = !1;
          }
        }
        class $c extends mn {
          getDefault() {
            return this.gl.LESS;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.depthFunc(a), this.current = a, this.dirty = !1);
          }
        }
        class lh extends mn {
          getDefault() {
            return !1;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const h = this.gl;
            a ? h.enable(h.BLEND) : h.disable(h.BLEND), this.current = a, this.dirty = !1;
          }
        }
        class qc extends mn {
          getDefault() {
            const a = this.gl;
            return [a.ONE, a.ZERO];
          }
          set(a) {
            const h = this.current;
            (a[0] !== h[0] || a[1] !== h[1] || this.dirty) && (this.gl.blendFunc(a[0], a[1]), this.current = a, this.dirty = !1);
          }
        }
        class tc extends mn {
          getDefault() {
            return o.be.transparent;
          }
          set(a) {
            const h = this.current;
            (a.r !== h.r || a.g !== h.g || a.b !== h.b || a.a !== h.a || this.dirty) && (this.gl.blendColor(a.r, a.g, a.b, a.a), this.current = a, this.dirty = !1);
          }
        }
        class Cl extends mn {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.blendEquation(a), this.current = a, this.dirty = !1);
          }
        }
        class ha extends mn {
          getDefault() {
            return !1;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const h = this.gl;
            a ? h.enable(h.CULL_FACE) : h.disable(h.CULL_FACE), this.current = a, this.dirty = !1;
          }
        }
        class Ra extends mn {
          getDefault() {
            return this.gl.BACK;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.cullFace(a), this.current = a, this.dirty = !1);
          }
        }
        class Ja extends mn {
          getDefault() {
            return this.gl.CCW;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.frontFace(a), this.current = a, this.dirty = !1);
          }
        }
        class Qa extends mn {
          getDefault() {
            return null;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.useProgram(a), this.current = a, this.dirty = !1);
          }
        }
        class lo extends mn {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.activeTexture(a), this.current = a, this.dirty = !1);
          }
        }
        class el extends mn {
          getDefault() {
            const a = this.gl;
            return [0, 0, a.drawingBufferWidth, a.drawingBufferHeight];
          }
          set(a) {
            const h = this.current;
            (a[0] !== h[0] || a[1] !== h[1] || a[2] !== h[2] || a[3] !== h[3] || this.dirty) && (this.gl.viewport(a[0], a[1], a[2], a[3]), this.current = a, this.dirty = !1);
          }
        }
        class xs extends mn {
          getDefault() {
            return null;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const h = this.gl;
            h.bindFramebuffer(h.FRAMEBUFFER, a), this.current = a, this.dirty = !1;
          }
        }
        class Ai extends mn {
          getDefault() {
            return null;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const h = this.gl;
            h.bindRenderbuffer(h.RENDERBUFFER, a), this.current = a, this.dirty = !1;
          }
        }
        class Yn extends mn {
          getDefault() {
            return null;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const h = this.gl;
            h.bindTexture(h.TEXTURE_2D, a), this.current = a, this.dirty = !1;
          }
        }
        class Kn extends mn {
          getDefault() {
            return null;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const h = this.gl;
            h.bindBuffer(h.ARRAY_BUFFER, a), this.current = a, this.dirty = !1;
          }
        }
        class Ti extends mn {
          getDefault() {
            return null;
          }
          set(a) {
            const h = this.gl;
            h.bindBuffer(h.ELEMENT_ARRAY_BUFFER, a), this.current = a, this.dirty = !1;
          }
        }
        class li extends mn {
          getDefault() {
            return null;
          }
          set(a) {
            var h;
            if (a === this.current && !this.dirty) return;
            const g = this.gl;
            Di(g) ? g.bindVertexArray(a) : (h = g.getExtension("OES_vertex_array_object")) === null || h === void 0 || h.bindVertexArrayOES(a), this.current = a, this.dirty = !1;
          }
        }
        class No extends mn {
          getDefault() {
            return 4;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const h = this.gl;
            h.pixelStorei(h.UNPACK_ALIGNMENT, a), this.current = a, this.dirty = !1;
          }
        }
        class Il extends mn {
          getDefault() {
            return !1;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const h = this.gl;
            h.pixelStorei(h.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a), this.current = a, this.dirty = !1;
          }
        }
        class Ba extends mn {
          getDefault() {
            return !1;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const h = this.gl;
            h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL, a), this.current = a, this.dirty = !1;
          }
        }
        class tl extends mn {
          constructor(a, h) {
            super(a), this.context = a, this.parent = h;
          }
          getDefault() {
            return null;
          }
        }
        class ch extends tl {
          setDirty() {
            this.dirty = !0;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const h = this.gl;
            h.framebufferTexture2D(h.FRAMEBUFFER, h.COLOR_ATTACHMENT0, h.TEXTURE_2D, a, 0), this.current = a, this.dirty = !1;
          }
        }
        class rl extends tl {
          set(a) {
            if (a === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const h = this.gl;
            h.framebufferRenderbuffer(h.FRAMEBUFFER, h.DEPTH_ATTACHMENT, h.RENDERBUFFER, a), this.current = a, this.dirty = !1;
          }
        }
        class os extends tl {
          set(a) {
            if (a === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const h = this.gl;
            h.framebufferRenderbuffer(h.FRAMEBUFFER, h.DEPTH_STENCIL_ATTACHMENT, h.RENDERBUFFER, a), this.current = a, this.dirty = !1;
          }
        }
        const co = "Framebuffer is not complete";
        class Gc {
          constructor(a, h, g, y, w) {
            this.context = a, this.width = h, this.height = g;
            const C = a.gl, P = this.framebuffer = C.createFramebuffer();
            if (this.colorAttachment = new ch(a, P), y) this.depthAttachment = w ? new os(a, P) : new rl(a, P);
            else if (w) throw new Error("Stencil cannot be set without depth");
            if (C.checkFramebufferStatus(C.FRAMEBUFFER) !== C.FRAMEBUFFER_COMPLETE) throw new Error(co);
          }
          destroy() {
            const a = this.context.gl, h = this.colorAttachment.get();
            if (h && a.deleteTexture(h), this.depthAttachment) {
              const g = this.depthAttachment.get();
              g && a.deleteRenderbuffer(g);
            }
            a.deleteFramebuffer(this.framebuffer);
          }
        }
        class cn {
          constructor(a) {
            var h, g;
            if (this.gl = a, this.clearColor = new vs(this), this.clearDepth = new wi(this), this.clearStencil = new Pa(this), this.colorMask = new la(this), this.depthMask = new ca(this), this.stencilMask = new Ql(this), this.stencilFunc = new ua(this), this.stencilOp = new Zn(this), this.stencilTest = new ec(this), this.depthRange = new Ws(this), this.depthTest = new ko(this), this.depthFunc = new $c(this), this.blend = new lh(this), this.blendFunc = new qc(this), this.blendColor = new tc(this), this.blendEquation = new Cl(this), this.cullFace = new ha(this), this.cullFaceSide = new Ra(this), this.frontFace = new Ja(this), this.program = new Qa(this), this.activeTexture = new lo(this), this.viewport = new el(this), this.bindFramebuffer = new xs(this), this.bindRenderbuffer = new Ai(this), this.bindTexture = new Yn(this), this.bindVertexBuffer = new Kn(this), this.bindElementBuffer = new Ti(this), this.bindVertexArray = new li(this), this.pixelStoreUnpack = new No(this), this.pixelStoreUnpackPremultiplyAlpha = new Il(this), this.pixelStoreUnpackFlipY = new Ba(this), this.extTextureFilterAnisotropic = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = a.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE), Di(a)) {
              this.HALF_FLOAT = a.HALF_FLOAT;
              const y = a.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = (h = a.RGBA16F) !== null && h !== void 0 ? h : y == null ? void 0 : y.RGBA16F_EXT, this.RGB16F = (g = a.RGB16F) !== null && g !== void 0 ? g : y == null ? void 0 : y.RGB16F_EXT, a.getExtension("EXT_color_buffer_float");
            } else {
              a.getExtension("EXT_color_buffer_half_float"), a.getExtension("OES_texture_half_float_linear");
              const y = a.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = y == null ? void 0 : y.HALF_FLOAT_OES;
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
          }
          createIndexBuffer(a, h) {
            return new Ru(this, a, h);
          }
          createVertexBuffer(a, h, g) {
            return new Ma(this, a, h, g);
          }
          createRenderbuffer(a, h, g) {
            const y = this.gl, w = y.createRenderbuffer();
            return this.bindRenderbuffer.set(w), y.renderbufferStorage(y.RENDERBUFFER, a, h, g), this.bindRenderbuffer.set(null), w;
          }
          createFramebuffer(a, h, g, y) {
            return new Gc(this, a, h, g, y);
          }
          clear(a) {
            let { color: h, depth: g, stencil: y } = a;
            const w = this.gl;
            let C = 0;
            h && (C |= w.COLOR_BUFFER_BIT, this.clearColor.set(h), this.colorMask.set([!0, !0, !0, !0])), g !== void 0 && (C |= w.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(g), this.depthMask.set(!0)), y !== void 0 && (C |= w.STENCIL_BUFFER_BIT, this.clearStencil.set(y), this.stencilMask.set(255)), w.clear(C);
          }
          setCullFace(a) {
            a.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(a.mode), this.frontFace.set(a.frontFace));
          }
          setDepthMode(a) {
            a.func !== this.gl.ALWAYS || a.mask ? (this.depthTest.set(!0), this.depthFunc.set(a.func), this.depthMask.set(a.mask), this.depthRange.set(a.range)) : this.depthTest.set(!1);
          }
          setStencilMode(a) {
            a.test.func !== this.gl.ALWAYS || a.mask ? (this.stencilTest.set(!0), this.stencilMask.set(a.mask), this.stencilOp.set([a.fail, a.depthFail, a.pass]), this.stencilFunc.set({ func: a.test.func, ref: a.ref, mask: a.test.mask })) : this.stencilTest.set(!1);
          }
          setColorMode(a) {
            o.bG(a.blendFunction, pn.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(a.blendFunction), this.blendColor.set(a.blendColor)), this.colorMask.set(a.mask);
          }
          createVertexArray() {
            var a;
            return Di(this.gl) ? this.gl.createVertexArray() : (a = this.gl.getExtension("OES_vertex_array_object")) === null || a === void 0 ? void 0 : a.createVertexArrayOES();
          }
          deleteVertexArray(a) {
            var h;
            return Di(this.gl) ? this.gl.deleteVertexArray(a) : (h = this.gl.getExtension("OES_vertex_array_object")) === null || h === void 0 ? void 0 : h.deleteVertexArrayOES(a);
          }
          unbindVAO() {
            this.bindVertexArray.set(null);
          }
        }
        let Ml;
        function Lu(v, a, h, g, y) {
          const w = v.context, C = v.transform, P = w.gl, L = v.useProgram("collisionBox"), F = [];
          let j = 0, X = 0;
          for (let Te = 0; Te < g.length; Te++) {
            const Me = g[Te], Ve = a.getTile(Me).getBucket(h);
            if (!Ve) continue;
            const De = y ? Ve.textCollisionBox : Ve.iconCollisionBox, He = Ve.collisionCircleArray;
            He.length > 0 && (F.push({ circleArray: He, circleOffset: X, coord: Me }), j += He.length / 4, X = j), De && L.draw(w, P.LINES, Yr.disabled, Or.disabled, v.colorModeForRenderPass(), Wr.disabled, fi(v.transform), v.style.map.terrain && v.style.map.terrain.getTerrainData(Me), C.getProjectionData({ overscaledTileID: Me, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), h.id, De.layoutVertexBuffer, De.indexBuffer, De.segments, null, v.transform.zoom, null, null, De.collisionVertexBuffer);
          }
          if (!y || !F.length) return;
          const G = v.useProgram("collisionCircle"), Q = new o.b_();
          Q.resize(4 * j), Q._trim();
          let le = 0;
          for (const Te of F) for (let Me = 0; Me < Te.circleArray.length / 4; Me++) {
            const Ve = 4 * Me, De = Te.circleArray[Ve + 0], He = Te.circleArray[Ve + 1], Ze = Te.circleArray[Ve + 2], Fe = Te.circleArray[Ve + 3];
            Q.emplace(le++, De, He, Ze, Fe, 0), Q.emplace(le++, De, He, Ze, Fe, 1), Q.emplace(le++, De, He, Ze, Fe, 2), Q.emplace(le++, De, He, Ze, Fe, 3);
          }
          (!Ml || Ml.length < 2 * j) && (Ml = function(Te) {
            const Me = 2 * Te, Ve = new o.c0();
            Ve.resize(Me), Ve._trim();
            for (let De = 0; De < Me; De++) {
              const He = 6 * De;
              Ve.uint16[He + 0] = 4 * De + 0, Ve.uint16[He + 1] = 4 * De + 1, Ve.uint16[He + 2] = 4 * De + 2, Ve.uint16[He + 3] = 4 * De + 2, Ve.uint16[He + 4] = 4 * De + 3, Ve.uint16[He + 5] = 4 * De + 0;
            }
            return Ve;
          }(j));
          const Ae = w.createIndexBuffer(Ml, !0), we = w.createVertexBuffer(Q, o.b$.members, !0);
          for (const Te of F) {
            const Me = Vi(v.transform);
            G.draw(w, P.TRIANGLES, Yr.disabled, Or.disabled, v.colorModeForRenderPass(), Wr.disabled, Me, v.style.map.terrain && v.style.map.terrain.getTerrainData(Te.coord), null, h.id, we, Ae, o.aL.simpleSegment(0, 2 * Te.circleOffset, Te.circleArray.length, Te.circleArray.length / 2), null, v.transform.zoom, null, null, null);
          }
          we.destroy(), Ae.destroy();
        }
        const Ou = o.af(new Float32Array(16));
        function rc(v, a, h, g, y, w) {
          const { horizontalAlign: C, verticalAlign: P } = o.aG(v);
          return new o.P((-(C - 0.5) * a / y + g[0]) * w, (-(P - 0.5) * h / y + g[1]) * w);
        }
        function Jf(v, a, h, g, y, w) {
          const C = a.tileAnchorPoint.add(new o.P(a.translation[0], a.translation[1]));
          if (a.pitchWithMap) {
            let P = g.mult(w);
            h || (P = P.rotate(-y));
            const L = C.add(P);
            return Jr(L.x, L.y, a.pitchedLabelPlaneMatrix, a.getElevation).point;
          }
          if (h) {
            const P = rr(a.tileAnchorPoint.x + 1, a.tileAnchorPoint.y, a).point.sub(v), L = Math.atan(P.y / P.x) + (P.x < 0 ? Math.PI : 0);
            return v.add(g.rotate(L));
          }
          return v.add(g);
        }
        function Qh(v, a, h, g, y, w, C, P, L, F, j, X) {
          const G = v.text.placedSymbolArray, Q = v.text.dynamicLayoutVertexArray, le = v.icon.dynamicLayoutVertexArray, Ae = {};
          Q.clear();
          for (let we = 0; we < G.length; we++) {
            const Te = G.get(we), Me = Te.hidden || !Te.crossTileID || v.allowVerticalPlacement && !Te.placedOrientation ? null : g[Te.crossTileID];
            if (Me) {
              const Ve = new o.P(Te.anchorX, Te.anchorY), De = { getElevation: X, width: y.width, height: y.height, pitchedLabelPlaneMatrix: w, pitchWithMap: h, transform: y, tileAnchorPoint: Ve, translation: F, unwrappedTileID: j }, He = h ? Gr(Ve.x, Ve.y, De) : rr(Ve.x, Ve.y, De), Ze = Cr(y.cameraToCenterDistance, He.signedDistanceFromCamera);
              let Fe = o.ao(v.textSizeData, P, Te) * Ze / o.aA;
              h && (Fe *= v.tilePixelRatio / C);
              const { width: it, height: bt, anchor: dt, textOffset: Tt, textBoxScale: wt } = Me, ir = rc(dt, it, bt, Tt, wt, Fe), or = y.getPitchedTextCorrection(Ve.x + F[0], Ve.y + F[1], j), Vt = Jf(He.point, De, a, ir, -y.bearingInRadians, or), xr = v.allowVerticalPlacement && Te.placedOrientation === o.an.vertical ? Math.PI / 2 : 0;
              for (let an = 0; an < Te.numGlyphs; an++) o.au(Q, Vt, xr);
              L && Te.associatedIconIndex >= 0 && (Ae[Te.associatedIconIndex] = { shiftedAnchor: Vt, angle: xr });
            } else io(Te.numGlyphs, Q);
          }
          if (L) {
            le.clear();
            const we = v.icon.placedSymbolArray;
            for (let Te = 0; Te < we.length; Te++) {
              const Me = we.get(Te);
              if (Me.hidden) io(Me.numGlyphs, le);
              else {
                const Ve = Ae[Te];
                if (Ve) for (let De = 0; De < Me.numGlyphs; De++) o.au(le, Ve.shiftedAnchor, Ve.angle);
                else io(Me.numGlyphs, le);
              }
            }
            v.icon.dynamicLayoutVertexBuffer.updateData(le);
          }
          v.text.dynamicLayoutVertexBuffer.updateData(Q);
        }
        function uh(v, a, h) {
          return h.iconsInText && a ? "symbolTextAndIcon" : v ? "symbolSDF" : "symbolIcon";
        }
        function ku(v, a, h, g, y, w, C, P, L, F, j, X, G) {
          const Q = v.context, le = Q.gl, Ae = v.transform, we = P === "map", Te = L === "map", Me = P !== "viewport" && h.layout.get("symbol-placement") !== "point", Ve = we && !Te && !Me, De = !h.layout.get("symbol-sort-key").isConstant();
          let He = !1;
          const Ze = v.getDepthModeForSublayer(0, Yr.ReadOnly), Fe = h._unevaluatedLayout.hasValue("text-variable-anchor") || h._unevaluatedLayout.hasValue("text-variable-anchor-offset"), it = [], bt = Ae.getCircleRadiusCorrection();
          for (const dt of g) {
            const Tt = a.getTile(dt), wt = Tt.getBucket(h);
            if (!wt) continue;
            const ir = y ? wt.text : wt.icon;
            if (!ir || !ir.segments.get().length || !ir.hasVisibleVertices) continue;
            const or = ir.programConfigurations.get(h.id), Vt = y || wt.sdfIcons, xr = y ? wt.textSizeData : wt.iconSizeData, an = Te || Ae.pitch !== 0, An = v.useProgram(uh(Vt, y, wt), or), ni = o.am(xr, Ae.zoom), On = v.style.map.terrain && v.style.map.terrain.getTerrainData(dt);
            let kn, In, En, Nn, Ji = [0, 0], yn = null;
            if (y) In = Tt.glyphAtlasTexture, En = le.LINEAR, kn = Tt.glyphAtlasTexture.size, wt.iconsInText && (Ji = Tt.imageAtlasTexture.size, yn = Tt.imageAtlasTexture, Nn = an || v.options.rotating || v.options.zooming || xr.kind === "composite" || xr.kind === "camera" ? le.LINEAR : le.NEAREST);
            else {
              const $i = h.layout.get("icon-size").constantOr(0) !== 1 || wt.iconsNeedLinear;
              In = Tt.imageAtlasTexture, En = Vt || v.options.rotating || v.options.zooming || $i || an ? le.LINEAR : le.NEAREST, kn = Tt.imageAtlasTexture.size;
            }
            const as = o.aB(Tt, 1, v.transform.zoom), Qi = tr(we, v.transform, as), Na = o.L();
            o.ap(Na, Qi);
            const tu = xn(Te, we, v.transform, as), ru = o.aC(Ae, Tt, w, C), Rl = Ae.getProjectionData({ overscaledTileID: dt, applyGlobeMatrix: !G, applyTerrainMatrix: !0 }), sf = Fe && wt.hasTextData(), of = h.layout.get("icon-text-fit") !== "none" && sf && wt.hasIconData();
            if (Me) {
              const $i = v.style.map.terrain ? (Eo, As) => v.style.map.terrain.getElevation(dt, Eo, As) : null, gi = h.layout.get("text-rotation-alignment") === "map";
              Dn(wt, v, y, Qi, Na, Te, F, gi, dt.toUnwrapped(), Ae.width, Ae.height, ru, $i);
            }
            const vh = y && Fe || of, $o = Me || vh ? Ou : Te ? Qi : v.transform.clipSpaceToPixelsMatrix, ol = Vt && h.paint.get(y ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            let nu;
            nu = Vt ? wt.iconsInText ? Jh(xr.kind, ni, Ve, Te, Me, vh, v, $o, tu, ru, kn, Ji, bt) : Yi(xr.kind, ni, Ve, Te, Me, vh, v, $o, tu, ru, y, kn, 0, bt) : Kl(xr.kind, ni, Ve, Te, Me, vh, v, $o, tu, ru, y, kn, bt);
            const $u = { program: An, buffers: ir, uniformValues: nu, projectionData: Rl, atlasTexture: In, atlasTextureIcon: yn, atlasInterpolation: En, atlasInterpolationIcon: Nn, isSDF: Vt, hasHalo: ol };
            if (De && wt.canOverlap) {
              He = !0;
              const $i = ir.segments.get();
              for (const gi of $i) it.push({ segments: new o.aL([gi]), sortKey: gi.sortKey, state: $u, terrainData: On });
            } else it.push({ segments: ir.segments, sortKey: 0, state: $u, terrainData: On });
          }
          He && it.sort((dt, Tt) => dt.sortKey - Tt.sortKey);
          for (const dt of it) {
            const Tt = dt.state;
            if (Q.activeTexture.set(le.TEXTURE0), Tt.atlasTexture.bind(Tt.atlasInterpolation, le.CLAMP_TO_EDGE), Tt.atlasTextureIcon && (Q.activeTexture.set(le.TEXTURE1), Tt.atlasTextureIcon && Tt.atlasTextureIcon.bind(Tt.atlasInterpolationIcon, le.CLAMP_TO_EDGE)), Tt.isSDF) {
              const wt = Tt.uniformValues;
              Tt.hasHalo && (wt.u_is_halo = 1, Hc(Tt.buffers, dt.segments, h, v, Tt.program, Ze, j, X, wt, Tt.projectionData, dt.terrainData)), wt.u_is_halo = 0;
            }
            Hc(Tt.buffers, dt.segments, h, v, Tt.program, Ze, j, X, Tt.uniformValues, Tt.projectionData, dt.terrainData);
          }
        }
        function Hc(v, a, h, g, y, w, C, P, L, F, j) {
          const X = g.context;
          y.draw(X, X.gl.TRIANGLES, w, C, P, Wr.backCCW, L, j, F, h.id, v.layoutVertexBuffer, v.indexBuffer, a, h.paint, g.transform.zoom, v.programConfigurations.get(h.id), v.dynamicLayoutVertexBuffer, v.opacityVertexBuffer);
        }
        function hh(v, a, h, g, y) {
          const w = v.context, C = w.gl, P = Or.disabled, L = new pn([C.ONE, C.ONE], o.be.transparent, [!0, !0, !0, !0]), F = a.getBucket(h);
          if (!F) return;
          const j = g.key;
          let X = h.heatmapFbos.get(j);
          X || (X = Wc(w, a.tileSize, a.tileSize), h.heatmapFbos.set(j, X)), w.bindFramebuffer.set(X.framebuffer), w.viewport.set([0, 0, a.tileSize, a.tileSize]), w.clear({ color: o.be.transparent });
          const G = F.programConfigurations.get(h.id), Q = v.useProgram("heatmap", G, !y), le = v.transform.getProjectionData({ overscaledTileID: a.tileID, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), Ae = v.style.map.terrain.getTerrainData(g);
          Q.draw(w, C.TRIANGLES, Yr.disabled, P, L, Wr.disabled, Gs(a, v.transform.zoom, h.paint.get("heatmap-intensity"), 1), Ae, le, h.id, F.layoutVertexBuffer, F.indexBuffer, F.segments, h.paint, v.transform.zoom, G);
        }
        function fh(v, a, h, g, y) {
          const w = v.context, C = w.gl, P = v.transform;
          w.setColorMode(v.colorModeForRenderPass());
          const L = dh(w, a), F = h.key, j = a.heatmapFbos.get(F);
          if (!j) return;
          w.activeTexture.set(C.TEXTURE0), C.bindTexture(C.TEXTURE_2D, j.colorAttachment.get()), w.activeTexture.set(C.TEXTURE1), L.bind(C.LINEAR, C.CLAMP_TO_EDGE);
          const X = P.getProjectionData({ overscaledTileID: h, applyTerrainMatrix: y, applyGlobeMatrix: !g });
          v.useProgram("heatmapTexture").draw(w, C.TRIANGLES, Yr.disabled, Or.disabled, v.colorModeForRenderPass(), Wr.disabled, Ao(v, a, 0, 1), null, X, a.id, v.rasterBoundsBuffer, v.quadTriangleIndexBuffer, v.rasterBoundsSegments, a.paint, P.zoom), j.destroy(), a.heatmapFbos.delete(F);
        }
        function Wc(v, a, h) {
          var g, y;
          const w = v.gl, C = w.createTexture();
          w.bindTexture(w.TEXTURE_2D, C), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_WRAP_S, w.CLAMP_TO_EDGE), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_WRAP_T, w.CLAMP_TO_EDGE), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_MIN_FILTER, w.LINEAR), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_MAG_FILTER, w.LINEAR);
          const P = (g = v.HALF_FLOAT) !== null && g !== void 0 ? g : w.UNSIGNED_BYTE, L = (y = v.RGBA16F) !== null && y !== void 0 ? y : w.RGBA;
          w.texImage2D(w.TEXTURE_2D, 0, L, a, h, 0, w.RGBA, P, null);
          const F = v.createFramebuffer(a, h, !1, !1);
          return F.colorAttachment.set(C), F;
        }
        function dh(v, a) {
          return a.colorRampTexture || (a.colorRampTexture = new o.T(v, a.colorRamp, v.gl.RGBA)), a.colorRampTexture;
        }
        function ef(v, a, h, g, y) {
          if (!h || !g || !g.imageAtlas) return;
          const w = g.imageAtlas.patternPositions;
          let C = w[h.to.toString()], P = w[h.from.toString()];
          if (!C && P && (C = P), !P && C && (P = C), !C || !P) {
            const L = y.getPaintProperty(a);
            C = w[L], P = w[L];
          }
          C && P && v.setConstantPatternPositions(C, P);
        }
        function Nu(v, a, h, g, y, w, C, P) {
          const L = v.context.gl, F = "fill-pattern", j = h.paint.get(F), X = j && j.constantOr(1), G = h.getCrossfadeParameters();
          let Q, le, Ae, we, Te;
          const Me = v.transform, Ve = h.paint.get("fill-translate"), De = h.paint.get("fill-translate-anchor");
          C ? (le = X && !h.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", Q = L.LINES) : (le = X ? "fillPattern" : "fill", Q = L.TRIANGLES);
          const He = j.constantOr(null);
          for (const Ze of g) {
            const Fe = a.getTile(Ze);
            if (X && !Fe.patternsLoaded()) continue;
            const it = Fe.getBucket(h);
            if (!it) continue;
            const bt = it.programConfigurations.get(h.id), dt = v.useProgram(le, bt), Tt = v.style.map.terrain && v.style.map.terrain.getTerrainData(Ze);
            X && (v.context.activeTexture.set(L.TEXTURE0), Fe.imageAtlasTexture.bind(L.LINEAR, L.CLAMP_TO_EDGE), bt.updatePaintBuffers(G)), ef(bt, F, He, Fe, h);
            const wt = Me.getProjectionData({ overscaledTileID: Ze, applyGlobeMatrix: !P, applyTerrainMatrix: !0 }), ir = o.aC(Me, Fe, Ve, De);
            if (C) {
              we = it.indexBuffer2, Te = it.segments2;
              const Vt = [L.drawingBufferWidth, L.drawingBufferHeight];
              Ae = le === "fillOutlinePattern" && X ? vi(v, G, Fe, Vt, ir) : ln(Vt, ir);
            } else we = it.indexBuffer, Te = it.segments, Ae = X ? Qr(v, G, Fe, ir) : { u_fill_translate: ir };
            const or = v.stencilModeForClipping(Ze);
            dt.draw(v.context, Q, y, or, w, Wr.backCCW, Ae, Tt, wt, h.id, it.layoutVertexBuffer, we, Te, h.paint, v.transform.zoom, bt);
          }
        }
        function Xc(v, a, h, g, y, w, C, P) {
          const L = v.context, F = L.gl, j = "fill-extrusion-pattern", X = h.paint.get(j), G = X.constantOr(1), Q = h.getCrossfadeParameters(), le = h.paint.get("fill-extrusion-opacity"), Ae = X.constantOr(null), we = v.transform;
          for (const Te of g) {
            const Me = a.getTile(Te), Ve = Me.getBucket(h);
            if (!Ve) continue;
            const De = v.style.map.terrain && v.style.map.terrain.getTerrainData(Te), He = Ve.programConfigurations.get(h.id), Ze = v.useProgram(G ? "fillExtrusionPattern" : "fillExtrusion", He);
            G && (v.context.activeTexture.set(F.TEXTURE0), Me.imageAtlasTexture.bind(F.LINEAR, F.CLAMP_TO_EDGE), He.updatePaintBuffers(Q));
            const Fe = we.getProjectionData({ overscaledTileID: Te, applyGlobeMatrix: !P, applyTerrainMatrix: !0 });
            ef(He, j, Ae, Me, h);
            const it = o.aC(we, Me, h.paint.get("fill-extrusion-translate"), h.paint.get("fill-extrusion-translate-anchor")), bt = h.paint.get("fill-extrusion-vertical-gradient"), dt = G ? sn(v, bt, le, it, Te, Q, Me) : Fr(v, bt, le, it);
            Ze.draw(L, L.gl.TRIANGLES, y, w, C, Wr.backCCW, dt, De, Fe, h.id, Ve.layoutVertexBuffer, Ve.indexBuffer, Ve.segments, h.paint, v.transform.zoom, He, v.style.map.terrain && Ve.centroidVertexBuffer);
          }
        }
        function Zc(v, a, h, g, y, w, C, P, L) {
          var F;
          const j = v.style.projection, X = v.context, G = v.transform, Q = X.gl, le = [`#define NUM_ILLUMINATION_SOURCES ${h.paint.get("hillshade-highlight-color").values.length}`], Ae = v.useProgram("hillshade", null, !1, le), we = !v.options.moving;
          for (const Te of g) {
            const Me = a.getTile(Te), Ve = Me.fbo;
            if (!Ve) continue;
            const De = j.getMeshFromTileID(X, Te.canonical, P, !0, "raster"), He = (F = v.style.map.terrain) === null || F === void 0 ? void 0 : F.getTerrainData(Te);
            X.activeTexture.set(Q.TEXTURE0), Q.bindTexture(Q.TEXTURE_2D, Ve.colorAttachment.get());
            const Ze = G.getProjectionData({ overscaledTileID: Te, aligned: we, applyGlobeMatrix: !L, applyTerrainMatrix: !0 });
            Ae.draw(X, Q.TRIANGLES, w, y[Te.overscaledZ], C, Wr.backCCW, Hs(v, Me, h), He, Ze, h.id, De.vertexBuffer, De.indexBuffer, De.segments);
          }
        }
        function nc(v, a, h, g, y, w, C, P, L) {
          var F;
          const j = v.style.projection, X = v.context, G = v.transform, Q = X.gl, le = v.useProgram("colorRelief"), Ae = !v.options.moving;
          let we = !0;
          for (const Te of g) {
            const Me = a.getTile(Te), Ve = Me.dem;
            if (we) {
              const bt = Q.getParameter(Q.MAX_TEXTURE_SIZE), { elevationTexture: dt, colorTexture: Tt } = h.getColorRampTextures(X, bt, Ve.getUnpackVector());
              X.activeTexture.set(Q.TEXTURE1), dt.bind(Q.NEAREST, Q.CLAMP_TO_EDGE), X.activeTexture.set(Q.TEXTURE4), Tt.bind(Q.LINEAR, Q.CLAMP_TO_EDGE), we = !1;
            }
            if (!Ve || !Ve.data) continue;
            const De = Ve.stride, He = Ve.getPixels();
            if (X.activeTexture.set(Q.TEXTURE0), X.pixelStoreUnpackPremultiplyAlpha.set(!1), Me.demTexture = Me.demTexture || v.getTileTexture(De), Me.demTexture) {
              const bt = Me.demTexture;
              bt.update(He, { premultiply: !1 }), bt.bind(Q.LINEAR, Q.CLAMP_TO_EDGE);
            } else Me.demTexture = new o.T(X, He, Q.RGBA, { premultiply: !1 }), Me.demTexture.bind(Q.LINEAR, Q.CLAMP_TO_EDGE);
            const Ze = j.getMeshFromTileID(X, Te.canonical, P, !0, "raster"), Fe = (F = v.style.map.terrain) === null || F === void 0 ? void 0 : F.getTerrainData(Te), it = G.getProjectionData({ overscaledTileID: Te, aligned: Ae, applyGlobeMatrix: !L, applyTerrainMatrix: !0 });
            le.draw(X, Q.TRIANGLES, w, y[Te.overscaledZ], C, Wr.backCCW, Pu(h, Me.dem), Fe, it, h.id, Ze.vertexBuffer, Ze.indexBuffer, Ze.segments);
          }
        }
        const Du = [new o.P(0, 0), new o.P(o.$, 0), new o.P(o.$, o.$), new o.P(0, o.$)];
        function Do(v, a, h, g, y, w, C, P) {
          let L = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : !1, F = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : !1;
          const j = g[g.length - 1].overscaledZ, X = v.context, G = X.gl, Q = v.useProgram("raster"), le = v.transform, Ae = v.style.projection, we = v.colorModeForRenderPass(), Te = !v.options.moving;
          for (const Me of g) {
            const Ve = v.getDepthModeForSublayer(Me.overscaledZ - j, h.paint.get("raster-opacity") === 1 ? Yr.ReadWrite : Yr.ReadOnly, G.LESS), De = a.getTile(Me);
            De.registerFadeDuration(h.paint.get("raster-fade-duration"));
            const He = a.findLoadedParent(Me, 0), Ze = a.findLoadedSibling(Me), Fe = Ap(De, He || Ze || null, a, h, v.transform, v.style.map.terrain);
            let it, bt;
            const dt = h.paint.get("raster-resampling") === "nearest" ? G.NEAREST : G.LINEAR;
            X.activeTexture.set(G.TEXTURE0), De.texture.bind(dt, G.CLAMP_TO_EDGE, G.LINEAR_MIPMAP_NEAREST), X.activeTexture.set(G.TEXTURE1), He ? (He.texture.bind(dt, G.CLAMP_TO_EDGE, G.LINEAR_MIPMAP_NEAREST), it = Math.pow(2, He.tileID.overscaledZ - De.tileID.overscaledZ), bt = [De.tileID.canonical.x * it % 1, De.tileID.canonical.y * it % 1]) : De.texture.bind(dt, G.CLAMP_TO_EDGE, G.LINEAR_MIPMAP_NEAREST), De.texture.useMipmap && X.extTextureFilterAnisotropic && v.transform.pitch > 20 && G.texParameterf(G.TEXTURE_2D, X.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, X.extTextureFilterAnisotropicMax);
            const Tt = v.style.map.terrain && v.style.map.terrain.getTerrainData(Me), wt = le.getProjectionData({ overscaledTileID: Me, aligned: Te, applyGlobeMatrix: !F, applyTerrainMatrix: !0 }), ir = Oo(bt || [0, 0], it || 1, Fe, h, P), or = Ae.getMeshFromTileID(X, Me.canonical, w, C, "raster");
            Q.draw(X, G.TRIANGLES, Ve, y ? y[Me.overscaledZ] : Or.disabled, we, L ? Wr.frontCCW : Wr.backCCW, ir, Tt, wt, h.id, or.vertexBuffer, or.indexBuffer, or.segments);
          }
        }
        function Ap(v, a, h, g, y, w) {
          const C = g.paint.get("raster-fade-duration");
          if (!w && C > 0) {
            const P = M.now(), L = (P - v.timeAdded) / C, F = a ? (P - a.timeAdded) / C : -1, j = h.getSource(), X = Bt(y, { tileSize: j.tileSize, roundZoom: j.roundZoom }), G = !a || Math.abs(a.tileID.overscaledZ - X) > Math.abs(v.tileID.overscaledZ - X), Q = G && v.refreshedUponExpiration ? 1 : o.ag(G ? L : 1 - F, 0, 1);
            return v.refreshedUponExpiration && L >= 1 && (v.refreshedUponExpiration = !1), a ? { opacity: 1, mix: 1 - Q } : { opacity: Q, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        const Qf = new o.be(1, 0, 0, 1), Fu = new o.be(0, 1, 0, 1), tf = new o.be(0, 0, 1, 1), ed = new o.be(1, 0, 1, 1), td = new o.be(0, 1, 1, 1);
        function Uu(v, a, h, g) {
          uo(v, 0, a + h / 2, v.transform.width, h, g);
        }
        function fa(v, a, h, g) {
          uo(v, a - h / 2, 0, h, v.transform.height, g);
        }
        function uo(v, a, h, g, y, w) {
          const C = v.context, P = C.gl;
          P.enable(P.SCISSOR_TEST), P.scissor(a * v.pixelRatio, h * v.pixelRatio, g * v.pixelRatio, y * v.pixelRatio), C.clear({ color: w }), P.disable(P.SCISSOR_TEST);
        }
        function La(v, a, h) {
          const g = v.context, y = g.gl, w = v.useProgram("debug"), C = Yr.disabled, P = Or.disabled, L = v.colorModeForRenderPass(), F = "$debug", j = v.style.map.terrain && v.style.map.terrain.getTerrainData(h);
          g.activeTexture.set(y.TEXTURE0);
          const X = a.getTileByID(h.key).latestRawTileData, G = Math.floor((X && X.byteLength || 0) / 1024), Q = a.getTile(h).tileSize, le = 512 / Math.min(Q, 512) * (h.overscaledZ / v.transform.zoom) * 0.5;
          let Ae = h.canonical.toString();
          h.overscaledZ !== h.canonical.z && (Ae += ` => ${h.overscaledZ}`), function(Te, Me) {
            Te.initDebugOverlayCanvas();
            const Ve = Te.debugOverlayCanvas, De = Te.context.gl, He = Te.debugOverlayCanvas.getContext("2d");
            He.clearRect(0, 0, Ve.width, Ve.height), He.shadowColor = "white", He.shadowBlur = 2, He.lineWidth = 1.5, He.strokeStyle = "white", He.textBaseline = "top", He.font = "bold 36px Open Sans, sans-serif", He.fillText(Me, 5, 5), He.strokeText(Me, 5, 5), Te.debugOverlayTexture.update(Ve), Te.debugOverlayTexture.bind(De.LINEAR, De.CLAMP_TO_EDGE);
          }(v, `${Ae} ${G}kB`);
          const we = v.transform.getProjectionData({ overscaledTileID: h, applyGlobeMatrix: !0, applyTerrainMatrix: !0 });
          w.draw(g, y.TRIANGLES, C, P, pn.alphaBlended, Wr.disabled, Xi(o.be.transparent, le), null, we, F, v.debugBuffer, v.quadTriangleIndexBuffer, v.debugSegments), w.draw(g, y.LINE_STRIP, C, P, L, Wr.disabled, Xi(o.be.red), j, we, F, v.debugBuffer, v.tileBorderIndexBuffer, v.debugSegments);
        }
        function Si(v, a, h, g) {
          const { isRenderingGlobe: y } = g, w = v.context, C = w.gl, P = v.transform, L = v.colorModeForRenderPass(), F = v.getDepthModeFor3D(), j = v.useProgram("terrain");
          w.bindFramebuffer.set(null), w.viewport.set([0, 0, v.width, v.height]);
          for (const X of h) {
            const G = a.getTerrainMesh(X.tileID), Q = v.renderToTexture.getTexture(X), le = a.getTerrainData(X.tileID);
            w.activeTexture.set(C.TEXTURE0), C.bindTexture(C.TEXTURE_2D, Q.texture);
            const Ae = a.getMeshFrameDelta(P.zoom), we = P.calculateFogMatrix(X.tileID.toUnwrapped()), Te = tt(Ae, we, v.style.sky, P.pitch, y), Me = P.getProjectionData({ overscaledTileID: X.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 });
            j.draw(w, C.TRIANGLES, F, Or.disabled, L, Wr.backCCW, Te, le, Me, "terrain", G.vertexBuffer, G.indexBuffer, G.segments);
          }
        }
        function nl(v, a) {
          if (!a.mesh) {
            const h = new o.aK();
            h.emplaceBack(-1, -1), h.emplaceBack(1, -1), h.emplaceBack(1, 1), h.emplaceBack(-1, 1);
            const g = new o.aM();
            g.emplaceBack(0, 1, 2), g.emplaceBack(0, 2, 3), a.mesh = new sa(v.createVertexBuffer(h, oa.members), v.createIndexBuffer(g), o.aL.simpleSegment(0, 0, h.length, g.length));
          }
          return a.mesh;
        }
        class Ki {
          constructor(a, h) {
            this.context = new cn(a), this.transform = h, this._tileTextures = {}, this.terrainFacilitator = { dirty: !0, matrix: o.af(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = ft.maxUnderzooming + ft.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Gl();
          }
          resize(a, h, g) {
            if (this.width = Math.floor(a * g), this.height = Math.floor(h * g), this.pixelRatio = g, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const y of this.style._order) this.style._layers[y].resize();
          }
          setup() {
            const a = this.context, h = new o.aK();
            h.emplaceBack(0, 0), h.emplaceBack(o.$, 0), h.emplaceBack(0, o.$), h.emplaceBack(o.$, o.$), this.tileExtentBuffer = a.createVertexBuffer(h, oa.members), this.tileExtentSegments = o.aL.simpleSegment(0, 0, 4, 2);
            const g = new o.aK();
            g.emplaceBack(0, 0), g.emplaceBack(o.$, 0), g.emplaceBack(0, o.$), g.emplaceBack(o.$, o.$), this.debugBuffer = a.createVertexBuffer(g, oa.members), this.debugSegments = o.aL.simpleSegment(0, 0, 4, 5);
            const y = new o.c5();
            y.emplaceBack(0, 0, 0, 0), y.emplaceBack(o.$, 0, o.$, 0), y.emplaceBack(0, o.$, 0, o.$), y.emplaceBack(o.$, o.$, o.$, o.$), this.rasterBoundsBuffer = a.createVertexBuffer(y, ae.members), this.rasterBoundsSegments = o.aL.simpleSegment(0, 0, 4, 2);
            const w = new o.aK();
            w.emplaceBack(0, 0), w.emplaceBack(o.$, 0), w.emplaceBack(0, o.$), w.emplaceBack(o.$, o.$), this.rasterBoundsBufferPosOnly = a.createVertexBuffer(w, oa.members), this.rasterBoundsSegmentsPosOnly = o.aL.simpleSegment(0, 0, 4, 5);
            const C = new o.aK();
            C.emplaceBack(0, 0), C.emplaceBack(1, 0), C.emplaceBack(0, 1), C.emplaceBack(1, 1), this.viewportBuffer = a.createVertexBuffer(C, oa.members), this.viewportSegments = o.aL.simpleSegment(0, 0, 4, 2);
            const P = new o.c6();
            P.emplaceBack(0), P.emplaceBack(1), P.emplaceBack(3), P.emplaceBack(2), P.emplaceBack(0), this.tileBorderIndexBuffer = a.createIndexBuffer(P);
            const L = new o.aM();
            L.emplaceBack(1, 0, 2), L.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = a.createIndexBuffer(L);
            const F = this.context.gl;
            this.stencilClearMode = new Or({ func: F.ALWAYS, mask: 0 }, 0, 255, F.ZERO, F.ZERO, F.ZERO), this.tileExtentMesh = new sa(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
          clearStencil() {
            const a = this.context, h = a.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const g = o.L();
            o.bX(g, 0, this.width, this.height, 0, 0, 1), o.N(g, g, [h.drawingBufferWidth, h.drawingBufferHeight, 0]);
            const y = { mainMatrix: g, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: g };
            this.useProgram("clippingMask", null, !0).draw(a, h.TRIANGLES, Yr.disabled, this.stencilClearMode, pn.disabled, Wr.disabled, null, null, y, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          _renderTileClippingMasks(a, h, g) {
            if (this.currentStencilSource === a.source || !a.isTileClipped() || !h || !h.length) return;
            this.currentStencilSource = a.source, this.nextStencilID + h.length > 256 && this.clearStencil();
            const y = this.context;
            y.setColorMode(pn.disabled), y.setDepthMode(Yr.disabled);
            const w = {};
            for (const C of h) w[C.key] = this.nextStencilID++;
            this._renderTileMasks(w, h, g, !0), this._renderTileMasks(w, h, g, !1), this._tileClippingMaskIDs = w;
          }
          _renderTileMasks(a, h, g, y) {
            const w = this.context, C = w.gl, P = this.style.projection, L = this.transform, F = this.useProgram("clippingMask");
            for (const j of h) {
              const X = a[j.key], G = this.style.map.terrain && this.style.map.terrain.getTerrainData(j), Q = P.getMeshFromTileID(this.context, j.canonical, y, !0, "stencil"), le = L.getProjectionData({ overscaledTileID: j, applyGlobeMatrix: !g, applyTerrainMatrix: !0 });
              F.draw(w, C.TRIANGLES, Yr.disabled, new Or({ func: C.ALWAYS, mask: 0 }, X, 255, C.KEEP, C.KEEP, C.REPLACE), pn.disabled, g ? Wr.disabled : Wr.backCCW, null, G, le, "$clipping", Q.vertexBuffer, Q.indexBuffer, Q.segments);
            }
          }
          _renderTilesDepthBuffer() {
            const a = this.context, h = a.gl, g = this.style.projection, y = this.transform, w = this.useProgram("depth"), C = this.getDepthModeFor3D(), P = Pt(y, { tileSize: y.tileSize });
            for (const L of P) {
              const F = this.style.map.terrain && this.style.map.terrain.getTerrainData(L), j = g.getMeshFromTileID(this.context, L.canonical, !0, !0, "raster"), X = y.getProjectionData({ overscaledTileID: L, applyGlobeMatrix: !0, applyTerrainMatrix: !0 });
              w.draw(a, h.TRIANGLES, C, Or.disabled, pn.disabled, Wr.backCCW, null, F, X, "$clipping", j.vertexBuffer, j.indexBuffer, j.segments);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const a = this.nextStencilID++, h = this.context.gl;
            return new Or({ func: h.NOTEQUAL, mask: 255 }, a, 255, h.KEEP, h.KEEP, h.REPLACE);
          }
          stencilModeForClipping(a) {
            const h = this.context.gl;
            return new Or({ func: h.EQUAL, mask: 255 }, this._tileClippingMaskIDs[a.key], 0, h.KEEP, h.KEEP, h.REPLACE);
          }
          getStencilConfigForOverlapAndUpdateStencilID(a) {
            const h = this.context.gl, g = a.sort((C, P) => P.overscaledZ - C.overscaledZ), y = g[g.length - 1].overscaledZ, w = g[0].overscaledZ - y + 1;
            if (w > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + w > 256 && this.clearStencil();
              const C = {};
              for (let P = 0; P < w; P++) C[P + y] = new Or({ func: h.GEQUAL, mask: 255 }, P + this.nextStencilID, 255, h.KEEP, h.KEEP, h.REPLACE);
              return this.nextStencilID += w, [C, g];
            }
            return [{ [y]: Or.disabled }, g];
          }
          stencilConfigForOverlapTwoPass(a) {
            const h = this.context.gl, g = a.sort((C, P) => P.overscaledZ - C.overscaledZ), y = g[g.length - 1].overscaledZ, w = g[0].overscaledZ - y + 1;
            if (this.clearStencil(), w > 1) {
              const C = {}, P = {};
              for (let L = 0; L < w; L++) C[L + y] = new Or({ func: h.GREATER, mask: 255 }, w + 1 + L, 255, h.KEEP, h.KEEP, h.REPLACE), P[L + y] = new Or({ func: h.GREATER, mask: 255 }, 1 + L, 255, h.KEEP, h.KEEP, h.REPLACE);
              return this.nextStencilID = 2 * w + 1, [C, P, g];
            }
            return this.nextStencilID = 3, [{ [y]: new Or({ func: h.GREATER, mask: 255 }, 2, 255, h.KEEP, h.KEEP, h.REPLACE) }, { [y]: new Or({ func: h.GREATER, mask: 255 }, 1, 255, h.KEEP, h.KEEP, h.REPLACE) }, g];
          }
          colorModeForRenderPass() {
            const a = this.context.gl;
            return this._showOverdrawInspector ? new pn([a.CONSTANT_COLOR, a.ONE], new o.be(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? pn.unblended : pn.alphaBlended;
          }
          getDepthModeForSublayer(a, h, g) {
            if (!this.opaquePassEnabledForLayer()) return Yr.disabled;
            const y = 1 - ((1 + this.currentLayer) * this.numSublayers + a) * this.depthEpsilon;
            return new Yr(g || this.context.gl.LEQUAL, h, [y, y]);
          }
          getDepthModeFor3D() {
            return new Yr(this.context.gl.LEQUAL, Yr.ReadWrite, this.depthRangeFor3D);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(a, h) {
            var g, y;
            this.style = a, this.options = h, this.lineAtlas = a.lineAtlas, this.imageManager = a.imageManager, this.glyphManager = a.glyphManager, this.symbolFadeChange = a.placement.symbolFadeChange(M.now()), this.imageManager.beginFrame();
            const w = this.style._order, C = this.style.sourceCaches, P = {}, L = {}, F = {}, j = { isRenderingToTexture: !1, isRenderingGlobe: ((g = a.projection) === null || g === void 0 ? void 0 : g.transitionState) > 0 };
            for (const G in C) {
              const Q = C[G];
              Q.used && Q.prepare(this.context), P[G] = Q.getVisibleCoordinates(!1), L[G] = P[G].slice().reverse(), F[G] = Q.getVisibleCoordinates(!0).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let G = 0; G < w.length; G++) if (this.style._layers[w[G]].is3D()) {
              this.opaquePassCutoff = G;
              break;
            }
            this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const G of w) {
              const Q = this.style._layers[G];
              if (!Q.hasOffscreenPass() || Q.isHidden(this.transform.zoom)) continue;
              const le = L[Q.source];
              (Q.type === "custom" || le.length) && this.renderLayer(this, C[Q.source], Q, le, j);
            }
            if ((y = this.style.projection) === null || y === void 0 || y.updateGPUdependent({ context: this.context, useProgram: (G) => this.useProgram(G) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: h.showOverdrawInspector ? o.be.black : o.be.transparent, depth: 1 }), this.clearStencil(), this.style.sky && function(G, Q) {
              const le = G.context, Ae = le.gl, we = ((Ze, Fe, it) => {
                const bt = Math.cos(Fe.rollInRadians), dt = Math.sin(Fe.rollInRadians), Tt = fe(Fe), wt = Fe.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }).projectionTransition;
                return { u_sky_color: Ze.properties.get("sky-color"), u_horizon_color: Ze.properties.get("horizon-color"), u_horizon: [(Fe.width / 2 - Tt * dt) * it, (Fe.height / 2 + Tt * bt) * it], u_horizon_normal: [-dt, bt], u_sky_horizon_blend: Ze.properties.get("sky-horizon-blend") * Fe.height / 2 * it, u_sky_blend: wt };
              })(Q, G.style.map.transform, G.pixelRatio), Te = new Yr(Ae.LEQUAL, Yr.ReadWrite, [0, 1]), Me = Or.disabled, Ve = G.colorModeForRenderPass(), De = G.useProgram("sky"), He = nl(le, Q);
              De.draw(le, Ae.TRIANGLES, Te, Me, Ve, Wr.disabled, we, null, void 0, "sky", He.vertexBuffer, He.indexBuffer, He.segments);
            }(this, this.style.sky), this._showOverdrawInspector = h.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (a._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = w.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const G = this.style._layers[w[this.currentLayer]], Q = C[G.source], le = P[G.source];
              this._renderTileClippingMasks(G, le, !1), this.renderLayer(this, Q, G, le, j);
            }
            this.renderPass = "translucent";
            let X = !1;
            for (this.currentLayer = 0; this.currentLayer < w.length; this.currentLayer++) {
              const G = this.style._layers[w[this.currentLayer]], Q = C[G.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(G, j)) continue;
              this.opaquePassEnabledForLayer() || X || (X = !0, j.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const le = (G.type === "symbol" ? F : L)[G.source];
              this._renderTileClippingMasks(G, P[G.source], !!this.renderToTexture), this.renderLayer(this, Q, G, le, j);
            }
            if (j.isRenderingGlobe && function(G, Q, le) {
              const Ae = G.context, we = Ae.gl, Te = G.useProgram("atmosphere"), Me = new Yr(we.LEQUAL, Yr.ReadOnly, [0, 1]), Ve = G.transform, De = function(wt, ir) {
                const or = wt.properties.get("position"), Vt = [-or.x, -or.y, -or.z], xr = o.af(new Float64Array(16));
                return wt.properties.get("anchor") === "map" && (o.b5(xr, xr, ir.rollInRadians), o.b6(xr, xr, -ir.pitchInRadians), o.b5(xr, xr, ir.bearingInRadians), o.b6(xr, xr, ir.center.lat * Math.PI / 180), o.by(xr, xr, -ir.center.lng * Math.PI / 180)), o.c4(Vt, Vt, xr), Vt;
              }(le, G.transform), He = Ve.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), Ze = Q.properties.get("atmosphere-blend") * He.projectionTransition;
              if (Ze === 0) return;
              const Fe = Rs(Ve.worldSize, Ve.center.lat), it = Ve.inverseProjectionMatrix, bt = new Float64Array(4);
              bt[3] = 1, o.av(bt, bt, Ve.modelViewProjectionMatrix), bt[0] /= bt[3], bt[1] /= bt[3], bt[2] /= bt[3], bt[3] = 1, o.av(bt, bt, it), bt[0] /= bt[3], bt[1] /= bt[3], bt[2] /= bt[3], bt[3] = 1;
              const dt = /* @__PURE__ */ ((wt, ir, or, Vt, xr) => ({ u_sun_pos: wt, u_atmosphere_blend: ir, u_globe_position: or, u_globe_radius: Vt, u_inv_proj_matrix: xr }))(De, Ze, [bt[0], bt[1], bt[2]], Fe, it), Tt = nl(Ae, Q);
              Te.draw(Ae, we.TRIANGLES, Me, Or.disabled, pn.alphaBlended, Wr.disabled, dt, null, null, "atmosphere", Tt.vertexBuffer, Tt.indexBuffer, Tt.segments);
            }(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const G = function(Q, le) {
                let Ae = null;
                const we = Object.values(Q._layers).flatMap((De) => De.source && !De.isHidden(le) ? [Q.sourceCaches[De.source]] : []), Te = we.filter((De) => De.getSource().type === "vector"), Me = we.filter((De) => De.getSource().type !== "vector"), Ve = (De) => {
                  (!Ae || Ae.getSource().maxzoom < De.getSource().maxzoom) && (Ae = De);
                };
                return Te.forEach((De) => Ve(De)), Ae || Me.forEach((De) => Ve(De)), Ae;
              }(this.style, this.transform.zoom);
              G && function(Q, le, Ae) {
                for (let we = 0; we < Ae.length; we++) La(Q, le, Ae[we]);
              }(this, G, G.getVisibleCoordinates());
            }
            this.options.showPadding && function(G) {
              const Q = G.transform.padding;
              Uu(G, G.transform.height - (Q.top || 0), 3, Qf), Uu(G, Q.bottom || 0, 3, Fu), fa(G, Q.left || 0, 3, tf), fa(G, G.transform.width - (Q.right || 0), 3, ed);
              const le = G.transform.centerPoint;
              (function(Ae, we, Te, Me) {
                uo(Ae, we - 1, Te - 10, 2, 20, Me), uo(Ae, we - 10, Te - 1, 20, 2, Me);
              })(G, le.x, G.transform.height - le.y, td);
            }(this), this.context.setDefault();
          }
          maybeDrawDepthAndCoords(a) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const h = this.terrainFacilitator.matrix, g = this.transform.modelViewProjectionMatrix;
            let y = this.terrainFacilitator.dirty;
            y || (y = a ? !o.c7(h, g) : !o.c8(h, g)), y || (y = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)), y && (o.c9(h, g), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, function(w, C) {
              const P = w.context, L = P.gl, F = w.transform, j = pn.unblended, X = new Yr(L.LEQUAL, Yr.ReadWrite, [0, 1]), G = C.sourceCache.getRenderableTiles(), Q = w.useProgram("terrainDepth");
              P.bindFramebuffer.set(C.getFramebuffer("depth").framebuffer), P.viewport.set([0, 0, w.width / devicePixelRatio, w.height / devicePixelRatio]), P.clear({ color: o.be.transparent, depth: 1 });
              for (const le of G) {
                const Ae = C.getTerrainMesh(le.tileID), we = C.getTerrainData(le.tileID), Te = F.getProjectionData({ overscaledTileID: le.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 }), Me = { u_ele_delta: C.getMeshFrameDelta(F.zoom) };
                Q.draw(P, L.TRIANGLES, X, Or.disabled, j, Wr.backCCW, Me, we, Te, "terrain", Ae.vertexBuffer, Ae.indexBuffer, Ae.segments);
              }
              P.bindFramebuffer.set(null), P.viewport.set([0, 0, w.width, w.height]);
            }(this, this.style.map.terrain), function(w, C) {
              const P = w.context, L = P.gl, F = w.transform, j = pn.unblended, X = new Yr(L.LEQUAL, Yr.ReadWrite, [0, 1]), G = C.getCoordsTexture(), Q = C.sourceCache.getRenderableTiles(), le = w.useProgram("terrainCoords");
              P.bindFramebuffer.set(C.getFramebuffer("coords").framebuffer), P.viewport.set([0, 0, w.width / devicePixelRatio, w.height / devicePixelRatio]), P.clear({ color: o.be.transparent, depth: 1 }), C.coordsIndex = [];
              for (const Ae of Q) {
                const we = C.getTerrainMesh(Ae.tileID), Te = C.getTerrainData(Ae.tileID);
                P.activeTexture.set(L.TEXTURE0), L.bindTexture(L.TEXTURE_2D, G.texture);
                const Me = { u_terrain_coords_id: (255 - C.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: C.getMeshFrameDelta(F.zoom) }, Ve = F.getProjectionData({ overscaledTileID: Ae.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 });
                le.draw(P, L.TRIANGLES, X, Or.disabled, j, Wr.backCCW, Me, Te, Ve, "terrain", we.vertexBuffer, we.indexBuffer, we.segments), C.coordsIndex.push(Ae.tileID.key);
              }
              P.bindFramebuffer.set(null), P.viewport.set([0, 0, w.width, w.height]);
            }(this, this.style.map.terrain));
          }
          renderLayer(a, h, g, y, w) {
            g.isHidden(this.transform.zoom) || (g.type === "background" || g.type === "custom" || (y || []).length) && (this.id = g.id, o.ca(g) ? function(C, P, L, F, j, X) {
              if (C.renderPass !== "translucent") return;
              const { isRenderingToTexture: G } = X, Q = Or.disabled, le = C.colorModeForRenderPass();
              (L._unevaluatedLayout.hasValue("text-variable-anchor") || L._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(Ae, we, Te, Me, Ve, De, He, Ze, Fe) {
                const it = we.transform, bt = we.style.map.terrain, dt = Ve === "map", Tt = De === "map";
                for (const wt of Ae) {
                  const ir = Me.getTile(wt), or = ir.getBucket(Te);
                  if (!or || !or.text || !or.text.segments.get().length) continue;
                  const Vt = o.am(or.textSizeData, it.zoom), xr = o.aB(ir, 1, we.transform.zoom), an = tr(dt, we.transform, xr), An = Te.layout.get("icon-text-fit") !== "none" && or.hasIconData();
                  if (Vt) {
                    const ni = Math.pow(2, it.zoom - ir.tileID.overscaledZ), On = bt ? (kn, In) => bt.getElevation(wt, kn, In) : null;
                    Qh(or, dt, Tt, Fe, it, an, ni, Vt, An, o.aC(it, ir, He, Ze), wt.toUnwrapped(), On);
                  }
                }
              }(F, C, L, P, L.layout.get("text-rotation-alignment"), L.layout.get("text-pitch-alignment"), L.paint.get("text-translate"), L.paint.get("text-translate-anchor"), j), L.paint.get("icon-opacity").constantOr(1) !== 0 && ku(C, P, L, F, !1, L.paint.get("icon-translate"), L.paint.get("icon-translate-anchor"), L.layout.get("icon-rotation-alignment"), L.layout.get("icon-pitch-alignment"), L.layout.get("icon-keep-upright"), Q, le, G), L.paint.get("text-opacity").constantOr(1) !== 0 && ku(C, P, L, F, !0, L.paint.get("text-translate"), L.paint.get("text-translate-anchor"), L.layout.get("text-rotation-alignment"), L.layout.get("text-pitch-alignment"), L.layout.get("text-keep-upright"), Q, le, G), P.map.showCollisionBoxes && (Lu(C, P, L, F, !0), Lu(C, P, L, F, !1));
            }(a, h, g, y, this.style.placement.variableOffsets, w) : o.cb(g) ? function(C, P, L, F, j) {
              if (C.renderPass !== "translucent") return;
              const { isRenderingToTexture: X } = j, G = L.paint.get("circle-opacity"), Q = L.paint.get("circle-stroke-width"), le = L.paint.get("circle-stroke-opacity"), Ae = !L.layout.get("circle-sort-key").isConstant();
              if (G.constantOr(1) === 0 && (Q.constantOr(1) === 0 || le.constantOr(1) === 0)) return;
              const we = C.context, Te = we.gl, Me = C.transform, Ve = C.getDepthModeForSublayer(0, Yr.ReadOnly), De = Or.disabled, He = C.colorModeForRenderPass(), Ze = [], Fe = Me.getCircleRadiusCorrection();
              for (let it = 0; it < F.length; it++) {
                const bt = F[it], dt = P.getTile(bt), Tt = dt.getBucket(L);
                if (!Tt) continue;
                const wt = L.paint.get("circle-translate"), ir = L.paint.get("circle-translate-anchor"), or = o.aC(Me, dt, wt, ir), Vt = Tt.programConfigurations.get(L.id), xr = C.useProgram("circle", Vt), an = Tt.layoutVertexBuffer, An = Tt.indexBuffer, ni = C.style.map.terrain && C.style.map.terrain.getTerrainData(bt), On = { programConfiguration: Vt, program: xr, layoutVertexBuffer: an, indexBuffer: An, uniformValues: xi(C, dt, L, or, Fe), terrainData: ni, projectionData: Me.getProjectionData({ overscaledTileID: bt, applyGlobeMatrix: !X, applyTerrainMatrix: !0 }) };
                if (Ae) {
                  const kn = Tt.segments.get();
                  for (const In of kn) Ze.push({ segments: new o.aL([In]), sortKey: In.sortKey, state: On });
                } else Ze.push({ segments: Tt.segments, sortKey: 0, state: On });
              }
              Ae && Ze.sort((it, bt) => it.sortKey - bt.sortKey);
              for (const it of Ze) {
                const { programConfiguration: bt, program: dt, layoutVertexBuffer: Tt, indexBuffer: wt, uniformValues: ir, terrainData: or, projectionData: Vt } = it.state;
                dt.draw(we, Te.TRIANGLES, Ve, De, He, Wr.backCCW, ir, or, Vt, L.id, Tt, wt, it.segments, L.paint, C.transform.zoom, bt);
              }
            }(a, h, g, y, w) : o.cc(g) ? function(C, P, L, F, j) {
              if (L.paint.get("heatmap-opacity") === 0) return;
              const X = C.context, { isRenderingToTexture: G, isRenderingGlobe: Q } = j;
              if (C.style.map.terrain) {
                for (const le of F) {
                  const Ae = P.getTile(le);
                  P.hasRenderableParent(le) || (C.renderPass === "offscreen" ? hh(C, Ae, L, le, Q) : C.renderPass === "translucent" && fh(C, L, le, G, Q));
                }
                X.viewport.set([0, 0, C.width, C.height]);
              } else C.renderPass === "offscreen" ? function(le, Ae, we, Te) {
                const Me = le.context, Ve = Me.gl, De = le.transform, He = Or.disabled, Ze = new pn([Ve.ONE, Ve.ONE], o.be.transparent, [!0, !0, !0, !0]);
                (function(Fe, it, bt) {
                  const dt = Fe.gl;
                  Fe.activeTexture.set(dt.TEXTURE1), Fe.viewport.set([0, 0, it.width / 4, it.height / 4]);
                  let Tt = bt.heatmapFbos.get(o.c1);
                  Tt ? (dt.bindTexture(dt.TEXTURE_2D, Tt.colorAttachment.get()), Fe.bindFramebuffer.set(Tt.framebuffer)) : (Tt = Wc(Fe, it.width / 4, it.height / 4), bt.heatmapFbos.set(o.c1, Tt));
                })(Me, le, we), Me.clear({ color: o.be.transparent });
                for (let Fe = 0; Fe < Te.length; Fe++) {
                  const it = Te[Fe];
                  if (Ae.hasRenderableParent(it)) continue;
                  const bt = Ae.getTile(it), dt = bt.getBucket(we);
                  if (!dt) continue;
                  const Tt = dt.programConfigurations.get(we.id), wt = le.useProgram("heatmap", Tt), ir = De.getProjectionData({ overscaledTileID: it, applyGlobeMatrix: !0, applyTerrainMatrix: !1 }), or = De.getCircleRadiusCorrection();
                  wt.draw(Me, Ve.TRIANGLES, Yr.disabled, He, Ze, Wr.backCCW, Gs(bt, De.zoom, we.paint.get("heatmap-intensity"), or), null, ir, we.id, dt.layoutVertexBuffer, dt.indexBuffer, dt.segments, we.paint, De.zoom, Tt);
                }
                Me.viewport.set([0, 0, le.width, le.height]);
              }(C, P, L, F) : C.renderPass === "translucent" && function(le, Ae) {
                const we = le.context, Te = we.gl;
                we.setColorMode(le.colorModeForRenderPass());
                const Me = Ae.heatmapFbos.get(o.c1);
                Me && (we.activeTexture.set(Te.TEXTURE0), Te.bindTexture(Te.TEXTURE_2D, Me.colorAttachment.get()), we.activeTexture.set(Te.TEXTURE1), dh(we, Ae).bind(Te.LINEAR, Te.CLAMP_TO_EDGE), le.useProgram("heatmapTexture").draw(we, Te.TRIANGLES, Yr.disabled, Or.disabled, le.colorModeForRenderPass(), Wr.disabled, Ao(le, Ae, 0, 1), null, null, Ae.id, le.viewportBuffer, le.quadTriangleIndexBuffer, le.viewportSegments, Ae.paint, le.transform.zoom));
              }(C, L);
            }(a, h, g, y, w) : o.cd(g) ? function(C, P, L, F, j) {
              if (C.renderPass !== "translucent") return;
              const { isRenderingToTexture: X } = j, G = L.paint.get("line-opacity"), Q = L.paint.get("line-width");
              if (G.constantOr(1) === 0 || Q.constantOr(1) === 0) return;
              const le = C.getDepthModeForSublayer(0, Yr.ReadOnly), Ae = C.colorModeForRenderPass(), we = L.paint.get("line-dasharray"), Te = L.paint.get("line-pattern"), Me = Te.constantOr(1), Ve = L.paint.get("line-gradient"), De = L.getCrossfadeParameters(), He = Me ? "linePattern" : we ? "lineSDF" : Ve ? "lineGradient" : "line", Ze = C.context, Fe = Ze.gl, it = C.transform;
              let bt = !0;
              for (const dt of F) {
                const Tt = P.getTile(dt);
                if (Me && !Tt.patternsLoaded()) continue;
                const wt = Tt.getBucket(L);
                if (!wt) continue;
                const ir = wt.programConfigurations.get(L.id), or = C.context.program.get(), Vt = C.useProgram(He, ir), xr = bt || Vt.program !== or, an = C.style.map.terrain && C.style.map.terrain.getTerrainData(dt), An = Te.constantOr(null);
                if (An && Tt.imageAtlas) {
                  const En = Tt.imageAtlas, Nn = En.patternPositions[An.to.toString()], Ji = En.patternPositions[An.from.toString()];
                  Nn && Ji && ir.setConstantPatternPositions(Nn, Ji);
                }
                const ni = it.getProjectionData({ overscaledTileID: dt, applyGlobeMatrix: !X, applyTerrainMatrix: !0 }), On = it.getPixelScale(), kn = Me ? Vc(C, Tt, L, On, De) : we ? Zl(C, Tt, L, On, we, De) : Ve ? Xl(C, Tt, L, On, wt.lineClipsArray.length) : Ka(C, Tt, L, On);
                if (Me) Ze.activeTexture.set(Fe.TEXTURE0), Tt.imageAtlasTexture.bind(Fe.LINEAR, Fe.CLAMP_TO_EDGE), ir.updatePaintBuffers(De);
                else if (we && (xr || C.lineAtlas.dirty)) Ze.activeTexture.set(Fe.TEXTURE0), C.lineAtlas.bind(Ze);
                else if (Ve) {
                  const En = wt.gradients[L.id];
                  let Nn = En.texture;
                  if (L.gradientVersion !== En.version) {
                    let Ji = 256;
                    if (L.stepInterpolant) {
                      const yn = P.getSource().maxzoom, as = dt.canonical.z === yn ? Math.ceil(1 << C.transform.maxZoom - dt.canonical.z) : 1;
                      Ji = o.ag(o.c2(wt.maxLineLength / o.$ * 1024 * as), 256, Ze.maxTextureSize);
                    }
                    En.gradient = o.c3({ expression: L.gradientExpression(), evaluationKey: "lineProgress", resolution: Ji, image: En.gradient || void 0, clips: wt.lineClipsArray }), En.texture ? En.texture.update(En.gradient) : En.texture = new o.T(Ze, En.gradient, Fe.RGBA), En.version = L.gradientVersion, Nn = En.texture;
                  }
                  Ze.activeTexture.set(Fe.TEXTURE0), Nn.bind(L.stepInterpolant ? Fe.NEAREST : Fe.LINEAR, Fe.CLAMP_TO_EDGE);
                }
                const In = C.stencilModeForClipping(dt);
                Vt.draw(Ze, Fe.TRIANGLES, le, In, Ae, Wr.disabled, kn, an, ni, L.id, wt.layoutVertexBuffer, wt.indexBuffer, wt.segments, L.paint, C.transform.zoom, ir, wt.layoutVertexBuffer2), bt = !1;
              }
            }(a, h, g, y, w) : o.ce(g) ? function(C, P, L, F, j) {
              const X = L.paint.get("fill-color"), G = L.paint.get("fill-opacity");
              if (G.constantOr(1) === 0) return;
              const { isRenderingToTexture: Q } = j, le = C.colorModeForRenderPass(), Ae = L.paint.get("fill-pattern"), we = C.opaquePassEnabledForLayer() && !Ae.constantOr(1) && X.constantOr(o.be.transparent).a === 1 && G.constantOr(0) === 1 ? "opaque" : "translucent";
              if (C.renderPass === we) {
                const Te = C.getDepthModeForSublayer(1, C.renderPass === "opaque" ? Yr.ReadWrite : Yr.ReadOnly);
                Nu(C, P, L, F, Te, le, !1, Q);
              }
              if (C.renderPass === "translucent" && L.paint.get("fill-antialias")) {
                const Te = C.getDepthModeForSublayer(L.getPaintProperty("fill-outline-color") ? 2 : 0, Yr.ReadOnly);
                Nu(C, P, L, F, Te, le, !0, Q);
              }
            }(a, h, g, y, w) : o.cf(g) ? function(C, P, L, F, j) {
              const X = L.paint.get("fill-extrusion-opacity");
              if (X === 0) return;
              const { isRenderingToTexture: G } = j;
              if (C.renderPass === "translucent") {
                const Q = new Yr(C.context.gl.LEQUAL, Yr.ReadWrite, C.depthRangeFor3D);
                if (X !== 1 || L.paint.get("fill-extrusion-pattern").constantOr(1)) Xc(C, P, L, F, Q, Or.disabled, pn.disabled, G), Xc(C, P, L, F, Q, C.stencilModeFor3D(), C.colorModeForRenderPass(), G);
                else {
                  const le = C.colorModeForRenderPass();
                  Xc(C, P, L, F, Q, Or.disabled, le, G);
                }
              }
            }(a, h, g, y, w) : o.cg(g) ? function(C, P, L, F, j) {
              if (C.renderPass !== "offscreen" && C.renderPass !== "translucent") return;
              const { isRenderingToTexture: X } = j, G = C.context, Q = C.style.projection.useSubdivision, le = C.getDepthModeForSublayer(0, Yr.ReadOnly), Ae = C.colorModeForRenderPass();
              if (C.renderPass === "offscreen") (function(we, Te, Me, Ve, De, He, Ze) {
                const Fe = we.context, it = Fe.gl;
                for (const bt of Me) {
                  const dt = Te.getTile(bt), Tt = dt.dem;
                  if (!Tt || !Tt.data || !dt.needsHillshadePrepare) continue;
                  const wt = Tt.dim, ir = Tt.stride, or = Tt.getPixels();
                  if (Fe.activeTexture.set(it.TEXTURE1), Fe.pixelStoreUnpackPremultiplyAlpha.set(!1), dt.demTexture = dt.demTexture || we.getTileTexture(ir), dt.demTexture) {
                    const xr = dt.demTexture;
                    xr.update(or, { premultiply: !1 }), xr.bind(it.NEAREST, it.CLAMP_TO_EDGE);
                  } else dt.demTexture = new o.T(Fe, or, it.RGBA, { premultiply: !1 }), dt.demTexture.bind(it.NEAREST, it.CLAMP_TO_EDGE);
                  Fe.activeTexture.set(it.TEXTURE0);
                  let Vt = dt.fbo;
                  if (!Vt) {
                    const xr = new o.T(Fe, { width: wt, height: wt, data: null }, it.RGBA);
                    xr.bind(it.LINEAR, it.CLAMP_TO_EDGE), Vt = dt.fbo = Fe.createFramebuffer(wt, wt, !0, !1), Vt.colorAttachment.set(xr.texture);
                  }
                  Fe.bindFramebuffer.set(Vt.framebuffer), Fe.viewport.set([0, 0, wt, wt]), we.useProgram("hillshadePrepare").draw(Fe, it.TRIANGLES, De, He, Ze, Wr.disabled, oh(dt.tileID, Tt), null, null, Ve.id, we.rasterBoundsBuffer, we.quadTriangleIndexBuffer, we.rasterBoundsSegments), dt.needsHillshadePrepare = !1;
                }
              })(C, P, F, L, le, Or.disabled, Ae), G.viewport.set([0, 0, C.width, C.height]);
              else if (C.renderPass === "translucent") if (Q) {
                const [we, Te, Me] = C.stencilConfigForOverlapTwoPass(F);
                Zc(C, P, L, Me, we, le, Ae, !1, X), Zc(C, P, L, Me, Te, le, Ae, !0, X);
              } else {
                const [we, Te] = C.getStencilConfigForOverlapAndUpdateStencilID(F);
                Zc(C, P, L, Te, we, le, Ae, !1, X);
              }
            }(a, h, g, y, w) : o.ch(g) ? function(C, P, L, F, j) {
              if (C.renderPass !== "translucent" || !F.length) return;
              const { isRenderingToTexture: X } = j, G = C.style.projection.useSubdivision, Q = C.getDepthModeForSublayer(0, Yr.ReadOnly), le = C.colorModeForRenderPass();
              if (G) {
                const [Ae, we, Te] = C.stencilConfigForOverlapTwoPass(F);
                nc(C, P, L, Te, Ae, Q, le, !1, X), nc(C, P, L, Te, we, Q, le, !0, X);
              } else {
                const [Ae, we] = C.getStencilConfigForOverlapAndUpdateStencilID(F);
                nc(C, P, L, we, Ae, Q, le, !1, X);
              }
            }(a, h, g, y, w) : o.ci(g) ? function(C, P, L, F, j) {
              if (C.renderPass !== "translucent" || L.paint.get("raster-opacity") === 0 || !F.length) return;
              const { isRenderingToTexture: X } = j, G = P.getSource(), Q = C.style.projection.useSubdivision;
              if (G instanceof Yt) Do(C, P, L, F, null, !1, !1, G.tileCoords, G.flippedWindingOrder, X);
              else if (Q) {
                const [le, Ae, we] = C.stencilConfigForOverlapTwoPass(F);
                Do(C, P, L, we, le, !1, !0, Du, !1, X), Do(C, P, L, we, Ae, !0, !0, Du, !1, X);
              } else {
                const [le, Ae] = C.getStencilConfigForOverlapAndUpdateStencilID(F);
                Do(C, P, L, Ae, le, !1, !0, Du, !1, X);
              }
            }(a, h, g, y, w) : o.cj(g) ? function(C, P, L, F, j) {
              const X = L.paint.get("background-color"), G = L.paint.get("background-opacity");
              if (G === 0) return;
              const { isRenderingToTexture: Q } = j, le = C.context, Ae = le.gl, we = C.style.projection, Te = C.transform, Me = Te.tileSize, Ve = L.paint.get("background-pattern");
              if (C.isPatternMissing(Ve)) return;
              const De = !Ve && X.a === 1 && G === 1 && C.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (C.renderPass !== De) return;
              const He = Or.disabled, Ze = C.getDepthModeForSublayer(0, De === "opaque" ? Yr.ReadWrite : Yr.ReadOnly), Fe = C.colorModeForRenderPass(), it = C.useProgram(Ve ? "backgroundPattern" : "background"), bt = F || Pt(Te, { tileSize: Me, terrain: C.style.map.terrain });
              Ve && (le.activeTexture.set(Ae.TEXTURE0), C.imageManager.bind(C.context));
              const dt = L.getCrossfadeParameters();
              for (const Tt of bt) {
                const wt = Te.getProjectionData({ overscaledTileID: Tt, applyGlobeMatrix: !Q, applyTerrainMatrix: !0 }), ir = Ve ? ah(G, C, Ve, { tileID: Tt, tileSize: Me }, dt) : El(G, X), or = C.style.map.terrain && C.style.map.terrain.getTerrainData(Tt), Vt = we.getMeshFromTileID(le, Tt.canonical, !1, !0, "raster");
                it.draw(le, Ae.TRIANGLES, Ze, He, Fe, Wr.backCCW, ir, or, wt, L.id, Vt.vertexBuffer, Vt.indexBuffer, Vt.segments);
              }
            }(a, 0, g, y, w) : o.ck(g) && function(C, P, L, F) {
              const { isRenderingGlobe: j } = F, X = C.context, G = L.implementation, Q = C.style.projection, le = C.transform, Ae = le.getProjectionDataForCustomLayer(j), we = { farZ: le.farZ, nearZ: le.nearZ, fov: le.fov * Math.PI / 180, modelViewProjectionMatrix: le.modelViewProjectionMatrix, projectionMatrix: le.projectionMatrix, shaderData: { variantName: Q.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${Q.shaderPreludeCode.vertexSource}`, define: Q.shaderDefine }, defaultProjectionData: Ae }, Te = G.renderingMode ? G.renderingMode : "2d";
              if (C.renderPass === "offscreen") {
                const Me = G.prerender;
                Me && (C.setCustomLayerDefaults(), X.setColorMode(C.colorModeForRenderPass()), Me.call(G, X.gl, we), X.setDirty(), C.setBaseState());
              } else if (C.renderPass === "translucent") {
                C.setCustomLayerDefaults(), X.setColorMode(C.colorModeForRenderPass()), X.setStencilMode(Or.disabled);
                const Me = Te === "3d" ? C.getDepthModeFor3D() : C.getDepthModeForSublayer(0, Yr.ReadOnly);
                X.setDepthMode(Me), G.render(X.gl, we), X.setDirty(), C.setBaseState(), X.bindFramebuffer.set(null);
              }
            }(a, 0, g, w));
          }
          saveTileTexture(a) {
            const h = this._tileTextures[a.size[0]];
            h ? h.push(a) : this._tileTextures[a.size[0]] = [a];
          }
          getTileTexture(a) {
            const h = this._tileTextures[a];
            return h && h.length > 0 ? h.pop() : null;
          }
          isPatternMissing(a) {
            if (!a) return !1;
            if (!a.from || !a.to) return !0;
            const h = this.imageManager.getPattern(a.from.toString()), g = this.imageManager.getPattern(a.to.toString());
            return !h || !g;
          }
          useProgram(a, h) {
            let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, y = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
            this.cache = this.cache || {};
            const w = !!this.style.map.terrain, C = this.style.projection, P = g ? oo.projectionMercator : C.shaderPreludeCode, L = g ? $s : C.shaderDefine, F = a + (h ? h.cacheKey : "") + `/${g ? bl : C.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (w ? "/terrain" : "") + (y ? `/${y.join("/")}` : "");
            return this.cache[F] || (this.cache[F] = new Jt(this.context, oo[a], h, Jl[a], this._showOverdrawInspector, w, P, L, y)), this.cache[F];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const a = this.context.gl;
            this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(a.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new o.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy();
          }
          overLimit() {
            const { drawingBufferWidth: a, drawingBufferHeight: h } = this.context.gl;
            return this.width !== a || this.height !== h;
          }
        }
        function Xs(v, a) {
          var h = this;
          let g, y = !1, w = null, C = null;
          const P = () => {
            w = null, y && (v.apply(C, g), w = setTimeout(P, a), y = !1);
          };
          return function() {
            for (var L = arguments.length, F = new Array(L), j = 0; j < L; j++)
              F[j] = arguments[j];
            return y = !0, C = h, g = F, w || P(), w;
          };
        }
        class zu {
          constructor(a) {
            this._getCurrentHash = () => {
              const h = window.location.hash.replace("#", "");
              if (this._hashName) {
                let g;
                return h.split("&").map((y) => y.split("=")).forEach((y) => {
                  y[0] === this._hashName && (g = y);
                }), (g && g[1] || "").split("/");
              }
              return h.split("/");
            }, this._onHashChange = () => {
              const h = this._getCurrentHash();
              if (!this._isValidHash(h)) return !1;
              const g = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(h[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+h[2], +h[1]], zoom: +h[0], bearing: g, pitch: +(h[4] || 0) }), !0;
            }, this._updateHashUnthrottled = () => {
              const h = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, h);
            }, this._removeHash = () => {
              const h = this._getCurrentHash();
              if (h.length === 0) return;
              const g = h.join("/");
              let y = g;
              y.split("&").length > 0 && (y = y.split("&")[0]), this._hashName && (y = `${this._hashName}=${g}`);
              let w = window.location.hash.replace(y, "");
              w.startsWith("#&") ? w = w.slice(0, 1) + w.slice(2) : w === "#" && (w = "");
              let C = window.location.href.replace(/(#.+)?$/, w);
              C = C.replace("&&", "&"), window.history.replaceState(window.history.state, null, C);
            }, this._updateHash = Xs(this._updateHashUnthrottled, 300), this._hashName = a && encodeURIComponent(a);
          }
          addTo(a) {
            return this._map = a, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
          }
          getHashString(a) {
            const h = this._map.getCenter(), g = Math.round(100 * this._map.getZoom()) / 100, y = Math.ceil((g * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), w = Math.pow(10, y), C = Math.round(h.lng * w) / w, P = Math.round(h.lat * w) / w, L = this._map.getBearing(), F = this._map.getPitch();
            let j = "";
            if (j += a ? `/${C}/${P}/${g}` : `${g}/${P}/${C}`, (L || F) && (j += "/" + Math.round(10 * L) / 10), F && (j += `/${Math.round(F)}`), this._hashName) {
              const X = this._hashName;
              let G = !1;
              const Q = window.location.hash.slice(1).split("&").map((le) => {
                const Ae = le.split("=")[0];
                return Ae === X ? (G = !0, `${Ae}=${j}`) : le;
              }).filter((le) => le);
              return G || Q.push(`${X}=${j}`), `#${Q.join("&")}`;
            }
            return `#${j}`;
          }
          _isValidHash(a) {
            if (a.length < 3 || a.some(isNaN)) return !1;
            try {
              new o.S(+a[2], +a[1]);
            } catch {
              return !1;
            }
            const h = +a[0], g = +(a[3] || 0), y = +(a[4] || 0);
            return h >= this._map.getMinZoom() && h <= this._map.getMaxZoom() && g >= -180 && g <= 180 && y >= this._map.getMinPitch() && y <= this._map.getMaxPitch();
          }
        }
        const Yc = { linearity: 0.3, easing: o.cl(0, 0, 0.3, 1) }, ic = o.e({ deceleration: 2500, maxSpeed: 1400 }, Yc), ph = o.e({ deceleration: 20, maxSpeed: 1400 }, Yc), Kc = o.e({ deceleration: 1e3, maxSpeed: 360 }, Yc), gh = o.e({ deceleration: 1e3, maxSpeed: 90 }, Yc), rd = o.e({ deceleration: 1e3, maxSpeed: 360 }, Yc);
        class ju {
          constructor(a) {
            this._map = a, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(a) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: M.now(), settings: a });
          }
          _drainInertiaBuffer() {
            const a = this._inertiaBuffer, h = M.now();
            for (; a.length > 0 && h - a[0].time > 160; ) a.shift();
          }
          _onMoveEnd(a) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const h = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new o.P(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: w } of this._inertiaBuffer) h.zoom += w.zoomDelta || 0, h.bearing += w.bearingDelta || 0, h.pitch += w.pitchDelta || 0, h.roll += w.rollDelta || 0, w.panDelta && h.pan._add(w.panDelta), w.around && (h.around = w.around), w.pinchAround && (h.pinchAround = w.pinchAround);
            const g = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, y = {};
            if (h.pan.mag()) {
              const w = Oa(h.pan.mag(), g, o.e({}, ic, a || {})), C = h.pan.mult(w.amount / h.pan.mag()), P = this._map.cameraHelper.handlePanInertia(C, this._map.transform);
              y.center = P.easingCenter, y.offset = P.easingOffset, il(y, w);
            }
            if (h.zoom) {
              const w = Oa(h.zoom, g, ph);
              y.zoom = this._map.transform.zoom + w.amount, il(y, w);
            }
            if (h.bearing) {
              const w = Oa(h.bearing, g, Kc);
              y.bearing = this._map.transform.bearing + o.ag(w.amount, -179, 179), il(y, w);
            }
            if (h.pitch) {
              const w = Oa(h.pitch, g, gh);
              y.pitch = this._map.transform.pitch + w.amount, il(y, w);
            }
            if (h.roll) {
              const w = Oa(h.roll, g, rd);
              y.roll = this._map.transform.roll + o.ag(w.amount, -179, 179), il(y, w);
            }
            if (y.zoom || y.bearing) {
              const w = h.pinchAround === void 0 ? h.around : h.pinchAround;
              y.around = w ? this._map.unproject(w) : this._map.getCenter();
            }
            return this.clear(), o.e(y, { noMoveStart: !0 });
          }
        }
        function il(v, a) {
          (!v.duration || v.duration < a.duration) && (v.duration = a.duration, v.easing = a.easing);
        }
        function Oa(v, a, h) {
          const { maxSpeed: g, linearity: y, deceleration: w } = h, C = o.ag(v * y / (a / 1e3), -g, g), P = Math.abs(C) / (w * y);
          return { easing: h.easing, duration: 1e3 * P, amount: C * (P / 2) };
        }
        class Bs extends o.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(a, h, g) {
            let y = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            g = g instanceof MouseEvent ? g : new MouseEvent(a, g);
            const w = E.mousePos(h.getCanvas(), g), C = h.unproject(w);
            super(a, o.e({ point: w, lngLat: C, originalEvent: g }, y)), this._defaultPrevented = !1, this.target = h;
          }
        }
        class da extends o.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(a, h, g) {
            const y = a === "touchend" ? g.changedTouches : g.touches, w = E.touchPos(h.getCanvasContainer(), y), C = w.map((L) => h.unproject(L)), P = w.reduce((L, F, j, X) => L.add(F.div(X.length)), new o.P(0, 0));
            super(a, { points: w, point: P, lngLats: C, lngLat: h.unproject(P), originalEvent: g }), this._defaultPrevented = !1;
          }
        }
        class mh extends o.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(a, h, g) {
            super(a, { originalEvent: g }), this._defaultPrevented = !1;
          }
        }
        class nd {
          constructor(a, h) {
            this._map = a, this._clickTolerance = h.clickTolerance;
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(a) {
            return this._firePreventable(new mh(a.type, this._map, a));
          }
          mousedown(a, h) {
            return this._mousedownPos = h, this._firePreventable(new Bs(a.type, this._map, a));
          }
          mouseup(a) {
            this._map.fire(new Bs(a.type, this._map, a));
          }
          click(a, h) {
            this._mousedownPos && this._mousedownPos.dist(h) >= this._clickTolerance || this._map.fire(new Bs(a.type, this._map, a));
          }
          dblclick(a) {
            return this._firePreventable(new Bs(a.type, this._map, a));
          }
          mouseover(a) {
            this._map.fire(new Bs(a.type, this._map, a));
          }
          mouseout(a) {
            this._map.fire(new Bs(a.type, this._map, a));
          }
          touchstart(a) {
            return this._firePreventable(new da(a.type, this._map, a));
          }
          touchmove(a) {
            this._map.fire(new da(a.type, this._map, a));
          }
          touchend(a) {
            this._map.fire(new da(a.type, this._map, a));
          }
          touchcancel(a) {
            this._map.fire(new da(a.type, this._map, a));
          }
          _firePreventable(a) {
            if (this._map.fire(a), a.defaultPrevented) return {};
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {
          }
          disable() {
          }
        }
        class id {
          constructor(a) {
            this._map = a;
          }
          reset() {
            this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
          }
          mousemove(a) {
            this._map.fire(new Bs(a.type, this._map, a));
          }
          mousedown() {
            this._delayContextMenu = !0, this._ignoreContextMenu = !1;
          }
          mouseup() {
            this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Bs("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(a) {
            this._delayContextMenu ? this._contextMenuEvent = a : this._ignoreContextMenu || this._map.fire(new Bs(a.type, this._map, a)), this._map.listens("contextmenu") && a.preventDefault();
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {
          }
          disable() {
          }
        }
        class Jc {
          constructor(a) {
            this._map = a;
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform;
          }
          get center() {
            return { lng: this.transform.center.lng, lat: this.transform.center.lat };
          }
          get zoom() {
            return this.transform.zoom;
          }
          get pitch() {
            return this.transform.pitch;
          }
          get bearing() {
            return this.transform.bearing;
          }
          unproject(a) {
            return this.transform.screenPointToLocation(o.P.convert(a), this._map.terrain);
          }
        }
        class rf {
          constructor(a, h) {
            this._map = a, this._tr = new Jc(a), this._el = a.getCanvasContainer(), this._container = a.getContainer(), this._clickTolerance = h.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = !0);
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          mousedown(a, h) {
            this.isEnabled() && a.shiftKey && a.button === 0 && (E.disableDrag(), this._startPos = this._lastPos = h, this._active = !0);
          }
          mousemoveWindow(a, h) {
            if (!this._active) return;
            const g = h;
            if (this._lastPos.equals(g) || !this._box && g.dist(this._startPos) < this._clickTolerance) return;
            const y = this._startPos;
            this._lastPos = g, this._box || (this._box = E.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", a));
            const w = Math.min(y.x, g.x), C = Math.max(y.x, g.x), P = Math.min(y.y, g.y), L = Math.max(y.y, g.y);
            E.setTransform(this._box, `translate(${w}px,${P}px)`), this._box.style.width = C - w + "px", this._box.style.height = L - P + "px";
          }
          mouseupWindow(a, h) {
            if (!this._active || a.button !== 0) return;
            const g = this._startPos, y = h;
            if (this.reset(), E.suppressClick(), g.x !== y.x || g.y !== y.y) return this._map.fire(new o.l("boxzoomend", { originalEvent: a })), { cameraAnimation: (w) => w.fitScreenCoordinates(g, y, this._tr.bearing, { linear: !0 }) };
            this._fireEvent("boxzoomcancel", a);
          }
          keydown(a) {
            this._active && a.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", a));
          }
          reset() {
            this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (E.remove(this._box), this._box = null), E.enableDrag(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(a, h) {
            return this._map.fire(new o.l(a, { originalEvent: h }));
          }
        }
        function _h(v, a) {
          if (v.length !== a.length) throw new Error(`The number of touches and points are not equal - touches ${v.length}, points ${a.length}`);
          const h = {};
          for (let g = 0; g < v.length; g++) h[v[g].identifier] = a[g];
          return h;
        }
        class sd {
          constructor(a) {
            this.reset(), this.numTouches = a.numTouches;
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
          }
          touchstart(a, h, g) {
            (this.centroid || g.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = a.timeStamp), g.length === this.numTouches && (this.centroid = function(y) {
              const w = new o.P(0, 0);
              for (const C of y) w._add(C);
              return w.div(y.length);
            }(h), this.touches = _h(g, h)));
          }
          touchmove(a, h, g) {
            if (this.aborted || !this.centroid) return;
            const y = _h(g, h);
            for (const w in this.touches) {
              const C = y[w];
              (!C || C.dist(this.touches[w]) > 30) && (this.aborted = !0);
            }
          }
          touchend(a, h, g) {
            if ((!this.centroid || a.timeStamp - this.startTime > 500) && (this.aborted = !0), g.length === 0) {
              const y = !this.aborted && this.centroid;
              if (this.reset(), y) return y;
            }
          }
        }
        class Vu {
          constructor(a) {
            this.singleTap = new sd(a), this.numTaps = a.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
          }
          touchstart(a, h, g) {
            this.singleTap.touchstart(a, h, g);
          }
          touchmove(a, h, g) {
            this.singleTap.touchmove(a, h, g);
          }
          touchend(a, h, g) {
            const y = this.singleTap.touchend(a, h, g);
            if (y) {
              const w = a.timeStamp - this.lastTime < 500, C = !this.lastTap || this.lastTap.dist(y) < 30;
              if (w && C || this.reset(), this.count++, this.lastTime = a.timeStamp, this.lastTap = y, this.count === this.numTaps) return this.reset(), y;
            }
          }
        }
        class sc {
          constructor(a) {
            this._tr = new Jc(a), this._zoomIn = new Vu({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Vu({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(a, h, g) {
            this._zoomIn.touchstart(a, h, g), this._zoomOut.touchstart(a, h, g);
          }
          touchmove(a, h, g) {
            this._zoomIn.touchmove(a, h, g), this._zoomOut.touchmove(a, h, g);
          }
          touchend(a, h, g) {
            const y = this._zoomIn.touchend(a, h, g), w = this._zoomOut.touchend(a, h, g), C = this._tr;
            return y ? (this._active = !0, a.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (P) => P.easeTo({ duration: 300, zoom: C.zoom + 1, around: C.unproject(y) }, { originalEvent: a }) }) : w ? (this._active = !0, a.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (P) => P.easeTo({ duration: 300, zoom: C.zoom - 1, around: C.unproject(w) }, { originalEvent: a }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Qc {
          constructor(a) {
            this._enabled = !!a.enable, this._moveStateManager = a.moveStateManager, this._clickTolerance = a.clickTolerance || 1, this._moveFunction = a.move, this._activateOnStart = !!a.activateOnStart, a.assignEvents(this), this.reset();
          }
          reset(a) {
            this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(a);
          }
          _move() {
            const a = this._moveFunction(...arguments);
            if (a.bearingDelta || a.pitchDelta || a.rollDelta || a.around || a.panDelta) return this._active = !0, a;
          }
          dragStart(a, h) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(a) && (this._moveStateManager.startMove(a), this._lastPoint = Array.isArray(h) ? h[0] : h, this._activateOnStart && this._lastPoint && (this._active = !0));
          }
          dragMove(a, h) {
            if (!this.isEnabled()) return;
            const g = this._lastPoint;
            if (!g) return;
            if (a.preventDefault(), !this._moveStateManager.isValidMoveEvent(a)) return void this.reset(a);
            const y = Array.isArray(h) ? h[0] : h;
            return !this._moved && y.dist(g) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = y, this._move(g, y));
          }
          dragEnd(a) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(a) && (this._moved && E.suppressClick(), this.reset(a));
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          getClickTolerance() {
            return this._clickTolerance;
          }
        }
        const Fo = 0, Uo = 2, S = { [Fo]: 1, [Uo]: 2 };
        class R {
          constructor(a) {
            this._correctEvent = a.checkCorrectEvent;
          }
          startMove(a) {
            const h = E.mouseButton(a);
            this._eventButton = h;
          }
          endMove(a) {
            delete this._eventButton;
          }
          isValidStartEvent(a) {
            return this._correctEvent(a);
          }
          isValidMoveEvent(a) {
            return !function(h, g) {
              const y = S[g];
              return h.buttons === void 0 || (h.buttons & y) !== y;
            }(a, this._eventButton);
          }
          isValidEndEvent(a) {
            return E.mouseButton(a) === this._eventButton;
          }
        }
        class D {
          constructor() {
            this._firstTouch = void 0;
          }
          _isOneFingerTouch(a) {
            return a.targetTouches.length === 1;
          }
          _isSameTouchEvent(a) {
            return a.targetTouches[0].identifier === this._firstTouch;
          }
          startMove(a) {
            this._firstTouch = a.targetTouches[0].identifier;
          }
          endMove(a) {
            delete this._firstTouch;
          }
          isValidStartEvent(a) {
            return this._isOneFingerTouch(a);
          }
          isValidMoveEvent(a) {
            return this._isOneFingerTouch(a) && this._isSameTouchEvent(a);
          }
          isValidEndEvent(a) {
            return this._isOneFingerTouch(a) && this._isSameTouchEvent(a);
          }
        }
        class W {
          constructor() {
            let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new R({ checkCorrectEvent: () => !0 }), h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new D();
            this.mouseMoveStateManager = a, this.oneFingerTouchMoveStateManager = h;
          }
          _executeRelevantHandler(a, h, g) {
            return a instanceof MouseEvent ? h(a) : typeof TouchEvent < "u" && a instanceof TouchEvent ? g(a) : void 0;
          }
          startMove(a) {
            this._executeRelevantHandler(a, (h) => this.mouseMoveStateManager.startMove(h), (h) => this.oneFingerTouchMoveStateManager.startMove(h));
          }
          endMove(a) {
            this._executeRelevantHandler(a, (h) => this.mouseMoveStateManager.endMove(h), (h) => this.oneFingerTouchMoveStateManager.endMove(h));
          }
          isValidStartEvent(a) {
            return this._executeRelevantHandler(a, (h) => this.mouseMoveStateManager.isValidStartEvent(h), (h) => this.oneFingerTouchMoveStateManager.isValidStartEvent(h));
          }
          isValidMoveEvent(a) {
            return this._executeRelevantHandler(a, (h) => this.mouseMoveStateManager.isValidMoveEvent(h), (h) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(h));
          }
          isValidEndEvent(a) {
            return this._executeRelevantHandler(a, (h) => this.mouseMoveStateManager.isValidEndEvent(h), (h) => this.oneFingerTouchMoveStateManager.isValidEndEvent(h));
          }
        }
        const se = (v) => {
          v.mousedown = v.dragStart, v.mousemoveWindow = v.dragMove, v.mouseup = v.dragEnd, v.contextmenu = (a) => {
            a.preventDefault();
          };
        };
        class de {
          constructor(a, h) {
            this._clickTolerance = a.clickTolerance || 1, this._map = h, this.reset();
          }
          reset() {
            this._active = !1, this._touches = {}, this._sum = new o.P(0, 0);
          }
          _shouldBePrevented(a) {
            return a < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
          }
          touchstart(a, h, g) {
            return this._calculateTransform(a, h, g);
          }
          touchmove(a, h, g) {
            if (this._active) {
              if (!this._shouldBePrevented(g.length)) return a.preventDefault(), this._calculateTransform(a, h, g);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", a);
            }
          }
          touchend(a, h, g) {
            this._calculateTransform(a, h, g), this._active && this._shouldBePrevented(g.length) && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(a, h, g) {
            g.length > 0 && (this._active = !0);
            const y = _h(g, h), w = new o.P(0, 0), C = new o.P(0, 0);
            let P = 0;
            for (const F in y) {
              const j = y[F], X = this._touches[F];
              X && (w._add(j), C._add(j.sub(X)), P++, y[F] = j);
            }
            if (this._touches = y, this._shouldBePrevented(P) || !C.mag()) return;
            const L = C.div(P);
            return this._sum._add(L), this._sum.mag() < this._clickTolerance ? void 0 : { around: w.div(P), panDelta: L };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class ge {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = !1, delete this._firstTwoTouches;
          }
          touchstart(a, h, g) {
            this._firstTwoTouches || g.length < 2 || (this._firstTwoTouches = [g[0].identifier, g[1].identifier], this._start([h[0], h[1]]));
          }
          touchmove(a, h, g) {
            if (!this._firstTwoTouches) return;
            a.preventDefault();
            const [y, w] = this._firstTwoTouches, C = _e(g, h, y), P = _e(g, h, w);
            if (!C || !P) return;
            const L = this._aroundCenter ? null : C.add(P).div(2);
            return this._move([C, P], L, a);
          }
          touchend(a, h, g) {
            if (!this._firstTwoTouches) return;
            const [y, w] = this._firstTwoTouches, C = _e(g, h, y), P = _e(g, h, w);
            C && P || (this._active && E.suppressClick(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(a) {
            this._enabled = !0, this._aroundCenter = !!a && a.around === "center";
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
        }
        function _e(v, a, h) {
          for (let g = 0; g < v.length; g++) if (v[g].identifier === h) return a[g];
        }
        function xe(v, a) {
          return Math.log(v / a) / Math.LN2;
        }
        class Ie extends ge {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance;
          }
          _start(a) {
            this._startDistance = this._distance = a[0].dist(a[1]);
          }
          _move(a, h) {
            const g = this._distance;
            if (this._distance = a[0].dist(a[1]), this._active || !(Math.abs(xe(this._distance, this._startDistance)) < 0.1)) return this._active = !0, { zoomDelta: xe(this._distance, g), pinchAround: h };
          }
        }
        function Re(v, a) {
          return 180 * v.angleWith(a) / Math.PI;
        }
        class At extends ge {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
          }
          _start(a) {
            this._startVector = this._vector = a[0].sub(a[1]), this._minDiameter = a[0].dist(a[1]);
          }
          _move(a, h, g) {
            const y = this._vector;
            if (this._vector = a[0].sub(a[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, { bearingDelta: Re(this._vector, y), pinchAround: h };
          }
          _isBelowThreshold(a) {
            this._minDiameter = Math.min(this._minDiameter, a.mag());
            const h = 25 / (Math.PI * this._minDiameter) * 360, g = Re(a, this._startVector);
            return Math.abs(g) < h;
          }
        }
        function vt(v) {
          return Math.abs(v.y) > Math.abs(v.x);
        }
        class at extends ge {
          constructor(a) {
            super(), this._currentTouchCount = 0, this._map = a;
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }
          touchstart(a, h, g) {
            super.touchstart(a, h, g), this._currentTouchCount = g.length;
          }
          _start(a) {
            this._lastPoints = a, vt(a[0].sub(a[1])) && (this._valid = !1);
          }
          _move(a, h, g) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const y = a[0].sub(this._lastPoints[0]), w = a[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(y, w, g.timeStamp), this._valid ? (this._lastPoints = a, this._active = !0, { pitchDelta: (y.y + w.y) / 2 * -0.5 }) : void 0;
          }
          gestureBeginsVertically(a, h, g) {
            if (this._valid !== void 0) return this._valid;
            const y = a.mag() >= 2, w = h.mag() >= 2;
            if (!y && !w) return;
            if (!y || !w) return this._firstMove === void 0 && (this._firstMove = g), g - this._firstMove < 100 && void 0;
            const C = a.y > 0 == h.y > 0;
            return vt(a) && vt(h) && C;
          }
        }
        const Gt = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class kt {
          constructor(a) {
            this._tr = new Jc(a);
            const h = Gt;
            this._panStep = h.panStep, this._bearingStep = h.bearingStep, this._pitchStep = h.pitchStep, this._rotationDisabled = !1;
          }
          reset() {
            this._active = !1;
          }
          keydown(a) {
            if (a.altKey || a.ctrlKey || a.metaKey) return;
            let h = 0, g = 0, y = 0, w = 0, C = 0;
            switch (a.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                h = 1;
                break;
              case 189:
              case 109:
              case 173:
                h = -1;
                break;
              case 37:
                a.shiftKey ? g = -1 : (a.preventDefault(), w = -1);
                break;
              case 39:
                a.shiftKey ? g = 1 : (a.preventDefault(), w = 1);
                break;
              case 38:
                a.shiftKey ? y = 1 : (a.preventDefault(), C = -1);
                break;
              case 40:
                a.shiftKey ? y = -1 : (a.preventDefault(), C = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (g = 0, y = 0), { cameraAnimation: (P) => {
              const L = this._tr;
              P.easeTo({ duration: 300, easeId: "keyboardHandler", easing: rt, zoom: h ? Math.round(L.zoom) + h * (a.shiftKey ? 2 : 1) : L.zoom, bearing: L.bearing + g * this._bearingStep, pitch: L.pitch + y * this._pitchStep, offset: [-w * this._panStep, -C * this._panStep], center: L.center }, { originalEvent: a });
            } };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = !0;
          }
          enableRotation() {
            this._rotationDisabled = !1;
          }
        }
        function rt(v) {
          return v * (2 - v);
        }
        const Xe = 4.000244140625, qt = 1 / 450;
        class Zt {
          constructor(a, h) {
            this._onTimeout = (g) => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(g);
            }, this._map = a, this._tr = new Jc(a), this._triggerRenderFrame = h, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = qt;
          }
          setZoomRate(a) {
            this._defaultZoomRate = a;
          }
          setWheelZoomRate(a) {
            this._wheelZoomRate = a;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(a) {
            this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!a && a.around === "center");
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          _shouldBePrevented(a) {
            return !!this._map.cooperativeGestures.isEnabled() && !(a.ctrlKey || this._map.cooperativeGestures.isBypassed(a));
          }
          wheel(a) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(a)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", a);
            let h = a.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * a.deltaY : a.deltaY;
            const g = M.now(), y = g - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = g, h !== 0 && h % Xe == 0 ? this._type = "wheel" : h !== 0 && Math.abs(h) < 4 ? this._type = "trackpad" : y > 400 ? (this._type = null, this._lastValue = h, this._timeout = setTimeout(this._onTimeout, 40, a)) : this._type || (this._type = Math.abs(y * h) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, h += this._lastValue)), a.shiftKey && h && (h /= 4), this._type && (this._lastWheelEvent = a, this._delta -= h, this._active || this._start(a)), a.preventDefault();
          }
          _start(a) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const h = E.mousePos(this._map.getCanvas(), a), g = this._tr;
            this._aroundPoint = this._aroundCenter ? g.transform.locationToScreenPoint(o.S.convert(g.center)) : h, this._frameId || (this._frameId = !0, this._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const a = this._tr.transform;
            if (typeof this._lastExpectedZoom == "number") {
              const P = a.zoom - this._lastExpectedZoom;
              typeof this._startZoom == "number" && (this._startZoom += P), typeof this._targetZoom == "number" && (this._targetZoom += P);
            }
            if (this._delta !== 0) {
              const P = this._type === "wheel" && Math.abs(this._delta) > Xe ? this._wheelZoomRate : this._defaultZoomRate;
              let L = 2 / (1 + Math.exp(-Math.abs(this._delta * P)));
              this._delta < 0 && L !== 0 && (L = 1 / L);
              const F = typeof this._targetZoom != "number" ? a.scale : o.ae(this._targetZoom);
              this._targetZoom = a.getConstrained(a.getCameraLngLat(), o.aj(F * L)).zoom, this._type === "wheel" && (this._startZoom = a.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            const h = typeof this._targetZoom != "number" ? a.zoom : this._targetZoom, g = this._startZoom, y = this._easing;
            let w, C = !1;
            if (this._type === "wheel" && g && y) {
              const P = M.now() - this._lastWheelEventTime, L = Math.min((P + 5) / 200, 1), F = y(L);
              w = o.C.number(g, h, F), L < 1 ? this._frameId || (this._frameId = !0) : C = !0;
            } else w = h, C = !0;
            return this._active = !0, C && (this._active = !1, this._finishTimeout = setTimeout(() => {
              this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
            }, 200)), this._lastExpectedZoom = w, { noInertia: !0, needsRenderFrame: !C, zoomDelta: w - a.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(a) {
            let h = o.cn;
            if (this._prevEase) {
              const g = this._prevEase, y = (M.now() - g.start) / g.duration, w = g.easing(y + 0.01) - g.easing(y), C = 0.27 / Math.sqrt(w * w + 1e-4) * 0.01, P = Math.sqrt(0.0729 - C * C);
              h = o.cl(C, P, 0.25, 1);
            }
            return this._prevEase = { start: M.now(), duration: a, easing: h }, h;
          }
          reset() {
            this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          }
        }
        class Ht {
          constructor(a, h) {
            this._clickZoom = a, this._tapZoom = h;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class Mr {
          constructor(a) {
            this._tr = new Jc(a), this.reset();
          }
          reset() {
            this._active = !1;
          }
          dblclick(a, h) {
            return a.preventDefault(), { cameraAnimation: (g) => {
              g.easeTo({ duration: 300, zoom: this._tr.zoom + (a.shiftKey ? -1 : 1), around: this._tr.unproject(h) }, { originalEvent: a });
            } };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class yr {
          constructor() {
            this._tap = new Vu({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
          }
          touchstart(a, h, g) {
            if (!this._swipePoint) if (this._tapTime) {
              const y = h[0], w = a.timeStamp - this._tapTime < 500, C = this._tapPoint.dist(y) < 30;
              w && C ? g.length > 0 && (this._swipePoint = y, this._swipeTouch = g[0].identifier) : this.reset();
            } else this._tap.touchstart(a, h, g);
          }
          touchmove(a, h, g) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (g[0].identifier !== this._swipeTouch) return;
                const y = h[0], w = y.y - this._swipePoint.y;
                return this._swipePoint = y, a.preventDefault(), this._active = !0, { zoomDelta: w / 128 };
              }
            } else this._tap.touchmove(a, h, g);
          }
          touchend(a, h, g) {
            if (this._tapTime) this._swipePoint && g.length === 0 && this.reset();
            else {
              const y = this._tap.touchend(a, h, g);
              y && (this._tapTime = a.timeStamp, this._tapPoint = y);
            }
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class $r {
          constructor(a, h, g) {
            this._el = a, this._mousePan = h, this._touchPan = g;
          }
          enable(a) {
            this._inertiaOptions = a || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class br {
          constructor(a, h, g, y) {
            this._pitchWithRotate = a.pitchWithRotate, this._rollEnabled = a.rollEnabled, this._mouseRotate = h, this._mousePitch = g, this._mouseRoll = y;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
          }
        }
        class Pn {
          constructor(a, h, g, y) {
            this._el = a, this._touchZoom = h, this._touchRotate = g, this._tapDragZoom = y, this._rotationDisabled = !1, this._enabled = !0;
          }
          enable(a) {
            this._touchZoom.enable(a), this._rotationDisabled || this._touchRotate.enable(a), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = !0, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        class Fn {
          constructor(a, h) {
            this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = a, this._options = h, this._enabled = !1;
          }
          isActive() {
            return !1;
          }
          reset() {
          }
          _setupUI() {
            if (this._container) return;
            const a = this._map.getCanvasContainer();
            a.classList.add("maplibregl-cooperative-gestures"), this._container = E.create("div", "maplibregl-cooperative-gesture-screen", a);
            let h = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            this._bypassKey === "metaKey" && (h = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const g = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), y = document.createElement("div");
            y.className = "maplibregl-desktop-message", y.textContent = h, this._container.appendChild(y);
            const w = document.createElement("div");
            w.className = "maplibregl-mobile-message", w.textContent = g, this._container.appendChild(w), this._container.setAttribute("aria-hidden", "true");
          }
          _destroyUI() {
            this._container && (E.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
          }
          enable() {
            this._setupUI(), this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this._destroyUI();
          }
          isEnabled() {
            return this._enabled;
          }
          isBypassed(a) {
            return a[this._bypassKey];
          }
          notifyGestureBlocked(a, h) {
            this._enabled && (this._map.fire(new o.l("cooperativegestureprevented", { gestureType: a, originalEvent: h })), this._container.classList.add("maplibregl-show"), setTimeout(() => {
              this._container.classList.remove("maplibregl-show");
            }, 100));
          }
        }
        const wn = (v) => v.zoom || v.drag || v.roll || v.pitch || v.rotate;
        class Sn extends o.l {
        }
        function Vn(v) {
          return v.panDelta && v.panDelta.mag() || v.zoomDelta || v.bearingDelta || v.pitchDelta || v.rollDelta;
        }
        class Cn {
          constructor(a, h) {
            this.handleWindowEvent = (y) => {
              this.handleEvent(y, `${y.type}Window`);
            }, this.handleEvent = (y, w) => {
              if (y.type === "blur") return void this.stop(!0);
              this._updatingCamera = !0;
              const C = y.type === "renderFrame" ? void 0 : y, P = { needsRenderFrame: !1 }, L = {}, F = {};
              for (const { handlerName: G, handler: Q, allowed: le } of this._handlers) {
                if (!Q.isEnabled()) continue;
                let Ae;
                if (this._blockedByActive(F, le, G)) Q.reset();
                else if (Q[w || y.type]) {
                  if (o.co(y, w || y.type)) {
                    const we = E.mousePos(this._map.getCanvas(), y);
                    Ae = Q[w || y.type](y, we);
                  } else if (o.cp(y, w || y.type)) {
                    const we = this._getMapTouches(y.touches), Te = E.touchPos(this._map.getCanvas(), we);
                    Ae = Q[w || y.type](y, Te, we);
                  } else o.cq(w || y.type) || (Ae = Q[w || y.type](y));
                  this.mergeHandlerResult(P, L, Ae, G, C), Ae && Ae.needsRenderFrame && this._triggerRenderFrame();
                }
                (Ae || Q.isActive()) && (F[G] = Q);
              }
              const j = {};
              for (const G in this._previousActiveHandlers) F[G] || (j[G] = C);
              this._previousActiveHandlers = F, (Object.keys(j).length || Vn(P)) && (this._changes.push([P, L, j]), this._triggerRenderFrame()), (Object.keys(F).length || Vn(P)) && this._map._stop(!0), this._updatingCamera = !1;
              const { cameraAnimation: X } = P;
              X && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], X(this._map));
            }, this._map = a, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new ju(a), this._bearingSnap = h.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(h);
            const g = this._el;
            this._listeners = [[g, "touchstart", { passive: !0 }], [g, "touchmove", { passive: !1 }], [g, "touchend", void 0], [g, "touchcancel", void 0], [g, "mousedown", void 0], [g, "mousemove", void 0], [g, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [g, "mouseover", void 0], [g, "mouseout", void 0], [g, "dblclick", void 0], [g, "click", void 0], [g, "keydown", { capture: !1 }], [g, "keyup", void 0], [g, "wheel", { passive: !1 }], [g, "contextmenu", void 0], [window, "blur", void 0]];
            for (const [y, w, C] of this._listeners) E.addEventListener(y, w, y === document ? this.handleWindowEvent : this.handleEvent, C);
          }
          destroy() {
            for (const [a, h, g] of this._listeners) E.removeEventListener(a, h, a === document ? this.handleWindowEvent : this.handleEvent, g);
          }
          _addDefaultHandlers(a) {
            const h = this._map, g = h.getCanvasContainer();
            this._add("mapEvent", new nd(h, a));
            const y = h.boxZoom = new rf(h, a);
            this._add("boxZoom", y), a.interactive && a.boxZoom && y.enable();
            const w = h.cooperativeGestures = new Fn(h, a.cooperativeGestures);
            this._add("cooperativeGestures", w), a.cooperativeGestures && w.enable();
            const C = new sc(h), P = new Mr(h);
            h.doubleClickZoom = new Ht(P, C), this._add("tapZoom", C), this._add("clickZoom", P), a.interactive && a.doubleClickZoom && h.doubleClickZoom.enable();
            const L = new yr();
            this._add("tapDragZoom", L);
            const F = h.touchPitch = new at(h);
            this._add("touchPitch", F), a.interactive && a.touchPitch && h.touchPitch.enable(a.touchPitch);
            const j = () => h.project(h.getCenter()), X = function(De, He) {
              let { enable: Ze, clickTolerance: Fe, aroundCenter: it = !0, minPixelCenterThreshold: bt = 100, rotateDegreesPerPixelMoved: dt = 0.8 } = De;
              const Tt = new R({ checkCorrectEvent: (wt) => E.mouseButton(wt) === 0 && wt.ctrlKey || E.mouseButton(wt) === 2 && !wt.ctrlKey });
              return new Qc({ clickTolerance: Fe, move: (wt, ir) => {
                const or = He();
                if (it && Math.abs(or.y - wt.y) > bt) return { bearingDelta: o.cm(new o.P(wt.x, ir.y), ir, or) };
                let Vt = (ir.x - wt.x) * dt;
                return it && ir.y < or.y && (Vt = -Vt), { bearingDelta: Vt };
              }, moveStateManager: Tt, enable: Ze, assignEvents: se });
            }(a, j), G = function(De) {
              let { enable: He, clickTolerance: Ze, pitchDegreesPerPixelMoved: Fe = -0.5 } = De;
              const it = new R({ checkCorrectEvent: (bt) => E.mouseButton(bt) === 0 && bt.ctrlKey || E.mouseButton(bt) === 2 });
              return new Qc({ clickTolerance: Ze, move: (bt, dt) => ({ pitchDelta: (dt.y - bt.y) * Fe }), moveStateManager: it, enable: He, assignEvents: se });
            }(a), Q = function(De, He) {
              let { enable: Ze, clickTolerance: Fe, rollDegreesPerPixelMoved: it = 0.3 } = De;
              const bt = new R({ checkCorrectEvent: (dt) => E.mouseButton(dt) === 2 && dt.ctrlKey });
              return new Qc({ clickTolerance: Fe, move: (dt, Tt) => {
                const wt = He();
                let ir = (Tt.x - dt.x) * it;
                return Tt.y < wt.y && (ir = -ir), { rollDelta: ir };
              }, moveStateManager: bt, enable: Ze, assignEvents: se });
            }(a, j);
            h.dragRotate = new br(a, X, G, Q), this._add("mouseRotate", X, ["mousePitch"]), this._add("mousePitch", G, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", Q, ["mousePitch"]), a.interactive && a.dragRotate && h.dragRotate.enable();
            const le = function(De) {
              let { enable: He, clickTolerance: Ze } = De;
              const Fe = new R({ checkCorrectEvent: (it) => E.mouseButton(it) === 0 && !it.ctrlKey });
              return new Qc({ clickTolerance: Ze, move: (it, bt) => ({ around: bt, panDelta: bt.sub(it) }), activateOnStart: !0, moveStateManager: Fe, enable: He, assignEvents: se });
            }(a), Ae = new de(a, h);
            h.dragPan = new $r(g, le, Ae), this._add("mousePan", le), this._add("touchPan", Ae, ["touchZoom", "touchRotate"]), a.interactive && a.dragPan && h.dragPan.enable(a.dragPan);
            const we = new At(), Te = new Ie();
            h.touchZoomRotate = new Pn(g, Te, we, L), this._add("touchRotate", we, ["touchPan", "touchZoom"]), this._add("touchZoom", Te, ["touchPan", "touchRotate"]), a.interactive && a.touchZoomRotate && h.touchZoomRotate.enable(a.touchZoomRotate);
            const Me = h.scrollZoom = new Zt(h, () => this._triggerRenderFrame());
            this._add("scrollZoom", Me, ["mousePan"]), a.interactive && a.scrollZoom && h.scrollZoom.enable(a.scrollZoom);
            const Ve = h.keyboard = new kt(h);
            this._add("keyboard", Ve), a.interactive && a.keyboard && h.keyboard.enable(), this._add("blockableMapEvent", new id(h));
          }
          _add(a, h, g) {
            this._handlers.push({ handlerName: a, handler: h, allowed: g }), this._handlersById[a] = h;
          }
          stop(a) {
            if (!this._updatingCamera) {
              for (const { handler: h } of this._handlers) h.reset();
              this._inertia.clear(), this._fireEvents({}, {}, a), this._changes = [];
            }
          }
          isActive() {
            for (const { handler: a } of this._handlers) if (a.isActive()) return !0;
            return !1;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return !!wn(this._eventsInProgress) || this.isZooming();
          }
          _blockedByActive(a, h, g) {
            for (const y in a) if (y !== g && (!h || h.indexOf(y) < 0)) return !0;
            return !1;
          }
          _getMapTouches(a) {
            const h = [];
            for (const g of a) this._el.contains(g.target) && h.push(g);
            return h;
          }
          mergeHandlerResult(a, h, g, y, w) {
            if (!g) return;
            o.e(a, g);
            const C = { handlerName: y, originalEvent: g.originalEvent || w };
            g.zoomDelta !== void 0 && (h.zoom = C), g.panDelta !== void 0 && (h.drag = C), g.rollDelta !== void 0 && (h.roll = C), g.pitchDelta !== void 0 && (h.pitch = C), g.bearingDelta !== void 0 && (h.rotate = C);
          }
          _applyChanges() {
            const a = {}, h = {}, g = {};
            for (const [y, w, C] of this._changes) y.panDelta && (a.panDelta = (a.panDelta || new o.P(0, 0))._add(y.panDelta)), y.zoomDelta && (a.zoomDelta = (a.zoomDelta || 0) + y.zoomDelta), y.bearingDelta && (a.bearingDelta = (a.bearingDelta || 0) + y.bearingDelta), y.pitchDelta && (a.pitchDelta = (a.pitchDelta || 0) + y.pitchDelta), y.rollDelta && (a.rollDelta = (a.rollDelta || 0) + y.rollDelta), y.around !== void 0 && (a.around = y.around), y.pinchAround !== void 0 && (a.pinchAround = y.pinchAround), y.noInertia && (a.noInertia = y.noInertia), o.e(h, w), o.e(g, C);
            this._updateMapTransform(a, h, g), this._changes = [];
          }
          _updateMapTransform(a, h, g) {
            const y = this._map, w = y._getTransformForUpdate(), C = y.terrain;
            if (!(Vn(a) || C && this._terrainMovement)) return this._fireEvents(h, g, !0);
            y._stop(!0);
            let { panDelta: P, zoomDelta: L, bearingDelta: F, pitchDelta: j, rollDelta: X, around: G, pinchAround: Q } = a;
            Q !== void 0 && (G = Q), G = G || y.transform.centerPoint, C && !w.isPointOnMapSurface(G) && (G = w.centerPoint);
            const le = { panDelta: P, zoomDelta: L, rollDelta: X, pitchDelta: j, bearingDelta: F, around: G };
            this._map.cameraHelper.useGlobeControls && !w.isPointOnMapSurface(G) && (G = w.centerPoint);
            const Ae = G.distSqr(w.centerPoint) < 0.01 ? w.center : w.screenPointToLocation(P ? G.sub(P) : G);
            C ? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(le, w), this._terrainMovement || !h.drag && !h.zoom ? h.drag && this._terrainMovement ? w.setCenter(w.screenPointToLocation(w.centerPoint.sub(P))) : this._map.cameraHelper.handleMapControlsPan(le, w, Ae) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, this._map.cameraHelper.handleMapControlsPan(le, w, Ae))) : (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(le, w), this._map.cameraHelper.handleMapControlsPan(le, w, Ae)), y._applyUpdatedTransform(w), this._map._update(), a.noInertia || this._inertia.record(a), this._fireEvents(h, g, !0);
          }
          _fireEvents(a, h, g) {
            const y = wn(this._eventsInProgress), w = wn(a), C = {};
            for (const X in a) {
              const { originalEvent: G } = a[X];
              this._eventsInProgress[X] || (C[`${X}start`] = G), this._eventsInProgress[X] = a[X];
            }
            !y && w && this._fireEvent("movestart", w.originalEvent);
            for (const X in C) this._fireEvent(X, C[X]);
            w && this._fireEvent("move", w.originalEvent);
            for (const X in a) {
              const { originalEvent: G } = a[X];
              this._fireEvent(X, G);
            }
            const P = {};
            let L;
            for (const X in this._eventsInProgress) {
              const { handlerName: G, originalEvent: Q } = this._eventsInProgress[X];
              this._handlersById[G].isActive() || (delete this._eventsInProgress[X], L = h[G] || Q, P[`${X}end`] = L);
            }
            for (const X in P) this._fireEvent(X, P[X]);
            const F = wn(this._eventsInProgress), j = (y || w) && !F;
            if (j && this._terrainMovement) {
              this._map._elevationFreeze = !1, this._terrainMovement = !1;
              const X = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && X.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(X);
            }
            if (g && j) {
              this._updatingCamera = !0;
              const X = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), G = (Q) => Q !== 0 && -this._bearingSnap < Q && Q < this._bearingSnap;
              !X || !X.essential && M.prefersReducedMotion ? (this._map.fire(new o.l("moveend", { originalEvent: L })), G(this._map.getBearing()) && this._map.resetNorth()) : (G(X.bearing || this._map.getBearing()) && (X.bearing = 0), X.freezeElevation = !0, this._map.easeTo(X, { originalEvent: L })), this._updatingCamera = !1;
            }
          }
          _fireEvent(a, h) {
            this._map.fire(new o.l(a, h ? { originalEvent: h } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((a) => {
              delete this._frameId, this.handleEvent(new Sn("renderFrame", { timeStamp: a })), this._applyChanges();
            });
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame());
          }
        }
        class Br extends o.E {
          constructor(a, h, g) {
            super(), this._renderFrameCallback = () => {
              const y = Math.min((M.now() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(y)), y < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }, this._moving = !1, this._zooming = !1, this.transform = a, this._bearingSnap = g.bearingSnap, this.cameraHelper = h, this.on("moveend", () => {
              delete this._requestedCameraState;
            });
          }
          migrateProjection(a, h) {
            a.apply(this.transform), this.transform = a, this.cameraHelper = h;
          }
          getCenter() {
            return new o.S(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(a, h) {
            return this.jumpTo({ center: a }, h);
          }
          getCenterElevation() {
            return this.transform.elevation;
          }
          setCenterElevation(a, h) {
            return this.jumpTo({ elevation: a }, h), this;
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround;
          }
          setCenterClampedToGround(a) {
            this._centerClampedToGround = a;
          }
          panBy(a, h, g) {
            return a = o.P.convert(a).mult(-1), this.panTo(this.transform.center, o.e({ offset: a }, h), g);
          }
          panTo(a, h, g) {
            return this.easeTo(o.e({ center: a }, h), g);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(a, h) {
            return this.jumpTo({ zoom: a }, h), this;
          }
          zoomTo(a, h, g) {
            return this.easeTo(o.e({ zoom: a }, h), g);
          }
          zoomIn(a, h) {
            return this.zoomTo(this.getZoom() + 1, a, h), this;
          }
          zoomOut(a, h) {
            return this.zoomTo(this.getZoom() - 1, a, h), this;
          }
          getVerticalFieldOfView() {
            return this.transform.fov;
          }
          setVerticalFieldOfView(a, h) {
            return a != this.transform.fov && (this.transform.setFov(a), this.fire(new o.l("movestart", h)).fire(new o.l("move", h)).fire(new o.l("moveend", h))), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(a, h) {
            return this.jumpTo({ bearing: a }, h), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(a, h) {
            return this.jumpTo({ padding: a }, h), this;
          }
          rotateTo(a, h, g) {
            return this.easeTo(o.e({ bearing: a }, h), g);
          }
          resetNorth(a, h) {
            return this.rotateTo(0, o.e({ duration: 1e3 }, a), h), this;
          }
          resetNorthPitch(a, h) {
            return this.easeTo(o.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, a), h), this;
          }
          snapToNorth(a, h) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(a, h) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(a, h) {
            return this.jumpTo({ pitch: a }, h), this;
          }
          getRoll() {
            return this.transform.roll;
          }
          setRoll(a, h) {
            return this.jumpTo({ roll: a }, h), this;
          }
          cameraForBounds(a, h) {
            a = sr.convert(a).adjustAntiMeridian();
            const g = h && h.bearing || 0;
            return this._cameraForBoxAndBearing(a.getNorthWest(), a.getSouthEast(), g, h);
          }
          _cameraForBoxAndBearing(a, h, g, y) {
            const w = { top: 0, bottom: 0, right: 0, left: 0 };
            if (typeof (y = o.e({ padding: w, offset: [0, 0], maxZoom: this.transform.maxZoom }, y)).padding == "number") {
              const F = y.padding;
              y.padding = { top: F, bottom: F, right: F, left: F };
            }
            const C = o.e(w, y.padding);
            y.padding = C;
            const P = this.transform, L = new sr(a, h);
            return this.cameraHelper.cameraForBoxAndBearing(y, C, L, g, P);
          }
          fitBounds(a, h, g) {
            return this._fitInternal(this.cameraForBounds(a, h), h, g);
          }
          fitScreenCoordinates(a, h, g, y, w) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(o.P.convert(a)), this.transform.screenPointToLocation(o.P.convert(h)), g, y), y, w);
          }
          _fitInternal(a, h, g) {
            return a ? (delete (h = o.e(a, h)).padding, h.linear ? this.easeTo(h, g) : this.flyTo(h, g)) : this;
          }
          jumpTo(a, h) {
            this.stop();
            const g = this._getTransformForUpdate();
            let y = !1, w = !1, C = !1;
            const P = g.zoom;
            this.cameraHelper.handleJumpToCenterZoom(g, a);
            const L = g.zoom !== P;
            return "elevation" in a && g.elevation !== +a.elevation && g.setElevation(+a.elevation), "bearing" in a && g.bearing !== +a.bearing && (y = !0, g.setBearing(+a.bearing)), "pitch" in a && g.pitch !== +a.pitch && (w = !0, g.setPitch(+a.pitch)), "roll" in a && g.roll !== +a.roll && (C = !0, g.setRoll(+a.roll)), a.padding == null || g.isPaddingEqual(a.padding) || g.setPadding(a.padding), this._applyUpdatedTransform(g), this.fire(new o.l("movestart", h)).fire(new o.l("move", h)), L && this.fire(new o.l("zoomstart", h)).fire(new o.l("zoom", h)).fire(new o.l("zoomend", h)), y && this.fire(new o.l("rotatestart", h)).fire(new o.l("rotate", h)).fire(new o.l("rotateend", h)), w && this.fire(new o.l("pitchstart", h)).fire(new o.l("pitch", h)).fire(new o.l("pitchend", h)), C && this.fire(new o.l("rollstart", h)).fire(new o.l("roll", h)).fire(new o.l("rollend", h)), this.fire(new o.l("moveend", h));
          }
          calculateCameraOptionsFromTo(a, h, g) {
            let y = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
            const w = o.a0.fromLngLat(a, h), C = o.a0.fromLngLat(g, y), P = C.x - w.x, L = C.y - w.y, F = C.z - w.z, j = Math.hypot(P, L, F);
            if (j === 0) throw new Error("Can't calculate camera options with same From and To");
            const X = Math.hypot(P, L), G = o.aj(this.transform.cameraToCenterDistance / j / this.transform.tileSize), Q = 180 * Math.atan2(P, -L) / Math.PI;
            let le = 180 * Math.acos(X / j) / Math.PI;
            return le = F < 0 ? 90 - le : 90 + le, { center: C.toLngLat(), elevation: y, zoom: G, pitch: le, bearing: Q };
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(a, h, g, y, w) {
            const C = this.transform.calculateCenterFromCameraLngLatAlt(a, h, g, y);
            return { center: C.center, elevation: C.elevation, zoom: C.zoom, bearing: g, pitch: y, roll: w };
          }
          easeTo(a, h) {
            this._stop(!1, a.easeId), ((a = o.e({ offset: [0, 0], duration: 500, easing: o.cn }, a)).animate === !1 || !a.essential && M.prefersReducedMotion) && (a.duration = 0);
            const g = this._getTransformForUpdate(), y = this.getBearing(), w = g.pitch, C = g.roll, P = "bearing" in a ? this._normalizeBearing(a.bearing, y) : y, L = "pitch" in a ? +a.pitch : w, F = "roll" in a ? this._normalizeBearing(a.roll, C) : C, j = "padding" in a ? a.padding : g.padding, X = o.P.convert(a.offset);
            let G, Q;
            a.around && (G = o.S.convert(a.around), Q = g.locationToScreenPoint(G));
            const le = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, Ae = this.cameraHelper.handleEaseTo(g, { bearing: P, pitch: L, roll: F, padding: j, around: G, aroundPoint: Q, offsetAsPoint: X, offset: a.offset, zoom: a.zoom, center: a.center });
            return this._rotating = this._rotating || y !== P, this._pitching = this._pitching || L !== w, this._rolling = this._rolling || F !== C, this._padding = !g.isPaddingEqual(j), this._zooming = this._zooming || Ae.isZooming, this._easeId = a.easeId, this._prepareEase(h, a.noMoveStart, le), this.terrain && this._prepareElevation(Ae.elevationCenter), this._ease((we) => {
              Ae.easeFunc(we), this.terrain && !a.freezeElevation && this._updateElevation(we), this._applyUpdatedTransform(g), this._fireMoveEvents(h);
            }, (we) => {
              this.terrain && a.freezeElevation && this._finalizeElevation(), this._afterEase(h, we);
            }, a), this;
          }
          _prepareEase(a, h) {
            let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            this._moving = !0, h || g.moving || this.fire(new o.l("movestart", a)), this._zooming && !g.zooming && this.fire(new o.l("zoomstart", a)), this._rotating && !g.rotating && this.fire(new o.l("rotatestart", a)), this._pitching && !g.pitching && this.fire(new o.l("pitchstart", a)), this._rolling && !g.rolling && this.fire(new o.l("rollstart", a));
          }
          _prepareElevation(a) {
            this._elevationCenter = a, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(a, this.transform.tileZoom), this._elevationFreeze = !0;
          }
          _updateElevation(a) {
            this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const h = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (a < 1 && h !== this._elevationTarget) {
              const g = this._elevationTarget - this._elevationStart;
              this._elevationStart += a * (g - (h - (g * a + this._elevationStart)) / (1 - a)), this._elevationTarget = h;
            }
            this.transform.setElevation(o.C.number(this._elevationStart, this._elevationTarget, a));
          }
          _finalizeElevation() {
            this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
          }
          _elevateCameraIfInsideTerrain(a) {
            if (!this.terrain && a.elevation >= 0 && a.pitch <= 90) return {};
            const h = a.getCameraLngLat(), g = a.getCameraAltitude(), y = this.terrain ? this.terrain.getElevationForLngLatZoom(h, a.zoom) : 0;
            if (g < y) {
              const w = this.calculateCameraOptionsFromTo(h, y, a.center, a.elevation);
              return { pitch: w.pitch, zoom: w.zoom };
            }
            return {};
          }
          _applyUpdatedTransform(a) {
            const h = [];
            if (h.push((y) => this._elevateCameraIfInsideTerrain(y)), this.transformCameraUpdate && h.push((y) => this.transformCameraUpdate(y)), !h.length) return;
            const g = a.clone();
            for (const y of h) {
              const w = g.clone(), { center: C, zoom: P, roll: L, pitch: F, bearing: j, elevation: X } = y(w);
              C && w.setCenter(C), X !== void 0 && w.setElevation(X), P !== void 0 && w.setZoom(P), L !== void 0 && w.setRoll(L), F !== void 0 && w.setPitch(F), j !== void 0 && w.setBearing(j), g.apply(w);
            }
            this.transform.apply(g);
          }
          _fireMoveEvents(a) {
            this.fire(new o.l("move", a)), this._zooming && this.fire(new o.l("zoom", a)), this._rotating && this.fire(new o.l("rotate", a)), this._pitching && this.fire(new o.l("pitch", a)), this._rolling && this.fire(new o.l("roll", a));
          }
          _afterEase(a, h) {
            if (this._easeId && h && this._easeId === h) return;
            delete this._easeId;
            const g = this._zooming, y = this._rotating, w = this._pitching, C = this._rolling;
            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, g && this.fire(new o.l("zoomend", a)), y && this.fire(new o.l("rotateend", a)), w && this.fire(new o.l("pitchend", a)), C && this.fire(new o.l("rollend", a)), this.fire(new o.l("moveend", a));
          }
          flyTo(a, h) {
            if (!a.essential && M.prefersReducedMotion) {
              const wt = o.Q(a, ["center", "zoom", "bearing", "pitch", "roll", "elevation"]);
              return this.jumpTo(wt, h);
            }
            this.stop(), a = o.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: o.cn }, a);
            const g = this._getTransformForUpdate(), y = g.bearing, w = g.pitch, C = g.roll, P = g.padding, L = "bearing" in a ? this._normalizeBearing(a.bearing, y) : y, F = "pitch" in a ? +a.pitch : w, j = "roll" in a ? this._normalizeBearing(a.roll, C) : C, X = "padding" in a ? a.padding : g.padding, G = o.P.convert(a.offset);
            let Q = g.centerPoint.add(G);
            const le = g.screenPointToLocation(Q), Ae = this.cameraHelper.handleFlyTo(g, { bearing: L, pitch: F, roll: j, padding: X, locationAtOffset: le, offsetAsPoint: G, center: a.center, minZoom: a.minZoom, zoom: a.zoom });
            let we = a.curve;
            const Te = Math.max(g.width, g.height), Me = Te / Ae.scaleOfZoom, Ve = Ae.pixelPathLength;
            typeof Ae.scaleOfMinZoom == "number" && (we = Math.sqrt(Te / Ae.scaleOfMinZoom / Ve * 2));
            const De = we * we;
            function He(wt) {
              const ir = (Me * Me - Te * Te + (wt ? -1 : 1) * De * De * Ve * Ve) / (2 * (wt ? Me : Te) * De * Ve);
              return Math.log(Math.sqrt(ir * ir + 1) - ir);
            }
            function Ze(wt) {
              return (Math.exp(wt) - Math.exp(-wt)) / 2;
            }
            function Fe(wt) {
              return (Math.exp(wt) + Math.exp(-wt)) / 2;
            }
            const it = He(!1);
            let bt = function(wt) {
              return Fe(it) / Fe(it + we * wt);
            }, dt = function(wt) {
              return Te * ((Fe(it) * (Ze(ir = it + we * wt) / Fe(ir)) - Ze(it)) / De) / Ve;
              var ir;
            }, Tt = (He(!0) - it) / we;
            if (Math.abs(Ve) < 2e-6 || !isFinite(Tt)) {
              if (Math.abs(Te - Me) < 1e-6) return this.easeTo(a, h);
              const wt = Me < Te ? -1 : 1;
              Tt = Math.abs(Math.log(Me / Te)) / we, dt = () => 0, bt = (ir) => Math.exp(wt * we * ir);
            }
            return a.duration = "duration" in a ? +a.duration : 1e3 * Tt / ("screenSpeed" in a ? +a.screenSpeed / we : +a.speed), a.maxDuration && a.duration > a.maxDuration && (a.duration = 0), this._zooming = !0, this._rotating = y !== L, this._pitching = F !== w, this._rolling = j !== C, this._padding = !g.isPaddingEqual(X), this._prepareEase(h, !1), this.terrain && this._prepareElevation(Ae.targetCenter), this._ease((wt) => {
              const ir = wt * Tt, or = 1 / bt(ir), Vt = dt(ir);
              this._rotating && g.setBearing(o.C.number(y, L, wt)), this._pitching && g.setPitch(o.C.number(w, F, wt)), this._rolling && g.setRoll(o.C.number(C, j, wt)), this._padding && (g.interpolatePadding(P, X, wt), Q = g.centerPoint.add(G)), Ae.easeFunc(wt, or, Vt, Q), this.terrain && !a.freezeElevation && this._updateElevation(wt), this._applyUpdatedTransform(g), this._fireMoveEvents(h);
            }, () => {
              this.terrain && a.freezeElevation && this._finalizeElevation(), this._afterEase(h);
            }, a), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(a, h) {
            var g;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const y = this._onEaseEnd;
              delete this._onEaseEnd, y.call(this, h);
            }
            return a || (g = this.handlers) === null || g === void 0 || g.stop(!1), this;
          }
          _ease(a, h, g) {
            g.animate === !1 || g.duration === 0 ? (a(1), h()) : (this._easeStart = M.now(), this._easeOptions = g, this._onEaseFrame = a, this._onEaseEnd = h, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _normalizeBearing(a, h) {
            a = o.aN(a, -180, 180);
            const g = Math.abs(a - h);
            return Math.abs(a - 360 - h) < g && (a -= 360), Math.abs(a + 360 - h) < g && (a += 360), a;
          }
          queryTerrainElevation(a) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(o.S.convert(a), this.transform.tileZoom) : null;
          }
        }
        const di = { compact: !0, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
        class ws {
          constructor() {
            let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : di;
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
            }, this._updateData = (h) => {
              !h || h.sourceDataType !== "metadata" && h.sourceDataType !== "visibility" && h.dataType !== "style" && h.type !== "terrain" || this._updateAttributions();
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
            }, this.options = a;
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(a) {
            return this._map = a, this._compact = this.options.compact, this._container = E.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = E.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = E.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
          }
          onRemove() {
            E.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(a, h) {
            const g = this._map._getUIString(`AttributionControl.${h}`);
            a.title = g, a.setAttribute("aria-label", g);
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let a = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? a = a.concat(this.options.customAttribution.map((y) => typeof y != "string" ? "" : y)) : typeof this.options.customAttribution == "string" && a.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const y = this._map.style.stylesheet;
              this.styleOwner = y.owner, this.styleId = y.id;
            }
            const h = this._map.style.sourceCaches;
            for (const y in h) {
              const w = h[y];
              if (w.used || w.usedForTerrain) {
                const C = w.getSource();
                C.attribution && a.indexOf(C.attribution) < 0 && a.push(C.attribution);
              }
            }
            a = a.filter((y) => String(y).trim()), a.sort((y, w) => y.length - w.length), a = a.filter((y, w) => {
              for (let C = w + 1; C < a.length; C++) if (a[C].indexOf(y) >= 0) return !1;
              return !0;
            });
            const g = a.join(" | ");
            g !== this._attribHTML && (this._attribHTML = g, a.length ? (this._innerContainer.innerHTML = E.sanitize(g), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
          }
        }
        class Bi {
          constructor() {
            let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            this._updateCompact = () => {
              const h = this._container.children;
              if (h.length) {
                const g = h[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && g.classList.add("maplibregl-compact") : g.classList.remove("maplibregl-compact");
              }
            }, this.options = a;
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(a) {
            this._map = a, this._compact = this.options && this.options.compact, this._container = E.create("div", "maplibregl-ctrl");
            const h = E.create("a", "maplibregl-ctrl-logo");
            return h.target = "_blank", h.rel = "noopener nofollow", h.href = "https://maplibre.org/", h.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), h.setAttribute("rel", "noopener nofollow"), this._container.appendChild(h), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            E.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
          }
        }
        class Zs {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
          }
          add(a) {
            const h = ++this._id;
            return this._queue.push({ callback: a, id: h, cancelled: !1 }), h;
          }
          remove(a) {
            const h = this._currentlyRunning, g = h ? this._queue.concat(h) : this._queue;
            for (const y of g) if (y.id === a) return void (y.cancelled = !0);
          }
          run() {
            let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const h = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const g of h) if (!g.cancelled && (g.callback(a), this._cleared)) break;
            this._cleared = !1, this._currentlyRunning = !1;
          }
          clear() {
            this._currentlyRunning && (this._cleared = !0), this._queue = [];
          }
        }
        var Un = o.aI([{ name: "a_pos3d", type: "Int16", components: 3 }]);
        class So extends o.E {
          constructor(a) {
            super(), this._lastTilesetChange = M.now(), this.sourceCache = a, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = a._source.tileSize * 2 ** this.deltaZoom, a.usedForTerrain = !0, a.tileSize = this.tileSize;
          }
          destruct() {
            this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null;
          }
          update(a, h) {
            this.sourceCache.update(a, h), this._renderableTilesKeys = [];
            const g = {};
            for (const y of Pt(a, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: !1, terrain: h, calculateTileZoom: this.sourceCache._source.calculateTileZoom })) g[y.key] = !0, this._renderableTilesKeys.push(y.key), this._tiles[y.key] || (y.terrainRttPosMatrix32f = new Float64Array(16), o.bX(y.terrainRttPosMatrix32f, 0, o.$, o.$, 0, 0, 1), this._tiles[y.key] = new vn(y, this.tileSize), this._lastTilesetChange = M.now());
            for (const y in this._tiles) g[y] || delete this._tiles[y];
          }
          freeRtt(a) {
            for (const h in this._tiles) {
              const g = this._tiles[h];
              (!a || g.tileID.equals(a) || g.tileID.isChildOf(a) || a.isChildOf(g.tileID)) && (g.rtt = []);
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map((a) => this.getTileByID(a));
          }
          getTileByID(a) {
            return this._tiles[a];
          }
          getTerrainCoords(a, h) {
            return h ? this._getTerrainCoordsForTileRanges(a, h) : this._getTerrainCoordsForRegularTile(a);
          }
          _getTerrainCoordsForRegularTile(a) {
            const h = {};
            for (const g of this._renderableTilesKeys) {
              const y = this._tiles[g].tileID, w = a.clone(), C = o.b9();
              if (y.canonical.equals(a.canonical)) o.bX(C, 0, o.$, o.$, 0, 0, 1);
              else if (y.canonical.isChildOf(a.canonical)) {
                const P = y.canonical.z - a.canonical.z, L = y.canonical.x - (y.canonical.x >> P << P), F = y.canonical.y - (y.canonical.y >> P << P), j = o.$ >> P;
                o.bX(C, 0, j, j, 0, 0, 1), o.M(C, C, [-L * j, -F * j, 0]);
              } else {
                if (!a.canonical.isChildOf(y.canonical)) continue;
                {
                  const P = a.canonical.z - y.canonical.z, L = a.canonical.x - (a.canonical.x >> P << P), F = a.canonical.y - (a.canonical.y >> P << P), j = o.$ >> P;
                  o.bX(C, 0, o.$, o.$, 0, 0, 1), o.M(C, C, [L * j, F * j, 0]), o.N(C, C, [1 / 2 ** P, 1 / 2 ** P, 0]);
                }
              }
              w.terrainRttPosMatrix32f = new Float32Array(C), h[g] = w;
            }
            return h;
          }
          _getTerrainCoordsForTileRanges(a, h) {
            const g = {};
            for (const y of this._renderableTilesKeys) {
              const w = this._tiles[y].tileID;
              if (!this._isWithinTileRanges(w, h)) continue;
              const C = a.clone(), P = o.b9();
              if (w.canonical.z === a.canonical.z) {
                const L = a.canonical.x - w.canonical.x, F = a.canonical.y - w.canonical.y;
                o.bX(P, 0, o.$, o.$, 0, 0, 1), o.M(P, P, [L * o.$, F * o.$, 0]);
              } else if (w.canonical.z > a.canonical.z) {
                const L = w.canonical.z - a.canonical.z, F = w.canonical.x - (w.canonical.x >> L << L), j = w.canonical.y - (w.canonical.y >> L << L), X = a.canonical.x - (w.canonical.x >> L), G = a.canonical.y - (w.canonical.y >> L), Q = o.$ >> L;
                o.bX(P, 0, Q, Q, 0, 0, 1), o.M(P, P, [-F * Q + X * o.$, -j * Q + G * o.$, 0]);
              } else {
                const L = a.canonical.z - w.canonical.z, F = a.canonical.x - (a.canonical.x >> L << L), j = a.canonical.y - (a.canonical.y >> L << L), X = (a.canonical.x >> L) - w.canonical.x, G = (a.canonical.y >> L) - w.canonical.y, Q = o.$ << L;
                o.bX(P, 0, Q, Q, 0, 0, 1), o.M(P, P, [F * o.$ + X * Q, j * o.$ + G * Q, 0]);
              }
              C.terrainRttPosMatrix32f = new Float32Array(P), g[y] = C;
            }
            return g;
          }
          getSourceTile(a, h) {
            const g = this.sourceCache._source;
            let y = a.overscaledZ - this.deltaZoom;
            if (y > g.maxzoom && (y = g.maxzoom), y < g.minzoom) return null;
            this._sourceTileCache[a.key] || (this._sourceTileCache[a.key] = a.scaledTo(y).key);
            let w = this.sourceCache.getTileByID(this._sourceTileCache[a.key]);
            if ((!w || !w.dem) && h) for (; y >= g.minzoom && (!w || !w.dem); ) w = this.sourceCache.getTileByID(a.scaledTo(y--).key);
            return w;
          }
          anyTilesAfterTime() {
            let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Date.now();
            return this._lastTilesetChange >= a;
          }
          _isWithinTileRanges(a, h) {
            return h[a.canonical.z] && a.canonical.x >= h[a.canonical.z].minTileX && a.canonical.x <= h[a.canonical.z].maxTileX && a.canonical.y >= h[a.canonical.z].minTileY && a.canonical.y <= h[a.canonical.z].maxTileY;
          }
        }
        class Li {
          constructor(a, h, g) {
            this._meshCache = {}, this.painter = a, this.sourceCache = new So(h), this.options = g, this.exaggeration = typeof g.exaggeration == "number" ? g.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
          }
          getDEMElevation(a, h, g) {
            let y = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : o.$;
            var w;
            if (!(h >= 0 && h < y && g >= 0 && g < y)) return 0;
            const C = this.getTerrainData(a), P = (w = C.tile) === null || w === void 0 ? void 0 : w.dem;
            if (!P) return 0;
            const L = o.cr([], [h / y * o.$, g / y * o.$], C.u_terrain_matrix), F = [L[0] * P.dim, L[1] * P.dim], j = Math.floor(F[0]), X = Math.floor(F[1]), G = F[0] - j, Q = F[1] - X;
            return P.get(j, X) * (1 - G) * (1 - Q) + P.get(j + 1, X) * G * (1 - Q) + P.get(j, X + 1) * (1 - G) * Q + P.get(j + 1, X + 1) * G * Q;
          }
          getElevationForLngLatZoom(a, h) {
            if (!o.cs(h, a.wrap())) return 0;
            const { tileID: g, mercatorX: y, mercatorY: w } = this._getOverscaledTileIDFromLngLatZoom(a, h);
            return this.getElevation(g, y % o.$, w % o.$, o.$);
          }
          getElevation(a, h, g) {
            let y = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : o.$;
            return this.getDEMElevation(a, h, g, y) * this.exaggeration;
          }
          getTerrainData(a) {
            if (!this._emptyDemTexture) {
              const y = this.painter.context, w = new o.R({ width: 1, height: 1 }, new Uint8Array(4));
              this._emptyDepthTexture = new o.T(y, w, y.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new o.T(y, new o.R({ width: 1, height: 1 }), y.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(y.gl.NEAREST, y.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = o.af([]);
            }
            const h = this.sourceCache.getSourceTile(a, !0);
            if (h && h.dem && (!h.demTexture || h.needsTerrainPrepare)) {
              const y = this.painter.context;
              h.demTexture = this.painter.getTileTexture(h.dem.stride), h.demTexture ? h.demTexture.update(h.dem.getPixels(), { premultiply: !1 }) : h.demTexture = new o.T(y, h.dem.getPixels(), y.gl.RGBA, { premultiply: !1 }), h.demTexture.bind(y.gl.NEAREST, y.gl.CLAMP_TO_EDGE), h.needsTerrainPrepare = !1;
            }
            const g = h && h + h.tileID.key + a.key;
            if (g && !this._demMatrixCache[g]) {
              const y = this.sourceCache.sourceCache._source.maxzoom;
              let w = a.canonical.z - h.tileID.canonical.z;
              a.overscaledZ > a.canonical.z && (a.canonical.z >= y ? w = a.canonical.z - y : o.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const C = a.canonical.x - (a.canonical.x >> w << w), P = a.canonical.y - (a.canonical.y >> w << w), L = o.ct(new Float64Array(16), [1 / (o.$ << w), 1 / (o.$ << w), 0]);
              o.M(L, L, [C * o.$, P * o.$, 0]), this._demMatrixCache[a.key] = { matrix: L, coord: a };
            }
            return { u_depth: 2, u_terrain: 3, u_terrain_dim: h && h.dem && h.dem.dim || 1, u_terrain_matrix: g ? this._demMatrixCache[a.key].matrix : this._emptyDemMatrix, u_terrain_unpack: h && h.dem && h.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (h && h.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: h };
          }
          getFramebuffer(a) {
            const h = this.painter, g = h.width / devicePixelRatio, y = h.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === g && this._fbo.height === y || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new o.T(h.context, { width: g, height: y, data: null }, h.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(h.context.gl.NEAREST, h.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new o.T(h.context, { width: g, height: y, data: null }, h.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(h.context.gl.NEAREST, h.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = h.context.createFramebuffer(g, y, !0, !1), this._fbo.depthAttachment.set(h.context.createRenderbuffer(h.context.gl.DEPTH_COMPONENT16, g, y))), this._fbo.colorAttachment.set(a === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
          }
          getCoordsTexture() {
            const a = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const h = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let w = 0, C = 0; w < this._coordsTextureSize; w++) for (let P = 0; P < this._coordsTextureSize; P++, C += 4) h[C + 0] = 255 & P, h[C + 1] = 255 & w, h[C + 2] = P >> 8 << 4 | w >> 8, h[C + 3] = 0;
            const g = new o.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(h.buffer)), y = new o.T(a, g, a.gl.RGBA, { premultiply: !1 });
            return y.bind(a.gl.NEAREST, a.gl.CLAMP_TO_EDGE), this._coordsTexture = y, y;
          }
          pointCoordinate(a) {
            this.painter.maybeDrawDepthAndCoords(!0);
            const h = new Uint8Array(4), g = this.painter.context, y = g.gl, w = Math.round(a.x * this.painter.pixelRatio / devicePixelRatio), C = Math.round(a.y * this.painter.pixelRatio / devicePixelRatio), P = Math.round(this.painter.height / devicePixelRatio);
            g.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), y.readPixels(w, P - C - 1, 1, 1, y.RGBA, y.UNSIGNED_BYTE, h), g.bindFramebuffer.set(null);
            const L = h[0] + (h[2] >> 4 << 8), F = h[1] + ((15 & h[2]) << 8), j = this.coordsIndex[255 - h[3]], X = j && this.sourceCache.getTileByID(j);
            if (!X) return null;
            const G = this._coordsTextureSize, Q = (1 << X.tileID.canonical.z) * G;
            return new o.a0((X.tileID.canonical.x * G + L) / Q + X.tileID.wrap, (X.tileID.canonical.y * G + F) / Q, this.getElevation(X.tileID, L, F, G));
          }
          depthAtPoint(a) {
            const h = new Uint8Array(4), g = this.painter.context, y = g.gl;
            return g.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), y.readPixels(a.x, this.painter.height / devicePixelRatio - a.y - 1, 1, 1, y.RGBA, y.UNSIGNED_BYTE, h), g.bindFramebuffer.set(null), (h[0] / 16777216 + h[1] / 65536 + h[2] / 256 + h[3]) / 256;
          }
          getTerrainMesh(a) {
            var h;
            const g = ((h = this.painter.style.projection) === null || h === void 0 ? void 0 : h.transitionState) > 0, y = g && a.canonical.y === 0, w = g && a.canonical.y === (1 << a.canonical.z) - 1, C = `m_${y ? "n" : ""}_${w ? "s" : ""}`;
            if (this._meshCache[C]) return this._meshCache[C];
            const P = this.painter.context, L = new o.cu(), F = new o.aM(), j = this.meshSize, X = o.$ / j, G = j * j;
            for (let Fe = 0; Fe <= j; Fe++) for (let it = 0; it <= j; it++) L.emplaceBack(it * X, Fe * X, 0);
            for (let Fe = 0; Fe < G; Fe += j + 1) for (let it = 0; it < j; it++) F.emplaceBack(it + Fe, j + it + Fe + 1, j + it + Fe + 2), F.emplaceBack(it + Fe, j + it + Fe + 2, it + Fe + 1);
            const Q = L.length, le = Q + (j + 1), Ae = (j + 1) * j, we = y ? o.bg : 0, Te = y ? 0 : 1, Me = w ? o.bh : o.$, Ve = w ? 0 : 1;
            for (let Fe = 0; Fe <= j; Fe++) L.emplaceBack(Fe * X, we, Te);
            for (let Fe = 0; Fe <= j; Fe++) L.emplaceBack(Fe * X, Me, Ve);
            for (let Fe = 0; Fe < j; Fe++) F.emplaceBack(Ae + Fe, le + Fe, le + Fe + 1), F.emplaceBack(Ae + Fe, le + Fe + 1, Ae + Fe + 1), F.emplaceBack(0 + Fe, Q + Fe + 1, Q + Fe), F.emplaceBack(0 + Fe, 0 + Fe + 1, Q + Fe + 1);
            const De = L.length, He = De + 2 * (j + 1);
            for (const Fe of [0, 1]) for (let it = 0; it <= j; it++) for (const bt of [0, 1]) L.emplaceBack(Fe * o.$, it * X, bt);
            for (let Fe = 0; Fe < 2 * j; Fe += 2) F.emplaceBack(De + Fe, De + Fe + 1, De + Fe + 3), F.emplaceBack(De + Fe, De + Fe + 3, De + Fe + 2), F.emplaceBack(He + Fe, He + Fe + 3, He + Fe + 1), F.emplaceBack(He + Fe, He + Fe + 2, He + Fe + 3);
            const Ze = new sa(P.createVertexBuffer(L, Un.members), P.createIndexBuffer(F), o.aL.simpleSegment(0, 0, L.length, F.length));
            return this._meshCache[C] = Ze, Ze;
          }
          getMeshFrameDelta(a) {
            return 2 * Math.PI * o.bt / Math.pow(2, Math.max(a, 0)) / 5;
          }
          getMinTileElevationForLngLatZoom(a, h) {
            var g;
            const { tileID: y } = this._getOverscaledTileIDFromLngLatZoom(a, h);
            return (g = this.getMinMaxElevation(y).minElevation) !== null && g !== void 0 ? g : 0;
          }
          getMinMaxElevation(a) {
            const h = this.getTerrainData(a).tile, g = { minElevation: null, maxElevation: null };
            return h && h.dem && (g.minElevation = h.dem.min * this.exaggeration, g.maxElevation = h.dem.max * this.exaggeration), g;
          }
          _getOverscaledTileIDFromLngLatZoom(a, h) {
            const g = o.a0.fromLngLat(a.wrap()), y = (1 << h) * o.$, w = g.x * y, C = g.y * y, P = Math.floor(w / o.$), L = Math.floor(C / o.$);
            return { tileID: new o.Z(h, 0, h, P, L), mercatorX: w, mercatorY: C };
          }
        }
        class Fi {
          constructor(a, h, g) {
            this._context = a, this._size = h, this._tileSize = g, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
          }
          destruct() {
            for (const a of this._objects) a.texture.destroy(), a.fbo.destroy();
          }
          _createObject(a) {
            const h = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), g = new o.T(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
            return g.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), h.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), h.colorAttachment.set(g.texture), { id: a, fbo: h, texture: g, stamp: -1, inUse: !1 };
          }
          getObjectForId(a) {
            return this._objects[a];
          }
          useObject(a) {
            a.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter((h) => a.id !== h), this._recentlyUsed.push(a.id);
          }
          stampObject(a) {
            a.stamp = ++this._stamp;
          }
          getOrCreateFreeObject() {
            for (const h of this._recentlyUsed) if (!this._objects[h].inUse) return this._objects[h];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const a = this._createObject(this._objects.length);
            return this._objects.push(a), a;
          }
          freeObject(a) {
            a.inUse = !1;
          }
          freeAllObjects() {
            for (const a of this._objects) this.freeObject(a);
          }
          isFull() {
            return !(this._objects.length < this._size) && this._objects.some((a) => !a.inUse) === !1;
          }
        }
        const fr = { background: !0, fill: !0, line: !0, raster: !0, hillshade: !0, "color-relief": !0 };
        class Ir {
          constructor(a, h) {
            this.painter = a, this.terrain = h, this.pool = new Fi(a.context, 30, h.sourceCache.tileSize * h.qualityFactor);
          }
          destruct() {
            this.pool.destruct();
          }
          getTexture(a) {
            return this.pool.getObjectForId(a.rtt[this._stacks.length - 1].id).texture;
          }
          prepareForRender(a, h) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = a._order.filter((g) => !a._layers[g].isHidden(h)), this._coordsAscending = {};
            for (const g in a.sourceCaches) {
              this._coordsAscending[g] = {};
              const y = a.sourceCaches[g].getVisibleCoordinates(), w = a.sourceCaches[g].getSource(), C = w instanceof Yt ? w.terrainTileRanges : null;
              for (const P of y) {
                const L = this.terrain.sourceCache.getTerrainCoords(P, C);
                for (const F in L) this._coordsAscending[g][F] || (this._coordsAscending[g][F] = []), this._coordsAscending[g][F].push(L[F]);
              }
            }
            this._coordsAscendingStr = {};
            for (const g of a._order) {
              const y = a._layers[g], w = y.source;
              if (fr[y.type] && !this._coordsAscendingStr[w]) {
                this._coordsAscendingStr[w] = {};
                for (const C in this._coordsAscending[w]) this._coordsAscendingStr[w][C] = this._coordsAscending[w][C].map((P) => P.key).sort().join();
              }
            }
            for (const g of this._renderableTiles) for (const y in this._coordsAscendingStr) {
              const w = this._coordsAscendingStr[y][g.tileID.key];
              w && w !== g.rttCoords[y] && (g.rtt = []);
            }
          }
          renderLayer(a, h) {
            if (a.isHidden(this.painter.transform.zoom)) return !1;
            const g = Object.assign(Object.assign({}, h), { isRenderingToTexture: !0 }), y = a.type, w = this.painter, C = this._renderableLayerIds[this._renderableLayerIds.length - 1] === a.id;
            if (fr[y] && (this._prevType && fr[this._prevType] || this._stacks.push([]), this._prevType = y, this._stacks[this._stacks.length - 1].push(a.id), !C)) return !0;
            if (fr[this._prevType] || fr[y] && C) {
              this._prevType = y;
              const P = this._stacks.length - 1, L = this._stacks[P] || [];
              for (const F of this._renderableTiles) {
                if (this.pool.isFull() && (Si(this.painter, this.terrain, this._rttTiles, g), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(F), F.rtt[P]) {
                  const X = this.pool.getObjectForId(F.rtt[P].id);
                  if (X.stamp === F.rtt[P].stamp) {
                    this.pool.useObject(X);
                    continue;
                  }
                }
                const j = this.pool.getOrCreateFreeObject();
                this.pool.useObject(j), this.pool.stampObject(j), F.rtt[P] = { id: j.id, stamp: j.stamp }, w.context.bindFramebuffer.set(j.fbo.framebuffer), w.context.clear({ color: o.be.transparent, stencil: 0 }), w.currentStencilSource = void 0;
                for (let X = 0; X < L.length; X++) {
                  const G = w.style._layers[L[X]], Q = G.source ? this._coordsAscending[G.source][F.tileID.key] : [F.tileID];
                  w.context.viewport.set([0, 0, j.fbo.width, j.fbo.height]), w._renderTileClippingMasks(G, Q, !0), w.renderLayer(w, w.style.sourceCaches[G.source], G, Q, g), G.source && (F.rttCoords[G.source] = this._coordsAscendingStr[G.source][F.tileID.key]);
                }
              }
              return Si(this.painter, this.terrain, this._rttTiles, g), this._rttTiles = [], this.pool.freeAllObjects(), fr[y];
            }
            return !1;
          }
        }
        const Ys = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "GlobeControl.Enable": "Enable globe", "GlobeControl.Disable": "Disable globe", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use ⌘ + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, zo = d, Oi = { hash: !1, interactive: !0, bearingSnap: 7, attributionControl: di, maplibreLogo: !1, refreshExpiredTiles: !0, canvasContextAttributes: { antialias: !1, preserveDrawingBuffer: !1, powerPreference: "high-performance", failIfMajorPerformanceCaveat: !1, desynchronized: !1, contextType: void 0 }, scrollZoom: !0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, trackResize: !0, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: !0, maxTileCacheSize: null, maxTileCacheZoomLevels: o.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: !0, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: !0, rollEnabled: !1, validateStyle: !0, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: !0, centerClampedToGround: !0 }, Ei = { showCompass: !0, showZoom: !0, visualizePitch: !1, visualizeRoll: !0 };
        class Pl {
          constructor(a, h) {
            let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
            this.mousedown = (w) => {
              this.startMove(w, E.mousePos(this.element, w)), E.addEventListener(window, "mousemove", this.mousemove), E.addEventListener(window, "mouseup", this.mouseup);
            }, this.mousemove = (w) => {
              this.move(w, E.mousePos(this.element, w));
            }, this.mouseup = (w) => {
              this._rotatePitchHanlder.dragEnd(w), this.offTemp();
            }, this.touchstart = (w) => {
              w.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = E.touchPos(this.element, w.targetTouches)[0], this.startMove(w, this._startPos), E.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), E.addEventListener(window, "touchend", this.touchend));
            }, this.touchmove = (w) => {
              w.targetTouches.length !== 1 ? this.reset() : (this._lastPos = E.touchPos(this.element, w.targetTouches)[0], this.move(w, this._lastPos));
            }, this.touchend = (w) => {
              w.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this.reset = () => {
              this._rotatePitchHanlder.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this._clickTolerance = 10, this.element = h;
            const y = new W();
            this._rotatePitchHanlder = new Qc({ clickTolerance: 3, move: (w, C) => {
              const P = h.getBoundingClientRect(), L = new o.P((P.bottom - P.top) / 2, (P.right - P.left) / 2);
              return { bearingDelta: o.cm(new o.P(w.x, C.y), C, L), pitchDelta: g ? -0.5 * (C.y - w.y) : void 0 };
            }, moveStateManager: y, enable: !0, assignEvents: () => {
            } }), this.map = a, E.addEventListener(h, "mousedown", this.mousedown), E.addEventListener(h, "touchstart", this.touchstart, { passive: !1 }), E.addEventListener(h, "touchcancel", this.reset);
          }
          startMove(a, h) {
            this._rotatePitchHanlder.dragStart(a, h), E.disableDrag();
          }
          move(a, h) {
            const g = this.map, { bearingDelta: y, pitchDelta: w } = this._rotatePitchHanlder.dragMove(a, h) || {};
            y && g.setBearing(g.getBearing() + y), w && g.setPitch(g.getPitch() + w);
          }
          off() {
            const a = this.element;
            E.removeEventListener(a, "mousedown", this.mousedown), E.removeEventListener(a, "touchstart", this.touchstart, { passive: !1 }), E.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), E.removeEventListener(window, "touchend", this.touchend), E.removeEventListener(a, "touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            E.enableDrag(), E.removeEventListener(window, "mousemove", this.mousemove), E.removeEventListener(window, "mouseup", this.mouseup), E.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), E.removeEventListener(window, "touchend", this.touchend);
          }
        }
        let ki;
        function sl(v, a, h) {
          if ((arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1) || !h.getCoveringTilesDetailsProvider().allowWorldCopies()) return v == null ? void 0 : v.wrap();
          const y = new o.S(v.lng, v.lat);
          if (v = new o.S(v.lng, v.lat), a) {
            const w = new o.S(v.lng - 360, v.lat), C = new o.S(v.lng + 360, v.lat), P = h.locationToScreenPoint(v).distSqr(a);
            h.locationToScreenPoint(w).distSqr(a) < P ? v = w : h.locationToScreenPoint(C).distSqr(a) < P && (v = C);
          }
          for (; Math.abs(v.lng - h.center.lng) > 180; ) {
            const w = h.locationToScreenPoint(v);
            if (w.x >= 0 && w.y >= 0 && w.x <= h.width && w.y <= h.height) break;
            v.lng > h.center.lng ? v.lng -= 360 : v.lng += 360;
          }
          return v.lng !== y.lng && h.isPointOnMapSurface(h.locationToScreenPoint(v)) ? v : y;
        }
        const Wn = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        function ri(v, a, h) {
          const g = v.classList;
          for (const y in Wn) g.remove(`maplibregl-${h}-anchor-${y}`);
          g.add(`maplibregl-${h}-anchor-${a}`);
        }
        class pi extends o.E {
          constructor(a) {
            if (super(), this._onKeyPress = (h) => {
              const g = h.code, y = h.charCode || h.keyCode;
              g !== "Space" && g !== "Enter" && y !== 32 && y !== 13 || this.togglePopup();
            }, this._onMapClick = (h) => {
              const g = h.originalEvent.target, y = this._element;
              this._popup && (g === y || y.contains(g)) && this.togglePopup();
            }, this._update = (h) => {
              if (!this._map) return;
              const g = this._map.loaded() && !this._map.isMoving();
              ((h == null ? void 0 : h.type) === "terrain" || (h == null ? void 0 : h.type) === "render" && !g) && this._map.once("render", this._update), this._lngLat = sl(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
              let y = "";
              this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? y = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (y = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
              let w = "";
              this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? w = "rotateX(0deg)" : this._pitchAlignment === "map" && (w = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || h && h.type !== "moveend" || (this._pos = this._pos.round()), E.setTransform(this._element, `${Wn[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${w} ${y}`), M.frameAsync(new AbortController()).then(() => {
                this._updateOpacity(h && h.type === "moveend");
              }).catch(() => {
              });
            }, this._onMove = (h) => {
              if (!this._isDragging) {
                const g = this._clickTolerance || this._map._clickTolerance;
                this._isDragging = h.point.dist(this._pointerdownPos) >= g;
              }
              this._isDragging && (this._pos = h.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new o.l("dragstart"))), this.fire(new o.l("drag")));
            }, this._onUp = () => {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new o.l("dragend")), this._state = "inactive";
            }, this._addDragHandler = (h) => {
              this._element.contains(h.originalEvent.target) && (h.preventDefault(), this._positionDelta = h.point.sub(this._pos).add(this._offset), this._pointerdownPos = h.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }, this._anchor = a && a.anchor || "center", this._color = a && a.color || "#3FB1CE", this._scale = a && a.scale || 1, this._draggable = a && a.draggable || !1, this._clickTolerance = a && a.clickTolerance || 0, this._subpixelPositioning = a && a.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = a && a.rotation || 0, this._rotationAlignment = a && a.rotationAlignment || "auto", this._pitchAlignment = a && a.pitchAlignment && a.pitchAlignment !== "auto" ? a.pitchAlignment : this._rotationAlignment, this.setOpacity(a == null ? void 0 : a.opacity, a == null ? void 0 : a.opacityWhenCovered), a && a.element) this._element = a.element, this._offset = o.P.convert(a && a.offset || [0, 0]);
            else {
              this._defaultMarker = !0, this._element = E.create("div");
              const h = E.createNS("http://www.w3.org/2000/svg", "svg"), g = 41, y = 27;
              h.setAttributeNS(null, "display", "block"), h.setAttributeNS(null, "height", `${g}px`), h.setAttributeNS(null, "width", `${y}px`), h.setAttributeNS(null, "viewBox", `0 0 ${y} ${g}`);
              const w = E.createNS("http://www.w3.org/2000/svg", "g");
              w.setAttributeNS(null, "stroke", "none"), w.setAttributeNS(null, "stroke-width", "1"), w.setAttributeNS(null, "fill", "none"), w.setAttributeNS(null, "fill-rule", "evenodd");
              const C = E.createNS("http://www.w3.org/2000/svg", "g");
              C.setAttributeNS(null, "fill-rule", "nonzero");
              const P = E.createNS("http://www.w3.org/2000/svg", "g");
              P.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), P.setAttributeNS(null, "fill", "#000000");
              const L = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
              for (const Te of L) {
                const Me = E.createNS("http://www.w3.org/2000/svg", "ellipse");
                Me.setAttributeNS(null, "opacity", "0.04"), Me.setAttributeNS(null, "cx", "10.5"), Me.setAttributeNS(null, "cy", "5.80029008"), Me.setAttributeNS(null, "rx", Te.rx), Me.setAttributeNS(null, "ry", Te.ry), P.appendChild(Me);
              }
              const F = E.createNS("http://www.w3.org/2000/svg", "g");
              F.setAttributeNS(null, "fill", this._color);
              const j = E.createNS("http://www.w3.org/2000/svg", "path");
              j.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), F.appendChild(j);
              const X = E.createNS("http://www.w3.org/2000/svg", "g");
              X.setAttributeNS(null, "opacity", "0.25"), X.setAttributeNS(null, "fill", "#000000");
              const G = E.createNS("http://www.w3.org/2000/svg", "path");
              G.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), X.appendChild(G);
              const Q = E.createNS("http://www.w3.org/2000/svg", "g");
              Q.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), Q.setAttributeNS(null, "fill", "#FFFFFF");
              const le = E.createNS("http://www.w3.org/2000/svg", "g");
              le.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const Ae = E.createNS("http://www.w3.org/2000/svg", "circle");
              Ae.setAttributeNS(null, "fill", "#000000"), Ae.setAttributeNS(null, "opacity", "0.25"), Ae.setAttributeNS(null, "cx", "5.5"), Ae.setAttributeNS(null, "cy", "5.5"), Ae.setAttributeNS(null, "r", "5.4999962");
              const we = E.createNS("http://www.w3.org/2000/svg", "circle");
              we.setAttributeNS(null, "fill", "#FFFFFF"), we.setAttributeNS(null, "cx", "5.5"), we.setAttributeNS(null, "cy", "5.5"), we.setAttributeNS(null, "r", "5.4999962"), le.appendChild(Ae), le.appendChild(we), C.appendChild(P), C.appendChild(F), C.appendChild(X), C.appendChild(Q), C.appendChild(le), h.appendChild(C), h.setAttributeNS(null, "height", g * this._scale + "px"), h.setAttributeNS(null, "width", y * this._scale + "px"), this._element.appendChild(h), this._offset = o.P.convert(a && a.offset || [0, -14]);
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (h) => {
              h.preventDefault();
            }), this._element.addEventListener("mousedown", (h) => {
              h.preventDefault();
            }), ri(this._element, this._anchor, "marker"), a && a.className) for (const h of a.className.split(" ")) this._element.classList.add(h);
            this._popup = null;
          }
          addTo(a) {
            return this.remove(), this._map = a, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", a._getUIString("Marker.Title")), a.getCanvasContainer().appendChild(this._element), a.on("move", this._update), a.on("moveend", this._update), a.on("terrain", this._update), a.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), E.remove(this._element), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(a) {
            return this._lngLat = o.S.convert(a), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(a) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), a) {
              if (!("offset" in a.options)) {
                const y = Math.abs(13.5) / Math.SQRT2;
                a.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [y, -1 * (38.1 - 13.5 + y)], "bottom-right": [-y, -1 * (38.1 - 13.5 + y)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
              }
              this._popup = a, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
            }
            return this;
          }
          setSubpixelPositioning(a) {
            return this._subpixelPositioning = a, this;
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const a = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : a ? (a.isOpen() ? a.remove() : (a.setLngLat(this._lngLat), a.addTo(this._map)), this) : this;
          }
          _updateOpacity() {
            let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
            var h, g;
            const y = (h = this._map) === null || h === void 0 ? void 0 : h.terrain, w = this._map.transform.isLocationOccluded(this._lngLat);
            if (!y || w) {
              const Q = w ? this._opacityWhenCovered : this._opacity;
              return void (this._element.style.opacity !== Q && (this._element.style.opacity = Q));
            }
            if (a) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout(() => {
                this._opacityTimeout = null;
              }, 100);
            }
            const C = this._map, P = C.terrain.depthAtPoint(this._pos), L = C.terrain.getElevationForLngLatZoom(this._lngLat, C.transform.tileZoom);
            if (C.transform.lngLatToCameraDepth(this._lngLat, L) - P < 6e-3) return void (this._element.style.opacity = this._opacity);
            const F = -this._offset.y / C.transform.pixelsPerMeter, j = Math.sin(C.getPitch() * Math.PI / 180) * F, X = C.terrain.depthAtPoint(new o.P(this._pos.x, this._pos.y - this._offset.y)), G = C.transform.lngLatToCameraDepth(this._lngLat, L + j) - X > 6e-3;
            !((g = this._popup) === null || g === void 0) && g.isOpen() && G && this._popup.remove(), this._element.style.opacity = G ? this._opacityWhenCovered : this._opacity;
          }
          getOffset() {
            return this._offset;
          }
          setOffset(a) {
            return this._offset = o.P.convert(a), this._update(), this;
          }
          addClassName(a) {
            this._element.classList.add(a);
          }
          removeClassName(a) {
            this._element.classList.remove(a);
          }
          toggleClassName(a) {
            return this._element.classList.toggle(a);
          }
          setDraggable(a) {
            return this._draggable = !!a, this._map && (a ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(a) {
            return this._rotation = a || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(a) {
            return this._rotationAlignment = a || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(a) {
            return this._pitchAlignment = a && a !== "auto" ? a : this._rotationAlignment, this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
          setOpacity(a, h) {
            return (this._opacity === void 0 || a === void 0 && h === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), a !== void 0 && (this._opacity = a), h !== void 0 && (this._opacityWhenCovered = h), this._map && this._updateOpacity(!0), this;
          }
        }
        const nf = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 };
        let pa = 0, jo = !1;
        const eu = { maxWidth: 100, unit: "metric" };
        function ho(v, a, h) {
          const g = h && h.maxWidth || 100, y = v._container.clientHeight / 2, w = v._container.clientWidth / 2, C = v.unproject([w - g / 2, y]), P = v.unproject([w + g / 2, y]), L = Math.round(v.project(P).x - v.project(C).x), F = Math.min(g, L, v._container.clientWidth), j = C.distanceTo(P);
          if (h && h.unit === "imperial") {
            const X = 3.2808 * j;
            X > 5280 ? Vo(a, F, X / 5280, v._getUIString("ScaleControl.Miles")) : Vo(a, F, X, v._getUIString("ScaleControl.Feet"));
          } else h && h.unit === "nautical" ? Vo(a, F, j / 1852, v._getUIString("ScaleControl.NauticalMiles")) : j >= 1e3 ? Vo(a, F, j / 1e3, v._getUIString("ScaleControl.Kilometers")) : Vo(a, F, j, v._getUIString("ScaleControl.Meters"));
        }
        function Vo(v, a, h, g) {
          const y = function(w) {
            const C = Math.pow(10, `${Math.floor(w)}`.length - 1);
            let P = w / C;
            return P = P >= 10 ? 10 : P >= 5 ? 5 : P >= 3 ? 3 : P >= 2 ? 2 : P >= 1 ? 1 : function(L) {
              const F = Math.pow(10, Math.ceil(-Math.log(L) / Math.LN10));
              return Math.round(L * F) / F;
            }(P), C * P;
          }(h);
          v.style.width = a * (y / h) + "px", v.innerHTML = `${y}&nbsp;${g}`;
        }
        const ka = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px", subpixelPositioning: !1, locationOccludedOpacity: void 0 }, yh = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function oc(v) {
          if (v) {
            if (typeof v == "number") {
              const a = Math.round(Math.abs(v) / Math.SQRT2);
              return { center: new o.P(0, 0), top: new o.P(0, v), "top-left": new o.P(a, a), "top-right": new o.P(-a, a), bottom: new o.P(0, -v), "bottom-left": new o.P(a, -a), "bottom-right": new o.P(-a, -a), left: new o.P(v, 0), right: new o.P(-v, 0) };
            }
            if (v instanceof o.P || Array.isArray(v)) {
              const a = o.P.convert(v);
              return { center: a, top: a, "top-left": a, "top-right": a, bottom: a, "bottom-left": a, "bottom-right": a, left: a, right: a };
            }
            return { center: o.P.convert(v.center || [0, 0]), top: o.P.convert(v.top || [0, 0]), "top-left": o.P.convert(v["top-left"] || [0, 0]), "top-right": o.P.convert(v["top-right"] || [0, 0]), bottom: o.P.convert(v.bottom || [0, 0]), "bottom-left": o.P.convert(v["bottom-left"] || [0, 0]), "bottom-right": o.P.convert(v["bottom-right"] || [0, 0]), left: o.P.convert(v.left || [0, 0]), right: o.P.convert(v.right || [0, 0]) };
          }
          return oc(new o.P(0, 0));
        }
        const bh = d;
        l.AJAXError = o.cy, l.Event = o.l, l.Evented = o.E, l.LngLat = o.S, l.MercatorCoordinate = o.a0, l.Point = o.P, l.addProtocol = o.cz, l.config = o.a, l.removeProtocol = o.cA, l.AttributionControl = ws, l.BoxZoomHandler = rf, l.CanvasSource = mr, l.CooperativeGesturesHandler = Fn, l.DoubleClickZoomHandler = Ht, l.DragPanHandler = $r, l.DragRotateHandler = br, l.EdgeInsets = qs, l.FullscreenControl = class extends o.E {
          constructor() {
            let v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            super(), this._onFullscreenChange = () => {
              var a;
              let h = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; !((a = h == null ? void 0 : h.shadowRoot) === null || a === void 0) && a.fullscreenElement; ) h = h.shadowRoot.fullscreenElement;
              h === this._container !== this._fullscreen && this._handleFullscreenChange();
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
            }, this._fullscreen = !1, v && v.container && (v.container instanceof HTMLElement ? this._container = v.container : o.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
          }
          onAdd(v) {
            return this._map = v, this._container || (this._container = this._map.getContainer()), this._controlContainer = E.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
          }
          onRemove() {
            E.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _setupUI() {
            const v = this._fullscreenButton = E.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            E.create("span", "maplibregl-ctrl-icon", v).setAttribute("aria-hidden", "true"), v.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _updateTitle() {
            const v = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", v), this._fullscreenButton.title = v;
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new o.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new o.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
          }
        }, l.GeoJSONSource = Tr, l.GeolocateControl = class extends o.E {
          constructor(v) {
            super(), this._onSuccess = (a) => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(a)) return this._setErrorState(), this.fire(new o.l("outofmaxbounds", a)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = a, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(a), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(a), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new o.l("geolocate", a)), this._finish();
              }
            }, this._updateCamera = (a) => {
              const h = new o.S(a.coords.longitude, a.coords.latitude), g = a.coords.accuracy, y = this._map.getBearing(), w = o.e({ bearing: y }, this.options.fitBoundsOptions), C = sr.fromLngLat(h, g);
              this._map.fitBounds(C, w, { geolocateSource: !0 });
            }, this._updateMarker = (a) => {
              if (a) {
                const h = new o.S(a.coords.longitude, a.coords.latitude);
                this._accuracyCircleMarker.setLngLat(h).addTo(this._map), this._userLocationDotMarker.setLngLat(h).addTo(this._map), this._accuracy = a.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }, this._onZoom = () => {
              this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            }, this._onError = (a) => {
              if (this._map) {
                if (a.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                  const h = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = h, this._geolocateButton.setAttribute("aria-label", h), this._geolocationWatchID !== void 0 && this._clearWatch();
                } else {
                  if (a.code === 3 && jo) return;
                  this.options.trackUserLocation && this._setErrorState();
                }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new o.l("error", a)), this._finish();
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", (a) => a.preventDefault()), this._geolocateButton = E.create("button", "maplibregl-ctrl-geolocate", this._container), E.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0);
            }, this._finishSetupUI = (a) => {
              if (this._map) {
                if (a === !1) {
                  o.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const h = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = !0, this._geolocateButton.title = h, this._geolocateButton.setAttribute("aria-label", h);
                } else {
                  const h = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = !1, this._geolocateButton.title = h, this._geolocateButton.setAttribute("aria-label", h);
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = E.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new pi({ element: this._dotElement }), this._circleElement = E.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new pi({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (h) => {
                  h.geolocateSource || this._watchState !== "ACTIVE_LOCK" || h.originalEvent && h.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new o.l("trackuserlocationend")), this.fire(new o.l("userlocationlostfocus")));
                });
              }
            }, this.options = o.e({}, nf, v);
          }
          onAdd(v) {
            return this._map = v, this._container = E.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function() {
              return o._(this, arguments, void 0, function() {
                let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
                return function* () {
                  if (ki !== void 0 && !a) return ki;
                  if (window.navigator.permissions === void 0) return ki = !!window.navigator.geolocation, ki;
                  try {
                    ki = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
                  } catch {
                    ki = !!window.navigator.geolocation;
                  }
                  return ki;
                }();
              });
            }().then((a) => this._finishSetupUI(a)), this._container;
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), E.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, pa = 0, jo = !1;
          }
          _isOutOfMapMaxBounds(v) {
            const a = this._map.getMaxBounds(), h = v.coords;
            return a && (h.longitude < a.getWest() || h.longitude > a.getEast() || h.latitude < a.getSouth() || h.latitude > a.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
          }
          _updateCircleRadius() {
            const v = this._map.getBounds(), a = v.getSouthEast(), h = v.getNorthEast(), g = a.distanceTo(h), y = Math.ceil(this._accuracy / (g / this._map._container.clientHeight) * 2);
            this._circleElement.style.width = `${y}px`, this._circleElement.style.height = `${y}px`;
          }
          trigger() {
            if (!this._setup) return o.w("Geolocate control triggered before added to a map"), !1;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new o.l("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  pa--, jo = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new o.l("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new o.l("trackuserlocationstart")), this.fire(new o.l("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let v;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), pa++, pa > 1 ? (v = { maximumAge: 6e5, timeout: 0 }, jo = !0) : (v = this.options.positionOptions, jo = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, v);
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return !0;
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, l.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var v;
              const a = (v = this._map.getProjection()) === null || v === void 0 ? void 0 : v.type;
              this._map.setProjection(a !== "mercator" && a ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
            }, this._updateGlobeIcon = () => {
              var v;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((v = this._map.getProjection()) === null || v === void 0 ? void 0 : v.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
            };
          }
          onAdd(v) {
            return this._map = v, this._container = E.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = E.create("button", "maplibregl-ctrl-globe", this._container), E.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
          }
          onRemove() {
            E.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0;
          }
        }, l.Hash = zu, l.ImageSource = Yt, l.KeyboardHandler = kt, l.LngLatBounds = sr, l.LogoControl = Bi, l.Map = class extends Br {
          constructor(v) {
            var a, h;
            o.cv.mark(o.cw.create);
            const g = Object.assign(Object.assign(Object.assign({}, Oi), v), { canvasContextAttributes: Object.assign(Object.assign({}, Oi.canvasContextAttributes), v.canvasContextAttributes) });
            if (g.minZoom != null && g.maxZoom != null && g.minZoom > g.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (g.minPitch != null && g.maxPitch != null && g.minPitch > g.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (g.minPitch != null && g.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (g.maxPitch != null && g.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const y = new zn(), w = new wl();
            if (g.minZoom !== void 0 && y.setMinZoom(g.minZoom), g.maxZoom !== void 0 && y.setMaxZoom(g.maxZoom), g.minPitch !== void 0 && y.setMinPitch(g.minPitch), g.maxPitch !== void 0 && y.setMaxPitch(g.maxPitch), g.renderWorldCopies !== void 0 && y.setRenderWorldCopies(g.renderWorldCopies), super(y, w, { bearingSnap: g.bearingSnap }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new Zs(), this._controls = [], this._mapId = o.a6(), this._contextLost = (P) => {
              P.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new o.l("webglcontextlost", { originalEvent: P }));
            }, this._contextRestored = (P) => {
              this._setupPainter(), this.resize(), this._update(), this.fire(new o.l("webglcontextrestored", { originalEvent: P }));
            }, this._onMapScroll = (P) => {
              if (P.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
            }, this._onWindowOnline = () => {
              this._update();
            }, this._interactive = g.interactive, this._maxTileCacheSize = g.maxTileCacheSize, this._maxTileCacheZoomLevels = g.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, g.canvasContextAttributes), this._trackResize = g.trackResize === !0, this._bearingSnap = g.bearingSnap, this._centerClampedToGround = g.centerClampedToGround, this._refreshExpiredTiles = g.refreshExpiredTiles === !0, this._fadeDuration = g.fadeDuration, this._crossSourceCollisions = g.crossSourceCollisions === !0, this._collectResourceTiming = g.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, Ys), g.locale), this._clickTolerance = g.clickTolerance, this._overridePixelRatio = g.pixelRatio, this._maxCanvasSize = g.maxCanvasSize, this.transformCameraUpdate = g.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = g.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = Z.addThrottleControl(() => this.isMoving()), this._requestManager = new K(g.transformRequest), typeof g.container == "string") {
              if (this._container = document.getElementById(g.container), !this._container) throw new Error(`Container '${g.container}' not found.`);
            } else {
              if (!(g.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = g.container;
            }
            if (g.maxBounds && this.setMaxBounds(g.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(!1)), this.on("moveend", () => this._update(!1)), this.on("zoom", () => this._update(!0)), this.on("terrain", () => {
              this.painter.terrainFacilitator.dirty = !0, this._update(!0);
            }), this.once("idle", () => {
              this._idleTriggered = !0;
            }), typeof window < "u") {
              addEventListener("online", this._onWindowOnline, !1);
              let P = !1;
              const L = Xs((F) => {
                this._trackResize && !this._removed && (this.resize(F), this.redraw());
              }, 50);
              this._resizeObserver = new ResizeObserver((F) => {
                P ? L(F) : P = !0;
              }), this._resizeObserver.observe(this._container);
            }
            this.handlers = new Cn(this, g), this._hash = g.hash && new zu(typeof g.hash == "string" && g.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: g.center, elevation: g.elevation, zoom: g.zoom, bearing: g.bearing, pitch: g.pitch, roll: g.roll }), g.bounds && (this.resize(), this.fitBounds(g.bounds, o.e({}, g.fitBoundsOptions, { duration: 0 }))));
            const C = typeof g.style == "string" || ((h = (a = g.style) === null || a === void 0 ? void 0 : a.projection) === null || h === void 0 ? void 0 : h.type) !== "globe";
            this.resize(null, C), this._localIdeographFontFamily = g.localIdeographFontFamily, this._validateStyle = g.validateStyle, g.style && this.setStyle(g.style, { localIdeographFontFamily: g.localIdeographFontFamily }), g.attributionControl && this.addControl(new ws(typeof g.attributionControl == "boolean" ? void 0 : g.attributionControl)), g.maplibreLogo && this.addControl(new Bi(), g.logoPosition), this.on("style.load", () => {
              if (C || this._resizeTransform(), this.transform.unmodified) {
                const P = o.Q(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(P);
              }
            }), this.on("data", (P) => {
              this._update(P.dataType === "style"), this.fire(new o.l(`${P.dataType}data`, P));
            }), this.on("dataloading", (P) => {
              this.fire(new o.l(`${P.dataType}dataloading`, P));
            }), this.on("dataabort", (P) => {
              this.fire(new o.l("sourcedataabort", P));
            });
          }
          _getMapId() {
            return this._mapId;
          }
          setGlobalStateProperty(v, a) {
            return this.style.setGlobalStateProperty(v, a), this._update(!0);
          }
          getGlobalState() {
            return this.style.getGlobalState();
          }
          addControl(v, a) {
            if (a === void 0 && (a = v.getDefaultPosition ? v.getDefaultPosition() : "top-right"), !v || !v.onAdd) return this.fire(new o.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const h = v.onAdd(this);
            this._controls.push(v);
            const g = this._controlPositions[a];
            return a.indexOf("bottom") !== -1 ? g.insertBefore(h, g.firstChild) : g.appendChild(h), this;
          }
          removeControl(v) {
            if (!v || !v.onRemove) return this.fire(new o.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const a = this._controls.indexOf(v);
            return a > -1 && this._controls.splice(a, 1), v.onRemove(this), this;
          }
          hasControl(v) {
            return this._controls.indexOf(v) > -1;
          }
          calculateCameraOptionsFromTo(v, a, h, g) {
            return g == null && this.terrain && (g = this.terrain.getElevationForLngLatZoom(h, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(v, a, h, g);
          }
          resize(v) {
            let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
            const [h, g] = this._containerDimensions(), y = this._getClampedPixelRatio(h, g);
            if (this._resizeCanvas(h, g, y), this.painter.resize(h, g, y), this.painter.overLimit()) {
              const C = this.painter.context.gl;
              this._maxCanvasSize = [C.drawingBufferWidth, C.drawingBufferHeight];
              const P = this._getClampedPixelRatio(h, g);
              this._resizeCanvas(h, g, P), this.painter.resize(h, g, P);
            }
            this._resizeTransform(a);
            const w = !this._moving;
            return w && (this.stop(), this.fire(new o.l("movestart", v)).fire(new o.l("move", v))), this.fire(new o.l("resize", v)), w && this.fire(new o.l("moveend", v)), this;
          }
          _resizeTransform() {
            let v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
            var a;
            const [h, g] = this._containerDimensions();
            this.transform.resize(h, g, v), (a = this._requestedCameraState) === null || a === void 0 || a.resize(h, g, v);
          }
          _getClampedPixelRatio(v, a) {
            const { 0: h, 1: g } = this._maxCanvasSize, y = this.getPixelRatio(), w = v * y, C = a * y;
            return Math.min(w > h ? h / w : 1, C > g ? g / C : 1) * y;
          }
          getPixelRatio() {
            var v;
            return (v = this._overridePixelRatio) !== null && v !== void 0 ? v : devicePixelRatio;
          }
          setPixelRatio(v) {
            this._overridePixelRatio = v, this.resize();
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds();
          }
          setMaxBounds(v) {
            return this.transform.setMaxBounds(sr.convert(v)), this._update();
          }
          setMinZoom(v) {
            if ((v = v ?? -2) >= -2 && v <= this.transform.maxZoom) return this.transform.setMinZoom(v), this._update(), this.getZoom() < v && this.setZoom(v), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(v) {
            if ((v = v ?? 22) >= this.transform.minZoom) return this.transform.setMaxZoom(v), this._update(), this.getZoom() > v && this.setZoom(v), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(v) {
            if ((v = v ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (v >= 0 && v <= this.transform.maxPitch) return this.transform.setMinPitch(v), this._update(), this.getPitch() < v && this.setPitch(v), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(v) {
            if ((v = v ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (v >= this.transform.minPitch) return this.transform.setMaxPitch(v), this._update(), this.getPitch() > v && this.setPitch(v), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(v) {
            return this.transform.setRenderWorldCopies(v), this._update();
          }
          project(v) {
            return this.transform.locationToScreenPoint(o.S.convert(v), this.style && this.terrain);
          }
          unproject(v) {
            return this.transform.screenPointToLocation(o.P.convert(v), this.terrain);
          }
          isMoving() {
            var v;
            return this._moving || ((v = this.handlers) === null || v === void 0 ? void 0 : v.isMoving());
          }
          isZooming() {
            var v;
            return this._zooming || ((v = this.handlers) === null || v === void 0 ? void 0 : v.isZooming());
          }
          isRotating() {
            var v;
            return this._rotating || ((v = this.handlers) === null || v === void 0 ? void 0 : v.isRotating());
          }
          _createDelegatedListener(v, a, h) {
            if (v === "mouseenter" || v === "mouseover") {
              let g = !1;
              return { layers: a, listener: h, delegates: { mousemove: (w) => {
                const C = a.filter((L) => this.getLayer(L)), P = C.length !== 0 ? this.queryRenderedFeatures(w.point, { layers: C }) : [];
                P.length ? g || (g = !0, h.call(this, new Bs(v, this, w.originalEvent, { features: P }))) : g = !1;
              }, mouseout: () => {
                g = !1;
              } } };
            }
            if (v === "mouseleave" || v === "mouseout") {
              let g = !1;
              return { layers: a, listener: h, delegates: { mousemove: (C) => {
                const P = a.filter((L) => this.getLayer(L));
                (P.length !== 0 ? this.queryRenderedFeatures(C.point, { layers: P }) : []).length ? g = !0 : g && (g = !1, h.call(this, new Bs(v, this, C.originalEvent)));
              }, mouseout: (C) => {
                g && (g = !1, h.call(this, new Bs(v, this, C.originalEvent)));
              } } };
            }
            {
              const g = (y) => {
                const w = a.filter((P) => this.getLayer(P)), C = w.length !== 0 ? this.queryRenderedFeatures(y.point, { layers: w }) : [];
                C.length && (y.features = C, h.call(this, y), delete y.features);
              };
              return { layers: a, listener: h, delegates: { [v]: g } };
            }
          }
          _saveDelegatedListener(v, a) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[v] = this._delegatedListeners[v] || [], this._delegatedListeners[v].push(a);
          }
          _removeDelegatedListener(v, a, h) {
            if (!this._delegatedListeners || !this._delegatedListeners[v]) return;
            const g = this._delegatedListeners[v];
            for (let y = 0; y < g.length; y++) {
              const w = g[y];
              if (w.listener === h && w.layers.length === a.length && w.layers.every((C) => a.includes(C))) {
                for (const C in w.delegates) this.off(C, w.delegates[C]);
                return void g.splice(y, 1);
              }
            }
          }
          on(v, a, h) {
            if (h === void 0) return super.on(v, a);
            const g = typeof a == "string" ? [a] : a, y = this._createDelegatedListener(v, g, h);
            this._saveDelegatedListener(v, y);
            for (const w in y.delegates) this.on(w, y.delegates[w]);
            return { unsubscribe: () => {
              this._removeDelegatedListener(v, g, h);
            } };
          }
          once(v, a, h) {
            var g = this;
            if (h === void 0) return super.once(v, a);
            const y = typeof a == "string" ? [a] : a, w = this._createDelegatedListener(v, y, h);
            for (const C in w.delegates) {
              const P = w.delegates[C];
              w.delegates[C] = function() {
                g._removeDelegatedListener(v, y, h), P(...arguments);
              };
            }
            this._saveDelegatedListener(v, w);
            for (const C in w.delegates) this.once(C, w.delegates[C]);
            return this;
          }
          off(v, a, h) {
            return h === void 0 ? super.off(v, a) : (this._removeDelegatedListener(v, typeof a == "string" ? [a] : a, h), this);
          }
          queryRenderedFeatures(v, a) {
            if (!this.style) return [];
            let h;
            const g = v instanceof o.P || Array.isArray(v), y = g ? v : [[0, 0], [this.transform.width, this.transform.height]];
            if (a = a || (g ? {} : v) || {}, y instanceof o.P || typeof y[0] == "number") h = [o.P.convert(y)];
            else {
              const w = o.P.convert(y[0]), C = o.P.convert(y[1]);
              h = [w, new o.P(C.x, w.y), C, new o.P(w.x, C.y), w];
            }
            return this.style.queryRenderedFeatures(h, a, this.transform);
          }
          querySourceFeatures(v, a) {
            return this.style.querySourceFeatures(v, a);
          }
          setStyle(v, a) {
            return (a = o.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, a)).diff !== !1 && a.localIdeographFontFamily === this._localIdeographFontFamily && this.style && v ? (this._diffStyle(v, a), this) : (this._localIdeographFontFamily = a.localIdeographFontFamily, this._updateStyle(v, a));
          }
          setTransformRequest(v) {
            return this._requestManager.setTransformRequest(v), this;
          }
          _getUIString(v) {
            const a = this._locale[v];
            if (a == null) throw new Error(`Missing UI string '${v}'`);
            return a;
          }
          _updateStyle(v, a) {
            var h, g;
            if (a.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", () => this._updateStyle(v, a));
            const y = this.style && a.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!v)), v ? (this.style = new O(this, a || {}), this.style.setEventedParent(this, { style: this.style }), typeof v == "string" ? this.style.loadURL(v, a, y) : this.style.loadJSON(v, a, y), this) : ((g = (h = this.style) === null || h === void 0 ? void 0 : h.projection) === null || g === void 0 || g.destroy(), delete this.style, this);
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new O(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(v, a) {
            if (typeof v == "string") {
              const h = this._requestManager.transformRequest(v, "Style");
              o.j(h, new AbortController()).then((g) => {
                this._updateDiff(g.data, a);
              }).catch((g) => {
                g && this.fire(new o.k(g));
              });
            } else typeof v == "object" && this._updateDiff(v, a);
          }
          _updateDiff(v, a) {
            try {
              this.style.setState(v, a) && this._update(!0);
            } catch (h) {
              o.w(`Unable to perform style diff: ${h.message || h.error || h}.  Rebuilding the style from scratch.`), this._updateStyle(v, a);
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : o.w("There is no style added to the map.");
          }
          addSource(v, a) {
            return this._lazyInitEmptyStyle(), this.style.addSource(v, a), this._update(!0);
          }
          isSourceLoaded(v) {
            const a = this.style && this.style.sourceCaches[v];
            if (a !== void 0) return a.loaded();
            this.fire(new o.k(new Error(`There is no source with ID '${v}'`)));
          }
          setTerrain(v) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), v) {
              const a = this.style.sourceCaches[v.source];
              if (!a) throw new Error(`cannot load terrain, because there exists no source with ID: ${v.source}`);
              this.terrain === null && a.reload();
              for (const h in this.style._layers) {
                const g = this.style._layers[h];
                g.type === "hillshade" && g.source === v.source && o.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), g.type === "color-relief" && g.source === v.source && o.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
              }
              this.terrain = new Li(this.painter, a, v), this.painter.renderToTexture = new Ir(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (h) => {
                var g;
                h.dataType === "style" ? this.terrain.sourceCache.freeRtt() : h.dataType === "source" && h.tile && (h.sourceId !== v.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((g = h.source) === null || g === void 0 ? void 0 : g.type) === "image" ? this.terrain.sourceCache.freeRtt() : this.terrain.sourceCache.freeRtt(h.tile.tileID));
              }, this.style.on("data", this._terrainDataCallback);
            } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new o.l("terrain", { terrain: v })), this;
          }
          getTerrain() {
            var v, a;
            return (a = (v = this.terrain) === null || v === void 0 ? void 0 : v.options) !== null && a !== void 0 ? a : null;
          }
          areTilesLoaded() {
            const v = this.style && this.style.sourceCaches;
            for (const a in v) {
              const h = v[a]._tiles;
              for (const g in h) {
                const y = h[g];
                if (y.state !== "loaded" && y.state !== "errored") return !1;
              }
            }
            return !0;
          }
          removeSource(v) {
            return this.style.removeSource(v), this._update(!0);
          }
          getSource(v) {
            return this.style.getSource(v);
          }
          setSourceTileLodParams(v, a, h) {
            if (h) {
              const g = this.getSource(h);
              if (!g) throw new Error(`There is no source with ID "${h}", cannot set LOD parameters`);
              g.calculateTileZoom = gt(Math.max(1, v), Math.max(1, a));
            } else for (const g in this.style.sourceCaches) this.style.sourceCaches[g].getSource().calculateTileZoom = gt(Math.max(1, v), Math.max(1, a));
            return this._update(!0), this;
          }
          refreshTiles(v, a) {
            const h = this.style.sourceCaches[v];
            if (!h) throw new Error(`There is no source cache with ID "${v}", cannot refresh tile`);
            a === void 0 ? h.reload(!0) : h.refreshTiles(a.map((g) => new o.a3(g.z, g.x, g.y)));
          }
          addImage(v, a) {
            let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            const { pixelRatio: g = 1, sdf: y = !1, stretchX: w, stretchY: C, content: P, textFitWidth: L, textFitHeight: F } = h;
            if (this._lazyInitEmptyStyle(), !(a instanceof HTMLImageElement || o.b(a))) {
              if (a.width === void 0 || a.height === void 0) return this.fire(new o.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const { width: j, height: X, data: G } = a, Q = a;
                return this.style.addImage(v, { data: new o.R({ width: j, height: X }, new Uint8Array(G)), pixelRatio: g, stretchX: w, stretchY: C, content: P, textFitWidth: L, textFitHeight: F, sdf: y, version: 0, userImage: Q }), Q.onAdd && Q.onAdd(this, v), this;
              }
            }
            {
              const { width: j, height: X, data: G } = M.getImageData(a);
              this.style.addImage(v, { data: new o.R({ width: j, height: X }, G), pixelRatio: g, stretchX: w, stretchY: C, content: P, textFitWidth: L, textFitHeight: F, sdf: y, version: 0 });
            }
          }
          updateImage(v, a) {
            const h = this.style.getImage(v);
            if (!h) return this.fire(new o.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const g = a instanceof HTMLImageElement || o.b(a) ? M.getImageData(a) : a, { width: y, height: w, data: C } = g;
            if (y === void 0 || w === void 0) return this.fire(new o.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (y !== h.data.width || w !== h.data.height) return this.fire(new o.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const P = !(a instanceof HTMLImageElement || o.b(a));
            return h.data.replace(C, P), this.style.updateImage(v, h), this;
          }
          getImage(v) {
            return this.style.getImage(v);
          }
          hasImage(v) {
            return v ? !!this.style.getImage(v) : (this.fire(new o.k(new Error("Missing required image id"))), !1);
          }
          removeImage(v) {
            this.style.removeImage(v);
          }
          loadImage(v) {
            return Z.getImage(this._requestManager.transformRequest(v, "Image"), new AbortController());
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(v, a) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(v, a), this._update(!0);
          }
          moveLayer(v, a) {
            return this.style.moveLayer(v, a), this._update(!0);
          }
          removeLayer(v) {
            return this.style.removeLayer(v), this._update(!0);
          }
          getLayer(v) {
            return this.style.getLayer(v);
          }
          getLayersOrder() {
            return this.style.getLayersOrder();
          }
          setLayerZoomRange(v, a, h) {
            return this.style.setLayerZoomRange(v, a, h), this._update(!0);
          }
          setFilter(v, a) {
            let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return this.style.setFilter(v, a, h), this._update(!0);
          }
          getFilter(v) {
            return this.style.getFilter(v);
          }
          setPaintProperty(v, a, h) {
            let g = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            return this.style.setPaintProperty(v, a, h, g), this._update(!0);
          }
          getPaintProperty(v, a) {
            return this.style.getPaintProperty(v, a);
          }
          setLayoutProperty(v, a, h) {
            let g = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            return this.style.setLayoutProperty(v, a, h, g), this._update(!0);
          }
          getLayoutProperty(v, a) {
            return this.style.getLayoutProperty(v, a);
          }
          setGlyphs(v) {
            let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(v, a), this._update(!0);
          }
          getGlyphs() {
            return this.style.getGlyphsUrl();
          }
          addSprite(v, a) {
            let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return this._lazyInitEmptyStyle(), this.style.addSprite(v, a, h, (g) => {
              g || this._update(!0);
            }), this;
          }
          removeSprite(v) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(v), this._update(!0);
          }
          getSprite() {
            return this.style.getSprite();
          }
          setSprite(v) {
            let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return this._lazyInitEmptyStyle(), this.style.setSprite(v, a, (h) => {
              h || this._update(!0);
            }), this;
          }
          setLight(v) {
            let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return this._lazyInitEmptyStyle(), this.style.setLight(v, a), this._update(!0);
          }
          getLight() {
            return this.style.getLight();
          }
          setSky(v) {
            let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return this._lazyInitEmptyStyle(), this.style.setSky(v, a), this._update(!0);
          }
          getSky() {
            return this.style.getSky();
          }
          setFeatureState(v, a) {
            return this.style.setFeatureState(v, a), this._update();
          }
          removeFeatureState(v, a) {
            return this.style.removeFeatureState(v, a), this._update();
          }
          getFeatureState(v) {
            return this.style.getFeatureState(v);
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          _containerDimensions() {
            let v = 0, a = 0;
            return this._container && (v = this._container.clientWidth || 400, a = this._container.clientHeight || 300), [v, a];
          }
          _setupContainer() {
            const v = this._container;
            v.classList.add("maplibregl-map");
            const a = this._canvasContainer = E.create("div", "maplibregl-canvas-container", v);
            this._interactive && a.classList.add("maplibregl-interactive"), this._canvas = E.create("canvas", "maplibregl-canvas", a), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const h = this._containerDimensions(), g = this._getClampedPixelRatio(h[0], h[1]);
            this._resizeCanvas(h[0], h[1], g);
            const y = this._controlContainer = E.create("div", "maplibregl-control-container", v), w = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((C) => {
              w[C] = E.create("div", `maplibregl-ctrl-${C} `, y);
            }), this._container.addEventListener("scroll", this._onMapScroll, !1);
          }
          _resizeCanvas(v, a, h) {
            this._canvas.width = Math.floor(h * v), this._canvas.height = Math.floor(h * a), this._canvas.style.width = `${v}px`, this._canvas.style.height = `${a}px`;
          }
          _setupPainter() {
            const v = Object.assign(Object.assign({}, this._canvasContextAttributes), { alpha: !0, depth: !0, stencil: !0, premultipliedAlpha: !0 });
            let a = null;
            this._canvas.addEventListener("webglcontextcreationerror", (g) => {
              a = { requestedAttributes: v }, g && (a.statusMessage = g.statusMessage, a.type = g.type);
            }, { once: !0 });
            let h = null;
            if (h = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, v) : this._canvas.getContext("webgl2", v) || this._canvas.getContext("webgl", v), !h) {
              const g = "Failed to initialize WebGL";
              throw a ? (a.message = g, new Error(JSON.stringify(a))) : new Error(g);
            }
            this.painter = new Ki(h, this.transform), k.testSupport(h);
          }
          migrateProjection(v, a) {
            super.migrateProjection(v, a), this.painter.transform = v, this.fire(new o.l("projectiontransition", { newProjection: this.style.projection.name }));
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(v) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || v, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(v) {
            return this._update(), this._renderTaskQueue.add(v);
          }
          _cancelRenderFrame(v) {
            this._renderTaskQueue.remove(v);
          }
          _render(v) {
            var a, h, g, y, w;
            const C = this._idleTriggered ? this._fadeDuration : 0, P = ((a = this.style.projection) === null || a === void 0 ? void 0 : a.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(v), this._removed) return;
            let L = !1;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              const X = this.transform.zoom, G = M.now();
              this.style.zoomHistory.update(X, G);
              const Q = new o.F(X, { now: G, fadeDuration: C, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition(), globalState: this.style.getGlobalState() }), le = Q.crossFadingFactor();
              le === 1 && le === this._crossFadingFactor || (L = !0, this._crossFadingFactor = le), this.style.update(Q);
            }
            const F = ((h = this.style.projection) === null || h === void 0 ? void 0 : h.transitionState) > 0 !== P;
            (g = this.style.projection) === null || g === void 0 || g.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((y = this.style.projection) === null || y === void 0 ? void 0 : y.transitionState, (w = this.style.projection) === null || w === void 0 ? void 0 : w.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || F) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, C, this._crossSourceCollisions, F), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: C, showPadding: this.showPadding }), this.fire(new o.l("render")), this.loaded() && !this._loaded && (this._loaded = !0, o.cv.mark(o.cw.load), this.fire(new o.l("load"))), this.style && (this.style.hasTransitions() || L) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const j = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return j || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new o.l("idle")), !this._loaded || this._fullyLoaded || j || (this._fullyLoaded = !0, o.cv.mark(o.cw.fullLoad)), this;
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
          }
          remove() {
            var v;
            this._hash && this._hash.remove();
            for (const h of this._controls) h.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), Z.removeThrottleControl(this._imageQueueHandle), (v = this._resizeObserver) === null || v === void 0 || v.disconnect();
            const a = this.painter.context.gl.getExtension("WEBGL_lose_context");
            a != null && a.loseContext && a.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), E.remove(this._canvasContainer), E.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), o.cv.clearMetrics(), this._removed = !0, this.fire(new o.l("remove"));
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController(), M.frame(this._frameRequest, (v) => {
              o.cv.frame(v), this._frameRequest = null;
              try {
                this._render(v);
              } catch (a) {
                if (!o.cx(a) && !function(h) {
                  return h.message === co;
                }(a)) throw a;
              }
            }, () => {
            }));
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(v) {
            this._showTileBoundaries !== v && (this._showTileBoundaries = v, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(v) {
            this._showPadding !== v && (this._showPadding = v, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(v) {
            this._showCollisionBoxes !== v && (this._showCollisionBoxes = v, v ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(v) {
            this._showOverdrawInspector !== v && (this._showOverdrawInspector = v, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(v) {
            this._repaint !== v && (this._repaint = v, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(v) {
            this._vertices = v, this._update();
          }
          get version() {
            return zo;
          }
          getCameraTargetElevation() {
            return this.transform.elevation;
          }
          getProjection() {
            return this.style.getProjection();
          }
          setProjection(v) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(v), this._update(!0);
          }
        }, l.MapMouseEvent = Bs, l.MapTouchEvent = da, l.MapWheelEvent = mh, l.Marker = pi, l.NavigationControl = class {
          constructor(v) {
            this._updateZoomButtons = () => {
              const a = this._map.getZoom(), h = a === this._map.getMaxZoom(), g = a === this._map.getMinZoom();
              this._zoomInButton.disabled = h, this._zoomOutButton.disabled = g, this._zoomInButton.setAttribute("aria-disabled", h.toString()), this._zoomOutButton.setAttribute("aria-disabled", g.toString());
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
            }, this._setButtonTitle = (a, h) => {
              const g = this._map._getUIString(`NavigationControl.${h}`);
              a.title = g, a.setAttribute("aria-label", g);
            }, this.options = o.e({}, Ei, v), this._container = E.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (a) => a.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (a) => this._map.zoomIn({}, { originalEvent: a })), E.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (a) => this._map.zoomOut({}, { originalEvent: a })), E.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (a) => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: a }) : this._map.resetNorth({}, { originalEvent: a });
            }), this._compassIcon = E.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          onAdd(v) {
            return this._map = v, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Pl(this._map, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            E.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
          }
          _createButton(v, a) {
            const h = E.create("button", v, this._container);
            return h.type = "button", h.addEventListener("click", a), h;
          }
        }, l.Popup = class extends o.E {
          constructor(v) {
            super(), this._updateOpacity = () => {
              this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : void 0);
            }, this.remove = () => (this._content && E.remove(this._content), this._container && (E.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new o.l("close"))), this), this._onMouseUp = (a) => {
              this._update(a.point);
            }, this._onMouseMove = (a) => {
              this._update(a.point);
            }, this._onDrag = (a) => {
              this._update(a.point);
            }, this._update = (a) => {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = E.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = E.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const C of this.options.className.split(" ")) this._container.classList.add(C);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = sl(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !a) return;
              const h = this._flatPos = this._pos = this._trackPointer && a ? a : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && a ? a : this._map.transform.locationToScreenPoint(this._lngLat));
              let g = this.options.anchor;
              const y = oc(this.options.offset);
              if (!g) {
                const C = this._container.offsetWidth, P = this._container.offsetHeight;
                let L;
                L = h.y + y.bottom.y < P ? ["top"] : h.y > this._map.transform.height - P ? ["bottom"] : [], h.x < C / 2 ? L.push("left") : h.x > this._map.transform.width - C / 2 && L.push("right"), g = L.length === 0 ? "bottom" : L.join("-");
              }
              let w = h.add(y[g]);
              this.options.subpixelPositioning || (w = w.round()), E.setTransform(this._container, `${Wn[g]} translate(${w.x}px,${w.y}px)`), ri(this._container, g, "popup"), this._updateOpacity();
            }, this._onClose = () => {
              this.remove();
            }, this.options = o.e(Object.create(ka), v);
          }
          addTo(v) {
            return this._map && this.remove(), this._map = v, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new o.l("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(v) {
            return this._lngLat = o.S.convert(v), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
          }
          trackPointer() {
            return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(v) {
            return this.setDOMContent(document.createTextNode(v));
          }
          setHTML(v) {
            const a = document.createDocumentFragment(), h = document.createElement("body");
            let g;
            for (h.innerHTML = v; g = h.firstChild, g; ) a.appendChild(g);
            return this.setDOMContent(a);
          }
          getMaxWidth() {
            var v;
            return (v = this._container) === null || v === void 0 ? void 0 : v.style.maxWidth;
          }
          setMaxWidth(v) {
            return this.options.maxWidth = v, this._update(), this;
          }
          setDOMContent(v) {
            if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = E.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(v), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }
          addClassName(v) {
            return this._container && this._container.classList.add(v), this;
          }
          removeClassName(v) {
            return this._container && this._container.classList.remove(v), this;
          }
          setOffset(v) {
            return this.options.offset = v, this._update(), this;
          }
          toggleClassName(v) {
            if (this._container) return this._container.classList.toggle(v);
          }
          setSubpixelPositioning(v) {
            this.options.subpixelPositioning = v;
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = E.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const v = this._container.querySelector(yh);
            v && v.focus();
          }
        }, l.RasterDEMTileSource = Dr, l.RasterTileSource = We, l.ScaleControl = class {
          constructor(v) {
            this._onMove = () => {
              ho(this._map, this._container, this.options);
            }, this.setUnit = (a) => {
              this.options.unit = a, ho(this._map, this._container, this.options);
            }, this.options = Object.assign(Object.assign({}, eu), v);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(v) {
            return this._map = v, this._container = E.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", v.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
          }
          onRemove() {
            E.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
          }
        }, l.ScrollZoomHandler = Zt, l.Style = O, l.TerrainControl = class {
          constructor(v) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
            }, this.options = v;
          }
          onAdd(v) {
            return this._map = v, this._container = E.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = E.create("button", "maplibregl-ctrl-terrain", this._container), E.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
          }
          onRemove() {
            E.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
          }
        }, l.TwoFingersTouchPitchHandler = at, l.TwoFingersTouchRotateHandler = At, l.TwoFingersTouchZoomHandler = Ie, l.TwoFingersTouchZoomRotateHandler = Pn, l.VectorTileSource = Nt, l.VideoSource = pr, l.addSourceType = (v, a) => o._(void 0, void 0, void 0, function* () {
          if (Lr(v)) throw new Error(`A source type called "${v}" already exists.`);
          ((h, g) => {
            _r[h] = g;
          })(v, a);
        }), l.clearPrewarmedResources = function() {
          const v = Oe;
          v && (v.isPreloaded() && v.numActive() === 1 ? (v.release(Dt), Oe = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, l.createTileMesh = zc, l.getMaxParallelImageRequests = function() {
          return o.a.MAX_PARALLEL_IMAGE_REQUESTS;
        }, l.getRTLTextPluginStatus = function() {
          return nn().getRTLTextPluginStatus();
        }, l.getVersion = function() {
          return bh;
        }, l.getWorkerCount = function() {
          return hr.workerCount;
        }, l.getWorkerUrl = function() {
          return o.a.WORKER_URL;
        }, l.importScriptInWorkers = function(v) {
          return ht().broadcast("IS", v);
        }, l.prewarm = function() {
          et().acquire(Dt);
        }, l.setMaxParallelImageRequests = function(v) {
          o.a.MAX_PARALLEL_IMAGE_REQUESTS = v;
        }, l.setRTLTextPlugin = function(v, a) {
          return nn().setRTLTextPlugin(v, a);
        }, l.setWorkerCount = function(v) {
          hr.workerCount = v;
        }, l.setWorkerUrl = function(v) {
          o.a.WORKER_URL = v;
        };
      });
      var s = t;
      return s;
    });
  }(a_)), a_.exports;
}
var kE = h4();
const po = /* @__PURE__ */ e2(kE), If = new Uint8Array([102, 103, 98, 3, 102, 103, 98, 0]), Ju = 4, qp = 4, Gp = 4, qg = 4, kh = new Int32Array(2), gA = new Float32Array(kh.buffer), mA = new Float64Array(kh.buffer), vm = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
var M1;
(function(r) {
  r[r.UTF8_BYTES = 1] = "UTF8_BYTES", r[r.UTF16_STRING = 2] = "UTF16_STRING";
})(M1 || (M1 = {}));
class th {
  /**
   * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
   */
  constructor(e) {
    this.bytes_ = e, this.position_ = 0, this.text_decoder_ = new TextDecoder();
  }
  /**
   * Create and allocate a new ByteBuffer with a given size.
   */
  static allocate(e) {
    return new th(new Uint8Array(e));
  }
  clear() {
    this.position_ = 0;
  }
  /**
   * Get the underlying `Uint8Array`.
   */
  bytes() {
    return this.bytes_;
  }
  /**
   * Get the buffer's position.
   */
  position() {
    return this.position_;
  }
  /**
   * Set the buffer's position.
   */
  setPosition(e) {
    this.position_ = e;
  }
  /**
   * Get the buffer's capacity.
   */
  capacity() {
    return this.bytes_.length;
  }
  readInt8(e) {
    return this.readUint8(e) << 24 >> 24;
  }
  readUint8(e) {
    return this.bytes_[e];
  }
  readInt16(e) {
    return this.readUint16(e) << 16 >> 16;
  }
  readUint16(e) {
    return this.bytes_[e] | this.bytes_[e + 1] << 8;
  }
  readInt32(e) {
    return this.bytes_[e] | this.bytes_[e + 1] << 8 | this.bytes_[e + 2] << 16 | this.bytes_[e + 3] << 24;
  }
  readUint32(e) {
    return this.readInt32(e) >>> 0;
  }
  readInt64(e) {
    return BigInt.asIntN(64, BigInt(this.readUint32(e)) + (BigInt(this.readUint32(e + 4)) << BigInt(32)));
  }
  readUint64(e) {
    return BigInt.asUintN(64, BigInt(this.readUint32(e)) + (BigInt(this.readUint32(e + 4)) << BigInt(32)));
  }
  readFloat32(e) {
    return kh[0] = this.readInt32(e), gA[0];
  }
  readFloat64(e) {
    return kh[vm ? 0 : 1] = this.readInt32(e), kh[vm ? 1 : 0] = this.readInt32(e + 4), mA[0];
  }
  writeInt8(e, t) {
    this.bytes_[e] = t;
  }
  writeUint8(e, t) {
    this.bytes_[e] = t;
  }
  writeInt16(e, t) {
    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8;
  }
  writeUint16(e, t) {
    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8;
  }
  writeInt32(e, t) {
    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8, this.bytes_[e + 2] = t >> 16, this.bytes_[e + 3] = t >> 24;
  }
  writeUint32(e, t) {
    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8, this.bytes_[e + 2] = t >> 16, this.bytes_[e + 3] = t >> 24;
  }
  writeInt64(e, t) {
    this.writeInt32(e, Number(BigInt.asIntN(32, t))), this.writeInt32(e + 4, Number(BigInt.asIntN(32, t >> BigInt(32))));
  }
  writeUint64(e, t) {
    this.writeUint32(e, Number(BigInt.asUintN(32, t))), this.writeUint32(e + 4, Number(BigInt.asUintN(32, t >> BigInt(32))));
  }
  writeFloat32(e, t) {
    gA[0] = t, this.writeInt32(e, kh[0]);
  }
  writeFloat64(e, t) {
    mA[0] = t, this.writeInt32(e, kh[vm ? 0 : 1]), this.writeInt32(e + 4, kh[vm ? 1 : 0]);
  }
  /**
   * Return the file identifier.   Behavior is undefined for FlatBuffers whose
   * schema does not include a file_identifier (likely points at padding or the
   * start of a the root vtable).
   */
  getBufferIdentifier() {
    if (this.bytes_.length < this.position_ + qp + Gp)
      throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
    let e = "";
    for (let t = 0; t < Gp; t++)
      e += String.fromCharCode(this.readInt8(this.position_ + qp + t));
    return e;
  }
  /**
   * Look up a field in the vtable, return an offset into the object, or 0 if the
   * field is not present.
   */
  __offset(e, t) {
    const n = e - this.readInt32(e);
    return t < this.readInt16(n) ? this.readInt16(n + t) : 0;
  }
  /**
   * Initialize any Table-derived type to point to the union at the given offset.
   */
  __union(e, t) {
    return e.bb_pos = t + this.readInt32(t), e.bb = this, e;
  }
  /**
   * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
   * This allocates a new string and converts to wide chars upon each access.
   *
   * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the
   * "optionalEncoding" argument. This is useful for avoiding conversion when
   * the data will just be packaged back up in another FlatBuffer later on.
   *
   * @param offset
   * @param opt_encoding Defaults to UTF16_STRING
   */
  __string(e, t) {
    e += this.readInt32(e);
    const n = this.readInt32(e);
    e += qp;
    const i = this.bytes_.subarray(e, e + n);
    return t === M1.UTF8_BYTES ? i : this.text_decoder_.decode(i);
  }
  /**
   * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
   * if a string then return a new one
   *
   * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
   * makes the behaviour of __union_with_string different compared to __union
   */
  __union_with_string(e, t) {
    return typeof e == "string" ? this.__string(t) : this.__union(e, t);
  }
  /**
   * Retrieve the relative offset stored at "offset"
   */
  __indirect(e) {
    return e + this.readInt32(e);
  }
  /**
   * Get the start of data of a vector whose offset is stored at "offset" in this object.
   */
  __vector(e) {
    return e + this.readInt32(e) + qp;
  }
  /**
   * Get the length of a vector whose offset is stored at "offset" in this object.
   */
  __vector_len(e) {
    return this.readInt32(e + this.readInt32(e));
  }
  __has_identifier(e) {
    if (e.length != Gp)
      throw new Error("FlatBuffers: file identifier must be length " + Gp);
    for (let t = 0; t < Gp; t++)
      if (e.charCodeAt(t) != this.readInt8(this.position() + qp + t))
        return !1;
    return !0;
  }
  /**
   * A helper function for generating list for obj api
   */
  createScalarList(e, t) {
    const n = [];
    for (let i = 0; i < t; ++i) {
      const s = e(i);
      s !== null && n.push(s);
    }
    return n;
  }
  /**
   * A helper function for generating list for obj api
   * @param listAccessor function that accepts an index and return data at that index
   * @param listLength listLength
   * @param res result list
   */
  createObjList(e, t) {
    const n = [];
    for (let i = 0; i < t; ++i) {
      const s = e(i);
      s !== null && n.push(s.unpack());
    }
    return n;
  }
}
var Jn, Io = ((Jn = {})[Jn.Byte = 0] = "Byte", Jn[Jn.UByte = 1] = "UByte", Jn[Jn.Bool = 2] = "Bool", Jn[Jn.Short = 3] = "Short", Jn[Jn.UShort = 4] = "UShort", Jn[Jn.Int = 5] = "Int", Jn[Jn.UInt = 6] = "UInt", Jn[Jn.Long = 7] = "Long", Jn[Jn.ULong = 8] = "ULong", Jn[Jn.Float = 9] = "Float", Jn[Jn.Double = 10] = "Double", Jn[Jn.String = 11] = "String", Jn[Jn.Json = 12] = "Json", Jn[Jn.DateTime = 13] = "DateTime", Jn[Jn.Binary = 14] = "Binary", Jn);
class mo {
  constructor() {
    H(this, "bb", null);
    H(this, "bb_pos", 0);
  }
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsColumn(e, t) {
    return (t || new mo()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsColumn(e, t) {
    return e.setPosition(e.position() + qg), (t || new mo()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  name(e) {
    let t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  type() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.readUint8(this.bb_pos + e) : Io.Byte;
  }
  title(e) {
    let t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  description(e) {
    let t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  width() {
    let e = this.bb.__offset(this.bb_pos, 12);
    return e ? this.bb.readInt32(this.bb_pos + e) : -1;
  }
  precision() {
    let e = this.bb.__offset(this.bb_pos, 14);
    return e ? this.bb.readInt32(this.bb_pos + e) : -1;
  }
  scale() {
    let e = this.bb.__offset(this.bb_pos, 16);
    return e ? this.bb.readInt32(this.bb_pos + e) : -1;
  }
  nullable() {
    let e = this.bb.__offset(this.bb_pos, 18);
    return !e || !!this.bb.readInt8(this.bb_pos + e);
  }
  unique() {
    let e = this.bb.__offset(this.bb_pos, 20);
    return !!e && !!this.bb.readInt8(this.bb_pos + e);
  }
  primaryKey() {
    let e = this.bb.__offset(this.bb_pos, 22);
    return !!e && !!this.bb.readInt8(this.bb_pos + e);
  }
  metadata(e) {
    let t = this.bb.__offset(this.bb_pos, 24);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  static startColumn(e) {
    e.startObject(11);
  }
  static addName(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addType(e, t) {
    e.addFieldInt8(1, t, Io.Byte);
  }
  static addTitle(e, t) {
    e.addFieldOffset(2, t, 0);
  }
  static addDescription(e, t) {
    e.addFieldOffset(3, t, 0);
  }
  static addWidth(e, t) {
    e.addFieldInt32(4, t, -1);
  }
  static addPrecision(e, t) {
    e.addFieldInt32(5, t, -1);
  }
  static addScale(e, t) {
    e.addFieldInt32(6, t, -1);
  }
  static addNullable(e, t) {
    e.addFieldInt8(7, +t, 1);
  }
  static addUnique(e, t) {
    e.addFieldInt8(8, +t, 0);
  }
  static addPrimaryKey(e, t) {
    e.addFieldInt8(9, +t, 0);
  }
  static addMetadata(e, t) {
    e.addFieldOffset(10, t, 0);
  }
  static endColumn(e) {
    let t = e.endObject();
    return e.requiredField(t, 4), t;
  }
  static createColumn(e, t, n, i, s, l, o, d, m, b, A, M) {
    return mo.startColumn(e), mo.addName(e, t), mo.addType(e, n), mo.addTitle(e, i), mo.addDescription(e, s), mo.addWidth(e, l), mo.addPrecision(e, o), mo.addScale(e, d), mo.addNullable(e, m), mo.addUnique(e, b), mo.addPrimaryKey(e, A), mo.addMetadata(e, M), mo.endColumn(e);
  }
}
var Rn, Jo = ((Rn = {})[Rn.Unknown = 0] = "Unknown", Rn[Rn.Point = 1] = "Point", Rn[Rn.LineString = 2] = "LineString", Rn[Rn.Polygon = 3] = "Polygon", Rn[Rn.MultiPoint = 4] = "MultiPoint", Rn[Rn.MultiLineString = 5] = "MultiLineString", Rn[Rn.MultiPolygon = 6] = "MultiPolygon", Rn[Rn.GeometryCollection = 7] = "GeometryCollection", Rn[Rn.CircularString = 8] = "CircularString", Rn[Rn.CompoundCurve = 9] = "CompoundCurve", Rn[Rn.CurvePolygon = 10] = "CurvePolygon", Rn[Rn.MultiCurve = 11] = "MultiCurve", Rn[Rn.MultiSurface = 12] = "MultiSurface", Rn[Rn.Curve = 13] = "Curve", Rn[Rn.Surface = 14] = "Surface", Rn[Rn.PolyhedralSurface = 15] = "PolyhedralSurface", Rn[Rn.TIN = 16] = "TIN", Rn[Rn.Triangle = 17] = "Triangle", Rn);
let f4 = class Fa {
  constructor() {
    H(this, "bb", null);
    H(this, "bb_pos", 0);
  }
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsGeometry(e, t) {
    return (t || new Fa()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsGeometry(e, t) {
    return e.setPosition(e.position() + qg), (t || new Fa()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  ends(e) {
    let t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readUint32(this.bb.__vector(this.bb_pos + t) + 4 * e) : 0;
  }
  endsLength() {
    let e = this.bb.__offset(this.bb_pos, 4);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  endsArray() {
    let e = this.bb.__offset(this.bb_pos, 4);
    return e ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  xy(e) {
    let t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + 8 * e) : 0;
  }
  xyLength() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  xyArray() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  z(e) {
    let t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + 8 * e) : 0;
  }
  zLength() {
    let e = this.bb.__offset(this.bb_pos, 8);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  zArray() {
    let e = this.bb.__offset(this.bb_pos, 8);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  m(e) {
    let t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + 8 * e) : 0;
  }
  mLength() {
    let e = this.bb.__offset(this.bb_pos, 10);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  mArray() {
    let e = this.bb.__offset(this.bb_pos, 10);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  t(e) {
    let t = this.bb.__offset(this.bb_pos, 12);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + 8 * e) : 0;
  }
  tLength() {
    let e = this.bb.__offset(this.bb_pos, 12);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  tArray() {
    let e = this.bb.__offset(this.bb_pos, 12);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  tm(e) {
    let t = this.bb.__offset(this.bb_pos, 14);
    return t ? this.bb.readUint64(this.bb.__vector(this.bb_pos + t) + 8 * e) : BigInt(0);
  }
  tmLength() {
    let e = this.bb.__offset(this.bb_pos, 14);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  type() {
    let e = this.bb.__offset(this.bb_pos, 16);
    return e ? this.bb.readUint8(this.bb_pos + e) : Jo.Unknown;
  }
  parts(e, t) {
    let n = this.bb.__offset(this.bb_pos, 18);
    return n ? (t || new Fa()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * e), this.bb) : null;
  }
  partsLength() {
    let e = this.bb.__offset(this.bb_pos, 18);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  static startGeometry(e) {
    e.startObject(8);
  }
  static addEnds(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static createEndsVector(e, t) {
    e.startVector(4, t.length, 4);
    for (let n = t.length - 1; n >= 0; n--) e.addInt32(t[n]);
    return e.endVector();
  }
  static startEndsVector(e, t) {
    e.startVector(4, t, 4);
  }
  static addXy(e, t) {
    e.addFieldOffset(1, t, 0);
  }
  static createXyVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let n = t.length - 1; n >= 0; n--) e.addFloat64(t[n]);
    return e.endVector();
  }
  static startXyVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addZ(e, t) {
    e.addFieldOffset(2, t, 0);
  }
  static createZVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let n = t.length - 1; n >= 0; n--) e.addFloat64(t[n]);
    return e.endVector();
  }
  static startZVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addM(e, t) {
    e.addFieldOffset(3, t, 0);
  }
  static createMVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let n = t.length - 1; n >= 0; n--) e.addFloat64(t[n]);
    return e.endVector();
  }
  static startMVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addT(e, t) {
    e.addFieldOffset(4, t, 0);
  }
  static createTVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let n = t.length - 1; n >= 0; n--) e.addFloat64(t[n]);
    return e.endVector();
  }
  static startTVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addTm(e, t) {
    e.addFieldOffset(5, t, 0);
  }
  static createTmVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let n = t.length - 1; n >= 0; n--) e.addInt64(t[n]);
    return e.endVector();
  }
  static startTmVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addType(e, t) {
    e.addFieldInt8(6, t, Jo.Unknown);
  }
  static addParts(e, t) {
    e.addFieldOffset(7, t, 0);
  }
  static createPartsVector(e, t) {
    e.startVector(4, t.length, 4);
    for (let n = t.length - 1; n >= 0; n--) e.addOffset(t[n]);
    return e.endVector();
  }
  static startPartsVector(e, t) {
    e.startVector(4, t, 4);
  }
  static endGeometry(e) {
    return e.endObject();
  }
  static createGeometry(e, t, n, i, s, l, o, d, m) {
    return Fa.startGeometry(e), Fa.addEnds(e, t), Fa.addXy(e, n), Fa.addZ(e, i), Fa.addM(e, s), Fa.addT(e, l), Fa.addTm(e, o), Fa.addType(e, d), Fa.addParts(e, m), Fa.endGeometry(e);
  }
};
class xc {
  constructor() {
    H(this, "bb", null);
    H(this, "bb_pos", 0);
  }
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsFeature(e, t) {
    return (t || new xc()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsFeature(e, t) {
    return e.setPosition(e.position() + qg), (t || new xc()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  geometry(e) {
    let t = this.bb.__offset(this.bb_pos, 4);
    return t ? (e || new f4()).__init(this.bb.__indirect(this.bb_pos + t), this.bb) : null;
  }
  properties(e) {
    let t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readUint8(this.bb.__vector(this.bb_pos + t) + e) : 0;
  }
  propertiesLength() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  propertiesArray() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  columns(e, t) {
    let n = this.bb.__offset(this.bb_pos, 8);
    return n ? (t || new mo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * e), this.bb) : null;
  }
  columnsLength() {
    let e = this.bb.__offset(this.bb_pos, 8);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  static startFeature(e) {
    e.startObject(3);
  }
  static addGeometry(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addProperties(e, t) {
    e.addFieldOffset(1, t, 0);
  }
  static createPropertiesVector(e, t) {
    e.startVector(1, t.length, 1);
    for (let n = t.length - 1; n >= 0; n--) e.addInt8(t[n]);
    return e.endVector();
  }
  static startPropertiesVector(e, t) {
    e.startVector(1, t, 1);
  }
  static addColumns(e, t) {
    e.addFieldOffset(2, t, 0);
  }
  static createColumnsVector(e, t) {
    e.startVector(4, t.length, 4);
    for (let n = t.length - 1; n >= 0; n--) e.addOffset(t[n]);
    return e.endVector();
  }
  static startColumnsVector(e, t) {
    e.startVector(4, t, 4);
  }
  static endFeature(e) {
    return e.endObject();
  }
  static finishFeatureBuffer(e, t) {
    e.finish(t);
  }
  static finishSizePrefixedFeatureBuffer(e, t) {
    e.finish(t, void 0, !0);
  }
  static createFeature(e, t, n, i) {
    return xc.startFeature(e), xc.addGeometry(e, t), xc.addProperties(e, n), xc.addColumns(e, i), xc.endFeature(e);
  }
}
function X0(r, e) {
  let t = [];
  for (let n = 0; n < r.length; n += 2) {
    let i = [r[n], r[n + 1]];
    e && i.push(e[n >> 1]), t.push(i);
  }
  return t;
}
new TextEncoder();
let _A = new TextDecoder();
function d4(r, e) {
  let t = {};
  if (!e || e.length === 0) return t;
  let n = r.propertiesArray();
  if (!n) return t;
  let i = new DataView(n.buffer, n.byteOffset), s = r.propertiesLength(), l = 0;
  for (; l < s; ) {
    let o = i.getUint16(l, !0);
    l += 2;
    let d = e[o], m = d.name;
    switch (d.type) {
      case Io.Bool:
        t[m] = !!i.getUint8(l), l += 1;
        break;
      case Io.Byte:
        t[m] = i.getInt8(l), l += 1;
        break;
      case Io.UByte:
        t[m] = i.getUint8(l), l += 1;
        break;
      case Io.Short:
        t[m] = i.getInt16(l, !0), l += 2;
        break;
      case Io.UShort:
        t[m] = i.getUint16(l, !0), l += 2;
        break;
      case Io.Int:
        t[m] = i.getInt32(l, !0), l += 4;
        break;
      case Io.UInt:
        t[m] = i.getUint32(l, !0), l += 4;
        break;
      case Io.Long:
        t[m] = Number(i.getBigInt64(l, !0)), l += 8;
        break;
      case Io.ULong:
        t[m] = Number(i.getBigUint64(l, !0)), l += 8;
        break;
      case Io.Float:
        t[m] = i.getFloat32(l, !0), l += 4;
        break;
      case Io.Double:
        t[m] = i.getFloat64(l, !0), l += 8;
        break;
      case Io.DateTime:
      case Io.String: {
        let b = i.getUint32(l, !0);
        l += 4, t[m] = _A.decode(n.subarray(l, l + b)), l += b;
        break;
      }
      case Io.Json: {
        let b = i.getUint32(l, !0);
        l += 4;
        let A = _A.decode(n.subarray(l, l + b));
        t[m] = JSON.parse(A), l += b;
        break;
      }
      case Io.Binary: {
        let b = i.getUint32(l, !0);
        l += 4, t[m] = n.subarray(l, l + b), l += b;
        break;
      }
      default:
        throw Error(`Unknown type ${d.type}`);
    }
  }
  return t;
}
const t2 = new Uint8Array(0);
function p4() {
  return this._source.cancel();
}
function g4(r, e) {
  if (!r.length) return e;
  if (!e.length) return r;
  var t = new Uint8Array(r.length + e.length);
  return t.set(r), t.set(e, r.length), t;
}
function m4() {
  var r = this, e = r._array.subarray(r._index);
  return r._source.read().then(function(t) {
    return r._array = t2, r._index = 0, t.done ? e.length > 0 ? {
      done: !1,
      value: e
    } : {
      done: !0,
      value: void 0
    } : {
      done: !1,
      value: g4(e, t.value)
    };
  });
}
function _4(r) {
  if ((r |= 0) < 0) throw new Error("invalid length");
  var e = this, t = this._array.length - this._index;
  if (this._index + r <= this._array.length)
    return Promise.resolve(this._array.subarray(this._index, this._index += r));
  var n = new Uint8Array(r);
  return n.set(this._array.subarray(this._index)), function i() {
    return e._source.read().then(function(s) {
      return s.done ? (e._array = t2, e._index = 0, t > 0 ? n.subarray(0, t) : null) : t + s.value.length >= r ? (e._array = s.value, e._index = r - t, n.set(s.value.subarray(0, r - t), t), n) : (n.set(s.value, t), t += s.value.length, i());
    });
  }();
}
function y4(r) {
  return typeof r.slice == "function" ? r : new By(typeof r.read == "function" ? r : r.getReader());
}
function By(r) {
  this._source = r, this._array = t2, this._index = 0;
}
By.prototype.read = m4;
By.prototype.slice = _4;
By.prototype.cancel = p4;
class Bl {
  constructor() {
    H(this, "bb", null);
    H(this, "bb_pos", 0);
  }
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsCrs(e, t) {
    return (t || new Bl()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsCrs(e, t) {
    return e.setPosition(e.position() + qg), (t || new Bl()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  org(e) {
    let t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  code() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.readInt32(this.bb_pos + e) : 0;
  }
  name(e) {
    let t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  description(e) {
    let t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  wkt(e) {
    let t = this.bb.__offset(this.bb_pos, 12);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  codeString(e) {
    let t = this.bb.__offset(this.bb_pos, 14);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  static startCrs(e) {
    e.startObject(6);
  }
  static addOrg(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addCode(e, t) {
    e.addFieldInt32(1, t, 0);
  }
  static addName(e, t) {
    e.addFieldOffset(2, t, 0);
  }
  static addDescription(e, t) {
    e.addFieldOffset(3, t, 0);
  }
  static addWkt(e, t) {
    e.addFieldOffset(4, t, 0);
  }
  static addCodeString(e, t) {
    e.addFieldOffset(5, t, 0);
  }
  static endCrs(e) {
    return e.endObject();
  }
  static createCrs(e, t, n, i, s, l, o) {
    return Bl.startCrs(e), Bl.addOrg(e, t), Bl.addCode(e, n), Bl.addName(e, i), Bl.addDescription(e, s), Bl.addWkt(e, l), Bl.addCodeString(e, o), Bl.endCrs(e);
  }
}
class M_ {
  constructor() {
    H(this, "bb", null);
    H(this, "bb_pos", 0);
  }
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsHeader(e, t) {
    return (t || new M_()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsHeader(e, t) {
    return e.setPosition(e.position() + qg), (t || new M_()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  name(e) {
    let t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  envelope(e) {
    let t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + 8 * e) : 0;
  }
  envelopeLength() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  envelopeArray() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  geometryType() {
    let e = this.bb.__offset(this.bb_pos, 8);
    return e ? this.bb.readUint8(this.bb_pos + e) : Jo.Unknown;
  }
  hasZ() {
    let e = this.bb.__offset(this.bb_pos, 10);
    return !!e && !!this.bb.readInt8(this.bb_pos + e);
  }
  hasM() {
    let e = this.bb.__offset(this.bb_pos, 12);
    return !!e && !!this.bb.readInt8(this.bb_pos + e);
  }
  hasT() {
    let e = this.bb.__offset(this.bb_pos, 14);
    return !!e && !!this.bb.readInt8(this.bb_pos + e);
  }
  hasTm() {
    let e = this.bb.__offset(this.bb_pos, 16);
    return !!e && !!this.bb.readInt8(this.bb_pos + e);
  }
  columns(e, t) {
    let n = this.bb.__offset(this.bb_pos, 18);
    return n ? (t || new mo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * e), this.bb) : null;
  }
  columnsLength() {
    let e = this.bb.__offset(this.bb_pos, 18);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  featuresCount() {
    let e = this.bb.__offset(this.bb_pos, 20);
    return e ? this.bb.readUint64(this.bb_pos + e) : BigInt("0");
  }
  indexNodeSize() {
    let e = this.bb.__offset(this.bb_pos, 22);
    return e ? this.bb.readUint16(this.bb_pos + e) : 16;
  }
  crs(e) {
    let t = this.bb.__offset(this.bb_pos, 24);
    return t ? (e || new Bl()).__init(this.bb.__indirect(this.bb_pos + t), this.bb) : null;
  }
  title(e) {
    let t = this.bb.__offset(this.bb_pos, 26);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  description(e) {
    let t = this.bb.__offset(this.bb_pos, 28);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  metadata(e) {
    let t = this.bb.__offset(this.bb_pos, 30);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  static startHeader(e) {
    e.startObject(14);
  }
  static addName(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addEnvelope(e, t) {
    e.addFieldOffset(1, t, 0);
  }
  static createEnvelopeVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let n = t.length - 1; n >= 0; n--) e.addFloat64(t[n]);
    return e.endVector();
  }
  static startEnvelopeVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addGeometryType(e, t) {
    e.addFieldInt8(2, t, Jo.Unknown);
  }
  static addHasZ(e, t) {
    e.addFieldInt8(3, +t, 0);
  }
  static addHasM(e, t) {
    e.addFieldInt8(4, +t, 0);
  }
  static addHasT(e, t) {
    e.addFieldInt8(5, +t, 0);
  }
  static addHasTm(e, t) {
    e.addFieldInt8(6, +t, 0);
  }
  static addColumns(e, t) {
    e.addFieldOffset(7, t, 0);
  }
  static createColumnsVector(e, t) {
    e.startVector(4, t.length, 4);
    for (let n = t.length - 1; n >= 0; n--) e.addOffset(t[n]);
    return e.endVector();
  }
  static startColumnsVector(e, t) {
    e.startVector(4, t, 4);
  }
  static addFeaturesCount(e, t) {
    e.addFieldInt64(8, t, BigInt("0"));
  }
  static addIndexNodeSize(e, t) {
    e.addFieldInt16(9, t, 16);
  }
  static addCrs(e, t) {
    e.addFieldOffset(10, t, 0);
  }
  static addTitle(e, t) {
    e.addFieldOffset(11, t, 0);
  }
  static addDescription(e, t) {
    e.addFieldOffset(12, t, 0);
  }
  static addMetadata(e, t) {
    e.addFieldOffset(13, t, 0);
  }
  static endHeader(e) {
    return e.endObject();
  }
  static finishHeaderBuffer(e, t) {
    e.finish(t);
  }
  static finishSizePrefixedHeaderBuffer(e, t) {
    e.finish(t, void 0, !0);
  }
}
function r2(r) {
  let e = M_.getRootAsHeader(r), t = e.featuresCount(), n = e.indexNodeSize(), i = [];
  for (let o = 0; o < e.columnsLength(); o++) {
    let d = e.columns(o);
    if (!d) throw Error("Column unexpectedly missing");
    if (!d.name()) throw Error("Column name unexpectedly missing");
    i.push({
      name: d.name(),
      type: d.type(),
      title: d.title(),
      description: d.description(),
      width: d.width(),
      precision: d.precision(),
      scale: d.scale(),
      nullable: d.nullable(),
      unique: d.unique(),
      primary_key: d.primaryKey()
    });
  }
  let s = e.crs(), l = s ? {
    org: s.org(),
    code: s.code(),
    name: s.name(),
    description: s.description(),
    wkt: s.wkt(),
    code_string: s.codeString()
  } : null;
  return {
    geometryType: e.geometryType(),
    columns: i,
    envelope: null,
    featuresCount: Number(t),
    indexNodeSize: n,
    crs: l,
    title: e.title(),
    description: e.description(),
    metadata: e.metadata()
  };
}
var Of;
let NE = (Of = class {
  constructor() {
    H(this, "_extraRequestThreshold", 262144);
  }
  extraRequestThreshold() {
    return this._extraRequestThreshold;
  }
  setExtraRequestThreshold(e) {
    if (e < 0) throw Error("extraRequestThreshold cannot be negative");
    this._extraRequestThreshold = e;
  }
}, H(Of, "global", new Of()), Of);
const b4 = 40, v4 = 16;
function n2(r, e) {
  e = Math.min(Math.max(+e, 2), 65535);
  let t = r, n = t;
  do
    n += t = Math.ceil(t / e);
  while (t !== 1);
  return 40 * n;
}
function x4(r, e) {
  if (e < 2) throw Error("Node size must be at least 2");
  if (r === 0) throw Error("Number of items must be greater than 0");
  let t = r, n = t, i = [t];
  do
    n += t = Math.ceil(t / e), i.push(t);
  while (t !== 1);
  let s = [];
  for (let o of (t = n, i)) s.push(t - o), t -= o;
  let l = [];
  for (let o = 0; o < i.length; o++) l.push([s[o], s[o] + i[o]]);
  return l;
}
async function* w4(r, e, t, n) {
  class i {
    constructor(E, k) {
      H(this, "_level");
      H(this, "nodes");
      this._level = k, this.nodes = E;
    }
    level() {
      return this._level;
    }
    startNodeIdx() {
      return this.nodes[0];
    }
    endNodeIdx() {
      return this.nodes[1];
    }
    extendEndNodeIdx(E) {
      this.nodes[1] = E;
    }
    toString() {
      return `[NodeRange level: ${this._level}, nodes: ${this.nodes[0]}-${this.nodes[1]}]`;
    }
  }
  let {
    minX: s,
    minY: l,
    maxX: o,
    maxY: d
  } = t, m = x4(r, e), b = m[0][0], A = [new i([0, 1], m.length - 1)];
  for (; A.length !== 0; ) {
    let M = A.shift(), E = M.startNodeIdx(), k = E >= b, U = (() => {
      let [, Y] = m[M.level()], re = Math.min(M.endNodeIdx() + e, Y);
      return k && re < Y ? re + 1 : re;
    })(), V = U - E, q = new DataView(await n(40 * E, 40 * V));
    for (let Y = E; Y < U; Y++) {
      let re = Y - E, Z = 40 * re;
      if (o < q.getFloat64(Z + 0, !0) || d < q.getFloat64(Z + 8, !0) || s > q.getFloat64(Z + 16, !0) || l > q.getFloat64(Z + 24, !0)) continue;
      let K = q.getBigUint64(Z + 32, !0);
      if (k) {
        let Be = (() => {
          if (Y < r - 1) {
            let pe = (re + 1) * 40;
            return q.getBigUint64(pe + 32, !0) - K;
          }
          return null;
        })(), ke = Y - b;
        yield [Number(K), ke, Number(Be)];
        continue;
      }
      let ie = NE.global.extraRequestThreshold() / 40, be = A[A.length - 1];
      if (be !== void 0 && be.level() === M.level() - 1 && K < be.endNodeIdx() + ie) {
        be.extendEndNodeIdx(Number(K));
        continue;
      }
      let he = (() => {
        let Be = M.level() - 1;
        return new i([Number(K), Number(K) + 1], Be);
      })();
      be !== void 0 && (be.level(), he.level()), A.push(he);
    }
  }
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var P1 = function(r, e) {
  return P1 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(t, n) {
    t.__proto__ = n;
  } || function(t, n) {
    for (var i in n) n.hasOwnProperty(i) && (t[i] = n[i]);
  }, P1(r, e);
};
function A4(r, e) {
  P1(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
function rp(r, e, t, n) {
  function i(s) {
    return s instanceof t ? s : new t(function(l) {
      l(s);
    });
  }
  return new (t || (t = Promise))(function(s, l) {
    function o(b) {
      try {
        m(n.next(b));
      } catch (A) {
        l(A);
      }
    }
    function d(b) {
      try {
        m(n.throw(b));
      } catch (A) {
        l(A);
      }
    }
    function m(b) {
      b.done ? s(b.value) : i(b.value).then(o, d);
    }
    m((n = n.apply(r, [])).next());
  });
}
function Gh(r, e) {
  var t = {
    label: 0,
    sent: function() {
      if (s[0] & 1) throw s[1];
      return s[1];
    },
    trys: [],
    ops: []
  }, n, i, s, l;
  return l = {
    next: o(0),
    throw: o(1),
    return: o(2)
  }, typeof Symbol == "function" && (l[Symbol.iterator] = function() {
    return this;
  }), l;
  function o(m) {
    return function(b) {
      return d([m, b]);
    };
  }
  function d(m) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; t; ) try {
      if (n = 1, i && (s = m[0] & 2 ? i.return : m[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, m[1])).done) return s;
      switch (i = 0, s && (m = [m[0] & 2, s.value]), m[0]) {
        case 0:
        case 1:
          s = m;
          break;
        case 4:
          return t.label++, {
            value: m[1],
            done: !1
          };
        case 5:
          t.label++, i = m[1], m = [0];
          continue;
        case 7:
          m = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (m[0] === 6 || m[0] === 2)) {
            t = 0;
            continue;
          }
          if (m[0] === 3 && (!s || m[1] > s[0] && m[1] < s[3])) {
            t.label = m[1];
            break;
          }
          if (m[0] === 6 && t.label < s[1]) {
            t.label = s[1], s = m;
            break;
          }
          if (s && t.label < s[2]) {
            t.label = s[2], t.ops.push(m);
            break;
          }
          s[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      m = e.call(r, t);
    } catch (b) {
      m = [6, b], i = 0;
    } finally {
      n = s = 0;
    }
    if (m[0] & 5) throw m[1];
    return {
      value: m[0] ? m[1] : void 0,
      done: !0
    };
  }
}
function pp(r) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && r[e], n = 0;
  if (t) return t.call(r);
  if (r && typeof r.length == "number") return {
    next: function() {
      return r && n >= r.length && (r = void 0), {
        value: r && r[n++],
        done: !r
      };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Mg(r) {
  return this instanceof Mg ? (this.v = r, this) : new Mg(r);
}
function T4(r, e, t) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = t.apply(r, e || []), i, s = [];
  return i = {}, l("next"), l("throw"), l("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function l(M) {
    n[M] && (i[M] = function(E) {
      return new Promise(function(k, U) {
        s.push([M, E, k, U]) > 1 || o(M, E);
      });
    });
  }
  function o(M, E) {
    try {
      d(n[M](E));
    } catch (k) {
      A(s[0][3], k);
    }
  }
  function d(M) {
    M.value instanceof Mg ? Promise.resolve(M.value.v).then(m, b) : A(s[0][2], M);
  }
  function m(M) {
    o("next", M);
  }
  function b(M) {
    o("throw", M);
  }
  function A(M, E) {
    M(E), s.shift(), s.length && o(s[0][0], s[0][1]);
  }
}
var DE = (
  /** @class */
  function(r) {
    A4(e, r);
    function e(t) {
      var n = r.call(this, t) || this;
      return Object.defineProperty(n, "name", {
        value: "RepeaterOverflowError",
        enumerable: !1
      }), typeof Object.setPrototypeOf == "function" ? Object.setPrototypeOf(n, n.constructor.prototype) : n.__proto__ = n.constructor.prototype, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(n, n.constructor), n;
    }
    return e;
  }(Error)
);
(function() {
  function r(e) {
    if (e < 0)
      throw new RangeError("Capacity may not be less than 0");
    this._c = e, this._q = [];
  }
  return Object.defineProperty(r.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(r.prototype, "full", {
    get: function() {
      return this._q.length >= this._c;
    },
    enumerable: !1,
    configurable: !0
  }), r.prototype.add = function(e) {
    if (this.full)
      throw new Error("Buffer full");
    this._q.push(e);
  }, r.prototype.remove = function() {
    if (this.empty)
      throw new Error("Buffer empty");
    return this._q.shift();
  }, r;
})();
(function() {
  function r(e) {
    if (e < 1)
      throw new RangeError("Capacity may not be less than 1");
    this._c = e, this._q = [];
  }
  return Object.defineProperty(r.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(r.prototype, "full", {
    get: function() {
      return !1;
    },
    enumerable: !1,
    configurable: !0
  }), r.prototype.add = function(e) {
    for (; this._q.length >= this._c; )
      this._q.shift();
    this._q.push(e);
  }, r.prototype.remove = function() {
    if (this.empty)
      throw new Error("Buffer empty");
    return this._q.shift();
  }, r;
})();
(function() {
  function r(e) {
    if (e < 1)
      throw new RangeError("Capacity may not be less than 1");
    this._c = e, this._q = [];
  }
  return Object.defineProperty(r.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(r.prototype, "full", {
    get: function() {
      return !1;
    },
    enumerable: !1,
    configurable: !0
  }), r.prototype.add = function(e) {
    this._q.length < this._c && this._q.push(e);
  }, r.prototype.remove = function() {
    if (this.empty)
      throw new Error("Buffer empty");
    return this._q.shift();
  }, r;
})();
function R1(r) {
  r != null && typeof r.then == "function" && r.then(B_, B_);
}
var Z0 = 0, yA = 1, jf = 2, P_ = 3, B1 = 4, R_ = 1024, B_ = function() {
};
function Gd(r) {
  var e = r.err, t = Promise.resolve(r.execution).then(function(n) {
    if (e != null)
      throw e;
    return n;
  });
  return r.err = void 0, r.execution = t.then(function() {
  }, function() {
  }), r.pending === void 0 ? t : r.pending.then(function() {
    return t;
  });
}
function Tf(r, e) {
  var t = r.state >= P_;
  return Promise.resolve(e).then(function(n) {
    return !t && r.state >= B1 ? Gd(r).then(function(i) {
      return {
        value: i,
        done: !0
      };
    }) : {
      value: n,
      done: t
    };
  });
}
function i2(r, e) {
  var t, n;
  if (!(r.state >= jf))
    if (r.state = jf, r.onnext(), r.onstop(), r.err == null && (r.err = e), r.pushes.length === 0 && (typeof r.buffer > "u" || r.buffer.empty))
      gg(r);
    else
      try {
        for (var i = pp(r.pushes), s = i.next(); !s.done; s = i.next()) {
          var l = s.value;
          l.resolve();
        }
      } catch (o) {
        t = {
          error: o
        };
      } finally {
        try {
          s && !s.done && (n = i.return) && n.call(i);
        } finally {
          if (t) throw t.error;
        }
      }
}
function gg(r) {
  var e, t;
  if (!(r.state >= P_)) {
    r.state < jf && i2(r), r.state = P_, r.buffer = void 0;
    try {
      for (var n = pp(r.nexts), i = n.next(); !i.done; i = n.next()) {
        var s = i.value, l = r.pending === void 0 ? Gd(r) : r.pending.then(function() {
          return Gd(r);
        });
        s.resolve(Tf(r, l));
      }
    } catch (o) {
      e = {
        error: o
      };
    } finally {
      try {
        i && !i.done && (t = n.return) && t.call(n);
      } finally {
        if (e) throw e.error;
      }
    }
    r.pushes = [], r.nexts = [];
  }
}
function bA(r) {
  r.state >= B1 || (r.state < P_ && gg(r), r.state = B1);
}
function S4(r, e) {
  if (R1(e), r.pushes.length >= R_)
    throw new DE("No more than " + R_ + " pending calls to push are allowed on a single repeater.");
  if (r.state >= jf)
    return Promise.resolve(void 0);
  var t = r.pending === void 0 ? Promise.resolve(e) : r.pending.then(function() {
    return e;
  });
  t = t.catch(function(d) {
    r.state < jf && (r.err = d), bA(r);
  });
  var n;
  if (r.nexts.length) {
    var i = r.nexts.shift();
    i.resolve(Tf(r, t)), r.nexts.length ? n = Promise.resolve(r.nexts[0].value) : typeof r.buffer < "u" && !r.buffer.full ? n = Promise.resolve(void 0) : n = new Promise(function(d) {
      return r.onnext = d;
    });
  } else typeof r.buffer < "u" && !r.buffer.full ? (r.buffer.add(t), n = Promise.resolve(void 0)) : n = new Promise(function(d) {
    return r.pushes.push({
      resolve: d,
      value: t
    });
  });
  var s = !0, l = {}, o = n.catch(function(d) {
    if (s)
      throw d;
  });
  return l.then = function(d, m) {
    return s = !1, Promise.prototype.then.call(n, d, m);
  }, l.catch = function(d) {
    return s = !1, Promise.prototype.catch.call(n, d);
  }, l.finally = n.finally.bind(n), r.pending = t.then(function() {
    return o;
  }).catch(function(d) {
    r.err = d, bA(r);
  }), l;
}
function E4(r) {
  var e = i2.bind(null, r), t = new Promise(function(n) {
    return r.onstop = n;
  });
  return e.then = t.then.bind(t), e.catch = t.catch.bind(t), e.finally = t.finally.bind(t), e;
}
function C4(r) {
  if (!(r.state >= yA)) {
    r.state = yA;
    var e = S4.bind(null, r), t = E4(r);
    r.execution = new Promise(function(n) {
      return n(r.executor(e, t));
    }), r.execution.catch(function() {
      return i2(r);
    });
  }
}
var xm = /* @__PURE__ */ new WeakMap(), Gg = (
  /** @class */
  function() {
    function r(e, t) {
      xm.set(this, {
        executor: e,
        buffer: t,
        err: void 0,
        state: Z0,
        pushes: [],
        nexts: [],
        pending: void 0,
        execution: void 0,
        onnext: B_,
        onstop: B_
      });
    }
    return r.prototype.next = function(e) {
      R1(e);
      var t = xm.get(this);
      if (t === void 0)
        throw new Error("WeakMap error");
      if (t.nexts.length >= R_)
        throw new DE("No more than " + R_ + " pending calls to next are allowed on a single repeater.");
      if (t.state <= Z0 && C4(t), t.onnext(e), typeof t.buffer < "u" && !t.buffer.empty) {
        var n = Tf(t, t.buffer.remove());
        if (t.pushes.length) {
          var i = t.pushes.shift();
          t.buffer.add(i.value), t.onnext = i.resolve;
        }
        return n;
      } else if (t.pushes.length) {
        var s = t.pushes.shift();
        return t.onnext = s.resolve, Tf(t, s.value);
      } else if (t.state >= jf)
        return gg(t), Tf(t, Gd(t));
      return new Promise(function(l) {
        return t.nexts.push({
          resolve: l,
          value: e
        });
      });
    }, r.prototype.return = function(e) {
      R1(e);
      var t = xm.get(this);
      if (t === void 0)
        throw new Error("WeakMap error");
      return gg(t), t.execution = Promise.resolve(t.execution).then(function() {
        return e;
      }), Tf(t, Gd(t));
    }, r.prototype.throw = function(e) {
      var t = xm.get(this);
      if (t === void 0)
        throw new Error("WeakMap error");
      return t.state <= Z0 || t.state >= jf || typeof t.buffer < "u" && !t.buffer.empty ? (gg(t), t.err == null && (t.err = e), Tf(t, Gd(t))) : this.next(Promise.reject(e));
    }, r.prototype[Symbol.asyncIterator] = function() {
      return this;
    }, r.race = I4, r.merge = M4, r.zip = P4, r.latest = R4, r;
  }()
);
function Ly(r, e) {
  var t, n, i = [], s = function(m) {
    m != null && typeof m[Symbol.asyncIterator] == "function" ? i.push(m[Symbol.asyncIterator]()) : m != null && typeof m[Symbol.iterator] == "function" ? i.push(m[Symbol.iterator]()) : i.push(function() {
      return T4(this, arguments, function() {
        return Gh(this, function(M) {
          switch (M.label) {
            case 0:
              return e.yieldValues ? [4, Mg(m)] : [3, 3];
            case 1:
              return [4, M.sent()];
            case 2:
              M.sent(), M.label = 3;
            case 3:
              return e.returnValues ? [4, Mg(m)] : [3, 5];
            case 4:
              return [2, M.sent()];
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }());
  };
  try {
    for (var l = pp(r), o = l.next(); !o.done; o = l.next()) {
      var d = o.value;
      s(d);
    }
  } catch (m) {
    t = {
      error: m
    };
  } finally {
    try {
      o && !o.done && (n = l.return) && n.call(l);
    } finally {
      if (t) throw t.error;
    }
  }
  return i;
}
function I4(r) {
  var e = this, t = Ly(r, {
    returnValues: !0
  });
  return new Gg(function(n, i) {
    return rp(e, void 0, void 0, function() {
      var s, l, o, d, m, b;
      return Gh(this, function(A) {
        switch (A.label) {
          case 0:
            if (!t.length)
              return i(), [
                2
                /*return*/
              ];
            l = !1, i.then(function() {
              s(), l = !0;
            }), A.label = 1;
          case 1:
            A.trys.push([1, , 5, 7]), d = void 0, m = 0, b = function() {
              var M, E, k, U, V, q;
              return Gh(this, function(Y) {
                switch (Y.label) {
                  case 0:
                    M = m;
                    try {
                      for (E = (V = void 0, pp(t)), k = E.next(); !k.done; k = E.next())
                        U = k.value, Promise.resolve(U.next()).then(function(re) {
                          re.done ? (i(), o === void 0 && (o = re)) : m === M && (m++, s(re));
                        }, function(re) {
                          return i(re);
                        });
                    } catch (re) {
                      V = {
                        error: re
                      };
                    } finally {
                      try {
                        k && !k.done && (q = E.return) && q.call(E);
                      } finally {
                        if (V) throw V.error;
                      }
                    }
                    return [4, new Promise(function(re) {
                      return s = re;
                    })];
                  case 1:
                    return d = Y.sent(), d === void 0 ? [3, 3] : [4, n(d.value)];
                  case 2:
                    Y.sent(), Y.label = 3;
                  case 3:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            }, A.label = 2;
          case 2:
            return l ? [3, 4] : [5, b()];
          case 3:
            return A.sent(), [3, 2];
          case 4:
            return [2, o && o.value];
          case 5:
            return i(), [4, Promise.race(t.map(function(M) {
              return M.return && M.return();
            }))];
          case 6:
            return A.sent(), [
              7
              /*endfinally*/
            ];
          case 7:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
function M4(r) {
  var e = this, t = Ly(r, {
    yieldValues: !0
  });
  return new Gg(function(n, i) {
    return rp(e, void 0, void 0, function() {
      var s, l, o, d = this;
      return Gh(this, function(m) {
        switch (m.label) {
          case 0:
            if (!t.length)
              return i(), [
                2
                /*return*/
              ];
            s = [], l = !1, i.then(function() {
              var b, A;
              l = !0;
              try {
                for (var M = pp(s), E = M.next(); !E.done; E = M.next()) {
                  var k = E.value;
                  k();
                }
              } catch (U) {
                b = {
                  error: U
                };
              } finally {
                try {
                  E && !E.done && (A = M.return) && A.call(M);
                } finally {
                  if (b) throw b.error;
                }
              }
            }), m.label = 1;
          case 1:
            return m.trys.push([1, , 3, 4]), [4, Promise.all(t.map(function(b, A) {
              return rp(d, void 0, void 0, function() {
                var M, E;
                return Gh(this, function(k) {
                  switch (k.label) {
                    case 0:
                      k.trys.push([0, , 6, 9]), k.label = 1;
                    case 1:
                      return l ? [3, 5] : (Promise.resolve(b.next()).then(function(U) {
                        return s[A](U);
                      }, function(U) {
                        return i(U);
                      }), [4, new Promise(function(U) {
                        s[A] = U;
                      })]);
                    case 2:
                      return M = k.sent(), M === void 0 ? [3, 4] : M.done ? (o = M, [
                        2
                        /*return*/
                      ]) : [4, n(M.value)];
                    case 3:
                      k.sent(), k.label = 4;
                    case 4:
                      return [3, 1];
                    case 5:
                      return [3, 9];
                    case 6:
                      return E = b.return, E ? [4, b.return()] : [3, 8];
                    case 7:
                      E = k.sent(), k.label = 8;
                    case 8:
                      return [
                        7
                        /*endfinally*/
                      ];
                    case 9:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }))];
          case 2:
            return m.sent(), [2, o && o.value];
          case 3:
            return i(), [
              7
              /*endfinally*/
            ];
          case 4:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
function P4(r) {
  var e = this, t = Ly(r, {
    returnValues: !0
  });
  return new Gg(function(n, i) {
    return rp(e, void 0, void 0, function() {
      var s, l, o, d;
      return Gh(this, function(m) {
        switch (m.label) {
          case 0:
            if (!t.length)
              return i(), [2, []];
            l = !1, i.then(function() {
              s(), l = !0;
            }), m.label = 1;
          case 1:
            m.trys.push([1, , 6, 8]), m.label = 2;
          case 2:
            return l ? [3, 5] : (Promise.all(t.map(function(b) {
              return b.next();
            })).then(function(b) {
              return s(b);
            }, function(b) {
              return i(b);
            }), [4, new Promise(function(b) {
              return s = b;
            })]);
          case 3:
            return o = m.sent(), o === void 0 ? [
              2
              /*return*/
            ] : (d = o.map(function(b) {
              return b.value;
            }), o.some(function(b) {
              return b.done;
            }) ? [2, d] : [4, n(d)]);
          case 4:
            return m.sent(), [3, 2];
          case 5:
            return [3, 8];
          case 6:
            return i(), [4, Promise.all(t.map(function(b) {
              return b.return && b.return();
            }))];
          case 7:
            return m.sent(), [
              7
              /*endfinally*/
            ];
          case 8:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
function R4(r) {
  var e = this, t = Ly(r, {
    yieldValues: !0,
    returnValues: !0
  });
  return new Gg(function(n, i) {
    return rp(e, void 0, void 0, function() {
      var s, l, o, d, m, b = this;
      return Gh(this, function(A) {
        switch (A.label) {
          case 0:
            if (!t.length)
              return i(), [2, []];
            l = [], o = !1, i.then(function() {
              var M, E;
              s();
              try {
                for (var k = pp(l), U = k.next(); !U.done; U = k.next()) {
                  var V = U.value;
                  V();
                }
              } catch (q) {
                M = {
                  error: q
                };
              } finally {
                try {
                  U && !U.done && (E = k.return) && E.call(k);
                } finally {
                  if (M) throw M.error;
                }
              }
              o = !0;
            }), A.label = 1;
          case 1:
            return A.trys.push([1, , 5, 7]), Promise.all(t.map(function(M) {
              return M.next();
            })).then(function(M) {
              return s(M);
            }, function(M) {
              return i(M);
            }), [4, new Promise(function(M) {
              return s = M;
            })];
          case 2:
            return d = A.sent(), d === void 0 ? [
              2
              /*return*/
            ] : (m = d.map(function(M) {
              return M.value;
            }), d.every(function(M) {
              return M.done;
            }) ? [2, m] : [4, n(m.slice())]);
          case 3:
            return A.sent(), [4, Promise.all(t.map(function(M, E) {
              return rp(b, void 0, void 0, function() {
                var k;
                return Gh(this, function(U) {
                  switch (U.label) {
                    case 0:
                      if (d[E].done)
                        return [2, d[E].value];
                      U.label = 1;
                    case 1:
                      return o ? [3, 4] : (Promise.resolve(M.next()).then(function(V) {
                        return l[E](V);
                      }, function(V) {
                        return i(V);
                      }), [4, new Promise(function(V) {
                        return l[E] = V;
                      })]);
                    case 2:
                      return k = U.sent(), k === void 0 ? [2, d[E].value] : k.done ? [2, k.value] : (m[E] = k.value, [4, n(m.slice())]);
                    case 3:
                      return U.sent(), [3, 1];
                    case 4:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }))];
          case 4:
            return [2, A.sent()];
          case 5:
            return i(), [4, Promise.all(t.map(function(M) {
              return M.return && M.return();
            }))];
          case 6:
            return A.sent(), [
              7
              /*endfinally*/
            ];
          case 7:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
class s2 {
  constructor(e, t, n, i, s) {
    H(this, "headerClient");
    H(this, "header");
    H(this, "headerLength");
    H(this, "indexLength");
    H(this, "nocache");
    this.headerClient = e, this.header = t, this.headerLength = n, this.indexLength = i, this.nocache = s;
  }
  static async open(e, t) {
    let n, i = new vA(e, t), s = 2024 + (() => {
      let m, b = 0;
      for (m = 0; m < 3; m++) b += v4 ** m * b4;
      return b;
    })();
    if (!new Uint8Array(await i.getRange(0, 8, s, "header")).subarray(0, 3).every((m, b) => If[b] === m)) throw Error("Not a FlatGeobuf file");
    if ((n = new DataView(await i.getRange(8, 4, s, "header")).getUint32(0, !0)) > 10485760 || n < 8) throw Error("Invalid header size");
    let l = await i.getRange(12, n, s, "header"), o = r2(new th(new Uint8Array(l)));
    if (o.indexNodeSize === 0) throw Error("No index found, cannot read features filtered by bbox");
    let d = n2(o.featuresCount, o.indexNodeSize);
    return new s2(i, o, n, d, t);
  }
  async *selectBbox(e) {
    let t = this.lengthBeforeTree(), n = this.headerClient, i = async (d, m) => n.getRange(t + d, m, 0, "index"), s = [], l = [];
    for await (let d of w4(this.header.featuresCount, this.header.indexNodeSize, e, i)) {
      let [m, b] = d, [, , A] = d;
      if (A || (A = 4), l.length === 0) {
        l.push([m, A, b]);
        continue;
      }
      let M = l[l.length - 1];
      m - (M[0] + M[1]) > NE.global.extraRequestThreshold() && (s.push(l), l = []), l.push([m, A, b]);
    }
    this.headerClient.logUsage("header+index"), l.length > 0 && s.push(l);
    let o = s.flatMap((d) => this.readFeatureBatch(d, this.nocache));
    yield* Gg.merge(o);
  }
  lengthBeforeTree() {
    return If.length + Ju + this.headerLength;
  }
  lengthBeforeFeatures() {
    return this.lengthBeforeTree() + this.indexLength;
  }
  buildFeatureClient(e) {
    return new vA(this.headerClient.httpClient, e);
  }
  async *readFeatureBatch(e, t) {
    let [n] = e[0], [i, s] = e[e.length - 1], l = this.buildFeatureClient(t), o = i + s - n;
    for (let [d, , m] of e) {
      let b = await this.readFeature(l, d, o);
      yield {
        id: m,
        feature: b
      }, o = 0;
    }
    l.logUsage("feature");
  }
  async readFeature(e, t, n) {
    let i, s = t + this.lengthBeforeFeatures();
    i = new DataView(await e.getRange(s, 4, n, "feature length")).getUint32(0, !0);
    let l = new Uint8Array(await e.getRange(s + 4, i, n, "feature data")), o = new Uint8Array(i + Ju);
    o.set(l, Ju);
    let d = new th(o);
    return d.setPosition(Ju), xc.getRootAsFeature(d);
  }
}
let vA = class {
  constructor(e, t) {
    H(this, "httpClient");
    H(this, "bytesEverUsed", 0);
    H(this, "bytesEverFetched", 0);
    H(this, "buffer", new ArrayBuffer(0));
    H(this, "head", 0);
    if (typeof e == "string") this.httpClient = new xA(e, t);
    else if (e instanceof xA) this.httpClient = e;
    else throw Error("Unknown source");
  }
  async getRange(e, t, n, i) {
    this.bytesEverUsed += t;
    let s = e - this.head, l = s + t;
    if (s >= 0 && l <= this.buffer.byteLength) return this.buffer.slice(s, l);
    let o = Math.max(t, n);
    return this.bytesEverFetched += o, this.buffer = await this.httpClient.getRange(e, o, i), this.head = e, this.buffer.slice(0, t);
  }
  logUsage(e) {
    e.split(" ")[0], (100 * this.bytesEverUsed / this.bytesEverFetched).toFixed(2);
  }
}, xA = class {
  constructor(e, t) {
    H(this, "url");
    H(this, "nocache");
    H(this, "requestsEverMade", 0);
    H(this, "bytesEverRequested", 0);
    this.url = e, this.nocache = t;
  }
  async getRange(e, t, n) {
    this.requestsEverMade += 1, this.bytesEverRequested += t;
    let i = {
      Range: `bytes=${e}-${e + t - 1}`
    };
    return this.nocache && (i["Cache-Control"] = "no-cache, no-store"), await (await fetch(this.url, {
      headers: i
    })).arrayBuffer();
  }
};
async function* B4(r, e, t, n) {
  if (!r.subarray(0, 3).every((A, M) => If[M] === A)) throw Error("Not a FlatGeobuf file");
  let i = new th(r), s = i.readUint32(If.length);
  i.setPosition(If.length + Ju);
  let l = r2(i), o = If.length + Ju + s, {
    indexNodeSize: d,
    featuresCount: m
  } = l;
  d > 0 && (o += n2(m, d));
  let b = 0;
  for (; o < i.capacity(); ) {
    let A = i.readUint32(o);
    i.setPosition(o + Ju);
    let M = xc.getRootAsFeature(i);
    yield e(b++, M, l), o += Ju + A;
  }
}
async function* L4(r, e, t) {
  let n, i = y4(r), s = async (E) => await i.slice(E), l = new Uint8Array(await s(8));
  if (!l.subarray(0, 3).every((E, k) => If[k] === E)) throw Error("Not a FlatGeobuf file");
  l = new Uint8Array(await s(4));
  let o = new th(l), d = o.readUint32(0);
  l = new Uint8Array(await s(d));
  let m = r2(o = new th(l)), {
    indexNodeSize: b,
    featuresCount: A
  } = m;
  if (b > 0) {
    let E = n2(A, b);
    await s(E);
  }
  let M = 0;
  for (; n = await k4(s, m, e, M++); ) yield n;
}
function O4(r, e, t, n) {
  try {
    let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
    return async function* () {
      let s = await s2.open(r, i);
      for await (let l of (n && n(s.header), s.selectBbox(e))) yield t(l.id, l.feature, s.header);
    }();
  } catch (i) {
    return Promise.reject(i);
  }
}
async function k4(r, e, t, n) {
  let i = new Uint8Array(await r(4, "feature length"));
  if (i.byteLength === 0) return;
  let s = new th(i), l = s.readUint32(0);
  i = new Uint8Array(await r(l, "feature data"));
  let o = new Uint8Array(l + 4);
  return o.set(i, 4), (s = new th(o)).setPosition(Ju), t(n, xc.getRootAsFeature(s), e);
}
function L1(r, e) {
  let t = e;
  if (t === Jo.Unknown && (t = r.type()), t === Jo.GeometryCollection) {
    let i = [];
    for (let s = 0; s < r.partsLength(); s++) {
      let l = r.parts(s), o = l.type();
      i.push(L1(l, o));
    }
    return {
      type: Jo[t],
      geometries: i
    };
  }
  if (t === Jo.MultiPolygon) {
    let i = [];
    for (let s = 0; s < r.partsLength(); s++) i.push(L1(r.parts(s), Jo.Polygon));
    return {
      type: Jo[t],
      coordinates: i.map((s) => s.coordinates)
    };
  }
  let n = function(i, s) {
    let l = i.xyArray(), o = i.zArray();
    switch (s) {
      case Jo.Point: {
        let d = Array.from(l);
        return o && d.push(o[0]), d;
      }
      case Jo.MultiPoint:
      case Jo.LineString:
        return X0(l, o);
      case Jo.MultiLineString:
      case Jo.Polygon:
        return function(d, m, b) {
          let A;
          if (!b || b.length === 0) return [X0(d, m)];
          let M = 0, E = Array.from(b).map((k) => d.slice(M, M = k << 1));
          return m && (M = 0, A = Array.from(b).map((k) => m.slice(M, M = k))), E.map((k, U) => X0(k, A ? A[U] : void 0));
        }(l, o, i.endsArray());
    }
  }(r, t);
  return {
    type: Jo[t],
    coordinates: n
  };
}
function o2(r, e, t) {
  let n = t.columns;
  return {
    type: "Feature",
    id: r,
    geometry: L1(e.geometry(), t.geometryType),
    properties: d4(e, n)
  };
}
async function* N4(r, e, t) {
  yield* B4(r, o2);
}
function D4(r, e) {
  return L4(r, o2);
}
function F4(r, e, t) {
  let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  return O4(r, e, o2, t, n);
}
function wA(r, e, t) {
  let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  return r instanceof Uint8Array ? N4(r) : r instanceof ReadableStream ? D4(r) : F4(r, e, t, n);
}
class U4 {
  constructor() {
    this._bearing = 0, this._pitch = 60, this._minpitchzoom = null;
  }
  onAdd(e) {
    this._map = e;
    let t = this;
    return this._btn = document.createElement("button"), this._btn.className = "maplibregl-ctrl-icon maplibregl-ctrl-pitchtoggle-2d", this._btn.id = "bt3D", this._btn.type = "button", this._btn["aria-label"] = "Vista 3D", this._btn.onclick = function() {
      if (t._btn.className.indexOf("3d") != -1) {
        let m = {
          pitch: t._pitch,
          bearing: t._bearing
        };
        t._minpitchzoom && e.getZoom() > t._minpitchzoom && (m.zoom = t._minpitchzoom);
        var n = 0, i = 38.5, s = 6, l = 62.33, {
          longitude: o,
          latitude: d
        } = e.getCenter();
        e.getZoom() < 10 ? e.setTerrain({
          source: "terrainICGC",
          exaggeration: 1.5
        }) : o >= n && o <= s && d >= i && d <= l ? e.setTerrain({
          source: "terrainICGC",
          exaggeration: 1.2
        }) : e.setTerrain({
          source: "terrainICGC",
          exaggeration: 1.5
        }), e.easeTo(m), t._btn.className = "maplibregl-ctrl-icon maplibregl-ctrl-pitchtoggle-2d";
      } else
        e.setTerrain(null), e.easeTo({
          pitch: 0,
          bearing: 0
        }), t._btn.className = "maplibregl-ctrl-icon maplibregl-ctrl-pitchtoggle-3d";
    }, this._container = document.createElement("div"), this._container.className = "maplibregl-ctrl maplibregl-ctrl-group", this._container.title = "Vista 3D", this._container.appendChild(this._btn), this._container;
  }
  onRemove() {
    this._container.parentNode.removeChild(this._container), this._map = void 0;
  }
}
async function Hg(r, e, t, n) {
  return n._parse(r, e, t, n);
}
function Mi(r, e) {
  if (!r)
    throw new Error(e || "loader assertion failed.");
}
const Oy = (
  // @ts-ignore process does not exist on browser
  !!(typeof process != "object" || String(process) !== "[object process]" || process.browser)
), AA = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version);
AA && parseFloat(AA[1]);
const wm = globalThis, bd = globalThis.process || {}, z4 = globalThis.navigator || {};
function FE(r) {
  var n, i;
  if (typeof window < "u" && ((n = window.process) == null ? void 0 : n.type) === "renderer" || typeof process < "u" && ((i = process.versions) != null && i.electron))
    return !0;
  const t = typeof navigator < "u" && navigator.userAgent;
  return !!(t && t.indexOf("Electron") >= 0);
}
function Wf() {
  return !// @ts-expect-error
  (typeof process == "object" && String(process) === "[object process]" && !(process != null && process.browser)) || FE();
}
function j4(r) {
  return Wf() ? FE() ? "Electron" : (z4.userAgent || "").indexOf("Edge") > -1 ? "Edge" : globalThis.chrome ? "Chrome" : globalThis.safari ? "Safari" : globalThis.mozInnerScreenX ? "Firefox" : "Unknown" : "Node";
}
const UE = "4.1.0";
function V4(r) {
  try {
    const e = window[r], t = "__storage_test__";
    return e.setItem(t, t), e.removeItem(t), e;
  } catch {
    return null;
  }
}
class $4 {
  constructor(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "sessionStorage";
    this.storage = V4(n), this.id = e, this.config = t, this._loadConfiguration();
  }
  getConfiguration() {
    return this.config;
  }
  setConfiguration(e) {
    if (Object.assign(this.config, e), this.storage) {
      const t = JSON.stringify(this.config);
      this.storage.setItem(this.id, t);
    }
  }
  // Get config from persistent store, if available
  _loadConfiguration() {
    let e = {};
    if (this.storage) {
      const t = this.storage.getItem(this.id);
      e = t ? JSON.parse(t) : {};
    }
    return Object.assign(this.config, e), this;
  }
}
function q4(r) {
  let e;
  return r < 10 ? e = `${r.toFixed(2)}ms` : r < 100 ? e = `${r.toFixed(1)}ms` : r < 1e3 ? e = `${r.toFixed(0)}ms` : e = `${(r / 1e3).toFixed(2)}s`, e;
}
function G4(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;
  const t = Math.max(e - r.length, 0);
  return `${" ".repeat(t)}${r}`;
}
var L_;
(function(r) {
  r[r.BLACK = 30] = "BLACK", r[r.RED = 31] = "RED", r[r.GREEN = 32] = "GREEN", r[r.YELLOW = 33] = "YELLOW", r[r.BLUE = 34] = "BLUE", r[r.MAGENTA = 35] = "MAGENTA", r[r.CYAN = 36] = "CYAN", r[r.WHITE = 37] = "WHITE", r[r.BRIGHT_BLACK = 90] = "BRIGHT_BLACK", r[r.BRIGHT_RED = 91] = "BRIGHT_RED", r[r.BRIGHT_GREEN = 92] = "BRIGHT_GREEN", r[r.BRIGHT_YELLOW = 93] = "BRIGHT_YELLOW", r[r.BRIGHT_BLUE = 94] = "BRIGHT_BLUE", r[r.BRIGHT_MAGENTA = 95] = "BRIGHT_MAGENTA", r[r.BRIGHT_CYAN = 96] = "BRIGHT_CYAN", r[r.BRIGHT_WHITE = 97] = "BRIGHT_WHITE";
})(L_ || (L_ = {}));
const H4 = 10;
function TA(r) {
  return typeof r != "string" ? r : (r = r.toUpperCase(), L_[r] || L_.WHITE);
}
function W4(r, e, t) {
  return !Wf && typeof r == "string" && (e && (r = `\x1B[${TA(e)}m${r}\x1B[39m`), t && (r = `\x1B[${TA(t) + H4}m${r}\x1B[49m`)), r;
}
function X4(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ["constructor"];
  const t = Object.getPrototypeOf(r), n = Object.getOwnPropertyNames(t), i = r;
  for (const s of n) {
    const l = i[s];
    typeof l == "function" && (e.find((o) => s === o) || (i[s] = l.bind(r)));
  }
}
function a2(r, e) {
  if (!r)
    throw new Error("Assertion failed");
}
function vd() {
  var e, t, n;
  let r;
  if (Wf() && wm.performance)
    r = (t = (e = wm == null ? void 0 : wm.performance) == null ? void 0 : e.now) == null ? void 0 : t.call(e);
  else if ("hrtime" in bd) {
    const i = (n = bd == null ? void 0 : bd.hrtime) == null ? void 0 : n.call(bd);
    r = i[0] * 1e3 + i[1] / 1e6;
  } else
    r = Date.now();
  return r;
}
const xd = {
  debug: Wf() && console.debug || console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
}, Z4 = {
  enabled: !0,
  level: 0
};
function wd() {
}
const SA = {}, EA = {
  once: !0
};
class gp {
  constructor() {
    let {
      id: e
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      id: ""
    };
    this.VERSION = UE, this._startTs = vd(), this._deltaTs = vd(), this.userData = {}, this.LOG_THROTTLE_TIMEOUT = 0, this.id = e, this.userData = {}, this._storage = new $4(`__probe-${this.id}__`, Z4), this.timeStamp(`${this.id} started`), X4(this), Object.seal(this);
  }
  set level(e) {
    this.setLevel(e);
  }
  get level() {
    return this.getLevel();
  }
  isEnabled() {
    return this._storage.config.enabled;
  }
  getLevel() {
    return this._storage.config.level;
  }
  /** @return milliseconds, with fractions */
  getTotal() {
    return Number((vd() - this._startTs).toPrecision(10));
  }
  /** @return milliseconds, with fractions */
  getDelta() {
    return Number((vd() - this._deltaTs).toPrecision(10));
  }
  /** @deprecated use logLevel */
  set priority(e) {
    this.level = e;
  }
  /** @deprecated use logLevel */
  get priority() {
    return this.level;
  }
  /** @deprecated use logLevel */
  getPriority() {
    return this.level;
  }
  // Configure
  enable() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    return this._storage.setConfiguration({
      enabled: e
    }), this;
  }
  setLevel(e) {
    return this._storage.setConfiguration({
      level: e
    }), this;
  }
  /** return the current status of the setting */
  get(e) {
    return this._storage.config[e];
  }
  // update the status of the setting
  set(e, t) {
    this._storage.setConfiguration({
      [e]: t
    });
  }
  /** Logs the current settings as a table */
  settings() {
    console.table ? console.table(this._storage.config) : console.log(this._storage.config);
  }
  // Unconditional logging
  assert(e, t) {
    if (!e)
      throw new Error(t || "Assertion failed");
  }
  warn(e) {
    return this._getLogFunction(0, e, xd.warn, arguments, EA);
  }
  error(e) {
    return this._getLogFunction(0, e, xd.error, arguments);
  }
  /** Print a deprecation warning */
  deprecated(e, t) {
    return this.warn(`\`${e}\` is deprecated and will be removed in a later version. Use \`${t}\` instead`);
  }
  /** Print a removal warning */
  removed(e, t) {
    return this.error(`\`${e}\` has been removed. Use \`${t}\` instead`);
  }
  probe(e, t) {
    return this._getLogFunction(e, t, xd.log, arguments, {
      time: !0,
      once: !0
    });
  }
  log(e, t) {
    return this._getLogFunction(e, t, xd.debug, arguments);
  }
  info(e, t) {
    return this._getLogFunction(e, t, console.info, arguments);
  }
  once(e, t) {
    return this._getLogFunction(e, t, xd.debug || xd.info, arguments, EA);
  }
  /** Logs an object as a table */
  table(e, t, n) {
    return t ? this._getLogFunction(e, t, console.table || wd, n && [n], {
      tag: K4(t)
    }) : wd;
  }
  time(e, t) {
    return this._getLogFunction(e, t, console.time ? console.time : console.info);
  }
  timeEnd(e, t) {
    return this._getLogFunction(e, t, console.timeEnd ? console.timeEnd : console.info);
  }
  timeStamp(e, t) {
    return this._getLogFunction(e, t, console.timeStamp || wd);
  }
  group(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      collapsed: !1
    };
    const i = CA({
      logLevel: e,
      message: t,
      opts: n
    }), {
      collapsed: s
    } = n;
    return i.method = (s ? console.groupCollapsed : console.group) || console.info, this._getLogFunction(i);
  }
  groupCollapsed(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.group(e, t, Object.assign({}, n, {
      collapsed: !0
    }));
  }
  groupEnd(e) {
    return this._getLogFunction(e, "", console.groupEnd || wd);
  }
  // EXPERIMENTAL
  withGroup(e, t, n) {
    this.group(e, t)();
    try {
      n();
    } finally {
      this.groupEnd(e)();
    }
  }
  trace() {
    console.trace && console.trace();
  }
  // PRIVATE METHODS
  /** Deduces log level from a variety of arguments */
  _shouldLog(e) {
    return this.isEnabled() && this.getLevel() >= zE(e);
  }
  _getLogFunction(e, t, n, i, s) {
    if (this._shouldLog(e)) {
      s = CA({
        logLevel: e,
        message: t,
        args: i,
        opts: s
      }), n = n || s.method, a2(n), s.total = this.getTotal(), s.delta = this.getDelta(), this._deltaTs = vd();
      const l = s.tag || s.message;
      if (s.once && l)
        if (!SA[l])
          SA[l] = vd();
        else
          return wd;
      return t = Y4(this.id, s.message, s), n.bind(console, t, ...s.args);
    }
    return wd;
  }
}
gp.VERSION = UE;
function zE(r) {
  if (!r)
    return 0;
  let e;
  switch (typeof r) {
    case "number":
      e = r;
      break;
    case "object":
      e = r.logLevel || r.priority || 0;
      break;
    default:
      return 0;
  }
  return a2(Number.isFinite(e) && e >= 0), e;
}
function CA(r) {
  const {
    logLevel: e,
    message: t
  } = r;
  r.logLevel = zE(e);
  const n = r.args ? Array.from(r.args) : [];
  for (; n.length && n.shift() !== t; )
    ;
  switch (typeof e) {
    case "string":
    case "function":
      t !== void 0 && n.unshift(t), r.message = e;
      break;
    case "object":
      Object.assign(r, e);
      break;
  }
  typeof r.message == "function" && (r.message = r.message());
  const i = typeof r.message;
  return a2(i === "string" || i === "object"), Object.assign(r, {
    args: n
  }, r.opts);
}
function Y4(r, e, t) {
  if (typeof e == "string") {
    const n = t.time ? G4(q4(t.total)) : "";
    e = t.time ? `${r}: ${n}  ${e}` : `${r}: ${e}`, e = W4(e, t.color, t.background);
  }
  return e;
}
function K4(r) {
  for (const e in r)
    for (const t in r[e])
      return t || "untitled";
  return "empty";
}
globalThis.probe = {};
const jE = new gp({
  id: "@probe.gl/log"
}), Y0 = "4.3.2", J4 = Y0[0] >= "0" && Y0[0] <= "9" ? `v${Y0}` : "";
function Q4() {
  const r = new gp({
    id: "loaders.gl"
  });
  return globalThis.loaders = globalThis.loaders || {}, globalThis.loaders.log = r, globalThis.loaders.version = J4, globalThis.probe = globalThis.probe || {}, globalThis.probe.loaders = r, r;
}
const eB = Q4();
function tB(r, e) {
  return VE(r || {}, e);
}
function VE(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  if (t > 3)
    return e;
  const n = {
    ...r
  };
  for (const [i, s] of Object.entries(e))
    s && typeof s == "object" && !Array.isArray(s) ? n[i] = VE(n[i] || {}, e[i], t + 1) : n[i] = e[i];
  return n;
}
function rB(r) {
  var e;
  globalThis.loaders || (globalThis.loaders = {}), (e = globalThis.loaders).modules || (e.modules = {}), Object.assign(globalThis.loaders.modules, r);
}
function nB(r) {
  var t, n;
  return ((n = (t = globalThis.loaders) == null ? void 0 : t.modules) == null ? void 0 : n[r]) || null;
}
const iB = "latest";
function sB() {
  var r;
  return (r = globalThis._loadersgl_) != null && r.version || (globalThis._loadersgl_ = globalThis._loadersgl_ || {}, globalThis._loadersgl_.version = "4.3.2"), globalThis._loadersgl_.version;
}
const $E = sB();
function rh(r, e) {
  if (!r)
    throw new Error(e || "loaders.gl assertion failed.");
}
const Dl = (
  // @ts-ignore process.browser
  typeof process != "object" || String(process) !== "[object process]" || process.browser
), l2 = typeof importScripts == "function", oB = typeof window < "u" && typeof window.orientation < "u", IA = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version);
IA && parseFloat(IA[1]);
class aB {
  constructor(e, t) {
    H(this, "name");
    H(this, "workerThread");
    H(this, "isRunning", !0);
    /** Promise that resolves when Job is done */
    H(this, "result");
    H(this, "_resolve", () => {
    });
    H(this, "_reject", () => {
    });
    this.name = e, this.workerThread = t, this.result = new Promise((n, i) => {
      this._resolve = n, this._reject = i;
    });
  }
  /**
   * Send a message to the job's worker thread
   * @param data any data structure, ideally consisting mostly of transferrable objects
   */
  postMessage(e, t) {
    this.workerThread.postMessage({
      source: "loaders.gl",
      // Lets worker ignore unrelated messages
      type: e,
      payload: t
    });
  }
  /**
   * Call to resolve the `result` Promise with the supplied value
   */
  done(e) {
    rh(this.isRunning), this.isRunning = !1, this._resolve(e);
  }
  /**
   * Call to reject the `result` Promise with the supplied error
   */
  error(e) {
    rh(this.isRunning), this.isRunning = !1, this._reject(e);
  }
}
class K0 {
  terminate() {
  }
}
const J0 = /* @__PURE__ */ new Map();
function lB(r) {
  rh(r.source && !r.url || !r.source && r.url);
  let e = J0.get(r.source || r.url);
  return e || (r.url && (e = cB(r.url), J0.set(r.url, e)), r.source && (e = qE(r.source), J0.set(r.source, e))), rh(e), e;
}
function cB(r) {
  if (!r.startsWith("http"))
    return r;
  const e = uB(r);
  return qE(e);
}
function qE(r) {
  const e = new Blob([r], {
    type: "application/javascript"
  });
  return URL.createObjectURL(e);
}
function uB(r) {
  return `try {
  importScripts('${r}');
} catch (error) {
  console.error(error);
  throw error;
}`;
}
function GE(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, t = arguments.length > 2 ? arguments[2] : void 0;
  const n = t || /* @__PURE__ */ new Set();
  if (r) {
    if (MA(r))
      n.add(r);
    else if (MA(r.buffer))
      n.add(r.buffer);
    else if (!ArrayBuffer.isView(r)) {
      if (e && typeof r == "object")
        for (const i in r)
          GE(r[i], e, n);
    }
  }
  return t === void 0 ? Array.from(n) : [];
}
function MA(r) {
  return r ? r instanceof ArrayBuffer || typeof MessagePort < "u" && r instanceof MessagePort || typeof ImageBitmap < "u" && r instanceof ImageBitmap || typeof OffscreenCanvas < "u" && r instanceof OffscreenCanvas : !1;
}
const Q0 = () => {
};
class O1 {
  constructor(e) {
    H(this, "name");
    H(this, "source");
    H(this, "url");
    H(this, "terminated", !1);
    H(this, "worker");
    H(this, "onMessage");
    H(this, "onError");
    H(this, "_loadableURL", "");
    const {
      name: t,
      source: n,
      url: i
    } = e;
    rh(n || i), this.name = t, this.source = n, this.url = i, this.onMessage = Q0, this.onError = (s) => console.log(s), this.worker = Dl ? this._createBrowserWorker() : this._createNodeWorker();
  }
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return typeof Worker < "u" && Dl || typeof K0 < "u" && !Dl;
  }
  /**
   * Terminate this worker thread
   * @note Can free up significant memory
   */
  destroy() {
    this.onMessage = Q0, this.onError = Q0, this.worker.terminate(), this.terminated = !0;
  }
  get isRunning() {
    return !!this.onMessage;
  }
  /**
   * Send a message to this worker thread
   * @param data any data structure, ideally consisting mostly of transferrable objects
   * @param transferList If not supplied, calculated automatically by traversing data
   */
  postMessage(e, t) {
    t = t || GE(e), this.worker.postMessage(e, t);
  }
  // PRIVATE
  /**
   * Generate a standard Error from an ErrorEvent
   * @param event
   */
  _getErrorFromErrorEvent(e) {
    let t = "Failed to load ";
    return t += `worker ${this.name} from ${this.url}. `, e.message && (t += `${e.message} in `), e.lineno && (t += `:${e.lineno}:${e.colno}`), new Error(t);
  }
  /**
   * Creates a worker thread on the browser
   */
  _createBrowserWorker() {
    this._loadableURL = lB({
      source: this.source,
      url: this.url
    });
    const e = new Worker(this._loadableURL, {
      name: this.name
    });
    return e.onmessage = (t) => {
      t.data ? this.onMessage(t.data) : this.onError(new Error("No data received"));
    }, e.onerror = (t) => {
      this.onError(this._getErrorFromErrorEvent(t)), this.terminated = !0;
    }, e.onmessageerror = (t) => console.error(t), e;
  }
  /**
   * Creates a worker thread in node.js
   * @todo https://nodejs.org/api/async_hooks.html#async-resource-worker-pool
   */
  _createNodeWorker() {
    let e;
    if (this.url) {
      const n = this.url.includes(":/") || this.url.startsWith("/") ? this.url : `./${this.url}`;
      e = new K0(n, {
        eval: !1
      });
    } else if (this.source)
      e = new K0(this.source, {
        eval: !0
      });
    else
      throw new Error("no worker");
    return e.on("message", (t) => {
      this.onMessage(t);
    }), e.on("error", (t) => {
      this.onError(t);
    }), e.on("exit", (t) => {
    }), e;
  }
}
class hB {
  /**
   * @param processor - worker function
   * @param maxConcurrency - max count of workers
   */
  constructor(e) {
    H(this, "name", "unnamed");
    H(this, "source");
    // | Function;
    H(this, "url");
    H(this, "maxConcurrency", 1);
    H(this, "maxMobileConcurrency", 1);
    H(this, "onDebug", () => {
    });
    H(this, "reuseWorkers", !0);
    H(this, "props", {});
    H(this, "jobQueue", []);
    H(this, "idleQueue", []);
    H(this, "count", 0);
    H(this, "isDestroyed", !1);
    this.source = e.source, this.url = e.url, this.setProps(e);
  }
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return O1.isSupported();
  }
  /**
   * Terminates all workers in the pool
   * @note Can free up significant memory
   */
  destroy() {
    this.idleQueue.forEach((e) => e.destroy()), this.isDestroyed = !0;
  }
  setProps(e) {
    this.props = {
      ...this.props,
      ...e
    }, e.name !== void 0 && (this.name = e.name), e.maxConcurrency !== void 0 && (this.maxConcurrency = e.maxConcurrency), e.maxMobileConcurrency !== void 0 && (this.maxMobileConcurrency = e.maxMobileConcurrency), e.reuseWorkers !== void 0 && (this.reuseWorkers = e.reuseWorkers), e.onDebug !== void 0 && (this.onDebug = e.onDebug);
  }
  async startJob(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (s, l, o) => s.done(o), n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (s, l) => s.error(l);
    const i = new Promise((s) => (this.jobQueue.push({
      name: e,
      onMessage: t,
      onError: n,
      onStart: s
    }), this));
    return this._startQueuedJob(), await i;
  }
  // PRIVATE
  /**
   * Starts first queued job if worker is available or can be created
   * Called when job is started and whenever a worker returns to the idleQueue
   */
  async _startQueuedJob() {
    if (!this.jobQueue.length)
      return;
    const e = this._getAvailableWorker();
    if (!e)
      return;
    const t = this.jobQueue.shift();
    if (t) {
      this.onDebug({
        message: "Starting job",
        name: t.name,
        workerThread: e,
        backlog: this.jobQueue.length
      });
      const n = new aB(t.name, e);
      e.onMessage = (i) => t.onMessage(n, i.type, i.payload), e.onError = (i) => t.onError(n, i), t.onStart(n);
      try {
        await n.result;
      } catch (i) {
        console.error(`Worker exception: ${i}`);
      } finally {
        this.returnWorkerToQueue(e);
      }
    }
  }
  /**
   * Returns a worker to the idle queue
   * Destroys the worker if
   *  - pool is destroyed
   *  - if this pool doesn't reuse workers
   *  - if maxConcurrency has been lowered
   * @param worker
   */
  returnWorkerToQueue(e) {
    // Workers on Node.js prevent the process from exiting.
    // Until we figure out how to close them before exit, we always destroy them
    !Dl || // If the pool is destroyed, there is no reason to keep the worker around
    this.isDestroyed || // If the app has disabled worker reuse, any completed workers should be destroyed
    !this.reuseWorkers || // If concurrency has been lowered, this worker might be surplus to requirements
    this.count > this._getMaxConcurrency() ? (e.destroy(), this.count--) : this.idleQueue.push(e), this.isDestroyed || this._startQueuedJob();
  }
  /**
   * Returns idle worker or creates new worker if maxConcurrency has not been reached
   */
  _getAvailableWorker() {
    if (this.idleQueue.length > 0)
      return this.idleQueue.shift() || null;
    if (this.count < this._getMaxConcurrency()) {
      this.count++;
      const e = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
      return new O1({
        name: e,
        source: this.source,
        url: this.url
      });
    }
    return null;
  }
  _getMaxConcurrency() {
    return oB ? this.maxMobileConcurrency : this.maxConcurrency;
  }
}
const fB = {
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: !0,
  onDebug: () => {
  }
}, Dh = class Dh {
  /** get global instance with WorkerFarm.getWorkerFarm() */
  constructor(e) {
    H(this, "props");
    H(this, "workerPools", /* @__PURE__ */ new Map());
    this.props = {
      ...fB
    }, this.setProps(e), this.workerPools = /* @__PURE__ */ new Map();
  }
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return O1.isSupported();
  }
  /** Get the singleton instance of the global worker farm */
  static getWorkerFarm() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Dh._workerFarm = Dh._workerFarm || new Dh({}), Dh._workerFarm.setProps(e), Dh._workerFarm;
  }
  /**
   * Terminate all workers in the farm
   * @note Can free up significant memory
   */
  destroy() {
    for (const e of this.workerPools.values())
      e.destroy();
    this.workerPools = /* @__PURE__ */ new Map();
  }
  /**
   * Set props used when initializing worker pools
   * @param props
   */
  setProps(e) {
    this.props = {
      ...this.props,
      ...e
    };
    for (const t of this.workerPools.values())
      t.setProps(this._getWorkerPoolProps());
  }
  /**
   * Returns a worker pool for the specified worker
   * @param options - only used first time for a specific worker name
   * @param options.name - the name of the worker - used to identify worker pool
   * @param options.url -
   * @param options.source -
   * @example
   *   const job = WorkerFarm.getWorkerFarm().getWorkerPool({name, url}).startJob(...);
   */
  getWorkerPool(e) {
    const {
      name: t,
      source: n,
      url: i
    } = e;
    let s = this.workerPools.get(t);
    return s || (s = new hB({
      name: t,
      source: n,
      url: i
    }), s.setProps(this._getWorkerPoolProps()), this.workerPools.set(t, s)), s;
  }
  _getWorkerPoolProps() {
    return {
      maxConcurrency: this.props.maxConcurrency,
      maxMobileConcurrency: this.props.maxMobileConcurrency,
      reuseWorkers: this.props.reuseWorkers,
      onDebug: this.props.onDebug
    };
  }
};
// singleton
H(Dh, "_workerFarm");
let O_ = Dh;
function dB(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = e[r.id] || {}, n = Dl ? `${r.id}-worker.js` : `${r.id}-worker-node.js`;
  let i = t.workerUrl;
  if (!i && r.id === "compression" && (i = e.workerUrl), e._workerType === "test" && (Dl ? i = `modules/${r.module}/dist/${n}` : i = `modules/${r.module}/src/workers/${r.id}-worker-node.ts`), !i) {
    let s = r.version;
    s === "latest" && (s = iB);
    const l = s ? `@${s}` : "";
    i = `https://unpkg.com/@loaders.gl/${r.module}${l}/dist/${n}`;
  }
  return rh(i), i;
}
function pB(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : $E;
  rh(r, "no worker provided");
  const t = r.version;
  return !(!e || !t);
}
const eb = {};
async function kf(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  return e && (r = gB(r, e, t, n)), eb[r] = // eslint-disable-next-line @typescript-eslint/no-misused-promises
  eb[r] || mB(r), await eb[r];
}
function gB(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  if (!t.useLocalLibraries && r.startsWith("http"))
    return r;
  n = n || r;
  const i = t.modules || {};
  return i[n] ? i[n] : Dl ? t.CDN ? (rh(t.CDN.startsWith("http")), `${t.CDN}/${e}@${$E}/dist/libs/${n}`) : l2 ? `../src/libs/${n}` : `modules/${e}/src/libs/${n}` : `modules/${e}/dist/libs/${n}`;
}
async function mB(r) {
  if (r.endsWith("wasm"))
    return await yB(r);
  if (!Dl)
    try {
      const {
        requireFromFile: t
      } = globalThis.loaders || {};
      return await (t == null ? void 0 : t(r));
    } catch (t) {
      return console.error(t), null;
    }
  if (l2)
    return importScripts(r);
  const e = await bB(r);
  return _B(e, r);
}
function _B(r, e) {
  if (!Dl) {
    const {
      requireFromString: n
    } = globalThis.loaders || {};
    return n == null ? void 0 : n(r, e);
  }
  if (l2)
    return eval.call(globalThis, r), null;
  const t = document.createElement("script");
  t.id = e;
  try {
    t.appendChild(document.createTextNode(r));
  } catch {
    t.text = r;
  }
  return document.body.appendChild(t), null;
}
async function yB(r) {
  const {
    readFileAsArrayBuffer: e
  } = globalThis.loaders || {};
  return Dl || !e || r.startsWith("http") ? await (await fetch(r)).arrayBuffer() : await e(r);
}
async function bB(r) {
  const {
    readFileAsText: e
  } = globalThis.loaders || {};
  return Dl || !e || r.startsWith("http") ? await (await fetch(r)).text() : await e(r);
}
function vB(r, e) {
  return !O_.isSupported() || !Dl && !(e != null && e._nodeWorkers) ? !1 : r.worker && (e == null ? void 0 : e.worker);
}
async function xB(r, e, t, n, i) {
  const s = r.id, l = dB(r, t), d = O_.getWorkerFarm(t).getWorkerPool({
    name: s,
    url: l
  });
  t = JSON.parse(JSON.stringify(t)), n = JSON.parse(JSON.stringify(n || {}));
  const m = await d.startJob(
    "process-on-worker",
    // @ts-expect-error
    wB.bind(null, i)
    // eslint-disable-line @typescript-eslint/no-misused-promises
  );
  return m.postMessage("process", {
    // @ts-ignore
    input: e,
    options: t,
    context: n
  }), await (await m.result).result;
}
async function wB(r, e, t, n) {
  switch (t) {
    case "done":
      e.done(n);
      break;
    case "error":
      e.error(new Error(n.error));
      break;
    case "process":
      const {
        id: i,
        input: s,
        options: l
      } = n;
      try {
        const o = await r(s, l);
        e.postMessage("done", {
          id: i,
          result: o
        });
      } catch (o) {
        const d = o instanceof Error ? o.message : "unknown error";
        e.postMessage("error", {
          id: i,
          error: d
        });
      }
      break;
    default:
      console.warn(`parse-with-worker unknown message ${t}`);
  }
}
function AB(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
  return typeof r == "string" ? r.slice(0, e) : ArrayBuffer.isView(r) ? PA(r.buffer, r.byteOffset, e) : r instanceof ArrayBuffer ? PA(r, 0, e) : "";
}
function PA(r, e, t) {
  if (r.byteLength <= e + t)
    return "";
  const n = new DataView(r);
  let i = "";
  for (let s = 0; s < t; s++)
    i += String.fromCharCode(n.getUint8(e + s));
  return i;
}
function TB(r) {
  try {
    return JSON.parse(r);
  } catch {
    throw new Error(`Failed to parse JSON from data starting with "${AB(r)}"`);
  }
}
function SB(r, e, t) {
  if (t = t || r.byteLength, r.byteLength < t || e.byteLength < t)
    return !1;
  const n = new Uint8Array(r), i = new Uint8Array(e);
  for (let s = 0; s < n.length; ++s)
    if (n[s] !== i[s])
      return !1;
  return !0;
}
function EB() {
  for (var r = arguments.length, e = new Array(r), t = 0; t < r; t++)
    e[t] = arguments[t];
  return CB(e);
}
function CB(r) {
  const e = r.map((s) => s instanceof ArrayBuffer ? new Uint8Array(s) : s), t = e.reduce((s, l) => s + l.byteLength, 0), n = new Uint8Array(t);
  let i = 0;
  for (const s of e)
    n.set(s, i), i += s.byteLength;
  return n.buffer;
}
function c2(r, e, t) {
  const n = t !== void 0 ? new Uint8Array(r).subarray(e, e + t) : new Uint8Array(r).subarray(e);
  return new Uint8Array(n).buffer;
}
function Wg(r, e) {
  return Mi(r >= 0), Mi(e > 0), r + (e - 1) & -4;
}
function IB(r, e, t) {
  let n;
  if (r instanceof ArrayBuffer)
    n = new Uint8Array(r);
  else {
    const i = r.byteOffset, s = r.byteLength;
    n = new Uint8Array(r.buffer || r.arrayBuffer, i, s);
  }
  return e.set(n, t), t + Wg(n.byteLength, 4);
}
async function MB(r) {
  const e = [];
  for await (const t of r)
    e.push(t);
  return EB(...e);
}
function RA() {
  let r;
  if (typeof window < "u" && window.performance)
    r = window.performance.now();
  else if (typeof process < "u" && process.hrtime) {
    const e = process.hrtime();
    r = e[0] * 1e3 + e[1] / 1e6;
  } else
    r = Date.now();
  return r;
}
class BA {
  constructor(e, t) {
    this.sampleSize = 1, this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this.name = e, this.type = t, this.reset();
  }
  reset() {
    return this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this;
  }
  setSampleSize(e) {
    return this.sampleSize = e, this;
  }
  /** Call to increment count (+1) */
  incrementCount() {
    return this.addCount(1), this;
  }
  /** Call to decrement count (-1) */
  decrementCount() {
    return this.subtractCount(1), this;
  }
  /** Increase count */
  addCount(e) {
    return this._count += e, this._samples++, this._checkSampling(), this;
  }
  /** Decrease count */
  subtractCount(e) {
    return this._count -= e, this._samples++, this._checkSampling(), this;
  }
  /** Add an arbitrary timing and bump the count */
  addTime(e) {
    return this._time += e, this.lastTiming = e, this._samples++, this._checkSampling(), this;
  }
  /** Start a timer */
  timeStart() {
    return this._startTime = RA(), this._timerPending = !0, this;
  }
  /** End a timer. Adds to time and bumps the timing count. */
  timeEnd() {
    return this._timerPending ? (this.addTime(RA() - this._startTime), this._timerPending = !1, this._checkSampling(), this) : this;
  }
  getSampleAverageCount() {
    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
  }
  /** Calculate average time / count for the previous window */
  getSampleAverageTime() {
    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
  }
  /** Calculate counts per second for the previous window */
  getSampleHz() {
    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
  }
  getAverageCount() {
    return this.samples > 0 ? this.count / this.samples : 0;
  }
  /** Calculate average time / count */
  getAverageTime() {
    return this.samples > 0 ? this.time / this.samples : 0;
  }
  /** Calculate counts per second */
  getHz() {
    return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
  }
  _checkSampling() {
    this._samples === this.sampleSize && (this.lastSampleTime = this._time, this.lastSampleCount = this._count, this.count += this._count, this.time += this._time, this.samples += this._samples, this._time = 0, this._count = 0, this._samples = 0);
  }
}
class mp {
  constructor(e) {
    this.stats = {}, this.id = e.id, this.stats = {}, this._initializeStats(e.stats), Object.seal(this);
  }
  /** Acquire a stat. Create if it doesn't exist. */
  get(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "count";
    return this._getOrCreate({
      name: e,
      type: t
    });
  }
  get size() {
    return Object.keys(this.stats).length;
  }
  /** Reset all stats */
  reset() {
    for (const e of Object.values(this.stats))
      e.reset();
    return this;
  }
  forEach(e) {
    for (const t of Object.values(this.stats))
      e(t);
  }
  getTable() {
    const e = {};
    return this.forEach((t) => {
      e[t.name] = {
        time: t.time || 0,
        count: t.count || 0,
        average: t.getAverageTime() || 0,
        hz: t.getHz() || 0
      };
    }), e;
  }
  _initializeStats() {
    (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).forEach((t) => this._getOrCreate(t));
  }
  _getOrCreate(e) {
    const {
      name: t,
      type: n
    } = e;
    let i = this.stats[t];
    return i || (e instanceof BA ? i = e : i = new BA(t, n), this.stats[t] = i), i;
  }
}
const PB = "Queued Requests", RB = "Active Requests", BB = "Cancelled Requests", LB = "Queued Requests Ever", OB = "Active Requests Ever", kB = {
  id: "request-scheduler",
  /** Specifies if the request scheduler should throttle incoming requests, mainly for comparative testing. */
  throttleRequests: !0,
  /** The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit. */
  maxRequests: 6,
  /**
   * Specifies a debounce time, in milliseconds. All requests are queued, until no new requests have
   * been added to the queue for this amount of time.
   */
  debounceTime: 0
};
class NB {
  constructor() {
    H(this, "props");
    H(this, "stats");
    H(this, "activeRequestCount", 0);
    /** Tracks the number of active requests and prioritizes/cancels queued requests. */
    H(this, "requestQueue", []);
    H(this, "requestMap", /* @__PURE__ */ new Map());
    H(this, "updateTimer", null);
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.props = {
      ...kB,
      ...e
    }, this.stats = new mp({
      id: this.props.id
    }), this.stats.get(PB), this.stats.get(RB), this.stats.get(BB), this.stats.get(LB), this.stats.get(OB);
  }
  /**
   * Called by an application that wants to issue a request, without having it deeply queued by the browser
   *
   * When the returned promise resolved, it is OK for the application to issue a request.
   * The promise resolves to an object that contains a `done` method.
   * When the application's request has completed (or failed), the application must call the `done` function
   *
   * @param handle
   * @param getPriority will be called when request "slots" open up,
   *    allowing the caller to update priority or cancel the request
   *    Highest priority executes first, priority < 0 cancels the request
   * @returns a promise
   *   - resolves to a object (with a `done` field) when the request can be issued without queueing,
   *   - resolves to `null` if the request has been cancelled (by the callback return < 0).
   *     In this case the application should not issue the request
   */
  scheduleRequest(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : () => 0;
    if (!this.props.throttleRequests)
      return Promise.resolve({
        done: () => {
        }
      });
    if (this.requestMap.has(e))
      return this.requestMap.get(e);
    const n = {
      handle: e,
      priority: 0,
      getPriority: t
    }, i = new Promise((s) => (n.resolve = s, n));
    return this.requestQueue.push(n), this.requestMap.set(e, i), this._issueNewRequests(), i;
  }
  // PRIVATE
  _issueRequest(e) {
    const {
      handle: t,
      resolve: n
    } = e;
    let i = !1;
    const s = () => {
      i || (i = !0, this.requestMap.delete(t), this.activeRequestCount--, this._issueNewRequests());
    };
    return this.activeRequestCount++, n ? n({
      done: s
    }) : Promise.resolve({
      done: s
    });
  }
  /** We check requests asynchronously, to prevent multiple updates */
  _issueNewRequests() {
    this.updateTimer !== null && clearTimeout(this.updateTimer), this.updateTimer = setTimeout(() => this._issueNewRequestsAsync(), this.props.debounceTime);
  }
  /** Refresh all requests  */
  _issueNewRequestsAsync() {
    this.updateTimer !== null && clearTimeout(this.updateTimer), this.updateTimer = null;
    const e = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
    if (e !== 0) {
      this._updateAllRequests();
      for (let t = 0; t < e; ++t) {
        const n = this.requestQueue.shift();
        n && this._issueRequest(n);
      }
    }
  }
  /** Ensure all requests have updated priorities, and that no longer valid requests are cancelled */
  _updateAllRequests() {
    const e = this.requestQueue;
    for (let t = 0; t < e.length; ++t) {
      const n = e[t];
      this._updateRequest(n) || (e.splice(t, 1), this.requestMap.delete(n.handle), t--);
    }
    e.sort((t, n) => t.priority - n.priority);
  }
  /** Update a single request by calling the callback */
  _updateRequest(e) {
    return e.priority = e.getPriority(e.handle), e.priority < 0 ? (e.resolve(null), !1) : !0;
  }
}
let DB = "";
const LA = {};
function FB(r) {
  for (const e in LA)
    if (r.startsWith(e)) {
      const t = LA[e];
      r = r.replace(e, t);
    }
  return !r.startsWith("http://") && !r.startsWith("https://") && (r = `${DB}${r}`), r;
}
function UB(r) {
  return r && typeof r == "object" && r.isBuffer;
}
function HE(r) {
  if (UB(r))
    return r;
  if (r instanceof ArrayBuffer)
    return r;
  if (ArrayBuffer.isView(r))
    return r.byteOffset === 0 && r.byteLength === r.buffer.byteLength ? r.buffer : r.buffer.slice(r.byteOffset, r.byteOffset + r.byteLength);
  if (typeof r == "string") {
    const e = r;
    return new TextEncoder().encode(e).buffer;
  }
  if (r && typeof r == "object" && r._toArrayBuffer)
    return r._toArrayBuffer();
  throw new Error("toArrayBuffer");
}
function zB() {
  var e;
  if (typeof process < "u" && typeof process.cwd < "u")
    return process.cwd();
  const r = (e = window.location) == null ? void 0 : e.pathname;
  return (r == null ? void 0 : r.slice(0, r.lastIndexOf("/") + 1)) || "";
}
function WE(r) {
  const e = r ? r.lastIndexOf("/") : -1;
  return e >= 0 ? r.substr(e + 1) : "";
}
function u2(r) {
  const e = r ? r.lastIndexOf("/") : -1;
  return e >= 0 ? r.substr(0, e) : "";
}
function jB() {
  const r = [];
  for (let i = 0; i < arguments.length; i++)
    r[i] = i < 0 || arguments.length <= i ? void 0 : arguments[i];
  let e = "", t = !1, n;
  for (let i = r.length - 1; i >= -1 && !t; i--) {
    let s;
    i >= 0 ? s = r[i] : (n === void 0 && (n = zB()), s = n), s.length !== 0 && (e = `${s}/${e}`, t = s.charCodeAt(0) === og);
  }
  return e = VB(e, !t), t ? `/${e}` : e.length > 0 ? e : ".";
}
const og = 47, tb = 46;
function VB(r, e) {
  let t = "", n = -1, i = 0, s, l = !1;
  for (let o = 0; o <= r.length; ++o) {
    if (o < r.length)
      s = r.charCodeAt(o);
    else {
      if (s === og)
        break;
      s = og;
    }
    if (s === og) {
      if (!(n === o - 1 || i === 1)) if (n !== o - 1 && i === 2) {
        if (t.length < 2 || !l || t.charCodeAt(t.length - 1) !== tb || t.charCodeAt(t.length - 2) !== tb) {
          if (t.length > 2) {
            const d = t.length - 1;
            let m = d;
            for (; m >= 0 && t.charCodeAt(m) !== og; --m)
              ;
            if (m !== d) {
              t = m === -1 ? "" : t.slice(0, m), n = o, i = 0, l = !1;
              continue;
            }
          } else if (t.length === 2 || t.length === 1) {
            t = "", n = o, i = 0, l = !1;
            continue;
          }
        }
        e && (t.length > 0 ? t += "/.." : t = "..", l = !0);
      } else {
        const d = r.slice(n + 1, o);
        t.length > 0 ? t += `/${d}` : t = d, l = !1;
      }
      n = o, i = 0;
    } else s === tb && i !== -1 ? ++i : i = -1;
  }
  return t;
}
const $B = (r) => typeof r == "boolean", mg = (r) => typeof r == "function", Xg = (r) => r !== null && typeof r == "object", OA = (r) => Xg(r) && r.constructor === {}.constructor, qB = (r) => !!r && typeof r[Symbol.iterator] == "function", GB = (r) => r && typeof r[Symbol.asyncIterator] == "function", Xf = (r) => typeof Response < "u" && r instanceof Response || r && r.arrayBuffer && r.text && r.json, Zf = (r) => typeof Blob < "u" && r instanceof Blob, HB = (r) => r && typeof r == "object" && r.isBuffer, WB = (r) => typeof ReadableStream < "u" && r instanceof ReadableStream || Xg(r) && mg(r.tee) && mg(r.cancel) && mg(r.getReader), XB = (r) => Xg(r) && mg(r.read) && mg(r.pipe) && $B(r.readable), XE = (r) => WB(r) || XB(r);
class ZB extends Error {
  constructor(t, n) {
    super(t);
    /** A best effort reason for why the fetch failed */
    H(this, "reason");
    /** The URL that failed to load. Empty string if not available. */
    H(this, "url");
    /** The Response object, if any. */
    H(this, "response");
    this.reason = n.reason, this.url = n.url, this.response = n.response;
  }
}
const YB = /^data:([-\w.]+\/[-\w.+]+)(;|,)/, KB = /^([-\w.]+\/[-\w.+]+)/;
function kA(r, e) {
  return r.toLowerCase() === e.toLowerCase();
}
function JB(r) {
  const e = KB.exec(r);
  return e ? e[1] : r;
}
function NA(r) {
  const e = YB.exec(r);
  return e ? e[1] : "";
}
const ZE = /\?.*/;
function QB(r) {
  const e = r.match(ZE);
  return e && e[0];
}
function h2(r) {
  return r.replace(ZE, "");
}
function eL(r) {
  if (r.length < 50)
    return r;
  const e = r.slice(r.length - 15);
  return `${r.substr(0, 32)}...${e}`;
}
function ky(r) {
  return Xf(r) ? r.url : Zf(r) ? r.name || "" : typeof r == "string" ? r : "";
}
function f2(r) {
  if (Xf(r)) {
    const e = r, t = e.headers.get("content-type") || "", n = h2(e.url);
    return JB(t) || NA(n);
  }
  return Zf(r) ? r.type || "" : typeof r == "string" ? NA(r) : "";
}
function tL(r) {
  return Xf(r) ? r.headers["content-length"] || -1 : Zf(r) ? r.size : typeof r == "string" ? r.length : r instanceof ArrayBuffer || ArrayBuffer.isView(r) ? r.byteLength : -1;
}
async function YE(r) {
  if (Xf(r))
    return r;
  const e = {}, t = tL(r);
  t >= 0 && (e["content-length"] = String(t));
  const n = ky(r), i = f2(r);
  i && (e["content-type"] = i);
  const s = await iL(r);
  s && (e["x-first-bytes"] = s), typeof r == "string" && (r = new TextEncoder().encode(r));
  const l = new Response(r, {
    headers: e
  });
  return Object.defineProperty(l, "url", {
    value: n
  }), l;
}
async function rL(r) {
  if (!r.ok)
    throw await nL(r);
}
async function nL(r) {
  const e = eL(r.url);
  let t = `Failed to fetch resource (${r.status}) ${r.statusText}: ${e}`;
  t = t.length > 100 ? `${t.slice(0, 100)}...` : t;
  const n = {
    reason: r.statusText,
    url: r.url,
    response: r
  };
  try {
    const i = r.headers.get("Content-Type");
    n.reason = !r.bodyUsed && (i != null && i.includes("application/json")) ? await r.json() : await r.text();
  } catch {
  }
  return new ZB(t, n);
}
async function iL(r) {
  if (typeof r == "string")
    return `data:,${r.slice(0, 5)}`;
  if (r instanceof Blob) {
    const t = r.slice(0, 5);
    return await new Promise((n) => {
      const i = new FileReader();
      i.onload = (s) => {
        var l;
        return n((l = s == null ? void 0 : s.target) == null ? void 0 : l.result);
      }, i.readAsDataURL(t);
    });
  }
  if (r instanceof ArrayBuffer) {
    const t = r.slice(0, 5);
    return `data:base64,${sL(t)}`;
  }
  return null;
}
function sL(r) {
  let e = "";
  const t = new Uint8Array(r);
  for (let n = 0; n < t.byteLength; n++)
    e += String.fromCharCode(t[n]);
  return btoa(e);
}
function oL(r) {
  return !aL(r) && !lL(r);
}
function aL(r) {
  return r.startsWith("http:") || r.startsWith("https:");
}
function lL(r) {
  return r.startsWith("data:");
}
async function DA(r, e) {
  var t, n;
  if (typeof r == "string") {
    const i = FB(r);
    return oL(i) && (t = globalThis.loaders) != null && t.fetchNode ? (n = globalThis.loaders) == null ? void 0 : n.fetchNode(i, e) : await fetch(i, e);
  }
  return await YE(r);
}
const FA = new gp({
  id: "loaders.gl"
});
class cL {
  log() {
    return () => {
    };
  }
  info() {
    return () => {
    };
  }
  warn() {
    return () => {
    };
  }
  error() {
    return () => {
    };
  }
}
class uL {
  constructor() {
    H(this, "console");
    this.console = console;
  }
  log() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.console.log.bind(this.console, ...t);
  }
  info() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.console.info.bind(this.console, ...t);
  }
  warn() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.console.warn.bind(this.console, ...t);
  }
  error() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.console.error.bind(this.console, ...t);
  }
}
const KE = {
  // baseUri
  fetch: null,
  mimeType: void 0,
  nothrow: !1,
  log: new uL(),
  // A probe.gl compatible (`log.log()()` syntax) that just logs to console
  useLocalLibraries: !1,
  CDN: "https://unpkg.com/@loaders.gl",
  worker: !0,
  // By default, use worker if provided by loader.
  maxConcurrency: 3,
  // How many worker instances should be created for each loader.
  maxMobileConcurrency: 1,
  // How many worker instances should be created for each loader on mobile devices.
  reuseWorkers: Oy,
  // By default reuse workers in browser (Node.js refuses to terminate if browsers are running)
  _nodeWorkers: !1,
  // By default do not support node workers
  _workerType: "",
  // 'test' to use locally generated workers
  limit: 0,
  _limitMB: 0,
  batchSize: "auto",
  batchDebounceMs: 0,
  metadata: !1,
  // TODO - currently only implemented for parseInBatches, adds initial metadata batch,
  transforms: []
}, hL = {
  throws: "nothrow",
  dataType: "(no longer used)",
  uri: "baseUri",
  // Warn if fetch options are used on top-level
  method: "fetch.method",
  headers: "fetch.headers",
  body: "fetch.body",
  mode: "fetch.mode",
  credentials: "fetch.credentials",
  cache: "fetch.cache",
  redirect: "fetch.redirect",
  referrer: "fetch.referrer",
  referrerPolicy: "fetch.referrerPolicy",
  integrity: "fetch.integrity",
  keepalive: "fetch.keepalive",
  signal: "fetch.signal"
};
function JE() {
  globalThis.loaders = globalThis.loaders || {};
  const {
    loaders: r
  } = globalThis;
  return r._state || (r._state = {}), r._state;
}
function QE() {
  const r = JE();
  return r.globalOptions = r.globalOptions || {
    ...KE
  }, r.globalOptions;
}
function fL(r, e, t, n) {
  return t = t || [], t = Array.isArray(t) ? t : [t], dL(r, t), gL(e, r, n);
}
function dL(r, e) {
  UA(r, null, KE, hL, e);
  for (const t of e) {
    const n = r && r[t.id] || {}, i = t.options && t.options[t.id] || {}, s = t.deprecatedOptions && t.deprecatedOptions[t.id] || {};
    UA(n, t.id, i, s, e);
  }
}
function UA(r, e, t, n, i) {
  const s = e || "Top level", l = e ? `${e}.` : "";
  for (const o in r) {
    const d = !e && Xg(r[o]), m = o === "baseUri" && !e, b = o === "workerUrl" && e;
    if (!(o in t) && !m && !b) {
      if (o in n)
        FA.warn(`${s} loader option '${l}${o}' no longer supported, use '${n[o]}'`)();
      else if (!d) {
        const A = pL(o, i);
        FA.warn(`${s} loader option '${l}${o}' not recognized. ${A}`)();
      }
    }
  }
}
function pL(r, e) {
  const t = r.toLowerCase();
  let n = "";
  for (const i of e)
    for (const s in i.options) {
      if (r === s)
        return `Did you mean '${i.id}.${s}'?`;
      const l = s.toLowerCase();
      (t.startsWith(l) || l.startsWith(t)) && (n = n || `Did you mean '${i.id}.${s}'?`);
    }
  return n;
}
function gL(r, e, t) {
  const i = {
    ...r.options || {}
  };
  return mL(i, t), i.log === null && (i.log = new cL()), zA(i, QE()), zA(i, e), i;
}
function zA(r, e) {
  for (const t in e)
    if (t in e) {
      const n = e[t];
      OA(n) && OA(r[t]) ? r[t] = {
        ...r[t],
        ...e[t]
      } : r[t] = e[t];
    }
}
function mL(r, e) {
  e && !("baseUri" in r) && (r.baseUri = e);
}
function d2(r) {
  return r ? (Array.isArray(r) && (r = r[0]), Array.isArray(r == null ? void 0 : r.extensions)) : !1;
}
function p2(r) {
  Mi(r, "null loader"), Mi(d2(r), "invalid loader");
  let e;
  return Array.isArray(r) && (e = r[1], r = r[0], r = {
    ...r,
    options: {
      ...r.options,
      ...e
    }
  }), (r != null && r.parseTextSync || r != null && r.parseText) && (r.text = !0), r.text || (r.binary = !0), r;
}
const eC = () => {
  const r = JE();
  return r.loaderRegistry = r.loaderRegistry || [], r.loaderRegistry;
};
function _L(r) {
  const e = eC();
  r = Array.isArray(r) ? r : [r];
  for (const t of r) {
    const n = p2(t);
    e.find((i) => n === i) || e.unshift(n);
  }
}
function yL() {
  return eC();
}
const bL = /\.([^.]+)$/;
async function vL(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], t = arguments.length > 2 ? arguments[2] : void 0, n = arguments.length > 3 ? arguments[3] : void 0;
  if (!tC(r))
    return null;
  let i = jA(r, e, {
    ...t,
    nothrow: !0
  }, n);
  if (i)
    return i;
  if (Zf(r) && (r = await r.slice(0, 10).arrayBuffer(), i = jA(r, e, t, n)), !i && !(t != null && t.nothrow))
    throw new Error(rC(r));
  return i;
}
function jA(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], t = arguments.length > 2 ? arguments[2] : void 0, n = arguments.length > 3 ? arguments[3] : void 0;
  if (!tC(r))
    return null;
  if (e && !Array.isArray(e))
    return p2(e);
  let i = [];
  e && (i = i.concat(e)), t != null && t.ignoreRegisteredLoaders || i.push(...yL()), wL(i);
  const s = xL(r, i, t, n);
  if (!s && !(t != null && t.nothrow))
    throw new Error(rC(r));
  return s;
}
function xL(r, e, t, n) {
  const i = ky(r), s = f2(r), l = h2(i) || (n == null ? void 0 : n.url);
  let o = null, d = "";
  return t != null && t.mimeType && (o = rb(e, t == null ? void 0 : t.mimeType), d = `match forced by supplied MIME type ${t == null ? void 0 : t.mimeType}`), o = o || AL(e, l), d = d || (o ? `matched url ${l}` : ""), o = o || rb(e, s), d = d || (o ? `matched MIME type ${s}` : ""), o = o || SL(e, r), d = d || (o ? `matched initial data ${nC(r)}` : ""), t != null && t.fallbackMimeType && (o = o || rb(e, t == null ? void 0 : t.fallbackMimeType), d = d || (o ? `matched fallback MIME type ${s}` : "")), d && eB.log(1, `selectLoader selected ${o == null ? void 0 : o.name}: ${d}.`), o;
}
function tC(r) {
  return !(r instanceof Response && r.status === 204);
}
function rC(r) {
  const e = ky(r), t = f2(r);
  let n = "No valid loader found (";
  n += e ? `${WE(e)}, ` : "no url provided, ", n += `MIME type: ${t ? `"${t}"` : "not provided"}, `;
  const i = r ? nC(r) : "";
  return n += i ? ` first bytes: "${i}"` : "first bytes: not available", n += ")", n;
}
function wL(r) {
  for (const e of r)
    p2(e);
}
function AL(r, e) {
  const t = e && bL.exec(e), n = t && t[1];
  return n ? TL(r, n) : null;
}
function TL(r, e) {
  e = e.toLowerCase();
  for (const t of r)
    for (const n of t.extensions)
      if (n.toLowerCase() === e)
        return t;
  return null;
}
function rb(r, e) {
  var t;
  for (const n of r)
    if ((t = n.mimeTypes) != null && t.some((i) => kA(e, i)) || kA(e, `application/x.${n.id}`))
      return n;
  return null;
}
function SL(r, e) {
  if (!e)
    return null;
  for (const t of r)
    if (typeof e == "string") {
      if (EL(e, t))
        return t;
    } else if (ArrayBuffer.isView(e)) {
      if (VA(e.buffer, e.byteOffset, t))
        return t;
    } else if (e instanceof ArrayBuffer && VA(e, 0, t))
      return t;
  return null;
}
function EL(r, e) {
  return e.testText ? e.testText(r) : (Array.isArray(e.tests) ? e.tests : [e.tests]).some((n) => r.startsWith(n));
}
function VA(r, e, t) {
  return (Array.isArray(t.tests) ? t.tests : [t.tests]).some((i) => CL(r, e, t, i));
}
function CL(r, e, t, n) {
  if (n instanceof ArrayBuffer)
    return SB(n, r, n.byteLength);
  switch (typeof n) {
    case "function":
      return n(r);
    case "string":
      const i = k1(r, e, n.length);
      return n === i;
    default:
      return !1;
  }
}
function nC(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
  return typeof r == "string" ? r.slice(0, e) : ArrayBuffer.isView(r) ? k1(r.buffer, r.byteOffset, e) : r instanceof ArrayBuffer ? k1(r, 0, e) : "";
}
function k1(r, e, t) {
  if (r.byteLength < e + t)
    return "";
  const n = new DataView(r);
  let i = "";
  for (let s = 0; s < t; s++)
    i += String.fromCharCode(n.getUint8(e + s));
  return i;
}
const IL = 256 * 1024;
function* ML(r, e) {
  const t = (e == null ? void 0 : e.chunkSize) || IL;
  let n = 0;
  const i = new TextEncoder();
  for (; n < r.length; ) {
    const s = Math.min(r.length - n, t), l = r.slice(n, n + s);
    n += s, yield i.encode(l);
  }
}
const PL = 256 * 1024;
function RL(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    const {
      chunkSize: t = PL
    } = e;
    let n = 0;
    for (; n < r.byteLength; ) {
      const i = Math.min(r.byteLength - n, t), s = new ArrayBuffer(i), l = new Uint8Array(r, n, i);
      new Uint8Array(s).set(l), n += i, yield s;
    }
  }();
}
const BL = 1024 * 1024;
async function* LL(r, e) {
  const t = (e == null ? void 0 : e.chunkSize) || BL;
  let n = 0;
  for (; n < r.size; ) {
    const i = n + t, s = await r.slice(n, i).arrayBuffer();
    n = i, yield s;
  }
}
function $A(r, e) {
  return Oy ? OL(r, e) : kL(r);
}
async function* OL(r, e) {
  const t = r.getReader();
  let n;
  try {
    for (; ; ) {
      const i = n || t.read();
      e != null && e._streamReadAhead && (n = t.read());
      const {
        done: s,
        value: l
      } = await i;
      if (s)
        return;
      yield HE(l);
    }
  } catch {
    t.releaseLock();
  }
}
async function* kL(r, e) {
  for await (const t of r)
    yield HE(t);
}
function NL(r, e) {
  if (typeof r == "string")
    return ML(r, e);
  if (r instanceof ArrayBuffer)
    return RL(r, e);
  if (Zf(r))
    return LL(r, e);
  if (XE(r))
    return $A(r, e);
  if (Xf(r))
    return $A(r.body, e);
  throw new Error("makeIterator");
}
const iC = "Cannot convert supplied data type";
function DL(r, e, t) {
  if (e.text && typeof r == "string")
    return r;
  if (HB(r) && (r = r.buffer), r instanceof ArrayBuffer) {
    const n = r;
    return e.text && !e.binary ? new TextDecoder("utf8").decode(n) : n;
  }
  if (ArrayBuffer.isView(r)) {
    if (e.text && !e.binary)
      return new TextDecoder("utf8").decode(r);
    let n = r.buffer;
    const i = r.byteLength || r.length;
    return (r.byteOffset !== 0 || i !== n.byteLength) && (n = n.slice(r.byteOffset, r.byteOffset + i)), n;
  }
  throw new Error(iC);
}
async function FL(r, e, t) {
  const n = r instanceof ArrayBuffer || ArrayBuffer.isView(r);
  if (typeof r == "string" || n)
    return DL(r, e);
  if (Zf(r) && (r = await YE(r)), Xf(r)) {
    const i = r;
    return await rL(i), e.binary ? await i.arrayBuffer() : await i.text();
  }
  if (XE(r) && (r = NL(r, t)), qB(r) || GB(r))
    return MB(r);
  throw new Error(iC);
}
function sC(r, e) {
  const t = QE(), n = r || t;
  return typeof n.fetch == "function" ? n.fetch : Xg(n.fetch) ? (i) => DA(i, n.fetch) : e != null && e.fetch ? e == null ? void 0 : e.fetch : DA;
}
function UL(r, e, t) {
  if (t)
    return t;
  const n = {
    fetch: sC(e, r),
    ...r
  };
  if (n.url) {
    const i = h2(n.url);
    n.baseUrl = i, n.queryString = QB(n.url), n.filename = WE(i), n.baseUrl = u2(i);
  }
  return Array.isArray(n.loaders) || (n.loaders = null), n;
}
function zL(r, e) {
  if (r && !Array.isArray(r))
    return r;
  let t;
  if (r && (t = Array.isArray(r) ? r : [r]), e && e.loaders) {
    const n = Array.isArray(e.loaders) ? e.loaders : [e.loaders];
    t = t ? [...t, ...n] : n;
  }
  return t && t.length ? t : void 0;
}
async function k_(r, e, t, n) {
  e && !Array.isArray(e) && !d2(e) && (n = void 0, t = e, e = void 0), r = await r, t = t || {};
  const i = ky(r), l = zL(e, n), o = await vL(r, l, t);
  return o ? (t = fL(t, o, l, i), n = UL(
    // @ts-expect-error
    {
      url: i,
      _parse: k_,
      loaders: l
    },
    t,
    n || null
  ), await jL(o, r, t, n)) : null;
}
async function jL(r, e, t, n) {
  if (pB(r), t = tB(r.options, t), Xf(e)) {
    const s = e, {
      ok: l,
      redirected: o,
      status: d,
      statusText: m,
      type: b,
      url: A
    } = s, M = Object.fromEntries(s.headers.entries());
    n.response = {
      headers: M,
      ok: l,
      redirected: o,
      status: d,
      statusText: m,
      type: b,
      url: A
    };
  }
  e = await FL(e, r, t);
  const i = r;
  if (i.parseTextSync && typeof e == "string")
    return i.parseTextSync(e, t, n);
  if (vB(r, t))
    return await xB(r, e, t, n, k_);
  if (i.parseText && typeof e == "string")
    return await i.parseText(e, t, n);
  if (i.parse)
    return await i.parse(e, t, n);
  throw rh(!i.parseSync), new Error(`${r.id} loader - no parser found and worker is disabled`);
}
function VL(r) {
  switch (r.constructor) {
    case Int8Array:
      return "int8";
    case Uint8Array:
    case Uint8ClampedArray:
      return "uint8";
    case Int16Array:
      return "int16";
    case Uint16Array:
      return "uint16";
    case Int32Array:
      return "int32";
    case Uint32Array:
      return "uint32";
    case Float32Array:
      return "float32";
    case Float64Array:
      return "float64";
    default:
      return "null";
  }
}
function oC(r) {
  let e = 1 / 0, t = 1 / 0, n = 1 / 0, i = -1 / 0, s = -1 / 0, l = -1 / 0;
  const o = r.POSITION ? r.POSITION.value : [], d = o && o.length;
  for (let m = 0; m < d; m += 3) {
    const b = o[m], A = o[m + 1], M = o[m + 2];
    e = b < e ? b : e, t = A < t ? A : t, n = M < n ? M : n, i = b > i ? b : i, s = A > s ? A : s, l = M > l ? M : l;
  }
  return [[e, t, n], [i, s, l]];
}
function $L(r, e, t) {
  const n = VL(e.value), i = t || qL(e);
  return {
    name: r,
    type: {
      type: "fixed-size-list",
      listSize: e.size,
      children: [{
        name: "value",
        type: n
      }]
    },
    nullable: !1,
    metadata: i
  };
}
function qL(r) {
  const e = {};
  return "byteOffset" in r && (e.byteOffset = r.byteOffset.toString(10)), "byteStride" in r && (e.byteStride = r.byteStride.toString(10)), "normalized" in r && (e.normalized = r.normalized.toString()), e;
}
async function Hh(r, e, t, n) {
  let i, s;
  !Array.isArray(e) && !d2(e) ? (i = [], s = e) : (i = e, s = t);
  const l = sC(s);
  let o = r;
  return typeof r == "string" && (o = await l(r)), Zf(r) && (o = await l(r)), Array.isArray(i) ? await k_(o, i, s) : await k_(o, i, s);
}
const HL = "4.3.2";
var LE;
const WL = (LE = globalThis.loaders) == null ? void 0 : LE.parseImageNode, N1 = typeof Image < "u", D1 = typeof ImageBitmap < "u", XL = !!WL, F1 = Oy ? !0 : XL;
function ZL(r) {
  switch (r) {
    case "auto":
      return D1 || N1 || F1;
    case "imagebitmap":
      return D1;
    case "image":
      return N1;
    case "data":
      return F1;
    default:
      throw new Error(`@loaders.gl/images: image ${r} not supported in this environment`);
  }
}
function YL() {
  if (D1)
    return "imagebitmap";
  if (N1)
    return "image";
  if (F1)
    return "data";
  throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
}
function KL(r) {
  const e = JL(r);
  if (!e)
    throw new Error("Not an image");
  return e;
}
function aC(r) {
  switch (KL(r)) {
    case "data":
      return r;
    case "image":
    case "imagebitmap":
      const e = document.createElement("canvas"), t = e.getContext("2d");
      if (!t)
        throw new Error("getImageData");
      return e.width = r.width, e.height = r.height, t.drawImage(r, 0, 0), t.getImageData(0, 0, r.width, r.height);
    default:
      throw new Error("getImageData");
  }
}
function JL(r) {
  return typeof ImageBitmap < "u" && r instanceof ImageBitmap ? "imagebitmap" : typeof Image < "u" && r instanceof Image ? "image" : r && typeof r == "object" && r.data && r.width && r.height ? "data" : null;
}
const QL = /^data:image\/svg\+xml/, eO = /\.svg((\?|#).*)?$/;
function g2(r) {
  return r && (QL.test(r) || eO.test(r));
}
function tO(r, e) {
  if (g2(e)) {
    let n = new TextDecoder().decode(r);
    try {
      typeof unescape == "function" && typeof encodeURIComponent == "function" && (n = unescape(encodeURIComponent(n)));
    } catch (s) {
      throw new Error(s.message);
    }
    return `data:image/svg+xml;base64,${btoa(n)}`;
  }
  return lC(r, e);
}
function lC(r, e) {
  if (g2(e))
    throw new Error("SVG cannot be parsed directly to imagebitmap");
  return new Blob([new Uint8Array(r)]);
}
async function cC(r, e, t) {
  const n = tO(r, t), i = self.URL || self.webkitURL, s = typeof n != "string" && i.createObjectURL(n);
  try {
    return await rO(s || n, e);
  } finally {
    s && i.revokeObjectURL(s);
  }
}
async function rO(r, e) {
  const t = new Image();
  return t.src = r, e.image && e.image.decode && t.decode ? (await t.decode(), t) : await new Promise((n, i) => {
    try {
      t.onload = () => n(t), t.onerror = (s) => {
        const l = s instanceof Error ? s.message : "error";
        i(new Error(l));
      };
    } catch (s) {
      i(s);
    }
  });
}
const nO = {};
let qA = !0;
async function iO(r, e, t) {
  let n;
  g2(t) ? n = await cC(r, e, t) : n = lC(r, t);
  const i = e && e.imagebitmap;
  return await sO(n, i);
}
async function sO(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if ((oO(e) || !qA) && (e = null), e)
    try {
      return await createImageBitmap(r, e);
    } catch (t) {
      console.warn(t), qA = !1;
    }
  return await createImageBitmap(r);
}
function oO(r) {
  for (const e in r || nO)
    return !1;
  return !0;
}
function aO(r) {
  return !hO(r, "ftyp", 4) || (r[8] & 96) === 0 ? null : lO(r);
}
function lO(r) {
  switch (cO(r, 8, 12).replace("\0", " ").trim()) {
    case "avif":
    case "avis":
      return {
        extension: "avif",
        mimeType: "image/avif"
      };
    default:
      return null;
  }
}
function cO(r, e, t) {
  return String.fromCharCode(...r.slice(e, t));
}
function uO(r) {
  return [...r].map((e) => e.charCodeAt(0));
}
function hO(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const n = uO(e);
  for (let i = 0; i < n.length; ++i)
    if (n[i] !== r[i + t])
      return !1;
  return !0;
}
const du = !1, _g = !0;
function m2(r) {
  const e = Zg(r);
  return dO(e) || mO(e) || pO(e) || gO(e) || fO(e);
}
function fO(r) {
  const e = new Uint8Array(r instanceof DataView ? r.buffer : r), t = aO(e);
  return t ? {
    mimeType: t.mimeType,
    // TODO - decode width and height
    width: 0,
    height: 0
  } : null;
}
function dO(r) {
  const e = Zg(r);
  return e.byteLength >= 24 && e.getUint32(0, du) === 2303741511 ? {
    mimeType: "image/png",
    width: e.getUint32(16, du),
    height: e.getUint32(20, du)
  } : null;
}
function pO(r) {
  const e = Zg(r);
  return e.byteLength >= 10 && e.getUint32(0, du) === 1195984440 ? {
    mimeType: "image/gif",
    width: e.getUint16(6, _g),
    height: e.getUint16(8, _g)
  } : null;
}
function gO(r) {
  const e = Zg(r);
  return e.byteLength >= 14 && e.getUint16(0, du) === 16973 && e.getUint32(2, _g) === e.byteLength ? {
    mimeType: "image/bmp",
    width: e.getUint32(18, _g),
    height: e.getUint32(22, _g)
  } : null;
}
function mO(r) {
  const e = Zg(r);
  if (!(e.byteLength >= 3 && e.getUint16(0, du) === 65496 && e.getUint8(2) === 255))
    return null;
  const {
    tableMarkers: n,
    sofMarkers: i
  } = _O();
  let s = 2;
  for (; s + 9 < e.byteLength; ) {
    const l = e.getUint16(s, du);
    if (i.has(l))
      return {
        mimeType: "image/jpeg",
        height: e.getUint16(s + 5, du),
        // Number of lines
        width: e.getUint16(s + 7, du)
        // Number of pixels per line
      };
    if (!n.has(l))
      return null;
    s += 2, s += e.getUint16(s, du);
  }
  return null;
}
function _O() {
  const r = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);
  for (let t = 65504; t < 65520; ++t)
    r.add(t);
  return {
    tableMarkers: r,
    sofMarkers: /* @__PURE__ */ new Set([65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485, 65486, 65487, 65502])
  };
}
function Zg(r) {
  if (r instanceof DataView)
    return r;
  if (ArrayBuffer.isView(r))
    return new DataView(r.buffer);
  if (r instanceof ArrayBuffer)
    return new DataView(r);
  throw new Error("toDataView");
}
async function yO(r, e) {
  var i;
  const {
    mimeType: t
  } = m2(r) || {}, n = (i = globalThis.loaders) == null ? void 0 : i.parseImageNode;
  return Mi(n), await n(r, t);
}
async function bO(r, e, t) {
  e = e || {};
  const i = (e.image || {}).type || "auto", {
    url: s
  } = t || {}, l = vO(i);
  let o;
  switch (l) {
    case "imagebitmap":
      o = await iO(r, e, s);
      break;
    case "image":
      o = await cC(r, e, s);
      break;
    case "data":
      o = await yO(r);
      break;
    default:
      Mi(!1);
  }
  return i === "data" && (o = aC(o)), o;
}
function vO(r) {
  switch (r) {
    case "auto":
    case "data":
      return YL();
    default:
      return ZL(r), r;
  }
}
const xO = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"], wO = ["image/png", "image/jpeg", "image/gif", "image/webp", "image/avif", "image/bmp", "image/vnd.microsoft.icon", "image/svg+xml"], AO = {
  image: {
    type: "auto",
    decode: !0
    // if format is HTML
  }
  // imagebitmap: {} - passes (platform dependent) parameters to ImageBitmap constructor
}, uC = {
  dataType: null,
  batchType: null,
  id: "image",
  module: "images",
  name: "Images",
  version: HL,
  mimeTypes: wO,
  extensions: xO,
  parse: bO,
  // TODO: byteOffset, byteLength;
  tests: [(r) => !!m2(new DataView(r))],
  options: AO
}, nb = {};
function TO(r) {
  if (nb[r] === void 0) {
    const e = Oy ? EO(r) : SO(r);
    nb[r] = e;
  }
  return nb[r];
}
function SO(r) {
  var i, s;
  const e = ["image/png", "image/jpeg", "image/gif"], t = ((i = globalThis.loaders) == null ? void 0 : i.imageFormatsNode) || e;
  return !!((s = globalThis.loaders) == null ? void 0 : s.parseImageNode) && t.includes(r);
}
function EO(r) {
  switch (r) {
    case "image/avif":
    // Will fail
    case "image/webp":
      return CO(r);
    default:
      return !0;
  }
}
function CO(r) {
  try {
    return document.createElement("canvas").toDataURL(r).indexOf(`data:${r}`) === 0;
  } catch {
    return !1;
  }
}
const Gn = new gp({
  id: "deck"
}), Eh = {
  attributeUpdateStart: -1,
  attributeManagerUpdateStart: -1,
  attributeUpdateMessages: []
}, ib = 1, Hp = 2, sb = 3, ob = 4, IO = 2, MO = (r) => ({
  /* Layer events */
  "layer.changeFlag": (e, t, n) => {
    r.log(sb, `${e.id} ${t}: `, n[t])();
  },
  "layer.initialize": (e) => {
    r.log(ib, `Initializing ${e}`)();
  },
  "layer.update": (e, t) => {
    if (t) {
      const n = e.getChangeFlags();
      r.log(Hp, `Updating ${e} because: ${Object.keys(n).filter((i) => n[i]).join(", ")}`)();
    } else
      r.log(ob, `${e} does not need update`)();
  },
  "layer.matched": (e, t) => {
    t && r.log(ob, `Matched ${e}, state transfered`)();
  },
  "layer.finalize": (e) => {
    r.log(ib, `Finalizing ${e}`)();
  },
  /* CompositeLayer events */
  "compositeLayer.renderLayers": (e, t, n) => {
    t ? r.log(Hp, `Composite layer rendered new subLayers ${e}`, n)() : r.log(ob, `Composite layer reused subLayers ${e}`, n)();
  },
  /* LayerManager events */
  "layerManager.setLayers": (e, t, n) => {
    t && r.log(Hp, `Updating ${n.length} deck layers`)();
  },
  "layerManager.activateViewport": (e, t) => {
    r.log(sb, "Viewport changed", t)();
  },
  /* AttributeManager events */
  "attributeManager.invalidate": (e, t, n) => {
    r.log(ib, n ? `invalidated attributes ${n} (${t}) for ${e.id}` : `invalidated all attributes for ${e.id}`)();
  },
  "attributeManager.updateStart": (e) => {
    Eh.attributeUpdateMessages.length = 0, Eh.attributeManagerUpdateStart = Date.now();
  },
  "attributeManager.updateEnd": (e, t) => {
    const n = Math.round(Date.now() - Eh.attributeManagerUpdateStart);
    r.groupCollapsed(Hp, `Updated attributes for ${t} instances in ${e.id} in ${n}ms`)();
    for (const i of Eh.attributeUpdateMessages)
      r.log(sb, i)();
    r.groupEnd(Hp)();
  },
  /* Attribute events */
  "attribute.updateStart": (e) => {
    Eh.attributeUpdateStart = Date.now();
  },
  "attribute.allocate": (e, t) => {
    const n = `${e.id} allocated ${t}`;
    Eh.attributeUpdateMessages.push(n);
  },
  "attribute.updateEnd": (e, t) => {
    const n = Math.round(Date.now() - Eh.attributeUpdateStart), i = `${e.id} updated ${t} in ${n}ms`;
    Eh.attributeUpdateMessages.push(i);
  },
  /* Render events */
  "deckRenderer.renderLayers": (e, t, n) => {
    const {
      pass: i,
      redrawReason: s,
      stats: l
    } = n;
    for (const o of t) {
      const {
        totalCount: d,
        visibleCount: m,
        compositeCount: b,
        pickableCount: A
      } = o, E = d - b - m;
      r.log(IO, `RENDER #${e.renderCount}   ${m} (of ${d} layers) to ${i} because ${s}   (${E} hidden, ${b} composite ${A} pickable)`)(), l && l.get("Redraw Layers").add(m);
    }
  }
});
var PO = {};
let N_ = {};
PO.NODE_ENV !== "production" && (N_ = MO(Gn));
function RO(r) {
  N_ = r;
}
function ea(r, e, t, n) {
  Gn.level > 0 && N_[r] && N_[r].call(null, e, t, n);
}
function BO(r) {
  const e = r[0], t = r[r.length - 1];
  return e === "{" && t === "}" || e === "[" && t === "]";
}
const LO = {
  dataType: null,
  batchType: null,
  id: "JSON",
  name: "JSON",
  module: "",
  version: "",
  options: {},
  extensions: ["json", "geojson"],
  mimeTypes: ["application/json", "application/geo+json"],
  testText: BO,
  parseTextSync: JSON.parse
};
function OO() {
  const r = "9.1.12", e = globalThis.deck && globalThis.deck.VERSION;
  if (e && e !== r)
    throw new Error(`deck.gl - multiple versions detected: ${e} vs ${r}`);
  return e || (Gn.log(1, `deck.gl ${r}`)(), globalThis.deck = {
    ...globalThis.deck,
    VERSION: r,
    version: r,
    log: Gn,
    // experimental
    _registerLoggers: RO
  }, _L([
    LO,
    // @ts-expect-error non-standard Loader format
    [uC, {
      imagebitmap: {
        premultiplyAlpha: "none"
      }
    }]
  ])), r;
}
const kO = OO();
function _2(r, e) {
  if (!r)
    throw new Error(e || "shadertools: assertion failed.");
}
const ab = {
  number: {
    type: "number",
    validate(r, e) {
      return Number.isFinite(r) && typeof e == "object" && (e.max === void 0 || r <= e.max) && (e.min === void 0 || r >= e.min);
    }
  },
  array: {
    type: "array",
    validate(r, e) {
      return Array.isArray(r) || ArrayBuffer.isView(r);
    }
  }
};
function NO(r) {
  const e = {};
  for (const [t, n] of Object.entries(r))
    e[t] = DO(n);
  return e;
}
function DO(r) {
  let e = GA(r);
  if (e !== "object")
    return {
      value: r,
      ...ab[e],
      type: e
    };
  if (typeof r == "object")
    return r ? r.type !== void 0 ? {
      ...r,
      ...ab[r.type],
      type: r.type
    } : r.value === void 0 ? {
      type: "object",
      value: r
    } : (e = GA(r.value), {
      ...r,
      ...ab[e],
      type: e
    }) : {
      type: "object",
      value: null
    };
  throw new Error("props");
}
function GA(r) {
  return Array.isArray(r) || ArrayBuffer.isView(r) ? "array" : typeof r;
}
const FO = (
  /* glsl */
  `#ifdef MODULE_LOGDEPTH
  logdepth_adjustPosition(gl_Position);
#endif
`
), UO = (
  /* glsl */
  `#ifdef MODULE_MATERIAL
  fragColor = material_filterColor(fragColor);
#endif

#ifdef MODULE_LIGHTING
  fragColor = lighting_filterColor(fragColor);
#endif

#ifdef MODULE_FOG
  fragColor = fog_filterColor(fragColor);
#endif

#ifdef MODULE_PICKING
  fragColor = picking_filterHighlightColor(fragColor);
  fragColor = picking_filterPickingColor(fragColor);
#endif

#ifdef MODULE_LOGDEPTH
  logdepth_setFragDepth();
#endif
`
), zO = {
  vertex: FO,
  fragment: UO
}, HA = /void\s+main\s*\([^)]*\)\s*\{\n?/, WA = /}\n?[^{}]*$/, lb = [], l_ = "__LUMA_INJECT_DECLARATIONS__";
function jO(r) {
  const e = {
    vertex: {},
    fragment: {}
  };
  for (const t in r) {
    let n = r[t];
    const i = VO(t);
    typeof n == "string" && (n = {
      order: 0,
      injection: n
    }), e[i][t] = n;
  }
  return e;
}
function VO(r) {
  const e = r.slice(0, 2);
  switch (e) {
    case "vs":
      return "vertex";
    case "fs":
      return "fragment";
    default:
      throw new Error(e);
  }
}
function D_(r, e, t) {
  let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  const i = e === "vertex";
  for (const s in t) {
    const l = t[s];
    l.sort((d, m) => d.order - m.order), lb.length = l.length;
    for (let d = 0, m = l.length; d < m; ++d)
      lb[d] = l[d].injection;
    const o = `${lb.join(`
`)}
`;
    switch (s) {
      // declarations are injected before the main function
      case "vs:#decl":
        i && (r = r.replace(l_, o));
        break;
      // inject code at the beginning of the main function
      case "vs:#main-start":
        i && (r = r.replace(HA, (d) => d + o));
        break;
      // inject code at the end of main function
      case "vs:#main-end":
        i && (r = r.replace(WA, (d) => o + d));
        break;
      // declarations are injected before the main function
      case "fs:#decl":
        i || (r = r.replace(l_, o));
        break;
      // inject code at the beginning of the main function
      case "fs:#main-start":
        i || (r = r.replace(HA, (d) => d + o));
        break;
      // inject code at the end of main function
      case "fs:#main-end":
        i || (r = r.replace(WA, (d) => o + d));
        break;
      default:
        r = r.replace(s, (d) => d + o);
    }
  }
  return r = r.replace(l_, ""), n && (r = r.replace(/\}\s*$/, (s) => s + zO[e])), r;
}
function F_(r) {
  r.map((e) => $O(e));
}
function $O(r) {
  if (r.instance)
    return;
  F_(r.dependencies || []);
  const {
    propTypes: e = {},
    deprecations: t = [],
    // defines = {},
    inject: n = {}
  } = r, i = {
    normalizedInjections: jO(n),
    parsedDeprecations: qO(t)
  };
  e && (i.propValidators = NO(e)), r.instance = i;
  let s = {};
  e && (s = Object.entries(e).reduce((l, o) => {
    let [d, m] = o;
    const b = m == null ? void 0 : m.value;
    return b && (l[d] = b), l;
  }, {})), r.defaultUniforms = {
    ...r.defaultUniforms,
    ...s
  };
}
function hC(r, e, t) {
  var n;
  (n = r.deprecations) == null || n.forEach((i) => {
    var s;
    (s = i.regex) != null && s.test(e) && (i.deprecated ? t.deprecated(i.old, i.new)() : t.removed(i.old, i.new)());
  });
}
function qO(r) {
  return r.forEach((e) => {
    switch (e.type) {
      case "function":
        e.regex = new RegExp(`\\b${e.old}\\(`);
        break;
      default:
        e.regex = new RegExp(`${e.type} ${e.old};`);
    }
  }), r;
}
function y2(r) {
  F_(r);
  const e = {}, t = {};
  fC({
    modules: r,
    level: 0,
    moduleMap: e,
    moduleDepth: t
  });
  const n = Object.keys(t).sort((i, s) => t[s] - t[i]).map((i) => e[i]);
  return F_(n), n;
}
function fC(r) {
  const {
    modules: e,
    level: t,
    moduleMap: n,
    moduleDepth: i
  } = r;
  if (t >= 5)
    throw new Error("Possible loop in shader dependency graph");
  for (const s of e)
    n[s.name] = s, (i[s.name] === void 0 || i[s.name] < t) && (i[s.name] = t);
  for (const s of e)
    s.dependencies && fC({
      modules: s.dependencies,
      level: t + 1,
      moduleMap: n,
      moduleDepth: i
    });
}
function GO(r) {
  switch (r == null ? void 0 : r.gpu.toLowerCase()) {
    case "apple":
      return (
        /* glsl */
        `#define APPLE_GPU
// Apple optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`
      );
    case "nvidia":
      return (
        /* glsl */
        `#define NVIDIA_GPU
// Nvidia optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
`
      );
    case "intel":
      return (
        /* glsl */
        `#define INTEL_GPU
// Intel optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Intel's built-in 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`
      );
    case "amd":
      return (
        /* glsl */
        `#define AMD_GPU
`
      );
    default:
      return (
        /* glsl */
        `#define DEFAULT_GPU
// Prevent driver from optimizing away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Headless Chrome's software shader 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// If the GPU doesn't have full 32 bits precision, will causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`
      );
  }
}
function HO(r, e) {
  var n;
  if (Number(((n = r.match(/^#version[ \t]+(\d+)/m)) == null ? void 0 : n[1]) || 100) !== 300)
    throw new Error("luma.gl v9 only supports GLSL 3.00 shader sources");
  switch (e) {
    case "vertex":
      return r = XA(r, WO), r;
    case "fragment":
      return r = XA(r, XO), r;
    default:
      throw new Error(e);
  }
}
const dC = [
  // Fix poorly formatted version directive
  [/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, `#version 300 es
`],
  // The individual `texture...()` functions were replaced with `texture()` overloads
  [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("],
  [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]
], WO = [
  ...dC,
  // `attribute` keyword replaced with `in`
  [U1("attribute"), "in $1"],
  // `varying` keyword replaced with `out`
  [U1("varying"), "out $1"]
], XO = [
  ...dC,
  // `varying` keyword replaced with `in`
  [U1("varying"), "in $1"]
];
function XA(r, e) {
  for (const [t, n] of e)
    r = r.replace(t, n);
  return r;
}
function U1(r) {
  return new RegExp(`\\b${r}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`, "g");
}
function pC(r, e) {
  let t = "";
  for (const n in r) {
    const i = r[n];
    if (t += `void ${i.signature} {
`, i.header && (t += `  ${i.header}`), e[n]) {
      const s = e[n];
      s.sort((l, o) => l.order - o.order);
      for (const l of s)
        t += `  ${l.injection}
`;
    }
    i.footer && (t += `  ${i.footer}`), t += `}
`;
  }
  return t;
}
function gC(r) {
  const e = {
    vertex: {},
    fragment: {}
  };
  for (const t of r) {
    let n, i;
    typeof t != "string" ? (n = t, i = n.hook) : (n = {}, i = t), i = i.trim();
    const [s, l] = i.split(":"), o = i.replace(/\(.+/, ""), d = Object.assign(n, {
      signature: l
    });
    switch (s) {
      case "vs":
        e.vertex[o] = d;
        break;
      case "fs":
        e.fragment[o] = d;
        break;
      default:
        throw new Error(s);
    }
  }
  return e;
}
function ZO(r, e) {
  return {
    name: YO(r, e),
    language: "glsl",
    version: KO(r)
  };
}
function YO(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "unnamed";
  const n = /#define[^\S\r\n]*SHADER_NAME[^\S\r\n]*([A-Za-z0-9_-]+)\s*/.exec(r);
  return n ? n[1] : e;
}
function KO(r) {
  let e = 100;
  const t = r.match(/[^\s]+/g);
  if (t && t.length >= 2 && t[0] === "#version") {
    const n = parseInt(t[1], 10);
    Number.isFinite(n) && (e = n);
  }
  if (e !== 100 && e !== 300)
    throw new Error(`Invalid GLSL version ${e}`);
  return e;
}
const mC = `

${l_}
`, JO = (
  /* glsl */
  `precision highp float;
`
);
function QO(r) {
  const e = y2(r.modules || []);
  return {
    source: t6(r.platformInfo, {
      ...r,
      source: r.source,
      stage: "vertex",
      modules: e
    }),
    getUniforms: _C(e)
  };
}
function e6(r) {
  const {
    vs: e,
    fs: t
  } = r, n = y2(r.modules || []);
  return {
    vs: ZA(r.platformInfo, {
      ...r,
      source: e,
      stage: "vertex",
      modules: n
    }),
    fs: ZA(r.platformInfo, {
      ...r,
      // @ts-expect-error
      source: t,
      stage: "fragment",
      modules: n
    }),
    getUniforms: _C(n)
  };
}
function t6(r, e) {
  var U;
  const {
    // id,
    source: t,
    stage: n,
    modules: i,
    // defines = {},
    hookFunctions: s = [],
    inject: l = {},
    log: o
  } = e;
  _2(typeof t == "string", "shader source must be a string");
  const d = t;
  let m = "";
  const b = gC(s), A = {}, M = {}, E = {};
  for (const V in l) {
    const q = typeof l[V] == "string" ? {
      injection: l[V],
      order: 0
    } : l[V], Y = /^(v|f)s:(#)?([\w-]+)$/.exec(V);
    if (Y) {
      const re = Y[2], Z = Y[3];
      re ? Z === "decl" ? M[V] = [q] : E[V] = [q] : A[V] = [q];
    } else
      E[V] = [q];
  }
  const k = i;
  for (const V of k) {
    o && hC(V, d, o);
    const q = yC(V, "wgsl");
    m += q;
    const Y = ((U = V.injections) == null ? void 0 : U[n]) || {};
    for (const re in Y) {
      const Z = /^(v|f)s:#([\w-]+)$/.exec(re);
      if (Z) {
        const ie = Z[2] === "decl" ? M : E;
        ie[re] = ie[re] || [], ie[re].push(Y[re]);
      } else
        A[re] = A[re] || [], A[re].push(Y[re]);
    }
  }
  return m += mC, m = D_(m, n, M), m += pC(b[n], A), m += d, m = D_(m, n, E), m;
}
function ZA(r, e) {
  var be;
  const {
    id: t,
    source: n,
    stage: i,
    language: s = "glsl",
    modules: l,
    defines: o = {},
    hookFunctions: d = [],
    inject: m = {},
    prologue: b = !0,
    log: A
  } = e;
  _2(typeof n == "string", "shader source must be a string");
  const M = s === "glsl" ? ZO(n).version : -1, E = r.shaderLanguageVersion, k = M === 100 ? "#version 100" : "#version 300 es", V = n.split(`
`).slice(1).join(`
`), q = {};
  l.forEach((he) => {
    Object.assign(q, he.defines);
  }), Object.assign(q, o);
  let Y = "";
  switch (s) {
    case "wgsl":
      break;
    case "glsl":
      Y = b ? `${k}

// ----- PROLOGUE -------------------------
${r6({
        id: t,
        source: n,
        stage: i
      })}
${`#define SHADER_TYPE_${i.toUpperCase()}`}

${GO(r)}
${i === "fragment" ? JO : ""}

// ----- APPLICATION DEFINES -------------------------

${n6(q)}

` : `${k}
`;
      break;
  }
  const re = gC(d), Z = {}, K = {}, ie = {};
  for (const he in m) {
    const Be = typeof m[he] == "string" ? {
      injection: m[he],
      order: 0
    } : m[he], ke = /^(v|f)s:(#)?([\w-]+)$/.exec(he);
    if (ke) {
      const pe = ke[2], me = ke[3];
      pe ? me === "decl" ? K[he] = [Be] : ie[he] = [Be] : Z[he] = [Be];
    } else
      ie[he] = [Be];
  }
  for (const he of l) {
    A && hC(he, V, A);
    const Be = yC(he, i);
    Y += Be;
    const ke = ((be = he.instance) == null ? void 0 : be.normalizedInjections[i]) || {};
    for (const pe in ke) {
      const me = /^(v|f)s:#([\w-]+)$/.exec(pe);
      if (me) {
        const Pe = me[2] === "decl" ? K : ie;
        Pe[pe] = Pe[pe] || [], Pe[pe].push(ke[pe]);
      } else
        Z[pe] = Z[pe] || [], Z[pe].push(ke[pe]);
    }
  }
  return Y += "// ----- MAIN SHADER SOURCE -------------------------", Y += mC, Y = D_(Y, i, K), Y += pC(re[i], Z), Y += V, Y = D_(Y, i, ie), s === "glsl" && M !== E && (Y = HO(Y, i)), Y.trim();
}
function _C(r) {
  return function(t) {
    var i;
    const n = {};
    for (const s of r) {
      const l = (i = s.getUniforms) == null ? void 0 : i.call(s, t, n);
      Object.assign(n, l);
    }
    return n;
  };
}
function r6(r) {
  const {
    id: e,
    source: t,
    stage: n
  } = r;
  return e && t.indexOf("SHADER_NAME") === -1 ? `
#define SHADER_NAME ${e}_${n}` : "";
}
function n6() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = "";
  for (const t in r) {
    const n = r[t];
    (n || Number.isFinite(n)) && (e += `#define ${t.toUpperCase()} ${r[t]}
`);
  }
  return e;
}
function yC(r, e) {
  let t;
  switch (e) {
    case "vertex":
      t = r.vs || "";
      break;
    case "fragment":
      t = r.fs || "";
      break;
    case "wgsl":
      t = r.source || "";
      break;
    default:
      _2(!1);
  }
  if (!r.name)
    throw new Error("Shader module must have a name");
  const n = r.name.toUpperCase().replace(/[^0-9a-z]/gi, "_");
  let i = `// ----- MODULE ${r.name} ---------------

`;
  return e !== "wgsl" && (i += `#define MODULE_${n}
`), i += `${t}
`, i;
}
const i6 = /^\s*\#\s*ifdef\s*([a-zA-Z_]+)\s*$/, s6 = /^\s*\#\s*endif\s*$/;
function o6(r, e) {
  var l;
  const t = r.split(`
`), n = [];
  let i = !0, s = null;
  for (const o of t) {
    const d = o.match(i6), m = o.match(s6);
    d ? (s = d[1], i = !!((l = e == null ? void 0 : e.defines) != null && l[s])) : m ? i = !0 : i && n.push(o);
  }
  return n.join(`
`);
}
const Cf = class Cf {
  constructor() {
    /** Hook functions */
    H(this, "_hookFunctions", []);
    /** Shader modules */
    H(this, "_defaultModules", []);
  }
  /**
   * A default shader assembler instance - the natural place to register default modules and hooks
   * @returns
   */
  static getDefaultShaderAssembler() {
    return Cf.defaultShaderAssembler = Cf.defaultShaderAssembler || new Cf(), Cf.defaultShaderAssembler;
  }
  /**
   * Add a default module that does not have to be provided with every call to assembleShaders()
   */
  addDefaultModule(e) {
    this._defaultModules.find((t) => t.name === (typeof e == "string" ? e : e.name)) || this._defaultModules.push(e);
  }
  /**
   * Remove a default module
   */
  removeDefaultModule(e) {
    const t = typeof e == "string" ? e : e.name;
    this._defaultModules = this._defaultModules.filter((n) => n.name !== t);
  }
  /**
   * Register a shader hook
   * @param hook
   * @param opts
   */
  addShaderHook(e, t) {
    t && (e = Object.assign(t, {
      hook: e
    })), this._hookFunctions.push(e);
  }
  /**
   * Assemble a WGSL unified shader
   * @param platformInfo
   * @param props
   * @returns
   */
  assembleWGSLShader(e) {
    const t = this._getModuleList(e.modules), n = this._hookFunctions, {
      source: i,
      getUniforms: s
    } = QO({
      ...e,
      // @ts-expect-error
      source: e.source,
      modules: t,
      hookFunctions: n
    });
    return {
      source: e.platformInfo.shaderLanguage === "wgsl" ? o6(i) : i,
      getUniforms: s,
      modules: t
    };
  }
  /**
   * Assemble a pair of shaders into a single shader program
   * @param platformInfo
   * @param props
   * @returns
   */
  assembleGLSLShaderPair(e) {
    const t = this._getModuleList(e.modules), n = this._hookFunctions;
    return {
      ...e6({
        ...e,
        // @ts-expect-error
        vs: e.vs,
        // @ts-expect-error
        fs: e.fs,
        modules: t,
        hookFunctions: n
      }),
      modules: t
    };
  }
  /**
   * Dedupe and combine with default modules
   */
  _getModuleList() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const t = new Array(this._defaultModules.length + e.length), n = {};
    let i = 0;
    for (let s = 0, l = this._defaultModules.length; s < l; ++s) {
      const o = this._defaultModules[s], d = o.name;
      t[i++] = o, n[d] = !0;
    }
    for (let s = 0, l = e.length; s < l; ++s) {
      const o = e[s], d = o.name;
      n[d] || (t[i++] = o, n[d] = !0);
    }
    return t.length = i, F_(t), t;
  }
};
/** Default ShaderAssembler instance */
H(Cf, "defaultShaderAssembler");
let U_ = Cf;
const a6 = (
  /* glsl */
  `out vec4 transform_output;
void main() {
  transform_output = vec4(0);
}`
), l6 = `#version 300 es
${a6}`;
function c6(r) {
  const {
    input: e,
    inputChannels: t,
    output: n
  } = {};
  if (!e)
    return l6;
  if (!t)
    throw new Error("inputChannels");
  const i = u6(t), s = h6(e, t);
  return `#version 300 es
in ${i} ${e};
out vec4 ${n};
void main() {
  ${n} = ${s};
}`;
}
function u6(r) {
  switch (r) {
    case 1:
      return "float";
    case 2:
      return "vec2";
    case 3:
      return "vec3";
    case 4:
      return "vec4";
    default:
      throw new Error(`invalid channels: ${r}`);
  }
}
function h6(r, e) {
  switch (e) {
    case 1:
      return `vec4(${r}, 0.0, 0.0, 1.0)`;
    case 2:
      return `vec4(${r}, 0.0, 1.0)`;
    case 3:
      return `vec4(${r}, 1.0)`;
    case 4:
      return r;
    default:
      throw new Error(`invalid channels: ${e}`);
  }
}
class f6 {
  constructor() {
    H(this, "stats", /* @__PURE__ */ new Map());
  }
  getStats(e) {
    return this.get(e);
  }
  get(e) {
    return this.stats.has(e) || this.stats.set(e, new mp({
      id: e
    })), this.stats.get(e);
  }
}
const bC = new f6(), cr = new gp({
  id: "luma.gl"
}), cb = {};
function Ny() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "id";
  cb[r] = cb[r] || 1;
  const e = cb[r]++;
  return `${r}-${e}`;
}
var I1;
let yi = (I1 = class {
  /**
   * Create a new Resource. Called from Subclass
   */
  constructor(e, t, n) {
    /** props.id, for debugging. */
    H(this, "id");
    H(this, "props");
    H(this, "userData", {});
    H(this, "_device");
    /** Whether this resource has been destroyed */
    H(this, "destroyed", !1);
    /** For resources that allocate GPU memory */
    H(this, "allocatedBytes", 0);
    /** Attached resources will be destroyed when this resource is destroyed. Tracks auto-created "sub" resources. */
    H(this, "_attachedResources", /* @__PURE__ */ new Set());
    if (!e)
      throw new Error("no device");
    this._device = e, this.props = d6(t, n);
    const i = this.props.id !== "undefined" ? this.props.id : Ny(this[Symbol.toStringTag]);
    this.props.id = i, this.id = i, this.userData = this.props.userData || {}, this.addStats();
  }
  toString() {
    return `${this[Symbol.toStringTag] || this.constructor.name}:"${this.id}"`;
  }
  /**
   * destroy can be called on any resource to release it before it is garbage collected.
   */
  destroy() {
    this.destroyResource();
  }
  /** @deprecated Use destroy() */
  delete() {
    return this.destroy(), this;
  }
  /**
   * Combines a map of user props and default props, only including props from defaultProps
   * @returns returns a map of overridden default props
   */
  getProps() {
    return this.props;
  }
  // ATTACHED RESOURCES
  /**
   * Attaches a resource. Attached resources are auto destroyed when this resource is destroyed
   * Called automatically when sub resources are auto created but can be called by application
   */
  attachResource(e) {
    this._attachedResources.add(e);
  }
  /**
   * Detach an attached resource. The resource will no longer be auto-destroyed when this resource is destroyed.
   */
  detachResource(e) {
    this._attachedResources.delete(e);
  }
  /**
   * Destroys a resource (only if owned), and removes from the owned (auto-destroy) list for this resource.
   */
  destroyAttachedResource(e) {
    this._attachedResources.delete(e) && e.destroy();
  }
  /** Destroy all owned resources. Make sure the resources are no longer needed before calling. */
  destroyAttachedResources() {
    for (const e of Object.values(this._attachedResources))
      e.destroy();
    this._attachedResources = /* @__PURE__ */ new Set();
  }
  // PROTECTED METHODS
  /** Perform all destroy steps. Can be called by derived resources when overriding destroy() */
  destroyResource() {
    this.destroyAttachedResources(), this.removeStats(), this.destroyed = !0;
  }
  /** Called by .destroy() to track object destruction. Subclass must call if overriding destroy() */
  removeStats() {
    const e = this._device.statsManager.getStats("Resource Counts"), t = this[Symbol.toStringTag];
    e.get(`${t}s Active`).decrementCount();
  }
  /** Called by subclass to track memory allocations */
  trackAllocatedMemory(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this[Symbol.toStringTag];
    const n = this._device.statsManager.getStats("Resource Counts");
    n.get("GPU Memory").addCount(e), n.get(`${t} Memory`).addCount(e), this.allocatedBytes = e;
  }
  /** Called by subclass to track memory deallocations */
  trackDeallocatedMemory() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this[Symbol.toStringTag];
    const t = this._device.statsManager.getStats("Resource Counts");
    t.get("GPU Memory").subtractCount(this.allocatedBytes), t.get(`${e} Memory`).subtractCount(this.allocatedBytes), this.allocatedBytes = 0;
  }
  /** Called by resource constructor to track object creation */
  addStats() {
    const e = this._device.statsManager.getStats("Resource Counts"), t = this[Symbol.toStringTag];
    e.get("Resources Created").incrementCount(), e.get(`${t}s Created`).incrementCount(), e.get(`${t}s Active`).incrementCount();
  }
}, /** Default properties for resource */
H(I1, "defaultProps", {
  id: "undefined",
  handle: void 0,
  userData: void 0
}), I1);
function d6(r, e) {
  const t = {
    ...e
  };
  for (const n in r)
    r[n] !== void 0 && (t[n] = r[n]);
  return t;
}
var Fs;
let gs = (Fs = class extends yi {
  constructor(t, n) {
    const i = {
      ...n
    };
    (n.usage || 0) & Fs.INDEX && !n.indexType && (n.data instanceof Uint32Array ? i.indexType = "uint32" : n.data instanceof Uint16Array && (i.indexType = "uint16")), delete i.data;
    super(t, i, Fs.defaultProps);
    /** The usage with which this buffer was created */
    H(this, "usage");
    /** For index buffers, whether indices are 16 or 32 bit */
    H(this, "indexType");
    /** "Time" of last update, can be used to check if redraw is needed */
    H(this, "updateTimestamp");
    /** A partial CPU-side copy of the data in this buffer, for debugging purposes */
    H(this, "debugData", new ArrayBuffer(0));
    this.usage = i.usage || 0, this.indexType = i.indexType, this.updateTimestamp = t.incrementTimestamp();
  }
  get [Symbol.toStringTag]() {
    return "Buffer";
  }
  /**
   * Create a copy of this Buffer with new byteLength, with same props but of the specified size.
   * @note Does not copy contents of the cloned Buffer.
   */
  clone(t) {
    return this.device.createBuffer({
      ...this.props,
      ...t
    });
  }
  /** Read data synchronously. @note WebGL2 only */
  readSyncWebGL(t, n) {
    throw new Error("not implemented");
  }
  /** This doesn't handle partial non-zero offset updates correctly */
  _setDebugData(t, n, i) {
    const s = ArrayBuffer.isView(t) ? t.buffer : t, l = Math.min(t ? t.byteLength : i, Fs.DEBUG_DATA_MAX_LENGTH);
    s === null ? this.debugData = new ArrayBuffer(l) : n === 0 && i === s.byteLength ? this.debugData = s.slice(0, l) : this.debugData = s.slice(n, n + l);
  }
}, H(Fs, "defaultProps", {
  ...yi.defaultProps,
  usage: 0,
  // Buffer.COPY_DST | Buffer.COPY_SRC
  byteLength: 0,
  byteOffset: 0,
  data: null,
  indexType: "uint16",
  mappedAtCreation: !1
}), // Usage Flags
H(Fs, "MAP_READ", 1), H(Fs, "MAP_WRITE", 2), H(Fs, "COPY_SRC", 4), H(Fs, "COPY_DST", 8), /** Index buffer */
H(Fs, "INDEX", 16), /** Vertex buffer */
H(Fs, "VERTEX", 32), /** Uniform buffer */
H(Fs, "UNIFORM", 64), /** Storage buffer */
H(Fs, "STORAGE", 128), H(Fs, "INDIRECT", 256), H(Fs, "QUERY_RESOLVE", 512), // PROTECTED METHODS (INTENDED FOR USE BY OTHER FRAMEWORK CODE ONLY)
/** Max amount of debug data saved. Two vec4's */
H(Fs, "DEBUG_DATA_MAX_LENGTH", 32), Fs);
function vC(r) {
  const e = YA[r], t = p6(e), n = r.includes("norm"), i = !n && !r.startsWith("float"), s = r.startsWith("s");
  return {
    dataType: YA[r],
    byteLength: t,
    integer: i,
    signed: s,
    normalized: n
  };
}
function p6(r) {
  return g6[r];
}
const YA = {
  uint8: "uint8",
  sint8: "sint8",
  unorm8: "uint8",
  snorm8: "sint8",
  uint16: "uint16",
  sint16: "sint16",
  unorm16: "uint16",
  snorm16: "sint16",
  float16: "float16",
  float32: "float32",
  uint32: "uint32",
  sint32: "sint32"
}, g6 = {
  uint8: 1,
  sint8: 1,
  uint16: 2,
  sint16: 2,
  float16: 2,
  float32: 4,
  uint32: 4,
  sint32: 4
}, Ho = "texture-compression-bc", _i = "texture-compression-astc", ou = "texture-compression-etc2", m6 = "texture-compression-etc1-webgl", Am = "texture-compression-pvrtc-webgl", ub = "texture-compression-atc-webgl", Tm = "float32-renderable-webgl", hb = "float16-renderable-webgl", _6 = "rgb9e5ufloat-renderable-webgl", fb = "snorm8-renderable-webgl", Wp = "norm16-renderable-webgl", db = "snorm16-renderable-webgl", Sm = "float32-filterable", KA = "float16-filterable-webgl";
function xC(r) {
  const e = y6[r];
  if (!e)
    throw new Error(`Unsupported texture format ${r}`);
  return e;
}
const y6 = {
  // 8-bit formats
  r8unorm: {},
  r8snorm: {
    render: fb
  },
  r8uint: {},
  r8sint: {},
  // 16-bit formats
  rg8unorm: {},
  rg8snorm: {
    render: fb
  },
  rg8uint: {},
  rg8sint: {},
  r16uint: {},
  r16sint: {},
  r16float: {
    render: hb,
    filter: "float16-filterable-webgl"
  },
  "r16unorm-webgl": {
    f: Wp
  },
  "r16snorm-webgl": {
    f: db
  },
  // Packed 16-bit formats
  "rgba4unorm-webgl": {
    channels: "rgba",
    bitsPerChannel: [4, 4, 4, 4],
    packed: !0
  },
  "rgb565unorm-webgl": {
    channels: "rgb",
    bitsPerChannel: [5, 6, 5, 0],
    packed: !0
  },
  "rgb5a1unorm-webgl": {
    channels: "rgba",
    bitsPerChannel: [5, 5, 5, 1],
    packed: !0
  },
  // 24-bit formats
  "rgb8unorm-webgl": {},
  "rgb8snorm-webgl": {},
  // 32-bit formats  
  rgba8unorm: {},
  "rgba8unorm-srgb": {},
  rgba8snorm: {
    render: fb
  },
  rgba8uint: {},
  rgba8sint: {},
  // 32-bit, reverse colors, webgpu only
  bgra8unorm: {},
  "bgra8unorm-srgb": {},
  rg16uint: {},
  rg16sint: {},
  rg16float: {
    render: hb,
    filter: KA
  },
  "rg16unorm-webgl": {
    render: Wp
  },
  "rg16snorm-webgl": {
    render: db
  },
  r32uint: {},
  r32sint: {},
  r32float: {
    render: Tm,
    filter: Sm
  },
  // Packed 32 bit formats
  rgb9e5ufloat: {
    channels: "rgb",
    packed: !0,
    render: _6
  },
  // , filter: true},
  rg11b10ufloat: {
    channels: "rgb",
    bitsPerChannel: [11, 11, 10, 0],
    packed: !0,
    p: 1,
    render: Tm
  },
  rgb10a2unorm: {
    channels: "rgba",
    bitsPerChannel: [10, 10, 10, 2],
    packed: !0,
    p: 1
  },
  "rgb10a2uint-webgl": {
    channels: "rgba",
    bitsPerChannel: [10, 10, 10, 2],
    packed: !0,
    p: 1,
    wgpu: !1
  },
  // 48-bit formats
  "rgb16unorm-webgl": {
    f: Wp
  },
  // rgb not renderable
  "rgb16snorm-webgl": {
    f: Wp
  },
  // rgb not renderable
  // 64-bit formats
  rg32uint: {},
  rg32sint: {},
  rg32float: {
    render: !1,
    filter: Sm
  },
  rgba16uint: {},
  rgba16sint: {},
  rgba16float: {
    render: hb,
    filter: KA
  },
  "rgba16unorm-webgl": {
    render: Wp
  },
  "rgba16snorm-webgl": {
    render: db
  },
  // 96-bit formats (deprecated!)
  "rgb32float-webgl": {
    render: Tm,
    filter: Sm
  },
  // 128-bit formats
  rgba32uint: {},
  rgba32sint: {},
  rgba32float: {
    render: Tm,
    filter: Sm
  },
  // Depth/stencil
  // Depth and stencil formats
  stencil8: {
    attachment: "stencil",
    bitsPerChannel: [8, 0, 0, 0],
    dataType: "uint8"
  },
  depth16unorm: {
    attachment: "depth",
    bitsPerChannel: [16, 0, 0, 0],
    dataType: "uint16"
  },
  depth24plus: {
    attachment: "depth",
    bitsPerChannel: [24, 0, 0, 0],
    dataType: "uint32"
  },
  depth32float: {
    attachment: "depth",
    bitsPerChannel: [32, 0, 0, 0],
    dataType: "float32"
  },
  // The depth component of the "depth24plus" and "depth24plus-stencil8" formats may be implemented as either a 24-bit depth value or a "depth32float" value.
  "depth24plus-stencil8": {
    attachment: "depth-stencil",
    bitsPerChannel: [24, 8, 0, 0],
    packed: !0
  },
  // "depth32float-stencil8" feature
  "depth32float-stencil8": {
    attachment: "depth-stencil",
    bitsPerChannel: [32, 8, 0, 0],
    packed: !0
  },
  // BC compressed formats: check device.features.has("texture-compression-bc");
  "bc1-rgb-unorm-webgl": {
    f: Ho
  },
  "bc1-rgb-unorm-srgb-webgl": {
    f: Ho
  },
  "bc1-rgba-unorm": {
    f: Ho
  },
  "bc1-rgba-unorm-srgb": {
    f: Ho
  },
  "bc2-rgba-unorm": {
    f: Ho
  },
  "bc2-rgba-unorm-srgb": {
    f: Ho
  },
  "bc3-rgba-unorm": {
    f: Ho
  },
  "bc3-rgba-unorm-srgb": {
    f: Ho
  },
  "bc4-r-unorm": {
    f: Ho
  },
  "bc4-r-snorm": {
    f: Ho
  },
  "bc5-rg-unorm": {
    f: Ho
  },
  "bc5-rg-snorm": {
    f: Ho
  },
  "bc6h-rgb-ufloat": {
    f: Ho
  },
  "bc6h-rgb-float": {
    f: Ho
  },
  "bc7-rgba-unorm": {
    f: Ho
  },
  "bc7-rgba-unorm-srgb": {
    f: Ho
  },
  // WEBGL_compressed_texture_etc: device.features.has("texture-compression-etc2")
  // Note: Supposedly guaranteed availability compressed formats in WebGL2, but through CPU decompression
  "etc2-rgb8unorm": {
    f: ou
  },
  "etc2-rgb8unorm-srgb": {
    f: ou
  },
  "etc2-rgb8a1unorm": {
    f: ou
  },
  "etc2-rgb8a1unorm-srgb": {
    f: ou
  },
  "etc2-rgba8unorm": {
    f: ou
  },
  "etc2-rgba8unorm-srgb": {
    f: ou
  },
  "eac-r11unorm": {
    f: ou
  },
  "eac-r11snorm": {
    f: ou
  },
  "eac-rg11unorm": {
    f: ou
  },
  "eac-rg11snorm": {
    f: ou
  },
  // X_ASTC compressed formats: device.features.has("texture-compression-astc")
  "astc-4x4-unorm": {
    f: _i
  },
  "astc-4x4-unorm-srgb": {
    f: _i
  },
  "astc-5x4-unorm": {
    f: _i
  },
  "astc-5x4-unorm-srgb": {
    f: _i
  },
  "astc-5x5-unorm": {
    f: _i
  },
  "astc-5x5-unorm-srgb": {
    f: _i
  },
  "astc-6x5-unorm": {
    f: _i
  },
  "astc-6x5-unorm-srgb": {
    f: _i
  },
  "astc-6x6-unorm": {
    f: _i
  },
  "astc-6x6-unorm-srgb": {
    f: _i
  },
  "astc-8x5-unorm": {
    f: _i
  },
  "astc-8x5-unorm-srgb": {
    f: _i
  },
  "astc-8x6-unorm": {
    f: _i
  },
  "astc-8x6-unorm-srgb": {
    f: _i
  },
  "astc-8x8-unorm": {
    f: _i
  },
  "astc-8x8-unorm-srgb": {
    f: _i
  },
  "astc-10x5-unorm": {
    f: _i
  },
  "astc-10x5-unorm-srgb": {
    f: _i
  },
  "astc-10x6-unorm": {
    f: _i
  },
  "astc-10x6-unorm-srgb": {
    f: _i
  },
  "astc-10x8-unorm": {
    f: _i
  },
  "astc-10x8-unorm-srgb": {
    f: _i
  },
  "astc-10x10-unorm": {
    f: _i
  },
  "astc-10x10-unorm-srgb": {
    f: _i
  },
  "astc-12x10-unorm": {
    f: _i
  },
  "astc-12x10-unorm-srgb": {
    f: _i
  },
  "astc-12x12-unorm": {
    f: _i
  },
  "astc-12x12-unorm-srgb": {
    f: _i
  },
  // WEBGL_compressed_texture_pvrtc
  "pvrtc-rgb4unorm-webgl": {
    f: Am
  },
  "pvrtc-rgba4unorm-webgl": {
    f: Am
  },
  "pvrtc-rbg2unorm-webgl": {
    f: Am
  },
  "pvrtc-rgba2unorm-webgl": {
    f: Am
  },
  // WEBGL_compressed_texture_etc1
  "etc1-rbg-unorm-webgl": {
    f: m6
  },
  // WEBGL_compressed_texture_atc
  "atc-rgb-unorm-webgl": {
    f: ub
  },
  "atc-rgba-unorm-webgl": {
    f: ub
  },
  "atc-rgbai-unorm-webgl": {
    f: ub
  }
}, b6 = ["bc1", "bc2", "bc3", "bc4", "bc5", "bc6", "bc7", "etc1", "etc2", "eac", "atc", "astc", "pvrtc"], v6 = /^(r|rg|rgb|rgba|bgra)([0-9]*)([a-z]*)(-srgb)?(-webgl)?$/;
function wC(r) {
  return b6.some((e) => r.startsWith(e));
}
function b2(r) {
  let e = x6(r);
  if (wC(r)) {
    e.channels = "rgb", e.components = 3, e.bytesPerPixel = 1, e.srgb = !1, e.compressed = !0;
    const n = w6(r);
    n && (e.blockWidth = n.blockWidth, e.blockHeight = n.blockHeight);
  }
  const t = v6.exec(r);
  if (t) {
    const [, n, i, s, l, o] = t, d = `${s}${i}`, m = vC(d), b = m.byteLength * 8, A = n.length, M = [b, A >= 2 ? b : 0, A >= 3 ? b : 0, A >= 4 ? b : 0];
    e = {
      format: r,
      attachment: e.attachment,
      dataType: m.dataType,
      components: A,
      channels: n,
      integer: m.integer,
      signed: m.signed,
      normalized: m.normalized,
      bitsPerChannel: M,
      bytesPerPixel: m.byteLength * n.length,
      packed: e.packed,
      srgb: e.srgb
    }, o === "-webgl" && (e.webgl = !0), l === "-srgb" && (e.srgb = !0);
  }
  return r.endsWith("-webgl") && (e.webgl = !0), r.endsWith("-srgb") && (e.srgb = !0), e;
}
function x6(r) {
  var s;
  const e = xC(r), t = e.bytesPerPixel || 1, n = e.bitsPerChannel || [8, 8, 8, 8];
  return delete e.bitsPerChannel, delete e.bytesPerPixel, delete e.f, delete e.render, delete e.filter, delete e.blend, delete e.store, {
    ...e,
    format: r,
    attachment: e.attachment || "color",
    channels: e.channels || "r",
    components: e.components || ((s = e.channels) == null ? void 0 : s.length) || 1,
    bytesPerPixel: t,
    bitsPerChannel: n,
    dataType: e.dataType || "uint8",
    srgb: e.srgb ?? !1,
    packed: e.packed ?? !1,
    webgl: e.webgl ?? !1,
    integer: e.integer ?? !1,
    signed: e.signed ?? !1,
    normalized: e.normalized ?? !1,
    compressed: e.compressed ?? !1
  };
}
function w6(r) {
  const t = /.*-(\d+)x(\d+)-.*/.exec(r);
  if (t) {
    const [, n, i] = t;
    return {
      blockWidth: Number(n),
      blockHeight: Number(i)
    };
  }
  return null;
}
function A6(r) {
  const e = xC(r), t = {
    format: r,
    create: e.f ?? !0,
    render: e.render ?? !0,
    filter: e.filter ?? !0,
    blend: e.blend ?? !0,
    store: e.store ?? !0
  }, n = b2(r), i = r.startsWith("depth") || r.startsWith("stencil"), s = n == null ? void 0 : n.signed, l = n == null ? void 0 : n.integer, o = n == null ? void 0 : n.webgl;
  return t.render && (t.render = !s), t.filter && (t.filter = !i && !s && !l && !o), t;
}
class T6 {
}
class S6 {
  constructor() {
    H(this, "features");
    H(this, "disabledFeatures");
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 ? arguments[1] : void 0;
    this.features = new Set(e), this.disabledFeatures = t || {};
  }
  *[Symbol.iterator]() {
    yield* this.features;
  }
  has(e) {
    var t;
    return !((t = this.disabledFeatures) != null && t[e]) && this.features.has(e);
  }
}
const _y = class _y {
  constructor(e) {
    /** id of this device, primarily for debugging */
    H(this, "id");
    /** A copy of the device props  */
    H(this, "props");
    /** Available for the application to store data on the device */
    H(this, "userData", {});
    /** stats */
    H(this, "statsManager", bC);
    /** An abstract timestamp used for change tracking */
    H(this, "timestamp", 0);
    /** True if this device has been reused during device creation (app has multiple references) */
    H(this, "_reused", !1);
    /** Used by other luma.gl modules to store data on the device */
    H(this, "_lumaData", {});
    this.props = {
      ..._y.defaultProps,
      ...e
    }, this.id = this.props.id || Ny(this[Symbol.toStringTag].toLowerCase());
  }
  get [Symbol.toStringTag]() {
    return "Device";
  }
  /** Determines what operations are supported on a texture format, checking against supported device features */
  getTextureFormatCapabilities(e) {
    const t = A6(e), n = (l) => (typeof l == "string" ? this.features.has(l) : l) ?? !0, i = n(t.create), s = {
      format: e,
      create: i,
      render: i && n(t.render),
      filter: i && n(t.filter),
      blend: i && n(t.blend),
      store: i && n(t.store)
    };
    return this._getDeviceSpecificTextureFormatCapabilities(s);
  }
  /** Check if device supports a specific texture format (creation and `nearest` sampling) */
  isTextureFormatSupported(e, t) {
    return this.getTextureFormatCapabilities(e).create;
  }
  /** Check if linear filtering (sampler interpolation) is supported for a specific texture format */
  isTextureFormatFilterable(e) {
    return this.getTextureFormatCapabilities(e).filter;
  }
  /** Check if device supports rendering to a framebuffer color attachment of a specific texture format */
  isTextureFormatRenderable(e) {
    return this.getTextureFormatCapabilities(e).render;
  }
  /** Check if a specific texture format is GPU compressed */
  isTextureFormatCompressed(e) {
    return wC(e);
  }
  /**
   * Trigger device loss.
   * @returns `true` if context loss could actually be triggered.
   * @note primarily intended for testing how application reacts to device loss
   */
  loseDevice() {
    return !1;
  }
  /** Report error (normally called for unhandled device errors) */
  reportError(e) {
    this.props.onError(e);
  }
  /** Returns the default / primary canvas context. Throws an error if no canvas context is available (a WebGPU compute device) */
  getDefaultCanvasContext() {
    if (!this.canvasContext)
      throw new Error("Device has no default CanvasContext. See props.createCanvasContext");
    return this.canvasContext;
  }
  createCommandEncoder() {
    throw new Error("not implemented");
  }
  /** A monotonic counter for tracking buffer and texture updates */
  incrementTimestamp() {
    return this.timestamp++;
  }
  // Error Handling
  /** Report unhandled device errors */
  onError(e) {
    this.props.onError(e);
  }
  // DEPRECATED METHODS
  /** @deprecated Use getDefaultCanvasContext() */
  getCanvasContext() {
    return this.getDefaultCanvasContext();
  }
  // WebGL specific HACKS - enables app to remove webgl import
  // Use until we have a better way to handle these
  /** @deprecated - will be removed - should use command encoder */
  readPixelsToArrayWebGL(e, t) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use command encoder */
  readPixelsToBufferWebGL(e, t) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  setParametersWebGL(e) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  getParametersWebGL(e) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  withParametersWebGL(e, t) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use clear arguments in RenderPass */
  clearWebGL(e) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use for debugging only */
  resetWebGL() {
    throw new Error("not implemented");
  }
  // IMPLEMENTATION
  /** Helper to get the canvas context props */
  static _getCanvasContextProps(e) {
    return e.createCanvasContext === !0 ? {} : e.createCanvasContext;
  }
  /** Subclasses use this to support .createBuffer() overloads */
  _normalizeBufferProps(e) {
    (e instanceof ArrayBuffer || ArrayBuffer.isView(e)) && (e = {
      data: e
    });
    const t = {
      ...e
    };
    return (e.usage || 0) & gs.INDEX && !e.indexType && (e.data instanceof Uint32Array ? t.indexType = "uint32" : e.data instanceof Uint16Array ? t.indexType = "uint16" : cr.warn("indices buffer content must be of integer type")()), t;
  }
};
H(_y, "defaultProps", {
  id: null,
  powerPreference: "high-performance",
  failIfMajorPerformanceCaveat: !1,
  createCanvasContext: void 0,
  // Callbacks
  onError: (e) => cr.error(e.message)(),
  // Experimental
  _reuseDevices: !1,
  _requestMaxLimits: !0,
  _factoryDestroyPolicy: "unused",
  // TODO - Change these after confirming things work as expected
  _initializeFeatures: !0,
  _disabledFeatures: {
    "compilation-status-async-webgl": !0
  },
  _resourceDefaults: {},
  // WebGL specific
  webgl: {},
  debug: cr.get("debug") || void 0,
  debugShaders: cr.get("debug-shaders") || void 0,
  debugFramebuffers: !!cr.get("debug-framebuffers"),
  debugWebGL: !!cr.get("debug-webgl"),
  debugSpectorJS: void 0,
  // Note: log setting is queried by the spector.js code
  debugSpectorJSUrl: void 0,
  // INTERNAL
  _handle: void 0
});
let Vh = _y;
const E6 = Wf() && typeof document < "u", C6 = () => E6 && document.readyState === "complete", I6 = "set luma.log.level=1 (or higher) to trace rendering", JA = "No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.", Fh = class Fh {
  constructor() {
    /** Global stats for all devices */
    H(this, "stats", bC);
    /**
     * Global log
     *
     * Assign luma.log.level in console to control logging: \
     * 0: none, 1: minimal, 2: verbose, 3: attribute/uniforms, 4: gl logs
     * luma.log.break[], set to gl funcs, luma.log.profile[] set to model names`;
     */
    H(this, "log", cr);
    /** Version of luma.gl */
    H(this, "VERSION", // Version detection using build plugin
    // @ts-expect-error no-undef
    "9.1.9");
    H(this, "spector");
    H(this, "preregisteredAdapters", /* @__PURE__ */ new Map());
    if (globalThis.luma) {
      if (globalThis.luma.VERSION !== this.VERSION)
        throw cr.error(`Found luma.gl ${globalThis.luma.VERSION} while initialzing ${this.VERSION}`)(), cr.error("'yarn why @luma.gl/core' can help identify the source of the conflict")(), new Error("luma.gl - multiple versions detected: see console log");
      cr.error("This version of luma.gl has already been initialized")();
    }
    cr.log(1, `${this.VERSION} - ${I6}`)(), globalThis.luma = this;
  }
  registerAdapters(e) {
    for (const t of e)
      this.preregisteredAdapters.set(t.type, t);
  }
  /** Get type strings for supported Devices */
  getSupportedAdapters() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const t = this.getAdapterMap(e);
    return Array.from(t).map((n) => {
      let [, i] = n;
      return i;
    }).filter((n) => {
      var i;
      return (i = n.isSupported) == null ? void 0 : i.call(n);
    }).map((n) => n.type);
  }
  /** Get type strings for best available Device */
  getBestAvailableAdapter() {
    var n, i, s, l;
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const t = this.getAdapterMap(e);
    return (i = (n = t.get("webgpu")) == null ? void 0 : n.isSupported) != null && i.call(n) ? "webgpu" : (l = (s = t.get("webgl")) == null ? void 0 : s.isSupported) != null && l.call(s) ? "webgl" : null;
  }
  setDefaultDeviceProps(e) {
    Object.assign(Fh.defaultProps, e);
  }
  /** Creates a device. Asynchronously. */
  async createDevice() {
    var o;
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    e = {
      ...Fh.defaultProps,
      ...e
    }, e.waitForPageLoad && await Fh.pageLoaded;
    const t = this.getAdapterMap(e.adapters);
    let n = e.type || "";
    n === "best-available" && (n = this.getBestAvailableAdapter(e.adapters) || n);
    const s = (this.getAdapterMap(e.adapters) || t).get(n), l = await ((o = s == null ? void 0 : s.create) == null ? void 0 : o.call(s, e));
    if (l)
      return l;
    throw new Error(JA);
  }
  /** Attach to an existing GPU API handle (WebGL2RenderingContext or GPUDevice). */
  async attachDevice(e) {
    var l;
    const t = this.getAdapterMap(e.adapters);
    let n = "";
    e.handle instanceof WebGL2RenderingContext && (n = "webgl"), e.createCanvasContext && await Fh.pageLoaded, e.handle === null && (n = "unknown");
    const i = t.get(n), s = await ((l = i == null ? void 0 : i.attach) == null ? void 0 : l.call(i, null));
    if (s)
      return s;
    throw new Error(JA);
  }
  /**
   * Override `HTMLCanvasContext.getCanvas()` to always create WebGL2 contexts with additional WebGL1 compatibility.
   * Useful when attaching luma to a context from an external library does not support creating WebGL2 contexts.
   */
  enforceWebGL2() {
    var s;
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    const i = this.getAdapterMap(t).get("webgl");
    i || cr.warn("enforceWebGL2: webgl adapter not found")(), (s = i == null ? void 0 : i.enforceWebGL2) == null || s.call(i, e);
  }
  /** Convert a list of adapters to a map */
  getAdapterMap() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const t = new Map(this.preregisteredAdapters);
    for (const n of e)
      t.set(n.type, n);
    return t;
  }
  // DEPRECATED
  /** @deprecated Use registerAdapters */
  registerDevices(e) {
    cr.warn("luma.registerDevices() is deprecated, use luma.registerAdapters() instead");
    for (const t of e) {
      const n = t.adapter;
      n && this.preregisteredAdapters.set(n.type, n);
    }
  }
};
H(Fh, "defaultProps", {
  ...Vh.defaultProps,
  type: "best-available",
  adapters: void 0,
  waitForPageLoad: !0
}), /**
 * Page load promise
 * Get a 'lazy' promise that resolves when the DOM is loaded.
 * @note Since there may be limitations on number of `load` event listeners,
 * it is recommended avoid calling this function until actually needed.
 * I.e. don't call it until you know that you will be looking up a string in the DOM.
 */
H(Fh, "pageLoaded", M6().then(() => {
  cr.probe(2, "DOM is loaded")();
}));
let z1 = Fh;
const j1 = new z1();
function M6() {
  return C6() || typeof window > "u" ? Promise.resolve() : new Promise((r) => {
    window.addEventListener("load", () => r());
  });
}
class P6 {
}
const yy = class yy {
  constructor(e) {
    H(this, "id");
    H(this, "props");
    H(this, "canvas");
    H(this, "htmlCanvas");
    H(this, "offscreenCanvas");
    H(this, "type");
    H(this, "width", 1);
    H(this, "height", 1);
    H(this, "resizeObserver");
    /** State used by luma.gl classes: TODO - move to canvasContext*/
    H(this, "_canvasSizeInfo", {
      clientWidth: 0,
      clientHeight: 0,
      devicePixelRatio: 1
    });
    if (this.props = {
      ...yy.defaultProps,
      ...e
    }, e = this.props, !Wf()) {
      this.id = "node-canvas-context", this.type = "node", this.width = this.props.width, this.height = this.props.height, this.canvas = null;
      return;
    }
    if (e.canvas)
      typeof e.canvas == "string" ? this.canvas = B6(e.canvas) : this.canvas = e.canvas;
    else {
      const t = L6(e), n = R6((e == null ? void 0 : e.container) || null);
      n.insertBefore(t, n.firstChild), this.canvas = t, e != null && e.visible || (this.canvas.style.visibility = "hidden");
    }
    this.canvas instanceof HTMLCanvasElement ? (this.id = this.canvas.id, this.type = "html-canvas", this.htmlCanvas = this.canvas) : (this.id = "offscreen-canvas", this.type = "offscreen-canvas", this.offscreenCanvas = this.canvas), this.canvas instanceof HTMLCanvasElement && e.autoResize && (this.resizeObserver = new ResizeObserver((t) => {
      for (const n of t)
        n.target === this.canvas && this.update();
    }), this.resizeObserver.observe(this.canvas));
  }
  toString() {
    return `${this[Symbol.toStringTag]}(${this.id})`;
  }
  /**
   * Returns the current DPR, if props.useDevicePixels is true
   * Device refers to physical
   */
  getDevicePixelRatio(e) {
    return typeof OffscreenCanvas < "u" && this.canvas instanceof OffscreenCanvas || (e = e === void 0 ? this.props.useDevicePixels : e, !e || e <= 0) ? 1 : e === !0 ? typeof window < "u" && window.devicePixelRatio || 1 : e;
  }
  /**
   * Returns the size of drawing buffer in device pixels.
   * @note This can be different from the 'CSS' size of a canvas, and also from the
   * canvas' internal drawing buffer size (.width, .height).
   * This is the size required to cover the canvas, adjusted for DPR
   */
  getPixelSize() {
    switch (this.type) {
      case "node":
        return [this.width, this.height];
      case "offscreen-canvas":
        return [this.canvas.width, this.canvas.height];
      case "html-canvas":
        const e = this.getDevicePixelRatio(), t = this.canvas;
        return t.parentElement ? [t.clientWidth * e, t.clientHeight * e] : [this.canvas.width, this.canvas.height];
      default:
        throw new Error(this.type);
    }
  }
  getAspect() {
    const [e, t] = this.getPixelSize();
    return e / t;
  }
  /**
   * Returns multiplier need to convert CSS size to Device size
   */
  cssToDeviceRatio() {
    var e;
    try {
      const [t] = this.getDrawingBufferSize(), n = this._canvasSizeInfo.clientWidth || ((e = this.htmlCanvas) == null ? void 0 : e.clientWidth);
      return n ? t / n : 1;
    } catch {
      return 1;
    }
  }
  /**
   * Maps CSS pixel position to device pixel position
   */
  cssToDevicePixels(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    const n = this.cssToDeviceRatio(), [i, s] = this.getDrawingBufferSize();
    return O6(e, n, i, s, t);
  }
  /**
   * Use devicePixelRatio to set canvas width and height
   * @note this is a raw port of luma.gl v8 code. Might be worth a review
   */
  setDevicePixelRatio(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.htmlCanvas)
      return;
    let n = "width" in t ? t.width : this.htmlCanvas.clientWidth, i = "height" in t ? t.height : this.htmlCanvas.clientHeight;
    (!n || !i) && (cr.log(1, "Canvas clientWidth/clientHeight is 0")(), e = 1, n = this.htmlCanvas.width || 1, i = this.htmlCanvas.height || 1);
    const s = this._canvasSizeInfo;
    if (s.clientWidth !== n || s.clientHeight !== i || s.devicePixelRatio !== e) {
      let l = e;
      const o = Math.floor(n * l), d = Math.floor(i * l);
      if (this.htmlCanvas.width = o, this.htmlCanvas.height = d, this.device.gl) {
        const [b, A] = this.getDrawingBufferSize();
        (b !== o || A !== d) && (l = Math.min(b / n, A / i), this.htmlCanvas.width = Math.floor(n * l), this.htmlCanvas.height = Math.floor(i * l), cr.warn("Device pixel ratio clamped")()), this._canvasSizeInfo.clientWidth = n, this._canvasSizeInfo.clientHeight = i, this._canvasSizeInfo.devicePixelRatio = e;
      }
    }
  }
  // PRIVATE
  /** @todo Major hack done to port the CSS methods above, base canvas context should not depend on WebGL */
  getDrawingBufferSize() {
    const e = this.device.gl;
    return e ? [e.drawingBufferWidth, e.drawingBufferHeight] : this.getPixelSize();
  }
  /**
   * Allows subclass constructor to override the canvas id for auto created canvases.
   * This can really help when debugging DOM in apps that create multiple devices
   */
  _setAutoCreatedCanvasId(e) {
    var t;
    ((t = this.htmlCanvas) == null ? void 0 : t.id) === "lumagl-auto-created-canvas" && (this.htmlCanvas.id = e);
  }
};
H(yy, "defaultProps", {
  canvas: null,
  width: 800,
  // width are height are only used by headless gl
  height: 600,
  useDevicePixels: !0,
  autoResize: !0,
  container: null,
  visible: !0,
  alphaMode: "opaque",
  colorSpace: "srgb"
});
let V1 = yy;
function R6(r) {
  if (typeof r == "string") {
    const e = document.getElementById(r);
    if (!e)
      throw new Error(`${r} is not an HTML element`);
    return e;
  } else if (r)
    return r;
  return document.body;
}
function B6(r) {
  const e = document.getElementById(r);
  if (!(e instanceof HTMLCanvasElement))
    throw new Error("Object is not a canvas element");
  return e;
}
function L6(r) {
  const {
    width: e,
    height: t
  } = r, n = document.createElement("canvas");
  return n.id = Ny("lumagl-auto-created-canvas"), n.width = e || 1, n.height = t || 1, n.style.width = Number.isFinite(e) ? `${e}px` : "100%", n.style.height = Number.isFinite(t) ? `${t}px` : "100%", n;
}
function O6(r, e, t, n, i) {
  const s = r, l = QA(s[0], e, t);
  let o = eT(s[1], e, n, i), d = QA(s[0] + 1, e, t);
  const m = d === t - 1 ? d : d - 1;
  d = eT(s[1] + 1, e, n, i);
  let b;
  return i ? (d = d === 0 ? d : d + 1, b = o, o = d) : b = d === n - 1 ? d : d - 1, {
    x: l,
    y: o,
    // when ratio < 1, current css pixel and next css pixel may point to same device pixel, set width/height to 1 in those cases.
    width: Math.max(m - l + 1, 1),
    height: Math.max(b - o + 1, 1)
  };
}
function QA(r, e, t) {
  return Math.min(Math.round(r * e), t - 1);
}
function eT(r, e, t, n) {
  return n ? Math.max(0, t - 1 - Math.round(r * e)) : Math.min(Math.round(r * e), t - 1);
}
const Mo = class Mo extends yi {
  /** Do not use directly. Create with device.createTexture() */
  constructor(t, n) {
    n = Mo.normalizeProps(t, n);
    super(t, n, Mo.defaultProps);
    /** dimension of this texture */
    H(this, "dimension");
    /** format of this texture */
    H(this, "format");
    /** width in pixels of this texture */
    H(this, "width");
    /** height in pixels of this texture */
    H(this, "height");
    /** depth of this texture */
    H(this, "depth");
    /** mip levels in this texture */
    H(this, "mipLevels");
    /** "Time" of last update. Monotonically increasing timestamp. TODO move to AsyncTexture? */
    H(this, "updateTimestamp");
    if (this.dimension = this.props.dimension, this.format = this.props.format, this.width = this.props.width, this.height = this.props.height, this.depth = this.props.depth, this.props.width === void 0 || this.props.height === void 0) {
      const i = Mo.getTextureDataSize(this.props.data);
      this.width = (i == null ? void 0 : i.width) || 1, this.height = (i == null ? void 0 : i.height) || 1;
    }
    this.props.mipmaps && this.props.mipLevels === void 0 && (this.props.mipLevels = "pyramid"), this.mipLevels = this.props.mipLevels === "pyramid" ? Mo.getMipLevelCount(this.width, this.height) : this.props.mipLevels || 1, this.updateTimestamp = t.incrementTimestamp();
  }
  get [Symbol.toStringTag]() {
    return "Texture";
  }
  toString() {
    return `Texture(${this.id},${this.format},${this.width}x${this.height})`;
  }
  /**
   * Create a new texture with the same parameters and optionally, a different size
   * @note Textures are immutable and cannot be resized after creation, but we can create a similar texture with the same parameters but a new size.
   * @note Does not copy contents of the texture
   */
  clone(t) {
    return this.device.createTexture({
      ...this.props,
      ...t
    });
  }
  /** Check if data is an external image */
  static isExternalImage(t) {
    return typeof ImageData < "u" && t instanceof ImageData || typeof ImageBitmap < "u" && t instanceof ImageBitmap || typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLVideoElement < "u" && t instanceof HTMLVideoElement || typeof VideoFrame < "u" && t instanceof VideoFrame || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && t instanceof OffscreenCanvas;
  }
  /** Determine size (width and height) of provided image data */
  static getExternalImageSize(t) {
    if (typeof ImageData < "u" && t instanceof ImageData || typeof ImageBitmap < "u" && t instanceof ImageBitmap || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && t instanceof OffscreenCanvas)
      return {
        width: t.width,
        height: t.height
      };
    if (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement)
      return {
        width: t.naturalWidth,
        height: t.naturalHeight
      };
    if (typeof HTMLVideoElement < "u" && t instanceof HTMLVideoElement)
      return {
        width: t.videoWidth,
        height: t.videoHeight
      };
    if (typeof VideoFrame < "u" && t instanceof VideoFrame)
      return {
        width: t.displayWidth,
        height: t.displayHeight
      };
    throw new Error("Unknown image type");
  }
  /** Check if texture data is a typed array */
  static isTextureLevelData(t) {
    const n = t == null ? void 0 : t.data;
    return ArrayBuffer.isView(n);
  }
  /** Get the size of the texture described by the provided TextureData */
  static getTextureDataSize(t) {
    if (!t || ArrayBuffer.isView(t))
      return null;
    if (Array.isArray(t))
      return Mo.getTextureDataSize(t[0]);
    if (Mo.isExternalImage(t))
      return Mo.getExternalImageSize(t);
    if (t && typeof t == "object" && t.constructor === Object) {
      const i = Object.values(t)[0];
      return {
        width: i.width,
        height: i.height
      };
    }
    throw new Error("texture size deduction failed");
  }
  /**
   * Normalize TextureData to an array of TextureLevelData / ExternalImages
   * @param data
   * @param options
   * @returns array of TextureLevelData / ExternalImages
   */
  static normalizeTextureData(t, n) {
    let i;
    return ArrayBuffer.isView(t) ? i = [{
      // ts-expect-error does data really need to be Uint8ClampedArray?
      data: t,
      width: n.width,
      height: n.height
      // depth: options.depth
    }] : Array.isArray(t) ? i = t : i = [t], i;
  }
  /** Calculate the number of mip levels for a texture of width and height */
  static getMipLevelCount(t, n) {
    return Math.floor(Math.log2(Math.max(t, n))) + 1;
  }
  /** Convert luma.gl cubemap face constants to depth index */
  static getCubeFaceDepth(t) {
    switch (t) {
      case "+X":
        return 0;
      case "-X":
        return 1;
      case "+Y":
        return 2;
      case "-Y":
        return 3;
      case "+Z":
        return 4;
      case "-Z":
        return 5;
      default:
        throw new Error(t);
    }
  }
  /** Ensure we have integer coordinates */
  static normalizeProps(t, n) {
    var d, m;
    const i = {
      ...n
    }, s = ((m = (d = t == null ? void 0 : t.props) == null ? void 0 : d._resourceDefaults) == null ? void 0 : m.texture) || {};
    Object.assign(i, s);
    const {
      width: l,
      height: o
    } = i;
    return typeof l == "number" && (i.width = Math.max(1, Math.ceil(l))), typeof o == "number" && (i.height = Math.max(1, Math.ceil(o))), i;
  }
};
H(Mo, "COPY_SRC", 1), H(Mo, "COPY_DST", 2), H(Mo, "TEXTURE", 4), H(Mo, "STORAGE", 8), H(Mo, "RENDER_ATTACHMENT", 16), H(Mo, "CubeFaces", ["+X", "-X", "+Y", "-Y", "+Z", "-Z"]), H(Mo, "defaultProps", {
  ...yi.defaultProps,
  data: null,
  dimension: "2d",
  format: "rgba8unorm",
  width: void 0,
  height: void 0,
  depth: 1,
  mipmaps: !1,
  compressed: !1,
  usage: 0,
  mipLevels: void 0,
  samples: void 0,
  sampler: {},
  view: void 0,
  flipY: void 0
}), /** Default options */
H(Mo, "defaultCopyExternalImageOptions", {
  image: void 0,
  sourceX: 0,
  sourceY: 0,
  width: void 0,
  height: void 0,
  depth: 1,
  mipLevel: 0,
  x: 0,
  y: 0,
  z: 0,
  aspect: "all",
  colorSpace: "srgb",
  premultipliedAlpha: !1,
  flipY: !1
});
let ts = Mo;
const by = class by extends yi {
  get [Symbol.toStringTag]() {
    return "TextureView";
  }
  /** Should not be constructed directly. Use `texture.createView(props)` */
  constructor(e, t) {
    super(e, t, by.defaultProps);
  }
};
H(by, "defaultProps", {
  ...yi.defaultProps,
  format: void 0,
  dimension: void 0,
  aspect: "all",
  baseMipLevel: 0,
  mipLevelCount: void 0,
  baseArrayLayer: 0,
  arrayLayerCount: void 0
});
let z_ = by;
function k6(r, e, t) {
  let n = "";
  const i = e.split(/\r?\n/), s = r.slice().sort((l, o) => l.lineNum - o.lineNum);
  switch ((t == null ? void 0 : t.showSourceCode) || "no") {
    case "all":
      let l = 0;
      for (let o = 1; o <= i.length; o++)
        for (n += AC(i[o - 1], o, t); s.length > l && s[l].lineNum === o; ) {
          const d = s[l++];
          n += tT(d, i, d.lineNum, {
            ...t,
            inlineSource: !1
          });
        }
      return n;
    case "issues":
    case "no":
      for (const o of r)
        n += tT(o, i, o.lineNum, {
          inlineSource: (t == null ? void 0 : t.showSourceCode) !== "no"
        });
      return n;
  }
}
function tT(r, e, t, n) {
  if (n != null && n.inlineSource) {
    const s = N6(e, t), l = r.linePos > 0 ? `${" ".repeat(r.linePos + 5)}^^^
` : "";
    return `
${s}${l}${r.type.toUpperCase()}: ${r.message}

`;
  }
  const i = r.type === "error" ? "red" : "#8B4000";
  return n != null && n.html ? `<div class='luma-compiler-log-error' style="color:${i};"><b> ${r.type.toUpperCase()}: ${r.message}</b></div>` : `${r.type.toUpperCase()}: ${r.message}`;
}
function N6(r, e, t) {
  let n = "";
  for (let i = e - 2; i <= e; i++) {
    const s = r[i - 1];
    s !== void 0 && (n += AC(s, e, t));
  }
  return n;
}
function AC(r, e, t) {
  const n = t != null && t.html ? F6(r) : r;
  return `${D6(String(e), 4)}: ${n}${t != null && t.html ? "<br/>" : `
`}`;
}
function D6(r, e) {
  let t = "";
  for (let n = r.length; n < e; ++n)
    t += " ";
  return t + r;
}
function F6(r) {
  return r.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&#039;");
}
const vy = class vy extends yi {
  /** Create a new Shader instance */
  constructor(t, n) {
    n = {
      ...n,
      debugShaders: n.debugShaders || t.props.debugShaders || "errors"
    };
    super(t, {
      id: U6(n),
      ...n
    }, vy.defaultProps);
    /** The stage of this shader */
    H(this, "stage");
    /** The source code of this shader */
    H(this, "source");
    /** The compilation status of the shader. 'pending' if compilation is asynchronous, and on production */
    H(this, "compilationStatus", "pending");
    this.stage = this.props.stage, this.source = this.props.source;
  }
  get [Symbol.toStringTag]() {
    return "Shader";
  }
  /** Get compiler log synchronously (WebGL only) */
  getCompilationInfoSync() {
    return null;
  }
  /** Get translated shader source in host platform's native language (HLSL, GLSL, and even GLSL ES), if available */
  getTranslatedSource() {
    return null;
  }
  // PORTABLE HELPERS
  /** In browser logging of errors */
  async debugShader() {
    const t = this.props.debugShaders;
    switch (t) {
      case "never":
        return;
      case "errors":
        if (this.compilationStatus === "success")
          return;
        break;
    }
    const n = await this.getCompilationInfo();
    t === "warnings" && (n == null ? void 0 : n.length) === 0 || this._displayShaderLog(n);
  }
  // PRIVATE
  /**
   * In-browser UI logging of errors
   * TODO - this HTML formatting code should not be in Device, should be pluggable
   */
  _displayShaderLog(t) {
    var m;
    if (typeof document > "u" || !(document != null && document.createElement))
      return;
    const n = TC(this.source), i = `${this.stage} ${n}`;
    let s = k6(t, this.source, {
      showSourceCode: "all",
      html: !0
    });
    const l = this.getTranslatedSource();
    l && (s += `<br /><br /><h1>Translated Source</h1><br /><br /><code style="user-select:text;"><pre>${l}</pre></code>`);
    const o = document.createElement("Button");
    o.innerHTML = `
<h1>Shader Compilation Error in ${i}</h1><br /><br />
<code style="user-select:text;"><pre>
${s}
</pre></code>`, o.style.top = "10px", o.style.left = "10px", o.style.position = "absolute", o.style.zIndex = "9999", o.style.width = "100%", o.style.textAlign = "left", document.body.appendChild(o), (m = document.getElementsByClassName("luma-compiler-log-error")[0]) == null || m.scrollIntoView(), o.onclick = () => {
      const b = `data:text/plain,${encodeURIComponent(this.source)}`;
      navigator.clipboard.writeText(b);
    };
  }
};
H(vy, "defaultProps", {
  ...yi.defaultProps,
  language: "auto",
  stage: void 0,
  source: "",
  sourceMap: null,
  entryPoint: "main",
  debugShaders: void 0
});
let j_ = vy;
function U6(r) {
  return TC(r.source) || r.id || Ny(`unnamed ${r.stage}-shader`);
}
function TC(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "unnamed";
  const n = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/.exec(r);
  return n ? n[1] : e;
}
const Cg = class Cg extends yi {
  get [Symbol.toStringTag]() {
    return "Sampler";
  }
  constructor(e, t) {
    t = Cg.normalizeProps(e, t), super(e, t, Cg.defaultProps);
  }
  static normalizeProps(e, t) {
    var s, l;
    const n = ((l = (s = e == null ? void 0 : e.props) == null ? void 0 : s._resourceDefaults) == null ? void 0 : l.sampler) || {};
    return {
      ...t,
      ...n
    };
  }
};
H(Cg, "defaultProps", {
  ...yi.defaultProps,
  type: "color-sampler",
  addressModeU: "clamp-to-edge",
  addressModeV: "clamp-to-edge",
  addressModeW: "clamp-to-edge",
  magFilter: "nearest",
  minFilter: "nearest",
  mipmapFilter: "none",
  lodMinClamp: 0,
  lodMaxClamp: 32,
  // Per WebGPU spec
  compare: "less-equal",
  maxAnisotropy: 1
});
let V_ = Cg;
const xy = class xy extends yi {
  constructor(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(t, n, xy.defaultProps);
    /** Width of all attachments in this framebuffer */
    H(this, "width");
    /** Height of all attachments in this framebuffer */
    H(this, "height");
    this.width = this.props.width, this.height = this.props.height;
  }
  get [Symbol.toStringTag]() {
    return "Framebuffer";
  }
  /**
   * Create a copy of this framebuffer with new attached textures, with same props but of the specified size.
   * @note Does not copy contents of the attached textures.
   */
  clone(t) {
    const n = this.colorAttachments.map((s) => s.texture.clone(t)), i = this.depthStencilAttachment && this.depthStencilAttachment.texture.clone(t);
    return this.device.createFramebuffer({
      ...this.props,
      colorAttachments: n,
      depthStencilAttachment: i
    });
  }
  resize(t) {
    let n = !t;
    if (t) {
      const [i, s] = Array.isArray(t) ? t : [t.width, t.height];
      n = n || s !== this.height || i !== this.width, this.width = i, this.height = s;
    }
    n && (cr.log(2, `Resizing framebuffer ${this.id} to ${this.width}x${this.height}`)(), this.resizeAttachments(this.width, this.height));
  }
  /** Auto creates any textures */
  autoCreateAttachmentTextures() {
    if (this.props.colorAttachments.length === 0 && !this.props.depthStencilAttachment)
      throw new Error("Framebuffer has noattachments");
    this.colorAttachments = this.props.colorAttachments.map((n, i) => {
      if (typeof n == "string") {
        const s = this.createColorTexture(n, i);
        return this.attachResource(s), s.view;
      }
      return n instanceof ts ? n.view : n;
    });
    const t = this.props.depthStencilAttachment;
    if (t)
      if (typeof t == "string") {
        const n = this.createDepthStencilTexture(t);
        this.attachResource(n), this.depthStencilAttachment = n.view;
      } else t instanceof ts ? this.depthStencilAttachment = t.view : this.depthStencilAttachment = t;
  }
  /** Create a color texture */
  createColorTexture(t, n) {
    return this.device.createTexture({
      id: `${this.id}-color-attachment-${n}`,
      usage: ts.RENDER_ATTACHMENT,
      format: t,
      width: this.width,
      height: this.height,
      // TODO deprecated? - luma.gl v8 compatibility
      sampler: {
        magFilter: "linear",
        minFilter: "linear"
      }
    });
  }
  /** Create depth stencil texture */
  createDepthStencilTexture(t) {
    return this.device.createTexture({
      id: `${this.id}-depth-stencil-attachment`,
      usage: ts.RENDER_ATTACHMENT,
      format: t,
      width: this.width,
      height: this.height,
      mipmaps: !1
    });
  }
  /**
   * Default implementation of resize
   * Creates new textures with correct size for all attachments.
   * and destroys existing textures if owned
   */
  resizeAttachments(t, n) {
    for (let i = 0; i < this.colorAttachments.length; ++i)
      if (this.colorAttachments[i]) {
        const s = this.colorAttachments[i].texture.clone({
          width: t,
          height: n
        });
        this.destroyAttachedResource(this.colorAttachments[i]), this.colorAttachments[i] = s.view, this.attachResource(s.view);
      }
    if (this.depthStencilAttachment) {
      const i = this.depthStencilAttachment.texture.clone({
        width: t,
        height: n
      });
      this.destroyAttachedResource(this.depthStencilAttachment), this.depthStencilAttachment = i.view, this.attachResource(i);
    }
    this.updateAttachments();
  }
};
H(xy, "defaultProps", {
  ...yi.defaultProps,
  width: 1,
  height: 1,
  colorAttachments: [],
  // ['rgba8unorm'],
  depthStencilAttachment: null
  // 'depth24plus-stencil8'
});
let $_ = xy;
const wy = class wy extends yi {
  constructor(t, n) {
    super(t, n, wy.defaultProps);
    /** The merged layout */
    H(this, "shaderLayout");
    /** Buffer map describing buffer interleaving etc */
    H(this, "bufferLayout");
    /** The linking status of the pipeline. 'pending' if linking is asynchronous, and on production */
    H(this, "linkStatus", "pending");
    /** The hash of the pipeline */
    H(this, "hash", "");
    this.shaderLayout = this.props.shaderLayout, this.bufferLayout = this.props.bufferLayout || [];
  }
  get [Symbol.toStringTag]() {
    return "RenderPipeline";
  }
  // DEPRECATED METHODS
  /**
   * Uniforms
   * @deprecated Use uniforms buffers
   * @note textures, samplers and uniform buffers should be set via `setBindings()`, these are not considered uniforms.
   * @note In WebGL uniforms have a performance penalty, they are reset before each call to enable pipeline sharing.
   */
  setUniformsWebGL(t) {
    throw new Error("Use uniform blocks");
  }
};
H(wy, "defaultProps", {
  ...yi.defaultProps,
  vs: null,
  vertexEntryPoint: "vertexMain",
  vsConstants: {},
  fs: null,
  fragmentEntryPoint: "fragmentMain",
  fsConstants: {},
  shaderLayout: null,
  bufferLayout: [],
  topology: "triangle-list",
  parameters: {},
  // isInstanced: false,
  // instanceCount: 0,
  // vertexCount: 0,
  bindings: {},
  uniforms: {}
});
let np = wy;
const bc = class bc extends yi {
  get [Symbol.toStringTag]() {
    return "RenderPass";
  }
  constructor(e, t) {
    t = bc.normalizeProps(e, t), super(e, t, bc.defaultProps);
  }
  static normalizeProps(e, t) {
    var s;
    return {
      ...(s = e.props._resourceDefaults) == null ? void 0 : s.renderPass,
      ...t
    };
  }
};
/** TODO - should be [0, 0, 0, 0], update once deck.gl tests run clean */
H(bc, "defaultClearColor", [0, 0, 0, 1]), /** Depth 1.0 represents the far plance */
H(bc, "defaultClearDepth", 1), /** Clears all stencil bits */
H(bc, "defaultClearStencil", 0), /** Default properties for RenderPass */
H(bc, "defaultProps", {
  ...yi.defaultProps,
  framebuffer: null,
  parameters: void 0,
  clearColor: bc.defaultClearColor,
  clearColors: void 0,
  clearDepth: bc.defaultClearDepth,
  clearStencil: bc.defaultClearStencil,
  depthReadOnly: !1,
  stencilReadOnly: !1,
  discard: !1,
  occlusionQuerySet: void 0,
  timestampQuerySet: void 0,
  beginTimestampIndex: void 0,
  endTimestampIndex: void 0
});
let $1 = bc;
const Ay = class Ay extends yi {
  constructor(t, n) {
    super(t, n, Ay.defaultProps);
    H(this, "hash", "");
    /** The merged shader layout */
    H(this, "shaderLayout");
    this.shaderLayout = n.shaderLayout;
  }
  get [Symbol.toStringTag]() {
    return "ComputePipeline";
  }
};
H(Ay, "defaultProps", {
  ...yi.defaultProps,
  shader: void 0,
  entryPoint: void 0,
  constants: {},
  shaderLayout: void 0
});
let q_ = Ay;
const Ty = class Ty extends yi {
  get [Symbol.toStringTag]() {
    return "CommandEncoder";
  }
  constructor(e, t) {
    super(e, t, Ty.defaultProps);
  }
};
H(Ty, "defaultProps", {
  ...yi.defaultProps,
  measureExecutionTime: void 0
});
let q1 = Ty;
const Sy = class Sy extends yi {
  get [Symbol.toStringTag]() {
    return "CommandBuffer";
  }
  constructor(e, t) {
    super(e, t, Sy.defaultProps);
  }
};
H(Sy, "defaultProps", {
  ...yi.defaultProps
});
let G1 = Sy;
function z6(r) {
  const [e, t] = V6[r], n = e === "i32" || e === "u32", i = e !== "u32", s = $6[e] * t, l = j6(e, t);
  return {
    dataType: e,
    components: t,
    defaultVertexFormat: l,
    byteLength: s,
    integer: n,
    signed: i
  };
}
function j6(r, e) {
  let t;
  switch (r) {
    case "f32":
      t = "float32";
      break;
    case "i32":
      t = "sint32";
      break;
    case "u32":
      t = "uint32";
      break;
    case "f16":
      return e <= 2 ? "float16x2" : "float16x4";
  }
  return e === 1 ? t : `${t}x${e}`;
}
const V6 = {
  f32: ["f32", 1],
  "vec2<f32>": ["f32", 2],
  "vec3<f32>": ["f32", 3],
  "vec4<f32>": ["f32", 4],
  f16: ["f16", 1],
  "vec2<f16>": ["f16", 2],
  "vec3<f16>": ["f16", 3],
  "vec4<f16>": ["f16", 4],
  i32: ["i32", 1],
  "vec2<i32>": ["i32", 2],
  "vec3<i32>": ["i32", 3],
  "vec4<i32>": ["i32", 4],
  u32: ["u32", 1],
  "vec2<u32>": ["u32", 2],
  "vec3<u32>": ["u32", 3],
  "vec4<u32>": ["u32", 4]
}, $6 = {
  f32: 4,
  f16: 2,
  i32: 4,
  u32: 4
  // 'bool-webgl': 4,
};
function SC(r) {
  let e;
  r.endsWith("-webgl") && (r.replace("-webgl", ""), e = !0);
  const [t, n] = r.split("x"), i = t, s = n ? parseInt(n) : 1, l = vC(i), o = {
    type: i,
    components: s,
    byteLength: l.byteLength * s,
    integer: l.integer,
    signed: l.signed,
    normalized: l.normalized
  };
  return e && (o.webglOnly = !0), o;
}
function EC(r, e) {
  const t = {};
  for (const n of r.attributes) {
    const i = G6(r, e, n.name);
    i && (t[n.name] = i);
  }
  return t;
}
function q6(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 16;
  const n = EC(r, e), i = new Array(t).fill(null);
  for (const s of Object.values(n))
    i[s.location] = s;
  return i;
}
function G6(r, e, t) {
  const n = H6(r, t), i = W6(e, t);
  if (!n)
    return null;
  const s = z6(n.type), l = (i == null ? void 0 : i.vertexFormat) || s.defaultVertexFormat, o = SC(l);
  return {
    attributeName: (i == null ? void 0 : i.attributeName) || n.name,
    bufferName: (i == null ? void 0 : i.bufferName) || n.name,
    location: n.location,
    shaderType: n.type,
    shaderDataType: s.dataType,
    shaderComponents: s.components,
    vertexFormat: l,
    bufferDataType: o.type,
    bufferComponents: o.components,
    // normalized is a property of the buffer's vertex format
    normalized: o.normalized,
    // integer is a property of the shader declaration
    integer: s.integer,
    stepMode: (i == null ? void 0 : i.stepMode) || n.stepMode || "vertex",
    byteOffset: (i == null ? void 0 : i.byteOffset) || 0,
    byteStride: (i == null ? void 0 : i.byteStride) || 0
  };
}
function H6(r, e) {
  const t = r.attributes.find((n) => n.name === e);
  return t || cr.warn(`shader layout attribute "${e}" not present in shader`), t || null;
}
function W6(r, e) {
  X6(r);
  let t = Z6(r, e);
  return t || (t = Y6(r, e), t) ? t : (cr.warn(`layout for attribute "${e}" not present in buffer layout`), null);
}
function X6(r) {
  for (const e of r)
    (e.attributes && e.format || !e.attributes && !e.format) && cr.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`);
}
function Z6(r, e) {
  for (const t of r)
    if (t.format && t.name === e)
      return {
        attributeName: t.name,
        bufferName: e,
        stepMode: t.stepMode,
        vertexFormat: t.format,
        // If offset is needed, use `attributes` field.
        byteOffset: 0,
        byteStride: t.byteStride || 0
      };
  return null;
}
function Y6(r, e) {
  var t;
  for (const n of r) {
    let i = n.byteStride;
    if (typeof n.byteStride != "number")
      for (const l of n.attributes || []) {
        const o = SC(l.format);
        i += o.byteLength;
      }
    const s = (t = n.attributes) == null ? void 0 : t.find((l) => l.attribute === e);
    if (s)
      return {
        attributeName: s.attribute,
        bufferName: n.name,
        stepMode: n.stepMode,
        vertexFormat: s.format,
        byteOffset: s.byteOffset,
        // @ts-ignore
        byteStride: i
      };
  }
  return null;
}
const Ey = class Ey extends yi {
  constructor(t, n) {
    super(t, n, Ey.defaultProps);
    /** Max number of vertex attributes */
    H(this, "maxVertexAttributes");
    /** Attribute infos indexed by location - TODO only needed by webgl module? */
    H(this, "attributeInfos");
    /** Index buffer */
    H(this, "indexBuffer", null);
    /** Attributes indexed by buffer slot */
    H(this, "attributes");
    this.maxVertexAttributes = t.limits.maxVertexAttributes, this.attributes = new Array(this.maxVertexAttributes).fill(null);
    const {
      shaderLayout: i,
      bufferLayout: s
    } = n.renderPipeline || {};
    if (!i || !s)
      throw new Error("VertexArray");
    this.attributeInfos = q6(i, s, this.maxVertexAttributes);
  }
  get [Symbol.toStringTag]() {
    return "VertexArray";
  }
  // DEPRECATED METHODS
  /** @deprecated Set constant attributes (WebGL only) */
  setConstantWebGL(t, n) {
    this.device.reportError(new Error("constant attributes not supported"));
  }
};
H(Ey, "defaultProps", {
  ...yi.defaultProps,
  renderPipeline: null
});
let H1 = Ey;
const Cy = class Cy extends yi {
  get [Symbol.toStringTag]() {
    return "TransformFeedback";
  }
  constructor(e, t) {
    super(e, t, Cy.defaultProps);
  }
};
H(Cy, "defaultProps", {
  ...yi.defaultProps,
  layout: void 0,
  buffers: {}
});
let W1 = Cy;
const Iy = class Iy extends yi {
  get [Symbol.toStringTag]() {
    return "QuerySet";
  }
  constructor(e, t) {
    super(e, t, Iy.defaultProps);
  }
};
H(Iy, "defaultProps", {
  ...yi.defaultProps,
  type: void 0,
  count: void 0
});
let X1 = Iy;
const K6 = {
  f32: {
    type: "f32",
    components: 1
  },
  i32: {
    type: "i32",
    components: 1
  },
  u32: {
    type: "u32",
    components: 1
  },
  // 'bool-webgl': {type: 'bool-webgl', components: 1},
  "vec2<f32>": {
    type: "f32",
    components: 2
  },
  "vec3<f32>": {
    type: "f32",
    components: 3
  },
  "vec4<f32>": {
    type: "f32",
    components: 4
  },
  "vec2<i32>": {
    type: "i32",
    components: 2
  },
  "vec3<i32>": {
    type: "i32",
    components: 3
  },
  "vec4<i32>": {
    type: "i32",
    components: 4
  },
  "vec2<u32>": {
    type: "u32",
    components: 2
  },
  "vec3<u32>": {
    type: "u32",
    components: 3
  },
  "vec4<u32>": {
    type: "u32",
    components: 4
  },
  "mat2x2<f32>": {
    type: "f32",
    components: 4
  },
  "mat2x3<f32>": {
    type: "f32",
    components: 6
  },
  "mat2x4<f32>": {
    type: "f32",
    components: 8
  },
  "mat3x2<f32>": {
    type: "f32",
    components: 6
  },
  "mat3x3<f32>": {
    type: "f32",
    components: 9
  },
  "mat3x4<f32>": {
    type: "f32",
    components: 12
  },
  "mat4x2<f32>": {
    type: "f32",
    components: 8
  },
  "mat4x3<f32>": {
    type: "f32",
    components: 12
  },
  "mat4x4<f32>": {
    type: "f32",
    components: 16
  }
};
function J6(r) {
  return K6[r];
}
function Q6(r, e) {
  switch (e) {
    case 1:
      return r;
    // Pad upwards to even multiple of 2
    case 2:
      return r + r % 2;
    // Pad upwards to even multiple of 2
    default:
      return r + (4 - r % 4) % 4;
  }
}
let Em;
function CC(r) {
  return (!Em || Em.byteLength < r) && (Em = new ArrayBuffer(r)), Em;
}
function ek(r, e) {
  const t = CC(r.BYTES_PER_ELEMENT * e);
  return new r(t, 0, e);
}
function tk(r) {
  return ArrayBuffer.isView(r) && !(r instanceof DataView);
}
function G_(r) {
  return Array.isArray(r) ? r.length === 0 || typeof r[0] == "number" : tk(r);
}
const rT = 1024;
class rk {
  /** Create a new UniformBufferLayout given a map of attributes. */
  constructor(e) {
    H(this, "layout", {});
    /** number of bytes needed for buffer allocation */
    H(this, "byteLength");
    let t = 0;
    for (const [i, s] of Object.entries(e)) {
      const l = J6(s), {
        type: o,
        components: d
      } = l;
      t = Q6(t, d);
      const m = t;
      t += d, this.layout[i] = {
        type: o,
        size: d,
        offset: m
      };
    }
    t += (4 - t % 4) % 4;
    const n = t * 4;
    this.byteLength = Math.max(n, rT);
  }
  /** Get the data for the complete buffer */
  getData(e) {
    const t = Math.max(this.byteLength, rT), n = CC(t), i = {
      i32: new Int32Array(n),
      u32: new Uint32Array(n),
      f32: new Float32Array(n),
      // TODO not implemented
      f16: new Uint16Array(n)
    };
    for (const [s, l] of Object.entries(e)) {
      const o = this.layout[s];
      if (!o) {
        cr.warn(`Supplied uniform value ${s} not present in uniform block layout`)();
        continue;
      }
      const {
        type: d,
        size: m,
        offset: b
      } = o, A = i[d];
      if (m === 1) {
        if (typeof l != "number" && typeof l != "boolean") {
          cr.warn(`Supplied value for single component uniform ${s} is not a number: ${l}`)();
          continue;
        }
        A[b] = Number(l);
      } else {
        if (!G_(l)) {
          cr.warn(`Supplied value for multi component / array uniform ${s} is not a numeric array: ${l}`)();
          continue;
        }
        A.set(l, b);
      }
    }
    return new Uint8Array(n);
  }
  /** Does this layout have a field with specified name */
  has(e) {
    return !!this.layout[e];
  }
  /** Get offset and size for a field with specified name */
  get(e) {
    return this.layout[e];
  }
}
function nk(r, e) {
  if (r !== e)
    return !1;
  const t = r, n = e;
  if (!G_(t))
    return !1;
  if (G_(n) && t.length === n.length) {
    for (let i = 0; i < t.length; ++i)
      if (n[i] !== t[i])
        return !1;
  }
  return !0;
}
function ik(r) {
  return G_(r) ? r.slice() : r;
}
class sk {
  constructor(e) {
    H(this, "name");
    H(this, "uniforms", {});
    H(this, "modifiedUniforms", {});
    H(this, "modified", !0);
    H(this, "bindingLayout", {});
    H(this, "needsRedraw", "initialized");
    var t;
    if (this.name = (e == null ? void 0 : e.name) || "unnamed", e != null && e.name && (e != null && e.shaderLayout)) {
      const n = (t = e == null ? void 0 : e.shaderLayout.bindings) == null ? void 0 : t.find((s) => s.type === "uniform" && s.name === (e == null ? void 0 : e.name));
      if (!n)
        throw new Error(e == null ? void 0 : e.name);
      const i = n;
      for (const s of i.uniforms || [])
        this.bindingLayout[s.name] = s;
    }
  }
  /** Set a map of uniforms */
  setUniforms(e) {
    for (const [t, n] of Object.entries(e))
      this._setUniform(t, n), this.needsRedraw || this.setNeedsRedraw(`${this.name}.${t}=${n}`);
  }
  setNeedsRedraw(e) {
    this.needsRedraw = this.needsRedraw || e;
  }
  /** Returns all uniforms */
  getAllUniforms() {
    return this.modifiedUniforms = {}, this.needsRedraw = !1, this.uniforms || {};
  }
  /** Set a single uniform */
  _setUniform(e, t) {
    nk(this.uniforms[e], t) || (this.uniforms[e] = ik(t), this.modifiedUniforms[e] = !0, this.modified = !0);
  }
}
class ok {
  /**
   * Create a new UniformStore instance
   * @param blocks
   */
  constructor(e) {
    /** Stores the uniform values for each uniform block */
    H(this, "uniformBlocks", /* @__PURE__ */ new Map());
    /** Can generate data for a uniform buffer for each block from data */
    H(this, "uniformBufferLayouts", /* @__PURE__ */ new Map());
    /** Actual buffer for the blocks */
    H(this, "uniformBuffers", /* @__PURE__ */ new Map());
    for (const [t, n] of Object.entries(e)) {
      const i = t, s = new rk(n.uniformTypes || {});
      this.uniformBufferLayouts.set(i, s);
      const l = new sk({
        name: t
      });
      l.setUniforms(n.defaultUniforms || {}), this.uniformBlocks.set(i, l);
    }
  }
  /** Destroy any managed uniform buffers */
  destroy() {
    for (const e of this.uniformBuffers.values())
      e.destroy();
  }
  /**
   * Set uniforms
   * Makes all properties partial
   */
  setUniforms(e) {
    var t;
    for (const [n, i] of Object.entries(e))
      (t = this.uniformBlocks.get(n)) == null || t.setUniforms(i);
    this.updateUniformBuffers();
  }
  /** Get the required minimum length of the uniform buffer */
  getUniformBufferByteLength(e) {
    var t;
    return ((t = this.uniformBufferLayouts.get(e)) == null ? void 0 : t.byteLength) || 0;
  }
  /** Get formatted binary memory that can be uploaded to a buffer */
  getUniformBufferData(e) {
    var n, i;
    const t = ((n = this.uniformBlocks.get(e)) == null ? void 0 : n.getAllUniforms()) || {};
    return (i = this.uniformBufferLayouts.get(e)) == null ? void 0 : i.getData(t);
  }
  /**
   * Creates an unmanaged uniform buffer (umnanaged means that application is responsible for destroying it)
   * The new buffer is initialized with current / supplied values
   */
  createUniformBuffer(e, t, n) {
    n && this.setUniforms(n);
    const i = this.getUniformBufferByteLength(t), s = e.createBuffer({
      usage: gs.UNIFORM | gs.COPY_DST,
      byteLength: i
    }), l = this.getUniformBufferData(t);
    return s.write(l), s;
  }
  /** Get the managed uniform buffer. "managed" resources are destroyed when the uniformStore is destroyed. */
  getManagedUniformBuffer(e, t) {
    if (!this.uniformBuffers.get(t)) {
      const n = this.getUniformBufferByteLength(t), i = e.createBuffer({
        usage: gs.UNIFORM | gs.COPY_DST,
        byteLength: n
      });
      this.uniformBuffers.set(t, i);
    }
    return this.uniformBuffers.get(t);
  }
  /** Updates all uniform buffers where values have changed */
  updateUniformBuffers() {
    let e = !1;
    for (const t of this.uniformBlocks.keys()) {
      const n = this.updateUniformBuffer(t);
      e || (e = n);
    }
    return e && cr.log(3, `UniformStore.updateUniformBuffers(): ${e}`)(), e;
  }
  /** Update one uniform buffer. Only updates if values have changed */
  updateUniformBuffer(e) {
    var s;
    const t = this.uniformBlocks.get(e);
    let n = this.uniformBuffers.get(e), i = !1;
    if (n && (t != null && t.needsRedraw)) {
      i || (i = t.needsRedraw);
      const l = this.getUniformBufferData(e);
      n = this.uniformBuffers.get(e), n == null || n.write(l);
      const o = (s = this.uniformBlocks.get(e)) == null ? void 0 : s.getAllUniforms();
      cr.log(4, `Writing to uniform buffer ${String(e)}`, l, o)();
    }
    return i;
  }
}
function IC(r) {
  const e = ArrayBuffer.isView(r) ? r.constructor : r;
  switch (e) {
    case Float32Array:
      return "float32";
    case Uint16Array:
      return "uint16";
    case Uint32Array:
      return "uint32";
    case Uint8Array:
    case Uint8ClampedArray:
      return "uint8";
    case Int8Array:
      return "sint8";
    case Int16Array:
      return "sint16";
    case Int32Array:
      return "sint32";
    default:
      throw new Error(e.constructor.name);
  }
}
function MC(r) {
  switch (r) {
    case "float32":
      return Float32Array;
    case "uint32":
      return Uint32Array;
    case "sint32":
      return Int32Array;
    case "uint16":
    case "unorm16":
      return Uint16Array;
    case "sint16":
    case "snorm16":
      return Int16Array;
    case "uint8":
    case "unorm8":
      return Uint8Array;
    case "sint8":
    case "snorm8":
      return Int8Array;
    default:
      throw new Error(r);
  }
}
function ak(r, e, t) {
  if (!e || e > 4)
    throw new Error(`size ${e}`);
  const n = e;
  let i = IC(r);
  if (i === "uint8" && t && n === 1)
    return "unorm8-webgl";
  if (i === "uint8" && t && n === 3)
    return "unorm8x3-webgl";
  if (i === "uint8" || i === "sint8") {
    if (n === 1 || n === 3)
      throw new Error(`size: ${e}`);
    return t && (i = i.replace("int", "norm")), `${i}x${n}`;
  }
  if (i === "uint16" || i === "sint16") {
    if (n === 1 || n === 3)
      throw new Error(`size: ${e}`);
    return t && (i = i.replace("int", "norm")), `${i}x${n}`;
  }
  return n === 1 ? i : `${i}x${n}`;
}
class pb {
  constructor(e) {
    H(this, "bufferLayouts");
    this.bufferLayouts = e;
  }
  getBufferLayout(e) {
    return this.bufferLayouts.find((t) => t.name === e) || null;
  }
  /** Get attribute names from a BufferLayout */
  getAttributeNamesForBuffer(e) {
    var t;
    return e.attributes ? (t = e.attributes) == null ? void 0 : t.map((n) => n.attribute) : [e.name];
  }
  mergeBufferLayouts(e, t) {
    const n = [...e];
    for (const i of t) {
      const s = n.findIndex((l) => l.name === i.name);
      s < 0 ? n.push(i) : n[s] = i;
    }
    return n;
  }
  getBufferIndex(e) {
    const t = this.bufferLayouts.findIndex((n) => n.name === e);
    return t === -1 && cr.warn(`BufferLayout: Missing buffer for "${e}".`)(), t;
  }
}
function lk(r, e) {
  const t = Object.fromEntries(r.attributes.map((i) => [i.name, i.location])), n = e.slice();
  return n.sort((i, s) => {
    const l = i.attributes ? i.attributes.map((b) => b.attribute) : [i.name], o = s.attributes ? s.attributes.map((b) => b.attribute) : [s.name], d = Math.min(...l.map((b) => t[b])), m = Math.min(...o.map((b) => t[b]));
    return d - m;
  }), n;
}
class Fl {
  constructor(e, t) {
    this.name = e, this.attributes = t, this.size = 0;
  }
  get isArray() {
    return !1;
  }
  get isStruct() {
    return !1;
  }
  get isTemplate() {
    return !1;
  }
  get isPointer() {
    return !1;
  }
  getTypeName() {
    return this.name;
  }
}
class nT {
  constructor(e, t, n) {
    this.name = e, this.type = t, this.attributes = n, this.offset = 0, this.size = 0;
  }
  get isArray() {
    return this.type.isArray;
  }
  get isStruct() {
    return this.type.isStruct;
  }
  get isTemplate() {
    return this.type.isTemplate;
  }
  get align() {
    return this.type.isStruct ? this.type.align : 0;
  }
  get members() {
    return this.type.isStruct ? this.type.members : null;
  }
  get format() {
    return this.type.isArray || this.type.isTemplate ? this.type.format : null;
  }
  get count() {
    return this.type.isArray ? this.type.count : 0;
  }
  get stride() {
    return this.type.isArray ? this.type.stride : this.size;
  }
}
class Uh extends Fl {
  constructor(e, t) {
    super(e, t), this.members = [], this.align = 0, this.startLine = -1, this.endLine = -1, this.inUse = !1;
  }
  get isStruct() {
    return !0;
  }
}
class $h extends Fl {
  constructor(e, t) {
    super(e, t), this.count = 0, this.stride = 0;
  }
  get isArray() {
    return !0;
  }
  getTypeName() {
    return `array<${this.format.getTypeName()}, ${this.count}>`;
  }
}
class Z1 extends Fl {
  constructor(e, t, n) {
    super(e, n), this.format = t;
  }
  get isPointer() {
    return !0;
  }
  getTypeName() {
    return `&${this.format.getTypeName()}`;
  }
}
class Vf extends Fl {
  constructor(e, t, n, i) {
    super(e, n), this.format = t, this.access = i;
  }
  get isTemplate() {
    return !0;
  }
  getTypeName() {
    let e = this.name;
    if (this.format !== null) {
      if (e === "vec2" || e === "vec3" || e === "vec4" || e === "mat2x2" || e === "mat2x3" || e === "mat2x4" || e === "mat3x2" || e === "mat3x3" || e === "mat3x4" || e === "mat4x2" || e === "mat4x3" || e === "mat4x4") {
        if (this.format.name === "f32") return e += "f", e;
        if (this.format.name === "i32") return e += "i", e;
        if (this.format.name === "u32") return e += "u", e;
        if (this.format.name === "bool") return e += "b", e;
        if (this.format.name === "f16") return e += "h", e;
      }
      e += `<${this.format.name}>`;
    } else if (e === "vec2" || e === "vec3" || e === "vec4") return e;
    return e;
  }
}
var Nh;
((r) => {
  r[r.Uniform = 0] = "Uniform", r[r.Storage = 1] = "Storage", r[r.Texture = 2] = "Texture", r[r.Sampler = 3] = "Sampler", r[r.StorageTexture = 4] = "StorageTexture";
})(Nh || (Nh = {}));
class Cm {
  constructor(e, t, n, i, s, l, o) {
    this.name = e, this.type = t, this.group = n, this.binding = i, this.attributes = s, this.resourceType = l, this.access = o;
  }
  get isArray() {
    return this.type.isArray;
  }
  get isStruct() {
    return this.type.isStruct;
  }
  get isTemplate() {
    return this.type.isTemplate;
  }
  get size() {
    return this.type.size;
  }
  get align() {
    return this.type.isStruct ? this.type.align : 0;
  }
  get members() {
    return this.type.isStruct ? this.type.members : null;
  }
  get format() {
    return this.type.isArray || this.type.isTemplate ? this.type.format : null;
  }
  get count() {
    return this.type.isArray ? this.type.count : 0;
  }
  get stride() {
    return this.type.isArray ? this.type.stride : this.size;
  }
}
class ck {
  constructor(e, t) {
    this.name = e, this.type = t;
  }
}
class uk {
  constructor(e, t, n, i) {
    this.name = e, this.type = t, this.locationType = n, this.location = i, this.interpolation = null;
  }
}
class iT {
  constructor(e, t, n, i) {
    this.name = e, this.type = t, this.locationType = n, this.location = i;
  }
}
class hk {
  constructor(e, t, n, i) {
    this.name = e, this.type = t, this.attributes = n, this.id = i;
  }
}
class fk {
  constructor(e, t, n) {
    this.name = e, this.type = t, this.attributes = n;
  }
}
class dk {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, n = arguments.length > 2 ? arguments[2] : void 0;
    this.stage = null, this.inputs = [], this.outputs = [], this.arguments = [], this.returnType = null, this.resources = [], this.overrides = [], this.startLine = -1, this.endLine = -1, this.inUse = !1, this.calls = /* @__PURE__ */ new Set(), this.name = e, this.stage = t, this.attributes = n;
  }
}
class pk {
  constructor() {
    this.vertex = [], this.fragment = [], this.compute = [];
  }
}
const PC = new Float32Array(1), gk = new Int32Array(PC.buffer), Wo = new Uint16Array(1);
function mk(r) {
  PC[0] = r;
  const e = gk[0], t = e >> 31 & 1;
  let n = e >> 23 & 255, i = 8388607 & e;
  if (n === 255) return Wo[0] = t << 15 | 31744 | (i !== 0 ? 512 : 0), Wo[0];
  if (n === 0) {
    if (i === 0) return Wo[0] = t << 15, Wo[0];
    i |= 8388608;
    let s = 113;
    for (; !(8388608 & i); ) i <<= 1, s--;
    return n = 127 - s, i &= 8388607, n > 0 ? (i = (i >> 126 - n) + (i >> 127 - n & 1), Wo[0] = t << 15 | n << 10 | i >> 13, Wo[0]) : (Wo[0] = t << 15, Wo[0]);
  }
  return n = n - 127 + 15, n >= 31 ? (Wo[0] = t << 15 | 31744, Wo[0]) : n <= 0 ? n < -10 ? (Wo[0] = t << 15, Wo[0]) : (i = (8388608 | i) >> 1 - n, Wo[0] = t << 15 | i >> 13, Wo[0]) : (i >>= 13, Wo[0] = t << 15 | n << 10 | i, Wo[0]);
}
const v2 = new Uint32Array(1), RC = new Float32Array(v2.buffer, 0, 1);
function sT(r) {
  const e = 112 + (r >> 6 & 31) << 23 | (63 & r) << 17;
  return v2[0] = e, RC[0];
}
function _k(r, e, t, n, i, s, l, o, d) {
  const m = n * (l >>= i) * (s >>= i) + t * l + e * o;
  switch (d) {
    case "r8unorm":
      return [Qn(r, m, "8unorm", 1)[0]];
    case "r8snorm":
      return [Qn(r, m, "8snorm", 1)[0]];
    case "r8uint":
      return [Qn(r, m, "8uint", 1)[0]];
    case "r8sint":
      return [Qn(r, m, "8sint", 1)[0]];
    case "rg8unorm": {
      const b = Qn(r, m, "8unorm", 2);
      return [b[0], b[1]];
    }
    case "rg8snorm": {
      const b = Qn(r, m, "8snorm", 2);
      return [b[0], b[1]];
    }
    case "rg8uint": {
      const b = Qn(r, m, "8uint", 2);
      return [b[0], b[1]];
    }
    case "rg8sint": {
      const b = Qn(r, m, "8sint", 2);
      return [b[0], b[1]];
    }
    case "rgba8unorm-srgb":
    case "rgba8unorm": {
      const b = Qn(r, m, "8unorm", 4);
      return [b[0], b[1], b[2], b[3]];
    }
    case "rgba8snorm": {
      const b = Qn(r, m, "8snorm", 4);
      return [b[0], b[1], b[2], b[3]];
    }
    case "rgba8uint": {
      const b = Qn(r, m, "8uint", 4);
      return [b[0], b[1], b[2], b[3]];
    }
    case "rgba8sint": {
      const b = Qn(r, m, "8sint", 4);
      return [b[0], b[1], b[2], b[3]];
    }
    case "bgra8unorm-srgb":
    case "bgra8unorm": {
      const b = Qn(r, m, "8unorm", 4);
      return [b[2], b[1], b[0], b[3]];
    }
    case "r16uint":
      return [Qn(r, m, "16uint", 1)[0]];
    case "r16sint":
      return [Qn(r, m, "16sint", 1)[0]];
    case "r16float":
      return [Qn(r, m, "16float", 1)[0]];
    case "rg16uint": {
      const b = Qn(r, m, "16uint", 2);
      return [b[0], b[1]];
    }
    case "rg16sint": {
      const b = Qn(r, m, "16sint", 2);
      return [b[0], b[1]];
    }
    case "rg16float": {
      const b = Qn(r, m, "16float", 2);
      return [b[0], b[1]];
    }
    case "rgba16uint": {
      const b = Qn(r, m, "16uint", 4);
      return [b[0], b[1], b[2], b[3]];
    }
    case "rgba16sint": {
      const b = Qn(r, m, "16sint", 4);
      return [b[0], b[1], b[2], b[3]];
    }
    case "rgba16float": {
      const b = Qn(r, m, "16float", 4);
      return [b[0], b[1], b[2], b[3]];
    }
    case "r32uint":
      return [Qn(r, m, "32uint", 1)[0]];
    case "r32sint":
      return [Qn(r, m, "32sint", 1)[0]];
    case "depth16unorm":
    case "depth24plus":
    case "depth24plus-stencil8":
    case "depth32float":
    case "depth32float-stencil8":
    case "r32float":
      return [Qn(r, m, "32float", 1)[0]];
    case "rg32uint": {
      const b = Qn(r, m, "32uint", 2);
      return [b[0], b[1]];
    }
    case "rg32sint": {
      const b = Qn(r, m, "32sint", 2);
      return [b[0], b[1]];
    }
    case "rg32float": {
      const b = Qn(r, m, "32float", 2);
      return [b[0], b[1]];
    }
    case "rgba32uint": {
      const b = Qn(r, m, "32uint", 4);
      return [b[0], b[1], b[2], b[3]];
    }
    case "rgba32sint": {
      const b = Qn(r, m, "32sint", 4);
      return [b[0], b[1], b[2], b[3]];
    }
    case "rgba32float": {
      const b = Qn(r, m, "32float", 4);
      return [b[0], b[1], b[2], b[3]];
    }
    case "rg11b10ufloat": {
      const b = new Uint32Array(r.buffer, m, 1)[0], A = (4192256 & b) >> 11, M = (4290772992 & b) >> 22;
      return [sT(2047 & b), sT(A), function(E) {
        const k = 112 + (E >> 5 & 31) << 23 | (31 & E) << 18;
        return v2[0] = k, RC[0];
      }(M), 1];
    }
  }
  return null;
}
function Qn(r, e, t, n) {
  const i = [0, 0, 0, 0];
  for (let m = 0; m < n; ++m) switch (t) {
    case "8unorm":
      i[m] = r[e] / 255, e++;
      break;
    case "8snorm":
      i[m] = r[e] / 255 * 2 - 1, e++;
      break;
    case "8uint":
      i[m] = r[e], e++;
      break;
    case "8sint":
      i[m] = r[e] - 127, e++;
      break;
    case "16uint":
      i[m] = r[e] | r[e + 1] << 8, e += 2;
      break;
    case "16sint":
      i[m] = (r[e] | r[e + 1] << 8) - 32768, e += 2;
      break;
    case "16float":
      i[m] = (s = r[e] | r[e + 1] << 8, l = void 0, o = void 0, d = void 0, l = (32768 & s) >> 15, d = 1023 & s, (o = (31744 & s) >> 10) == 0 ? (l ? -1 : 1) * Math.pow(2, -14) * (d / Math.pow(2, 10)) : o == 31 ? d ? NaN : 1 / 0 * (l ? -1 : 1) : (l ? -1 : 1) * Math.pow(2, o - 15) * (1 + d / Math.pow(2, 10))), e += 2;
      break;
    case "32uint":
    case "32sint":
      i[m] = r[e] | r[e + 1] << 8 | r[e + 2] << 16 | r[e + 3] << 24, e += 4;
      break;
    case "32float":
      i[m] = new Float32Array(r.buffer, e, 1)[0], e += 4;
  }
  var s, l, o, d;
  return i;
}
function ii(r, e, t, n, i) {
  for (let s = 0; s < n; ++s) switch (t) {
    case "8unorm":
      r[e] = 255 * i[s], e++;
      break;
    case "8snorm":
      r[e] = 0.5 * (i[s] + 1) * 255, e++;
      break;
    case "8uint":
      r[e] = i[s], e++;
      break;
    case "8sint":
      r[e] = i[s] + 127, e++;
      break;
    case "16uint":
      new Uint16Array(r.buffer, e, 1)[0] = i[s], e += 2;
      break;
    case "16sint":
      new Int16Array(r.buffer, e, 1)[0] = i[s], e += 2;
      break;
    case "16float": {
      const l = mk(i[s]);
      new Uint16Array(r.buffer, e, 1)[0] = l, e += 2;
      break;
    }
    case "32uint":
      new Uint32Array(r.buffer, e, 1)[0] = i[s], e += 4;
      break;
    case "32sint":
      new Int32Array(r.buffer, e, 1)[0] = i[s], e += 4;
      break;
    case "32float":
      new Float32Array(r.buffer, e, 1)[0] = i[s], e += 4;
  }
  return i;
}
const gb = {
  r8unorm: {
    bytesPerBlock: 1,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 1
  },
  r8snorm: {
    bytesPerBlock: 1,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 1
  },
  r8uint: {
    bytesPerBlock: 1,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 1
  },
  r8sint: {
    bytesPerBlock: 1,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 1
  },
  rg8unorm: {
    bytesPerBlock: 2,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 2
  },
  rg8snorm: {
    bytesPerBlock: 2,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 2
  },
  rg8uint: {
    bytesPerBlock: 2,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 2
  },
  rg8sint: {
    bytesPerBlock: 2,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 2
  },
  rgba8unorm: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  "rgba8unorm-srgb": {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  rgba8snorm: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  rgba8uint: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  rgba8sint: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  bgra8unorm: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  "bgra8unorm-srgb": {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  r16uint: {
    bytesPerBlock: 2,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 1
  },
  r16sint: {
    bytesPerBlock: 2,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 1
  },
  r16float: {
    bytesPerBlock: 2,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 1
  },
  rg16uint: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 2
  },
  rg16sint: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 2
  },
  rg16float: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 2
  },
  rgba16uint: {
    bytesPerBlock: 8,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  rgba16sint: {
    bytesPerBlock: 8,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  rgba16float: {
    bytesPerBlock: 8,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  r32uint: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 1
  },
  r32sint: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 1
  },
  r32float: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 1
  },
  rg32uint: {
    bytesPerBlock: 8,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 2
  },
  rg32sint: {
    bytesPerBlock: 8,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 2
  },
  rg32float: {
    bytesPerBlock: 8,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 2
  },
  rgba32uint: {
    bytesPerBlock: 16,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  rgba32sint: {
    bytesPerBlock: 16,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  rgba32float: {
    bytesPerBlock: 16,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  rgb10a2uint: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  rgb10a2unorm: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  rg11b10ufloat: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  stencil8: {
    bytesPerBlock: 1,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    isDepthStencil: !0,
    hasDepth: !1,
    hasStencil: !0,
    channels: 1
  },
  depth16unorm: {
    bytesPerBlock: 2,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    isDepthStencil: !0,
    hasDepth: !0,
    hasStencil: !1,
    channels: 1
  },
  depth24plus: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    isDepthStencil: !0,
    hasDepth: !0,
    hasStencil: !1,
    depthOnlyFormat: "depth32float",
    channels: 1
  },
  "depth24plus-stencil8": {
    bytesPerBlock: 8,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    isDepthStencil: !0,
    hasDepth: !0,
    hasStencil: !0,
    depthOnlyFormat: "depth32float",
    channels: 1
  },
  depth32float: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    isDepthStencil: !0,
    hasDepth: !0,
    hasStencil: !1,
    channels: 1
  },
  "depth32float-stencil8": {
    bytesPerBlock: 8,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    isDepthStencil: !0,
    hasDepth: !0,
    hasStencil: !0,
    stencilOnlyFormat: "depth32float",
    channels: 1
  },
  rgb9e5ufloat: {
    bytesPerBlock: 4,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !1,
    channels: 4
  },
  "bc1-rgba-unorm": {
    bytesPerBlock: 8,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "bc1-rgba-unorm-srgb": {
    bytesPerBlock: 8,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "bc2-rgba-unorm": {
    bytesPerBlock: 16,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "bc2-rgba-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "bc3-rgba-unorm": {
    bytesPerBlock: 16,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "bc3-rgba-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "bc4-r-unorm": {
    bytesPerBlock: 8,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 1
  },
  "bc4-r-snorm": {
    bytesPerBlock: 8,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 1
  },
  "bc5-rg-unorm": {
    bytesPerBlock: 16,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 2
  },
  "bc5-rg-snorm": {
    bytesPerBlock: 16,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 2
  },
  "bc6h-rgb-ufloat": {
    bytesPerBlock: 16,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "bc6h-rgb-float": {
    bytesPerBlock: 16,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "bc7-rgba-unorm": {
    bytesPerBlock: 16,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "bc7-rgba-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "etc2-rgb8unorm": {
    bytesPerBlock: 8,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "etc2-rgb8unorm-srgb": {
    bytesPerBlock: 8,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "etc2-rgb8a1unorm": {
    bytesPerBlock: 8,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "etc2-rgb8a1unorm-srgb": {
    bytesPerBlock: 8,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "etc2-rgba8unorm": {
    bytesPerBlock: 16,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "etc2-rgba8unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "eac-r11unorm": {
    bytesPerBlock: 8,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !0,
    channels: 1
  },
  "eac-r11snorm": {
    bytesPerBlock: 8,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !0,
    channels: 1
  },
  "eac-rg11unorm": {
    bytesPerBlock: 16,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !0,
    channels: 2
  },
  "eac-rg11snorm": {
    bytesPerBlock: 16,
    blockWidth: 1,
    blockHeight: 1,
    isCompressed: !0,
    channels: 2
  },
  "astc-4x4-unorm": {
    bytesPerBlock: 16,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "astc-4x4-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 4,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "astc-5x4-unorm": {
    bytesPerBlock: 16,
    blockWidth: 5,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "astc-5x4-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 5,
    blockHeight: 4,
    isCompressed: !0,
    channels: 4
  },
  "astc-5x5-unorm": {
    bytesPerBlock: 16,
    blockWidth: 5,
    blockHeight: 5,
    isCompressed: !0,
    channels: 4
  },
  "astc-5x5-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 5,
    blockHeight: 5,
    isCompressed: !0,
    channels: 4
  },
  "astc-6x5-unorm": {
    bytesPerBlock: 16,
    blockWidth: 6,
    blockHeight: 5,
    isCompressed: !0,
    channels: 4
  },
  "astc-6x5-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 6,
    blockHeight: 5,
    isCompressed: !0,
    channels: 4
  },
  "astc-6x6-unorm": {
    bytesPerBlock: 16,
    blockWidth: 6,
    blockHeight: 6,
    isCompressed: !0,
    channels: 4
  },
  "astc-6x6-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 6,
    blockHeight: 6,
    isCompressed: !0,
    channels: 4
  },
  "astc-8x5-unorm": {
    bytesPerBlock: 16,
    blockWidth: 8,
    blockHeight: 5,
    isCompressed: !0,
    channels: 4
  },
  "astc-8x5-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 8,
    blockHeight: 5,
    isCompressed: !0,
    channels: 4
  },
  "astc-8x6-unorm": {
    bytesPerBlock: 16,
    blockWidth: 8,
    blockHeight: 6,
    isCompressed: !0,
    channels: 4
  },
  "astc-8x6-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 8,
    blockHeight: 6,
    isCompressed: !0,
    channels: 4
  },
  "astc-8x8-unorm": {
    bytesPerBlock: 16,
    blockWidth: 8,
    blockHeight: 8,
    isCompressed: !0,
    channels: 4
  },
  "astc-8x8-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 8,
    blockHeight: 8,
    isCompressed: !0,
    channels: 4
  },
  "astc-10x5-unorm": {
    bytesPerBlock: 16,
    blockWidth: 10,
    blockHeight: 5,
    isCompressed: !0,
    channels: 4
  },
  "astc-10x5-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 10,
    blockHeight: 5,
    isCompressed: !0,
    channels: 4
  },
  "astc-10x6-unorm": {
    bytesPerBlock: 16,
    blockWidth: 10,
    blockHeight: 6,
    isCompressed: !0,
    channels: 4
  },
  "astc-10x6-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 10,
    blockHeight: 6,
    isCompressed: !0,
    channels: 4
  },
  "astc-10x8-unorm": {
    bytesPerBlock: 16,
    blockWidth: 10,
    blockHeight: 8,
    isCompressed: !0,
    channels: 4
  },
  "astc-10x8-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 10,
    blockHeight: 8,
    isCompressed: !0,
    channels: 4
  },
  "astc-10x10-unorm": {
    bytesPerBlock: 16,
    blockWidth: 10,
    blockHeight: 10,
    isCompressed: !0,
    channels: 4
  },
  "astc-10x10-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 10,
    blockHeight: 10,
    isCompressed: !0,
    channels: 4
  },
  "astc-12x10-unorm": {
    bytesPerBlock: 16,
    blockWidth: 12,
    blockHeight: 10,
    isCompressed: !0,
    channels: 4
  },
  "astc-12x10-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 12,
    blockHeight: 10,
    isCompressed: !0,
    channels: 4
  },
  "astc-12x12-unorm": {
    bytesPerBlock: 16,
    blockWidth: 12,
    blockHeight: 12,
    isCompressed: !0,
    channels: 4
  },
  "astc-12x12-unorm-srgb": {
    bytesPerBlock: 16,
    blockWidth: 12,
    blockHeight: 12,
    isCompressed: !0,
    channels: 4
  }
};
class jl {
  constructor() {
    this.id = jl._id++, this.line = 0;
  }
  get isAstNode() {
    return !0;
  }
  get astNodeType() {
    return "";
  }
  search(e) {
    e(this);
  }
  searchBlock(e, t) {
    if (e) {
      t(H_.instance);
      for (const n of e) n instanceof Array ? this.searchBlock(n, t) : n.search(t);
      t(W_.instance);
    }
  }
  constEvaluate(e, t) {
    throw new Error("Cannot evaluate node");
  }
  constEvaluateString(e) {
    return this.constEvaluate(e).toString();
  }
}
jl._id = 0;
class H_ extends jl {
}
H_.instance = new H_();
class W_ extends jl {
}
W_.instance = new W_();
const BC = /* @__PURE__ */ new Set(["all", "all", "any", "select", "arrayLength", "abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "clamp", "cos", "cosh", "countLeadingZeros", "countOneBits", "countTrailingZeros", "cross", "degrees", "determinant", "distance", "dot", "dot4U8Packed", "dot4I8Packed", "exp", "exp2", "extractBits", "faceForward", "firstLeadingBit", "firstTrailingBit", "floor", "fma", "fract", "frexp", "insertBits", "inverseSqrt", "ldexp", "length", "log", "log2", "max", "min", "mix", "modf", "normalize", "pow", "quantizeToF16", "radians", "reflect", "refract", "reverseBits", "round", "saturate", "sign", "sin", "sinh", "smoothStep", "sqrt", "step", "tan", "tanh", "transpose", "trunc", "dpdx", "dpdxCoarse", "dpdxFine", "dpdy", "dpdyCoarse", "dpdyFine", "fwidth", "fwidthCoarse", "fwidthFine", "textureDimensions", "textureGather", "textureGatherCompare", "textureLoad", "textureNumLayers", "textureNumLevels", "textureNumSamples", "textureSample", "textureSampleBias", "textureSampleCompare", "textureSampleCompareLevel", "textureSampleGrad", "textureSampleLevel", "textureSampleBaseClampToEdge", "textureStore", "atomicLoad", "atomicStore", "atomicAdd", "atomicSub", "atomicMax", "atomicMin", "atomicAnd", "atomicOr", "atomicXor", "atomicExchange", "atomicCompareExchangeWeak", "pack4x8snorm", "pack4x8unorm", "pack4xI8", "pack4xU8", "pack4x8Clamp", "pack4xU8Clamp", "pack2x16snorm", "pack2x16unorm", "pack2x16float", "unpack4x8snorm", "unpack4x8unorm", "unpack4xI8", "unpack4xU8", "unpack2x16snorm", "unpack2x16unorm", "unpack2x16float", "storageBarrier", "textureBarrier", "workgroupBarrier", "workgroupUniformLoad", "subgroupAdd", "subgroupExclusiveAdd", "subgroupInclusiveAdd", "subgroupAll", "subgroupAnd", "subgroupAny", "subgroupBallot", "subgroupBroadcast", "subgroupBroadcastFirst", "subgroupElect", "subgroupMax", "subgroupMin", "subgroupMul", "subgroupExclusiveMul", "subgroupInclusiveMul", "subgroupOr", "subgroupShuffle", "subgroupShuffleDown", "subgroupShuffleUp", "subgroupShuffleXor", "subgroupXor", "quadBroadcast", "quadSwapDiagonal", "quadSwapX", "quadSwapY"]);
class Gi extends jl {
  constructor() {
    super();
  }
}
class Pg extends Gi {
  constructor(e, t, n, i, s, l) {
    super(), this.calls = /* @__PURE__ */ new Set(), this.name = e, this.args = t, this.returnType = n, this.body = i, this.startLine = s, this.endLine = l;
  }
  get astNodeType() {
    return "function";
  }
  search(e) {
    if (this.attributes) for (const t of this.attributes) e(t);
    e(this);
    for (const t of this.args) e(t);
    this.searchBlock(this.body, e);
  }
}
class yk extends Gi {
  constructor(e) {
    super(), this.expression = e;
  }
  get astNodeType() {
    return "staticAssert";
  }
  search(e) {
    this.expression.search(e);
  }
}
class LC extends Gi {
  constructor(e, t) {
    super(), this.condition = e, this.body = t;
  }
  get astNodeType() {
    return "while";
  }
  search(e) {
    this.condition.search(e), this.searchBlock(this.body, e);
  }
}
class Y1 extends Gi {
  constructor(e, t) {
    super(), this.body = e, this.loopId = t;
  }
  get astNodeType() {
    return "continuing";
  }
  search(e) {
    this.searchBlock(this.body, e);
  }
}
class OC extends Gi {
  constructor(e, t, n, i) {
    super(), this.init = e, this.condition = t, this.increment = n, this.body = i;
  }
  get astNodeType() {
    return "for";
  }
  search(e) {
    var t, n, i;
    (t = this.init) === null || t === void 0 || t.search(e), (n = this.condition) === null || n === void 0 || n.search(e), (i = this.increment) === null || i === void 0 || i.search(e), this.searchBlock(this.body, e);
  }
}
class Yu extends Gi {
  constructor(e, t, n, i, s) {
    super(), this.attributes = null, this.name = e, this.type = t, this.storage = n, this.access = i, this.value = s;
  }
  get astNodeType() {
    return "var";
  }
  search(e) {
    var t;
    e(this), (t = this.value) === null || t === void 0 || t.search(e);
  }
}
class x2 extends Gi {
  constructor(e, t, n) {
    super(), this.attributes = null, this.name = e, this.type = t, this.value = n;
  }
  get astNodeType() {
    return "override";
  }
  search(e) {
    var t;
    (t = this.value) === null || t === void 0 || t.search(e);
  }
}
class yg extends Gi {
  constructor(e, t, n, i, s) {
    super(), this.attributes = null, this.name = e, this.type = t, this.storage = n, this.access = i, this.value = s;
  }
  get astNodeType() {
    return "let";
  }
  search(e) {
    var t;
    e(this), (t = this.value) === null || t === void 0 || t.search(e);
  }
}
class c_ extends Gi {
  constructor(e, t, n, i, s) {
    super(), this.attributes = null, this.name = e, this.type = t, this.storage = n, this.access = i, this.value = s;
  }
  get astNodeType() {
    return "const";
  }
  constEvaluate(e, t) {
    return this.value.constEvaluate(e, t);
  }
  search(e) {
    var t;
    e(this), (t = this.value) === null || t === void 0 || t.search(e);
  }
}
var kd, ag, Et, lt;
((r) => {
  r.increment = "++", r.decrement = "--";
})(kd || (kd = {})), ((r) => {
  r.parse = function(e) {
    const t = e;
    if (t == "parse") throw new Error("Invalid value for IncrementOperator");
    return r[t];
  };
})(kd || (kd = {}));
class kC extends Gi {
  constructor(e, t) {
    super(), this.operator = e, this.variable = t;
  }
  get astNodeType() {
    return "increment";
  }
  search(e) {
    this.variable.search(e);
  }
}
((r) => {
  r.assign = "=", r.addAssign = "+=", r.subtractAssin = "-=", r.multiplyAssign = "*=", r.divideAssign = "/=", r.moduloAssign = "%=", r.andAssign = "&=", r.orAssign = "|=", r.xorAssign = "^=", r.shiftLeftAssign = "<<=", r.shiftRightAssign = ">>=";
})(ag || (ag = {})), ((r) => {
  r.parse = function(e) {
    const t = e;
    if (t == "parse") throw new Error("Invalid value for AssignOperator");
    return t;
  };
})(ag || (ag = {}));
class NC extends Gi {
  constructor(e, t, n) {
    super(), this.operator = e, this.variable = t, this.value = n;
  }
  get astNodeType() {
    return "assign";
  }
  search(e) {
    this.variable.search(e), this.value.search(e);
  }
}
class w2 extends Gi {
  constructor(e, t) {
    super(), this.name = e, this.args = t;
  }
  get astNodeType() {
    return "call";
  }
  isBuiltin() {
    return BC.has(this.name);
  }
  search(e) {
    for (const t of this.args) t.search(e);
    e(this);
  }
}
class DC extends Gi {
  constructor(e, t) {
    super(), this.body = e, this.continuing = t;
  }
  get astNodeType() {
    return "loop";
  }
}
class FC extends Gi {
  constructor(e, t) {
    super(), this.condition = e, this.cases = t;
  }
  get astNodeType() {
    return "switch";
  }
  search(e) {
    e(this);
    for (const t of this.cases) t.search(e);
  }
}
class UC extends Gi {
  constructor(e, t, n, i) {
    super(), this.condition = e, this.body = t, this.elseif = n, this.else = i;
  }
  get astNodeType() {
    return "if";
  }
  search(e) {
    this.condition.search(e), this.searchBlock(this.body, e), this.searchBlock(this.elseif, e), this.searchBlock(this.else, e);
  }
}
class zC extends Gi {
  constructor(e) {
    super(), this.value = e;
  }
  get astNodeType() {
    return "return";
  }
  search(e) {
    var t;
    (t = this.value) === null || t === void 0 || t.search(e);
  }
}
class bk extends Gi {
  constructor(e) {
    super(), this.name = e;
  }
  get astNodeType() {
    return "enable";
  }
}
class vk extends Gi {
  constructor(e) {
    super(), this.extensions = e;
  }
  get astNodeType() {
    return "requires";
  }
}
class jC extends Gi {
  constructor(e, t) {
    super(), this.severity = e, this.rule = t;
  }
  get astNodeType() {
    return "diagnostic";
  }
}
class A2 extends Gi {
  constructor(e, t) {
    super(), this.name = e, this.type = t;
  }
  get astNodeType() {
    return "alias";
  }
}
class xk extends Gi {
  constructor() {
    super();
  }
  get astNodeType() {
    return "discard";
  }
}
class VC extends Gi {
  constructor() {
    super(), this.condition = null, this.loopId = -1;
  }
  get astNodeType() {
    return "break";
  }
}
class $C extends Gi {
  constructor() {
    super(), this.loopId = -1;
  }
  get astNodeType() {
    return "continue";
  }
}
class Xt extends Gi {
  constructor(e) {
    super(), this.attributes = null, this.name = e;
  }
  get astNodeType() {
    return "type";
  }
  get isStruct() {
    return !1;
  }
  get isArray() {
    return !1;
  }
  static maxFormatType(e) {
    let t = e[0];
    if (t.name === "f32") return t;
    for (let n = 1; n < e.length; ++n) {
      const i = Xt._priority.get(t.name);
      Xt._priority.get(e[n].name) < i && (t = e[n]);
    }
    return t.name === "x32" ? Xt.i32 : t;
  }
  getTypeName() {
    return this.name;
  }
}
Xt.x32 = new Xt("x32"), Xt.f32 = new Xt("f32"), Xt.i32 = new Xt("i32"), Xt.u32 = new Xt("u32"), Xt.f16 = new Xt("f16"), Xt.bool = new Xt("bool"), Xt.void = new Xt("void"), Xt._priority = /* @__PURE__ */ new Map([["f32", 0], ["f16", 1], ["u32", 2], ["i32", 3], ["x32", 3]]);
class oT extends Xt {
  constructor(e) {
    super(e);
  }
}
let Xu = class extends Xt {
  constructor(e, t, n, i) {
    super(e), this.members = t, this.startLine = n, this.endLine = i;
  }
  get astNodeType() {
    return "struct";
  }
  get isStruct() {
    return !0;
  }
  getMemberIndex(e) {
    for (let t = 0; t < this.members.length; t++) if (this.members[t].name == e) return t;
    return -1;
  }
  search(e) {
    for (const t of this.members) e(t);
  }
};
class pt extends Xt {
  constructor(e, t, n) {
    super(e), this.format = t, this.access = n;
  }
  get astNodeType() {
    return "template";
  }
  getTypeName() {
    let e = this.name;
    if (this.format !== null) {
      if (e === "vec2" || e === "vec3" || e === "vec4" || e === "mat2x2" || e === "mat2x3" || e === "mat2x4" || e === "mat3x2" || e === "mat3x3" || e === "mat3x4" || e === "mat4x2" || e === "mat4x3" || e === "mat4x4") {
        if (this.format.name === "f32") return e += "f", e;
        if (this.format.name === "i32") return e += "i", e;
        if (this.format.name === "u32") return e += "u", e;
        if (this.format.name === "bool") return e += "b", e;
        if (this.format.name === "f16") return e += "h", e;
      }
      e += `<${this.format.name}>`;
    } else if (e === "vec2" || e === "vec3" || e === "vec4") return e;
    return e;
  }
}
pt.vec2f = new pt("vec2", Xt.f32, null), pt.vec3f = new pt("vec3", Xt.f32, null), pt.vec4f = new pt("vec4", Xt.f32, null), pt.vec2i = new pt("vec2", Xt.i32, null), pt.vec3i = new pt("vec3", Xt.i32, null), pt.vec4i = new pt("vec4", Xt.i32, null), pt.vec2u = new pt("vec2", Xt.u32, null), pt.vec3u = new pt("vec3", Xt.u32, null), pt.vec4u = new pt("vec4", Xt.u32, null), pt.vec2h = new pt("vec2", Xt.f16, null), pt.vec3h = new pt("vec3", Xt.f16, null), pt.vec4h = new pt("vec4", Xt.f16, null), pt.vec2b = new pt("vec2", Xt.bool, null), pt.vec3b = new pt("vec3", Xt.bool, null), pt.vec4b = new pt("vec4", Xt.bool, null), pt.mat2x2f = new pt("mat2x2", Xt.f32, null), pt.mat2x3f = new pt("mat2x3", Xt.f32, null), pt.mat2x4f = new pt("mat2x4", Xt.f32, null), pt.mat3x2f = new pt("mat3x2", Xt.f32, null), pt.mat3x3f = new pt("mat3x3", Xt.f32, null), pt.mat3x4f = new pt("mat3x4", Xt.f32, null), pt.mat4x2f = new pt("mat4x2", Xt.f32, null), pt.mat4x3f = new pt("mat4x3", Xt.f32, null), pt.mat4x4f = new pt("mat4x4", Xt.f32, null), pt.mat2x2h = new pt("mat2x2", Xt.f16, null), pt.mat2x3h = new pt("mat2x3", Xt.f16, null), pt.mat2x4h = new pt("mat2x4", Xt.f16, null), pt.mat3x2h = new pt("mat3x2", Xt.f16, null), pt.mat3x3h = new pt("mat3x3", Xt.f16, null), pt.mat3x4h = new pt("mat3x4", Xt.f16, null), pt.mat4x2h = new pt("mat4x2", Xt.f16, null), pt.mat4x3h = new pt("mat4x3", Xt.f16, null), pt.mat4x4h = new pt("mat4x4", Xt.f16, null), pt.mat2x2i = new pt("mat2x2", Xt.i32, null), pt.mat2x3i = new pt("mat2x3", Xt.i32, null), pt.mat2x4i = new pt("mat2x4", Xt.i32, null), pt.mat3x2i = new pt("mat3x2", Xt.i32, null), pt.mat3x3i = new pt("mat3x3", Xt.i32, null), pt.mat3x4i = new pt("mat3x4", Xt.i32, null), pt.mat4x2i = new pt("mat4x2", Xt.i32, null), pt.mat4x3i = new pt("mat4x3", Xt.i32, null), pt.mat4x4i = new pt("mat4x4", Xt.i32, null), pt.mat2x2u = new pt("mat2x2", Xt.u32, null), pt.mat2x3u = new pt("mat2x3", Xt.u32, null), pt.mat2x4u = new pt("mat2x4", Xt.u32, null), pt.mat3x2u = new pt("mat3x2", Xt.u32, null), pt.mat3x3u = new pt("mat3x3", Xt.u32, null), pt.mat3x4u = new pt("mat3x4", Xt.u32, null), pt.mat4x2u = new pt("mat4x2", Xt.u32, null), pt.mat4x3u = new pt("mat4x3", Xt.u32, null), pt.mat4x4u = new pt("mat4x4", Xt.u32, null);
class u_ extends Xt {
  constructor(e, t, n, i) {
    super(e), this.storage = t, this.type = n, this.access = i;
  }
  get astNodeType() {
    return "pointer";
  }
}
class bg extends Xt {
  constructor(e, t, n, i) {
    super(e), this.attributes = t, this.format = n, this.count = i;
  }
  get astNodeType() {
    return "array";
  }
  get isArray() {
    return !0;
  }
}
class lg extends Xt {
  constructor(e, t, n) {
    super(e), this.format = t, this.access = n;
  }
  get astNodeType() {
    return "sampler";
  }
}
class Bc extends jl {
  constructor() {
    super(), this.postfix = null;
  }
}
class $f extends Bc {
  constructor(e) {
    super(), this.value = e;
  }
  get astNodeType() {
    return "stringExpr";
  }
  toString() {
    return this.value;
  }
  constEvaluateString() {
    return this.value;
  }
}
class hu extends Bc {
  constructor(e, t) {
    super(), this.type = e, this.args = t;
  }
  get astNodeType() {
    return "createExpr";
  }
  search(e) {
    if (e(this), this.args) for (const t of this.args) t.search(e);
  }
  constEvaluate(e, t) {
    return t && (t[0] = this.type), e.evalExpression(this, e.context);
  }
}
let T2 = class extends Bc {
  constructor(e, t) {
    super(), this.cachedReturnValue = null, this.name = e, this.args = t;
  }
  get astNodeType() {
    return "callExpr";
  }
  setCachedReturnValue(e) {
    this.cachedReturnValue = e;
  }
  get isBuiltin() {
    return BC.has(this.name);
  }
  constEvaluate(e, t) {
    return e.evalExpression(this, e.context);
  }
  search(e) {
    for (const t of this.args) t.search(e);
    e(this);
  }
};
class gl extends Bc {
  constructor(e) {
    super(), this.name = e;
  }
  get astNodeType() {
    return "varExpr";
  }
  search(e) {
    e(this), this.postfix && this.postfix.search(e);
  }
  constEvaluate(e, t) {
    return e.evalExpression(this, e.context);
  }
}
class qC extends Bc {
  constructor(e, t) {
    super(), this.name = e, this.initializer = t;
  }
  get astNodeType() {
    return "constExpr";
  }
  constEvaluate(e, t) {
    if (this.initializer) {
      const n = e.evalExpression(this.initializer, e.context);
      return n !== null && this.postfix ? n.getSubData(e, this.postfix, e.context) : n;
    }
    return null;
  }
  search(e) {
    this.initializer.search(e);
  }
}
class eo extends Bc {
  constructor(e, t) {
    super(), this.value = e, this.type = t;
  }
  get astNodeType() {
    return "literalExpr";
  }
  constEvaluate(e, t) {
    return t !== void 0 && (t[0] = this.type), this.value;
  }
  get isScalar() {
    return this.value instanceof ut;
  }
  get isVector() {
    return this.value instanceof Ne || this.value instanceof tn;
  }
  get scalarValue() {
    return this.value instanceof ut ? this.value.value : (console.error("Value is not scalar."), 0);
  }
  get vectorValue() {
    return this.value instanceof Ne || this.value instanceof tn ? this.value.data : (console.error("Value is not a vector or matrix."), new Float32Array(0));
  }
}
let GC = class extends Bc {
  constructor(e, t) {
    super(), this.type = e, this.value = t;
  }
  get astNodeType() {
    return "bitcastExpr";
  }
  search(e) {
    this.value.search(e);
  }
}, ip = class extends Bc {
  constructor(e) {
    super(), this.index = e;
  }
  search(e) {
    this.index.search(e);
  }
};
class HC extends Bc {
  constructor() {
    super();
  }
}
class Us extends HC {
  constructor(e, t) {
    super(), this.operator = e, this.right = t;
  }
  get astNodeType() {
    return "unaryOp";
  }
  constEvaluate(e, t) {
    return e.evalExpression(this, e.context);
  }
  search(e) {
    this.right.search(e);
  }
}
let yc = class extends HC {
  constructor(e, t, n) {
    super(), this.operator = e, this.left = t, this.right = n;
  }
  get astNodeType() {
    return "binaryOp";
  }
  _getPromotedType(e, t) {
    return e.name === t.name ? e : e.name === "f32" || t.name === "f32" ? Xt.f32 : e.name === "u32" || t.name === "u32" ? Xt.u32 : Xt.i32;
  }
  constEvaluate(e, t) {
    return e.evalExpression(this, e.context);
  }
  search(e) {
    this.left.search(e), this.right.search(e);
  }
};
class WC extends jl {
  constructor(e) {
    super(), this.body = e;
  }
  search(e) {
    e(this), this.searchBlock(this.body, e);
  }
}
class h_ extends Bc {
  constructor() {
    super();
  }
  get astNodeType() {
    return "default";
  }
}
class XC extends WC {
  constructor(e, t) {
    super(t), this.selectors = e;
  }
  get astNodeType() {
    return "case";
  }
  search(e) {
    this.searchBlock(this.body, e);
  }
}
class ZC extends WC {
  constructor(e) {
    super(e);
  }
  get astNodeType() {
    return "default";
  }
  search(e) {
    this.searchBlock(this.body, e);
  }
}
let aT = class extends jl {
  constructor(e, t, n) {
    super(), this.name = e, this.type = t, this.attributes = n;
  }
  get astNodeType() {
    return "argument";
  }
};
class wk extends jl {
  constructor(e, t) {
    super(), this.condition = e, this.body = t;
  }
  get astNodeType() {
    return "elseif";
  }
  search(e) {
    this.condition.search(e), this.searchBlock(this.body, e);
  }
}
class lT extends jl {
  constructor(e, t, n) {
    super(), this.name = e, this.type = t, this.attributes = n;
  }
  get astNodeType() {
    return "member";
  }
}
class YC extends jl {
  constructor(e, t) {
    super(), this.name = e, this.value = t;
  }
  get astNodeType() {
    return "attribute";
  }
}
class zl {
  constructor(e, t) {
    this.parent = null, this.typeInfo = e, this.parent = t, this.id = zl._id++;
  }
  clone() {
    throw `Clone: Not implemented for ${this.constructor.name}`;
  }
  setDataValue(e, t, n, i) {
    console.error(`SetDataValue: Not implemented for ${this.constructor.name}`);
  }
  getSubData(e, t, n) {
    return console.error(`GetDataValue: Not implemented for ${this.constructor.name}`), null;
  }
  toString() {
    return `<${this.typeInfo.getTypeName()}>`;
  }
}
zl._id = 0;
class K1 extends zl {
  constructor() {
    super(new Fl("void", null), null);
  }
  toString() {
    return "void";
  }
}
K1.void = new K1();
class Ad extends zl {
  constructor(e) {
    super(new Z1("pointer", e.typeInfo, null), null), this.reference = e;
  }
  clone() {
    return this;
  }
  setDataValue(e, t, n, i) {
    this.reference.setDataValue(e, t, n, i);
  }
  getSubData(e, t, n) {
    return t ? this.reference.getSubData(e, t, n) : this;
  }
  toString() {
    return `&${this.reference.toString()}`;
  }
}
let ut = class cg extends zl {
  constructor(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    super(t, n), e instanceof Int32Array || e instanceof Uint32Array || e instanceof Float32Array ? this.data = e : this.typeInfo.name === "x32" ? e - Math.floor(e) != 0 ? this.data = new Float32Array([e]) : this.data = e >= 0 ? new Uint32Array([e]) : new Int32Array([e]) : this.typeInfo.name === "i32" || this.typeInfo.name === "bool" ? this.data = new Int32Array([e]) : this.typeInfo.name === "u32" ? this.data = new Uint32Array([e]) : this.typeInfo.name === "f32" || this.typeInfo.name === "f16" ? this.data = new Float32Array([e]) : console.error("ScalarData2: Invalid type", t);
  }
  clone() {
    if (this.data instanceof Float32Array) return new cg(new Float32Array(this.data), this.typeInfo, null);
    if (this.data instanceof Int32Array) return new cg(new Int32Array(this.data), this.typeInfo, null);
    if (this.data instanceof Uint32Array) return new cg(new Uint32Array(this.data), this.typeInfo, null);
    throw "ScalarData: Invalid data type";
  }
  get value() {
    return this.data[0];
  }
  set value(e) {
    this.data[0] = e;
  }
  setDataValue(e, t, n, i) {
    if (n) return void console.error("SetDataValue: Scalar data does not support postfix", n);
    if (!(t instanceof cg)) return void console.error("SetDataValue: Invalid value", t);
    let s = t.data[0];
    this.typeInfo.name === "i32" || this.typeInfo.name === "u32" ? s = Math.floor(s) : this.typeInfo.name === "bool" && (s = s ? 1 : 0), this.data[0] = s;
  }
  getSubData(e, t, n) {
    return t ? (console.error("getSubData: Scalar data does not support postfix", t), null) : this;
  }
  toString() {
    return `${this.value}`;
  }
};
function Ak(r, e, t) {
  const n = e.length;
  return n === 2 ? t === "f32" ? new Ne(new Float32Array(e), r.getTypeInfo("vec2f")) : t === "i32" || t === "bool" ? new Ne(new Int32Array(e), r.getTypeInfo("vec2i")) : t === "u32" ? new Ne(new Uint32Array(e), r.getTypeInfo("vec2u")) : t === "f16" ? new Ne(new Float32Array(e), r.getTypeInfo("vec2h")) : (console.error(`getSubData: Unknown format ${t}`), null) : n === 3 ? t === "f32" ? new Ne(new Float32Array(e), r.getTypeInfo("vec3f")) : t === "i32" || t === "bool" ? new Ne(new Int32Array(e), r.getTypeInfo("vec3i")) : t === "u32" ? new Ne(new Uint32Array(e), r.getTypeInfo("vec3u")) : t === "f16" ? new Ne(new Float32Array(e), r.getTypeInfo("vec3h")) : (console.error(`getSubData: Unknown format ${t}`), null) : n === 4 ? t === "f32" ? new Ne(new Float32Array(e), r.getTypeInfo("vec4f")) : t === "i32" || t === "bool" ? new Ne(new Int32Array(e), r.getTypeInfo("vec4i")) : t === "u32" ? new Ne(new Uint32Array(e), r.getTypeInfo("vec4u")) : t === "f16" ? new Ne(new Float32Array(e), r.getTypeInfo("vec4h")) : (console.error(`getSubData: Unknown format ${t}`), null) : (console.error(`getSubData: Invalid vector size ${e.length}`), null);
}
class Ne extends zl {
  constructor(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    if (super(t, n), e instanceof Float32Array || e instanceof Uint32Array || e instanceof Int32Array) this.data = e;
    else {
      const i = this.typeInfo.name;
      i === "vec2f" || i === "vec3f" || i === "vec4f" ? this.data = new Float32Array(e) : i === "vec2i" || i === "vec3i" || i === "vec4i" ? this.data = new Int32Array(e) : i === "vec2u" || i === "vec3u" || i === "vec4u" ? this.data = new Uint32Array(e) : i === "vec2h" || i === "vec3h" || i === "vec4h" ? this.data = new Float32Array(e) : i === "vec2b" || i === "vec3b" || i === "vec4b" ? this.data = new Int32Array(e) : i === "vec2" || i === "vec3" || i === "vec4" ? this.data = new Float32Array(e) : console.error(`VectorData: Invalid type ${i}`);
    }
  }
  clone() {
    if (this.data instanceof Float32Array) return new Ne(new Float32Array(this.data), this.typeInfo, null);
    if (this.data instanceof Int32Array) return new Ne(new Int32Array(this.data), this.typeInfo, null);
    if (this.data instanceof Uint32Array) return new Ne(new Uint32Array(this.data), this.typeInfo, null);
    throw "VectorData: Invalid data type";
  }
  setDataValue(e, t, n, i) {
    n instanceof $f ? console.error("TODO: Set vector postfix") : t instanceof Ne ? this.data = t.data : console.error("SetDataValue: Invalid value", t);
  }
  getSubData(e, t, n) {
    if (t === null) return this;
    let i = e.getTypeInfo("f32");
    if (this.typeInfo instanceof Vf) i = this.typeInfo.format || i;
    else {
      const l = this.typeInfo.name;
      l === "vec2f" || l === "vec3f" || l === "vec4f" ? i = e.getTypeInfo("f32") : l === "vec2i" || l === "vec3i" || l === "vec4i" ? i = e.getTypeInfo("i32") : l === "vec2b" || l === "vec3b" || l === "vec4b" ? i = e.getTypeInfo("bool") : l === "vec2u" || l === "vec3u" || l === "vec4u" ? i = e.getTypeInfo("u32") : l === "vec2h" || l === "vec3h" || l === "vec4h" ? i = e.getTypeInfo("f16") : console.error(`GetSubData: Unknown type ${l}`);
    }
    let s = this;
    for (; t !== null && s !== null; ) {
      if (t instanceof ip) {
        const l = t.index;
        let o = -1;
        if (l instanceof eo) {
          if (!(l.value instanceof ut)) return console.error(`GetSubData: Invalid array index ${l.value}`), null;
          o = l.value.value;
        } else {
          const d = e.evalExpression(l, n);
          if (!(d instanceof ut)) return console.error("GetSubData: Unknown index type", l), null;
          o = d.value;
        }
        if (o < 0 || o >= s.data.length) return console.error("GetSubData: Index out of range", o), null;
        if (s.data instanceof Float32Array) {
          const d = new Float32Array(s.data.buffer, s.data.byteOffset + 4 * o, 1);
          return new ut(d, i);
        }
        if (s.data instanceof Int32Array) {
          const d = new Int32Array(s.data.buffer, s.data.byteOffset + 4 * o, 1);
          return new ut(d, i);
        }
        if (s.data instanceof Uint32Array) {
          const d = new Uint32Array(s.data.buffer, s.data.byteOffset + 4 * o, 1);
          return new ut(d, i);
        }
        throw "GetSubData: Invalid data type";
      }
      if (!(t instanceof $f)) return console.error("GetSubData: Unknown postfix", t), null;
      {
        const l = t.value.toLowerCase();
        if (l.length === 1) {
          let d = 0;
          if (l === "x" || l === "r") d = 0;
          else if (l === "y" || l === "g") d = 1;
          else if (l === "z" || l === "b") d = 2;
          else {
            if (l !== "w" && l !== "a") return console.error(`GetSubData: Unknown member ${l}`), null;
            d = 3;
          }
          if (this.data instanceof Float32Array) {
            let m = new Float32Array(this.data.buffer, this.data.byteOffset + 4 * d, 1);
            return new ut(m, i, this);
          }
          if (this.data instanceof Int32Array) {
            let m = new Int32Array(this.data.buffer, this.data.byteOffset + 4 * d, 1);
            return new ut(m, i, this);
          }
          if (this.data instanceof Uint32Array) {
            let m = new Uint32Array(this.data.buffer, this.data.byteOffset + 4 * d, 1);
            return new ut(m, i, this);
          }
        }
        const o = [];
        for (const d of l) d === "x" || d === "r" ? o.push(this.data[0]) : d === "y" || d === "g" ? o.push(this.data[1]) : d === "z" || d === "b" ? o.push(this.data[2]) : d === "w" || d === "a" ? o.push(this.data[3]) : console.error(`GetDataValue: Unknown member ${d}`);
        s = Ak(e, o, i.name);
      }
      t = t.postfix;
    }
    return s;
  }
  toString() {
    let e = `${this.data[0]}`;
    for (let t = 1; t < this.data.length; ++t) e += `, ${this.data[t]}`;
    return e;
  }
}
class tn extends zl {
  constructor(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    super(t, n), e instanceof Float32Array ? this.data = e : this.data = new Float32Array(e);
  }
  clone() {
    return new tn(new Float32Array(this.data), this.typeInfo, null);
  }
  setDataValue(e, t, n, i) {
    n instanceof $f ? console.error("TODO: Set matrix postfix") : t instanceof tn ? this.data = t.data : console.error("SetDataValue: Invalid value", t);
  }
  getSubData(e, t, n) {
    if (t === null) return this;
    const i = this.typeInfo.name;
    if (e.getTypeInfo("f32"), this.typeInfo instanceof Vf) this.typeInfo.format;
    else if (i.endsWith("f")) e.getTypeInfo("f32");
    else if (i.endsWith("i")) e.getTypeInfo("i32");
    else if (i.endsWith("u")) e.getTypeInfo("u32");
    else {
      if (!i.endsWith("h")) return console.error(`GetDataValue: Unknown type ${i}`), null;
      e.getTypeInfo("f16");
    }
    if (t instanceof ip) {
      const s = t.index;
      let l = -1;
      if (s instanceof eo) {
        if (!(s.value instanceof ut)) return console.error(`GetDataValue: Invalid array index ${s.value}`), null;
        l = s.value.value;
      } else {
        const m = e.evalExpression(s, n);
        if (!(m instanceof ut)) return console.error("GetDataValue: Unknown index type", s), null;
        l = m.value;
      }
      if (l < 0 || l >= this.data.length) return console.error("GetDataValue: Index out of range", l), null;
      const o = i.endsWith("h") ? "h" : "f";
      let d;
      if (i === "mat2x2" || i === "mat2x2f" || i === "mat2x2h" || i === "mat3x2" || i === "mat3x2f" || i === "mat3x2h" || i === "mat4x2" || i === "mat4x2f" || i === "mat4x2h") d = new Ne(new Float32Array(this.data.buffer, this.data.byteOffset + 2 * l * 4, 2), e.getTypeInfo(`vec2${o}`));
      else if (i === "mat2x3" || i === "mat2x3f" || i === "mat2x3h" || i === "mat3x3" || i === "mat3x3f" || i === "mat3x3h" || i === "mat4x3" || i === "mat4x3f" || i === "mat4x3h") d = new Ne(new Float32Array(this.data.buffer, this.data.byteOffset + 3 * l * 4, 3), e.getTypeInfo(`vec3${o}`));
      else {
        if (i !== "mat2x4" && i !== "mat2x4f" && i !== "mat2x4h" && i !== "mat3x4" && i !== "mat3x4f" && i !== "mat3x4h" && i !== "mat4x4" && i !== "mat4x4f" && i !== "mat4x4h") return console.error(`GetDataValue: Unknown type ${i}`), null;
        d = new Ne(new Float32Array(this.data.buffer, this.data.byteOffset + 4 * l * 4, 4), e.getTypeInfo(`vec4${o}`));
      }
      return t.postfix ? d.getSubData(e, t.postfix, n) : d;
    }
    return console.error("GetDataValue: Invalid postfix", t), null;
  }
  toString() {
    let e = `${this.data[0]}`;
    for (let t = 1; t < this.data.length; ++t) e += `, ${this.data[t]}`;
    return e;
  }
}
class ps extends zl {
  constructor(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
    super(t, i), this.buffer = e instanceof ArrayBuffer ? e : e.buffer, this.offset = n;
  }
  clone() {
    const e = new Uint8Array(new Uint8Array(this.buffer, this.offset, this.typeInfo.size));
    return new ps(e.buffer, this.typeInfo, 0, null);
  }
  setDataValue(e, t, n, i) {
    if (t === null) return void console.log("setDataValue: NULL data.");
    let s = this.offset, l = this.typeInfo;
    for (; n; ) {
      if (n instanceof ip)
        if (l instanceof $h) {
          const o = n.index;
          if (o instanceof eo) {
            if (!(o.value instanceof ut)) return void console.error(`SetDataValue: Invalid index type ${o.value}`);
            s += o.value.value * l.stride;
          } else {
            const d = e.evalExpression(o, i);
            if (!(d instanceof ut)) return void console.error("SetDataValue: Unknown index type", o);
            s += d.value * l.stride;
          }
          l = l.format;
        } else console.error(`SetDataValue: Type ${l.getTypeName()} is not an array`);
      else {
        if (!(n instanceof $f)) return void console.error("SetDataValue: Unknown postfix type", n);
        {
          const o = n.value;
          if (l instanceof Uh) {
            let d = !1;
            for (const m of l.members) if (m.name === o) {
              s += m.offset, l = m.type, d = !0;
              break;
            }
            if (!d) return void console.error(`SetDataValue: Member ${o} not found`);
          } else if (l instanceof Fl) {
            const d = l.getTypeName();
            let m = 0;
            if (o === "x" || o === "r") m = 0;
            else if (o === "y" || o === "g") m = 1;
            else if (o === "z" || o === "b") m = 2;
            else {
              if (o !== "w" && o !== "a") return void console.error(`SetDataValue: Unknown member ${o}`);
              m = 3;
            }
            if (!(t instanceof ut)) return void console.error("SetDataValue: Invalid value", t);
            const b = t.value;
            return d === "vec2f" ? void (new Float32Array(this.buffer, s, 2)[m] = b) : d === "vec3f" ? void (new Float32Array(this.buffer, s, 3)[m] = b) : d === "vec4f" ? void (new Float32Array(this.buffer, s, 4)[m] = b) : d === "vec2i" ? void (new Int32Array(this.buffer, s, 2)[m] = b) : d === "vec3i" ? void (new Int32Array(this.buffer, s, 3)[m] = b) : d === "vec4i" ? void (new Int32Array(this.buffer, s, 4)[m] = b) : d === "vec2u" ? void (new Uint32Array(this.buffer, s, 2)[m] = b) : d === "vec3u" ? void (new Uint32Array(this.buffer, s, 3)[m] = b) : d === "vec4u" ? void (new Uint32Array(this.buffer, s, 4)[m] = b) : void console.error(`SetDataValue: Type ${d} is not a struct`);
          }
        }
      }
      n = n.postfix;
    }
    this.setData(e, t, l, s, i);
  }
  setData(e, t, n, i, s) {
    const l = n.getTypeName();
    if (l !== "f32" && l !== "f16")
      if (l !== "i32" && l !== "atomic<i32>" && l !== "x32")
        if (l !== "u32" && l !== "atomic<u32>")
          if (l !== "bool")
            if (l !== "vec2f" && l !== "vec2h")
              if (l !== "vec3f" && l !== "vec3h")
                if (l !== "vec4f" && l !== "vec4h")
                  if (l !== "vec2i")
                    if (l !== "vec3i")
                      if (l !== "vec4i")
                        if (l !== "vec2u")
                          if (l !== "vec3u")
                            if (l !== "vec4u")
                              if (l !== "vec2b")
                                if (l !== "vec3b")
                                  if (l !== "vec4b")
                                    if (l !== "mat2x2f" && l !== "mat2x2h")
                                      if (l !== "mat2x3f" && l !== "mat2x3h")
                                        if (l !== "mat2x4f" && l !== "mat2x4h")
                                          if (l !== "mat3x2f" && l !== "mat3x2h")
                                            if (l !== "mat3x3f" && l !== "mat3x3h")
                                              if (l !== "mat3x4f" && l !== "mat3x4h")
                                                if (l !== "mat4x2f" && l !== "mat4x2h")
                                                  if (l !== "mat4x3f" && l !== "mat4x3h")
                                                    if (l !== "mat4x4f" && l !== "mat4x4h")
                                                      if (t instanceof ps) {
                                                        if (n === t.typeInfo)
                                                          return void new Uint8Array(this.buffer, i, t.buffer.byteLength).set(new Uint8Array(t.buffer));
                                                        console.error("SetDataValue: Type mismatch", l, t.typeInfo.getTypeName());
                                                      } else console.error(`SetData: Unknown type ${l}`);
                                                    else {
                                                      const o = new Float32Array(this.buffer, i, 16);
                                                      t instanceof tn ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2], o[3] = t.data[3], o[4] = t.data[4], o[5] = t.data[5], o[6] = t.data[6], o[7] = t.data[7], o[8] = t.data[8], o[9] = t.data[9], o[10] = t.data[10], o[11] = t.data[11], o[12] = t.data[12], o[13] = t.data[13], o[14] = t.data[14], o[15] = t.data[15]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[4] = t[4], o[5] = t[5], o[6] = t[6], o[7] = t[7], o[8] = t[8], o[9] = t[9], o[10] = t[10], o[11] = t[11], o[12] = t[12], o[13] = t[13], o[14] = t[14], o[15] = t[15]);
                                                    }
                                                  else {
                                                    const o = new Float32Array(this.buffer, i, 12);
                                                    t instanceof tn ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2], o[3] = t.data[3], o[4] = t.data[4], o[5] = t.data[5], o[6] = t.data[6], o[7] = t.data[7], o[8] = t.data[8], o[9] = t.data[9], o[10] = t.data[10], o[11] = t.data[11]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[4] = t[4], o[5] = t[5], o[6] = t[6], o[7] = t[7], o[8] = t[8], o[9] = t[9], o[10] = t[10], o[11] = t[11]);
                                                  }
                                                else {
                                                  const o = new Float32Array(this.buffer, i, 8);
                                                  t instanceof tn ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2], o[3] = t.data[3], o[4] = t.data[4], o[5] = t.data[5], o[6] = t.data[6], o[7] = t.data[7]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[4] = t[4], o[5] = t[5], o[6] = t[6], o[7] = t[7]);
                                                }
                                              else {
                                                const o = new Float32Array(this.buffer, i, 12);
                                                t instanceof tn ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2], o[3] = t.data[3], o[4] = t.data[4], o[5] = t.data[5], o[6] = t.data[6], o[7] = t.data[7], o[8] = t.data[8], o[9] = t.data[9], o[10] = t.data[10], o[11] = t.data[11]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[4] = t[4], o[5] = t[5], o[6] = t[6], o[7] = t[7], o[8] = t[8], o[9] = t[9], o[10] = t[10], o[11] = t[11]);
                                              }
                                            else {
                                              const o = new Float32Array(this.buffer, i, 9);
                                              t instanceof tn ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2], o[3] = t.data[3], o[4] = t.data[4], o[5] = t.data[5], o[6] = t.data[6], o[7] = t.data[7], o[8] = t.data[8]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[4] = t[4], o[5] = t[5], o[6] = t[6], o[7] = t[7], o[8] = t[8]);
                                            }
                                          else {
                                            const o = new Float32Array(this.buffer, i, 6);
                                            t instanceof tn ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2], o[3] = t.data[3], o[4] = t.data[4], o[5] = t.data[5]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[4] = t[4], o[5] = t[5]);
                                          }
                                        else {
                                          const o = new Float32Array(this.buffer, i, 8);
                                          t instanceof tn ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2], o[3] = t.data[3], o[4] = t.data[4], o[5] = t.data[5], o[6] = t.data[6], o[7] = t.data[7]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[4] = t[4], o[5] = t[5], o[6] = t[6], o[7] = t[7]);
                                        }
                                      else {
                                        const o = new Float32Array(this.buffer, i, 6);
                                        t instanceof tn ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2], o[3] = t.data[3], o[4] = t.data[4], o[5] = t.data[5]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[4] = t[4], o[5] = t[5]);
                                      }
                                    else {
                                      const o = new Float32Array(this.buffer, i, 4);
                                      t instanceof tn ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2], o[3] = t.data[3]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3]);
                                    }
                                  else {
                                    const o = new Uint32Array(this.buffer, i, 4);
                                    t instanceof Ne ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2], o[3] = t.data[3]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3]);
                                  }
                                else {
                                  const o = new Uint32Array(this.buffer, i, 3);
                                  t instanceof Ne ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2]);
                                }
                              else {
                                const o = new Uint32Array(this.buffer, i, 2);
                                t instanceof Ne ? (o[0] = t.data[0], o[1] = t.data[1]) : (o[0] = t[0], o[1] = t[1]);
                              }
                            else {
                              const o = new Uint32Array(this.buffer, i, 4);
                              t instanceof Ne ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2], o[3] = t.data[3]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3]);
                            }
                          else {
                            const o = new Uint32Array(this.buffer, i, 3);
                            t instanceof Ne ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2]);
                          }
                        else {
                          const o = new Uint32Array(this.buffer, i, 2);
                          t instanceof Ne ? (o[0] = t.data[0], o[1] = t.data[1]) : (o[0] = t[0], o[1] = t[1]);
                        }
                      else {
                        const o = new Int32Array(this.buffer, i, 4);
                        t instanceof Ne ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2], o[3] = t.data[3]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3]);
                      }
                    else {
                      const o = new Int32Array(this.buffer, i, 3);
                      t instanceof Ne ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2]);
                    }
                  else {
                    const o = new Int32Array(this.buffer, i, 2);
                    t instanceof Ne ? (o[0] = t.data[0], o[1] = t.data[1]) : (o[0] = t[0], o[1] = t[1]);
                  }
                else {
                  const o = new Float32Array(this.buffer, i, 4);
                  t instanceof Ne ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2], o[3] = t.data[3]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3]);
                }
              else {
                const o = new Float32Array(this.buffer, i, 3);
                t instanceof Ne ? (o[0] = t.data[0], o[1] = t.data[1], o[2] = t.data[2]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2]);
              }
            else {
              const o = new Float32Array(this.buffer, i, 2);
              t instanceof Ne ? (o[0] = t.data[0], o[1] = t.data[1]) : (o[0] = t[0], o[1] = t[1]);
            }
          else t instanceof ut && (new Int32Array(this.buffer, i, 1)[0] = t.value);
        else t instanceof ut && (new Uint32Array(this.buffer, i, 1)[0] = t.value);
      else t instanceof ut && (new Int32Array(this.buffer, i, 1)[0] = t.value);
    else t instanceof ut && (new Float32Array(this.buffer, i, 1)[0] = t.value);
  }
  getSubData(e, t, n) {
    var i, s, l;
    if (t === null) return this;
    let o = this.offset, d = this.typeInfo;
    for (; t; ) {
      if (t instanceof ip) {
        const b = t.index, A = b instanceof Bc ? e.evalExpression(b, n) : b;
        let M = 0;
        if (A instanceof ut ? M = A.value : typeof A == "number" ? M = A : console.error("GetDataValue: Invalid index type", b), d instanceof $h) o += M * d.stride, d = d.format;
        else {
          const E = d.getTypeName();
          E === "mat4x4" || E === "mat4x4f" || E === "mat4x4h" ? (o += 16 * M, d = e.getTypeInfo("vec4f")) : console.error(`getDataValue: Type ${d.getTypeName()} is not an array`);
        }
      } else {
        if (!(t instanceof $f)) return console.error("GetDataValue: Unknown postfix type", t), null;
        {
          const b = t.value;
          if (d instanceof Uh) {
            let A = !1;
            for (const M of d.members) if (M.name === b) {
              o += M.offset, d = M.type, A = !0;
              break;
            }
            if (!A) return console.error(`GetDataValue: Member ${b} not found`), null;
          } else if (d instanceof Fl) {
            const A = d.getTypeName();
            if (A === "vec2f" || A === "vec3f" || A === "vec4f" || A === "vec2i" || A === "vec3i" || A === "vec4i" || A === "vec2u" || A === "vec3u" || A === "vec4u" || A === "vec2b" || A === "vec3b" || A === "vec4b" || A === "vec2h" || A === "vec3h" || A === "vec4h" || A === "vec2" || A === "vec3" || A === "vec4") {
              if (b.length > 0 && b.length < 5) {
                let M = "f";
                const E = [];
                for (let k = 0; k < b.length; ++k) {
                  const U = b[k].toLowerCase();
                  let V = 0;
                  if (U === "x" || U === "r") V = 0;
                  else if (U === "y" || U === "g") V = 1;
                  else if (U === "z" || U === "b") V = 2;
                  else {
                    if (U !== "w" && U !== "a") return console.error(`Unknown member ${b}`), null;
                    V = 3;
                  }
                  if (b.length === 1) {
                    if (A.endsWith("f")) return this.buffer.byteLength < o + 4 * V + 4 ? (console.log("Insufficient buffer data"), null) : new ut(new Float32Array(this.buffer, o + 4 * V, 1), e.getTypeInfo("f32"), this);
                    if (A.endsWith("h")) return new ut(new Float32Array(this.buffer, o + 4 * V, 1), e.getTypeInfo("f16"), this);
                    if (A.endsWith("i")) return new ut(new Int32Array(this.buffer, o + 4 * V, 1), e.getTypeInfo("i32"), this);
                    if (A.endsWith("b")) return new ut(new Int32Array(this.buffer, o + 4 * V, 1), e.getTypeInfo("bool"), this);
                    if (A.endsWith("u")) return new ut(new Uint32Array(this.buffer, o + 4 * V, 1), e.getTypeInfo("i32"), this);
                  }
                  if (A === "vec2f") E.push(new Float32Array(this.buffer, o, 2)[V]);
                  else if (A === "vec3f") {
                    if (o + 12 >= this.buffer.byteLength) return console.log("Insufficient buffer data"), null;
                    const q = new Float32Array(this.buffer, o, 3);
                    E.push(q[V]);
                  } else if (A === "vec4f") E.push(new Float32Array(this.buffer, o, 4)[V]);
                  else if (A === "vec2i") M = "i", E.push(new Int32Array(this.buffer, o, 2)[V]);
                  else if (A === "vec3i") M = "i", E.push(new Int32Array(this.buffer, o, 3)[V]);
                  else if (A === "vec4i") M = "i", E.push(new Int32Array(this.buffer, o, 4)[V]);
                  else if (A === "vec2u") {
                    M = "u";
                    const q = new Uint32Array(this.buffer, o, 2);
                    E.push(q[V]);
                  } else A === "vec3u" ? (M = "u", E.push(new Uint32Array(this.buffer, o, 3)[V])) : A === "vec4u" && (M = "u", E.push(new Uint32Array(this.buffer, o, 4)[V]));
                }
                return E.length === 2 ? d = e.getTypeInfo(`vec2${M}`) : E.length === 3 ? d = e.getTypeInfo(`vec3${M}`) : E.length === 4 ? d = e.getTypeInfo(`vec4${M}`) : console.error(`GetDataValue: Invalid vector length ${E.length}`), new Ne(E, d, null);
              }
              return console.error(`GetDataValue: Unknown member ${b}`), null;
            }
            return console.error(`GetDataValue: Type ${A} is not a struct`), null;
          }
        }
      }
      t = t.postfix;
    }
    const m = d.getTypeName();
    return m === "f32" ? new ut(new Float32Array(this.buffer, o, 1), d, this) : m === "i32" ? new ut(new Int32Array(this.buffer, o, 1), d, this) : m === "u32" ? new ut(new Uint32Array(this.buffer, o, 1), d, this) : m === "vec2f" ? new Ne(new Float32Array(this.buffer, o, 2), d, this) : m === "vec3f" ? new Ne(new Float32Array(this.buffer, o, 3), d, this) : m === "vec4f" ? new Ne(new Float32Array(this.buffer, o, 4), d, this) : m === "vec2i" ? new Ne(new Int32Array(this.buffer, o, 2), d, this) : m === "vec3i" ? new Ne(new Int32Array(this.buffer, o, 3), d, this) : m === "vec4i" ? new Ne(new Int32Array(this.buffer, o, 4), d, this) : m === "vec2u" ? new Ne(new Uint32Array(this.buffer, o, 2), d, this) : m === "vec3u" ? new Ne(new Uint32Array(this.buffer, o, 3), d, this) : m === "vec4u" ? new Ne(new Uint32Array(this.buffer, o, 4), d, this) : d instanceof Vf && d.name === "atomic" ? ((i = d.format) === null || i === void 0 ? void 0 : i.name) === "u32" ? new ut(new Uint32Array(this.buffer, o, 1)[0], d.format, this) : ((s = d.format) === null || s === void 0 ? void 0 : s.name) === "i32" ? new ut(new Int32Array(this.buffer, o, 1)[0], d.format, this) : (console.error(`GetDataValue: Invalid atomic format ${(l = d.format) === null || l === void 0 ? void 0 : l.name}`), null) : new ps(this.buffer, d, o, this);
  }
  toString() {
    let e = "";
    if (this.typeInfo instanceof $h)
      if (this.typeInfo.format.name === "f32") {
        const t = new Float32Array(this.buffer, this.offset);
        e = `[${t[0]}`;
        for (let n = 1; n < t.length; ++n) e += `, ${t[n]}`;
      } else if (this.typeInfo.format.name === "i32") {
        const t = new Int32Array(this.buffer, this.offset);
        e = `[${t[0]}`;
        for (let n = 1; n < t.length; ++n) e += `, ${t[n]}`;
      } else if (this.typeInfo.format.name === "u32") {
        const t = new Uint32Array(this.buffer, this.offset);
        e = `[${t[0]}`;
        for (let n = 1; n < t.length; ++n) e += `, ${t[n]}`;
      } else if (this.typeInfo.format.name === "vec2f") {
        const t = new Float32Array(this.buffer, this.offset);
        e = `[${t[0]}, ${t[1]}]`;
        for (let n = 1; n < t.length / 2; ++n) e += `, [${t[2 * n]}, ${t[2 * n + 1]}]`;
      } else if (this.typeInfo.format.name === "vec3f") {
        const t = new Float32Array(this.buffer, this.offset);
        e = `[${t[0]}, ${t[1]}, ${t[2]}]`;
        for (let n = 4; n < t.length; n += 4) e += `, [${t[n]}, ${t[n + 1]}, ${t[n + 2]}]`;
      } else if (this.typeInfo.format.name === "vec4f") {
        const t = new Float32Array(this.buffer, this.offset);
        e = `[${t[0]}, ${t[1]}, ${t[2]}, ${t[3]}]`;
        for (let n = 4; n < t.length; n += 4) e += `, [${t[n]}, ${t[n + 1]}, ${t[n + 2]}, ${t[n + 3]}]`;
      } else e = "[...]";
    else this.typeInfo instanceof Uh ? e += "{...}" : e = "[...]";
    return e;
  }
}
class Zu extends zl {
  constructor(e, t, n, i) {
    super(t, null), this.data = e, this.descriptor = n, this.view = i;
  }
  clone() {
    return new Zu(this.data, this.typeInfo, this.descriptor, this.view);
  }
  get width() {
    var e, t;
    const n = this.descriptor.size;
    return n instanceof Array && n.length > 0 ? (e = n[0]) !== null && e !== void 0 ? e : 0 : n instanceof Object && (t = n.width) !== null && t !== void 0 ? t : 0;
  }
  get height() {
    var e, t;
    const n = this.descriptor.size;
    return n instanceof Array && n.length > 1 ? (e = n[1]) !== null && e !== void 0 ? e : 0 : n instanceof Object && (t = n.height) !== null && t !== void 0 ? t : 0;
  }
  get depthOrArrayLayers() {
    var e, t;
    const n = this.descriptor.size;
    return n instanceof Array && n.length > 2 ? (e = n[2]) !== null && e !== void 0 ? e : 0 : n instanceof Object && (t = n.depthOrArrayLayers) !== null && t !== void 0 ? t : 0;
  }
  get format() {
    var e;
    return this.descriptor && (e = this.descriptor.format) !== null && e !== void 0 ? e : "rgba8unorm";
  }
  get sampleCount() {
    var e;
    return this.descriptor && (e = this.descriptor.sampleCount) !== null && e !== void 0 ? e : 1;
  }
  get mipLevelCount() {
    var e;
    return this.descriptor && (e = this.descriptor.mipLevelCount) !== null && e !== void 0 ? e : 1;
  }
  get dimension() {
    var e;
    return this.descriptor && (e = this.descriptor.dimension) !== null && e !== void 0 ? e : "2d";
  }
  getMipLevelSize(e) {
    if (e >= this.mipLevelCount) return [0, 0, 0];
    const t = [this.width, this.height, this.depthOrArrayLayers];
    for (let n = 0; n < t.length; ++n) t[n] = Math.max(1, t[n] >> e);
    return t;
  }
  get texelByteSize() {
    const e = this.format, t = gb[e];
    return t ? t.isDepthStencil ? 4 : t.bytesPerBlock : 0;
  }
  get bytesPerRow() {
    return this.width * this.texelByteSize;
  }
  get isDepthStencil() {
    const e = this.format, t = gb[e];
    return !!t && t.isDepthStencil;
  }
  getGpuSize() {
    const e = this.format, t = gb[e], n = this.width;
    if (!e || n <= 0 || !t) return -1;
    const i = this.height, s = this.depthOrArrayLayers, l = this.dimension;
    return n / t.blockWidth * (l === "1d" ? 1 : i / t.blockHeight) * t.bytesPerBlock * s;
  }
  getPixel(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    const s = this.texelByteSize, l = this.bytesPerRow, o = this.height, d = this.data[i];
    return _k(new Uint8Array(d), e, t, n, i, o, l, s, this.format);
  }
  setPixel(e, t, n, i, s) {
    const l = this.texelByteSize, o = this.bytesPerRow, d = this.height, m = this.data[i];
    (function(b, A, M, E, k, U, V, q, Y, re) {
      const Z = E * (V >>= k) * (U >>= k) + M * V + A * q;
      switch (Y) {
        case "r8unorm":
          return void ii(b, Z, "8unorm", 1, re);
        case "r8snorm":
          return void ii(b, Z, "8snorm", 1, re);
        case "r8uint":
          return void ii(b, Z, "8uint", 1, re);
        case "r8sint":
          return void ii(b, Z, "8sint", 1, re);
        case "rg8unorm":
          return void ii(b, Z, "8unorm", 2, re);
        case "rg8snorm":
          return void ii(b, Z, "8snorm", 2, re);
        case "rg8uint":
          return void ii(b, Z, "8uint", 2, re);
        case "rg8sint":
          return void ii(b, Z, "8sint", 2, re);
        case "rgba8unorm-srgb":
        case "rgba8unorm":
        case "bgra8unorm-srgb":
        case "bgra8unorm":
          return void ii(b, Z, "8unorm", 4, re);
        case "rgba8snorm":
          return void ii(b, Z, "8snorm", 4, re);
        case "rgba8uint":
          return void ii(b, Z, "8uint", 4, re);
        case "rgba8sint":
          return void ii(b, Z, "8sint", 4, re);
        case "r16uint":
          return void ii(b, Z, "16uint", 1, re);
        case "r16sint":
          return void ii(b, Z, "16sint", 1, re);
        case "r16float":
          return void ii(b, Z, "16float", 1, re);
        case "rg16uint":
          return void ii(b, Z, "16uint", 2, re);
        case "rg16sint":
          return void ii(b, Z, "16sint", 2, re);
        case "rg16float":
          return void ii(b, Z, "16float", 2, re);
        case "rgba16uint":
          return void ii(b, Z, "16uint", 4, re);
        case "rgba16sint":
          return void ii(b, Z, "16sint", 4, re);
        case "rgba16float":
          return void ii(b, Z, "16float", 4, re);
        case "r32uint":
          return void ii(b, Z, "32uint", 1, re);
        case "r32sint":
          return void ii(b, Z, "32sint", 1, re);
        case "depth16unorm":
        case "depth24plus":
        case "depth24plus-stencil8":
        case "depth32float":
        case "depth32float-stencil8":
        case "r32float":
          return void ii(b, Z, "32float", 1, re);
        case "rg32uint":
          return void ii(b, Z, "32uint", 2, re);
        case "rg32sint":
          return void ii(b, Z, "32sint", 2, re);
        case "rg32float":
          return void ii(b, Z, "32float", 2, re);
        case "rgba32uint":
          return void ii(b, Z, "32uint", 4, re);
        case "rgba32sint":
          return void ii(b, Z, "32sint", 4, re);
        case "rgba32float":
          return void ii(b, Z, "32float", 4, re);
        case "rg11b10ufloat":
          console.error("TODO: rg11b10ufloat not supported for writing");
      }
    })(new Uint8Array(m), e, t, n, i, d, o, l, this.format, s);
  }
}
((r) => {
  r[r.token = 0] = "token", r[r.keyword = 1] = "keyword", r[r.reserved = 2] = "reserved";
})(lt || (lt = {}));
let ct = class {
  constructor(e, t, n) {
    this.name = e, this.type = t, this.rule = n;
  }
  toString() {
    return this.name;
  }
};
class Ce {
}
Et = Ce, Ce.none = new ct("", lt.reserved, ""), Ce.eof = new ct("EOF", lt.token, ""), Ce.reserved = {
  asm: new ct("asm", lt.reserved, "asm"),
  bf16: new ct("bf16", lt.reserved, "bf16"),
  do: new ct("do", lt.reserved, "do"),
  enum: new ct("enum", lt.reserved, "enum"),
  f16: new ct("f16", lt.reserved, "f16"),
  f64: new ct("f64", lt.reserved, "f64"),
  handle: new ct("handle", lt.reserved, "handle"),
  i8: new ct("i8", lt.reserved, "i8"),
  i16: new ct("i16", lt.reserved, "i16"),
  i64: new ct("i64", lt.reserved, "i64"),
  mat: new ct("mat", lt.reserved, "mat"),
  premerge: new ct("premerge", lt.reserved, "premerge"),
  regardless: new ct("regardless", lt.reserved, "regardless"),
  typedef: new ct("typedef", lt.reserved, "typedef"),
  u8: new ct("u8", lt.reserved, "u8"),
  u16: new ct("u16", lt.reserved, "u16"),
  u64: new ct("u64", lt.reserved, "u64"),
  unless: new ct("unless", lt.reserved, "unless"),
  using: new ct("using", lt.reserved, "using"),
  vec: new ct("vec", lt.reserved, "vec"),
  void: new ct("void", lt.reserved, "void")
}, Ce.keywords = {
  array: new ct("array", lt.keyword, "array"),
  atomic: new ct("atomic", lt.keyword, "atomic"),
  bool: new ct("bool", lt.keyword, "bool"),
  f32: new ct("f32", lt.keyword, "f32"),
  i32: new ct("i32", lt.keyword, "i32"),
  mat2x2: new ct("mat2x2", lt.keyword, "mat2x2"),
  mat2x3: new ct("mat2x3", lt.keyword, "mat2x3"),
  mat2x4: new ct("mat2x4", lt.keyword, "mat2x4"),
  mat3x2: new ct("mat3x2", lt.keyword, "mat3x2"),
  mat3x3: new ct("mat3x3", lt.keyword, "mat3x3"),
  mat3x4: new ct("mat3x4", lt.keyword, "mat3x4"),
  mat4x2: new ct("mat4x2", lt.keyword, "mat4x2"),
  mat4x3: new ct("mat4x3", lt.keyword, "mat4x3"),
  mat4x4: new ct("mat4x4", lt.keyword, "mat4x4"),
  ptr: new ct("ptr", lt.keyword, "ptr"),
  sampler: new ct("sampler", lt.keyword, "sampler"),
  sampler_comparison: new ct("sampler_comparison", lt.keyword, "sampler_comparison"),
  struct: new ct("struct", lt.keyword, "struct"),
  texture_1d: new ct("texture_1d", lt.keyword, "texture_1d"),
  texture_2d: new ct("texture_2d", lt.keyword, "texture_2d"),
  texture_2d_array: new ct("texture_2d_array", lt.keyword, "texture_2d_array"),
  texture_3d: new ct("texture_3d", lt.keyword, "texture_3d"),
  texture_cube: new ct("texture_cube", lt.keyword, "texture_cube"),
  texture_cube_array: new ct("texture_cube_array", lt.keyword, "texture_cube_array"),
  texture_multisampled_2d: new ct("texture_multisampled_2d", lt.keyword, "texture_multisampled_2d"),
  texture_storage_1d: new ct("texture_storage_1d", lt.keyword, "texture_storage_1d"),
  texture_storage_2d: new ct("texture_storage_2d", lt.keyword, "texture_storage_2d"),
  texture_storage_2d_array: new ct("texture_storage_2d_array", lt.keyword, "texture_storage_2d_array"),
  texture_storage_3d: new ct("texture_storage_3d", lt.keyword, "texture_storage_3d"),
  texture_depth_2d: new ct("texture_depth_2d", lt.keyword, "texture_depth_2d"),
  texture_depth_2d_array: new ct("texture_depth_2d_array", lt.keyword, "texture_depth_2d_array"),
  texture_depth_cube: new ct("texture_depth_cube", lt.keyword, "texture_depth_cube"),
  texture_depth_cube_array: new ct("texture_depth_cube_array", lt.keyword, "texture_depth_cube_array"),
  texture_depth_multisampled_2d: new ct("texture_depth_multisampled_2d", lt.keyword, "texture_depth_multisampled_2d"),
  texture_external: new ct("texture_external", lt.keyword, "texture_external"),
  u32: new ct("u32", lt.keyword, "u32"),
  vec2: new ct("vec2", lt.keyword, "vec2"),
  vec3: new ct("vec3", lt.keyword, "vec3"),
  vec4: new ct("vec4", lt.keyword, "vec4"),
  bitcast: new ct("bitcast", lt.keyword, "bitcast"),
  block: new ct("block", lt.keyword, "block"),
  break: new ct("break", lt.keyword, "break"),
  case: new ct("case", lt.keyword, "case"),
  continue: new ct("continue", lt.keyword, "continue"),
  continuing: new ct("continuing", lt.keyword, "continuing"),
  default: new ct("default", lt.keyword, "default"),
  diagnostic: new ct("diagnostic", lt.keyword, "diagnostic"),
  discard: new ct("discard", lt.keyword, "discard"),
  else: new ct("else", lt.keyword, "else"),
  enable: new ct("enable", lt.keyword, "enable"),
  fallthrough: new ct("fallthrough", lt.keyword, "fallthrough"),
  false: new ct("false", lt.keyword, "false"),
  fn: new ct("fn", lt.keyword, "fn"),
  for: new ct("for", lt.keyword, "for"),
  function: new ct("function", lt.keyword, "function"),
  if: new ct("if", lt.keyword, "if"),
  let: new ct("let", lt.keyword, "let"),
  const: new ct("const", lt.keyword, "const"),
  loop: new ct("loop", lt.keyword, "loop"),
  while: new ct("while", lt.keyword, "while"),
  private: new ct("private", lt.keyword, "private"),
  read: new ct("read", lt.keyword, "read"),
  read_write: new ct("read_write", lt.keyword, "read_write"),
  return: new ct("return", lt.keyword, "return"),
  requires: new ct("requires", lt.keyword, "requires"),
  storage: new ct("storage", lt.keyword, "storage"),
  switch: new ct("switch", lt.keyword, "switch"),
  true: new ct("true", lt.keyword, "true"),
  alias: new ct("alias", lt.keyword, "alias"),
  type: new ct("type", lt.keyword, "type"),
  uniform: new ct("uniform", lt.keyword, "uniform"),
  var: new ct("var", lt.keyword, "var"),
  override: new ct("override", lt.keyword, "override"),
  workgroup: new ct("workgroup", lt.keyword, "workgroup"),
  write: new ct("write", lt.keyword, "write"),
  r8unorm: new ct("r8unorm", lt.keyword, "r8unorm"),
  r8snorm: new ct("r8snorm", lt.keyword, "r8snorm"),
  r8uint: new ct("r8uint", lt.keyword, "r8uint"),
  r8sint: new ct("r8sint", lt.keyword, "r8sint"),
  r16uint: new ct("r16uint", lt.keyword, "r16uint"),
  r16sint: new ct("r16sint", lt.keyword, "r16sint"),
  r16float: new ct("r16float", lt.keyword, "r16float"),
  rg8unorm: new ct("rg8unorm", lt.keyword, "rg8unorm"),
  rg8snorm: new ct("rg8snorm", lt.keyword, "rg8snorm"),
  rg8uint: new ct("rg8uint", lt.keyword, "rg8uint"),
  rg8sint: new ct("rg8sint", lt.keyword, "rg8sint"),
  r32uint: new ct("r32uint", lt.keyword, "r32uint"),
  r32sint: new ct("r32sint", lt.keyword, "r32sint"),
  r32float: new ct("r32float", lt.keyword, "r32float"),
  rg16uint: new ct("rg16uint", lt.keyword, "rg16uint"),
  rg16sint: new ct("rg16sint", lt.keyword, "rg16sint"),
  rg16float: new ct("rg16float", lt.keyword, "rg16float"),
  rgba8unorm: new ct("rgba8unorm", lt.keyword, "rgba8unorm"),
  rgba8unorm_srgb: new ct("rgba8unorm_srgb", lt.keyword, "rgba8unorm_srgb"),
  rgba8snorm: new ct("rgba8snorm", lt.keyword, "rgba8snorm"),
  rgba8uint: new ct("rgba8uint", lt.keyword, "rgba8uint"),
  rgba8sint: new ct("rgba8sint", lt.keyword, "rgba8sint"),
  bgra8unorm: new ct("bgra8unorm", lt.keyword, "bgra8unorm"),
  bgra8unorm_srgb: new ct("bgra8unorm_srgb", lt.keyword, "bgra8unorm_srgb"),
  rgb10a2unorm: new ct("rgb10a2unorm", lt.keyword, "rgb10a2unorm"),
  rg11b10float: new ct("rg11b10float", lt.keyword, "rg11b10float"),
  rg32uint: new ct("rg32uint", lt.keyword, "rg32uint"),
  rg32sint: new ct("rg32sint", lt.keyword, "rg32sint"),
  rg32float: new ct("rg32float", lt.keyword, "rg32float"),
  rgba16uint: new ct("rgba16uint", lt.keyword, "rgba16uint"),
  rgba16sint: new ct("rgba16sint", lt.keyword, "rgba16sint"),
  rgba16float: new ct("rgba16float", lt.keyword, "rgba16float"),
  rgba32uint: new ct("rgba32uint", lt.keyword, "rgba32uint"),
  rgba32sint: new ct("rgba32sint", lt.keyword, "rgba32sint"),
  rgba32float: new ct("rgba32float", lt.keyword, "rgba32float"),
  static_assert: new ct("static_assert", lt.keyword, "static_assert")
}, Ce.tokens = {
  decimal_float_literal: new ct("decimal_float_literal", lt.token, /((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?[fh]?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+[fh]?)|(-?[0-9]+[fh])/),
  hex_float_literal: new ct("hex_float_literal", lt.token, /-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+[fh]?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+[fh]?))/),
  int_literal: new ct("int_literal", lt.token, /-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),
  uint_literal: new ct("uint_literal", lt.token, /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),
  name: new ct("name", lt.token, /([_\p{XID_Start}][\p{XID_Continue}]+)|([\p{XID_Start}])/u),
  ident: new ct("ident", lt.token, /[_a-zA-Z][0-9a-zA-Z_]*/),
  and: new ct("and", lt.token, "&"),
  and_and: new ct("and_and", lt.token, "&&"),
  arrow: new ct("arrow ", lt.token, "->"),
  attr: new ct("attr", lt.token, "@"),
  forward_slash: new ct("forward_slash", lt.token, "/"),
  bang: new ct("bang", lt.token, "!"),
  bracket_left: new ct("bracket_left", lt.token, "["),
  bracket_right: new ct("bracket_right", lt.token, "]"),
  brace_left: new ct("brace_left", lt.token, "{"),
  brace_right: new ct("brace_right", lt.token, "}"),
  colon: new ct("colon", lt.token, ":"),
  comma: new ct("comma", lt.token, ","),
  equal: new ct("equal", lt.token, "="),
  equal_equal: new ct("equal_equal", lt.token, "=="),
  not_equal: new ct("not_equal", lt.token, "!="),
  greater_than: new ct("greater_than", lt.token, ">"),
  greater_than_equal: new ct("greater_than_equal", lt.token, ">="),
  shift_right: new ct("shift_right", lt.token, ">>"),
  less_than: new ct("less_than", lt.token, "<"),
  less_than_equal: new ct("less_than_equal", lt.token, "<="),
  shift_left: new ct("shift_left", lt.token, "<<"),
  modulo: new ct("modulo", lt.token, "%"),
  minus: new ct("minus", lt.token, "-"),
  minus_minus: new ct("minus_minus", lt.token, "--"),
  period: new ct("period", lt.token, "."),
  plus: new ct("plus", lt.token, "+"),
  plus_plus: new ct("plus_plus", lt.token, "++"),
  or: new ct("or", lt.token, "|"),
  or_or: new ct("or_or", lt.token, "||"),
  paren_left: new ct("paren_left", lt.token, "("),
  paren_right: new ct("paren_right", lt.token, ")"),
  semicolon: new ct("semicolon", lt.token, ";"),
  star: new ct("star", lt.token, "*"),
  tilde: new ct("tilde", lt.token, "~"),
  underscore: new ct("underscore", lt.token, "_"),
  xor: new ct("xor", lt.token, "^"),
  plus_equal: new ct("plus_equal", lt.token, "+="),
  minus_equal: new ct("minus_equal", lt.token, "-="),
  times_equal: new ct("times_equal", lt.token, "*="),
  division_equal: new ct("division_equal", lt.token, "/="),
  modulo_equal: new ct("modulo_equal", lt.token, "%="),
  and_equal: new ct("and_equal", lt.token, "&="),
  or_equal: new ct("or_equal", lt.token, "|="),
  xor_equal: new ct("xor_equal", lt.token, "^="),
  shift_right_equal: new ct("shift_right_equal", lt.token, ">>="),
  shift_left_equal: new ct("shift_left_equal", lt.token, "<<=")
}, Ce.simpleTokens = {
  "@": Et.tokens.attr,
  "{": Et.tokens.brace_left,
  "}": Et.tokens.brace_right,
  ":": Et.tokens.colon,
  ",": Et.tokens.comma,
  "(": Et.tokens.paren_left,
  ")": Et.tokens.paren_right,
  ";": Et.tokens.semicolon
}, Ce.literalTokens = {
  "&": Et.tokens.and,
  "&&": Et.tokens.and_and,
  "->": Et.tokens.arrow,
  "/": Et.tokens.forward_slash,
  "!": Et.tokens.bang,
  "[": Et.tokens.bracket_left,
  "]": Et.tokens.bracket_right,
  "=": Et.tokens.equal,
  "==": Et.tokens.equal_equal,
  "!=": Et.tokens.not_equal,
  ">": Et.tokens.greater_than,
  ">=": Et.tokens.greater_than_equal,
  ">>": Et.tokens.shift_right,
  "<": Et.tokens.less_than,
  "<=": Et.tokens.less_than_equal,
  "<<": Et.tokens.shift_left,
  "%": Et.tokens.modulo,
  "-": Et.tokens.minus,
  "--": Et.tokens.minus_minus,
  ".": Et.tokens.period,
  "+": Et.tokens.plus,
  "++": Et.tokens.plus_plus,
  "|": Et.tokens.or,
  "||": Et.tokens.or_or,
  "*": Et.tokens.star,
  "~": Et.tokens.tilde,
  _: Et.tokens.underscore,
  "^": Et.tokens.xor,
  "+=": Et.tokens.plus_equal,
  "-=": Et.tokens.minus_equal,
  "*=": Et.tokens.times_equal,
  "/=": Et.tokens.division_equal,
  "%=": Et.tokens.modulo_equal,
  "&=": Et.tokens.and_equal,
  "|=": Et.tokens.or_equal,
  "^=": Et.tokens.xor_equal,
  ">>=": Et.tokens.shift_right_equal,
  "<<=": Et.tokens.shift_left_equal
}, Ce.regexTokens = {
  decimal_float_literal: Et.tokens.decimal_float_literal,
  hex_float_literal: Et.tokens.hex_float_literal,
  int_literal: Et.tokens.int_literal,
  uint_literal: Et.tokens.uint_literal,
  ident: Et.tokens.ident
}, Ce.storage_class = [Et.keywords.function, Et.keywords.private, Et.keywords.workgroup, Et.keywords.uniform, Et.keywords.storage], Ce.access_mode = [Et.keywords.read, Et.keywords.write, Et.keywords.read_write], Ce.sampler_type = [Et.keywords.sampler, Et.keywords.sampler_comparison], Ce.sampled_texture_type = [Et.keywords.texture_1d, Et.keywords.texture_2d, Et.keywords.texture_2d_array, Et.keywords.texture_3d, Et.keywords.texture_cube, Et.keywords.texture_cube_array], Ce.multisampled_texture_type = [Et.keywords.texture_multisampled_2d], Ce.storage_texture_type = [Et.keywords.texture_storage_1d, Et.keywords.texture_storage_2d, Et.keywords.texture_storage_2d_array, Et.keywords.texture_storage_3d], Ce.depth_texture_type = [Et.keywords.texture_depth_2d, Et.keywords.texture_depth_2d_array, Et.keywords.texture_depth_cube, Et.keywords.texture_depth_cube_array, Et.keywords.texture_depth_multisampled_2d], Ce.texture_external_type = [Et.keywords.texture_external], Ce.any_texture_type = [...Et.sampled_texture_type, ...Et.multisampled_texture_type, ...Et.storage_texture_type, ...Et.depth_texture_type, ...Et.texture_external_type], Ce.texel_format = [Et.keywords.r8unorm, Et.keywords.r8snorm, Et.keywords.r8uint, Et.keywords.r8sint, Et.keywords.r16uint, Et.keywords.r16sint, Et.keywords.r16float, Et.keywords.rg8unorm, Et.keywords.rg8snorm, Et.keywords.rg8uint, Et.keywords.rg8sint, Et.keywords.r32uint, Et.keywords.r32sint, Et.keywords.r32float, Et.keywords.rg16uint, Et.keywords.rg16sint, Et.keywords.rg16float, Et.keywords.rgba8unorm, Et.keywords.rgba8unorm_srgb, Et.keywords.rgba8snorm, Et.keywords.rgba8uint, Et.keywords.rgba8sint, Et.keywords.bgra8unorm, Et.keywords.bgra8unorm_srgb, Et.keywords.rgb10a2unorm, Et.keywords.rg11b10float, Et.keywords.rg32uint, Et.keywords.rg32sint, Et.keywords.rg32float, Et.keywords.rgba16uint, Et.keywords.rgba16sint, Et.keywords.rgba16float, Et.keywords.rgba32uint, Et.keywords.rgba32sint, Et.keywords.rgba32float], Ce.const_literal = [Et.tokens.int_literal, Et.tokens.uint_literal, Et.tokens.decimal_float_literal, Et.tokens.hex_float_literal, Et.keywords.true, Et.keywords.false], Ce.literal_or_ident = [Et.tokens.ident, Et.tokens.int_literal, Et.tokens.uint_literal, Et.tokens.decimal_float_literal, Et.tokens.hex_float_literal, Et.tokens.name], Ce.element_count_expression = [Et.tokens.int_literal, Et.tokens.uint_literal, Et.tokens.ident], Ce.template_types = [Et.keywords.vec2, Et.keywords.vec3, Et.keywords.vec4, Et.keywords.mat2x2, Et.keywords.mat2x3, Et.keywords.mat2x4, Et.keywords.mat3x2, Et.keywords.mat3x3, Et.keywords.mat3x4, Et.keywords.mat4x2, Et.keywords.mat4x3, Et.keywords.mat4x4, Et.keywords.atomic, Et.keywords.bitcast, ...Et.any_texture_type], Ce.attribute_name = [Et.tokens.ident, Et.keywords.block, Et.keywords.diagnostic], Ce.assignment_operators = [Et.tokens.equal, Et.tokens.plus_equal, Et.tokens.minus_equal, Et.tokens.times_equal, Et.tokens.division_equal, Et.tokens.modulo_equal, Et.tokens.and_equal, Et.tokens.or_equal, Et.tokens.xor_equal, Et.tokens.shift_right_equal, Et.tokens.shift_left_equal], Ce.increment_operators = [Et.tokens.plus_plus, Et.tokens.minus_minus];
class cT {
  constructor(e, t, n, i, s) {
    this.type = e, this.lexeme = t, this.line = n, this.start = i, this.end = s;
  }
  toString() {
    return this.lexeme;
  }
  isTemplateType() {
    return Ce.template_types.indexOf(this.type) != -1;
  }
  isArrayType() {
    return this.type == Ce.keywords.array;
  }
  isArrayOrTemplateType() {
    return this.isArrayType() || this.isTemplateType();
  }
}
class Tk {
  constructor(e) {
    this._tokens = [], this._start = 0, this._current = 0, this._line = 1, this._source = e ?? "";
  }
  scanTokens() {
    for (; !this._isAtEnd(); ) if (this._start = this._current, !this.scanToken()) throw `Invalid syntax at line ${this._line}`;
    return this._tokens.push(new cT(Ce.eof, "", this._line, this._current, this._current)), this._tokens;
  }
  scanToken() {
    let e = this._advance();
    if (e == `
`) return this._line++, !0;
    if (this._isWhitespace(e)) return !0;
    if (e == "/") {
      if (this._peekAhead() == "/") {
        for (; e != `
`; ) {
          if (this._isAtEnd()) return !0;
          e = this._advance();
        }
        return this._line++, !0;
      }
      if (this._peekAhead() == "*") {
        this._advance();
        let l = 1;
        for (; l > 0; ) {
          if (this._isAtEnd()) return !0;
          if (e = this._advance(), e == `
`) this._line++;
          else if (e == "*") {
            if (this._peekAhead() == "/" && (this._advance(), l--, l == 0)) return !0;
          } else e == "/" && this._peekAhead() == "*" && (this._advance(), l++);
        }
        return !0;
      }
    }
    const t = Ce.simpleTokens[e];
    if (t) return this._addToken(t), !0;
    let n = Ce.none;
    const i = this._isAlpha(e), s = e === "_";
    if (this._isAlphaNumeric(e)) {
      let l = this._peekAhead();
      for (; this._isAlphaNumeric(l); ) e += this._advance(), l = this._peekAhead();
    }
    if (i) {
      const l = Ce.keywords[e];
      if (l) return this._addToken(l), !0;
    }
    if (i || s) return this._addToken(Ce.tokens.ident), !0;
    for (; ; ) {
      let l = this._findType(e);
      const o = this._peekAhead();
      if (e == "-" && this._tokens.length > 0) {
        if (o == "=") return this._current++, e += o, this._addToken(Ce.tokens.minus_equal), !0;
        if (o == "-") return this._current++, e += o, this._addToken(Ce.tokens.minus_minus), !0;
        const d = this._tokens.length - 1;
        if ((Ce.literal_or_ident.indexOf(this._tokens[d].type) != -1 || this._tokens[d].type == Ce.tokens.paren_right) && o != ">") return this._addToken(l), !0;
      }
      if (e == ">" && (o == ">" || o == "=")) {
        let d = !1, m = this._tokens.length - 1;
        for (let b = 0; b < 5 && m >= 0 && Ce.assignment_operators.indexOf(this._tokens[m].type) === -1; ++b, --m) if (this._tokens[m].type === Ce.tokens.less_than) {
          m > 0 && this._tokens[m - 1].isArrayOrTemplateType() && (d = !0);
          break;
        }
        if (d) return this._addToken(l), !0;
      }
      if (l === Ce.none) {
        let d = e, m = 0;
        const b = 2;
        for (let A = 0; A < b; ++A) if (d += this._peekAhead(A), l = this._findType(d), l !== Ce.none) {
          m = A;
          break;
        }
        if (l === Ce.none) return n !== Ce.none && (this._current--, this._addToken(n), !0);
        e = d, this._current += m + 1;
      }
      if (n = l, this._isAtEnd()) break;
      e += this._advance();
    }
    return n !== Ce.none && (this._addToken(n), !0);
  }
  _findType(e) {
    for (const n in Ce.regexTokens) {
      const i = Ce.regexTokens[n];
      if (this._match(e, i.rule)) return i;
    }
    return Ce.literalTokens[e] || Ce.none;
  }
  _match(e, t) {
    const n = t.exec(e);
    return n && n.index == 0 && n[0] == e;
  }
  _isAtEnd() {
    return this._current >= this._source.length;
  }
  _isAlpha(e) {
    return !this._isNumeric(e) && !this._isWhitespace(e) && e !== "_" && e !== "." && e !== "(" && e !== ")" && e !== "[" && e !== "]" && e !== "{" && e !== "}" && e !== "," && e !== ";" && e !== ":" && e !== "=" && e !== "!" && e !== "<" && e !== ">" && e !== "+" && e !== "-" && e !== "*" && e !== "/" && e !== "%" && e !== "&" && e !== "|" && e !== "^" && e !== "~" && e !== "@" && e !== "#" && e !== "?" && e !== "'" && e !== "`" && e !== '"' && e !== "\\" && e !== `
` && e !== "\r" && e !== "	" && e !== "\0";
  }
  _isNumeric(e) {
    return e >= "0" && e <= "9";
  }
  _isAlphaNumeric(e) {
    return this._isAlpha(e) || this._isNumeric(e) || e === "_";
  }
  _isWhitespace(e) {
    return e == " " || e == "	" || e == "\r";
  }
  _advance() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = this._source[this._current];
    return e = e || 0, e++, this._current += e, t;
  }
  _peekAhead() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return e = e || 0, this._current + e >= this._source.length ? "\0" : this._source[this._current + e];
  }
  _addToken(e) {
    const t = this._source.substring(this._start, this._current);
    this._tokens.push(new cT(e, t, this._line, this._start, this._current));
  }
}
function Ar(r) {
  return Array.isArray(r) || (r == null ? void 0 : r.buffer) instanceof ArrayBuffer;
}
const X_ = new Float32Array(1), Sk = new Uint32Array(X_.buffer), Ek = new Uint32Array(X_.buffer), Z_ = new Int32Array(1), Ck = new Float32Array(Z_.buffer), Ik = new Uint32Array(Z_.buffer), Y_ = new Uint32Array(1), Mk = new Float32Array(Y_.buffer), Pk = new Int32Array(Y_.buffer);
function uT(r, e, t) {
  if (e === t) return r;
  if (e === "f32") {
    if (t === "i32" || t === "x32") return X_[0] = r, Sk[0];
    if (t === "u32") return X_[0] = r, Ek[0];
  } else if (e === "i32" || e === "x32") {
    if (t === "f32") return Z_[0] = r, Ck[0];
    if (t === "u32") return Z_[0] = r, Ik[0];
  } else if (e === "u32") {
    if (t === "f32") return Y_[0] = r, Mk[0];
    if (t === "i32" || t === "x32") return Y_[0] = r, Pk[0];
  }
  return console.error(`Unsupported cast from ${e} to ${t}`), r;
}
class Rk {
  constructor(e) {
    this.resources = null, this.inUse = !1, this.info = null, this.node = e;
  }
}
class Im {
  constructor(e, t) {
    this.align = e, this.size = t;
  }
}
class gu {
  constructor() {
    this.uniforms = [], this.storage = [], this.textures = [], this.samplers = [], this.aliases = [], this.overrides = [], this.structs = [], this.entry = new pk(), this.functions = [], this._types = /* @__PURE__ */ new Map(), this._functions = /* @__PURE__ */ new Map();
  }
  _isStorageTexture(e) {
    return e.name == "texture_storage_1d" || e.name == "texture_storage_2d" || e.name == "texture_storage_2d_array" || e.name == "texture_storage_3d";
  }
  updateAST(e) {
    for (const t of e) t instanceof Pg && this._functions.set(t.name, new Rk(t));
    for (const t of e) if (t instanceof Xu) {
      const n = this.getTypeInfo(t, null);
      n instanceof Uh && this.structs.push(n);
    }
    for (const t of e) if (t instanceof A2) this.aliases.push(this._getAliasInfo(t));
    else if (t instanceof x2) {
      const n = t, i = this._getAttributeNum(n.attributes, "id", 0), s = n.type != null ? this.getTypeInfo(n.type, n.attributes) : null;
      this.overrides.push(new hk(n.name, s, n.attributes, i));
    } else if (this._isUniformVar(t)) {
      const n = t, i = this._getAttributeNum(n.attributes, "group", 0), s = this._getAttributeNum(n.attributes, "binding", 0), l = this.getTypeInfo(n.type, n.attributes), o = new Cm(n.name, l, i, s, n.attributes, Nh.Uniform, n.access);
      o.access || (o.access = "read"), this.uniforms.push(o);
    } else if (this._isStorageVar(t)) {
      const n = t, i = this._getAttributeNum(n.attributes, "group", 0), s = this._getAttributeNum(n.attributes, "binding", 0), l = this.getTypeInfo(n.type, n.attributes), o = this._isStorageTexture(l), d = new Cm(n.name, l, i, s, n.attributes, o ? Nh.StorageTexture : Nh.Storage, n.access);
      d.access || (d.access = "read"), this.storage.push(d);
    } else if (this._isTextureVar(t)) {
      const n = t, i = this._getAttributeNum(n.attributes, "group", 0), s = this._getAttributeNum(n.attributes, "binding", 0), l = this.getTypeInfo(n.type, n.attributes), o = this._isStorageTexture(l), d = new Cm(n.name, l, i, s, n.attributes, o ? Nh.StorageTexture : Nh.Texture, n.access);
      d.access || (d.access = "read"), o ? this.storage.push(d) : this.textures.push(d);
    } else if (this._isSamplerVar(t)) {
      const n = t, i = this._getAttributeNum(n.attributes, "group", 0), s = this._getAttributeNum(n.attributes, "binding", 0), l = this.getTypeInfo(n.type, n.attributes), o = new Cm(n.name, l, i, s, n.attributes, Nh.Sampler, n.access);
      this.samplers.push(o);
    }
    for (const t of e) if (t instanceof Pg) {
      const n = this._getAttribute(t, "vertex"), i = this._getAttribute(t, "fragment"), s = this._getAttribute(t, "compute"), l = n || i || s, o = new dk(t.name, l == null ? void 0 : l.name, t.attributes);
      o.attributes = t.attributes, o.startLine = t.startLine, o.endLine = t.endLine, this.functions.push(o), this._functions.get(t.name).info = o, l && (this._functions.get(t.name).inUse = !0, o.inUse = !0, o.resources = this._findResources(t, !!l), o.inputs = this._getInputs(t.args), o.outputs = this._getOutputs(t.returnType), this.entry[l.name].push(o)), o.arguments = t.args.map((d) => new fk(d.name, this.getTypeInfo(d.type, d.attributes), d.attributes)), o.returnType = t.returnType ? this.getTypeInfo(t.returnType, t.attributes) : null;
    }
    for (const t of this._functions.values()) t.info && (t.info.inUse = t.inUse, this._addCalls(t.node, t.info.calls));
    for (const t of this._functions.values()) t.node.search((n) => {
      var i, s, l;
      if (n instanceof YC) {
        if (n.value) if (Ar(n.value)) for (const o of n.value) for (const d of this.overrides) o === d.name && ((i = t.info) === null || i === void 0 || i.overrides.push(d));
        else for (const o of this.overrides) n.value === o.name && ((s = t.info) === null || s === void 0 || s.overrides.push(o));
      } else if (n instanceof gl) for (const o of this.overrides) n.name === o.name && ((l = t.info) === null || l === void 0 || l.overrides.push(o));
    });
    for (const t of this.uniforms) this._markStructsInUse(t.type);
    for (const t of this.storage) this._markStructsInUse(t.type);
  }
  getStructInfo(e) {
    for (const t of this.structs) if (t.name == e) return t;
    return null;
  }
  getOverrideInfo(e) {
    for (const t of this.overrides) if (t.name == e) return t;
    return null;
  }
  _markStructsInUse(e) {
    if (e) if (e.isStruct) {
      if (e.inUse = !0, e.members) for (const t of e.members) this._markStructsInUse(t.type);
    } else if (e.isArray) this._markStructsInUse(e.format);
    else if (e.isTemplate) e.format && this._markStructsInUse(e.format);
    else {
      const t = this._getAlias(e.name);
      t && this._markStructsInUse(t);
    }
  }
  _addCalls(e, t) {
    var n;
    for (const i of e.calls) {
      const s = (n = this._functions.get(i.name)) === null || n === void 0 ? void 0 : n.info;
      s && t.add(s);
    }
  }
  findResource(e, t, n) {
    if (n) {
      for (const i of this.entry.compute) if (i.name === n) {
        for (const s of i.resources) if (s.group == e && s.binding == t) return s;
      }
      for (const i of this.entry.vertex) if (i.name === n) {
        for (const s of i.resources) if (s.group == e && s.binding == t) return s;
      }
      for (const i of this.entry.fragment) if (i.name === n) {
        for (const s of i.resources) if (s.group == e && s.binding == t) return s;
      }
    }
    for (const i of this.uniforms) if (i.group == e && i.binding == t) return i;
    for (const i of this.storage) if (i.group == e && i.binding == t) return i;
    for (const i of this.textures) if (i.group == e && i.binding == t) return i;
    for (const i of this.samplers) if (i.group == e && i.binding == t) return i;
    return null;
  }
  _findResource(e) {
    for (const t of this.uniforms) if (t.name == e) return t;
    for (const t of this.storage) if (t.name == e) return t;
    for (const t of this.textures) if (t.name == e) return t;
    for (const t of this.samplers) if (t.name == e) return t;
    return null;
  }
  _markStructsFromAST(e) {
    const t = this.getTypeInfo(e, null);
    this._markStructsInUse(t);
  }
  _findResources(e, t) {
    const n = [], i = this, s = [];
    return e.search((l) => {
      if (l instanceof H_) s.push({});
      else if (l instanceof W_) s.pop();
      else if (l instanceof Yu) {
        const o = l;
        t && o.type !== null && this._markStructsFromAST(o.type), s.length > 0 && (s[s.length - 1][o.name] = o);
      } else if (l instanceof hu) {
        const o = l;
        t && o.type !== null && this._markStructsFromAST(o.type);
      } else if (l instanceof yg) {
        const o = l;
        t && o.type !== null && this._markStructsFromAST(o.type), s.length > 0 && (s[s.length - 1][o.name] = o);
      } else if (l instanceof gl) {
        const o = l;
        if (s.length > 0 && s[s.length - 1][o.name])
          return;
        const d = i._findResource(o.name);
        d && n.push(d);
      } else if (l instanceof T2) {
        const o = l, d = i._functions.get(o.name);
        d && (t && (d.inUse = !0), e.calls.add(d.node), d.resources === null && (d.resources = i._findResources(d.node, t)), n.push(...d.resources));
      } else if (l instanceof w2) {
        const o = l, d = i._functions.get(o.name);
        d && (t && (d.inUse = !0), e.calls.add(d.node), d.resources === null && (d.resources = i._findResources(d.node, t)), n.push(...d.resources));
      }
    }), [...new Map(n.map((l) => [l.name, l])).values()];
  }
  getBindGroups() {
    const e = [];
    function t(n, i) {
      n >= e.length && (e.length = n + 1), e[n] === void 0 && (e[n] = []), i >= e[n].length && (e[n].length = i + 1);
    }
    for (const n of this.uniforms)
      t(n.group, n.binding), e[n.group][n.binding] = n;
    for (const n of this.storage)
      t(n.group, n.binding), e[n.group][n.binding] = n;
    for (const n of this.textures)
      t(n.group, n.binding), e[n.group][n.binding] = n;
    for (const n of this.samplers)
      t(n.group, n.binding), e[n.group][n.binding] = n;
    return e;
  }
  _getOutputs(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
    if (t === void 0 && (t = []), e instanceof Xu) this._getStructOutputs(e, t);
    else {
      const n = this._getOutputInfo(e);
      n !== null && t.push(n);
    }
    return t;
  }
  _getStructOutputs(e, t) {
    for (const n of e.members) if (n.type instanceof Xu) this._getStructOutputs(n.type, t);
    else {
      const i = this._getAttribute(n, "location") || this._getAttribute(n, "builtin");
      if (i !== null) {
        const s = this.getTypeInfo(n.type, n.type.attributes), l = this._parseInt(i.value), o = new iT(n.name, s, i.name, l);
        t.push(o);
      }
    }
  }
  _getOutputInfo(e) {
    const t = this._getAttribute(e, "location") || this._getAttribute(e, "builtin");
    if (t !== null) {
      const n = this.getTypeInfo(e, e.attributes), i = this._parseInt(t.value);
      return new iT("", n, t.name, i);
    }
    return null;
  }
  _getInputs(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
    t === void 0 && (t = []);
    for (const n of e) if (n.type instanceof Xu) this._getStructInputs(n.type, t);
    else {
      const i = this._getInputInfo(n);
      i !== null && t.push(i);
    }
    return t;
  }
  _getStructInputs(e, t) {
    for (const n of e.members) if (n.type instanceof Xu) this._getStructInputs(n.type, t);
    else {
      const i = this._getInputInfo(n);
      i !== null && t.push(i);
    }
  }
  _getInputInfo(e) {
    const t = this._getAttribute(e, "location") || this._getAttribute(e, "builtin");
    if (t !== null) {
      const n = this._getAttribute(e, "interpolation"), i = this.getTypeInfo(e.type, e.attributes), s = this._parseInt(t.value), l = new uk(e.name, i, t.name, s);
      return n !== null && (l.interpolation = this._parseString(n.value)), l;
    }
    return null;
  }
  _parseString(e) {
    return e instanceof Array && (e = e[0]), e;
  }
  _parseInt(e) {
    e instanceof Array && (e = e[0]);
    const t = parseInt(e);
    return isNaN(t) ? e : t;
  }
  _getAlias(e) {
    for (const t of this.aliases) if (t.name == e) return t.type;
    return null;
  }
  _getAliasInfo(e) {
    return new ck(e.name, this.getTypeInfo(e.type, null));
  }
  getTypeInfoByName(e) {
    for (const t of this.structs) if (t.name == e) return t;
    for (const t of this.aliases) if (t.name == e) return t.type;
    return null;
  }
  getTypeInfo(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (this._types.has(e)) return this._types.get(e);
    if (e instanceof u_) {
      const i = e.type ? this.getTypeInfo(e.type, e.attributes) : null, s = new Z1(e.name, i, t);
      return this._types.set(e, s), this._updateTypeInfo(s), s;
    }
    if (e instanceof bg) {
      const i = e, s = i.format ? this.getTypeInfo(i.format, i.attributes) : null, l = new $h(i.name, t);
      return l.format = s, l.count = i.count, this._types.set(e, l), this._updateTypeInfo(l), l;
    }
    if (e instanceof Xu) {
      const i = e, s = new Uh(i.name, t);
      s.startLine = i.startLine, s.endLine = i.endLine;
      for (const l of i.members) {
        const o = this.getTypeInfo(l.type, l.attributes);
        s.members.push(new nT(l.name, o, l.attributes));
      }
      return this._types.set(e, s), this._updateTypeInfo(s), s;
    }
    if (e instanceof lg) {
      const i = e, s = i.format instanceof Xt, l = i.format ? s ? this.getTypeInfo(i.format, null) : new Fl(i.format, null) : null, o = new Vf(i.name, l, t, i.access);
      return this._types.set(e, o), this._updateTypeInfo(o), o;
    }
    if (e instanceof pt) {
      const i = e, s = i.format ? this.getTypeInfo(i.format, null) : null, l = new Vf(i.name, s, t, i.access);
      return this._types.set(e, l), this._updateTypeInfo(l), l;
    }
    const n = new Fl(e.name, t);
    return this._types.set(e, n), this._updateTypeInfo(n), n;
  }
  _updateTypeInfo(e) {
    var t, n, i;
    const s = this._getTypeSize(e);
    if (e.size = (t = s == null ? void 0 : s.size) !== null && t !== void 0 ? t : 0, e instanceof $h && e.format) {
      const l = this._getTypeSize(e.format);
      e.stride = Math.max((n = l == null ? void 0 : l.size) !== null && n !== void 0 ? n : 0, (i = l == null ? void 0 : l.align) !== null && i !== void 0 ? i : 0), this._updateTypeInfo(e.format);
    }
    e instanceof Z1 && this._updateTypeInfo(e.format), e instanceof Uh && this._updateStructInfo(e);
  }
  _updateStructInfo(e) {
    var t;
    let n = 0, i = 0, s = 0, l = 0;
    for (let o = 0, d = e.members.length; o < d; ++o) {
      const m = e.members[o], b = this._getTypeSize(m);
      if (!b) continue;
      (t = this._getAlias(m.type.name)) !== null && t !== void 0 || m.type;
      const A = b.align, M = b.size;
      n = this._roundUp(A, n + i), i = M, s = n, l = Math.max(l, A), m.offset = n, m.size = M, this._updateTypeInfo(m.type);
    }
    e.size = this._roundUp(l, s + i), e.align = l;
  }
  _getTypeSize(e) {
    var t, n;
    if (e == null) return null;
    const i = this._getAttributeNum(e.attributes, "size", 0), s = this._getAttributeNum(e.attributes, "align", 0);
    if (e instanceof nT && (e = e.type), e instanceof Fl) {
      const l = this._getAlias(e.name);
      l !== null && (e = l);
    }
    {
      const l = gu._typeInfo[e.name];
      if (l !== void 0) {
        const o = ((t = e.format) === null || t === void 0 ? void 0 : t.name) === "f16" ? 2 : 1;
        return new Im(Math.max(s, l.align / o), Math.max(i, l.size / o));
      }
    }
    {
      const l = gu._typeInfo[e.name.substring(0, e.name.length - 1)];
      if (l) {
        const o = e.name[e.name.length - 1] === "h" ? 2 : 1;
        return new Im(Math.max(s, l.align / o), Math.max(i, l.size / o));
      }
    }
    if (e instanceof $h) {
      let l = e, o = 8, d = 8;
      const m = this._getTypeSize(l.format);
      return m !== null && (d = m.size, o = m.align), d = l.count * this._getAttributeNum((n = e == null ? void 0 : e.attributes) !== null && n !== void 0 ? n : null, "stride", this._roundUp(o, d)), i && (d = i), new Im(Math.max(s, o), Math.max(i, d));
    }
    if (e instanceof Uh) {
      let l = 0, o = 0, d = 0, m = 0, b = 0;
      for (const A of e.members) {
        const M = this._getTypeSize(A.type);
        M !== null && (l = Math.max(M.align, l), d = this._roundUp(M.align, d + m), m = M.size, b = d);
      }
      return o = this._roundUp(l, b + m), new Im(Math.max(s, l), Math.max(i, o));
    }
    return null;
  }
  _isUniformVar(e) {
    return e instanceof Yu && e.storage == "uniform";
  }
  _isStorageVar(e) {
    return e instanceof Yu && e.storage == "storage";
  }
  _isTextureVar(e) {
    return e instanceof Yu && e.type !== null && gu._textureTypes.indexOf(e.type.name) != -1;
  }
  _isSamplerVar(e) {
    return e instanceof Yu && e.type !== null && gu._samplerTypes.indexOf(e.type.name) != -1;
  }
  _getAttribute(e, t) {
    const n = e;
    if (!n || !n.attributes) return null;
    const i = n.attributes;
    for (let s of i) if (s.name == t) return s;
    return null;
  }
  _getAttributeNum(e, t, n) {
    if (e === null) return n;
    for (let i of e) if (i.name == t) {
      let s = i !== null && i.value !== null ? i.value : n;
      return s instanceof Array && (s = s[0]), typeof s == "number" ? s : typeof s == "string" ? parseInt(s) : n;
    }
    return n;
  }
  _roundUp(e, t) {
    return Math.ceil(t / e) * e;
  }
}
gu._typeInfo = {
  f16: {
    align: 2,
    size: 2
  },
  i32: {
    align: 4,
    size: 4
  },
  u32: {
    align: 4,
    size: 4
  },
  f32: {
    align: 4,
    size: 4
  },
  atomic: {
    align: 4,
    size: 4
  },
  vec2: {
    align: 8,
    size: 8
  },
  vec3: {
    align: 16,
    size: 12
  },
  vec4: {
    align: 16,
    size: 16
  },
  mat2x2: {
    align: 8,
    size: 16
  },
  mat3x2: {
    align: 8,
    size: 24
  },
  mat4x2: {
    align: 8,
    size: 32
  },
  mat2x3: {
    align: 16,
    size: 32
  },
  mat3x3: {
    align: 16,
    size: 48
  },
  mat4x3: {
    align: 16,
    size: 64
  },
  mat2x4: {
    align: 16,
    size: 32
  },
  mat3x4: {
    align: 16,
    size: 48
  },
  mat4x4: {
    align: 16,
    size: 64
  }
}, gu._textureTypes = Ce.any_texture_type.map((r) => r.name), gu._samplerTypes = Ce.sampler_type.map((r) => r.name);
let S2 = 0;
class E2 {
  constructor(e, t, n) {
    this.id = S2++, this.name = e, this.value = t, this.node = n;
  }
  clone() {
    return new E2(this.name, this.value, this.node);
  }
}
class C2 {
  constructor(e) {
    this.id = S2++, this.name = e.name, this.node = e;
  }
  clone() {
    return new C2(this.node);
  }
}
class I2 {
  constructor(e) {
    this.parent = null, this.variables = /* @__PURE__ */ new Map(), this.functions = /* @__PURE__ */ new Map(), this.currentFunctionName = "", this.id = S2++, e && (this.parent = e, this.currentFunctionName = e.currentFunctionName);
  }
  getVariable(e) {
    var t;
    return this.variables.has(e) ? (t = this.variables.get(e)) !== null && t !== void 0 ? t : null : this.parent ? this.parent.getVariable(e) : null;
  }
  getFunction(e) {
    var t;
    return this.functions.has(e) ? (t = this.functions.get(e)) !== null && t !== void 0 ? t : null : this.parent ? this.parent.getFunction(e) : null;
  }
  createVariable(e, t, n) {
    this.variables.set(e, new E2(e, t, n ?? null));
  }
  setVariable(e, t, n) {
    const i = this.getVariable(e);
    i !== null ? i.value = t : this.createVariable(e, t, n);
  }
  getVariableValue(e) {
    var t;
    const n = this.getVariable(e);
    return (t = n == null ? void 0 : n.value) !== null && t !== void 0 ? t : null;
  }
  clone() {
    return new I2(this);
  }
}
class Bk {
  evalExpression(e, t) {
    return null;
  }
  getTypeInfo(e) {
    return null;
  }
  getVariableName(e, t) {
    return "";
  }
}
class Lk {
  constructor(e) {
    this.exec = e;
  }
  getTypeInfo(e) {
    return this.exec.getTypeInfo(e);
  }
  All(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    let i = !0;
    if (n instanceof Ne) return n.data.forEach((s) => {
      s || (i = !1);
    }), new ut(i ? 1 : 0, this.getTypeInfo("bool"));
    throw new Error(`All() expects a vector argument. Line ${e.line}`);
  }
  Any(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) {
      const i = n.data.some((s) => s);
      return new ut(i ? 1 : 0, this.getTypeInfo("bool"));
    }
    throw new Error(`Any() expects a vector argument. Line ${e.line}`);
  }
  Select(e, t) {
    const n = this.exec.evalExpression(e.args[2], t);
    if (!(n instanceof ut)) throw new Error(`Select() expects a bool condition. Line ${e.line}`);
    return n.value ? this.exec.evalExpression(e.args[1], t) : this.exec.evalExpression(e.args[0], t);
  }
  ArrayLength(e, t) {
    let n = e.args[0];
    n instanceof Us && (n = n.right);
    const i = this.exec.evalExpression(n, t);
    if (i instanceof ps && i.typeInfo.size === 0) {
      const s = i.typeInfo, l = i.buffer.byteLength / s.stride;
      return new ut(l, this.getTypeInfo("u32"));
    }
    return new ut(i.typeInfo.size, this.getTypeInfo("u32"));
  }
  Abs(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => Math.abs(s)), n.typeInfo);
    const i = n;
    return new ut(Math.abs(i.value), i.typeInfo);
  }
  Acos(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => Math.acos(s)), n.typeInfo);
    const i = n;
    return new ut(Math.acos(i.value), n.typeInfo);
  }
  Acosh(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => Math.acosh(s)), n.typeInfo);
    const i = n;
    return new ut(Math.acosh(i.value), n.typeInfo);
  }
  Asin(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => Math.asin(s)), n.typeInfo);
    const i = n;
    return new ut(Math.asin(i.value), n.typeInfo);
  }
  Asinh(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => Math.asinh(s)), n.typeInfo);
    const i = n;
    return new ut(Math.asinh(i.value), n.typeInfo);
  }
  Atan(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => Math.atan(s)), n.typeInfo);
    const i = n;
    return new ut(Math.atan(i.value), n.typeInfo);
  }
  Atanh(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => Math.atanh(s)), n.typeInfo);
    const i = n;
    return new ut(Math.atanh(i.value), n.typeInfo);
  }
  Atan2(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    if (n instanceof Ne && i instanceof Ne) return new Ne(n.data.map((o, d) => Math.atan2(o, i.data[d])), n.typeInfo);
    const s = n, l = i;
    return new ut(Math.atan2(s.value, l.value), n.typeInfo);
  }
  Ceil(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => Math.ceil(s)), n.typeInfo);
    const i = n;
    return new ut(Math.ceil(i.value), n.typeInfo);
  }
  _clamp(e, t, n) {
    return Math.min(Math.max(e, t), n);
  }
  Clamp(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t);
    if (n instanceof Ne && i instanceof Ne && s instanceof Ne) return new Ne(n.data.map((m, b) => this._clamp(m, i.data[b], s.data[b])), n.typeInfo);
    const l = n, o = i, d = s;
    return new ut(this._clamp(l.value, o.value, d.value), n.typeInfo);
  }
  Cos(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => Math.cos(s)), n.typeInfo);
    const i = n;
    return new ut(Math.cos(i.value), n.typeInfo);
  }
  Cosh(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => Math.cosh(s)), n.typeInfo);
    const i = n;
    return new ut(Math.cos(i.value), n.typeInfo);
  }
  CountLeadingZeros(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => Math.clz32(s)), n.typeInfo);
    const i = n;
    return new ut(Math.clz32(i.value), n.typeInfo);
  }
  _countOneBits(e) {
    let t = 0;
    for (; e !== 0; ) 1 & e && t++, e >>= 1;
    return t;
  }
  CountOneBits(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => this._countOneBits(s)), n.typeInfo);
    const i = n;
    return new ut(this._countOneBits(i.value), n.typeInfo);
  }
  _countTrailingZeros(e) {
    if (e === 0) return 32;
    let t = 0;
    for (; !(1 & e); ) e >>= 1, t++;
    return t;
  }
  CountTrailingZeros(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => this._countTrailingZeros(s)), n.typeInfo);
    const i = n;
    return new ut(this._countTrailingZeros(i.value), n.typeInfo);
  }
  Cross(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    if (n instanceof Ne && i instanceof Ne) {
      if (n.data.length !== 3 || i.data.length !== 3) return console.error(`Cross() expects 3D vectors. Line ${e.line}`), null;
      const s = n.data, l = i.data;
      return new Ne([s[1] * l[2] - l[1] * s[2], s[2] * l[0] - l[2] * s[0], s[0] * l[1] - l[0] * s[1]], n.typeInfo);
    }
    return console.error(`Cross() expects vector arguments. Line ${e.line}`), null;
  }
  Degrees(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = 180 / Math.PI;
    return n instanceof Ne ? new Ne(n.data.map((s) => s * i), n.typeInfo) : new ut(n.value * i, this.getTypeInfo("f32"));
  }
  Determinant(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof tn) {
      const i = n.data, s = n.typeInfo.getTypeName(), l = s.endsWith("h") ? this.getTypeInfo("f16") : this.getTypeInfo("f32");
      if (s === "mat2x2" || s === "mat2x2f" || s === "mat2x2h") return new ut(i[0] * i[3] - i[1] * i[2], l);
      if (s === "mat2x3" || s === "mat2x3f" || s === "mat2x3h") return new ut(i[0] * (i[4] * i[8] - i[5] * i[7]) - i[1] * (i[3] * i[8] - i[5] * i[6]) + i[2] * (i[3] * i[7] - i[4] * i[6]), l);
      if (s === "mat2x4" || s === "mat2x4f" || s === "mat2x4h") console.error(`TODO: Determinant for ${s}`);
      else if (s === "mat3x2" || s === "mat3x2f" || s === "mat3x2h") console.error(`TODO: Determinant for ${s}`);
      else {
        if (s === "mat3x3" || s === "mat3x3f" || s === "mat3x3h") return new ut(i[0] * (i[4] * i[8] - i[5] * i[7]) - i[1] * (i[3] * i[8] - i[5] * i[6]) + i[2] * (i[3] * i[7] - i[4] * i[6]), l);
        s === "mat3x4" || s === "mat3x4f" || s === "mat3x4h" || s === "mat4x2" || s === "mat4x2f" || s === "mat4x2h" || s === "mat4x3" || s === "mat4x3f" || s === "mat4x3h" ? console.error(`TODO: Determinant for ${s}`) : s !== "mat4x4" && s !== "mat4x4f" && s !== "mat4x4h" || console.error(`TODO: Determinant for ${s}`);
      }
    }
    return console.error(`Determinant expects a matrix argument. Line ${e.line}`), null;
  }
  Distance(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    if (n instanceof Ne && i instanceof Ne) {
      let o = 0;
      for (let d = 0; d < n.data.length; ++d) o += (n.data[d] - i.data[d]) * (n.data[d] - i.data[d]);
      return new ut(Math.sqrt(o), this.getTypeInfo("f32"));
    }
    const s = n, l = i;
    return new ut(Math.abs(s.value - l.value), n.typeInfo);
  }
  _dot(e, t) {
    let n = 0;
    for (let i = 0; i < e.length; ++i) n += t[i] * e[i];
    return n;
  }
  Dot(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    return n instanceof Ne && i instanceof Ne ? new ut(this._dot(n.data, i.data), this.getTypeInfo("f32")) : (console.error(`Dot() expects vector arguments. Line ${e.line}`), null);
  }
  Dot4U8Packed(e, t) {
    return console.error(`TODO: dot4U8Packed. Line ${e.line}`), null;
  }
  Dot4I8Packed(e, t) {
    return console.error(`TODO: dot4I8Packed. Line ${e.line}`), null;
  }
  Exp(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => Math.exp(s)), n.typeInfo);
    const i = n;
    return new ut(Math.exp(i.value), n.typeInfo);
  }
  Exp2(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => Math.pow(2, s)), n.typeInfo);
    const i = n;
    return new ut(Math.pow(2, i.value), n.typeInfo);
  }
  ExtractBits(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t);
    if (i.typeInfo.name !== "u32" && i.typeInfo.name !== "x32") return console.error(`ExtractBits() expects an i32 offset argument. Line ${e.line}`), null;
    if (s.typeInfo.name !== "u32" && s.typeInfo.name !== "x32") return console.error(`ExtractBits() expects an i32 count argument. Line ${e.line}`), null;
    const l = i.value, o = s.value;
    if (n instanceof Ne) return new Ne(n.data.map((m) => m >> l & (1 << o) - 1), n.typeInfo);
    if (n.typeInfo.name !== "i32" && n.typeInfo.name !== "x32") return console.error(`ExtractBits() expects an i32 argument. Line ${e.line}`), null;
    const d = n.value;
    return new ut(d >> l & (1 << o) - 1, this.getTypeInfo("i32"));
  }
  FaceForward(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t);
    if (n instanceof Ne && i instanceof Ne && s instanceof Ne) {
      const l = this._dot(i.data, s.data);
      return new Ne(l < 0 ? Array.from(n.data) : n.data.map((o) => -o), n.typeInfo);
    }
    return console.error(`FaceForward() expects vector arguments. Line ${e.line}`), null;
  }
  _firstLeadingBit(e) {
    return e === 0 ? -1 : 31 - Math.clz32(e);
  }
  FirstLeadingBit(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => this._firstLeadingBit(s)), n.typeInfo);
    const i = n;
    return new ut(this._firstLeadingBit(i.value), n.typeInfo);
  }
  _firstTrailingBit(e) {
    return e === 0 ? -1 : Math.log2(e & -e);
  }
  FirstTrailingBit(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => this._firstTrailingBit(s)), n.typeInfo);
    const i = n;
    return new ut(this._firstTrailingBit(i.value), n.typeInfo);
  }
  Floor(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => Math.floor(s)), n.typeInfo);
    const i = n;
    return new ut(Math.floor(i.value), n.typeInfo);
  }
  Fma(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t);
    if (n instanceof Ne && i instanceof Ne && s instanceof Ne) return n.data.length !== i.data.length || n.data.length !== s.data.length ? (console.error(`Fma() expects vectors of the same length. Line ${e.line}`), null) : new Ne(n.data.map((m, b) => m * i.data[b] + s.data[b]), n.typeInfo);
    const l = n, o = i, d = s;
    return new ut(l.value * o.value + d.value, l.typeInfo);
  }
  Fract(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => s - Math.floor(s)), n.typeInfo);
    const i = n;
    return new ut(i.value - Math.floor(i.value), n.typeInfo);
  }
  Frexp(e, t) {
    return console.error(`TODO: frexp. Line ${e.line}`), null;
  }
  InsertBits(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t), l = this.exec.evalExpression(e.args[3], t);
    if (s.typeInfo.name !== "u32" && s.typeInfo.name !== "x32") return console.error(`InsertBits() expects an i32 offset argument. Line ${e.line}`), null;
    const o = s.value, d = (1 << l.value) - 1 << o, m = ~d;
    if (n instanceof Ne && i instanceof Ne) return new Ne(n.data.map((M, E) => M & m | i.data[E] << o & d), n.typeInfo);
    const b = n.value, A = i.value;
    return new ut(b & m | A << o & d, n.typeInfo);
  }
  InverseSqrt(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => 1 / Math.sqrt(s)), n.typeInfo);
    const i = n;
    return new ut(1 / Math.sqrt(i.value), n.typeInfo);
  }
  Ldexp(e, t) {
    return console.error(`TODO: ldexp. Line ${e.line}`), null;
  }
  Length(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) {
      let s = 0;
      return n.data.forEach((l) => {
        s += l * l;
      }), new ut(Math.sqrt(s), this.getTypeInfo("f32"));
    }
    const i = n;
    return new ut(Math.abs(i.value), n.typeInfo);
  }
  Log(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => Math.log(s)), n.typeInfo);
    const i = n;
    return new ut(Math.log(i.value), n.typeInfo);
  }
  Log2(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => Math.log2(s)), n.typeInfo);
    const i = n;
    return new ut(Math.log2(i.value), n.typeInfo);
  }
  Max(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    if (n instanceof Ne && i instanceof Ne) return new Ne(n.data.map((o, d) => Math.max(o, i.data[d])), n.typeInfo);
    const s = n, l = i;
    return new ut(Math.max(s.value, l.value), n.typeInfo);
  }
  Min(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    if (n instanceof Ne && i instanceof Ne) return new Ne(n.data.map((o, d) => Math.min(o, i.data[d])), n.typeInfo);
    const s = n, l = i;
    return new ut(Math.min(s.value, l.value), n.typeInfo);
  }
  Mix(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t);
    if (n instanceof Ne && i instanceof Ne && s instanceof Ne) return new Ne(n.data.map((d, m) => n.data[m] * (1 - s.data[m]) + i.data[m] * s.data[m]), n.typeInfo);
    const l = i, o = s;
    return new ut(n.value * (1 - o.value) + l.value * o.value, n.typeInfo);
  }
  Modf(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    if (n instanceof Ne && i instanceof Ne) return new Ne(n.data.map((l, o) => l % i.data[o]), n.typeInfo);
    const s = i;
    return new ut(n.value % s.value, n.typeInfo);
  }
  Normalize(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) {
      const i = this.Length(e, t).value;
      return new Ne(n.data.map((s) => s / i), n.typeInfo);
    }
    return console.error(`Normalize() expects a vector argument. Line ${e.line}`), null;
  }
  Pow(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    if (n instanceof Ne && i instanceof Ne) return new Ne(n.data.map((o, d) => Math.pow(o, i.data[d])), n.typeInfo);
    const s = n, l = i;
    return new ut(Math.pow(s.value, l.value), n.typeInfo);
  }
  QuantizeToF16(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    return n instanceof Ne ? new Ne(n.data.map((i) => i), n.typeInfo) : new ut(n.value, n.typeInfo);
  }
  Radians(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    return n instanceof Ne ? new Ne(n.data.map((i) => i * Math.PI / 180), n.typeInfo) : new ut(n.value * Math.PI / 180, this.getTypeInfo("f32"));
  }
  Reflect(e, t) {
    let n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    if (n instanceof Ne && i instanceof Ne) {
      const s = this._dot(n.data, i.data);
      return new Ne(n.data.map((l, o) => l - 2 * s * i.data[o]), n.typeInfo);
    }
    return console.error(`Reflect() expects vector arguments. Line ${e.line}`), null;
  }
  Refract(e, t) {
    let n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t);
    if (n instanceof Ne && i instanceof Ne && s instanceof ut) {
      const l = this._dot(i.data, n.data);
      return new Ne(n.data.map((o, d) => {
        const m = 1 - s.value * s.value * (1 - l * l);
        if (m < 0) return 0;
        const b = Math.sqrt(m);
        return s.value * o - (s.value * l + b) * i.data[d];
      }), n.typeInfo);
    }
    return console.error(`Refract() expects vector arguments and a scalar argument. Line ${e.line}`), null;
  }
  ReverseBits(e, t) {
    return console.error(`TODO: reverseBits. Line ${e.line}`), null;
  }
  Round(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => Math.round(s)), n.typeInfo);
    const i = n;
    return new ut(Math.round(i.value), n.typeInfo);
  }
  Saturate(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => Math.min(Math.max(s, 0), 1)), n.typeInfo);
    const i = n;
    return new ut(Math.min(Math.max(i.value, 0), 1), n.typeInfo);
  }
  Sign(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => Math.sign(s)), n.typeInfo);
    const i = n;
    return new ut(Math.sign(i.value), n.typeInfo);
  }
  Sin(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => Math.sin(s)), n.typeInfo);
    const i = n;
    return new ut(Math.sin(i.value), n.typeInfo);
  }
  Sinh(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => Math.sinh(s)), n.typeInfo);
    const i = n;
    return new ut(Math.sinh(i.value), n.typeInfo);
  }
  _smoothstep(e, t, n) {
    const i = Math.min(Math.max((n - e) / (t - e), 0), 1);
    return i * i * (3 - 2 * i);
  }
  SmoothStep(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t);
    if (s instanceof Ne && n instanceof Ne && i instanceof Ne) return new Ne(s.data.map((m, b) => this._smoothstep(n.data[b], i.data[b], m)), s.typeInfo);
    const l = n, o = i, d = s;
    return new ut(this._smoothstep(l.value, o.value, d.value), s.typeInfo);
  }
  Sqrt(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => Math.sqrt(s)), n.typeInfo);
    const i = n;
    return new ut(Math.sqrt(i.value), n.typeInfo);
  }
  Step(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    if (i instanceof Ne && n instanceof Ne) return new Ne(i.data.map((l, o) => l < n.data[o] ? 0 : 1), i.typeInfo);
    const s = n;
    return new ut(i.value < s.value ? 0 : 1, s.typeInfo);
  }
  Tan(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => Math.tan(s)), n.typeInfo);
    const i = n;
    return new ut(Math.tan(i.value), n.typeInfo);
  }
  Tanh(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => Math.tanh(s)), n.typeInfo);
    const i = n;
    return new ut(Math.tanh(i.value), n.typeInfo);
  }
  _getTransposeType(e) {
    const t = e.getTypeName();
    return t === "mat2x2f" || t === "mat2x2h" ? e : t === "mat2x3f" ? this.getTypeInfo("mat3x2f") : t === "mat2x3h" ? this.getTypeInfo("mat3x2h") : t === "mat2x4f" ? this.getTypeInfo("mat4x2f") : t === "mat2x4h" ? this.getTypeInfo("mat4x2h") : t === "mat3x2f" ? this.getTypeInfo("mat2x3f") : t === "mat3x2h" ? this.getTypeInfo("mat2x3h") : t === "mat3x3f" || t === "mat3x3h" ? e : t === "mat3x4f" ? this.getTypeInfo("mat4x3f") : t === "mat3x4h" ? this.getTypeInfo("mat4x3h") : t === "mat4x2f" ? this.getTypeInfo("mat2x4f") : t === "mat4x2h" ? this.getTypeInfo("mat2x4h") : t === "mat4x3f" ? this.getTypeInfo("mat3x4f") : t === "mat4x3h" ? this.getTypeInfo("mat3x4h") : (t === "mat4x4f" || t === "mat4x4h" || console.error(`Invalid matrix type ${t}`), e);
  }
  Transpose(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (!(n instanceof tn)) return console.error(`Transpose() expects a matrix argument. Line ${e.line}`), null;
    const i = this._getTransposeType(n.typeInfo);
    if (n.typeInfo.name === "mat2x2" || n.typeInfo.name === "mat2x2f" || n.typeInfo.name === "mat2x2h") {
      const s = n.data;
      return new tn([s[0], s[2], s[1], s[3]], i);
    }
    if (n.typeInfo.name === "mat2x3" || n.typeInfo.name === "mat2x3f" || n.typeInfo.name === "mat2x3h") {
      const s = n.data;
      return new tn([s[0], s[3], s[6], s[1], s[4], s[7]], i);
    }
    if (n.typeInfo.name === "mat2x4" || n.typeInfo.name === "mat2x4f" || n.typeInfo.name === "mat2x4h") {
      const s = n.data;
      return new tn([s[0], s[4], s[8], s[12], s[1], s[5], s[9], s[13]], i);
    }
    if (n.typeInfo.name === "mat3x2" || n.typeInfo.name === "mat3x2f" || n.typeInfo.name === "mat3x2h") {
      const s = n.data;
      return new tn([s[0], s[3], s[1], s[4], s[2], s[5]], i);
    }
    if (n.typeInfo.name === "mat3x3" || n.typeInfo.name === "mat3x3f" || n.typeInfo.name === "mat3x3h") {
      const s = n.data;
      return new tn([s[0], s[3], s[6], s[1], s[4], s[7], s[2], s[5], s[8]], i);
    }
    if (n.typeInfo.name === "mat3x4" || n.typeInfo.name === "mat3x4f" || n.typeInfo.name === "mat3x4h") {
      const s = n.data;
      return new tn([s[0], s[4], s[8], s[12], s[1], s[5], s[9], s[13], s[2], s[6], s[10], s[14]], i);
    }
    if (n.typeInfo.name === "mat4x2" || n.typeInfo.name === "mat4x2f" || n.typeInfo.name === "mat4x2h") {
      const s = n.data;
      return new tn([s[0], s[4], s[1], s[5], s[2], s[6]], i);
    }
    if (n.typeInfo.name === "mat4x3" || n.typeInfo.name === "mat4x3f" || n.typeInfo.name === "mat4x3h") {
      const s = n.data;
      return new tn([s[0], s[4], s[8], s[1], s[5], s[9], s[2], s[6], s[10]], i);
    }
    if (n.typeInfo.name === "mat4x4" || n.typeInfo.name === "mat4x4f" || n.typeInfo.name === "mat4x4h") {
      const s = n.data;
      return new tn([s[0], s[4], s[8], s[12], s[1], s[5], s[9], s[13], s[2], s[6], s[10], s[14], s[3], s[7], s[11], s[15]], i);
    }
    return console.error(`Invalid matrix type ${n.typeInfo.name}`), null;
  }
  Trunc(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Ne) return new Ne(n.data.map((s) => Math.trunc(s)), n.typeInfo);
    const i = n;
    return new ut(Math.trunc(i.value), n.typeInfo);
  }
  Dpdx(e, t) {
    return console.error(`TODO: dpdx. Line ${e.line}`), null;
  }
  DpdxCoarse(e, t) {
    return console.error(`TODO: dpdxCoarse. Line ${e.line}`), null;
  }
  DpdxFine(e, t) {
    return console.error("TODO: dpdxFine"), null;
  }
  Dpdy(e, t) {
    return console.error("TODO: dpdy"), null;
  }
  DpdyCoarse(e, t) {
    return console.error("TODO: dpdyCoarse"), null;
  }
  DpdyFine(e, t) {
    return console.error("TODO: dpdyFine"), null;
  }
  Fwidth(e, t) {
    return console.error("TODO: fwidth"), null;
  }
  FwidthCoarse(e, t) {
    return console.error("TODO: fwidthCoarse"), null;
  }
  FwidthFine(e, t) {
    return console.error("TODO: fwidthFine"), null;
  }
  TextureDimensions(e, t) {
    const n = e.args[0], i = e.args.length > 1 ? this.exec.evalExpression(e.args[1], t).value : 0;
    if (n instanceof gl) {
      const s = n.name, l = t.getVariableValue(s);
      if (l instanceof Zu) {
        if (i < 0 || i >= l.mipLevelCount) return console.error(`Invalid mip level for textureDimensions. Line ${e.line}`), null;
        const o = l.getMipLevelSize(i), d = l.dimension;
        return d === "1d" ? new ut(o[0], this.getTypeInfo("u32")) : d === "3d" ? new Ne(o, this.getTypeInfo("vec3u")) : d === "2d" ? new Ne(o.slice(0, 2), this.getTypeInfo("vec2u")) : (console.error(`Invalid texture dimension ${d} not found. Line ${e.line}`), null);
      }
      return console.error(`Texture ${s} not found. Line ${e.line}`), null;
    }
    return console.error(`Invalid texture argument for textureDimensions. Line ${e.line}`), null;
  }
  TextureGather(e, t) {
    return console.error("TODO: textureGather"), null;
  }
  TextureGatherCompare(e, t) {
    return console.error("TODO: textureGatherCompare"), null;
  }
  TextureLoad(e, t) {
    const n = e.args[0], i = this.exec.evalExpression(e.args[1], t), s = e.args.length > 2 ? this.exec.evalExpression(e.args[2], t).value : 0;
    if (!(i instanceof Ne) || i.data.length !== 2) return console.error(`Invalid UV argument for textureLoad. Line ${e.line}`), null;
    if (n instanceof gl) {
      const l = n.name, o = t.getVariableValue(l);
      if (o instanceof Zu) {
        const d = Math.floor(i.data[0]), m = Math.floor(i.data[1]);
        if (d < 0 || d >= o.width || m < 0 || m >= o.height) return console.error(`Texture ${l} out of bounds. Line ${e.line}`), null;
        const b = o.getPixel(d, m, 0, s);
        return b === null ? (console.error(`Invalid texture format for textureLoad. Line ${e.line}`), null) : new Ne(b, this.getTypeInfo("vec4f"));
      }
      return console.error(`Texture ${l} not found. Line ${e.line}`), null;
    }
    return console.error(`Invalid texture argument for textureLoad. Line ${e.line}`), null;
  }
  TextureNumLayers(e, t) {
    const n = e.args[0];
    if (n instanceof gl) {
      const i = n.name, s = t.getVariableValue(i);
      return s instanceof Zu ? new ut(s.depthOrArrayLayers, this.getTypeInfo("u32")) : (console.error(`Texture ${i} not found. Line ${e.line}`), null);
    }
    return console.error(`Invalid texture argument for textureNumLayers. Line ${e.line}`), null;
  }
  TextureNumLevels(e, t) {
    const n = e.args[0];
    if (n instanceof gl) {
      const i = n.name, s = t.getVariableValue(i);
      return s instanceof Zu ? new ut(s.mipLevelCount, this.getTypeInfo("u32")) : (console.error(`Texture ${i} not found. Line ${e.line}`), null);
    }
    return console.error(`Invalid texture argument for textureNumLevels. Line ${e.line}`), null;
  }
  TextureNumSamples(e, t) {
    const n = e.args[0];
    if (n instanceof gl) {
      const i = n.name, s = t.getVariableValue(i);
      return s instanceof Zu ? new ut(s.sampleCount, this.getTypeInfo("u32")) : (console.error(`Texture ${i} not found. Line ${e.line}`), null);
    }
    return console.error(`Invalid texture argument for textureNumSamples. Line ${e.line}`), null;
  }
  TextureSample(e, t) {
    return console.error("TODO: textureSample"), null;
  }
  TextureSampleBias(e, t) {
    return console.error("TODO: textureSampleBias"), null;
  }
  TextureSampleCompare(e, t) {
    return console.error("TODO: textureSampleCompare"), null;
  }
  TextureSampleCompareLevel(e, t) {
    return console.error("TODO: textureSampleCompareLevel"), null;
  }
  TextureSampleGrad(e, t) {
    return console.error("TODO: textureSampleGrad"), null;
  }
  TextureSampleLevel(e, t) {
    return console.error("TODO: textureSampleLevel"), null;
  }
  TextureSampleBaseClampToEdge(e, t) {
    return console.error("TODO: textureSampleBaseClampToEdge"), null;
  }
  TextureStore(e, t) {
    const n = e.args[0], i = this.exec.evalExpression(e.args[1], t), s = e.args.length === 4 ? this.exec.evalExpression(e.args[2], t).value : 0, l = e.args.length === 4 ? this.exec.evalExpression(e.args[3], t).data : this.exec.evalExpression(e.args[2], t).data;
    if (l.length !== 4) return console.error(`Invalid value argument for textureStore. Line ${e.line}`), null;
    if (!(i instanceof Ne) || i.data.length !== 2) return console.error(`Invalid UV argument for textureStore. Line ${e.line}`), null;
    if (n instanceof gl) {
      const o = n.name, d = t.getVariableValue(o);
      if (d instanceof Zu) {
        const m = d.getMipLevelSize(0), b = Math.floor(i.data[0]), A = Math.floor(i.data[1]);
        return b < 0 || b >= m[0] || A < 0 || A >= m[1] ? (console.error(`Texture ${o} out of bounds. Line ${e.line}`), null) : (d.setPixel(b, A, 0, s, Array.from(l)), null);
      }
      return console.error(`Texture ${o} not found. Line ${e.line}`), null;
    }
    return console.error(`Invalid texture argument for textureStore. Line ${e.line}`), null;
  }
  AtomicLoad(e, t) {
    let n = e.args[0];
    n instanceof Us && (n = n.right);
    const i = this.exec.getVariableName(n, t);
    return t.getVariable(i).value.getSubData(this.exec, n.postfix, t);
  }
  AtomicStore(e, t) {
    let n = e.args[0];
    n instanceof Us && (n = n.right);
    const i = this.exec.getVariableName(n, t), s = t.getVariable(i);
    let l = e.args[1];
    const o = this.exec.evalExpression(l, t), d = s.value.getSubData(this.exec, n.postfix, t);
    return d instanceof ut && o instanceof ut && (d.value = o.value), s.value instanceof ps && s.value.setDataValue(this.exec, d, n.postfix, t), null;
  }
  AtomicAdd(e, t) {
    let n = e.args[0];
    n instanceof Us && (n = n.right);
    const i = this.exec.getVariableName(n, t), s = t.getVariable(i);
    let l = e.args[1];
    const o = this.exec.evalExpression(l, t), d = s.value.getSubData(this.exec, n.postfix, t), m = new ut(d.value, d.typeInfo);
    return d instanceof ut && o instanceof ut && (d.value += o.value), s.value instanceof ps && s.value.setDataValue(this.exec, d, n.postfix, t), m;
  }
  AtomicSub(e, t) {
    let n = e.args[0];
    n instanceof Us && (n = n.right);
    const i = this.exec.getVariableName(n, t), s = t.getVariable(i);
    let l = e.args[1];
    const o = this.exec.evalExpression(l, t), d = s.value.getSubData(this.exec, n.postfix, t), m = new ut(d.value, d.typeInfo);
    return d instanceof ut && o instanceof ut && (d.value -= o.value), s.value instanceof ps && s.value.setDataValue(this.exec, d, n.postfix, t), m;
  }
  AtomicMax(e, t) {
    let n = e.args[0];
    n instanceof Us && (n = n.right);
    const i = this.exec.getVariableName(n, t), s = t.getVariable(i);
    let l = e.args[1];
    const o = this.exec.evalExpression(l, t), d = s.value.getSubData(this.exec, n.postfix, t), m = new ut(d.value, d.typeInfo);
    return d instanceof ut && o instanceof ut && (d.value = Math.max(d.value, o.value)), s.value instanceof ps && s.value.setDataValue(this.exec, d, n.postfix, t), m;
  }
  AtomicMin(e, t) {
    let n = e.args[0];
    n instanceof Us && (n = n.right);
    const i = this.exec.getVariableName(n, t), s = t.getVariable(i);
    let l = e.args[1];
    const o = this.exec.evalExpression(l, t), d = s.value.getSubData(this.exec, n.postfix, t), m = new ut(d.value, d.typeInfo);
    return d instanceof ut && o instanceof ut && (d.value = Math.min(d.value, o.value)), s.value instanceof ps && s.value.setDataValue(this.exec, d, n.postfix, t), m;
  }
  AtomicAnd(e, t) {
    let n = e.args[0];
    n instanceof Us && (n = n.right);
    const i = this.exec.getVariableName(n, t), s = t.getVariable(i);
    let l = e.args[1];
    const o = this.exec.evalExpression(l, t), d = s.value.getSubData(this.exec, n.postfix, t), m = new ut(d.value, d.typeInfo);
    return d instanceof ut && o instanceof ut && (d.value = d.value & o.value), s.value instanceof ps && s.value.setDataValue(this.exec, d, n.postfix, t), m;
  }
  AtomicOr(e, t) {
    let n = e.args[0];
    n instanceof Us && (n = n.right);
    const i = this.exec.getVariableName(n, t), s = t.getVariable(i);
    let l = e.args[1];
    const o = this.exec.evalExpression(l, t), d = s.value.getSubData(this.exec, n.postfix, t), m = new ut(d.value, d.typeInfo);
    return d instanceof ut && o instanceof ut && (d.value = d.value | o.value), s.value instanceof ps && s.value.setDataValue(this.exec, d, n.postfix, t), m;
  }
  AtomicXor(e, t) {
    let n = e.args[0];
    n instanceof Us && (n = n.right);
    const i = this.exec.getVariableName(n, t), s = t.getVariable(i);
    let l = e.args[1];
    const o = this.exec.evalExpression(l, t), d = s.value.getSubData(this.exec, n.postfix, t), m = new ut(d.value, d.typeInfo);
    return d instanceof ut && o instanceof ut && (d.value = d.value ^ o.value), s.value instanceof ps && s.value.setDataValue(this.exec, d, n.postfix, t), m;
  }
  AtomicExchange(e, t) {
    let n = e.args[0];
    n instanceof Us && (n = n.right);
    const i = this.exec.getVariableName(n, t), s = t.getVariable(i);
    let l = e.args[1];
    const o = this.exec.evalExpression(l, t), d = s.value.getSubData(this.exec, n.postfix, t), m = new ut(d.value, d.typeInfo);
    return d instanceof ut && o instanceof ut && (d.value = o.value), s.value instanceof ps && s.value.setDataValue(this.exec, d, n.postfix, t), m;
  }
  AtomicCompareExchangeWeak(e, t) {
    return console.error("TODO: atomicCompareExchangeWeak"), null;
  }
  Pack4x8snorm(e, t) {
    return console.error("TODO: pack4x8snorm"), null;
  }
  Pack4x8unorm(e, t) {
    return console.error("TODO: pack4x8unorm"), null;
  }
  Pack4xI8(e, t) {
    return console.error("TODO: pack4xI8"), null;
  }
  Pack4xU8(e, t) {
    return console.error("TODO: pack4xU8"), null;
  }
  Pack4x8Clamp(e, t) {
    return console.error("TODO: pack4x8Clamp"), null;
  }
  Pack4xU8Clamp(e, t) {
    return console.error("TODO: pack4xU8Clamp"), null;
  }
  Pack2x16snorm(e, t) {
    return console.error("TODO: pack2x16snorm"), null;
  }
  Pack2x16unorm(e, t) {
    return console.error("TODO: pack2x16unorm"), null;
  }
  Pack2x16float(e, t) {
    return console.error("TODO: pack2x16float"), null;
  }
  Unpack4x8snorm(e, t) {
    return console.error("TODO: unpack4x8snorm"), null;
  }
  Unpack4x8unorm(e, t) {
    return console.error("TODO: unpack4x8unorm"), null;
  }
  Unpack4xI8(e, t) {
    return console.error("TODO: unpack4xI8"), null;
  }
  Unpack4xU8(e, t) {
    return console.error("TODO: unpack4xU8"), null;
  }
  Unpack2x16snorm(e, t) {
    return console.error("TODO: unpack2x16snorm"), null;
  }
  Unpack2x16unorm(e, t) {
    return console.error("TODO: unpack2x16unorm"), null;
  }
  Unpack2x16float(e, t) {
    return console.error("TODO: unpack2x16float"), null;
  }
  StorageBarrier(e, t) {
    return null;
  }
  TextureBarrier(e, t) {
    return null;
  }
  WorkgroupBarrier(e, t) {
    return null;
  }
  WorkgroupUniformLoad(e, t) {
    return null;
  }
  SubgroupAdd(e, t) {
    return console.error("TODO: subgroupAdd"), null;
  }
  SubgroupExclusiveAdd(e, t) {
    return console.error("TODO: subgroupExclusiveAdd"), null;
  }
  SubgroupInclusiveAdd(e, t) {
    return console.error("TODO: subgroupInclusiveAdd"), null;
  }
  SubgroupAll(e, t) {
    return console.error("TODO: subgroupAll"), null;
  }
  SubgroupAnd(e, t) {
    return console.error("TODO: subgroupAnd"), null;
  }
  SubgroupAny(e, t) {
    return console.error("TODO: subgroupAny"), null;
  }
  SubgroupBallot(e, t) {
    return console.error("TODO: subgroupBallot"), null;
  }
  SubgroupBroadcast(e, t) {
    return console.error("TODO: subgroupBroadcast"), null;
  }
  SubgroupBroadcastFirst(e, t) {
    return console.error("TODO: subgroupBroadcastFirst"), null;
  }
  SubgroupElect(e, t) {
    return console.error("TODO: subgroupElect"), null;
  }
  SubgroupMax(e, t) {
    return console.error("TODO: subgroupMax"), null;
  }
  SubgroupMin(e, t) {
    return console.error("TODO: subgroupMin"), null;
  }
  SubgroupMul(e, t) {
    return console.error("TODO: subgroupMul"), null;
  }
  SubgroupExclusiveMul(e, t) {
    return console.error("TODO: subgroupExclusiveMul"), null;
  }
  SubgroupInclusiveMul(e, t) {
    return console.error("TODO: subgroupInclusiveMul"), null;
  }
  SubgroupOr(e, t) {
    return console.error("TODO: subgroupOr"), null;
  }
  SubgroupShuffle(e, t) {
    return console.error("TODO: subgroupShuffle"), null;
  }
  SubgroupShuffleDown(e, t) {
    return console.error("TODO: subgroupShuffleDown"), null;
  }
  SubgroupShuffleUp(e, t) {
    return console.error("TODO: subgroupShuffleUp"), null;
  }
  SubgroupShuffleXor(e, t) {
    return console.error("TODO: subgroupShuffleXor"), null;
  }
  SubgroupXor(e, t) {
    return console.error("TODO: subgroupXor"), null;
  }
  QuadBroadcast(e, t) {
    return console.error("TODO: quadBroadcast"), null;
  }
  QuadSwapDiagonal(e, t) {
    return console.error("TODO: quadSwapDiagonal"), null;
  }
  QuadSwapX(e, t) {
    return console.error("TODO: quadSwapX"), null;
  }
  QuadSwapY(e, t) {
    return console.error("TODO: quadSwapY"), null;
  }
}
const mb = {
  vec2: 2,
  vec2f: 2,
  vec2i: 2,
  vec2u: 2,
  vec2b: 2,
  vec2h: 2,
  vec3: 3,
  vec3f: 3,
  vec3i: 3,
  vec3u: 3,
  vec3b: 3,
  vec3h: 3,
  vec4: 4,
  vec4f: 4,
  vec4i: 4,
  vec4u: 4,
  vec4b: 4,
  vec4h: 4
}, ba = {
  mat2x2: [2, 2, 4],
  mat2x2f: [2, 2, 4],
  mat2x2h: [2, 2, 4],
  mat2x3: [2, 3, 6],
  mat2x3f: [2, 3, 6],
  mat2x3h: [2, 3, 6],
  mat2x4: [2, 4, 8],
  mat2x4f: [2, 4, 8],
  mat2x4h: [2, 4, 8],
  mat3x2: [3, 2, 6],
  mat3x2f: [3, 2, 6],
  mat3x2h: [3, 2, 6],
  mat3x3: [3, 3, 9],
  mat3x3f: [3, 3, 9],
  mat3x3h: [3, 3, 9],
  mat3x4: [3, 4, 12],
  mat3x4f: [3, 4, 12],
  mat3x4h: [3, 4, 12],
  mat4x2: [4, 2, 8],
  mat4x2f: [4, 2, 8],
  mat4x2h: [4, 2, 8],
  mat4x3: [4, 3, 12],
  mat4x3f: [4, 3, 12],
  mat4x3h: [4, 3, 12],
  mat4x4: [4, 4, 16],
  mat4x4f: [4, 4, 16],
  mat4x4h: [4, 4, 16]
};
class Qo extends Bk {
  constructor(e, t) {
    var n;
    super(), this.ast = e ?? [], this.reflection = new gu(), this.reflection.updateAST(this.ast), this.context = (n = t == null ? void 0 : t.clone()) !== null && n !== void 0 ? n : new I2(), this.builtins = new Lk(this), this.typeInfo = {
      bool: this.getTypeInfo(Xt.bool),
      i32: this.getTypeInfo(Xt.i32),
      u32: this.getTypeInfo(Xt.u32),
      f32: this.getTypeInfo(Xt.f32),
      f16: this.getTypeInfo(Xt.f16),
      vec2f: this.getTypeInfo(pt.vec2f),
      vec2u: this.getTypeInfo(pt.vec2u),
      vec2i: this.getTypeInfo(pt.vec2i),
      vec2h: this.getTypeInfo(pt.vec2h),
      vec3f: this.getTypeInfo(pt.vec3f),
      vec3u: this.getTypeInfo(pt.vec3u),
      vec3i: this.getTypeInfo(pt.vec3i),
      vec3h: this.getTypeInfo(pt.vec3h),
      vec4f: this.getTypeInfo(pt.vec4f),
      vec4u: this.getTypeInfo(pt.vec4u),
      vec4i: this.getTypeInfo(pt.vec4i),
      vec4h: this.getTypeInfo(pt.vec4h),
      mat2x2f: this.getTypeInfo(pt.mat2x2f),
      mat2x3f: this.getTypeInfo(pt.mat2x3f),
      mat2x4f: this.getTypeInfo(pt.mat2x4f),
      mat3x2f: this.getTypeInfo(pt.mat3x2f),
      mat3x3f: this.getTypeInfo(pt.mat3x3f),
      mat3x4f: this.getTypeInfo(pt.mat3x4f),
      mat4x2f: this.getTypeInfo(pt.mat4x2f),
      mat4x3f: this.getTypeInfo(pt.mat4x3f),
      mat4x4f: this.getTypeInfo(pt.mat4x4f)
    };
  }
  getVariableValue(e) {
    var t, n;
    const i = (n = (t = this.context.getVariable(e)) === null || t === void 0 ? void 0 : t.value) !== null && n !== void 0 ? n : null;
    if (i === null) return null;
    if (i instanceof ut) return i.value;
    if (i instanceof Ne || i instanceof tn) return Array.from(i.data);
    if (i instanceof ps && i.typeInfo instanceof $h) {
      if (i.typeInfo.format.name === "u32") return Array.from(new Uint32Array(i.buffer, i.offset, i.typeInfo.count));
      if (i.typeInfo.format.name === "i32") return Array.from(new Int32Array(i.buffer, i.offset, i.typeInfo.count));
      if (i.typeInfo.format.name === "f32") return Array.from(new Float32Array(i.buffer, i.offset, i.typeInfo.count));
    }
    return console.error(`Unsupported return variable type ${i.typeInfo.name}`), null;
  }
  execute(e) {
    (e = e ?? {}).constants && this._setOverrides(e.constants, this.context), this._execStatements(this.ast, this.context);
  }
  dispatchWorkgroups(e, t, n, i) {
    const s = this.context.clone();
    (i = i ?? {}).constants && this._setOverrides(i.constants, s), this._execStatements(this.ast, s);
    const l = s.getFunction(e);
    if (!l) return void console.error(`Function ${e} not found`);
    if (typeof t == "number") t = [t, 1, 1];
    else {
      if (t.length === 0) return void console.error("Invalid dispatch count");
      t.length === 1 ? t = [t[0], 1, 1] : t.length === 2 ? t = [t[0], t[1], 1] : t.length > 3 && (t = [t[0], t[1], t[2]]);
    }
    const o = t[0], d = t[1], m = t[2], b = this.getTypeInfo("vec3u");
    s.setVariable("@num_workgroups", new Ne(t, b));
    for (const A in n) for (const M in n[A]) {
      const E = n[A][M];
      s.variables.forEach((k) => {
        var U;
        const V = k.node;
        if (V != null && V.attributes) {
          let q = null, Y = null;
          for (const re of V.attributes) re.name === "binding" ? q = re.value : re.name === "group" && (Y = re.value);
          if (M == q && A == Y) if (E.texture !== void 0 && E.descriptor !== void 0) {
            const re = new Zu(E.texture, this.getTypeInfo(V.type), E.descriptor, (U = E.texture.view) !== null && U !== void 0 ? U : null);
            k.value = re;
          } else E.uniform !== void 0 ? k.value = new ps(E.uniform, this.getTypeInfo(V.type)) : k.value = new ps(E, this.getTypeInfo(V.type));
        }
      });
    }
    for (let A = 0; A < m; ++A) for (let M = 0; M < d; ++M) for (let E = 0; E < o; ++E) s.setVariable("@workgroup_id", new Ne([E, M, A], this.getTypeInfo("vec3u"))), this._dispatchWorkgroup(l, [E, M, A], s);
  }
  execStatement(e, t) {
    if (e instanceof zC) return this.evalExpression(e.value, t);
    if (e instanceof VC) {
      if (e.condition) {
        const n = this.evalExpression(e.condition, t);
        if (!(n instanceof ut)) throw new Error("Invalid break-if condition");
        if (!n.value) return null;
      }
      return Qo._breakObj;
    }
    if (e instanceof $C) return Qo._continueObj;
    if (e instanceof yg) this._let(e, t);
    else if (e instanceof Yu) this._var(e, t);
    else if (e instanceof c_) this._const(e, t);
    else if (e instanceof Pg) this._function(e, t);
    else {
      if (e instanceof UC) return this._if(e, t);
      if (e instanceof FC) return this._switch(e, t);
      if (e instanceof OC) return this._for(e, t);
      if (e instanceof LC) return this._while(e, t);
      if (e instanceof DC) return this._loop(e, t);
      if (e instanceof Y1) {
        const n = t.clone();
        return n.currentFunctionName = t.currentFunctionName, this._execStatements(e.body, n);
      }
      if (e instanceof NC) this._assign(e, t);
      else if (e instanceof kC) this._increment(e, t);
      else {
        if (e instanceof Xu) return null;
        if (e instanceof x2) {
          const n = e.name;
          t.getVariable(n) === null && t.setVariable(n, new ut(0, this.getTypeInfo("u32")));
        } else if (e instanceof w2) this._call(e, t);
        else {
          if (e instanceof jC || e instanceof A2) return null;
          console.error("Invalid statement type.", e, `Line ${e.line}`);
        }
      }
    }
    return null;
  }
  evalExpression(e, t) {
    return e instanceof yc ? this._evalBinaryOp(e, t) : e instanceof eo ? this._evalLiteral(e, t) : e instanceof gl ? this._evalVariable(e, t) : e instanceof T2 ? this._evalCall(e, t) : e instanceof hu ? this._evalCreate(e, t) : e instanceof qC ? this._evalConst(e, t) : e instanceof GC ? this._evalBitcast(e, t) : e instanceof Us ? this._evalUnaryOp(e, t) : (console.error("Invalid expression type", e, `Line ${e.line}`), null);
  }
  getTypeInfo(e) {
    var t;
    if (e instanceof Xt) {
      const i = this.reflection.getTypeInfo(e);
      if (i !== null) return i;
    }
    let n = (t = this.typeInfo[e]) !== null && t !== void 0 ? t : null;
    return n !== null || (n = this.reflection.getTypeInfoByName(e)), n;
  }
  _setOverrides(e, t) {
    for (const n in e) {
      const i = e[n], s = this.reflection.getOverrideInfo(n);
      s !== null ? (s.type === null && (s.type = this.getTypeInfo("u32")), s.type.name === "u32" || s.type.name === "i32" || s.type.name === "f32" || s.type.name === "f16" ? t.setVariable(n, new ut(i, s.type)) : s.type.name === "bool" ? t.setVariable(n, new ut(i ? 1 : 0, s.type)) : s.type.name === "vec2" || s.type.name === "vec3" || s.type.name === "vec4" || s.type.name === "vec2f" || s.type.name === "vec3f" || s.type.name === "vec4f" || s.type.name === "vec2i" || s.type.name === "vec3i" || s.type.name === "vec4i" || s.type.name === "vec2u" || s.type.name === "vec3u" || s.type.name === "vec4u" || s.type.name === "vec2h" || s.type.name === "vec3h" || s.type.name === "vec4h" ? t.setVariable(n, new Ne(i, s.type)) : console.error(`Invalid constant type for ${n}`)) : console.error(`Override ${n} does not exist in the shader.`);
    }
  }
  _dispatchWorkgroup(e, t, n) {
    const i = [1, 1, 1];
    for (const b of e.node.attributes) if (b.name === "workgroup_size") {
      if (b.value.length > 0) {
        const A = n.getVariableValue(b.value[0]);
        i[0] = A instanceof ut ? A.value : parseInt(b.value[0]);
      }
      if (b.value.length > 1) {
        const A = n.getVariableValue(b.value[1]);
        i[1] = A instanceof ut ? A.value : parseInt(b.value[1]);
      }
      if (b.value.length > 2) {
        const A = n.getVariableValue(b.value[2]);
        i[2] = A instanceof ut ? A.value : parseInt(b.value[2]);
      }
    }
    const s = this.getTypeInfo("vec3u"), l = this.getTypeInfo("u32");
    n.setVariable("@workgroup_size", new Ne(i, s));
    const o = i[0], d = i[1], m = i[2];
    for (let b = 0, A = 0; b < m; ++b) for (let M = 0; M < d; ++M) for (let E = 0; E < o; ++E, ++A) {
      const k = [E, M, b], U = [E + t[0] * i[0], M + t[1] * i[1], b + t[2] * i[2]];
      n.setVariable("@local_invocation_id", new Ne(k, s)), n.setVariable("@global_invocation_id", new Ne(U, s)), n.setVariable("@local_invocation_index", new ut(A, l)), this._dispatchExec(e, n);
    }
  }
  _dispatchExec(e, t) {
    for (const n of e.node.args) for (const i of n.attributes) if (i.name === "builtin") {
      const s = `@${i.value}`, l = t.getVariable(s);
      l !== void 0 && t.variables.set(n.name, l);
    }
    this._execStatements(e.node.body, t);
  }
  getVariableName(e, t) {
    for (; e instanceof Us; ) e = e.right;
    return e instanceof gl ? e.name : (console.error("Unknown variable type", e, "Line", e.line), null);
  }
  _execStatements(e, t) {
    for (const n of e) {
      if (n instanceof Array) {
        const s = t.clone(), l = this._execStatements(n, s);
        if (l) return l;
        continue;
      }
      const i = this.execStatement(n, t);
      if (i) return i;
    }
    return null;
  }
  _call(e, t) {
    const n = t.clone();
    n.currentFunctionName = e.name;
    const i = t.getFunction(e.name);
    if (i) {
      for (let s = 0; s < i.node.args.length; ++s) {
        const l = i.node.args[s], o = this.evalExpression(e.args[s], n);
        n.setVariable(l.name, o, l);
      }
      this._execStatements(i.node.body, n);
    } else e.isBuiltin ? this._callBuiltinFunction(e, n) : this.getTypeInfo(e.name) && this._evalCreate(e, t);
  }
  _increment(e, t) {
    const n = this.getVariableName(e.variable, t), i = t.getVariable(n);
    i ? e.operator === "++" ? i.value instanceof ut ? i.value.value++ : console.error(`Variable ${n} is not a scalar. Line ${e.line}`) : e.operator === "--" ? i.value instanceof ut ? i.value.value-- : console.error(`Variable ${n} is not a scalar. Line ${e.line}`) : console.error(`Unknown increment operator ${e.operator}. Line ${e.line}`) : console.error(`Variable ${n} not found. Line ${e.line}`);
  }
  _getVariableData(e, t) {
    if (e instanceof gl) {
      const n = this.getVariableName(e, t), i = t.getVariable(n);
      return i === null ? (console.error(`Variable ${n} not found. Line ${e.line}`), null) : i.value.getSubData(this, e.postfix, t);
    }
    if (e instanceof Us) {
      if (e.operator === "*") {
        const n = this._getVariableData(e.right, t);
        return n instanceof Ad ? n.reference.getSubData(this, e.postfix, t) : (console.error(`Variable ${e.right} is not a pointer. Line ${e.line}`), null);
      }
      if (e.operator === "&") {
        const n = this._getVariableData(e.right, t);
        return new Ad(n);
      }
    }
    return null;
  }
  _assign(e, t) {
    let n = null, i = "<var>", s = null;
    if (e.variable instanceof Us) {
      const d = this._getVariableData(e.variable, t), m = this.evalExpression(e.value, t), b = e.operator;
      if (b === "=") {
        if (d instanceof ut || d instanceof Ne || d instanceof tn) {
          if (m instanceof ut || m instanceof Ne || m instanceof tn && d.data.length === m.data.length) return void d.data.set(m.data);
          console.error(`Invalid assignment. Line ${e.line}`);
        } else if (d instanceof ps && m instanceof ps && d.buffer.byteLength - d.offset >= m.buffer.byteLength - m.offset) return void (d.buffer.byteLength % 4 == 0 ? new Uint32Array(d.buffer, d.offset, d.typeInfo.size / 4).set(new Uint32Array(m.buffer, m.offset, m.typeInfo.size / 4)) : new Uint8Array(d.buffer, d.offset, d.typeInfo.size).set(new Uint8Array(m.buffer, m.offset, m.typeInfo.size)));
        return console.error(`Invalid assignment. Line ${e.line}`), null;
      }
      if (b === "+=") return d instanceof ut || d instanceof Ne || d instanceof tn ? m instanceof ut || m instanceof Ne || m instanceof tn ? void d.data.set(m.data.map((A, M) => d.data[M] + A)) : void console.error(`Invalid assignment . Line ${e.line}`) : void console.error(`Invalid assignment. Line ${e.line}`);
      if (b === "-=") return (d instanceof ut || d instanceof Ne || d instanceof tn) && (m instanceof ut || m instanceof Ne || m instanceof tn) ? void d.data.set(m.data.map((A, M) => d.data[M] - A)) : void console.error(`Invalid assignment. Line ${e.line}`);
    }
    if (e.variable instanceof Us) {
      if (e.variable.operator === "*") {
        i = this.getVariableName(e.variable.right, t);
        const d = t.getVariable(i);
        if (!(d && d.value instanceof Ad)) return void console.error(`Variable ${i} is not a pointer. Line ${e.line}`);
        n = d.value.reference;
        let m = e.variable.postfix;
        if (!m) {
          let b = e.variable.right;
          for (; b instanceof Us; ) {
            if (b.postfix) {
              m = b.postfix;
              break;
            }
            b = b.right;
          }
        }
        m && (n = n.getSubData(this, m, t));
      }
    } else {
      s = e.variable.postfix, i = this.getVariableName(e.variable, t);
      const d = t.getVariable(i);
      if (d === null) return void console.error(`Variable ${i} not found. Line ${e.line}`);
      n = d.value;
    }
    if (n instanceof Ad && (n = n.reference), n === null) return void console.error(`Variable ${i} not found. Line ${e.line}`);
    const l = this.evalExpression(e.value, t), o = e.operator;
    if (o === "=")
      if (n instanceof ps) n.setDataValue(this, l, s, t);
      else if (s) {
        if (!(n instanceof Ne || n instanceof tn)) return void console.error(`Variable ${i} is not a vector or matrix. Line ${e.line}`);
        if (s instanceof ip) {
          const d = this.evalExpression(s.index, t).value;
          if (n instanceof Ne) {
            if (!(l instanceof ut)) return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
            n.data[d] = l.value;
          } else {
            if (!(n instanceof tn)) return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
            {
              const m = this.evalExpression(s.index, t).value;
              if (m < 0) return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
              if (!(l instanceof Ne)) return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
              {
                const b = n.typeInfo.getTypeName();
                if (b === "mat2x2" || b === "mat2x2f" || b === "mat2x2h") {
                  if (!(m < 2 && l.data.length === 2)) return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
                  n.data[2 * m] = l.data[0], n.data[2 * m + 1] = l.data[1];
                } else if (b === "mat2x3" || b === "mat2x3f" || b === "mat2x3h") {
                  if (!(m < 2 && l.data.length === 3)) return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
                  n.data[3 * m] = l.data[0], n.data[3 * m + 1] = l.data[1], n.data[3 * m + 2] = l.data[2];
                } else if (b === "mat2x4" || b === "mat2x4f" || b === "mat2x4h") {
                  if (!(m < 2 && l.data.length === 4)) return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
                  n.data[4 * m] = l.data[0], n.data[4 * m + 1] = l.data[1], n.data[4 * m + 2] = l.data[2], n.data[4 * m + 3] = l.data[3];
                } else if (b === "mat3x2" || b === "mat3x2f" || b === "mat3x2h") {
                  if (!(m < 3 && l.data.length === 2)) return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
                  n.data[2 * m] = l.data[0], n.data[2 * m + 1] = l.data[1];
                } else if (b === "mat3x3" || b === "mat3x3f" || b === "mat3x3h") {
                  if (!(m < 3 && l.data.length === 3)) return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
                  n.data[3 * m] = l.data[0], n.data[3 * m + 1] = l.data[1], n.data[3 * m + 2] = l.data[2];
                } else if (b === "mat3x4" || b === "mat3x4f" || b === "mat3x4h") {
                  if (!(m < 3 && l.data.length === 4)) return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
                  n.data[4 * m] = l.data[0], n.data[4 * m + 1] = l.data[1], n.data[4 * m + 2] = l.data[2], n.data[4 * m + 3] = l.data[3];
                } else if (b === "mat4x2" || b === "mat4x2f" || b === "mat4x2h") {
                  if (!(m < 4 && l.data.length === 2)) return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
                  n.data[2 * m] = l.data[0], n.data[2 * m + 1] = l.data[1];
                } else if (b === "mat4x3" || b === "mat4x3f" || b === "mat4x3h") {
                  if (!(m < 4 && l.data.length === 3)) return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
                  n.data[3 * m] = l.data[0], n.data[3 * m + 1] = l.data[1], n.data[3 * m + 2] = l.data[2];
                } else {
                  if (b !== "mat4x4" && b !== "mat4x4f" && b !== "mat4x4h") return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
                  if (!(m < 4 && l.data.length === 4)) return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
                  n.data[4 * m] = l.data[0], n.data[4 * m + 1] = l.data[1], n.data[4 * m + 2] = l.data[2], n.data[4 * m + 3] = l.data[3];
                }
              }
            }
          }
        } else if (s instanceof $f) {
          const d = s.value;
          if (!(n instanceof Ne)) return void console.error(`Invalid assignment to ${d}. Variable ${i} is not a vector. Line ${e.line}`);
          if (l instanceof ut) {
            if (d.length > 1) return void console.error(`Invalid assignment to ${d} for variable ${i}. Line ${e.line}`);
            if (d === "x") n.data[0] = l.value;
            else if (d === "y") {
              if (n.data.length < 2) return void console.error(`Invalid assignment to ${d} for variable ${i}. Line ${e.line}`);
              n.data[1] = l.value;
            } else if (d === "z") {
              if (n.data.length < 3) return void console.error(`Invalid assignment to ${d} for variable ${i}. Line ${e.line}`);
              n.data[2] = l.value;
            } else if (d === "w") {
              if (n.data.length < 4) return void console.error(`Invalid assignment to ${d} for variable ${i}. Line ${e.line}`);
              n.data[3] = l.value;
            }
          } else {
            if (!(l instanceof Ne)) return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
            if (d.length !== l.data.length) return void console.error(`Invalid assignment to ${d} for variable ${i}. Line ${e.line}`);
            for (let m = 0; m < d.length; ++m) {
              const b = d[m];
              if (b === "x" || b === "r") n.data[0] = l.data[m];
              else if (b === "y" || b === "g") {
                if (l.data.length < 2) return void console.error(`Invalid assignment to ${b} for variable ${i}. Line ${e.line}`);
                n.data[1] = l.data[m];
              } else if (b === "z" || b === "b") {
                if (l.data.length < 3) return void console.error(`Invalid assignment to ${b} for variable ${i}. Line ${e.line}`);
                n.data[2] = l.data[m];
              } else {
                if (b !== "w" && b !== "a") return void console.error(`Invalid assignment to ${b} for variable ${i}. Line ${e.line}`);
                if (l.data.length < 4) return void console.error(`Invalid assignment to ${b} for variable ${i}. Line ${e.line}`);
                n.data[3] = l.data[m];
              }
            }
          }
        }
      } else n instanceof ut && l instanceof ut ? n.value = l.value : n instanceof Ne && l instanceof Ne || n instanceof tn && l instanceof tn ? n.data.set(l.data) : console.error(`Invalid assignment to ${i}. Line ${e.line}`);
    else {
      const d = n.getSubData(this, s, t);
      if (d instanceof Ne && l instanceof ut) {
        const m = d.data, b = l.value;
        if (o === "+=") for (let A = 0; A < m.length; ++A) m[A] += b;
        else if (o === "-=") for (let A = 0; A < m.length; ++A) m[A] -= b;
        else if (o === "*=") for (let A = 0; A < m.length; ++A) m[A] *= b;
        else if (o === "/=") for (let A = 0; A < m.length; ++A) m[A] /= b;
        else if (o === "%=") for (let A = 0; A < m.length; ++A) m[A] %= b;
        else if (o === "&=") for (let A = 0; A < m.length; ++A) m[A] &= b;
        else if (o === "|=") for (let A = 0; A < m.length; ++A) m[A] |= b;
        else if (o === "^=") for (let A = 0; A < m.length; ++A) m[A] ^= b;
        else if (o === "<<=") for (let A = 0; A < m.length; ++A) m[A] <<= b;
        else if (o === ">>=") for (let A = 0; A < m.length; ++A) m[A] >>= b;
        else console.error(`Invalid operator ${o}. Line ${e.line}`);
      } else if (d instanceof Ne && l instanceof Ne) {
        const m = d.data, b = l.data;
        if (m.length !== b.length) return void console.error(`Vector length mismatch. Line ${e.line}`);
        if (o === "+=") for (let A = 0; A < m.length; ++A) m[A] += b[A];
        else if (o === "-=") for (let A = 0; A < m.length; ++A) m[A] -= b[A];
        else if (o === "*=") for (let A = 0; A < m.length; ++A) m[A] *= b[A];
        else if (o === "/=") for (let A = 0; A < m.length; ++A) m[A] /= b[A];
        else if (o === "%=") for (let A = 0; A < m.length; ++A) m[A] %= b[A];
        else if (o === "&=") for (let A = 0; A < m.length; ++A) m[A] &= b[A];
        else if (o === "|=") for (let A = 0; A < m.length; ++A) m[A] |= b[A];
        else if (o === "^=") for (let A = 0; A < m.length; ++A) m[A] ^= b[A];
        else if (o === "<<=") for (let A = 0; A < m.length; ++A) m[A] <<= b[A];
        else if (o === ">>=") for (let A = 0; A < m.length; ++A) m[A] >>= b[A];
        else console.error(`Invalid operator ${o}. Line ${e.line}`);
      } else {
        if (!(d instanceof ut && l instanceof ut)) return void console.error(`Invalid type for ${e.operator} operator. Line ${e.line}`);
        o === "+=" ? d.value += l.value : o === "-=" ? d.value -= l.value : o === "*=" ? d.value *= l.value : o === "/=" ? d.value /= l.value : o === "%=" ? d.value %= l.value : o === "&=" ? d.value &= l.value : o === "|=" ? d.value |= l.value : o === "^=" ? d.value ^= l.value : o === "<<=" ? d.value <<= l.value : o === ">>=" ? d.value >>= l.value : console.error(`Invalid operator ${o}. Line ${e.line}`);
      }
      n instanceof ps && n.setDataValue(this, d, s, t);
    }
  }
  _function(e, t) {
    const n = new C2(e);
    t.functions.set(e.name, n);
  }
  _const(e, t) {
    let n = null;
    e.value !== null && (n = this.evalExpression(e.value, t)), t.createVariable(e.name, n, e);
  }
  _let(e, t) {
    let n = null;
    if (e.value !== null) {
      if (n = this.evalExpression(e.value, t), n === null) return void console.error(`Invalid value for variable ${e.name}. Line ${e.line}`);
      e.value instanceof Us || (n = n.clone());
    } else {
      const i = e.type.name;
      if (i === "f32" || i === "i32" || i === "u32" || i === "bool" || i === "f16" || i === "vec2" || i === "vec3" || i === "vec4" || i === "vec2f" || i === "vec3f" || i === "vec4f" || i === "vec2i" || i === "vec3i" || i === "vec4i" || i === "vec2u" || i === "vec3u" || i === "vec4u" || i === "vec2h" || i === "vec3h" || i === "vec4h" || i === "vec2b" || i === "vec3b" || i === "vec4b" || i === "mat2x2" || i === "mat2x3" || i === "mat2x4" || i === "mat3x2" || i === "mat3x3" || i === "mat3x4" || i === "mat4x2" || i === "mat4x3" || i === "mat4x4" || i === "mat2x2f" || i === "mat2x3f" || i === "mat2x4f" || i === "mat3x2f" || i === "mat3x3f" || i === "mat3x4f" || i === "mat4x2f" || i === "mat4x3f" || i === "mat4x4f" || i === "mat2x2h" || i === "mat2x3h" || i === "mat2x4h" || i === "mat3x2h" || i === "mat3x3h" || i === "mat3x4h" || i === "mat4x2h" || i === "mat4x3h" || i === "mat4x4h" || i === "array") {
        const s = new hu(e.type, []);
        n = this._evalCreate(s, t);
      }
    }
    t.createVariable(e.name, n, e);
  }
  _var(e, t) {
    let n = null;
    if (e.value !== null) {
      if (n = this.evalExpression(e.value, t), n === null) return void console.error(`Invalid value for variable ${e.name}. Line ${e.line}`);
      e.value instanceof Us || (n = n.clone());
    } else {
      if (e.type === null) return void console.error(`Variable ${e.name} has no type. Line ${e.line}`);
      const i = e.type.name;
      if (i === "f32" || i === "i32" || i === "u32" || i === "bool" || i === "f16" || i === "vec2" || i === "vec3" || i === "vec4" || i === "vec2f" || i === "vec3f" || i === "vec4f" || i === "vec2i" || i === "vec3i" || i === "vec4i" || i === "vec2u" || i === "vec3u" || i === "vec4u" || i === "vec2h" || i === "vec3h" || i === "vec4h" || i === "vec2b" || i === "vec3b" || i === "vec4b" || i === "mat2x2" || i === "mat2x3" || i === "mat2x4" || i === "mat3x2" || i === "mat3x3" || i === "mat3x4" || i === "mat4x2" || i === "mat4x3" || i === "mat4x4" || i === "mat2x2f" || i === "mat2x3f" || i === "mat2x4f" || i === "mat3x2f" || i === "mat3x3f" || i === "mat3x4f" || i === "mat4x2f" || i === "mat4x3f" || i === "mat4x4f" || i === "mat2x2h" || i === "mat2x3h" || i === "mat2x4h" || i === "mat3x2h" || i === "mat3x3h" || i === "mat3x4h" || i === "mat4x2h" || i === "mat4x3h" || i === "mat4x4h" || e.type instanceof bg || e.type instanceof Xu || e.type instanceof pt) {
        const s = new hu(e.type, []);
        n = this._evalCreate(s, t);
      }
    }
    t.createVariable(e.name, n, e);
  }
  _switch(e, t) {
    t = t.clone();
    const n = this.evalExpression(e.condition, t);
    if (!(n instanceof ut)) return console.error(`Invalid if condition. Line ${e.line}`), null;
    let i = null;
    for (const s of e.cases) if (s instanceof XC) for (const l of s.selectors) {
      if (l instanceof h_) {
        i = s;
        continue;
      }
      const o = this.evalExpression(l, t);
      if (!(o instanceof ut)) return console.error(`Invalid case selector. Line ${e.line}`), null;
      if (o.value === n.value) return this._execStatements(s.body, t);
    }
    else s instanceof ZC && (i = s);
    return i ? this._execStatements(i.body, t) : null;
  }
  _if(e, t) {
    t = t.clone();
    const n = this.evalExpression(e.condition, t);
    if (!(n instanceof ut)) return console.error(`Invalid if condition. Line ${e.line}`), null;
    if (n.value) return this._execStatements(e.body, t);
    for (const i of e.elseif) {
      const s = this.evalExpression(i.condition, t);
      if (!(s instanceof ut)) return console.error(`Invalid if condition. Line ${e.line}`), null;
      if (s.value) return this._execStatements(i.body, t);
    }
    return e.else ? this._execStatements(e.else, t) : null;
  }
  _getScalarValue(e) {
    return e instanceof ut ? e.value : (console.error("Expected scalar value.", e), 0);
  }
  _for(e, t) {
    for (t = t.clone(), this.execStatement(e.init, t); this._getScalarValue(this.evalExpression(e.condition, t)); ) {
      const n = this._execStatements(e.body, t);
      if (n === Qo._breakObj) break;
      if (n !== null && n !== Qo._continueObj) return n;
      this.execStatement(e.increment, t);
    }
    return null;
  }
  _loop(e, t) {
    for (t = t.clone(); ; ) {
      const n = this._execStatements(e.body, t);
      if (n === Qo._breakObj) break;
      if (n === Qo._continueObj) {
        if (e.continuing && this._execStatements(e.continuing.body, t) === Qo._breakObj)
          break;
      } else if (n !== null) return n;
    }
    return null;
  }
  _while(e, t) {
    for (t = t.clone(); this._getScalarValue(this.evalExpression(e.condition, t)); ) {
      const n = this._execStatements(e.body, t);
      if (n === Qo._breakObj) break;
      if (n !== Qo._continueObj && n !== null) return n;
    }
    return null;
  }
  _evalBitcast(e, t) {
    const n = this.evalExpression(e.value, t), i = e.type;
    if (n instanceof ut) {
      const s = uT(n.value, n.typeInfo.name, i.name);
      return new ut(s, this.getTypeInfo(i));
    }
    if (n instanceof Ne) {
      const s = n.typeInfo.getTypeName();
      let l = "";
      if (s.endsWith("f")) l = "f32";
      else if (s.endsWith("i")) l = "i32";
      else if (s.endsWith("u")) l = "u32";
      else if (s.endsWith("b")) l = "bool";
      else {
        if (!s.endsWith("h")) return console.error(`Unknown vector type ${s}. Line ${e.line}`), null;
        l = "f16";
      }
      const o = i.getTypeName();
      let d = "";
      if (o.endsWith("f")) d = "f32";
      else if (o.endsWith("i")) d = "i32";
      else if (o.endsWith("u")) d = "u32";
      else if (o.endsWith("b")) d = "bool";
      else {
        if (!o.endsWith("h")) return console.error(`Unknown vector type ${d}. Line ${e.line}`), null;
        d = "f16";
      }
      const m = function(b, A, M) {
        if (A === M) return b;
        const E = new Array(b.length);
        for (let k = 0; k < b.length; k++) E[k] = uT(b[k], A, M);
        return E;
      }(Array.from(n.data), l, d);
      return new Ne(m, this.getTypeInfo(i));
    }
    return console.error(`TODO: bitcast for ${n.typeInfo.name}. Line ${e.line}`), null;
  }
  _evalConst(e, t) {
    return t.getVariableValue(e.name).clone().getSubData(this, e.postfix, t);
  }
  _evalCreate(e, t) {
    var n;
    if (e instanceof hu) {
      if (e.type === null) return K1.void;
      switch (e.type.getTypeName()) {
        case "bool":
        case "i32":
        case "u32":
        case "f32":
        case "f16":
          return this._callConstructorValue(e, t);
        case "vec2":
        case "vec3":
        case "vec4":
        case "vec2f":
        case "vec3f":
        case "vec4f":
        case "vec2h":
        case "vec3h":
        case "vec4h":
        case "vec2i":
        case "vec3i":
        case "vec4i":
        case "vec2u":
        case "vec3u":
        case "vec4u":
        case "vec2b":
        case "vec3b":
        case "vec4b":
          return this._callConstructorVec(e, t);
        case "mat2x2":
        case "mat2x2f":
        case "mat2x2h":
        case "mat2x3":
        case "mat2x3f":
        case "mat2x3h":
        case "mat2x4":
        case "mat2x4f":
        case "mat2x4h":
        case "mat3x2":
        case "mat3x2f":
        case "mat3x2h":
        case "mat3x3":
        case "mat3x3f":
        case "mat3x3h":
        case "mat3x4":
        case "mat3x4f":
        case "mat3x4h":
        case "mat4x2":
        case "mat4x2f":
        case "mat4x2h":
        case "mat4x3":
        case "mat4x3f":
        case "mat4x3h":
        case "mat4x4":
        case "mat4x4f":
        case "mat4x4h":
          return this._callConstructorMatrix(e, t);
      }
    }
    const i = e instanceof hu ? e.type.name : e.name, s = e instanceof hu ? this.getTypeInfo(e.type) : this.getTypeInfo(e.name);
    if (s === null) return console.error(`Unknown type ${i}. Line ${e.line}`), null;
    if (s.size === 0) return null;
    const l = new ps(new ArrayBuffer(s.size), s, 0);
    if (s instanceof Uh) {
      if (e.args) for (let o = 0; o < e.args.length; ++o) {
        const d = s.members[o], m = e.args[o], b = this.evalExpression(m, t);
        l.setData(this, b, d.type, d.offset, t);
      }
    } else if (s instanceof $h) {
      let o = 0;
      if (e.args) for (let d = 0; d < e.args.length; ++d) {
        const m = e.args[d], b = this.evalExpression(m, t);
        s.format === null && (((n = b.typeInfo) === null || n === void 0 ? void 0 : n.name) === "x32" ? s.format = this.getTypeInfo("i32") : s.format = b.typeInfo), l.setData(this, b, s.format, o, t), o += s.stride;
      }
    } else console.error(`Unknown type "${i}". Line ${e.line}`);
    return e instanceof hu ? l.getSubData(this, e.postfix, t) : l;
  }
  _evalLiteral(e, t) {
    const n = this.getTypeInfo(e.type), i = n.name;
    return i === "x32" || i === "u32" || i === "f32" || i === "f16" || i === "i32" || i === "bool" ? new ut(e.scalarValue, n) : i === "vec2" || i === "vec3" || i === "vec4" || i === "vec2f" || i === "vec3f" || i === "vec4f" || i === "vec2h" || i === "vec3h" || i === "vec4h" || i === "vec2i" || i === "vec3i" || i === "vec4i" || i === "vec2u" || i === "vec3u" || i === "vec4u" ? this._callConstructorVec(e, t) : i === "mat2x2" || i === "mat2x3" || i === "mat2x4" || i === "mat3x2" || i === "mat3x3" || i === "mat3x4" || i === "mat4x2" || i === "mat4x3" || i === "mat4x4" || i === "mat2x2f" || i === "mat2x3f" || i === "mat2x4f" || i === "mat3x2f" || i === "mat3x3f" || i === "mat3x4f" || i === "mat4x2f" || i === "mat4x3f" || i === "mat4x4f" || i === "mat2x2h" || i === "mat2x3h" || i === "mat2x4h" || i === "mat3x2h" || i === "mat3x3h" || i === "mat3x4h" || i === "mat4x2h" || i === "mat4x3h" || i === "mat4x4h" ? this._callConstructorMatrix(e, t) : e.value;
  }
  _evalVariable(e, t) {
    const n = t.getVariableValue(e.name);
    return n === null ? n : n.getSubData(this, e.postfix, t);
  }
  _maxFormatTypeInfo(e) {
    let t = e[0];
    if (t.name === "f32") return t;
    for (let n = 1; n < e.length; ++n) {
      const i = Qo._priority.get(t.name);
      Qo._priority.get(e[n].name) < i && (t = e[n]);
    }
    return t.name === "x32" ? this.getTypeInfo("i32") : t;
  }
  _evalUnaryOp(e, t) {
    const n = this.evalExpression(e.right, t);
    if (e.operator === "&") return new Ad(n);
    if (e.operator === "*") return n instanceof Ad ? n.reference.getSubData(this, e.postfix, t) : (console.error(`Invalid dereference. Line ${e.line}`), null);
    const i = n instanceof ut ? n.value : n instanceof Ne ? Array.from(n.data) : null;
    switch (e.operator) {
      case "+": {
        if (Ar(i)) {
          const o = i.map((d, m) => +d);
          return new Ne(o, n.typeInfo);
        }
        const s = i, l = this._maxFormatTypeInfo([n.typeInfo, n.typeInfo]);
        return new ut(+s, l);
      }
      case "-": {
        if (Ar(i)) {
          const o = i.map((d, m) => -d);
          return new Ne(o, n.typeInfo);
        }
        const s = i, l = this._maxFormatTypeInfo([n.typeInfo, n.typeInfo]);
        return new ut(-s, l);
      }
      case "!": {
        if (Ar(i)) {
          const o = i.map((d, m) => d ? 0 : 1);
          return new Ne(o, n.typeInfo);
        }
        const s = i, l = this._maxFormatTypeInfo([n.typeInfo, n.typeInfo]);
        return new ut(s ? 0 : 1, l);
      }
      case "~": {
        if (Ar(i)) {
          const o = i.map((d, m) => ~d);
          return new Ne(o, n.typeInfo);
        }
        const s = i, l = this._maxFormatTypeInfo([n.typeInfo, n.typeInfo]);
        return new ut(~s, l);
      }
    }
    return console.error(`Invalid unary operator ${e.operator}. Line ${e.line}`), null;
  }
  _evalBinaryOp(e, t) {
    const n = this.evalExpression(e.left, t), i = this.evalExpression(e.right, t), s = n instanceof ut ? n.value : n instanceof Ne || n instanceof tn ? Array.from(n.data) : null, l = i instanceof ut ? i.value : i instanceof Ne || i instanceof tn ? Array.from(i.data) : null;
    switch (e.operator) {
      case "+": {
        if (Ar(s) && Ar(l)) {
          const b = s, A = l;
          if (b.length !== A.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const M = b.map((E, k) => E + A[k]);
          return new Ne(M, n.typeInfo);
        }
        if (Ar(s)) {
          const b = l, A = s.map((M, E) => M + b);
          return new Ne(A, n.typeInfo);
        }
        if (Ar(l)) {
          const b = s, A = l.map((M, E) => b + M);
          return new Ne(A, i.typeInfo);
        }
        const o = s, d = l, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new ut(o + d, m);
      }
      case "-": {
        if (Ar(s) && Ar(l)) {
          const b = s, A = l;
          if (b.length !== A.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const M = b.map((E, k) => E - A[k]);
          return new Ne(M, n.typeInfo);
        }
        if (Ar(s)) {
          const b = l, A = s.map((M, E) => M - b);
          return new Ne(A, n.typeInfo);
        }
        if (Ar(l)) {
          const b = s, A = l.map((M, E) => b - M);
          return new Ne(A, i.typeInfo);
        }
        const o = s, d = l, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new ut(o - d, m);
      }
      case "*": {
        if (Ar(s) && Ar(l)) {
          const b = s, A = l;
          if (n instanceof tn && i instanceof tn) {
            const M = function(V, q, Y, re) {
              if (ba[q.name] === void 0 || ba[re.name] === void 0) return null;
              const Z = ba[q.name][0], K = ba[q.name][1], ie = ba[re.name][0];
              if (Z !== ba[re.name][1]) return null;
              const be = new Array(ie * K);
              for (let he = 0; he < K; he++) for (let Be = 0; Be < ie; Be++) {
                let ke = 0;
                for (let pe = 0; pe < Z; pe++) ke += V[pe * K + he] * Y[Be * Z + pe];
                be[he * ie + Be] = ke;
              }
              return be;
            }(b, n.typeInfo, A, i.typeInfo);
            if (M === null) return console.error(`Matrix multiplication failed. Line ${e.line}.`), null;
            const E = ba[i.typeInfo.name][0], k = ba[n.typeInfo.name][1], U = this.getTypeInfo(`mat${E}x${k}f`);
            return new tn(M, U);
          }
          if (n instanceof tn && i instanceof Ne) {
            const M = function(E, k, U, V) {
              if (ba[k.name] === void 0 || mb[V.name] === void 0) return null;
              const q = ba[k.name][0], Y = ba[k.name][1];
              if (q !== U.length) return null;
              const re = new Array(Y);
              for (let Z = 0; Z < Y; Z++) {
                let K = 0;
                for (let ie = 0; ie < q; ie++) K += E[ie * Y + Z] * U[ie];
                re[Z] = K;
              }
              return re;
            }(b, n.typeInfo, A, i.typeInfo);
            return M === null ? (console.error(`Matrix vector multiplication failed. Line ${e.line}.`), null) : new Ne(M, i.typeInfo);
          }
          if (n instanceof Ne && i instanceof tn) {
            const M = function(E, k, U, V) {
              if (mb[k.name] === void 0 || ba[V.name] === void 0) return null;
              const q = ba[V.name][0], Y = ba[V.name][1];
              if (Y !== E.length) return null;
              const re = [];
              for (let Z = 0; Z < q; Z++) {
                let K = 0;
                for (let ie = 0; ie < Y; ie++) K += E[ie] * U[ie * q + Z];
                re[Z] = K;
              }
              return re;
            }(b, n.typeInfo, A, i.typeInfo);
            return M === null ? (console.error(`Matrix vector multiplication failed. Line ${e.line}.`), null) : new Ne(M, n.typeInfo);
          }
          {
            if (b.length !== A.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
            const M = b.map((E, k) => E * A[k]);
            return new Ne(M, n.typeInfo);
          }
        }
        if (Ar(s)) {
          const b = l, A = s.map((M, E) => M * b);
          return n instanceof tn ? new tn(A, n.typeInfo) : new Ne(A, n.typeInfo);
        }
        if (Ar(l)) {
          const b = s, A = l.map((M, E) => b * M);
          return i instanceof tn ? new tn(A, i.typeInfo) : new Ne(A, i.typeInfo);
        }
        const o = s, d = l, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new ut(o * d, m);
      }
      case "%": {
        if (Ar(s) && Ar(l)) {
          const b = s, A = l;
          if (b.length !== A.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const M = b.map((E, k) => E % A[k]);
          return new Ne(M, n.typeInfo);
        }
        if (Ar(s)) {
          const b = l, A = s.map((M, E) => M % b);
          return new Ne(A, n.typeInfo);
        }
        if (Ar(l)) {
          const b = s, A = l.map((M, E) => b % M);
          return new Ne(A, i.typeInfo);
        }
        const o = s, d = l, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new ut(o % d, m);
      }
      case "/": {
        if (Ar(s) && Ar(l)) {
          const b = s, A = l;
          if (b.length !== A.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const M = b.map((E, k) => E / A[k]);
          return new Ne(M, n.typeInfo);
        }
        if (Ar(s)) {
          const b = l, A = s.map((M, E) => M / b);
          return new Ne(A, n.typeInfo);
        }
        if (Ar(l)) {
          const b = s, A = l.map((M, E) => b / M);
          return new Ne(A, i.typeInfo);
        }
        const o = s, d = l, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new ut(o / d, m);
      }
      case "&": {
        if (Ar(s) && Ar(l)) {
          const b = s, A = l;
          if (b.length !== A.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const M = b.map((E, k) => E & A[k]);
          return new Ne(M, n.typeInfo);
        }
        if (Ar(s)) {
          const b = l, A = s.map((M, E) => M & b);
          return new Ne(A, n.typeInfo);
        }
        if (Ar(l)) {
          const b = s, A = l.map((M, E) => b & M);
          return new Ne(A, i.typeInfo);
        }
        const o = s, d = l, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new ut(o & d, m);
      }
      case "|": {
        if (Ar(s) && Ar(l)) {
          const b = s, A = l;
          if (b.length !== A.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const M = b.map((E, k) => E | A[k]);
          return new Ne(M, n.typeInfo);
        }
        if (Ar(s)) {
          const b = l, A = s.map((M, E) => M | b);
          return new Ne(A, n.typeInfo);
        }
        if (Ar(l)) {
          const b = s, A = l.map((M, E) => b | M);
          return new Ne(A, i.typeInfo);
        }
        const o = s, d = l, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new ut(o | d, m);
      }
      case "^": {
        if (Ar(s) && Ar(l)) {
          const b = s, A = l;
          if (b.length !== A.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const M = b.map((E, k) => E ^ A[k]);
          return new Ne(M, n.typeInfo);
        }
        if (Ar(s)) {
          const b = l, A = s.map((M, E) => M ^ b);
          return new Ne(A, n.typeInfo);
        }
        if (Ar(l)) {
          const b = s, A = l.map((M, E) => b ^ M);
          return new Ne(A, i.typeInfo);
        }
        const o = s, d = l, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new ut(o ^ d, m);
      }
      case "<<": {
        if (Ar(s) && Ar(l)) {
          const b = s, A = l;
          if (b.length !== A.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const M = b.map((E, k) => E << A[k]);
          return new Ne(M, n.typeInfo);
        }
        if (Ar(s)) {
          const b = l, A = s.map((M, E) => M << b);
          return new Ne(A, n.typeInfo);
        }
        if (Ar(l)) {
          const b = s, A = l.map((M, E) => b << M);
          return new Ne(A, i.typeInfo);
        }
        const o = s, d = l, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new ut(o << d, m);
      }
      case ">>": {
        if (Ar(s) && Ar(l)) {
          const b = s, A = l;
          if (b.length !== A.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const M = b.map((E, k) => E >> A[k]);
          return new Ne(M, n.typeInfo);
        }
        if (Ar(s)) {
          const b = l, A = s.map((M, E) => M >> b);
          return new Ne(A, n.typeInfo);
        }
        if (Ar(l)) {
          const b = s, A = l.map((M, E) => b >> M);
          return new Ne(A, i.typeInfo);
        }
        const o = s, d = l, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new ut(o >> d, m);
      }
      case ">":
        if (Ar(s) && Ar(l)) {
          const o = s, d = l;
          if (o.length !== d.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = o.map((b, A) => b > d[A] ? 1 : 0);
          return new Ne(m, n.typeInfo);
        }
        if (Ar(s)) {
          const o = l, d = s.map((m, b) => m > o ? 1 : 0);
          return new Ne(d, n.typeInfo);
        }
        if (Ar(l)) {
          const o = s, d = l.map((m, b) => o > m ? 1 : 0);
          return new Ne(d, i.typeInfo);
        }
        return new ut(s > l ? 1 : 0, this.getTypeInfo("bool"));
      case "<":
        if (Ar(s) && Ar(l)) {
          const o = s, d = l;
          if (o.length !== d.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = o.map((b, A) => b < d[A] ? 1 : 0);
          return new Ne(m, n.typeInfo);
        }
        if (Ar(s)) {
          const o = l, d = s.map((m, b) => m < o ? 1 : 0);
          return new Ne(d, n.typeInfo);
        }
        if (Ar(l)) {
          const o = s, d = l.map((m, b) => o < m ? 1 : 0);
          return new Ne(d, i.typeInfo);
        }
        return new ut(s < l ? 1 : 0, this.getTypeInfo("bool"));
      case "==":
        if (Ar(s) && Ar(l)) {
          const o = s, d = l;
          if (o.length !== d.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = o.map((b, A) => b === d[A] ? 1 : 0);
          return new Ne(m, n.typeInfo);
        }
        if (Ar(s)) {
          const o = l, d = s.map((m, b) => m == o ? 1 : 0);
          return new Ne(d, n.typeInfo);
        }
        if (Ar(l)) {
          const o = s, d = l.map((m, b) => o == m ? 1 : 0);
          return new Ne(d, i.typeInfo);
        }
        return new ut(s === l ? 1 : 0, this.getTypeInfo("bool"));
      case "!=":
        if (Ar(s) && Ar(l)) {
          const o = s, d = l;
          if (o.length !== d.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = o.map((b, A) => b !== d[A] ? 1 : 0);
          return new Ne(m, n.typeInfo);
        }
        if (Ar(s)) {
          const o = l, d = s.map((m, b) => m !== o ? 1 : 0);
          return new Ne(d, n.typeInfo);
        }
        if (Ar(l)) {
          const o = s, d = l.map((m, b) => o !== m ? 1 : 0);
          return new Ne(d, i.typeInfo);
        }
        return new ut(s !== l ? 1 : 0, this.getTypeInfo("bool"));
      case ">=":
        if (Ar(s) && Ar(l)) {
          const o = s, d = l;
          if (o.length !== d.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = o.map((b, A) => b >= d[A] ? 1 : 0);
          return new Ne(m, n.typeInfo);
        }
        if (Ar(s)) {
          const o = l, d = s.map((m, b) => m >= o ? 1 : 0);
          return new Ne(d, n.typeInfo);
        }
        if (Ar(l)) {
          const o = s, d = l.map((m, b) => o >= m ? 1 : 0);
          return new Ne(d, i.typeInfo);
        }
        return new ut(s >= l ? 1 : 0, this.getTypeInfo("bool"));
      case "<=":
        if (Ar(s) && Ar(l)) {
          const o = s, d = l;
          if (o.length !== d.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = o.map((b, A) => b <= d[A] ? 1 : 0);
          return new Ne(m, n.typeInfo);
        }
        if (Ar(s)) {
          const o = l, d = s.map((m, b) => m <= o ? 1 : 0);
          return new Ne(d, n.typeInfo);
        }
        if (Ar(l)) {
          const o = s, d = l.map((m, b) => o <= m ? 1 : 0);
          return new Ne(d, i.typeInfo);
        }
        return new ut(s <= l ? 1 : 0, this.getTypeInfo("bool"));
      case "&&":
        if (Ar(s) && Ar(l)) {
          const o = s, d = l;
          if (o.length !== d.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = o.map((b, A) => b && d[A] ? 1 : 0);
          return new Ne(m, n.typeInfo);
        }
        if (Ar(s)) {
          const o = l, d = s.map((m, b) => m && o ? 1 : 0);
          return new Ne(d, n.typeInfo);
        }
        if (Ar(l)) {
          const o = s, d = l.map((m, b) => o && m ? 1 : 0);
          return new Ne(d, i.typeInfo);
        }
        return new ut(s && l ? 1 : 0, this.getTypeInfo("bool"));
      case "||":
        if (Ar(s) && Ar(l)) {
          const o = s, d = l;
          if (o.length !== d.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = o.map((b, A) => b || d[A] ? 1 : 0);
          return new Ne(m, n.typeInfo);
        }
        if (Ar(s)) {
          const o = l, d = s.map((m, b) => m || o ? 1 : 0);
          return new Ne(d, n.typeInfo);
        }
        if (Ar(l)) {
          const o = s, d = l.map((m, b) => o || m ? 1 : 0);
          return new Ne(d, i.typeInfo);
        }
        return new ut(s || l ? 1 : 0, this.getTypeInfo("bool"));
    }
    return console.error(`Unknown operator ${e.operator}. Line ${e.line}`), null;
  }
  _evalCall(e, t) {
    if (e.cachedReturnValue !== null) return e.cachedReturnValue;
    const n = t.clone();
    n.currentFunctionName = e.name;
    const i = t.getFunction(e.name);
    if (!i)
      return e.isBuiltin ? this._callBuiltinFunction(e, n) : this.getTypeInfo(e.name) ? this._evalCreate(e, t) : (console.error(`Unknown function "${e.name}". Line ${e.line}`), null);
    for (let s = 0; s < i.node.args.length; ++s) {
      const l = i.node.args[s], o = this.evalExpression(e.args[s], n);
      n.createVariable(l.name, o, l);
    }
    return this._execStatements(i.node.body, n);
  }
  _callBuiltinFunction(e, t) {
    switch (e.name) {
      case "all":
        return this.builtins.All(e, t);
      case "any":
        return this.builtins.Any(e, t);
      case "select":
        return this.builtins.Select(e, t);
      case "arrayLength":
        return this.builtins.ArrayLength(e, t);
      case "abs":
        return this.builtins.Abs(e, t);
      case "acos":
        return this.builtins.Acos(e, t);
      case "acosh":
        return this.builtins.Acosh(e, t);
      case "asin":
        return this.builtins.Asin(e, t);
      case "asinh":
        return this.builtins.Asinh(e, t);
      case "atan":
        return this.builtins.Atan(e, t);
      case "atanh":
        return this.builtins.Atanh(e, t);
      case "atan2":
        return this.builtins.Atan2(e, t);
      case "ceil":
        return this.builtins.Ceil(e, t);
      case "clamp":
        return this.builtins.Clamp(e, t);
      case "cos":
        return this.builtins.Cos(e, t);
      case "cosh":
        return this.builtins.Cosh(e, t);
      case "countLeadingZeros":
        return this.builtins.CountLeadingZeros(e, t);
      case "countOneBits":
        return this.builtins.CountOneBits(e, t);
      case "countTrailingZeros":
        return this.builtins.CountTrailingZeros(e, t);
      case "cross":
        return this.builtins.Cross(e, t);
      case "degrees":
        return this.builtins.Degrees(e, t);
      case "determinant":
        return this.builtins.Determinant(e, t);
      case "distance":
        return this.builtins.Distance(e, t);
      case "dot":
        return this.builtins.Dot(e, t);
      case "dot4U8Packed":
        return this.builtins.Dot4U8Packed(e, t);
      case "dot4I8Packed":
        return this.builtins.Dot4I8Packed(e, t);
      case "exp":
        return this.builtins.Exp(e, t);
      case "exp2":
        return this.builtins.Exp2(e, t);
      case "extractBits":
        return this.builtins.ExtractBits(e, t);
      case "faceForward":
        return this.builtins.FaceForward(e, t);
      case "firstLeadingBit":
        return this.builtins.FirstLeadingBit(e, t);
      case "firstTrailingBit":
        return this.builtins.FirstTrailingBit(e, t);
      case "floor":
        return this.builtins.Floor(e, t);
      case "fma":
        return this.builtins.Fma(e, t);
      case "fract":
        return this.builtins.Fract(e, t);
      case "frexp":
        return this.builtins.Frexp(e, t);
      case "insertBits":
        return this.builtins.InsertBits(e, t);
      case "inverseSqrt":
        return this.builtins.InverseSqrt(e, t);
      case "ldexp":
        return this.builtins.Ldexp(e, t);
      case "length":
        return this.builtins.Length(e, t);
      case "log":
        return this.builtins.Log(e, t);
      case "log2":
        return this.builtins.Log2(e, t);
      case "max":
        return this.builtins.Max(e, t);
      case "min":
        return this.builtins.Min(e, t);
      case "mix":
        return this.builtins.Mix(e, t);
      case "modf":
        return this.builtins.Modf(e, t);
      case "normalize":
        return this.builtins.Normalize(e, t);
      case "pow":
        return this.builtins.Pow(e, t);
      case "quantizeToF16":
        return this.builtins.QuantizeToF16(e, t);
      case "radians":
        return this.builtins.Radians(e, t);
      case "reflect":
        return this.builtins.Reflect(e, t);
      case "refract":
        return this.builtins.Refract(e, t);
      case "reverseBits":
        return this.builtins.ReverseBits(e, t);
      case "round":
        return this.builtins.Round(e, t);
      case "saturate":
        return this.builtins.Saturate(e, t);
      case "sign":
        return this.builtins.Sign(e, t);
      case "sin":
        return this.builtins.Sin(e, t);
      case "sinh":
        return this.builtins.Sinh(e, t);
      case "smoothStep":
        return this.builtins.SmoothStep(e, t);
      case "sqrt":
        return this.builtins.Sqrt(e, t);
      case "step":
        return this.builtins.Step(e, t);
      case "tan":
        return this.builtins.Tan(e, t);
      case "tanh":
        return this.builtins.Tanh(e, t);
      case "transpose":
        return this.builtins.Transpose(e, t);
      case "trunc":
        return this.builtins.Trunc(e, t);
      case "dpdx":
        return this.builtins.Dpdx(e, t);
      case "dpdxCoarse":
        return this.builtins.DpdxCoarse(e, t);
      case "dpdxFine":
        return this.builtins.DpdxFine(e, t);
      case "dpdy":
        return this.builtins.Dpdy(e, t);
      case "dpdyCoarse":
        return this.builtins.DpdyCoarse(e, t);
      case "dpdyFine":
        return this.builtins.DpdyFine(e, t);
      case "fwidth":
        return this.builtins.Fwidth(e, t);
      case "fwidthCoarse":
        return this.builtins.FwidthCoarse(e, t);
      case "fwidthFine":
        return this.builtins.FwidthFine(e, t);
      case "textureDimensions":
        return this.builtins.TextureDimensions(e, t);
      case "textureGather":
        return this.builtins.TextureGather(e, t);
      case "textureGatherCompare":
        return this.builtins.TextureGatherCompare(e, t);
      case "textureLoad":
        return this.builtins.TextureLoad(e, t);
      case "textureNumLayers":
        return this.builtins.TextureNumLayers(e, t);
      case "textureNumLevels":
        return this.builtins.TextureNumLevels(e, t);
      case "textureNumSamples":
        return this.builtins.TextureNumSamples(e, t);
      case "textureSample":
        return this.builtins.TextureSample(e, t);
      case "textureSampleBias":
        return this.builtins.TextureSampleBias(e, t);
      case "textureSampleCompare":
        return this.builtins.TextureSampleCompare(e, t);
      case "textureSampleCompareLevel":
        return this.builtins.TextureSampleCompareLevel(e, t);
      case "textureSampleGrad":
        return this.builtins.TextureSampleGrad(e, t);
      case "textureSampleLevel":
        return this.builtins.TextureSampleLevel(e, t);
      case "textureSampleBaseClampToEdge":
        return this.builtins.TextureSampleBaseClampToEdge(e, t);
      case "textureStore":
        return this.builtins.TextureStore(e, t);
      case "atomicLoad":
        return this.builtins.AtomicLoad(e, t);
      case "atomicStore":
        return this.builtins.AtomicStore(e, t);
      case "atomicAdd":
        return this.builtins.AtomicAdd(e, t);
      case "atomicSub":
        return this.builtins.AtomicSub(e, t);
      case "atomicMax":
        return this.builtins.AtomicMax(e, t);
      case "atomicMin":
        return this.builtins.AtomicMin(e, t);
      case "atomicAnd":
        return this.builtins.AtomicAnd(e, t);
      case "atomicOr":
        return this.builtins.AtomicOr(e, t);
      case "atomicXor":
        return this.builtins.AtomicXor(e, t);
      case "atomicExchange":
        return this.builtins.AtomicExchange(e, t);
      case "atomicCompareExchangeWeak":
        return this.builtins.AtomicCompareExchangeWeak(e, t);
      case "pack4x8snorm":
        return this.builtins.Pack4x8snorm(e, t);
      case "pack4x8unorm":
        return this.builtins.Pack4x8unorm(e, t);
      case "pack4xI8":
        return this.builtins.Pack4xI8(e, t);
      case "pack4xU8":
        return this.builtins.Pack4xU8(e, t);
      case "pack4x8Clamp":
        return this.builtins.Pack4x8Clamp(e, t);
      case "pack4xU8Clamp":
        return this.builtins.Pack4xU8Clamp(e, t);
      case "pack2x16snorm":
        return this.builtins.Pack2x16snorm(e, t);
      case "pack2x16unorm":
        return this.builtins.Pack2x16unorm(e, t);
      case "pack2x16float":
        return this.builtins.Pack2x16float(e, t);
      case "unpack4x8snorm":
        return this.builtins.Unpack4x8snorm(e, t);
      case "unpack4x8unorm":
        return this.builtins.Unpack4x8unorm(e, t);
      case "unpack4xI8":
        return this.builtins.Unpack4xI8(e, t);
      case "unpack4xU8":
        return this.builtins.Unpack4xU8(e, t);
      case "unpack2x16snorm":
        return this.builtins.Unpack2x16snorm(e, t);
      case "unpack2x16unorm":
        return this.builtins.Unpack2x16unorm(e, t);
      case "unpack2x16float":
        return this.builtins.Unpack2x16float(e, t);
      case "storageBarrier":
        return this.builtins.StorageBarrier(e, t);
      case "textureBarrier":
        return this.builtins.TextureBarrier(e, t);
      case "workgroupBarrier":
        return this.builtins.WorkgroupBarrier(e, t);
      case "workgroupUniformLoad":
        return this.builtins.WorkgroupUniformLoad(e, t);
      case "subgroupAdd":
        return this.builtins.SubgroupAdd(e, t);
      case "subgroupExclusiveAdd":
        return this.builtins.SubgroupExclusiveAdd(e, t);
      case "subgroupInclusiveAdd":
        return this.builtins.SubgroupInclusiveAdd(e, t);
      case "subgroupAll":
        return this.builtins.SubgroupAll(e, t);
      case "subgroupAnd":
        return this.builtins.SubgroupAnd(e, t);
      case "subgroupAny":
        return this.builtins.SubgroupAny(e, t);
      case "subgroupBallot":
        return this.builtins.SubgroupBallot(e, t);
      case "subgroupBroadcast":
        return this.builtins.SubgroupBroadcast(e, t);
      case "subgroupBroadcastFirst":
        return this.builtins.SubgroupBroadcastFirst(e, t);
      case "subgroupElect":
        return this.builtins.SubgroupElect(e, t);
      case "subgroupMax":
        return this.builtins.SubgroupMax(e, t);
      case "subgroupMin":
        return this.builtins.SubgroupMin(e, t);
      case "subgroupMul":
        return this.builtins.SubgroupMul(e, t);
      case "subgroupExclusiveMul":
        return this.builtins.SubgroupExclusiveMul(e, t);
      case "subgroupInclusiveMul":
        return this.builtins.SubgroupInclusiveMul(e, t);
      case "subgroupOr":
        return this.builtins.SubgroupOr(e, t);
      case "subgroupShuffle":
        return this.builtins.SubgroupShuffle(e, t);
      case "subgroupShuffleDown":
        return this.builtins.SubgroupShuffleDown(e, t);
      case "subgroupShuffleUp":
        return this.builtins.SubgroupShuffleUp(e, t);
      case "subgroupShuffleXor":
        return this.builtins.SubgroupShuffleXor(e, t);
      case "subgroupXor":
        return this.builtins.SubgroupXor(e, t);
      case "quadBroadcast":
        return this.builtins.QuadBroadcast(e, t);
      case "quadSwapDiagonal":
        return this.builtins.QuadSwapDiagonal(e, t);
      case "quadSwapX":
        return this.builtins.QuadSwapX(e, t);
      case "quadSwapY":
        return this.builtins.QuadSwapY(e, t);
    }
    const n = t.getFunction(e.name);
    if (n) {
      const i = t.clone();
      for (let s = 0; s < n.node.args.length; ++s) {
        const l = n.node.args[s], o = this.evalExpression(e.args[s], i);
        i.setVariable(l.name, o, l);
      }
      return this._execStatements(n.node.body, i);
    }
    return null;
  }
  _callConstructorValue(e, t) {
    if (!e.args || e.args.length === 0) return new ut(0, this.getTypeInfo(e.type));
    const n = this.evalExpression(e.args[0], t);
    return n.typeInfo = this.getTypeInfo(e.type), n.getSubData(this, e.postfix, t).clone();
  }
  _callConstructorVec(e, t) {
    const n = this.getTypeInfo(e.type), i = e.type.getTypeName(), s = mb[i];
    if (s === void 0) return console.error(`Invalid vec constructor ${i}. Line ${e.line}`), null;
    const l = [];
    if (e instanceof eo)
      if (e.isVector) {
        const o = e.vectorValue;
        for (const d of o) l.push(d);
      } else l.push(e.scalarValue);
    else if (e.args) for (const o of e.args) {
      const d = this.evalExpression(o, t);
      if (d instanceof Ne) {
        const m = d.data;
        for (let b = 0; b < m.length; ++b) {
          let A = m[b];
          l.push(A);
        }
      } else if (d instanceof ut) {
        let m = d.value;
        l.push(m);
      }
    }
    if (e.type instanceof pt && e.type.format === null && (e.type.format = pt.f32), l.length === 0) {
      const o = new Array(s).fill(0);
      return new Ne(o, n).getSubData(this, e.postfix, t);
    }
    if (l.length === 1) for (; l.length < s; ) l.push(l[0]);
    return l.length < s ? (console.error(`Invalid vec constructor. Line ${e.line}`), null) : new Ne(l.length > s ? l.slice(0, s) : l, n).getSubData(this, e.postfix, t);
  }
  _callConstructorMatrix(e, t) {
    const n = this.getTypeInfo(e.type), i = e.type.getTypeName(), s = ba[i];
    if (s === void 0) return console.error(`Invalid matrix constructor ${i}. Line ${e.line}`), null;
    const l = [];
    if (e instanceof eo)
      if (e.isVector) {
        const o = e.vectorValue;
        for (const d of o) l.push(d);
      } else l.push(e.scalarValue);
    else if (e.args) for (const o of e.args) {
      const d = this.evalExpression(o, t);
      d instanceof Ne ? l.push(...d.data) : d instanceof ut ? l.push(d.value) : d instanceof tn && l.push(...d.data);
    }
    if (n instanceof Vf && n.format === null && (n.format = this.getTypeInfo("f32")), l.length === 0) {
      const o = new Array(s[2]).fill(0);
      return new tn(o, n).getSubData(this, e.postfix, t);
    }
    return l.length !== s[2] ? (console.error(`Invalid matrix constructor. Line ${e.line}`), null) : new tn(l, n).getSubData(this, e.postfix, t);
  }
}
Qo._breakObj = new zl(new Fl("BREAK", null), null), Qo._continueObj = new zl(new Fl("CONTINUE", null), null), Qo._priority = /* @__PURE__ */ new Map([["f32", 0], ["f16", 1], ["u32", 2], ["i32", 3], ["x32", 3]]);
class Ok {
  constructor() {
    this.constants = /* @__PURE__ */ new Map(), this.aliases = /* @__PURE__ */ new Map(), this.structs = /* @__PURE__ */ new Map();
  }
}
class kk {
  constructor() {
    this._tokens = [], this._current = 0, this._currentLine = 1, this._deferArrayCountEval = [], this._currentLoop = [], this._context = new Ok(), this._exec = new Qo(), this._forwardTypeCount = 0;
  }
  parse(e) {
    this._initialize(e), this._deferArrayCountEval.length = 0;
    const t = [];
    for (; !this._isAtEnd(); ) {
      const n = this._global_decl_or_directive();
      if (!n) break;
      t.push(n);
    }
    if (this._deferArrayCountEval.length > 0) {
      for (const n of this._deferArrayCountEval) {
        const i = n.arrayType, s = n.countNode;
        if (s instanceof gl) {
          const l = s.name, o = this._context.constants.get(l);
          if (o) try {
            const d = o.constEvaluate(this._exec);
            i.count = d;
          } catch {
          }
        }
      }
      this._deferArrayCountEval.length = 0;
    }
    if (this._forwardTypeCount > 0) for (const n of t) n.search((i) => {
      i instanceof lT || i instanceof u_ ? i.type = this._forwardType(i.type) : i instanceof bg ? i.format = this._forwardType(i.format) : i instanceof Yu || i instanceof yg || i instanceof c_ ? i.type = this._forwardType(i.type) : i instanceof Pg ? i.returnType = this._forwardType(i.returnType) : i instanceof aT && (i.type = this._forwardType(i.type));
    });
    return t;
  }
  _forwardType(e) {
    if (e instanceof oT) {
      const t = this._getType(e.name);
      if (t) return t;
    } else e instanceof u_ ? e.type = this._forwardType(e.type) : e instanceof bg && (e.format = this._forwardType(e.format));
    return e;
  }
  _initialize(e) {
    if (e)
      if (typeof e == "string") {
        const t = new Tk(e);
        this._tokens = t.scanTokens();
      } else this._tokens = e;
    else this._tokens = [];
    this._current = 0;
  }
  _updateNode(e, t) {
    return e.line = t ?? this._currentLine, e;
  }
  _error(e, t) {
    return {
      token: e,
      message: t,
      toString: () => `${t}`
    };
  }
  _isAtEnd() {
    return this._current >= this._tokens.length || this._peek().type == Ce.eof;
  }
  _match(e) {
    if (e instanceof ct) return !!this._check(e) && (this._advance(), !0);
    for (let t = 0, n = e.length; t < n; ++t) {
      const i = e[t];
      if (this._check(i)) return this._advance(), !0;
    }
    return !1;
  }
  _consume(e, t) {
    if (this._check(e)) return this._advance();
    throw this._error(this._peek(), `${t}. Line:${this._currentLine}`);
  }
  _check(e) {
    if (this._isAtEnd()) return !1;
    const t = this._peek();
    if (e instanceof Array) {
      const n = t.type;
      let i = !1;
      for (const s of e) {
        if (n === s) return !0;
        s === Ce.tokens.name && (i = !0);
      }
      if (i) {
        const s = Ce.tokens.name.rule.exec(t.lexeme);
        if (s && s.index == 0 && s[0] == t.lexeme) return !0;
      }
      return !1;
    }
    if (t.type === e) return !0;
    if (e === Ce.tokens.name) {
      const n = Ce.tokens.name.rule.exec(t.lexeme);
      return n && n.index == 0 && n[0] == t.lexeme;
    }
    return !1;
  }
  _advance() {
    var e, t;
    return this._currentLine = (t = (e = this._peek()) === null || e === void 0 ? void 0 : e.line) !== null && t !== void 0 ? t : -1, this._isAtEnd() || this._current++, this._previous();
  }
  _peek() {
    return this._tokens[this._current];
  }
  _previous() {
    return this._tokens[this._current - 1];
  }
  _global_decl_or_directive() {
    for (; this._match(Ce.tokens.semicolon) && !this._isAtEnd(); ) ;
    if (this._match(Ce.keywords.alias)) {
      const t = this._type_alias();
      return this._consume(Ce.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([t]), t;
    }
    if (this._match(Ce.keywords.diagnostic)) {
      const t = this._diagnostic();
      return this._consume(Ce.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([t]), t;
    }
    if (this._match(Ce.keywords.requires)) {
      const t = this._requires_directive();
      return this._consume(Ce.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([t]), t;
    }
    if (this._match(Ce.keywords.enable)) {
      const t = this._enable_directive();
      return this._consume(Ce.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([t]), t;
    }
    const e = this._attribute();
    if (this._check(Ce.keywords.var)) {
      const t = this._global_variable_decl();
      return t != null && (t.attributes = e), this._consume(Ce.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t]), t;
    }
    if (this._check(Ce.keywords.override)) {
      const t = this._override_variable_decl();
      return t != null && (t.attributes = e), this._consume(Ce.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t]), t;
    }
    if (this._check(Ce.keywords.let)) {
      const t = this._global_let_decl();
      return t != null && (t.attributes = e), this._consume(Ce.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t]), t;
    }
    if (this._check(Ce.keywords.const)) {
      const t = this._global_const_decl();
      return t != null && (t.attributes = e), this._consume(Ce.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t]), t;
    }
    if (this._check(Ce.keywords.struct)) {
      const t = this._struct_decl();
      return t != null && (t.attributes = e), this._exec.reflection.updateAST([t]), t;
    }
    if (this._check(Ce.keywords.fn)) {
      const t = this._function_decl();
      return t != null && (t.attributes = e), this._exec.reflection.updateAST([t]), t;
    }
    return null;
  }
  _function_decl() {
    if (!this._match(Ce.keywords.fn)) return null;
    const e = this._currentLine, t = this._consume(Ce.tokens.ident, "Expected function name.").toString();
    this._consume(Ce.tokens.paren_left, "Expected '(' for function arguments.");
    const n = [];
    if (!this._check(Ce.tokens.paren_right)) do {
      if (this._check(Ce.tokens.paren_right)) break;
      const o = this._attribute(), d = this._consume(Ce.tokens.name, "Expected argument name.").toString();
      this._consume(Ce.tokens.colon, "Expected ':' for argument type.");
      const m = this._attribute(), b = this._type_decl();
      b != null && (b.attributes = m, n.push(this._updateNode(new aT(d, b, o))));
    } while (this._match(Ce.tokens.comma));
    this._consume(Ce.tokens.paren_right, "Expected ')' after function arguments.");
    let i = null;
    if (this._match(Ce.tokens.arrow)) {
      const o = this._attribute();
      i = this._type_decl(), i != null && (i.attributes = o);
    }
    const s = this._compound_statement(), l = this._currentLine;
    return this._updateNode(new Pg(t, n, i, s, e, l), e);
  }
  _compound_statement() {
    const e = [];
    for (this._consume(Ce.tokens.brace_left, "Expected '{' for block."); !this._check(Ce.tokens.brace_right); ) {
      const t = this._statement();
      t !== null && e.push(t);
    }
    return this._consume(Ce.tokens.brace_right, "Expected '}' for block."), e;
  }
  _statement() {
    for (; this._match(Ce.tokens.semicolon) && !this._isAtEnd(); ) ;
    if (this._check(Ce.tokens.attr) && this._attribute(), this._check(Ce.keywords.if)) return this._if_statement();
    if (this._check(Ce.keywords.switch)) return this._switch_statement();
    if (this._check(Ce.keywords.loop)) return this._loop_statement();
    if (this._check(Ce.keywords.for)) return this._for_statement();
    if (this._check(Ce.keywords.while)) return this._while_statement();
    if (this._check(Ce.keywords.continuing)) return this._continuing_statement();
    if (this._check(Ce.keywords.static_assert)) return this._static_assert_statement();
    if (this._check(Ce.tokens.brace_left)) return this._compound_statement();
    let e = null;
    if (this._check(Ce.keywords.return)) e = this._return_statement();
    else if (this._check([Ce.keywords.var, Ce.keywords.let, Ce.keywords.const])) e = this._variable_statement();
    else if (this._match(Ce.keywords.discard)) e = this._updateNode(new xk());
    else if (this._match(Ce.keywords.break)) {
      const t = this._updateNode(new VC());
      if (this._currentLoop.length > 0) {
        const n = this._currentLoop[this._currentLoop.length - 1];
        t.loopId = n.id;
      }
      e = t, this._check(Ce.keywords.if) && (this._advance(), t.condition = this._optional_paren_expression());
    } else if (this._match(Ce.keywords.continue)) {
      const t = this._updateNode(new $C());
      if (!(this._currentLoop.length > 0)) throw this._error(this._peek(), `Continue statement must be inside a loop. Line: ${t.line}`);
      {
        const n = this._currentLoop[this._currentLoop.length - 1];
        t.loopId = n.id;
      }
      e = t;
    } else e = this._increment_decrement_statement() || this._func_call_statement() || this._assignment_statement();
    return e != null && this._consume(Ce.tokens.semicolon, "Expected ';' after statement."), e;
  }
  _static_assert_statement() {
    if (!this._match(Ce.keywords.static_assert)) return null;
    const e = this._currentLine, t = this._optional_paren_expression();
    return this._updateNode(new yk(t), e);
  }
  _while_statement() {
    if (!this._match(Ce.keywords.while)) return null;
    const e = this._updateNode(new LC(null, null));
    return this._currentLoop.push(e), e.condition = this._optional_paren_expression(), this._check(Ce.tokens.attr) && this._attribute(), e.body = this._compound_statement(), this._currentLoop.pop(), e;
  }
  _continuing_statement() {
    const e = this._currentLoop.length > 0 ? this._currentLoop[this._currentLoop.length - 1].id : -1;
    if (!this._match(Ce.keywords.continuing)) return null;
    const t = this._currentLine, n = this._compound_statement();
    return this._updateNode(new Y1(n, e), t);
  }
  _for_statement() {
    if (!this._match(Ce.keywords.for)) return null;
    this._consume(Ce.tokens.paren_left, "Expected '('.");
    const e = this._updateNode(new OC(null, null, null, null));
    return this._currentLoop.push(e), e.init = this._check(Ce.tokens.semicolon) ? null : this._for_init(), this._consume(Ce.tokens.semicolon, "Expected ';'."), e.condition = this._check(Ce.tokens.semicolon) ? null : this._short_circuit_or_expression(), this._consume(Ce.tokens.semicolon, "Expected ';'."), e.increment = this._check(Ce.tokens.paren_right) ? null : this._for_increment(), this._consume(Ce.tokens.paren_right, "Expected ')'."), this._check(Ce.tokens.attr) && this._attribute(), e.body = this._compound_statement(), this._currentLoop.pop(), e;
  }
  _for_init() {
    return this._variable_statement() || this._func_call_statement() || this._assignment_statement();
  }
  _for_increment() {
    return this._func_call_statement() || this._increment_decrement_statement() || this._assignment_statement();
  }
  _variable_statement() {
    if (this._check(Ce.keywords.var)) {
      const e = this._variable_decl();
      if (e === null) throw this._error(this._peek(), "Variable declaration expected.");
      let t = null;
      return this._match(Ce.tokens.equal) && (t = this._short_circuit_or_expression()), this._updateNode(new Yu(e.name, e.type, e.storage, e.access, t), e.line);
    }
    if (this._match(Ce.keywords.let)) {
      const e = this._currentLine, t = this._consume(Ce.tokens.name, "Expected name for let.").toString();
      let n = null;
      if (this._match(Ce.tokens.colon)) {
        const s = this._attribute();
        n = this._type_decl(), n != null && (n.attributes = s);
      }
      this._consume(Ce.tokens.equal, "Expected '=' for let.");
      const i = this._short_circuit_or_expression();
      return this._updateNode(new yg(t, n, null, null, i), e);
    }
    if (this._match(Ce.keywords.const)) {
      const e = this._currentLine, t = this._consume(Ce.tokens.name, "Expected name for const.").toString();
      let n = null;
      if (this._match(Ce.tokens.colon)) {
        const s = this._attribute();
        n = this._type_decl(), n != null && (n.attributes = s);
      }
      this._consume(Ce.tokens.equal, "Expected '=' for const.");
      const i = this._short_circuit_or_expression();
      return n === null && i instanceof eo && (n = i.type), this._updateNode(new c_(t, n, null, null, i), e);
    }
    return null;
  }
  _increment_decrement_statement() {
    const e = this._current, t = this._unary_expression();
    if (t == null) return null;
    if (!this._check(Ce.increment_operators)) return this._current = e, null;
    const n = this._consume(Ce.increment_operators, "Expected increment operator");
    return this._updateNode(new kC(n.type === Ce.tokens.plus_plus ? kd.increment : kd.decrement, t));
  }
  _assignment_statement() {
    let e = null;
    const t = this._currentLine;
    if (this._check(Ce.tokens.brace_right)) return null;
    let n = this._match(Ce.tokens.underscore);
    if (n || (e = this._unary_expression()), !n && e == null) return null;
    const i = this._consume(Ce.assignment_operators, "Expected assignment operator."), s = this._short_circuit_or_expression();
    return this._updateNode(new NC(ag.parse(i.lexeme), e, s), t);
  }
  _func_call_statement() {
    if (!this._check(Ce.tokens.ident)) return null;
    const e = this._currentLine, t = this._current, n = this._consume(Ce.tokens.ident, "Expected function name."), i = this._argument_expression_list();
    return i === null ? (this._current = t, null) : this._updateNode(new w2(n.lexeme, i), e);
  }
  _loop_statement() {
    if (!this._match(Ce.keywords.loop)) return null;
    this._check(Ce.tokens.attr) && this._attribute(), this._consume(Ce.tokens.brace_left, "Expected '{' for loop.");
    const e = this._updateNode(new DC([], null));
    this._currentLoop.push(e);
    let t = this._statement();
    for (; t !== null; ) {
      if (Array.isArray(t)) for (let n of t) e.body.push(n);
      else e.body.push(t);
      if (t instanceof Y1) {
        e.continuing = t;
        break;
      }
      t = this._statement();
    }
    return this._currentLoop.pop(), this._consume(Ce.tokens.brace_right, "Expected '}' for loop."), e;
  }
  _switch_statement() {
    if (!this._match(Ce.keywords.switch)) return null;
    const e = this._updateNode(new FC(null, []));
    if (this._currentLoop.push(e), e.condition = this._optional_paren_expression(), this._check(Ce.tokens.attr) && this._attribute(), this._consume(Ce.tokens.brace_left, "Expected '{' for switch."), e.cases = this._switch_body(), e.cases == null || e.cases.length == 0) throw this._error(this._previous(), "Expected 'case' or 'default'.");
    return this._consume(Ce.tokens.brace_right, "Expected '}' for switch."), this._currentLoop.pop(), e;
  }
  _switch_body() {
    const e = [];
    let t = !1;
    for (; this._check([Ce.keywords.default, Ce.keywords.case]); ) {
      if (this._match(Ce.keywords.case)) {
        const n = this._case_selectors();
        for (const s of n) if (s instanceof h_) {
          if (t) throw this._error(this._previous(), "Multiple default cases in switch statement.");
          t = !0;
          break;
        }
        this._match(Ce.tokens.colon), this._check(Ce.tokens.attr) && this._attribute(), this._consume(Ce.tokens.brace_left, "Exected '{' for switch case.");
        const i = this._case_body();
        this._consume(Ce.tokens.brace_right, "Exected '}' for switch case."), e.push(this._updateNode(new XC(n, i)));
      }
      if (this._match(Ce.keywords.default)) {
        if (t) throw this._error(this._previous(), "Multiple default cases in switch statement.");
        this._match(Ce.tokens.colon), this._check(Ce.tokens.attr) && this._attribute(), this._consume(Ce.tokens.brace_left, "Exected '{' for switch default.");
        const n = this._case_body();
        this._consume(Ce.tokens.brace_right, "Exected '}' for switch default."), e.push(this._updateNode(new ZC(n)));
      }
    }
    return e;
  }
  _case_selectors() {
    const e = [];
    for (this._match(Ce.keywords.default) ? e.push(this._updateNode(new h_())) : e.push(this._shift_expression()); this._match(Ce.tokens.comma); ) this._match(Ce.keywords.default) ? e.push(this._updateNode(new h_())) : e.push(this._shift_expression());
    return e;
  }
  _case_body() {
    if (this._match(Ce.keywords.fallthrough)) return this._consume(Ce.tokens.semicolon, "Expected ';'"), [];
    let e = this._statement();
    if (e == null) return [];
    e instanceof Array || (e = [e]);
    const t = this._case_body();
    return t.length == 0 ? e : [...e, t[0]];
  }
  _if_statement() {
    if (!this._match(Ce.keywords.if)) return null;
    const e = this._currentLine, t = this._optional_paren_expression();
    this._check(Ce.tokens.attr) && this._attribute();
    const n = this._compound_statement();
    let i = [];
    this._match_elseif() && (this._check(Ce.tokens.attr) && this._attribute(), i = this._elseif_statement(i));
    let s = null;
    return this._match(Ce.keywords.else) && (this._check(Ce.tokens.attr) && this._attribute(), s = this._compound_statement()), this._updateNode(new UC(t, n, i, s), e);
  }
  _match_elseif() {
    return this._tokens[this._current].type === Ce.keywords.else && this._tokens[this._current + 1].type === Ce.keywords.if && (this._advance(), this._advance(), !0);
  }
  _elseif_statement() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const t = this._optional_paren_expression(), n = this._compound_statement();
    return e.push(this._updateNode(new wk(t, n))), this._match_elseif() && (this._check(Ce.tokens.attr) && this._attribute(), this._elseif_statement(e)), e;
  }
  _return_statement() {
    if (!this._match(Ce.keywords.return)) return null;
    const e = this._short_circuit_or_expression();
    return this._updateNode(new zC(e));
  }
  _short_circuit_or_expression() {
    let e = this._short_circuit_and_expr();
    for (; this._match(Ce.tokens.or_or); ) e = this._updateNode(new yc(this._previous().toString(), e, this._short_circuit_and_expr()));
    return e;
  }
  _short_circuit_and_expr() {
    let e = this._inclusive_or_expression();
    for (; this._match(Ce.tokens.and_and); ) e = this._updateNode(new yc(this._previous().toString(), e, this._inclusive_or_expression()));
    return e;
  }
  _inclusive_or_expression() {
    let e = this._exclusive_or_expression();
    for (; this._match(Ce.tokens.or); ) e = this._updateNode(new yc(this._previous().toString(), e, this._exclusive_or_expression()));
    return e;
  }
  _exclusive_or_expression() {
    let e = this._and_expression();
    for (; this._match(Ce.tokens.xor); ) e = this._updateNode(new yc(this._previous().toString(), e, this._and_expression()));
    return e;
  }
  _and_expression() {
    let e = this._equality_expression();
    for (; this._match(Ce.tokens.and); ) e = this._updateNode(new yc(this._previous().toString(), e, this._equality_expression()));
    return e;
  }
  _equality_expression() {
    const e = this._relational_expression();
    return this._match([Ce.tokens.equal_equal, Ce.tokens.not_equal]) ? this._updateNode(new yc(this._previous().toString(), e, this._relational_expression())) : e;
  }
  _relational_expression() {
    let e = this._shift_expression();
    for (; this._match([Ce.tokens.less_than, Ce.tokens.greater_than, Ce.tokens.less_than_equal, Ce.tokens.greater_than_equal]); ) e = this._updateNode(new yc(this._previous().toString(), e, this._shift_expression()));
    return e;
  }
  _shift_expression() {
    let e = this._additive_expression();
    for (; this._match([Ce.tokens.shift_left, Ce.tokens.shift_right]); ) e = this._updateNode(new yc(this._previous().toString(), e, this._additive_expression()));
    return e;
  }
  _additive_expression() {
    let e = this._multiplicative_expression();
    for (; this._match([Ce.tokens.plus, Ce.tokens.minus]); ) e = this._updateNode(new yc(this._previous().toString(), e, this._multiplicative_expression()));
    return e;
  }
  _multiplicative_expression() {
    let e = this._unary_expression();
    for (; this._match([Ce.tokens.star, Ce.tokens.forward_slash, Ce.tokens.modulo]); ) e = this._updateNode(new yc(this._previous().toString(), e, this._unary_expression()));
    return e;
  }
  _unary_expression() {
    return this._match([Ce.tokens.minus, Ce.tokens.bang, Ce.tokens.tilde, Ce.tokens.star, Ce.tokens.and]) ? this._updateNode(new Us(this._previous().toString(), this._unary_expression())) : this._singular_expression();
  }
  _singular_expression() {
    const e = this._primary_expression(), t = this._postfix_expression();
    return t && (e.postfix = t), e;
  }
  _postfix_expression() {
    if (this._match(Ce.tokens.bracket_left)) {
      const e = this._short_circuit_or_expression();
      this._consume(Ce.tokens.bracket_right, "Expected ']'.");
      const t = this._updateNode(new ip(e)), n = this._postfix_expression();
      return n && (t.postfix = n), t;
    }
    if (this._match(Ce.tokens.period)) {
      const e = this._consume(Ce.tokens.name, "Expected member name."), t = this._postfix_expression(), n = this._updateNode(new $f(e.lexeme));
      return t && (n.postfix = t), n;
    }
    return null;
  }
  _getStruct(e) {
    return this._context.aliases.has(e) ? this._context.aliases.get(e).type : this._context.structs.has(e) ? this._context.structs.get(e) : null;
  }
  _getType(e) {
    const t = this._getStruct(e);
    if (t !== null) return t;
    switch (e) {
      case "void":
        return Xt.void;
      case "bool":
        return Xt.bool;
      case "i32":
        return Xt.i32;
      case "u32":
        return Xt.u32;
      case "f32":
        return Xt.f32;
      case "f16":
        return Xt.f16;
      case "vec2f":
        return pt.vec2f;
      case "vec3f":
        return pt.vec3f;
      case "vec4f":
        return pt.vec4f;
      case "vec2i":
        return pt.vec2i;
      case "vec3i":
        return pt.vec3i;
      case "vec4i":
        return pt.vec4i;
      case "vec2u":
        return pt.vec2u;
      case "vec3u":
        return pt.vec3u;
      case "vec4u":
        return pt.vec4u;
      case "vec2h":
        return pt.vec2h;
      case "vec3h":
        return pt.vec3h;
      case "vec4h":
        return pt.vec4h;
      case "mat2x2f":
        return pt.mat2x2f;
      case "mat2x3f":
        return pt.mat2x3f;
      case "mat2x4f":
        return pt.mat2x4f;
      case "mat3x2f":
        return pt.mat3x2f;
      case "mat3x3f":
        return pt.mat3x3f;
      case "mat3x4f":
        return pt.mat3x4f;
      case "mat4x2f":
        return pt.mat4x2f;
      case "mat4x3f":
        return pt.mat4x3f;
      case "mat4x4f":
        return pt.mat4x4f;
      case "mat2x2h":
        return pt.mat2x2h;
      case "mat2x3h":
        return pt.mat2x3h;
      case "mat2x4h":
        return pt.mat2x4h;
      case "mat3x2h":
        return pt.mat3x2h;
      case "mat3x3h":
        return pt.mat3x3h;
      case "mat3x4h":
        return pt.mat3x4h;
      case "mat4x2h":
        return pt.mat4x2h;
      case "mat4x3h":
        return pt.mat4x3h;
      case "mat4x4h":
        return pt.mat4x4h;
      case "mat2x2i":
        return pt.mat2x2i;
      case "mat2x3i":
        return pt.mat2x3i;
      case "mat2x4i":
        return pt.mat2x4i;
      case "mat3x2i":
        return pt.mat3x2i;
      case "mat3x3i":
        return pt.mat3x3i;
      case "mat3x4i":
        return pt.mat3x4i;
      case "mat4x2i":
        return pt.mat4x2i;
      case "mat4x3i":
        return pt.mat4x3i;
      case "mat4x4i":
        return pt.mat4x4i;
      case "mat2x2u":
        return pt.mat2x2u;
      case "mat2x3u":
        return pt.mat2x3u;
      case "mat2x4u":
        return pt.mat2x4u;
      case "mat3x2u":
        return pt.mat3x2u;
      case "mat3x3u":
        return pt.mat3x3u;
      case "mat3x4u":
        return pt.mat3x4u;
      case "mat4x2u":
        return pt.mat4x2u;
      case "mat4x3u":
        return pt.mat4x3u;
      case "mat4x4u":
        return pt.mat4x4u;
    }
    return null;
  }
  _validateTypeRange(e, t) {
    if (t.name === "i32") {
      if (e < -2147483648 || e > 2147483647) throw this._error(this._previous(), `Value out of range for i32: ${e}. Line: ${this._currentLine}.`);
    } else if (t.name === "u32" && (e < 0 || e > 4294967295)) throw this._error(this._previous(), `Value out of range for u32: ${e}. Line: ${this._currentLine}.`);
  }
  _primary_expression() {
    if (this._match(Ce.tokens.ident)) {
      const n = this._previous().toString();
      if (this._check(Ce.tokens.paren_left)) {
        const i = this._argument_expression_list(), s = this._getType(n);
        return s !== null ? this._updateNode(new hu(s, i)) : this._updateNode(new T2(n, i));
      }
      if (this._context.constants.has(n)) {
        const i = this._context.constants.get(n);
        return this._updateNode(new qC(n, i.value));
      }
      return this._updateNode(new gl(n));
    }
    if (this._match(Ce.tokens.int_literal)) {
      const n = this._previous().toString();
      let i = n.endsWith("i") || n.endsWith("i") ? Xt.i32 : n.endsWith("u") || n.endsWith("U") ? Xt.u32 : Xt.x32;
      const s = parseInt(n);
      return this._validateTypeRange(s, i), this._updateNode(new eo(new ut(s, this._exec.getTypeInfo(i)), i));
    }
    if (this._match(Ce.tokens.uint_literal)) {
      const n = parseInt(this._previous().toString());
      return this._validateTypeRange(n, Xt.u32), this._updateNode(new eo(new ut(n, this._exec.getTypeInfo(Xt.u32)), Xt.u32));
    }
    if (this._match([Ce.tokens.decimal_float_literal, Ce.tokens.hex_float_literal])) {
      let n = this._previous().toString(), i = n.endsWith("h");
      i && (n = n.substring(0, n.length - 1));
      const s = parseFloat(n);
      this._validateTypeRange(s, i ? Xt.f16 : Xt.f32);
      const l = i ? Xt.f16 : Xt.f32;
      return this._updateNode(new eo(new ut(s, this._exec.getTypeInfo(l)), l));
    }
    if (this._match([Ce.keywords.true, Ce.keywords.false])) {
      let n = this._previous().toString() === Ce.keywords.true.rule;
      return this._updateNode(new eo(new ut(n ? 1 : 0, this._exec.getTypeInfo(Xt.bool)), Xt.bool));
    }
    if (this._check(Ce.tokens.paren_left)) return this._paren_expression();
    if (this._match(Ce.keywords.bitcast)) {
      this._consume(Ce.tokens.less_than, "Expected '<'.");
      const n = this._type_decl();
      this._consume(Ce.tokens.greater_than, "Expected '>'.");
      const i = this._paren_expression();
      return this._updateNode(new GC(n, i));
    }
    const e = this._type_decl(), t = this._argument_expression_list();
    return this._updateNode(new hu(e, t));
  }
  _argument_expression_list() {
    if (!this._match(Ce.tokens.paren_left)) return null;
    const e = [];
    do {
      if (this._check(Ce.tokens.paren_right)) break;
      const t = this._short_circuit_or_expression();
      e.push(t);
    } while (this._match(Ce.tokens.comma));
    return this._consume(Ce.tokens.paren_right, "Expected ')' for agument list"), e;
  }
  _optional_paren_expression() {
    this._match(Ce.tokens.paren_left);
    const e = this._short_circuit_or_expression();
    return this._match(Ce.tokens.paren_right), e;
  }
  _paren_expression() {
    this._consume(Ce.tokens.paren_left, "Expected '('.");
    const e = this._short_circuit_or_expression();
    return this._consume(Ce.tokens.paren_right, "Expected ')'."), e;
  }
  _struct_decl() {
    if (!this._match(Ce.keywords.struct)) return null;
    const e = this._currentLine, t = this._consume(Ce.tokens.ident, "Expected name for struct.").toString();
    this._consume(Ce.tokens.brace_left, "Expected '{' for struct body.");
    const n = [];
    for (; !this._check(Ce.tokens.brace_right); ) {
      const l = this._attribute(), o = this._consume(Ce.tokens.name, "Expected variable name.").toString();
      this._consume(Ce.tokens.colon, "Expected ':' for struct member type.");
      const d = this._attribute(), m = this._type_decl();
      m != null && (m.attributes = d), this._check(Ce.tokens.brace_right) ? this._match(Ce.tokens.comma) : this._consume(Ce.tokens.comma, "Expected ',' for struct member."), n.push(this._updateNode(new lT(o, m, l)));
    }
    this._consume(Ce.tokens.brace_right, "Expected '}' after struct body.");
    const i = this._currentLine, s = this._updateNode(new Xu(t, n, e, i), e);
    return this._context.structs.set(t, s), s;
  }
  _global_variable_decl() {
    const e = this._variable_decl();
    if (!e) return null;
    if (this._match(Ce.tokens.equal)) {
      const t = this._const_expression();
      e.value = t;
    }
    if (e.type !== null && e.value instanceof eo) {
      if (e.value.type.name !== "x32" && e.type.getTypeName() !== e.value.type.getTypeName())
        throw this._error(this._peek(), `Invalid cast from ${e.value.type.name} to ${e.type.name}. Line:${this._currentLine}`);
      e.value.isScalar && this._validateTypeRange(e.value.scalarValue, e.type), e.value.type = e.type;
    } else e.type === null && e.value instanceof eo && (e.type = e.value.type.name === "x32" ? Xt.i32 : e.value.type, e.value.isScalar && this._validateTypeRange(e.value.scalarValue, e.type));
    return e;
  }
  _override_variable_decl() {
    const e = this._override_decl();
    return e && this._match(Ce.tokens.equal) && (e.value = this._const_expression()), e;
  }
  _global_const_decl() {
    var e;
    if (!this._match(Ce.keywords.const)) return null;
    const t = this._consume(Ce.tokens.name, "Expected variable name"), n = this._currentLine;
    let i = null;
    if (this._match(Ce.tokens.colon)) {
      const d = this._attribute();
      i = this._type_decl(), i != null && (i.attributes = d);
    }
    let s = null;
    this._consume(Ce.tokens.equal, "const declarations require an assignment");
    const l = this._short_circuit_or_expression();
    try {
      let d = [Xt.f32], m = l.constEvaluate(this._exec, d);
      m instanceof ut && this._validateTypeRange(m.value, d[0]), d[0] instanceof pt && d[0].format === null && m.typeInfo instanceof Vf && m.typeInfo.format !== null && (m.typeInfo.format.name === "f16" ? d[0].format = Xt.f16 : m.typeInfo.format.name === "f32" ? d[0].format = Xt.f32 : m.typeInfo.format.name === "i32" ? d[0].format = Xt.i32 : m.typeInfo.format.name === "u32" ? d[0].format = Xt.u32 : m.typeInfo.format.name === "bool" ? d[0].format = Xt.bool : console.error(`TODO: impelement template format type ${m.typeInfo.format.name}`)), s = this._updateNode(new eo(m, d[0])), this._exec.context.setVariable(t.toString(), m);
    } catch {
      s = l;
    }
    if (i !== null && s instanceof eo) {
      if (s.type.name !== "x32" && i.getTypeName() !== s.type.getTypeName())
        throw this._error(this._peek(), `Invalid cast from ${s.type.name} to ${i.name}. Line:${this._currentLine}`);
      s.type = i, s.isScalar && this._validateTypeRange(s.scalarValue, s.type);
    } else i === null && s instanceof eo && (i = (e = s == null ? void 0 : s.type) !== null && e !== void 0 ? e : Xt.f32, i === Xt.x32 && (i = Xt.i32));
    const o = this._updateNode(new c_(t.toString(), i, "", "", s), n);
    return this._context.constants.set(o.name, o), o;
  }
  _global_let_decl() {
    if (!this._match(Ce.keywords.let)) return null;
    const e = this._currentLine, t = this._consume(Ce.tokens.name, "Expected variable name");
    let n = null;
    if (this._match(Ce.tokens.colon)) {
      const s = this._attribute();
      n = this._type_decl(), n != null && (n.attributes = s);
    }
    let i = null;
    if (this._match(Ce.tokens.equal) && (i = this._const_expression()), n !== null && i instanceof eo) {
      if (i.type.name !== "x32" && n.getTypeName() !== i.type.getTypeName())
        throw this._error(this._peek(), `Invalid cast from ${i.type.name} to ${n.name}. Line:${this._currentLine}`);
      i.type = n;
    } else n === null && i instanceof eo && (n = i.type.name === "x32" ? Xt.i32 : i.type);
    return i instanceof eo && i.isScalar && this._validateTypeRange(i.scalarValue, n), this._updateNode(new yg(t.toString(), n, "", "", i), e);
  }
  _const_expression() {
    return this._short_circuit_or_expression();
  }
  _variable_decl() {
    if (!this._match(Ce.keywords.var)) return null;
    const e = this._currentLine;
    let t = "", n = "";
    this._match(Ce.tokens.less_than) && (t = this._consume(Ce.storage_class, "Expected storage_class.").toString(), this._match(Ce.tokens.comma) && (n = this._consume(Ce.access_mode, "Expected access_mode.").toString()), this._consume(Ce.tokens.greater_than, "Expected '>'."));
    const i = this._consume(Ce.tokens.name, "Expected variable name");
    let s = null;
    if (this._match(Ce.tokens.colon)) {
      const l = this._attribute();
      s = this._type_decl(), s != null && (s.attributes = l);
    }
    return this._updateNode(new Yu(i.toString(), s, t, n, null), e);
  }
  _override_decl() {
    if (!this._match(Ce.keywords.override)) return null;
    const e = this._consume(Ce.tokens.name, "Expected variable name");
    let t = null;
    if (this._match(Ce.tokens.colon)) {
      const n = this._attribute();
      t = this._type_decl(), t != null && (t.attributes = n);
    }
    return this._updateNode(new x2(e.toString(), t, null));
  }
  _diagnostic() {
    this._consume(Ce.tokens.paren_left, "Expected '('");
    const e = this._consume(Ce.tokens.ident, "Expected severity control name.");
    this._consume(Ce.tokens.comma, "Expected ','");
    let t = this._consume(Ce.tokens.ident, "Expected diagnostic rule name.").toString();
    return this._match(Ce.tokens.period) && (t += `.${this._consume(Ce.tokens.ident, "Expected diagnostic message.").toString()}`), this._consume(Ce.tokens.paren_right, "Expected ')'"), this._updateNode(new jC(e.toString(), t));
  }
  _enable_directive() {
    const e = this._consume(Ce.tokens.ident, "identity expected.");
    return this._updateNode(new bk(e.toString()));
  }
  _requires_directive() {
    const e = [this._consume(Ce.tokens.ident, "identity expected.").toString()];
    for (; this._match(Ce.tokens.comma); ) {
      const t = this._consume(Ce.tokens.ident, "identity expected.");
      e.push(t.toString());
    }
    return this._updateNode(new vk(e));
  }
  _type_alias() {
    const e = this._consume(Ce.tokens.ident, "identity expected.");
    this._consume(Ce.tokens.equal, "Expected '=' for type alias.");
    let t = this._type_decl();
    if (t === null) throw this._error(this._peek(), "Expected Type for Alias.");
    this._context.aliases.has(t.name) && (t = this._context.aliases.get(t.name).type);
    const n = this._updateNode(new A2(e.toString(), t));
    return this._context.aliases.set(n.name, n), n;
  }
  _type_decl() {
    if (this._check([Ce.tokens.ident, ...Ce.texel_format, Ce.keywords.bool, Ce.keywords.f32, Ce.keywords.i32, Ce.keywords.u32])) {
      const n = this._advance().toString();
      if (this._context.structs.has(n)) return this._context.structs.get(n);
      if (this._context.aliases.has(n)) return this._context.aliases.get(n).type;
      if (!this._getType(n)) {
        const i = this._updateNode(new oT(n));
        return this._forwardTypeCount++, i;
      }
      return this._updateNode(new Xt(n));
    }
    let e = this._texture_sampler_types();
    if (e) return e;
    if (this._check(Ce.template_types)) {
      let n = this._advance().toString(), i = null, s = null;
      return this._match(Ce.tokens.less_than) && (i = this._type_decl(), s = null, this._match(Ce.tokens.comma) && (s = this._consume(Ce.access_mode, "Expected access_mode for pointer").toString()), this._consume(Ce.tokens.greater_than, "Expected '>' for type.")), this._updateNode(new pt(n, i, s));
    }
    if (this._match(Ce.keywords.ptr)) {
      let n = this._previous().toString();
      this._consume(Ce.tokens.less_than, "Expected '<' for pointer.");
      const i = this._consume(Ce.storage_class, "Expected storage_class for pointer");
      this._consume(Ce.tokens.comma, "Expected ',' for pointer.");
      const s = this._type_decl();
      let l = null;
      return this._match(Ce.tokens.comma) && (l = this._consume(Ce.access_mode, "Expected access_mode for pointer").toString()), this._consume(Ce.tokens.greater_than, "Expected '>' for pointer."), this._updateNode(new u_(n, i.toString(), s, l));
    }
    const t = this._attribute();
    if (this._match(Ce.keywords.array)) {
      let n = null, i = -1;
      const s = this._previous();
      let l = null;
      if (this._match(Ce.tokens.less_than)) {
        n = this._type_decl(), this._context.aliases.has(n.name) && (n = this._context.aliases.get(n.name).type);
        let d = "";
        if (this._match(Ce.tokens.comma)) {
          l = this._shift_expression();
          try {
            d = l.constEvaluate(this._exec).toString(), l = null;
          } catch {
            d = "1";
          }
        }
        this._consume(Ce.tokens.greater_than, "Expected '>' for array."), i = d ? parseInt(d) : 0;
      }
      const o = this._updateNode(new bg(s.toString(), t, n, i));
      return l && this._deferArrayCountEval.push({
        arrayType: o,
        countNode: l
      }), o;
    }
    return null;
  }
  _texture_sampler_types() {
    if (this._match(Ce.sampler_type)) return this._updateNode(new lg(this._previous().toString(), null, null));
    if (this._match(Ce.depth_texture_type)) return this._updateNode(new lg(this._previous().toString(), null, null));
    if (this._match(Ce.sampled_texture_type) || this._match(Ce.multisampled_texture_type)) {
      const e = this._previous();
      this._consume(Ce.tokens.less_than, "Expected '<' for sampler type.");
      const t = this._type_decl();
      return this._consume(Ce.tokens.greater_than, "Expected '>' for sampler type."), this._updateNode(new lg(e.toString(), t, null));
    }
    if (this._match(Ce.storage_texture_type)) {
      const e = this._previous();
      this._consume(Ce.tokens.less_than, "Expected '<' for sampler type.");
      const t = this._consume(Ce.texel_format, "Invalid texel format.").toString();
      this._consume(Ce.tokens.comma, "Expected ',' after texel format.");
      const n = this._consume(Ce.access_mode, "Expected access mode for storage texture type.").toString();
      return this._consume(Ce.tokens.greater_than, "Expected '>' for sampler type."), this._updateNode(new lg(e.toString(), t, n));
    }
    return null;
  }
  _attribute() {
    let e = [];
    for (; this._match(Ce.tokens.attr); ) {
      const t = this._consume(Ce.attribute_name, "Expected attribute name"), n = this._updateNode(new YC(t.toString(), null));
      if (this._match(Ce.tokens.paren_left)) {
        if (n.value = this._consume(Ce.literal_or_ident, "Expected attribute value").toString(), this._check(Ce.tokens.comma)) {
          this._advance();
          do {
            const i = this._consume(Ce.literal_or_ident, "Expected attribute value").toString();
            n.value instanceof Array || (n.value = [n.value]), n.value.push(i);
          } while (this._match(Ce.tokens.comma));
        }
        this._consume(Ce.tokens.paren_right, "Expected ')'");
      }
      e.push(n);
    }
    return e.length == 0 ? null : e;
  }
}
class Nk extends gu {
  constructor(e) {
    super(), e && this.update(e);
  }
  update(e) {
    const t = new kk().parse(e);
    this.updateAST(t);
  }
}
function Dk(r) {
  var s;
  const e = {
    attributes: [],
    bindings: []
  };
  let t;
  try {
    t = Fk(r);
  } catch (l) {
    return cr.error(l.message)(), e;
  }
  for (const l of t.uniforms) {
    const o = [];
    for (const d of ((s = l.type) == null ? void 0 : s.members) || [])
      o.push({
        name: d.name,
        type: hT(d.type)
      });
    e.bindings.push({
      type: "uniform",
      name: l.name,
      group: l.group,
      location: l.binding,
      // @ts-expect-error TODO - unused for now but needs fixing
      members: o
    });
  }
  for (const l of t.textures)
    e.bindings.push({
      type: "texture",
      name: l.name,
      group: l.group,
      location: l.binding
    });
  for (const l of t.samplers)
    e.bindings.push({
      type: "sampler",
      name: l.name,
      group: l.group,
      location: l.binding
    });
  const n = t.entry.vertex[0], i = (n == null ? void 0 : n.inputs.length) || 0;
  for (let l = 0; l < i; l++) {
    const o = n.inputs[l];
    if (o.locationType === "location") {
      const d = hT(o.type);
      e.attributes.push({
        name: o.name,
        location: Number(o.location),
        type: d
      });
    }
  }
  return e;
}
function hT(r) {
  return r.format ? `${r.name}<${r.format.name}>` : r.name;
}
function Fk(r) {
  try {
    return new Nk(r);
  } catch (e) {
    if (e instanceof Error)
      throw e;
    let t = "WGSL parse error";
    throw typeof e == "object" && (e != null && e.message) && (t += `: ${e.message} `), typeof e == "object" && (e != null && e.token) && (t += e.token.line || ""), new Error(t, {
      cause: e
    });
  }
}
const Uk = 1 / Math.PI * 180, zk = 1 / 180 * Math.PI, jk = {
  EPSILON: 1e-12,
  debug: !1,
  precision: 4,
  printTypes: !1,
  printDegrees: !1,
  printRowMajor: !0,
  _cartographicRadians: !1
};
globalThis.mathgl = globalThis.mathgl || {
  config: {
    ...jk
  }
};
const no = globalThis.mathgl.config;
function Vk(r) {
  let {
    precision: e = no.precision
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return r = Hk(r), `${parseFloat(r.toPrecision(e))}`;
}
function Wh(r) {
  return Array.isArray(r) || ArrayBuffer.isView(r) && !(r instanceof DataView);
}
function $k(r) {
  return Gk(r);
}
function qk(r) {
  return wc(r);
}
function Gk(r, e) {
  return M2(r, (t) => t * zk, e);
}
function wc(r, e) {
  return M2(r, (t) => t * Uk, e);
}
function Sc(r, e, t) {
  return M2(r, (n) => Math.max(e, Math.min(t, n)));
}
function K_(r, e, t) {
  return Wh(r) ? r.map((n, i) => K_(n, e[i], t)) : t * e + (1 - t) * r;
}
function Mc(r, e, t) {
  const n = no.EPSILON;
  t && (no.EPSILON = t);
  try {
    if (r === e)
      return !0;
    if (Wh(r) && Wh(e)) {
      if (r.length !== e.length)
        return !1;
      for (let i = 0; i < r.length; ++i)
        if (!Mc(r[i], e[i]))
          return !1;
      return !0;
    }
    return r && r.equals ? r.equals(e) : e && e.equals ? e.equals(r) : typeof r == "number" && typeof e == "number" ? Math.abs(r - e) <= no.EPSILON * Math.max(1, Math.abs(r), Math.abs(e)) : !1;
  } finally {
    no.EPSILON = n;
  }
}
function Hk(r) {
  return Math.round(r / no.EPSILON) * no.EPSILON;
}
function Wk(r) {
  return r.clone ? r.clone() : new Array(r.length);
}
function M2(r, e, t) {
  if (Wh(r)) {
    const n = r;
    t = t || Wk(n);
    for (let i = 0; i < t.length && i < n.length; ++i) {
      const s = typeof r == "number" ? r : r[i];
      t[i] = e(s, i, t);
    }
    return t;
  }
  return e(r);
}
class P2 extends Array {
  // Common methods
  /**
   * Clone the current object
   * @returns a new copy of this object
   */
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    for (let n = 0; n < this.ELEMENTS; ++n)
      this[n] = e[n + t];
    return this.check();
  }
  toArray() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    for (let n = 0; n < this.ELEMENTS; ++n)
      e[t + n] = this[n];
    return e;
  }
  toObject(e) {
    return e;
  }
  from(e) {
    return Array.isArray(e) ? this.copy(e) : (
      // @ts-ignore
      this.fromObject(e)
    );
  }
  to(e) {
    return e === this ? this : Wh(e) ? this.toArray(e) : this.toObject(e);
  }
  toTarget(e) {
    return e ? this.to(e) : this;
  }
  /** @deprecated */
  toFloat32Array() {
    return new Float32Array(this);
  }
  toString() {
    return this.formatString(no);
  }
  /** Formats string according to options */
  formatString(e) {
    let t = "";
    for (let n = 0; n < this.ELEMENTS; ++n)
      t += (n > 0 ? ", " : "") + Vk(this[n], e);
    return `${e.printTypes ? this.constructor.name : ""}[${t}]`;
  }
  equals(e) {
    if (!e || this.length !== e.length)
      return !1;
    for (let t = 0; t < this.ELEMENTS; ++t)
      if (!Mc(this[t], e[t]))
        return !1;
    return !0;
  }
  exactEquals(e) {
    if (!e || this.length !== e.length)
      return !1;
    for (let t = 0; t < this.ELEMENTS; ++t)
      if (this[t] !== e[t])
        return !1;
    return !0;
  }
  // Modifiers
  /** Negates all values in this object */
  negate() {
    for (let e = 0; e < this.ELEMENTS; ++e)
      this[e] = -this[e];
    return this.check();
  }
  lerp(e, t, n) {
    if (n === void 0)
      return this.lerp(this, e, t);
    for (let i = 0; i < this.ELEMENTS; ++i) {
      const s = e[i], l = typeof t == "number" ? t : t[i];
      this[i] = s + n * (l - s);
    }
    return this.check();
  }
  /** Minimal */
  min(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] = Math.min(e[t], this[t]);
    return this.check();
  }
  /** Maximal */
  max(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] = Math.max(e[t], this[t]);
    return this.check();
  }
  clamp(e, t) {
    for (let n = 0; n < this.ELEMENTS; ++n)
      this[n] = Math.min(Math.max(this[n], e[n]), t[n]);
    return this.check();
  }
  add() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    for (const i of t)
      for (let s = 0; s < this.ELEMENTS; ++s)
        this[s] += i[s];
    return this.check();
  }
  subtract() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    for (const i of t)
      for (let s = 0; s < this.ELEMENTS; ++s)
        this[s] -= i[s];
    return this.check();
  }
  scale(e) {
    if (typeof e == "number")
      for (let t = 0; t < this.ELEMENTS; ++t)
        this[t] *= e;
    else
      for (let t = 0; t < this.ELEMENTS && t < e.length; ++t)
        this[t] *= e[t];
    return this.check();
  }
  /**
   * Multiplies all elements by `scale`
   * Note: `Matrix4.multiplyByScalar` only scales its 3x3 "minor"
   */
  multiplyByScalar(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] *= e;
    return this.check();
  }
  // Debug checks
  /** Throws an error if array length is incorrect or contains illegal values */
  check() {
    if (no.debug && !this.validate())
      throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
    return this;
  }
  /** Returns false if the array length is incorrect or contains illegal values */
  validate() {
    let e = this.length === this.ELEMENTS;
    for (let t = 0; t < this.ELEMENTS; ++t)
      e = e && Number.isFinite(this[t]);
    return e;
  }
  // three.js compatibility
  /** @deprecated */
  sub(e) {
    return this.subtract(e);
  }
  /** @deprecated */
  setScalar(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] = e;
    return this.check();
  }
  /** @deprecated */
  addScalar(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] += e;
    return this.check();
  }
  /** @deprecated */
  subScalar(e) {
    return this.addScalar(-e);
  }
  /** @deprecated */
  multiplyScalar(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] *= e;
    return this.check();
  }
  /** @deprecated */
  divideScalar(e) {
    return this.multiplyByScalar(1 / e);
  }
  /** @deprecated */
  clampScalar(e, t) {
    for (let n = 0; n < this.ELEMENTS; ++n)
      this[n] = Math.min(Math.max(this[n], e), t);
    return this.check();
  }
  /** @deprecated */
  get elements() {
    return this;
  }
}
function Xk(r, e) {
  if (r.length !== e)
    return !1;
  for (let t = 0; t < r.length; ++t)
    if (!Number.isFinite(r[t]))
      return !1;
  return !0;
}
function ei(r) {
  if (!Number.isFinite(r))
    throw new Error(`Invalid number ${JSON.stringify(r)}`);
  return r;
}
function vg(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
  if (no.debug && !Xk(r, e))
    throw new Error(`math.gl: ${t} some fields set to invalid numbers'`);
  return r;
}
function Ac(r, e) {
  if (!r)
    throw new Error(`math.gl assertion ${e}`);
}
class R2 extends P2 {
  // ACCESSORS
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = ei(e);
  }
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = ei(e);
  }
  /**
   * Returns the length of the vector from the origin to the point described by this vector
   *
   * @note `length` is a reserved word for Arrays, so `v.length()` will return number of elements
   * Instead we provide `len` and `magnitude`
   */
  len() {
    return Math.sqrt(this.lengthSquared());
  }
  /**
   * Returns the length of the vector from the origin to the point described by this vector
   */
  magnitude() {
    return this.len();
  }
  /**
   * Returns the squared length of the vector from the origin to the point described by this vector
   */
  lengthSquared() {
    let e = 0;
    for (let t = 0; t < this.ELEMENTS; ++t)
      e += this[t] * this[t];
    return e;
  }
  /**
   * Returns the squared length of the vector from the origin to the point described by this vector
   */
  magnitudeSquared() {
    return this.lengthSquared();
  }
  distance(e) {
    return Math.sqrt(this.distanceSquared(e));
  }
  distanceSquared(e) {
    let t = 0;
    for (let n = 0; n < this.ELEMENTS; ++n) {
      const i = this[n] - e[n];
      t += i * i;
    }
    return ei(t);
  }
  dot(e) {
    let t = 0;
    for (let n = 0; n < this.ELEMENTS; ++n)
      t += this[n] * e[n];
    return ei(t);
  }
  // MODIFIERS
  normalize() {
    const e = this.magnitude();
    if (e !== 0)
      for (let t = 0; t < this.ELEMENTS; ++t)
        this[t] /= e;
    return this.check();
  }
  multiply() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    for (const i of t)
      for (let s = 0; s < this.ELEMENTS; ++s)
        this[s] *= i[s];
    return this.check();
  }
  divide() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    for (const i of t)
      for (let s = 0; s < this.ELEMENTS; ++s)
        this[s] /= i[s];
    return this.check();
  }
  // THREE.js compatibility
  lengthSq() {
    return this.lengthSquared();
  }
  distanceTo(e) {
    return this.distance(e);
  }
  distanceToSquared(e) {
    return this.distanceSquared(e);
  }
  getComponent(e) {
    return Ac(e >= 0 && e < this.ELEMENTS, "index is out of range"), ei(this[e]);
  }
  setComponent(e, t) {
    return Ac(e >= 0 && e < this.ELEMENTS, "index is out of range"), this[e] = t, this.check();
  }
  addVectors(e, t) {
    return this.copy(e).add(t);
  }
  subVectors(e, t) {
    return this.copy(e).subtract(t);
  }
  multiplyVectors(e, t) {
    return this.copy(e).multiply(t);
  }
  addScaledVector(e, t) {
    return this.add(new this.constructor(e).multiplyScalar(t));
  }
}
const xg = 1e-6;
let Rc = typeof Float32Array < "u" ? Float32Array : Array;
function Zk() {
  const r = new Rc(2);
  return Rc != Float32Array && (r[0] = 0, r[1] = 0), r;
}
function fT(r, e, t) {
  return r[0] = e[0] + t[0], r[1] = e[1] + t[1], r;
}
function Yk(r, e) {
  return r[0] = -e[0], r[1] = -e[1], r;
}
function KC(r, e, t, n) {
  const i = e[0], s = e[1];
  return r[0] = i + n * (t[0] - i), r[1] = s + n * (t[1] - s), r;
}
function Kk(r, e, t) {
  const n = e[0], i = e[1];
  return r[0] = t[0] * n + t[2] * i, r[1] = t[1] * n + t[3] * i, r;
}
function Jk(r, e, t) {
  const n = e[0], i = e[1];
  return r[0] = t[0] * n + t[2] * i + t[4], r[1] = t[1] * n + t[3] * i + t[5], r;
}
function JC(r, e, t) {
  const n = e[0], i = e[1];
  return r[0] = t[0] * n + t[3] * i + t[6], r[1] = t[1] * n + t[4] * i + t[7], r;
}
function QC(r, e, t) {
  const n = e[0], i = e[1];
  return r[0] = t[0] * n + t[4] * i + t[12], r[1] = t[1] * n + t[5] * i + t[13], r;
}
(function() {
  const r = Zk();
  return function(e, t, n, i, s, l) {
    let o, d;
    for (t || (t = 2), n || (n = 0), i ? d = Math.min(i * t + n, e.length) : d = e.length, o = n; o < d; o += t)
      r[0] = e[o], r[1] = e[o + 1], s(r, r, l), e[o] = r[0], e[o + 1] = r[1];
    return e;
  };
})();
function e5(r, e, t) {
  const n = e[0], i = e[1], s = t[3] * n + t[7] * i || 1;
  return r[0] = (t[0] * n + t[4] * i) / s, r[1] = (t[1] * n + t[5] * i) / s, r;
}
function t5(r, e, t) {
  const n = e[0], i = e[1], s = e[2], l = t[3] * n + t[7] * i + t[11] * s || 1;
  return r[0] = (t[0] * n + t[4] * i + t[8] * s) / l, r[1] = (t[1] * n + t[5] * i + t[9] * s) / l, r[2] = (t[2] * n + t[6] * i + t[10] * s) / l, r;
}
function Qk(r, e, t) {
  const n = e[0], i = e[1];
  return r[0] = t[0] * n + t[2] * i, r[1] = t[1] * n + t[3] * i, r[2] = e[2], r;
}
function eN(r, e, t) {
  const n = e[0], i = e[1];
  return r[0] = t[0] * n + t[2] * i, r[1] = t[1] * n + t[3] * i, r[2] = e[2], r[3] = e[3], r;
}
function r5(r, e, t) {
  const n = e[0], i = e[1], s = e[2];
  return r[0] = t[0] * n + t[3] * i + t[6] * s, r[1] = t[1] * n + t[4] * i + t[7] * s, r[2] = t[2] * n + t[5] * i + t[8] * s, r[3] = e[3], r;
}
class B2 extends R2 {
  // Creates a new, empty vec2
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    super(2), Wh(e) && arguments.length === 1 ? this.copy(e) : (no.debug && (ei(e), ei(t)), this[0] = e, this[1] = t);
  }
  set(e, t) {
    return this[0] = e, this[1] = t, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this.check();
  }
  fromObject(e) {
    return no.debug && (ei(e.x), ei(e.y)), this[0] = e.x, this[1] = e.y, this.check();
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e;
  }
  // Getters/setters
  get ELEMENTS() {
    return 2;
  }
  /**
   * Returns angle from x axis
   * @returns
   */
  horizontalAngle() {
    return Math.atan2(this.y, this.x);
  }
  /**
   * Returns angle from y axis
   * @returns
   */
  verticalAngle() {
    return Math.atan2(this.x, this.y);
  }
  // Transforms
  /**
   * Transforms as point
   * @param matrix4
   * @returns
   */
  transform(e) {
    return this.transformAsPoint(e);
  }
  /**
   * transforms as point (4th component is implicitly 1)
   * @param matrix4
   * @returns
   */
  transformAsPoint(e) {
    return QC(this, this, e), this.check();
  }
  /**
   * transforms as vector (4th component is implicitly 0, ignores translation. slightly faster)
   * @param matrix4
   * @returns
   */
  transformAsVector(e) {
    return e5(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return JC(this, this, e), this.check();
  }
  transformByMatrix2x3(e) {
    return Jk(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return Kk(this, this, e), this.check();
  }
}
function n5() {
  const r = new Rc(3);
  return Rc != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0), r;
}
function i5(r) {
  const e = r[0], t = r[1], n = r[2];
  return Math.sqrt(e * e + t * t + n * n);
}
function dT(r, e, t) {
  const n = new Rc(3);
  return n[0] = r, n[1] = e, n[2] = t, n;
}
function tN(r, e, t) {
  return r[0] = e[0] - t[0], r[1] = e[1] - t[1], r[2] = e[2] - t[2], r;
}
function rN(r) {
  const e = r[0], t = r[1], n = r[2];
  return e * e + t * t + n * n;
}
function nN(r, e) {
  return r[0] = -e[0], r[1] = -e[1], r[2] = -e[2], r;
}
function iN(r, e) {
  const t = e[0], n = e[1], i = e[2];
  let s = t * t + n * n + i * i;
  return s > 0 && (s = 1 / Math.sqrt(s)), r[0] = e[0] * s, r[1] = e[1] * s, r[2] = e[2] * s, r;
}
function L2(r, e) {
  return r[0] * e[0] + r[1] * e[1] + r[2] * e[2];
}
function f_(r, e, t) {
  const n = e[0], i = e[1], s = e[2], l = t[0], o = t[1], d = t[2];
  return r[0] = i * d - s * o, r[1] = s * l - n * d, r[2] = n * o - i * l, r;
}
function sN(r, e, t, n) {
  const i = e[0], s = e[1], l = e[2];
  return r[0] = i + n * (t[0] - i), r[1] = s + n * (t[1] - s), r[2] = l + n * (t[2] - l), r;
}
function O2(r, e, t) {
  const n = e[0], i = e[1], s = e[2];
  let l = t[3] * n + t[7] * i + t[11] * s + t[15];
  return l = l || 1, r[0] = (t[0] * n + t[4] * i + t[8] * s + t[12]) / l, r[1] = (t[1] * n + t[5] * i + t[9] * s + t[13]) / l, r[2] = (t[2] * n + t[6] * i + t[10] * s + t[14]) / l, r;
}
function s5(r, e, t) {
  const n = e[0], i = e[1], s = e[2];
  return r[0] = n * t[0] + i * t[3] + s * t[6], r[1] = n * t[1] + i * t[4] + s * t[7], r[2] = n * t[2] + i * t[5] + s * t[8], r;
}
function o5(r, e, t) {
  const n = t[0], i = t[1], s = t[2], l = t[3], o = e[0], d = e[1], m = e[2];
  let b = i * m - s * d, A = s * o - n * m, M = n * d - i * o, E = i * M - s * A, k = s * b - n * M, U = n * A - i * b;
  const V = l * 2;
  return b *= V, A *= V, M *= V, E *= 2, k *= 2, U *= 2, r[0] = o + b + E, r[1] = d + A + k, r[2] = m + M + U, r;
}
function oN(r, e, t, n) {
  const i = [], s = [];
  return i[0] = e[0] - t[0], i[1] = e[1] - t[1], i[2] = e[2] - t[2], s[0] = i[0], s[1] = i[1] * Math.cos(n) - i[2] * Math.sin(n), s[2] = i[1] * Math.sin(n) + i[2] * Math.cos(n), r[0] = s[0] + t[0], r[1] = s[1] + t[1], r[2] = s[2] + t[2], r;
}
function aN(r, e, t, n) {
  const i = [], s = [];
  return i[0] = e[0] - t[0], i[1] = e[1] - t[1], i[2] = e[2] - t[2], s[0] = i[2] * Math.sin(n) + i[0] * Math.cos(n), s[1] = i[1], s[2] = i[2] * Math.cos(n) - i[0] * Math.sin(n), r[0] = s[0] + t[0], r[1] = s[1] + t[1], r[2] = s[2] + t[2], r;
}
function lN(r, e, t, n) {
  const i = [], s = [];
  return i[0] = e[0] - t[0], i[1] = e[1] - t[1], i[2] = e[2] - t[2], s[0] = i[0] * Math.cos(n) - i[1] * Math.sin(n), s[1] = i[0] * Math.sin(n) + i[1] * Math.cos(n), s[2] = i[2], r[0] = s[0] + t[0], r[1] = s[1] + t[1], r[2] = s[2] + t[2], r;
}
function cN(r, e) {
  const t = r[0], n = r[1], i = r[2], s = e[0], l = e[1], o = e[2], d = Math.sqrt((t * t + n * n + i * i) * (s * s + l * l + o * o)), m = d && L2(r, e) / d;
  return Math.acos(Math.min(Math.max(m, -1), 1));
}
const a5 = tN, l5 = i5, _b = rN;
(function() {
  const r = n5();
  return function(e, t, n, i, s, l) {
    let o, d;
    for (t || (t = 3), n || (n = 0), i ? d = Math.min(i * t + n, e.length) : d = e.length, o = n; o < d; o += t)
      r[0] = e[o], r[1] = e[o + 1], r[2] = e[o + 2], s(r, r, l), e[o] = r[0], e[o + 1] = r[1], e[o + 2] = r[2];
    return e;
  };
})();
const yb = [0, 0, 0];
let Mm;
class Ct extends R2 {
  static get ZERO() {
    return Mm || (Mm = new Ct(0, 0, 0), Object.freeze(Mm)), Mm;
  }
  /**
   * @class
   * @param x
   * @param y
   * @param z
   */
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    super(-0, -0, -0), arguments.length === 1 && Wh(e) ? this.copy(e) : (no.debug && (ei(e), ei(t), ei(n)), this[0] = e, this[1] = t, this[2] = n);
  }
  set(e, t, n) {
    return this[0] = e, this[1] = t, this[2] = n, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this.check();
  }
  fromObject(e) {
    return no.debug && (ei(e.x), ei(e.y), ei(e.z)), this[0] = e.x, this[1] = e.y, this[2] = e.z, this.check();
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e.z = this[2], e;
  }
  // Getters/setters
  get ELEMENTS() {
    return 3;
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = ei(e);
  }
  // ACCESSORS
  angle(e) {
    return cN(this, e);
  }
  // MODIFIERS
  cross(e) {
    return f_(this, this, e), this.check();
  }
  rotateX(e) {
    let {
      radians: t,
      origin: n = yb
    } = e;
    return oN(this, this, n, t), this.check();
  }
  rotateY(e) {
    let {
      radians: t,
      origin: n = yb
    } = e;
    return aN(this, this, n, t), this.check();
  }
  rotateZ(e) {
    let {
      radians: t,
      origin: n = yb
    } = e;
    return lN(this, this, n, t), this.check();
  }
  // Transforms
  // transforms as point (4th component is implicitly 1)
  transform(e) {
    return this.transformAsPoint(e);
  }
  // transforms as point (4th component is implicitly 1)
  transformAsPoint(e) {
    return O2(this, this, e), this.check();
  }
  // transforms as vector  (4th component is implicitly 0, ignores translation. slightly faster)
  transformAsVector(e) {
    return t5(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return s5(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return Qk(this, this, e), this.check();
  }
  transformByQuaternion(e) {
    return o5(this, this, e), this.check();
  }
}
let Pm;
class k2 extends R2 {
  static get ZERO() {
    return Pm || (Pm = new k2(0, 0, 0, 0), Object.freeze(Pm)), Pm;
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    super(-0, -0, -0, -0), Wh(e) && arguments.length === 1 ? this.copy(e) : (no.debug && (ei(e), ei(t), ei(n), ei(i)), this[0] = e, this[1] = t, this[2] = n, this[3] = i);
  }
  set(e, t, n, i) {
    return this[0] = e, this[1] = t, this[2] = n, this[3] = i, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this.check();
  }
  fromObject(e) {
    return no.debug && (ei(e.x), ei(e.y), ei(e.z), ei(e.w)), this[0] = e.x, this[1] = e.y, this[2] = e.z, this[3] = e.w, this;
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e.z = this[2], e.w = this[3], e;
  }
  // Getters/setters
  /* eslint-disable no-multi-spaces, brace-style, no-return-assign */
  get ELEMENTS() {
    return 4;
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = ei(e);
  }
  get w() {
    return this[3];
  }
  set w(e) {
    this[3] = ei(e);
  }
  transform(e) {
    return O2(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return r5(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return eN(this, this, e), this.check();
  }
  transformByQuaternion(e) {
    return o5(this, this, e), this.check();
  }
  // three.js compatibility
  applyMatrix4(e) {
    return e.transform(this, this), this;
  }
}
class c5 extends P2 {
  // fromObject(object) {
  //   const array = object.elements;
  //   return this.fromRowMajor(array);
  // }
  // toObject(object) {
  //   const array = object.elements;
  //   this.toRowMajor(array);
  //   return object;
  // }
  // TODO better override formatString?
  toString() {
    let e = "[";
    if (no.printRowMajor) {
      e += "row-major:";
      for (let t = 0; t < this.RANK; ++t)
        for (let n = 0; n < this.RANK; ++n)
          e += ` ${this[n * this.RANK + t]}`;
    } else {
      e += "column-major:";
      for (let t = 0; t < this.ELEMENTS; ++t)
        e += ` ${this[t]}`;
    }
    return e += "]", e;
  }
  getElementIndex(e, t) {
    return t * this.RANK + e;
  }
  // By default assumes row major indices
  getElement(e, t) {
    return this[t * this.RANK + e];
  }
  // By default assumes row major indices
  setElement(e, t, n) {
    return this[t * this.RANK + e] = ei(n), this;
  }
  getColumn(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Array(this.RANK).fill(-0);
    const n = e * this.RANK;
    for (let i = 0; i < this.RANK; ++i)
      t[i] = this[n + i];
    return t;
  }
  setColumn(e, t) {
    const n = e * this.RANK;
    for (let i = 0; i < this.RANK; ++i)
      this[n + i] = t[i];
    return this;
  }
}
function uN() {
  const r = new Rc(9);
  return Rc != Float32Array && (r[1] = 0, r[2] = 0, r[3] = 0, r[5] = 0, r[6] = 0, r[7] = 0), r[0] = 1, r[4] = 1, r[8] = 1, r;
}
function hN(r, e) {
  if (r === e) {
    const t = e[1], n = e[2], i = e[5];
    r[1] = e[3], r[2] = e[6], r[3] = t, r[5] = e[7], r[6] = n, r[7] = i;
  } else
    r[0] = e[0], r[1] = e[3], r[2] = e[6], r[3] = e[1], r[4] = e[4], r[5] = e[7], r[6] = e[2], r[7] = e[5], r[8] = e[8];
  return r;
}
function fN(r, e) {
  const t = e[0], n = e[1], i = e[2], s = e[3], l = e[4], o = e[5], d = e[6], m = e[7], b = e[8], A = b * l - o * m, M = -b * s + o * d, E = m * s - l * d;
  let k = t * A + n * M + i * E;
  return k ? (k = 1 / k, r[0] = A * k, r[1] = (-b * n + i * m) * k, r[2] = (o * n - i * l) * k, r[3] = M * k, r[4] = (b * t - i * d) * k, r[5] = (-o * t + i * s) * k, r[6] = E * k, r[7] = (-m * t + n * d) * k, r[8] = (l * t - n * s) * k, r) : null;
}
function dN(r) {
  const e = r[0], t = r[1], n = r[2], i = r[3], s = r[4], l = r[5], o = r[6], d = r[7], m = r[8];
  return e * (m * s - l * d) + t * (-m * i + l * o) + n * (d * i - s * o);
}
function pT(r, e, t) {
  const n = e[0], i = e[1], s = e[2], l = e[3], o = e[4], d = e[5], m = e[6], b = e[7], A = e[8], M = t[0], E = t[1], k = t[2], U = t[3], V = t[4], q = t[5], Y = t[6], re = t[7], Z = t[8];
  return r[0] = M * n + E * l + k * m, r[1] = M * i + E * o + k * b, r[2] = M * s + E * d + k * A, r[3] = U * n + V * l + q * m, r[4] = U * i + V * o + q * b, r[5] = U * s + V * d + q * A, r[6] = Y * n + re * l + Z * m, r[7] = Y * i + re * o + Z * b, r[8] = Y * s + re * d + Z * A, r;
}
function pN(r, e, t) {
  const n = e[0], i = e[1], s = e[2], l = e[3], o = e[4], d = e[5], m = e[6], b = e[7], A = e[8], M = t[0], E = t[1];
  return r[0] = n, r[1] = i, r[2] = s, r[3] = l, r[4] = o, r[5] = d, r[6] = M * n + E * l + m, r[7] = M * i + E * o + b, r[8] = M * s + E * d + A, r;
}
function gN(r, e, t) {
  const n = e[0], i = e[1], s = e[2], l = e[3], o = e[4], d = e[5], m = e[6], b = e[7], A = e[8], M = Math.sin(t), E = Math.cos(t);
  return r[0] = E * n + M * l, r[1] = E * i + M * o, r[2] = E * s + M * d, r[3] = E * l - M * n, r[4] = E * o - M * i, r[5] = E * d - M * s, r[6] = m, r[7] = b, r[8] = A, r;
}
function gT(r, e, t) {
  const n = t[0], i = t[1];
  return r[0] = n * e[0], r[1] = n * e[1], r[2] = n * e[2], r[3] = i * e[3], r[4] = i * e[4], r[5] = i * e[5], r[6] = e[6], r[7] = e[7], r[8] = e[8], r;
}
function mN(r, e) {
  const t = e[0], n = e[1], i = e[2], s = e[3], l = t + t, o = n + n, d = i + i, m = t * l, b = n * l, A = n * o, M = i * l, E = i * o, k = i * d, U = s * l, V = s * o, q = s * d;
  return r[0] = 1 - A - k, r[3] = b - q, r[6] = M + V, r[1] = b + q, r[4] = 1 - m - k, r[7] = E - U, r[2] = M - V, r[5] = E + U, r[8] = 1 - m - A, r;
}
var J1;
(function(r) {
  r[r.COL0ROW0 = 0] = "COL0ROW0", r[r.COL0ROW1 = 1] = "COL0ROW1", r[r.COL0ROW2 = 2] = "COL0ROW2", r[r.COL1ROW0 = 3] = "COL1ROW0", r[r.COL1ROW1 = 4] = "COL1ROW1", r[r.COL1ROW2 = 5] = "COL1ROW2", r[r.COL2ROW0 = 6] = "COL2ROW0", r[r.COL2ROW1 = 7] = "COL2ROW1", r[r.COL2ROW2 = 8] = "COL2ROW2";
})(J1 || (J1 = {}));
const _N = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
class ms extends c5 {
  static get IDENTITY() {
    return bN();
  }
  static get ZERO() {
    return yN();
  }
  get ELEMENTS() {
    return 9;
  }
  get RANK() {
    return 3;
  }
  get INDICES() {
    return J1;
  }
  constructor(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
      n[i - 1] = arguments[i];
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(e) ? this.copy(e) : n.length > 0 ? this.copy([e, ...n]) : this.identity();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this[4] = e[4], this[5] = e[5], this[6] = e[6], this[7] = e[7], this[8] = e[8], this.check();
  }
  // Constructors
  identity() {
    return this.copy(_N);
  }
  /**
   *
   * @param object
   * @returns self
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fromObject(e) {
    return this.check();
  }
  /** Calculates a 3x3 matrix from the given quaternion
   * q quat  Quaternion to create matrix from
   */
  fromQuaternion(e) {
    return mN(this, e), this.check();
  }
  /**
   * accepts column major order, stores in column major order
   */
  // eslint-disable-next-line max-params
  set(e, t, n, i, s, l, o, d, m) {
    return this[0] = e, this[1] = t, this[2] = n, this[3] = i, this[4] = s, this[5] = l, this[6] = o, this[7] = d, this[8] = m, this.check();
  }
  /**
   * accepts row major order, stores as column major
   */
  // eslint-disable-next-line max-params
  setRowMajor(e, t, n, i, s, l, o, d, m) {
    return this[0] = e, this[1] = i, this[2] = o, this[3] = t, this[4] = s, this[5] = d, this[6] = n, this[7] = l, this[8] = m, this.check();
  }
  // Accessors
  determinant() {
    return dN(this);
  }
  // Modifiers
  transpose() {
    return hN(this, this), this.check();
  }
  /** Invert a matrix. Note that this can fail if the matrix is not invertible */
  invert() {
    return fN(this, this), this.check();
  }
  // Operations
  multiplyLeft(e) {
    return pT(this, e, this), this.check();
  }
  multiplyRight(e) {
    return pT(this, this, e), this.check();
  }
  rotate(e) {
    return gN(this, this, e), this.check();
  }
  scale(e) {
    return Array.isArray(e) ? gT(this, this, e) : gT(this, this, [e, e]), this.check();
  }
  translate(e) {
    return pN(this, this, e), this.check();
  }
  // Transforms
  transform(e, t) {
    let n;
    switch (e.length) {
      case 2:
        n = JC(t || [-0, -0], e, this);
        break;
      case 3:
        n = s5(t || [-0, -0, -0], e, this);
        break;
      case 4:
        n = r5(t || [-0, -0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return vg(n, e.length), n;
  }
  /** @deprecated */
  transformVector(e, t) {
    return this.transform(e, t);
  }
  /** @deprecated */
  transformVector2(e, t) {
    return this.transform(e, t);
  }
  /** @deprecated */
  transformVector3(e, t) {
    return this.transform(e, t);
  }
}
let Rm, Bm = null;
function yN() {
  return Rm || (Rm = new ms([0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(Rm)), Rm;
}
function bN() {
  return Bm || (Bm = new ms(), Object.freeze(Bm)), Bm;
}
function vN(r) {
  return r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = 1, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, r;
}
function xN(r, e) {
  if (r === e) {
    const t = e[1], n = e[2], i = e[3], s = e[6], l = e[7], o = e[11];
    r[1] = e[4], r[2] = e[8], r[3] = e[12], r[4] = t, r[6] = e[9], r[7] = e[13], r[8] = n, r[9] = s, r[11] = e[14], r[12] = i, r[13] = l, r[14] = o;
  } else
    r[0] = e[0], r[1] = e[4], r[2] = e[8], r[3] = e[12], r[4] = e[1], r[5] = e[5], r[6] = e[9], r[7] = e[13], r[8] = e[2], r[9] = e[6], r[10] = e[10], r[11] = e[14], r[12] = e[3], r[13] = e[7], r[14] = e[11], r[15] = e[15];
  return r;
}
function Q1(r, e) {
  const t = e[0], n = e[1], i = e[2], s = e[3], l = e[4], o = e[5], d = e[6], m = e[7], b = e[8], A = e[9], M = e[10], E = e[11], k = e[12], U = e[13], V = e[14], q = e[15], Y = t * o - n * l, re = t * d - i * l, Z = t * m - s * l, K = n * d - i * o, ie = n * m - s * o, be = i * m - s * d, he = b * U - A * k, Be = b * V - M * k, ke = b * q - E * k, pe = A * V - M * U, me = A * q - E * U, je = M * q - E * V;
  let Pe = Y * je - re * me + Z * pe + K * ke - ie * Be + be * he;
  return Pe ? (Pe = 1 / Pe, r[0] = (o * je - d * me + m * pe) * Pe, r[1] = (i * me - n * je - s * pe) * Pe, r[2] = (U * be - V * ie + q * K) * Pe, r[3] = (M * ie - A * be - E * K) * Pe, r[4] = (d * ke - l * je - m * Be) * Pe, r[5] = (t * je - i * ke + s * Be) * Pe, r[6] = (V * Z - k * be - q * re) * Pe, r[7] = (b * be - M * Z + E * re) * Pe, r[8] = (l * me - o * ke + m * he) * Pe, r[9] = (n * ke - t * me - s * he) * Pe, r[10] = (k * ie - U * Z + q * Y) * Pe, r[11] = (A * Z - b * ie - E * Y) * Pe, r[12] = (o * Be - l * pe - d * he) * Pe, r[13] = (t * pe - n * Be + i * he) * Pe, r[14] = (U * re - k * K - V * Y) * Pe, r[15] = (b * K - A * re + M * Y) * Pe, r) : null;
}
function wN(r) {
  const e = r[0], t = r[1], n = r[2], i = r[3], s = r[4], l = r[5], o = r[6], d = r[7], m = r[8], b = r[9], A = r[10], M = r[11], E = r[12], k = r[13], U = r[14], V = r[15], q = e * l - t * s, Y = e * o - n * s, re = t * o - n * l, Z = m * k - b * E, K = m * U - A * E, ie = b * U - A * k, be = e * ie - t * K + n * Z, he = s * ie - l * K + o * Z, Be = m * re - b * Y + A * q, ke = E * re - k * Y + U * q;
  return d * be - i * he + V * Be - M * ke;
}
function Nf(r, e, t) {
  const n = e[0], i = e[1], s = e[2], l = e[3], o = e[4], d = e[5], m = e[6], b = e[7], A = e[8], M = e[9], E = e[10], k = e[11], U = e[12], V = e[13], q = e[14], Y = e[15];
  let re = t[0], Z = t[1], K = t[2], ie = t[3];
  return r[0] = re * n + Z * o + K * A + ie * U, r[1] = re * i + Z * d + K * M + ie * V, r[2] = re * s + Z * m + K * E + ie * q, r[3] = re * l + Z * b + K * k + ie * Y, re = t[4], Z = t[5], K = t[6], ie = t[7], r[4] = re * n + Z * o + K * A + ie * U, r[5] = re * i + Z * d + K * M + ie * V, r[6] = re * s + Z * m + K * E + ie * q, r[7] = re * l + Z * b + K * k + ie * Y, re = t[8], Z = t[9], K = t[10], ie = t[11], r[8] = re * n + Z * o + K * A + ie * U, r[9] = re * i + Z * d + K * M + ie * V, r[10] = re * s + Z * m + K * E + ie * q, r[11] = re * l + Z * b + K * k + ie * Y, re = t[12], Z = t[13], K = t[14], ie = t[15], r[12] = re * n + Z * o + K * A + ie * U, r[13] = re * i + Z * d + K * M + ie * V, r[14] = re * s + Z * m + K * E + ie * q, r[15] = re * l + Z * b + K * k + ie * Y, r;
}
function J_(r, e, t) {
  const n = t[0], i = t[1], s = t[2];
  let l, o, d, m, b, A, M, E, k, U, V, q;
  return e === r ? (r[12] = e[0] * n + e[4] * i + e[8] * s + e[12], r[13] = e[1] * n + e[5] * i + e[9] * s + e[13], r[14] = e[2] * n + e[6] * i + e[10] * s + e[14], r[15] = e[3] * n + e[7] * i + e[11] * s + e[15]) : (l = e[0], o = e[1], d = e[2], m = e[3], b = e[4], A = e[5], M = e[6], E = e[7], k = e[8], U = e[9], V = e[10], q = e[11], r[0] = l, r[1] = o, r[2] = d, r[3] = m, r[4] = b, r[5] = A, r[6] = M, r[7] = E, r[8] = k, r[9] = U, r[10] = V, r[11] = q, r[12] = l * n + b * i + k * s + e[12], r[13] = o * n + A * i + U * s + e[13], r[14] = d * n + M * i + V * s + e[14], r[15] = m * n + E * i + q * s + e[15]), r;
}
function N2(r, e, t) {
  const n = t[0], i = t[1], s = t[2];
  return r[0] = e[0] * n, r[1] = e[1] * n, r[2] = e[2] * n, r[3] = e[3] * n, r[4] = e[4] * i, r[5] = e[5] * i, r[6] = e[6] * i, r[7] = e[7] * i, r[8] = e[8] * s, r[9] = e[9] * s, r[10] = e[10] * s, r[11] = e[11] * s, r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15], r;
}
function AN(r, e, t, n) {
  let i = n[0], s = n[1], l = n[2], o = Math.sqrt(i * i + s * s + l * l), d, m, b, A, M, E, k, U, V, q, Y, re, Z, K, ie, be, he, Be, ke, pe, me, je, Pe, St;
  return o < xg ? null : (o = 1 / o, i *= o, s *= o, l *= o, m = Math.sin(t), d = Math.cos(t), b = 1 - d, A = e[0], M = e[1], E = e[2], k = e[3], U = e[4], V = e[5], q = e[6], Y = e[7], re = e[8], Z = e[9], K = e[10], ie = e[11], be = i * i * b + d, he = s * i * b + l * m, Be = l * i * b - s * m, ke = i * s * b - l * m, pe = s * s * b + d, me = l * s * b + i * m, je = i * l * b + s * m, Pe = s * l * b - i * m, St = l * l * b + d, r[0] = A * be + U * he + re * Be, r[1] = M * be + V * he + Z * Be, r[2] = E * be + q * he + K * Be, r[3] = k * be + Y * he + ie * Be, r[4] = A * ke + U * pe + re * me, r[5] = M * ke + V * pe + Z * me, r[6] = E * ke + q * pe + K * me, r[7] = k * ke + Y * pe + ie * me, r[8] = A * je + U * Pe + re * St, r[9] = M * je + V * Pe + Z * St, r[10] = E * je + q * Pe + K * St, r[11] = k * je + Y * Pe + ie * St, e !== r && (r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r);
}
function u5(r, e, t) {
  const n = Math.sin(t), i = Math.cos(t), s = e[4], l = e[5], o = e[6], d = e[7], m = e[8], b = e[9], A = e[10], M = e[11];
  return e !== r && (r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[4] = s * i + m * n, r[5] = l * i + b * n, r[6] = o * i + A * n, r[7] = d * i + M * n, r[8] = m * i - s * n, r[9] = b * i - l * n, r[10] = A * i - o * n, r[11] = M * i - d * n, r;
}
function TN(r, e, t) {
  const n = Math.sin(t), i = Math.cos(t), s = e[0], l = e[1], o = e[2], d = e[3], m = e[8], b = e[9], A = e[10], M = e[11];
  return e !== r && (r[4] = e[4], r[5] = e[5], r[6] = e[6], r[7] = e[7], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[0] = s * i - m * n, r[1] = l * i - b * n, r[2] = o * i - A * n, r[3] = d * i - M * n, r[8] = s * n + m * i, r[9] = l * n + b * i, r[10] = o * n + A * i, r[11] = d * n + M * i, r;
}
function h5(r, e, t) {
  const n = Math.sin(t), i = Math.cos(t), s = e[0], l = e[1], o = e[2], d = e[3], m = e[4], b = e[5], A = e[6], M = e[7];
  return e !== r && (r[8] = e[8], r[9] = e[9], r[10] = e[10], r[11] = e[11], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[0] = s * i + m * n, r[1] = l * i + b * n, r[2] = o * i + A * n, r[3] = d * i + M * n, r[4] = m * i - s * n, r[5] = b * i - l * n, r[6] = A * i - o * n, r[7] = M * i - d * n, r;
}
function SN(r, e) {
  const t = e[0], n = e[1], i = e[2], s = e[4], l = e[5], o = e[6], d = e[8], m = e[9], b = e[10];
  return r[0] = Math.sqrt(t * t + n * n + i * i), r[1] = Math.sqrt(s * s + l * l + o * o), r[2] = Math.sqrt(d * d + m * m + b * b), r;
}
function EN(r, e) {
  const t = e[0], n = e[1], i = e[2], s = e[3], l = t + t, o = n + n, d = i + i, m = t * l, b = n * l, A = n * o, M = i * l, E = i * o, k = i * d, U = s * l, V = s * o, q = s * d;
  return r[0] = 1 - A - k, r[1] = b + q, r[2] = M - V, r[3] = 0, r[4] = b - q, r[5] = 1 - m - k, r[6] = E + U, r[7] = 0, r[8] = M + V, r[9] = E - U, r[10] = 1 - m - A, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, r;
}
function CN(r, e, t, n, i, s, l) {
  const o = 1 / (t - e), d = 1 / (i - n), m = 1 / (s - l);
  return r[0] = s * 2 * o, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = s * 2 * d, r[6] = 0, r[7] = 0, r[8] = (t + e) * o, r[9] = (i + n) * d, r[10] = (l + s) * m, r[11] = -1, r[12] = 0, r[13] = 0, r[14] = l * s * 2 * m, r[15] = 0, r;
}
function IN(r, e, t, n, i) {
  const s = 1 / Math.tan(e / 2);
  if (r[0] = s / t, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = s, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = -1, r[12] = 0, r[13] = 0, r[15] = 0, i != null && i !== 1 / 0) {
    const l = 1 / (n - i);
    r[10] = (i + n) * l, r[14] = 2 * i * n * l;
  } else
    r[10] = -1, r[14] = -2 * n;
  return r;
}
const MN = IN;
function PN(r, e, t, n, i, s, l) {
  const o = 1 / (e - t), d = 1 / (n - i), m = 1 / (s - l);
  return r[0] = -2 * o, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = -2 * d, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 2 * m, r[11] = 0, r[12] = (e + t) * o, r[13] = (i + n) * d, r[14] = (l + s) * m, r[15] = 1, r;
}
const RN = PN;
function BN(r, e, t, n) {
  let i, s, l, o, d, m, b, A, M, E;
  const k = e[0], U = e[1], V = e[2], q = n[0], Y = n[1], re = n[2], Z = t[0], K = t[1], ie = t[2];
  return Math.abs(k - Z) < xg && Math.abs(U - K) < xg && Math.abs(V - ie) < xg ? vN(r) : (A = k - Z, M = U - K, E = V - ie, i = 1 / Math.sqrt(A * A + M * M + E * E), A *= i, M *= i, E *= i, s = Y * E - re * M, l = re * A - q * E, o = q * M - Y * A, i = Math.sqrt(s * s + l * l + o * o), i ? (i = 1 / i, s *= i, l *= i, o *= i) : (s = 0, l = 0, o = 0), d = M * o - E * l, m = E * s - A * o, b = A * l - M * s, i = Math.sqrt(d * d + m * m + b * b), i ? (i = 1 / i, d *= i, m *= i, b *= i) : (d = 0, m = 0, b = 0), r[0] = s, r[1] = d, r[2] = A, r[3] = 0, r[4] = l, r[5] = m, r[6] = M, r[7] = 0, r[8] = o, r[9] = b, r[10] = E, r[11] = 0, r[12] = -(s * k + l * U + o * V), r[13] = -(d * k + m * U + b * V), r[14] = -(A * k + M * U + E * V), r[15] = 1, r);
}
function LN() {
  const r = new Rc(4);
  return Rc != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0, r[3] = 0), r;
}
function ON(r, e, t) {
  return r[0] = e[0] + t[0], r[1] = e[1] + t[1], r[2] = e[2] + t[2], r[3] = e[3] + t[3], r;
}
function D2(r, e, t) {
  return r[0] = e[0] * t, r[1] = e[1] * t, r[2] = e[2] * t, r[3] = e[3] * t, r;
}
function kN(r) {
  const e = r[0], t = r[1], n = r[2], i = r[3];
  return Math.sqrt(e * e + t * t + n * n + i * i);
}
function NN(r) {
  const e = r[0], t = r[1], n = r[2], i = r[3];
  return e * e + t * t + n * n + i * i;
}
function DN(r, e) {
  const t = e[0], n = e[1], i = e[2], s = e[3];
  let l = t * t + n * n + i * i + s * s;
  return l > 0 && (l = 1 / Math.sqrt(l)), r[0] = t * l, r[1] = n * l, r[2] = i * l, r[3] = s * l, r;
}
function FN(r, e) {
  return r[0] * e[0] + r[1] * e[1] + r[2] * e[2] + r[3] * e[3];
}
function UN(r, e, t, n) {
  const i = e[0], s = e[1], l = e[2], o = e[3];
  return r[0] = i + n * (t[0] - i), r[1] = s + n * (t[1] - s), r[2] = l + n * (t[2] - l), r[3] = o + n * (t[3] - o), r;
}
function _p(r, e, t) {
  const n = e[0], i = e[1], s = e[2], l = e[3];
  return r[0] = t[0] * n + t[4] * i + t[8] * s + t[12] * l, r[1] = t[1] * n + t[5] * i + t[9] * s + t[13] * l, r[2] = t[2] * n + t[6] * i + t[10] * s + t[14] * l, r[3] = t[3] * n + t[7] * i + t[11] * s + t[15] * l, r;
}
function zN(r, e, t) {
  const n = e[0], i = e[1], s = e[2], l = t[0], o = t[1], d = t[2], m = t[3], b = m * n + o * s - d * i, A = m * i + d * n - l * s, M = m * s + l * i - o * n, E = -l * n - o * i - d * s;
  return r[0] = b * m + E * -l + A * -d - M * -o, r[1] = A * m + E * -o + M * -l - b * -d, r[2] = M * m + E * -d + b * -o - A * -l, r[3] = e[3], r;
}
(function() {
  const r = LN();
  return function(e, t, n, i, s, l) {
    let o, d;
    for (t || (t = 4), n || (n = 0), i ? d = Math.min(i * t + n, e.length) : d = e.length, o = n; o < d; o += t)
      r[0] = e[o], r[1] = e[o + 1], r[2] = e[o + 2], r[3] = e[o + 3], s(r, r, l), e[o] = r[0], e[o + 1] = r[1], e[o + 2] = r[2], e[o + 3] = r[3];
    return e;
  };
})();
var ev;
(function(r) {
  r[r.COL0ROW0 = 0] = "COL0ROW0", r[r.COL0ROW1 = 1] = "COL0ROW1", r[r.COL0ROW2 = 2] = "COL0ROW2", r[r.COL0ROW3 = 3] = "COL0ROW3", r[r.COL1ROW0 = 4] = "COL1ROW0", r[r.COL1ROW1 = 5] = "COL1ROW1", r[r.COL1ROW2 = 6] = "COL1ROW2", r[r.COL1ROW3 = 7] = "COL1ROW3", r[r.COL2ROW0 = 8] = "COL2ROW0", r[r.COL2ROW1 = 9] = "COL2ROW1", r[r.COL2ROW2 = 10] = "COL2ROW2", r[r.COL2ROW3 = 11] = "COL2ROW3", r[r.COL3ROW0 = 12] = "COL3ROW0", r[r.COL3ROW1 = 13] = "COL3ROW1", r[r.COL3ROW2 = 14] = "COL3ROW2", r[r.COL3ROW3 = 15] = "COL3ROW3";
})(ev || (ev = {}));
const jN = 45 * Math.PI / 180, VN = 1, bb = 0.1, vb = 500, $N = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
class Bn extends c5 {
  static get IDENTITY() {
    return GN();
  }
  static get ZERO() {
    return qN();
  }
  get ELEMENTS() {
    return 16;
  }
  get RANK() {
    return 4;
  }
  get INDICES() {
    return ev;
  }
  constructor(e) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(e) ? this.copy(e) : this.identity();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this[4] = e[4], this[5] = e[5], this[6] = e[6], this[7] = e[7], this[8] = e[8], this[9] = e[9], this[10] = e[10], this[11] = e[11], this[12] = e[12], this[13] = e[13], this[14] = e[14], this[15] = e[15], this.check();
  }
  // eslint-disable-next-line max-params
  set(e, t, n, i, s, l, o, d, m, b, A, M, E, k, U, V) {
    return this[0] = e, this[1] = t, this[2] = n, this[3] = i, this[4] = s, this[5] = l, this[6] = o, this[7] = d, this[8] = m, this[9] = b, this[10] = A, this[11] = M, this[12] = E, this[13] = k, this[14] = U, this[15] = V, this.check();
  }
  // accepts row major order, stores as column major
  // eslint-disable-next-line max-params
  setRowMajor(e, t, n, i, s, l, o, d, m, b, A, M, E, k, U, V) {
    return this[0] = e, this[1] = s, this[2] = m, this[3] = E, this[4] = t, this[5] = l, this[6] = b, this[7] = k, this[8] = n, this[9] = o, this[10] = A, this[11] = U, this[12] = i, this[13] = d, this[14] = M, this[15] = V, this.check();
  }
  toRowMajor(e) {
    return e[0] = this[0], e[1] = this[4], e[2] = this[8], e[3] = this[12], e[4] = this[1], e[5] = this[5], e[6] = this[9], e[7] = this[13], e[8] = this[2], e[9] = this[6], e[10] = this[10], e[11] = this[14], e[12] = this[3], e[13] = this[7], e[14] = this[11], e[15] = this[15], e;
  }
  // Constructors
  /** Set to identity matrix */
  identity() {
    return this.copy($N);
  }
  /**
   *
   * @param object
   * @returns self
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fromObject(e) {
    return this.check();
  }
  /**
   * Calculates a 4x4 matrix from the given quaternion
   * @param quaternion Quaternion to create matrix from
   * @returns self
   */
  fromQuaternion(e) {
    return EN(this, e), this.check();
  }
  /**
   * Generates a frustum matrix with the given bounds
   * @param view.left - Left bound of the frustum
   * @param view.right - Right bound of the frustum
   * @param view.bottom - Bottom bound of the frustum
   * @param view.top - Top bound of the frustum
   * @param view.near - Near bound of the frustum
   * @param view.far - Far bound of the frustum. Can be set to Infinity.
   * @returns self
   */
  frustum(e) {
    const {
      left: t,
      right: n,
      bottom: i,
      top: s,
      near: l = bb,
      far: o = vb
    } = e;
    return o === 1 / 0 ? HN(this, t, n, i, s, l) : CN(this, t, n, i, s, l, o), this.check();
  }
  /**
   * Generates a look-at matrix with the given eye position, focal point,
   * and up axis
   * @param view.eye - (vector) Position of the viewer
   * @param view.center - (vector) Point the viewer is looking at
   * @param view.up - (vector) Up axis
   * @returns self
   */
  lookAt(e) {
    const {
      eye: t,
      center: n = [0, 0, 0],
      up: i = [0, 1, 0]
    } = e;
    return BN(this, t, n, i), this.check();
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds
   * from "traditional" view space parameters
   * @param view.left - Left bound of the frustum
   * @param view.right number  Right bound of the frustum
   * @param view.bottom - Bottom bound of the frustum
   * @param view.top number  Top bound of the frustum
   * @param view.near - Near bound of the frustum
   * @param view.far number  Far bound of the frustum
   * @returns self
   */
  ortho(e) {
    const {
      left: t,
      right: n,
      bottom: i,
      top: s,
      near: l = bb,
      far: o = vb
    } = e;
    return RN(this, t, n, i, s, l, o), this.check();
  }
  /**
   * Generates an orthogonal projection matrix with the same parameters
   * as a perspective matrix (plus focalDistance)
   * @param view.fovy Vertical field of view in radians
   * @param view.aspect Aspect ratio. Typically viewport width / viewport height
   * @param view.focalDistance Distance in the view frustum used for extent calculations
   * @param view.near Near bound of the frustum
   * @param view.far Far bound of the frustum
   * @returns self
   */
  orthographic(e) {
    const {
      fovy: t = jN,
      aspect: n = VN,
      focalDistance: i = 1,
      near: s = bb,
      far: l = vb
    } = e;
    mT(t);
    const o = t / 2, d = i * Math.tan(o), m = d * n;
    return this.ortho({
      left: -m,
      right: m,
      bottom: -d,
      top: d,
      near: s,
      far: l
    });
  }
  /**
   * Generates a perspective projection matrix with the given bounds
   * @param view.fovy Vertical field of view in radians
   * @param view.aspect Aspect ratio. typically viewport width/height
   * @param view.near Near bound of the frustum
   * @param view.far Far bound of the frustum
   * @returns self
   */
  perspective(e) {
    const {
      fovy: t = 45 * Math.PI / 180,
      aspect: n = 1,
      near: i = 0.1,
      far: s = 500
    } = e;
    return mT(t), MN(this, t, n, i, s), this.check();
  }
  // Accessors
  determinant() {
    return wN(this);
  }
  /**
   * Extracts the non-uniform scale assuming the matrix is an affine transformation.
   * The scales are the "lengths" of the column vectors in the upper-left 3x3 matrix.
   * @param result
   * @returns self
   */
  getScale() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [-0, -0, -0];
    return e[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]), e[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]), e[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]), e;
  }
  /**
   * Gets the translation portion, assuming the matrix is a affine transformation matrix.
   * @param result
   * @returns self
   */
  getTranslation() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [-0, -0, -0];
    return e[0] = this[12], e[1] = this[13], e[2] = this[14], e;
  }
  /**
   * Gets upper left 3x3 pure rotation matrix (non-scaling), assume affine transformation matrix
   * @param result
   * @param scaleResult
   * @returns self
   */
  getRotation(e, t) {
    e = e || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0], t = t || [-0, -0, -0];
    const n = this.getScale(t), i = 1 / n[0], s = 1 / n[1], l = 1 / n[2];
    return e[0] = this[0] * i, e[1] = this[1] * s, e[2] = this[2] * l, e[3] = 0, e[4] = this[4] * i, e[5] = this[5] * s, e[6] = this[6] * l, e[7] = 0, e[8] = this[8] * i, e[9] = this[9] * s, e[10] = this[10] * l, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   *
   * @param result
   * @param scaleResult
   * @returns self
   */
  getRotationMatrix3(e, t) {
    e = e || [-0, -0, -0, -0, -0, -0, -0, -0, -0], t = t || [-0, -0, -0];
    const n = this.getScale(t), i = 1 / n[0], s = 1 / n[1], l = 1 / n[2];
    return e[0] = this[0] * i, e[1] = this[1] * s, e[2] = this[2] * l, e[3] = this[4] * i, e[4] = this[5] * s, e[5] = this[6] * l, e[6] = this[8] * i, e[7] = this[9] * s, e[8] = this[10] * l, e;
  }
  // Modifiers
  transpose() {
    return xN(this, this), this.check();
  }
  invert() {
    return Q1(this, this), this.check();
  }
  // Operations
  multiplyLeft(e) {
    return Nf(this, e, this), this.check();
  }
  multiplyRight(e) {
    return Nf(this, this, e), this.check();
  }
  // Rotates a matrix by the given angle around the X axis
  rotateX(e) {
    return u5(this, this, e), this.check();
  }
  // Rotates a matrix by the given angle around the Y axis.
  rotateY(e) {
    return TN(this, this, e), this.check();
  }
  /**
   * Rotates a matrix by the given angle around the Z axis.
   * @param radians
   * @returns self
   */
  rotateZ(e) {
    return h5(this, this, e), this.check();
  }
  /**
   *
   * @param param0
   * @returns self
   */
  rotateXYZ(e) {
    return this.rotateX(e[0]).rotateY(e[1]).rotateZ(e[2]);
  }
  /**
   *
   * @param radians
   * @param axis
   * @returns self
   */
  rotateAxis(e, t) {
    return AN(this, this, e, t), this.check();
  }
  /**
   *
   * @param factor
   * @returns self
   */
  scale(e) {
    return N2(this, this, Array.isArray(e) ? e : [e, e, e]), this.check();
  }
  /**
   *
   * @param vec
   * @returns self
   */
  translate(e) {
    return J_(this, this, e), this.check();
  }
  // Transforms
  /**
   * Transforms any 2, 3 or 4 element vector. 2 and 3 elements are treated as points
   * @param vector
   * @param result
   * @returns self
   */
  transform(e, t) {
    return e.length === 4 ? (t = _p(t || [-0, -0, -0, -0], e, this), vg(t, 4), t) : this.transformAsPoint(e, t);
  }
  /**
   * Transforms any 2 or 3 element array as point (w implicitly 1)
   * @param vector
   * @param result
   * @returns self
   */
  transformAsPoint(e, t) {
    const {
      length: n
    } = e;
    let i;
    switch (n) {
      case 2:
        i = QC(t || [-0, -0], e, this);
        break;
      case 3:
        i = O2(t || [-0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return vg(i, e.length), i;
  }
  /**
   * Transforms any 2 or 3 element array as vector (w implicitly 0)
   * @param vector
   * @param result
   * @returns self
   */
  transformAsVector(e, t) {
    let n;
    switch (e.length) {
      case 2:
        n = e5(t || [-0, -0], e, this);
        break;
      case 3:
        n = t5(t || [-0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return vg(n, e.length), n;
  }
  /** @deprecated */
  transformPoint(e, t) {
    return this.transformAsPoint(e, t);
  }
  /** @deprecated */
  transformVector(e, t) {
    return this.transformAsPoint(e, t);
  }
  /** @deprecated */
  transformDirection(e, t) {
    return this.transformAsVector(e, t);
  }
  // three.js math API compatibility
  makeRotationX(e) {
    return this.identity().rotateX(e);
  }
  makeTranslation(e, t, n) {
    return this.identity().translate([e, t, n]);
  }
}
let Lm, Om;
function qN() {
  return Lm || (Lm = new Bn([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(Lm)), Lm;
}
function GN() {
  return Om || (Om = new Bn(), Object.freeze(Om)), Om;
}
function mT(r) {
  if (r > Math.PI * 2)
    throw Error("expected radians");
}
function HN(r, e, t, n, i, s) {
  const l = 2 * s / (t - e), o = 2 * s / (i - n), d = (t + e) / (t - e), m = (i + n) / (i - n), b = -1, A = -1, M = -2 * s;
  return r[0] = l, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = o, r[6] = 0, r[7] = 0, r[8] = d, r[9] = m, r[10] = b, r[11] = A, r[12] = 0, r[13] = 0, r[14] = M, r[15] = 0, r;
}
function _T() {
  const r = new Rc(4);
  return Rc != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0), r[3] = 1, r;
}
function WN(r) {
  return r[0] = 0, r[1] = 0, r[2] = 0, r[3] = 1, r;
}
function f5(r, e, t) {
  t = t * 0.5;
  const n = Math.sin(t);
  return r[0] = n * e[0], r[1] = n * e[1], r[2] = n * e[2], r[3] = Math.cos(t), r;
}
function yT(r, e, t) {
  const n = e[0], i = e[1], s = e[2], l = e[3], o = t[0], d = t[1], m = t[2], b = t[3];
  return r[0] = n * b + l * o + i * m - s * d, r[1] = i * b + l * d + s * o - n * m, r[2] = s * b + l * m + n * d - i * o, r[3] = l * b - n * o - i * d - s * m, r;
}
function XN(r, e, t) {
  t *= 0.5;
  const n = e[0], i = e[1], s = e[2], l = e[3], o = Math.sin(t), d = Math.cos(t);
  return r[0] = n * d + l * o, r[1] = i * d + s * o, r[2] = s * d - i * o, r[3] = l * d - n * o, r;
}
function ZN(r, e, t) {
  t *= 0.5;
  const n = e[0], i = e[1], s = e[2], l = e[3], o = Math.sin(t), d = Math.cos(t);
  return r[0] = n * d - s * o, r[1] = i * d + l * o, r[2] = s * d + n * o, r[3] = l * d - i * o, r;
}
function YN(r, e, t) {
  t *= 0.5;
  const n = e[0], i = e[1], s = e[2], l = e[3], o = Math.sin(t), d = Math.cos(t);
  return r[0] = n * d + i * o, r[1] = i * d - n * o, r[2] = s * d + l * o, r[3] = l * d - s * o, r;
}
function KN(r, e) {
  const t = e[0], n = e[1], i = e[2];
  return r[0] = t, r[1] = n, r[2] = i, r[3] = Math.sqrt(Math.abs(1 - t * t - n * n - i * i)), r;
}
function d_(r, e, t, n) {
  const i = e[0], s = e[1], l = e[2], o = e[3];
  let d = t[0], m = t[1], b = t[2], A = t[3], M, E, k, U, V;
  return M = i * d + s * m + l * b + o * A, M < 0 && (M = -M, d = -d, m = -m, b = -b, A = -A), 1 - M > xg ? (E = Math.acos(M), V = Math.sin(E), k = Math.sin((1 - n) * E) / V, U = Math.sin(n * E) / V) : (k = 1 - n, U = n), r[0] = k * i + U * d, r[1] = k * s + U * m, r[2] = k * l + U * b, r[3] = k * o + U * A, r;
}
function JN(r, e) {
  const t = e[0], n = e[1], i = e[2], s = e[3], l = t * t + n * n + i * i + s * s, o = l ? 1 / l : 0;
  return r[0] = -t * o, r[1] = -n * o, r[2] = -i * o, r[3] = s * o, r;
}
function QN(r, e) {
  return r[0] = -e[0], r[1] = -e[1], r[2] = -e[2], r[3] = e[3], r;
}
function d5(r, e) {
  const t = e[0] + e[4] + e[8];
  let n;
  if (t > 0)
    n = Math.sqrt(t + 1), r[3] = 0.5 * n, n = 0.5 / n, r[0] = (e[5] - e[7]) * n, r[1] = (e[6] - e[2]) * n, r[2] = (e[1] - e[3]) * n;
  else {
    let i = 0;
    e[4] > e[0] && (i = 1), e[8] > e[i * 3 + i] && (i = 2);
    const s = (i + 1) % 3, l = (i + 2) % 3;
    n = Math.sqrt(e[i * 3 + i] - e[s * 3 + s] - e[l * 3 + l] + 1), r[i] = 0.5 * n, n = 0.5 / n, r[3] = (e[s * 3 + l] - e[l * 3 + s]) * n, r[s] = (e[s * 3 + i] + e[i * 3 + s]) * n, r[l] = (e[l * 3 + i] + e[i * 3 + l]) * n;
  }
  return r;
}
const eD = ON, tD = D2, rD = FN, nD = UN, iD = kN, sD = NN, p5 = DN, oD = function() {
  const r = n5(), e = dT(1, 0, 0), t = dT(0, 1, 0);
  return function(n, i, s) {
    const l = L2(i, s);
    return l < -0.999999 ? (f_(r, e, i), l5(r) < 1e-6 && f_(r, t, i), iN(r, r), f5(n, r, Math.PI), n) : l > 0.999999 ? (n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 1, n) : (f_(r, i, s), n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = 1 + l, p5(n, n));
  };
}();
(function() {
  const r = _T(), e = _T();
  return function(t, n, i, s, l, o) {
    return d_(r, n, l, o), d_(e, i, s, o), d_(t, r, e, 2 * o * (1 - o)), t;
  };
})();
(function() {
  const r = uN();
  return function(e, t, n, i) {
    return r[0] = n[0], r[3] = n[1], r[6] = n[2], r[1] = i[0], r[4] = i[1], r[7] = i[2], r[2] = -t[0], r[5] = -t[1], r[8] = -t[2], p5(e, d5(e, r));
  };
})();
const aD = [0, 0, 0, 1];
class Rg extends P2 {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
    super(-0, -0, -0, -0), Array.isArray(e) && arguments.length === 1 ? this.copy(e) : this.set(e, t, n, i);
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this.check();
  }
  set(e, t, n, i) {
    return this[0] = e, this[1] = t, this[2] = n, this[3] = i, this.check();
  }
  fromObject(e) {
    return this[0] = e.x, this[1] = e.y, this[2] = e.z, this[3] = e.w, this.check();
  }
  /**
   * Creates a quaternion from the given 3x3 rotation matrix.
   * NOTE: The resultant quaternion is not normalized, so you should
   * be sure to renormalize the quaternion yourself where necessary.
   * @param m
   * @returns
   */
  fromMatrix3(e) {
    return d5(this, e), this.check();
  }
  fromAxisRotation(e, t) {
    return f5(this, e, t), this.check();
  }
  /** Set a quat to the identity quaternion */
  identity() {
    return WN(this), this.check();
  }
  // Set the components of a quat to the given values
  // set(i, j, k, l) {
  //   quat_set(this, i, j, k, l);
  //   return this.check();
  // }
  // Sets a quat from the given angle and rotation axis, then returns it.
  setAxisAngle(e, t) {
    return this.fromAxisRotation(e, t);
  }
  // Getters/setters
  get ELEMENTS() {
    return 4;
  }
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = ei(e);
  }
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = ei(e);
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = ei(e);
  }
  get w() {
    return this[3];
  }
  set w(e) {
    this[3] = ei(e);
  }
  // Calculates the length of a quat
  len() {
    return iD(this);
  }
  // Calculates the squared length of a quat
  lengthSquared() {
    return sD(this);
  }
  // Calculates the dot product of two quat's
  // @return {Number}
  dot(e) {
    return rD(this, e);
  }
  // Gets the rotation axis and angle for a given quaternion.
  // If a quaternion is created with setAxisAngle, this method will
  // return the same values as providied in the original parameter
  // list OR functionally equivalent values.
  // Example: The quaternion formed by axis [0, 0, 1] and angle -90
  // is the same as the quaternion formed by [0, 0, 1] and 270.
  // This method favors the latter.
  // @return {{[x,y,z], Number}}
  // getAxisAngle() {
  //   const axis = [];
  // //   const angle = quat_getAxisAngle(axis, this);
  //   return {axis, angle};
  // }
  // MODIFIERS
  // Sets a quaternion to represent the shortest rotation from one vector
  // to another. Both vectors are assumed to be unit length.
  rotationTo(e, t) {
    return oD(this, e, t), this.check();
  }
  // Sets the specified quaternion with values corresponding to the given axes.
  // Each axis is a vec3 and is expected to be unit length and perpendicular
  // to all other specified axes.
  // setAxes() {
  //   Number
  // }
  // Performs a spherical linear interpolation with two control points
  // sqlerp() {
  //   Number;
  // }
  // Adds two quat's
  add(e) {
    return eD(this, this, e), this.check();
  }
  // Calculates the W component of a quat from the X, Y, and Z components.
  // Any existing W component will be ignored.
  calculateW() {
    return KN(this, this), this.check();
  }
  // Calculates the conjugate of a quat If the quaternion is normalized,
  // this function is faster than quat_invert and produces the same result.
  conjugate() {
    return QN(this, this), this.check();
  }
  // Calculates the inverse of a quat
  invert() {
    return JN(this, this), this.check();
  }
  // Performs a linear interpolation between two quat's
  lerp(e, t, n) {
    return n === void 0 ? this.lerp(this, e, t) : (nD(this, e, t, n), this.check());
  }
  // Multiplies two quat's
  multiplyRight(e) {
    return yT(this, this, e), this.check();
  }
  multiplyLeft(e) {
    return yT(this, e, this), this.check();
  }
  // Normalize a quat
  normalize() {
    const e = this.len(), t = e > 0 ? 1 / e : 0;
    return this[0] = this[0] * t, this[1] = this[1] * t, this[2] = this[2] * t, this[3] = this[3] * t, e === 0 && (this[3] = 1), this.check();
  }
  // Rotates a quaternion by the given angle about the X axis
  rotateX(e) {
    return XN(this, this, e), this.check();
  }
  // Rotates a quaternion by the given angle about the Y axis
  rotateY(e) {
    return ZN(this, this, e), this.check();
  }
  // Rotates a quaternion by the given angle about the Z axis
  rotateZ(e) {
    return YN(this, this, e), this.check();
  }
  // Scales a quat by a scalar number
  scale(e) {
    return tD(this, this, e), this.check();
  }
  // Performs a spherical linear interpolation between two quat
  slerp(e, t, n) {
    let i, s, l;
    switch (arguments.length) {
      case 1:
        ({
          start: i = aD,
          target: s,
          ratio: l
        } = e);
        break;
      case 2:
        i = this, s = e, l = t;
        break;
      default:
        i = e, s = t, l = n;
    }
    return d_(this, i, s, l), this.check();
  }
  transformVector4(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new k2();
    return zN(t, e, this), vg(t, 4);
  }
  // THREE.js Math API compatibility
  lengthSq() {
    return this.lengthSquared();
  }
  setFromAxisAngle(e, t) {
    return this.setAxisAngle(e, t);
  }
  premultiply(e) {
    return this.multiplyLeft(e);
  }
  multiply(e) {
    return this.multiplyRight(e);
  }
}
const lD = 0.1, cD = 1e-12, g5 = 1e-15, uD = 1e-20;
function m5(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const n = Math.fround(r), i = r - n;
  return e[t] = n, e[t + 1] = i, e;
}
function hD(r) {
  return r - Math.fround(r);
}
function fD(r) {
  const e = new Float32Array(32);
  for (let t = 0; t < 4; ++t)
    for (let n = 0; n < 4; ++n) {
      const i = t * 4 + n;
      m5(r[n * 4 + t], e, i * 2);
    }
  return e;
}
const dD = (
  /* glsl */
  `#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND

// All these functions are for substituting tan() function from Intel GPU only
const float TWO_PI = 6.2831854820251465;
const float PI_2 = 1.5707963705062866;
const float PI_16 = 0.1963495463132858;

const float SIN_TABLE_0 = 0.19509032368659973;
const float SIN_TABLE_1 = 0.3826834261417389;
const float SIN_TABLE_2 = 0.5555702447891235;
const float SIN_TABLE_3 = 0.7071067690849304;

const float COS_TABLE_0 = 0.9807852506637573;
const float COS_TABLE_1 = 0.9238795042037964;
const float COS_TABLE_2 = 0.8314695954322815;
const float COS_TABLE_3 = 0.7071067690849304;

const float INVERSE_FACTORIAL_3 = 1.666666716337204e-01; // 1/3!
const float INVERSE_FACTORIAL_5 = 8.333333767950535e-03; // 1/5!
const float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04; // 1/7!
const float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06; // 1/9!

float sin_taylor_fp32(float a) {
  float r, s, t, x;

  if (a == 0.0) {
    return 0.0;
  }

  x = -a * a;
  s = a;
  r = a;

  r = r * x;
  t = r * INVERSE_FACTORIAL_3;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_5;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_7;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_9;
  s = s + t;

  return s;
}

void sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {
  if (a == 0.0) {
    sin_t = 0.0;
    cos_t = 1.0;
  }
  sin_t = sin_taylor_fp32(a);
  cos_t = sqrt(1.0 - sin_t * sin_t);
}

float tan_taylor_fp32(float a) {
    float sin_a;
    float cos_a;

    if (a == 0.0) {
        return 0.0;
    }

    // 2pi range reduction
    float z = floor(a / TWO_PI);
    float r = a - TWO_PI * z;

    float t;
    float q = floor(r / PI_2 + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return 1.0 / 0.0;
    }

    t = r - PI_2 * q;

    q = floor(t / PI_16 + 0.5);
    int k = int(q);
    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return 1.0 / 0.0;
    } else {
        t = t - PI_16 * q;
    }

    float u = 0.0;
    float v = 0.0;

    float sin_t, cos_t;
    float s, c;
    sincos_taylor_fp32(t, sin_t, cos_t);

    if (k == 0) {
        s = sin_t;
        c = cos_t;
    } else {
        if (abs(float(abs_k) - 1.0) < 0.5) {
            u = COS_TABLE_0;
            v = SIN_TABLE_0;
        } else if (abs(float(abs_k) - 2.0) < 0.5) {
            u = COS_TABLE_1;
            v = SIN_TABLE_1;
        } else if (abs(float(abs_k) - 3.0) < 0.5) {
            u = COS_TABLE_2;
            v = SIN_TABLE_2;
        } else if (abs(float(abs_k) - 4.0) < 0.5) {
            u = COS_TABLE_3;
            v = SIN_TABLE_3;
        }
        if (k > 0) {
            s = u * sin_t + v * cos_t;
            c = u * cos_t - v * sin_t;
        } else {
            s = u * sin_t - v * cos_t;
            c = u * cos_t + v * sin_t;
        }
    }

    if (j == 0) {
        sin_a = s;
        cos_a = c;
    } else if (j == 1) {
        sin_a = c;
        cos_a = -s;
    } else if (j == -1) {
        sin_a = -c;
        cos_a = s;
    } else {
        sin_a = -s;
        cos_a = -c;
    }
    return sin_a / cos_a;
}
#endif

float tan_fp32(float a) {
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
  return tan_taylor_fp32(a);
#else
  return tan(a);
#endif
}
`
), pD = {
  name: "fp32",
  vs: dD
}, gD = (
  /* glsl */
  `
uniform fp64arithmeticUniforms {
  uniform float ONE;
} fp64;

/*
About LUMA_FP64_CODE_ELIMINATION_WORKAROUND

The purpose of this workaround is to prevent shader compilers from
optimizing away necessary arithmetic operations by swapping their sequences
or transform the equation to some 'equivalent' form.

The method is to multiply an artifical variable, ONE, which will be known to
the compiler to be 1 only at runtime. The whole expression is then represented
as a polynomial with respective to ONE. In the coefficients of all terms, only one a
and one b should appear

err = (a + b) * ONE^6 - a * ONE^5 - (a + b) * ONE^4 + a * ONE^3 - b - (a + b) * ONE^2 + a * ONE
*/

// Divide float number to high and low floats to extend fraction bits
vec2 split(float a) {
  const float SPLIT = 4097.0;
  float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float a_hi = t * fp64.ONE - (t - a);
  float a_lo = a * fp64.ONE - a_hi;
#else
  float a_hi = t - (t - a);
  float a_lo = a - a_hi;
#endif
  return vec2(a_hi, a_lo);
}

// Divide float number again when high float uses too many fraction bits
vec2 split2(vec2 a) {
  vec2 b = split(a.x);
  b.y += a.y;
  return b;
}

// Special sum operation when a > b
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float sum = (a + b) * fp64.ONE;
  float err = b - (sum - a) * fp64.ONE;
#else
  float sum = a + b;
  float err = b - (sum - a);
#endif
  return vec2(sum, err);
}

// General sum operation
vec2 twoSum(float a, float b) {
  float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE + (b - v);
#else
  float v = s - a;
  float err = (a - (s - v)) + (b - v);
#endif
  return vec2(s, err);
}

vec2 twoSub(float a, float b) {
  float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE - (b + v);
#else
  float v = s - a;
  float err = (a - (s - v)) - (b + v);
#endif
  return vec2(s, err);
}

vec2 twoSqr(float a) {
  float prod = a * a;
  vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float err = ((a_fp64.x * a_fp64.x - prod) * fp64.ONE + 2.0 * a_fp64.x *
    a_fp64.y * fp64.ONE * fp64.ONE) + a_fp64.y * a_fp64.y * fp64.ONE * fp64.ONE * fp64.ONE;
#else
  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
  return vec2(prod, err);
}

vec2 twoProd(float a, float b) {
  float prod = a * b;
  vec2 a_fp64 = split(a);
  vec2 b_fp64 = split(b);
  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
  return vec2(prod, err);
}

vec2 sum_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSum(a.x, b.x);
  t = twoSum(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 sub_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSub(a.x, b.x);
  t = twoSub(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 mul_fp64(vec2 a, vec2 b) {
  vec2 prod = twoProd(a.x, b.x);
  // y component is for the error
  prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  return prod;
}

vec2 div_fp64(vec2 a, vec2 b) {
  float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
  vec2 yn = a * xn;
#endif
  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
  vec2 prod = twoProd(xn, diff);
  return sum_fp64(yn, prod);
}

vec2 sqrt_fp64(vec2 a) {
  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);

  float x = 1.0 / sqrt(a.x);
  float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  vec2 yn_sqr = twoSqr(yn) * fp64.ONE;
#else
  vec2 yn_sqr = twoSqr(yn);
#endif
  float diff = sub_fp64(a, yn_sqr).x;
  vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  return sum_fp64(split(yn), prod);
#else
  return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`
), mD = {
  // Used in LUMA_FP64_CODE_ELIMINATION_WORKAROUND
  ONE: 1
}, _D = {
  name: "fp64arithmetic",
  vs: gD,
  defaultUniforms: mD,
  uniformTypes: {
    ONE: "f32"
  },
  // Additional Functions
  fp64ify: m5,
  fp64LowPart: hD,
  fp64ifyMatrix4: fD
}, yD = [0, 1, 1, 1], bD = (
  /* glsl */
  `uniform pickingUniforms {
  float isActive;
  float isAttribute;
  float isHighlightActive;
  float useFloatColors;
  vec3 highlightedObjectColor;
  vec4 highlightColor;
} picking;

out vec4 picking_vRGBcolor_Avalid;

// Normalize unsigned byte color to 0-1 range
vec3 picking_normalizeColor(vec3 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

// Normalize unsigned byte color to 0-1 range
vec4 picking_normalizeColor(vec4 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

bool picking_isColorZero(vec3 color) {
  return dot(color, vec3(1.0)) < 0.00001;
}

bool picking_isColorValid(vec3 color) {
  return dot(color, vec3(1.0)) > 0.00001;
}

// Check if this vertex is highlighted 
bool isVertexHighlighted(vec3 vertexColor) {
  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);
  return
    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));
}

// Set the current picking color
void picking_setPickingColor(vec3 pickingColor) {
  pickingColor = picking_normalizeColor(pickingColor);

  if (bool(picking.isActive)) {
    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable
    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));

    if (!bool(picking.isAttribute)) {
      // Stores the picking color so that the fragment shader can render it during picking
      picking_vRGBcolor_Avalid.rgb = pickingColor;
    }
  } else {
    // Do the comparison with selected item color in vertex shader as it should mean fewer compares
    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));
  }
}

void picking_setPickingAttribute(float value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.r = value;
  }
}

void picking_setPickingAttribute(vec2 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rg = value;
  }
}

void picking_setPickingAttribute(vec3 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rgb = value;
  }
}
`
), vD = (
  /* glsl */
  `uniform pickingUniforms {
  float isActive;
  float isAttribute;
  float isHighlightActive;
  float useFloatColors;
  vec3 highlightedObjectColor;
  vec4 highlightColor;
} picking;

in vec4 picking_vRGBcolor_Avalid;

/*
 * Returns highlight color if this item is selected.
 */
vec4 picking_filterHighlightColor(vec4 color) {
  // If we are still picking, we don't highlight
  if (picking.isActive > 0.5) {
    return color;
  }

  bool selected = bool(picking_vRGBcolor_Avalid.a);

  if (selected) {
    // Blend in highlight color based on its alpha value
    float highLightAlpha = picking.highlightColor.a;
    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
    float highLightRatio = highLightAlpha / blendedAlpha;

    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);
    return vec4(blendedRGB, blendedAlpha);
  } else {
    return color;
  }
}

/*
 * Returns picking color if picking enabled else unmodified argument.
 */
vec4 picking_filterPickingColor(vec4 color) {
  if (bool(picking.isActive)) {
    if (picking_vRGBcolor_Avalid.a == 0.0) {
      discard;
    }
    return picking_vRGBcolor_Avalid;
  }
  return color;
}

/*
 * Returns picking color if picking is enabled if not
 * highlight color if this item is selected, otherwise unmodified argument.
 */
vec4 picking_filterColor(vec4 color) {
  vec4 highlightColor = picking_filterHighlightColor(color);
  return picking_filterPickingColor(highlightColor);
}
`
), bT = {
  props: {},
  uniforms: {},
  name: "picking",
  uniformTypes: {
    isActive: "f32",
    isAttribute: "f32",
    isHighlightActive: "f32",
    useFloatColors: "f32",
    highlightedObjectColor: "vec3<f32>",
    highlightColor: "vec4<f32>"
  },
  defaultUniforms: {
    isActive: !1,
    isAttribute: !1,
    isHighlightActive: !1,
    useFloatColors: !0,
    highlightedObjectColor: [0, 0, 0],
    highlightColor: yD
  },
  vs: bD,
  fs: vD,
  getUniforms: xD
};
function xD() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const e = {};
  if (r.highlightedObjectColor !== void 0) if (r.highlightedObjectColor === null)
    e.isHighlightActive = !1;
  else {
    e.isHighlightActive = !0;
    const t = r.highlightedObjectColor.slice(0, 3);
    e.highlightedObjectColor = t;
  }
  if (r.highlightColor) {
    const t = Array.from(r.highlightColor, (n) => n / 255);
    Number.isFinite(t[3]) || (t[3] = 1), e.highlightColor = t;
  }
  return r.isActive !== void 0 && (e.isActive = !!r.isActive, e.isAttribute = !!r.isAttribute), r.useFloatColors !== void 0 && (e.useFloatColors = !!r.useFloatColors), e;
}
const vT = (
  /* glsl */
  `precision highp int;

// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  vec3 color;
};

struct PointLight {
  vec3 color;
  vec3 position;
  vec3 attenuation; // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  vec3 color;
  vec3 direction;
};

uniform lightingUniforms {
  int enabled;
  int lightType;

  int directionalLightCount;
  int pointLightCount;

  vec3 ambientColor;

  vec3 lightColor0;
  vec3 lightPosition0;
  vec3 lightDirection0;
  vec3 lightAttenuation0;

  vec3 lightColor1;
  vec3 lightPosition1;
  vec3 lightDirection1;
  vec3 lightAttenuation1;

  vec3 lightColor2;
  vec3 lightPosition2;
  vec3 lightDirection2;
  vec3 lightAttenuation2;
} lighting;

PointLight lighting_getPointLight(int index) {
  switch (index) {
    case 0:
      return PointLight(lighting.lightColor0, lighting.lightPosition0, lighting.lightAttenuation0);
    case 1:
      return PointLight(lighting.lightColor1, lighting.lightPosition1, lighting.lightAttenuation1);
    case 2:
    default:  
      return PointLight(lighting.lightColor2, lighting.lightPosition2, lighting.lightAttenuation2);
  }
}

DirectionalLight lighting_getDirectionalLight(int index) {
  switch (index) {
    case 0:
      return DirectionalLight(lighting.lightColor0, lighting.lightDirection0);
    case 1:
      return DirectionalLight(lighting.lightColor1, lighting.lightDirection1);
    case 2:
    default:   
      return DirectionalLight(lighting.lightColor2, lighting.lightDirection2);
  }
} 

float getPointLightAttenuation(PointLight pointLight, float distance) {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}

// #endif
`
), wD = (
  /* wgsl */
  `// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  color: vec3<f32>,
};

struct PointLight {
  color: vec3<f32>,
  position: vec3<f32>,
  attenuation: vec3<f32>, // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  color: vec3<f32>,
  direction: vec3<f32>,
};

struct lightingUniforms {
  enabled: i32,
  pointLightCount: i32,
  directionalLightCount: i32,

  ambientColor: vec3<f32>,

  // TODO - support multiple lights by uncommenting arrays below
  lightType: i32,
  lightColor: vec3<f32>,
  lightDirection: vec3<f32>,
  lightPosition: vec3<f32>,
  lightAttenuation: vec3<f32>,

  // AmbientLight ambientLight;
  // PointLight pointLight[MAX_LIGHTS];
  // DirectionalLight directionalLight[MAX_LIGHTS];
};

// Binding 0:1 is reserved for lighting (Note: could go into separate bind group as it is stable across draw calls)
@binding(1) @group(0) var<uniform> lighting : lightingUniforms;

fn lighting_getPointLight(index: i32) -> PointLight {
  return PointLight(lighting.lightColor, lighting.lightPosition, lighting.lightAttenuation);
}

fn lighting_getDirectionalLight(index: i32) -> DirectionalLight {
  return DirectionalLight(lighting.lightColor, lighting.lightDirection);
} 

fn getPointLightAttenuation(pointLight: PointLight, distance: f32) -> f32 {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}
`
), _5 = 3, AD = 255;
var Bg;
(function(r) {
  r[r.POINT = 0] = "POINT", r[r.DIRECTIONAL = 1] = "DIRECTIONAL";
})(Bg || (Bg = {}));
const Hd = {
  props: {},
  uniforms: {},
  name: "lighting",
  defines: {
    MAX_LIGHTS: _5
  },
  uniformTypes: {
    enabled: "i32",
    lightType: "i32",
    directionalLightCount: "i32",
    pointLightCount: "i32",
    ambientLightColor: "vec3<f32>",
    // TODO define as arrays once we have appropriate uniformTypes
    lightColor0: "vec3<f32>",
    lightPosition0: "vec3<f32>",
    // TODO - could combine direction and attenuation
    lightDirection0: "vec3<f32>",
    lightAttenuation0: "vec3<f32>",
    lightColor1: "vec3<f32>",
    lightPosition1: "vec3<f32>",
    lightDirection1: "vec3<f32>",
    lightAttenuation1: "vec3<f32>",
    lightColor2: "vec3<f32>",
    lightPosition2: "vec3<f32>",
    lightDirection2: "vec3<f32>",
    lightAttenuation2: "vec3<f32>"
  },
  defaultUniforms: {
    enabled: 1,
    lightType: Bg.POINT,
    directionalLightCount: 0,
    pointLightCount: 0,
    ambientLightColor: [0.1, 0.1, 0.1],
    lightColor0: [1, 1, 1],
    lightPosition0: [1, 1, 2],
    // TODO - could combine direction and attenuation
    lightDirection0: [1, 1, 1],
    lightAttenuation0: [1, 0, 0],
    lightColor1: [1, 1, 1],
    lightPosition1: [1, 1, 2],
    lightDirection1: [1, 1, 1],
    lightAttenuation1: [1, 0, 0],
    lightColor2: [1, 1, 1],
    lightPosition2: [1, 1, 2],
    lightDirection2: [1, 1, 1],
    lightAttenuation2: [1, 0, 0]
  },
  source: wD,
  vs: vT,
  fs: vT,
  getUniforms: TD
};
function TD(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (r = r && {
    ...r
  }, !r)
    return {
      ...Hd.defaultUniforms
    };
  r.lights && (r = {
    ...r,
    ...ED(r.lights),
    lights: void 0
  });
  const {
    ambientLight: t,
    pointLights: n,
    directionalLights: i
  } = r || {};
  if (!(t || n && n.length > 0 || i && i.length > 0))
    return {
      ...Hd.defaultUniforms,
      enabled: 0
    };
  const l = {
    ...Hd.defaultUniforms,
    ...e,
    ...SD({
      ambientLight: t,
      pointLights: n,
      directionalLights: i
    })
  };
  return r.enabled !== void 0 && (l.enabled = r.enabled ? 1 : 0), l;
}
function SD(r) {
  let {
    ambientLight: e,
    pointLights: t = [],
    directionalLights: n = []
  } = r;
  const i = {};
  i.ambientLightColor = xb(e);
  let s = 0;
  for (const l of t) {
    i.lightType = Bg.POINT;
    const o = s;
    i[`lightColor${o}`] = xb(l), i[`lightPosition${o}`] = l.position, i[`lightAttenuation${o}`] = l.attenuation || [1, 0, 0], s++;
  }
  for (const l of n) {
    i.lightType = Bg.DIRECTIONAL;
    const o = s;
    i[`lightColor${o}`] = xb(l), i[`lightDirection${o}`] = l.direction, s++;
  }
  return s > _5 && cr.warn("MAX_LIGHTS exceeded")(), i.directionalLightCount = n.length, i.pointLightCount = t.length, i;
}
function ED(r) {
  var t, n;
  const e = {
    pointLights: [],
    directionalLights: []
  };
  for (const i of r || [])
    switch (i.type) {
      case "ambient":
        e.ambientLight = i;
        break;
      case "directional":
        (t = e.directionalLights) == null || t.push(i);
        break;
      case "point":
        (n = e.pointLights) == null || n.push(i);
        break;
    }
  return e;
}
function xb() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    color: e = [0, 0, 0],
    intensity: t = 1
  } = r;
  return e.map((n) => n * t / AD);
}
const y5 = (
  /* glsl */
  `uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;
`
), b5 = (
  /* glsl */
  `uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
  vec3 halfway_direction = normalize(light_direction + view_direction);
  float lambertian = dot(light_direction, normal_worldspace);
  float specular = 0.0;
  if (lambertian > 0.0) {
    float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, material.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;
}

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  vec3 view_direction = normalize(cameraPosition - position_worldspace);
  lightColor = material.ambient * surfaceColor * lighting.ambientColor;

  for (int i = 0; i < lighting.pointLightCount; i++) {
    PointLight pointLight = lighting_getPointLight(i);
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    float light_attenuation = getPointLightAttenuation(pointLight, distance(light_position_worldspace, position_worldspace));
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color / light_attenuation);
  }

  int totalLights = min(MAX_LIGHTS, lighting.pointLightCount + lighting.directionalLightCount);
  for (int i = lighting.pointLightCount; i < totalLights; i++) {
    DirectionalLight directionalLight = lighting_getDirectionalLight(i);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
}
`
), v5 = (
  /* wgsl */
  `struct phongMaterialUniforms {
  ambient: f32,
  diffuse: f32,
  shininess: f32,
  specularColor: vec3<f32>,
};

@binding(2) @group(0) var<uniform> phongMaterial : phongMaterialUniforms;

fn lighting_getLightColor(surfaceColor: vec3<f32>, light_direction: vec3<f32>, view_direction: vec3<f32>, normal_worldspace: vec3<f32>, color: vec3<f32>) -> vec3<f32> {
  let halfway_direction: vec3<f32> = normalize(light_direction + view_direction);
  var lambertian: f32 = dot(light_direction, normal_worldspace);
  var specular: f32 = 0.0;
  if (lambertian > 0.0) {
    let specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, phongMaterial.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * phongMaterial.diffuse * surfaceColor + specular * phongMaterial.specularColor) * color;
}

fn lighting_getLightColor2(surfaceColor: vec3<f32>, cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32> {
  var lightColor: vec3<f32> = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  let view_direction: vec3<f32> = normalize(cameraPosition - position_worldspace);
  lightColor = phongMaterial.ambient * surfaceColor * lighting.ambientColor;

  if (lighting.lightType == 0) {
    let pointLight: PointLight  = lighting_getPointLight(0);
    let light_position_worldspace: vec3<f32> = pointLight.position;
    let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  } else if (lighting.lightType == 1) {
    var directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
  /*
  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.pointLightCount) {
      break;
    }
    PointLight pointLight = lighting.pointLight[i];
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  }

  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.directionalLightCount) {
      break;
    }
    DirectionalLight directionalLight = lighting.directionalLight[i];
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  */
}

fn lighting_getSpecularLightColor(cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32>{
  var lightColor = vec3<f32>(0, 0, 0);
  let surfaceColor = vec3<f32>(0, 0, 0);

  if (lighting.enabled == 0) {
    let view_direction = normalize(cameraPosition - position_worldspace);

    switch (lighting.lightType) {
      case 0, default: {
        let pointLight: PointLight = lighting_getPointLight(0);
        let light_position_worldspace: vec3<f32> = pointLight.position;
        let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
        lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
      }
      case 1: {
        let directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
        lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
      }
    }
  }
  return lightColor;
}
`
), x5 = {
  props: {},
  name: "gouraudMaterial",
  // Note these are switched between phong and gouraud
  vs: b5.replace("phongMaterial", "gouraudMaterial"),
  fs: y5.replace("phongMaterial", "gouraudMaterial"),
  source: v5.replaceAll("phongMaterial", "gouraudMaterial"),
  defines: {
    LIGHTING_VERTEX: 1
  },
  dependencies: [Hd],
  uniformTypes: {
    ambient: "f32",
    diffuse: "f32",
    shininess: "f32",
    specularColor: "vec3<f32>"
  },
  defaultUniforms: {
    ambient: 0.35,
    diffuse: 0.6,
    shininess: 32,
    specularColor: [0.15, 0.15, 0.15]
  },
  getUniforms(r) {
    const e = {
      ...r
    };
    return e.specularColor && (e.specularColor = e.specularColor.map((t) => t / 255)), {
      ...x5.defaultUniforms,
      ...e
    };
  }
}, w5 = {
  name: "phongMaterial",
  dependencies: [Hd],
  // Note these are switched between phong and gouraud
  source: v5,
  vs: y5,
  fs: b5,
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  uniformTypes: {
    ambient: "f32",
    diffuse: "f32",
    shininess: "f32",
    specularColor: "vec3<f32>"
  },
  defaultUniforms: {
    ambient: 0.35,
    diffuse: 0.6,
    shininess: 32,
    specularColor: [0.15, 0.15, 0.15]
  },
  getUniforms(r) {
    const e = {
      ...r
    };
    return e.specularColor && (e.specularColor = e.specularColor.map((t) => t / 255)), {
      ...w5.defaultUniforms,
      ...e
    };
  }
}, CD = (
  /* glsl */
  `out vec3 pbr_vPosition;
out vec2 pbr_vUV;

#ifdef HAS_NORMALS
# ifdef HAS_TANGENTS
out mat3 pbr_vTBN;
# else
out vec3 pbr_vNormal;
# endif
#endif

void pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)
{
  vec4 pos = pbrProjection.modelMatrix * position;
  pbr_vPosition = vec3(pos.xyz) / pos.w;

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
  vec3 normalW = normalize(vec3(pbrProjection.normalMatrix * vec4(normal.xyz, 0.0)));
  vec3 tangentW = normalize(vec3(pbrProjection.modelMatrix * vec4(tangent.xyz, 0.0)));
  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;
  pbr_vTBN = mat3(tangentW, bitangentW, normalW);
#else // HAS_TANGENTS != 1
  pbr_vNormal = normalize(vec3(pbrProjection.modelMatrix * vec4(normal.xyz, 0.0)));
#endif
#endif

#ifdef HAS_UV
  pbr_vUV = uv;
#else
  pbr_vUV = vec2(0.,0.);
#endif
}
`
), ID = (
  /* glsl */
  `precision highp float;

uniform pbrMaterialUniforms {
  // Material is unlit
  bool unlit;

  // Base color map
  bool baseColorMapEnabled;
  vec4 baseColorFactor;

  bool normalMapEnabled;  
  float normalScale; // #ifdef HAS_NORMALMAP

  bool emissiveMapEnabled;
  vec3 emissiveFactor; // #ifdef HAS_EMISSIVEMAP

  vec2 metallicRoughnessValues;
  bool metallicRoughnessMapEnabled;

  bool occlusionMapEnabled;
  float occlusionStrength; // #ifdef HAS_OCCLUSIONMAP
  
  bool alphaCutoffEnabled;
  float alphaCutoff; // #ifdef ALPHA_CUTOFF
  
  // IBL
  bool IBLenabled;
  vec2 scaleIBLAmbient; // #ifdef USE_IBL
  
  // debugging flags used for shader output of intermediate PBR variables
  // #ifdef PBR_DEBUG
  vec4 scaleDiffBaseMR;
  vec4 scaleFGDSpec;
  // #endif
} pbrMaterial;

// Samplers
#ifdef HAS_BASECOLORMAP
uniform sampler2D pbr_baseColorSampler;
#endif
#ifdef HAS_NORMALMAP
uniform sampler2D pbr_normalSampler;
#endif
#ifdef HAS_EMISSIVEMAP
uniform sampler2D pbr_emissiveSampler;
#endif
#ifdef HAS_METALROUGHNESSMAP
uniform sampler2D pbr_metallicRoughnessSampler;
#endif
#ifdef HAS_OCCLUSIONMAP
uniform sampler2D pbr_occlusionSampler;
#endif
#ifdef USE_IBL
uniform samplerCube pbr_diffuseEnvSampler;
uniform samplerCube pbr_specularEnvSampler;
uniform sampler2D pbr_brdfLUT;
#endif

// Inputs from vertex shader

in vec3 pbr_vPosition;
in vec2 pbr_vUV;

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
in mat3 pbr_vTBN;
#else
in vec3 pbr_vNormal;
#endif
#endif

// Encapsulate the various inputs used by the various functions in the shading equation
// We store values in this struct to simplify the integration of alternative implementations
// of the shading terms, outlined in the Readme.MD Appendix.
struct PBRInfo {
  float NdotL;                  // cos angle between normal and light direction
  float NdotV;                  // cos angle between normal and view direction
  float NdotH;                  // cos angle between normal and half vector
  float LdotH;                  // cos angle between light direction and half vector
  float VdotH;                  // cos angle between view direction and half vector
  float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)
  float metalness;              // metallic value at the surface
  vec3 reflectance0;            // full reflectance color (normal incidence angle)
  vec3 reflectance90;           // reflectance color at grazing angle
  float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])
  vec3 diffuseColor;            // color contribution from diffuse lighting
  vec3 specularColor;           // color contribution from specular lighting
  vec3 n;                       // normal at surface point
  vec3 v;                       // vector from surface point to camera
};

const float M_PI = 3.141592653589793;
const float c_MinRoughness = 0.04;

vec4 SRGBtoLINEAR(vec4 srgbIn)
{
#ifdef MANUAL_SRGB
#ifdef SRGB_FAST_APPROXIMATION
  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));
#else // SRGB_FAST_APPROXIMATION
  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);
  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );
#endif //SRGB_FAST_APPROXIMATION
  return vec4(linOut,srgbIn.w);;
#else //MANUAL_SRGB
  return srgbIn;
#endif //MANUAL_SRGB
}

// Find the normal for this fragment, pulling either from a predefined normal map
// or from the interpolated mesh normal and tangent attributes.
vec3 getNormal()
{
  // Retrieve the tangent space matrix
#ifndef HAS_TANGENTS
  vec3 pos_dx = dFdx(pbr_vPosition);
  vec3 pos_dy = dFdy(pbr_vPosition);
  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));
  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));
  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);

#ifdef HAS_NORMALS
  vec3 ng = normalize(pbr_vNormal);
#else
  vec3 ng = cross(pos_dx, pos_dy);
#endif

  t = normalize(t - ng * dot(ng, t));
  vec3 b = normalize(cross(ng, t));
  mat3 tbn = mat3(t, b, ng);
#else // HAS_TANGENTS
  mat3 tbn = pbr_vTBN;
#endif

#ifdef HAS_NORMALMAP
  vec3 n = texture(pbr_normalSampler, pbr_vUV).rgb;
  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(pbrMaterial.normalScale, pbrMaterial.normalScale, 1.0)));
#else
  // The tbn matrix is linearly interpolated, so we need to re-normalize
  vec3 n = normalize(tbn[2].xyz);
#endif

  return n;
}

// Calculation of the lighting contribution from an optional Image Based Light source.
// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].
// See our README.md on Environment Maps [3] for additional discussion.
#ifdef USE_IBL
vec3 getIBLContribution(PBRInfo pbrInfo, vec3 n, vec3 reflection)
{
  float mipCount = 9.0; // resolution of 512x512
  float lod = (pbrInfo.perceptualRoughness * mipCount);
  // retrieve a scale and bias to F0. See [1], Figure 3
  vec3 brdf = SRGBtoLINEAR(texture(pbr_brdfLUT,
    vec2(pbrInfo.NdotV, 1.0 - pbrInfo.perceptualRoughness))).rgb;
  vec3 diffuseLight = SRGBtoLINEAR(texture(pbr_diffuseEnvSampler, n)).rgb;

#ifdef USE_TEX_LOD
  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection, lod)).rgb;
#else
  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection)).rgb;
#endif

  vec3 diffuse = diffuseLight * pbrInfo.diffuseColor;
  vec3 specular = specularLight * (pbrInfo.specularColor * brdf.x + brdf.y);

  // For presentation, this allows us to disable IBL terms
  diffuse *= pbrMaterial.scaleIBLAmbient.x;
  specular *= pbrMaterial.scaleIBLAmbient.y;

  return diffuse + specular;
}
#endif

// Basic Lambertian diffuse
// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog
// See also [1], Equation 1
vec3 diffuse(PBRInfo pbrInfo)
{
  return pbrInfo.diffuseColor / M_PI;
}

// The following equation models the Fresnel reflectance term of the spec equation (aka F())
// Implementation of fresnel from [4], Equation 15
vec3 specularReflection(PBRInfo pbrInfo)
{
  return pbrInfo.reflectance0 +
    (pbrInfo.reflectance90 - pbrInfo.reflectance0) *
    pow(clamp(1.0 - pbrInfo.VdotH, 0.0, 1.0), 5.0);
}

// This calculates the specular geometric attenuation (aka G()),
// where rougher material will reflect less light back to the viewer.
// This implementation is based on [1] Equation 4, and we adopt their modifications to
// alphaRoughness as input as originally proposed in [2].
float geometricOcclusion(PBRInfo pbrInfo)
{
  float NdotL = pbrInfo.NdotL;
  float NdotV = pbrInfo.NdotV;
  float r = pbrInfo.alphaRoughness;

  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));
  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));
  return attenuationL * attenuationV;
}

// The following equation(s) model the distribution of microfacet normals across
// the area being drawn (aka D())
// Implementation from "Average Irregularity Representation of a Roughened Surface
// for Ray Reflection" by T. S. Trowbridge, and K. P. Reitz
// Follows the distribution function recommended in the SIGGRAPH 2013 course notes
// from EPIC Games [1], Equation 3.
float microfacetDistribution(PBRInfo pbrInfo)
{
  float roughnessSq = pbrInfo.alphaRoughness * pbrInfo.alphaRoughness;
  float f = (pbrInfo.NdotH * roughnessSq - pbrInfo.NdotH) * pbrInfo.NdotH + 1.0;
  return roughnessSq / (M_PI * f * f);
}

void PBRInfo_setAmbientLight(inout PBRInfo pbrInfo) {
  pbrInfo.NdotL = 1.0;
  pbrInfo.NdotH = 0.0;
  pbrInfo.LdotH = 0.0;
  pbrInfo.VdotH = 1.0;
}

void PBRInfo_setDirectionalLight(inout PBRInfo pbrInfo, vec3 lightDirection) {
  vec3 n = pbrInfo.n;
  vec3 v = pbrInfo.v;
  vec3 l = normalize(lightDirection);             // Vector from surface point to light
  vec3 h = normalize(l+v);                        // Half vector between both l and v

  pbrInfo.NdotL = clamp(dot(n, l), 0.001, 1.0);
  pbrInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);
  pbrInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);
  pbrInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);
}

void PBRInfo_setPointLight(inout PBRInfo pbrInfo, PointLight pointLight) {
  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);
  PBRInfo_setDirectionalLight(pbrInfo, light_direction);
}

vec3 calculateFinalColor(PBRInfo pbrInfo, vec3 lightColor) {
  // Calculate the shading terms for the microfacet specular shading model
  vec3 F = specularReflection(pbrInfo);
  float G = geometricOcclusion(pbrInfo);
  float D = microfacetDistribution(pbrInfo);

  // Calculation of analytical lighting contribution
  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInfo);
  vec3 specContrib = F * G * D / (4.0 * pbrInfo.NdotL * pbrInfo.NdotV);
  // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)
  return pbrInfo.NdotL * lightColor * (diffuseContrib + specContrib);
}

vec4 pbr_filterColor(vec4 colorUnused)
{
  // The albedo may be defined from a base texture or a flat color
#ifdef HAS_BASECOLORMAP
  vec4 baseColor = SRGBtoLINEAR(texture(pbr_baseColorSampler, pbr_vUV)) * pbrMaterial.baseColorFactor;
#else
  vec4 baseColor = pbrMaterial.baseColorFactor;
#endif

#ifdef ALPHA_CUTOFF
  if (baseColor.a < pbrMaterial.alphaCutoff) {
    discard;
  }
#endif

  vec3 color = vec3(0, 0, 0);

  if(pbrMaterial.unlit){
    color.rgb = baseColor.rgb;
  }
  else{
    // Metallic and Roughness material properties are packed together
    // In glTF, these factors can be specified by fixed scalar values
    // or from a metallic-roughness map
    float perceptualRoughness = pbrMaterial.metallicRoughnessValues.y;
    float metallic = pbrMaterial.metallicRoughnessValues.x;
#ifdef HAS_METALROUGHNESSMAP
    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.
    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data
    vec4 mrSample = texture(pbr_metallicRoughnessSampler, pbr_vUV);
    perceptualRoughness = mrSample.g * perceptualRoughness;
    metallic = mrSample.b * metallic;
#endif
    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);
    metallic = clamp(metallic, 0.0, 1.0);
    // Roughness is authored as perceptual roughness; as is convention,
    // convert to material roughness by squaring the perceptual roughness [2].
    float alphaRoughness = perceptualRoughness * perceptualRoughness;

    vec3 f0 = vec3(0.04);
    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);
    diffuseColor *= 1.0 - metallic;
    vec3 specularColor = mix(f0, baseColor.rgb, metallic);

    // Compute reflectance.
    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);

    // For typical incident reflectance range (between 4% to 100%) set the grazing
    // reflectance to 100% for typical fresnel effect.
    // For very low reflectance range on highly diffuse objects (below 4%),
    // incrementally reduce grazing reflecance to 0%.
    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
    vec3 specularEnvironmentR0 = specularColor.rgb;
    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;

    vec3 n = getNormal();                          // normal at surface point
    vec3 v = normalize(pbrProjection.camera - pbr_vPosition);  // Vector from surface point to camera

    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
    vec3 reflection = -normalize(reflect(v, n));

    PBRInfo pbrInfo = PBRInfo(
      0.0, // NdotL
      NdotV,
      0.0, // NdotH
      0.0, // LdotH
      0.0, // VdotH
      perceptualRoughness,
      metallic,
      specularEnvironmentR0,
      specularEnvironmentR90,
      alphaRoughness,
      diffuseColor,
      specularColor,
      n,
      v
    );


#ifdef USE_LIGHTS
    // Apply ambient light
    PBRInfo_setAmbientLight(pbrInfo);
    color += calculateFinalColor(pbrInfo, lighting.ambientColor);

    // Apply directional light
    for(int i = 0; i < lighting.directionalLightCount; i++) {
      if (i < lighting.directionalLightCount) {
        PBRInfo_setDirectionalLight(pbrInfo, lighting_getDirectionalLight(i).direction);
        color += calculateFinalColor(pbrInfo, lighting_getDirectionalLight(i).color);
      }
    }

    // Apply point light
    for(int i = 0; i < lighting.pointLightCount; i++) {
      if (i < lighting.pointLightCount) {
        PBRInfo_setPointLight(pbrInfo, lighting_getPointLight(i));
        float attenuation = getPointLightAttenuation(lighting_getPointLight(i), distance(lighting_getPointLight(i).position, pbr_vPosition));
        color += calculateFinalColor(pbrInfo, lighting_getPointLight(i).color / attenuation);
      }
    }
#endif

    // Calculate lighting contribution from image based lighting source (IBL)
#ifdef USE_IBL
    if (pbrMaterial.IBLenabled) {
      color += getIBLContribution(pbrInfo, n, reflection);
    }
#endif

 // Apply optional PBR terms for additional (optional) shading
#ifdef HAS_OCCLUSIONMAP
    if (pbrMaterial.occlusionMapEnabled) {
      float ao = texture(pbr_occlusionSampler, pbr_vUV).r;
      color = mix(color, color * ao, pbrMaterial.occlusionStrength);
    }
#endif

#ifdef HAS_EMISSIVEMAP
    if (pbrMaterial.emissiveMapEnabled) {
      vec3 emissive = SRGBtoLINEAR(texture(pbr_emissiveSampler, pbr_vUV)).rgb * pbrMaterial.emissiveFactor;
      color += emissive;
    }
#endif

    // This section uses mix to override final color for reference app visualization
    // of various parameters in the lighting equation.
#ifdef PBR_DEBUG
    // TODO: Figure out how to debug multiple lights

    // color = mix(color, F, pbr_scaleFGDSpec.x);
    // color = mix(color, vec3(G), pbr_scaleFGDSpec.y);
    // color = mix(color, vec3(D), pbr_scaleFGDSpec.z);
    // color = mix(color, specContrib, pbr_scaleFGDSpec.w);

    // color = mix(color, diffuseContrib, pbr_scaleDiffBaseMR.x);
    color = mix(color, baseColor.rgb, pbrMaterial.scaleDiffBaseMR.y);
    color = mix(color, vec3(metallic), pbrMaterial.scaleDiffBaseMR.z);
    color = mix(color, vec3(perceptualRoughness), pbrMaterial.scaleDiffBaseMR.w);
#endif

  }

  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);
}
`
), xT = (
  /* glsl */
  `uniform pbrProjectionUniforms {
  mat4 modelViewProjectionMatrix;
  mat4 modelMatrix;
  mat4 normalMatrix;
  vec3 camera;
} pbrProjection;
`
), MD = {
  name: "pbrProjection",
  vs: xT,
  fs: xT,
  // TODO why is this needed?
  getUniforms: (r) => r,
  uniformTypes: {
    modelViewProjectionMatrix: "mat4x4<f32>",
    modelMatrix: "mat4x4<f32>",
    normalMatrix: "mat4x4<f32>",
    camera: "vec3<i32>"
  }
}, F2 = {
  props: {},
  uniforms: {},
  name: "pbrMaterial",
  dependencies: [Hd, MD],
  vs: CD,
  fs: ID,
  defines: {
    LIGHTING_FRAGMENT: 1
    // TODO defining these as 0 breaks shader
    // HAS_NORMALMAP: 0
    // HAS_EMISSIVEMAP: 0,
    // HAS_OCCLUSIONMAP: 0,
    // HAS_BASECOLORMAP: 0,
    // HAS_METALROUGHNESSMAP: 0,
    // ALPHA_CUTOFF: 0
    // USE_IBL: 0
    // PBR_DEBUG: 0
  },
  getUniforms: (r) => r,
  uniformTypes: {
    // Material is unlit
    unlit: "i32",
    // Base color map
    baseColorMapEnabled: "i32",
    baseColorFactor: "vec4<f32>",
    normalMapEnabled: "i32",
    normalScale: "f32",
    // #ifdef HAS_NORMALMAP
    emissiveMapEnabled: "i32",
    emissiveFactor: "vec3<f32>",
    // #ifdef HAS_EMISSIVEMAP
    metallicRoughnessValues: "vec2<f32>",
    metallicRoughnessMapEnabled: "i32",
    occlusionMapEnabled: "i32",
    occlusionStrength: "f32",
    // #ifdef HAS_OCCLUSIONMAP
    alphaCutoffEnabled: "i32",
    alphaCutoff: "f32",
    // #ifdef ALPHA_CUTOFF
    // IBL
    IBLenabled: "i32",
    scaleIBLAmbient: "vec2<f32>",
    // #ifdef USE_IBL
    // debugging flags used for shader output of intermediate PBR variables
    // #ifdef PBR_DEBUG
    scaleDiffBaseMR: "vec4<f32>",
    scaleFGDSpec: "vec4<f32>"
  }
}, wT = `uniform layerUniforms {
  uniform float opacity;
} layer;
`, PD = {
  name: "layer",
  vs: wT,
  fs: wT,
  getUniforms: (r) => ({
    // apply gamma to opacity to make it visually "linear"
    // TODO - v10: use raw opacity?
    opacity: Math.pow(r.opacity, 1 / 2.2)
  }),
  uniformTypes: {
    opacity: "f32"
  }
}, RD = (
  /* wgsl */
  `const SMOOTH_EDGE_RADIUS: f32 = 0.5;

struct VertexGeometry {
  position: vec4<f32>,
  worldPosition: vec3<f32>,
  worldPositionAlt: vec3<f32>,
  normal: vec3<f32>,
  uv: vec2<f32>,
  pickingColor: vec3<f32>,
};

var<private> geometry_: VertexGeometry = VertexGeometry(
  vec4<f32>(0.0, 0.0, 1.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec2<f32>(0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0)
);

struct FragmentGeometry {
  uv: vec2<f32>,
};

var<private> fragmentGeometry: FragmentGeometry;

fn smoothedge(edge: f32, x: f32) -> f32 {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`
), A5 = "#define SMOOTH_EDGE_RADIUS 0.5", BD = (
  /* glsl */
  `${A5}

struct VertexGeometry {
  vec4 position;
  vec3 worldPosition;
  vec3 worldPositionAlt;
  vec3 normal;
  vec2 uv;
  vec3 pickingColor;
} geometry = VertexGeometry(
  vec4(0.0, 0.0, 1.0, 0.0),
  vec3(0.0),
  vec3(0.0),
  vec3(0.0),
  vec2(0.0),
  vec3(0.0)
);
`
), LD = (
  /* glsl */
  `${A5}

struct FragmentGeometry {
  vec2 uv;
} geometry;

float smoothedge(float edge, float x) {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`
), T5 = {
  name: "geometry",
  source: RD,
  vs: BD,
  fs: LD
}, OD = 25;
var js;
(function(r) {
  r[r.Start = 1] = "Start", r[r.Move = 2] = "Move", r[r.End = 4] = "End", r[r.Cancel = 8] = "Cancel";
})(js || (js = {}));
var to;
(function(r) {
  r[r.None = 0] = "None", r[r.Left = 1] = "Left", r[r.Right = 2] = "Right", r[r.Up = 4] = "Up", r[r.Down = 8] = "Down", r[r.Horizontal = 3] = "Horizontal", r[r.Vertical = 12] = "Vertical", r[r.All = 15] = "All";
})(to || (to = {}));
var _n;
(function(r) {
  r[r.Possible = 1] = "Possible", r[r.Began = 2] = "Began", r[r.Changed = 4] = "Changed", r[r.Ended = 8] = "Ended", r[r.Recognized = 8] = "Recognized", r[r.Cancelled = 16] = "Cancelled", r[r.Failed = 32] = "Failed";
})(_n || (_n = {}));
const kD = "compute", ND = "auto", tv = "manipulation", p_ = "none", rv = "pan-x", nv = "pan-y";
function DD(r) {
  if (r.includes(p_))
    return p_;
  const e = r.includes(rv), t = r.includes(nv);
  return e && t ? p_ : e || t ? e ? rv : nv : r.includes(tv) ? tv : ND;
}
class FD {
  constructor(e, t) {
    this.actions = "", this.manager = e, this.set(t);
  }
  /**
   * set the touchAction value on the element or enable the polyfill
   */
  set(e) {
    e === kD && (e = this.compute()), this.manager.element && (this.manager.element.style.touchAction = e, this.actions = e);
  }
  /**
   * just re-set the touchAction value
   */
  update() {
    this.set(this.manager.options.touchAction);
  }
  /**
   * compute the value for the touchAction property based on the recognizer's settings
   */
  compute() {
    let e = [];
    for (const t of this.manager.recognizers)
      t.options.enable && (e = e.concat(t.getTouchAction()));
    return DD(e.join(" "));
  }
}
function Q_(r) {
  return r.trim().split(/\s+/g);
}
function wb(r, e, t) {
  if (r)
    for (const n of Q_(e))
      r.addEventListener(n, t, !1);
}
function Ab(r, e, t) {
  if (r)
    for (const n of Q_(e))
      r.removeEventListener(n, t, !1);
}
function AT(r) {
  return (r.ownerDocument || r).defaultView;
}
function UD(r, e) {
  let t = r;
  for (; t; ) {
    if (t === e)
      return !0;
    t = t.parentNode;
  }
  return !1;
}
function S5(r) {
  const e = r.length;
  if (e === 1)
    return {
      x: Math.round(r[0].clientX),
      y: Math.round(r[0].clientY)
    };
  let t = 0, n = 0, i = 0;
  for (; i < e; )
    t += r[i].clientX, n += r[i].clientY, i++;
  return {
    x: Math.round(t / e),
    y: Math.round(n / e)
  };
}
function TT(r) {
  const e = [];
  let t = 0;
  for (; t < r.pointers.length; )
    e[t] = {
      clientX: Math.round(r.pointers[t].clientX),
      clientY: Math.round(r.pointers[t].clientY)
    }, t++;
  return {
    timeStamp: Date.now(),
    pointers: e,
    center: S5(e),
    deltaX: r.deltaX,
    deltaY: r.deltaY
  };
}
function E5(r, e) {
  const t = e.x - r.x, n = e.y - r.y;
  return Math.sqrt(t * t + n * n);
}
function ST(r, e) {
  const t = e.clientX - r.clientX, n = e.clientY - r.clientY;
  return Math.sqrt(t * t + n * n);
}
function zD(r, e) {
  const t = e.x - r.x, n = e.y - r.y;
  return Math.atan2(n, t) * 180 / Math.PI;
}
function ET(r, e) {
  const t = e.clientX - r.clientX, n = e.clientY - r.clientY;
  return Math.atan2(n, t) * 180 / Math.PI;
}
function C5(r, e) {
  return r === e ? to.None : Math.abs(r) >= Math.abs(e) ? r < 0 ? to.Left : to.Right : e < 0 ? to.Up : to.Down;
}
function jD(r, e) {
  const t = e.center;
  let n = r.offsetDelta, i = r.prevDelta;
  const s = r.prevInput;
  return (e.eventType === js.Start || (s == null ? void 0 : s.eventType) === js.End) && (i = r.prevDelta = {
    x: (s == null ? void 0 : s.deltaX) || 0,
    y: (s == null ? void 0 : s.deltaY) || 0
  }, n = r.offsetDelta = {
    x: t.x,
    y: t.y
  }), {
    deltaX: i.x + (t.x - n.x),
    deltaY: i.y + (t.y - n.y)
  };
}
function I5(r, e, t) {
  return {
    x: e / r || 0,
    y: t / r || 0
  };
}
function VD(r, e) {
  return ST(e[0], e[1]) / ST(r[0], r[1]);
}
function $D(r, e) {
  return ET(e[1], e[0]) - ET(r[1], r[0]);
}
function qD(r, e) {
  const t = r.lastInterval || e, n = e.timeStamp - t.timeStamp;
  let i, s, l, o;
  if (e.eventType !== js.Cancel && (n > OD || t.velocity === void 0)) {
    const d = e.deltaX - t.deltaX, m = e.deltaY - t.deltaY, b = I5(n, d, m);
    s = b.x, l = b.y, i = Math.abs(b.x) > Math.abs(b.y) ? b.x : b.y, o = C5(d, m), r.lastInterval = e;
  } else
    i = t.velocity, s = t.velocityX, l = t.velocityY, o = t.direction;
  e.velocity = i, e.velocityX = s, e.velocityY = l, e.direction = o;
}
function GD(r, e) {
  const {
    session: t
  } = r, {
    pointers: n
  } = e, {
    length: i
  } = n;
  t.firstInput || (t.firstInput = TT(e)), i > 1 && !t.firstMultiple ? t.firstMultiple = TT(e) : i === 1 && (t.firstMultiple = !1);
  const {
    firstInput: s,
    firstMultiple: l
  } = t, o = l ? l.center : s.center, d = e.center = S5(n);
  e.timeStamp = Date.now(), e.deltaTime = e.timeStamp - s.timeStamp, e.angle = zD(o, d), e.distance = E5(o, d);
  const {
    deltaX: m,
    deltaY: b
  } = jD(t, e);
  e.deltaX = m, e.deltaY = b, e.offsetDirection = C5(e.deltaX, e.deltaY);
  const A = I5(e.deltaTime, e.deltaX, e.deltaY);
  e.overallVelocityX = A.x, e.overallVelocityY = A.y, e.overallVelocity = Math.abs(A.x) > Math.abs(A.y) ? A.x : A.y, e.scale = l ? VD(l.pointers, n) : 1, e.rotation = l ? $D(l.pointers, n) : 0, e.maxPointers = t.prevInput ? e.pointers.length > t.prevInput.maxPointers ? e.pointers.length : t.prevInput.maxPointers : e.pointers.length;
  let M = r.element;
  return UD(e.srcEvent.target, M) && (M = e.srcEvent.target), e.target = M, qD(t, e), e;
}
function HD(r, e, t) {
  const n = t.pointers.length, i = t.changedPointers.length, s = e & js.Start && n - i === 0, l = e & (js.End | js.Cancel) && n - i === 0;
  t.isFirst = !!s, t.isFinal = !!l, s && (r.session = {}), t.eventType = e;
  const o = GD(r, t);
  r.emit("hammer.input", o), r.recognize(o), r.session.prevInput = o;
}
let WD = class {
  constructor(e) {
    this.evEl = "", this.evWin = "", this.evTarget = "", this.domHandler = (t) => {
      this.manager.options.enable && this.handler(t);
    }, this.manager = e, this.element = e.element, this.target = e.options.inputTarget || e.element;
  }
  callback(e, t) {
    HD(this.manager, e, t);
  }
  // eslint-disable @typescript-eslint/unbound-method
  /**
   * bind the events
   */
  init() {
    wb(this.element, this.evEl, this.domHandler), wb(this.target, this.evTarget, this.domHandler), wb(AT(this.element), this.evWin, this.domHandler);
  }
  /**
   * unbind the events
   */
  destroy() {
    Ab(this.element, this.evEl, this.domHandler), Ab(this.target, this.evTarget, this.domHandler), Ab(AT(this.element), this.evWin, this.domHandler);
  }
};
const XD = {
  pointerdown: js.Start,
  pointermove: js.Move,
  pointerup: js.End,
  pointercancel: js.Cancel,
  pointerout: js.Cancel
}, ZD = "pointerdown", YD = "pointermove pointerup pointercancel";
class KD extends WD {
  constructor(e) {
    super(e), this.evEl = ZD, this.evWin = YD, this.store = this.manager.session.pointerEvents = [], this.init();
  }
  /**
   * handle mouse events
   */
  handler(e) {
    const {
      store: t
    } = this;
    let n = !1;
    const i = XD[e.type], s = e.pointerType, l = s === "touch";
    let o = t.findIndex((d) => d.pointerId === e.pointerId);
    i & js.Start && (e.buttons || l) ? o < 0 && (t.push(e), o = t.length - 1) : i & (js.End | js.Cancel) && (n = !0), !(o < 0) && (t[o] = e, this.callback(i, {
      pointers: t,
      changedPointers: [e],
      eventType: i,
      pointerType: s,
      srcEvent: e
    }), n && t.splice(o, 1));
  }
}
const JD = ["", "webkit", "Moz", "MS", "ms", "o"];
function QD(r, e) {
  const t = e[0].toUpperCase() + e.slice(1);
  for (const n of JD) {
    const i = n ? n + t : e;
    if (i in r)
      return i;
  }
}
const eF = 1, CT = 2, IT = {
  touchAction: "compute",
  enable: !0,
  inputTarget: null,
  cssProps: {
    /**
     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
     */
    userSelect: "none",
    /**
     * (Webkit) Disable default dragging behavior
     */
    // @ts-ignore
    userDrag: "none",
    /**
     * (iOS only) Disables the default callout shown when you touch and hold a touch target.
     * When you touch and hold a touch target such as a link, Safari displays
     * a callout containing information about the link. This property allows you to disable that callout.
     */
    // @ts-ignore
    touchCallout: "none",
    /**
     * (iOS only) Sets the color of the highlight that appears over a link while it's being tapped.
     */
    // @ts-ignore
    tapHighlightColor: "rgba(0,0,0,0)"
  }
};
class tF {
  constructor(e, t) {
    this.options = {
      ...IT,
      ...t,
      cssProps: {
        ...IT.cssProps,
        ...t.cssProps
      },
      inputTarget: t.inputTarget || e
    }, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = e, this.input = new KD(this), this.touchAction = new FD(this, this.options.touchAction), this.toggleCssProps(!0);
  }
  /**
   * set options
   */
  set(e) {
    return Object.assign(this.options, e), e.touchAction && this.touchAction.update(), e.inputTarget && (this.input.destroy(), this.input.target = e.inputTarget, this.input.init()), this;
  }
  /**
   * stop recognizing for this session.
   * This session will be discarded, when a new [input]start event is fired.
   * When forced, the recognizer cycle is stopped immediately.
   */
  stop(e) {
    this.session.stopped = e ? CT : eF;
  }
  /**
   * run the recognizers!
   * called by the inputHandler function on every movement of the pointers (touches)
   * it walks through all the recognizers and tries to detect the gesture that is being made
   */
  recognize(e) {
    const {
      session: t
    } = this;
    if (t.stopped)
      return;
    this.session.prevented && e.srcEvent.preventDefault();
    let n;
    const {
      recognizers: i
    } = this;
    let {
      curRecognizer: s
    } = t;
    (!s || s && s.state & _n.Recognized) && (s = t.curRecognizer = null);
    let l = 0;
    for (; l < i.length; )
      n = i[l], t.stopped !== CT && // 1
      (!s || n === s || // 2
      n.canRecognizeWith(s)) ? n.recognize(e) : n.reset(), !s && n.state & (_n.Began | _n.Changed | _n.Ended) && (s = t.curRecognizer = n), l++;
  }
  /**
   * get a recognizer by its event name.
   */
  get(e) {
    const {
      recognizers: t
    } = this;
    for (let n = 0; n < t.length; n++)
      if (t[n].options.event === e)
        return t[n];
    return null;
  }
  /**
   * add a recognizer to the manager
   * existing recognizers with the same event name will be removed
   */
  add(e) {
    if (Array.isArray(e)) {
      for (const n of e)
        this.add(n);
      return this;
    }
    const t = this.get(e.options.event);
    return t && this.remove(t), this.recognizers.push(e), e.manager = this, this.touchAction.update(), e;
  }
  /**
   * remove a recognizer by name or instance
   */
  remove(e) {
    if (Array.isArray(e)) {
      for (const n of e)
        this.remove(n);
      return this;
    }
    const t = typeof e == "string" ? this.get(e) : e;
    if (t) {
      const {
        recognizers: n
      } = this, i = n.indexOf(t);
      i !== -1 && (n.splice(i, 1), this.touchAction.update());
    }
    return this;
  }
  /**
   * bind event
   */
  on(e, t) {
    if (!e || !t)
      return;
    const {
      handlers: n
    } = this;
    for (const i of Q_(e))
      n[i] = n[i] || [], n[i].push(t);
  }
  /**
   * unbind event, leave hander blank to remove all handlers
   */
  off(e, t) {
    if (!e)
      return;
    const {
      handlers: n
    } = this;
    for (const i of Q_(e))
      t ? n[i] && n[i].splice(n[i].indexOf(t), 1) : delete n[i];
  }
  /**
   * emit event to the listeners
   */
  emit(e, t) {
    const n = this.handlers[e] && this.handlers[e].slice();
    if (!n || !n.length)
      return;
    const i = t;
    i.type = e, i.preventDefault = function() {
      t.srcEvent.preventDefault();
    };
    let s = 0;
    for (; s < n.length; )
      n[s](i), s++;
  }
  /**
   * destroy the manager and unbinds all events
   * it doesn't unbind dom events, that is the user own responsibility
   */
  destroy() {
    this.toggleCssProps(!1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;
  }
  /**
   * add/remove the css properties as defined in manager.options.cssProps
   */
  toggleCssProps(e) {
    const {
      element: t
    } = this;
    if (t) {
      for (const [n, i] of Object.entries(this.options.cssProps)) {
        const s = QD(t.style, n);
        e ? (this.oldCssProps[s] = t.style[s], t.style[s] = i) : t.style[s] = this.oldCssProps[s] || "";
      }
      e || (this.oldCssProps = {});
    }
  }
}
let rF = 1;
function nF() {
  return rF++;
}
function MT(r) {
  return r & _n.Cancelled ? "cancel" : r & _n.Ended ? "end" : r & _n.Changed ? "move" : r & _n.Began ? "start" : "";
}
class M5 {
  constructor(e) {
    this.options = e, this.id = nF(), this.state = _n.Possible, this.simultaneous = {}, this.requireFail = [];
  }
  /**
   * set options
   */
  set(e) {
    return Object.assign(this.options, e), this.manager.touchAction.update(), this;
  }
  /**
   * recognize simultaneous with an other recognizer.
   */
  recognizeWith(e) {
    if (Array.isArray(e)) {
      for (const i of e)
        this.recognizeWith(i);
      return this;
    }
    let t;
    if (typeof e == "string") {
      if (t = this.manager.get(e), !t)
        throw new Error(`Cannot find recognizer ${e}`);
    } else
      t = e;
    const {
      simultaneous: n
    } = this;
    return n[t.id] || (n[t.id] = t, t.recognizeWith(this)), this;
  }
  /**
   * drop the simultaneous link. it doesnt remove the link on the other recognizer.
   */
  dropRecognizeWith(e) {
    if (Array.isArray(e)) {
      for (const n of e)
        this.dropRecognizeWith(n);
      return this;
    }
    let t;
    return typeof e == "string" ? t = this.manager.get(e) : t = e, t && delete this.simultaneous[t.id], this;
  }
  /**
   * recognizer can only run when an other is failing
   */
  requireFailure(e) {
    if (Array.isArray(e)) {
      for (const i of e)
        this.requireFailure(i);
      return this;
    }
    let t;
    if (typeof e == "string") {
      if (t = this.manager.get(e), !t)
        throw new Error(`Cannot find recognizer ${e}`);
    } else
      t = e;
    const {
      requireFail: n
    } = this;
    return n.indexOf(t) === -1 && (n.push(t), t.requireFailure(this)), this;
  }
  /**
   * drop the requireFailure link. it does not remove the link on the other recognizer.
   */
  dropRequireFailure(e) {
    if (Array.isArray(e)) {
      for (const n of e)
        this.dropRequireFailure(n);
      return this;
    }
    let t;
    if (typeof e == "string" ? t = this.manager.get(e) : t = e, t) {
      const n = this.requireFail.indexOf(t);
      n > -1 && this.requireFail.splice(n, 1);
    }
    return this;
  }
  /**
   * has require failures boolean
   */
  hasRequireFailures() {
    return !!this.requireFail.find((e) => e.options.enable);
  }
  /**
   * if the recognizer can recognize simultaneous with an other recognizer
   */
  canRecognizeWith(e) {
    return !!this.simultaneous[e.id];
  }
  /**
   * You should use `tryEmit` instead of `emit` directly to check
   * that all the needed recognizers has failed before emitting.
   */
  emit(e) {
    if (!e) return;
    const {
      state: t
    } = this;
    t < _n.Ended && this.manager.emit(this.options.event + MT(t), e), this.manager.emit(this.options.event, e), e.additionalEvent && this.manager.emit(e.additionalEvent, e), t >= _n.Ended && this.manager.emit(this.options.event + MT(t), e);
  }
  /**
   * Check that all the require failure recognizers has failed,
   * if true, it emits a gesture event,
   * otherwise, setup the state to FAILED.
   */
  tryEmit(e) {
    this.canEmit() ? this.emit(e) : this.state = _n.Failed;
  }
  /**
   * can we emit?
   */
  canEmit() {
    let e = 0;
    for (; e < this.requireFail.length; ) {
      if (!(this.requireFail[e].state & (_n.Failed | _n.Possible)))
        return !1;
      e++;
    }
    return !0;
  }
  /**
   * update the recognizer
   */
  recognize(e) {
    const t = {
      ...e
    };
    if (!this.options.enable) {
      this.reset(), this.state = _n.Failed;
      return;
    }
    this.state & (_n.Recognized | _n.Cancelled | _n.Failed) && (this.state = _n.Possible), this.state = this.process(t), this.state & (_n.Began | _n.Changed | _n.Ended | _n.Cancelled) && this.tryEmit(t);
  }
  /**
   * return the event names that are emitted by this recognizer
   */
  getEventNames() {
    return [this.options.event];
  }
  /**
   * called when the gesture isn't allowed to recognize
   * like when another is being recognized or it is disabled
   */
  reset() {
  }
}
class P5 extends M5 {
  /**
   * Used to check if it the recognizer receives valid input, like input.distance > 10.
   */
  attrTest(e) {
    const t = this.options.pointers;
    return t === 0 || e.pointers.length === t;
  }
  /**
   * Process the input and return the state for the recognizer
   */
  process(e) {
    const {
      state: t
    } = this, {
      eventType: n
    } = e, i = t & (_n.Began | _n.Changed), s = this.attrTest(e);
    return i && (n & js.Cancel || !s) ? t | _n.Cancelled : i || s ? n & js.End ? t | _n.Ended : t & _n.Began ? t | _n.Changed : _n.Began : _n.Failed;
  }
}
class PT extends M5 {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super({
      enable: !0,
      event: "tap",
      pointers: 1,
      taps: 1,
      interval: 300,
      time: 250,
      threshold: 9,
      posThreshold: 10,
      ...e
    }), this.pTime = null, this.pCenter = null, this._timer = null, this._input = null, this.count = 0;
  }
  getTouchAction() {
    return [tv];
  }
  process(e) {
    const {
      options: t
    } = this, n = e.pointers.length === t.pointers, i = e.distance < t.threshold, s = e.deltaTime < t.time;
    if (this.reset(), e.eventType & js.Start && this.count === 0)
      return this.failTimeout();
    if (i && s && n) {
      if (e.eventType !== js.End)
        return this.failTimeout();
      const l = this.pTime ? e.timeStamp - this.pTime < t.interval : !0, o = !this.pCenter || E5(this.pCenter, e.center) < t.posThreshold;
      if (this.pTime = e.timeStamp, this.pCenter = e.center, !o || !l ? this.count = 1 : this.count += 1, this._input = e, this.count % t.taps === 0)
        return this.hasRequireFailures() ? (this._timer = setTimeout(() => {
          this.state = _n.Recognized, this.tryEmit(this._input);
        }, t.interval), _n.Began) : _n.Recognized;
    }
    return _n.Failed;
  }
  failTimeout() {
    return this._timer = setTimeout(() => {
      this.state = _n.Failed;
    }, this.options.interval), _n.Failed;
  }
  reset() {
    clearTimeout(this._timer);
  }
  emit(e) {
    this.state === _n.Recognized && (e.tapCount = this.count, this.manager.emit(this.options.event, e));
  }
}
const iF = ["", "start", "move", "end", "cancel", "up", "down", "left", "right"];
class RT extends P5 {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super({
      enable: !0,
      pointers: 1,
      event: "pan",
      threshold: 10,
      direction: to.All,
      ...e
    }), this.pX = null, this.pY = null;
  }
  getTouchAction() {
    const {
      options: {
        direction: e
      }
    } = this, t = [];
    return e & to.Horizontal && t.push(nv), e & to.Vertical && t.push(rv), t;
  }
  getEventNames() {
    return iF.map((e) => this.options.event + e);
  }
  directionTest(e) {
    const {
      options: t
    } = this;
    let n = !0, {
      distance: i
    } = e, {
      direction: s
    } = e;
    const l = e.deltaX, o = e.deltaY;
    return s & t.direction || (t.direction & to.Horizontal ? (s = l === 0 ? to.None : l < 0 ? to.Left : to.Right, n = l !== this.pX, i = Math.abs(e.deltaX)) : (s = o === 0 ? to.None : o < 0 ? to.Up : to.Down, n = o !== this.pY, i = Math.abs(e.deltaY))), e.direction = s, n && i > t.threshold && !!(s & t.direction);
  }
  attrTest(e) {
    return super.attrTest(e) && (!!(this.state & _n.Began) || !(this.state & _n.Began) && this.directionTest(e));
  }
  emit(e) {
    this.pX = e.deltaX, this.pY = e.deltaY;
    const t = to[e.direction].toLowerCase();
    t && (e.additionalEvent = this.options.event + t), super.emit(e);
  }
}
const sF = ["", "start", "move", "end", "cancel", "in", "out"];
class oF extends P5 {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super({
      enable: !0,
      event: "pinch",
      threshold: 0,
      pointers: 2,
      ...e
    });
  }
  getTouchAction() {
    return [p_];
  }
  getEventNames() {
    return sF.map((e) => this.options.event + e);
  }
  attrTest(e) {
    return super.attrTest(e) && (Math.abs(e.scale - 1) > this.options.threshold || !!(this.state & _n.Began));
  }
  emit(e) {
    if (e.scale !== 1) {
      const t = e.scale < 1 ? "in" : "out";
      e.additionalEvent = this.options.event + t;
    }
    super.emit(e);
  }
}
class Dy {
  constructor(e, t, n) {
    this.element = e, this.callback = t, this.options = n;
  }
}
const aF = typeof navigator < "u" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "", lF = aF.indexOf("firefox") !== -1, BT = 4.000244140625, cF = 40, uF = 0.25;
class hF extends Dy {
  constructor(e, t, n) {
    super(e, t, {
      enable: !0,
      ...n
    }), this.handleEvent = (i) => {
      if (!this.options.enable)
        return;
      let s = i.deltaY;
      globalThis.WheelEvent && (lF && i.deltaMode === globalThis.WheelEvent.DOM_DELTA_PIXEL && (s /= globalThis.devicePixelRatio), i.deltaMode === globalThis.WheelEvent.DOM_DELTA_LINE && (s *= cF)), s !== 0 && s % BT === 0 && (s = Math.floor(s / BT)), i.shiftKey && s && (s = s * uF), this.callback({
        type: "wheel",
        center: {
          x: i.clientX,
          y: i.clientY
        },
        delta: -s,
        srcEvent: i,
        pointerType: "mouse",
        target: i.target
      });
    }, e.addEventListener("wheel", this.handleEvent, {
      passive: !1
    });
  }
  destroy() {
    this.element.removeEventListener("wheel", this.handleEvent);
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    e === "wheel" && (this.options.enable = t);
  }
}
const LT = ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout", "mouseleave"];
class fF extends Dy {
  constructor(e, t, n) {
    super(e, t, {
      enable: !0,
      ...n
    }), this.handleEvent = (s) => {
      this.handleOverEvent(s), this.handleOutEvent(s), this.handleEnterEvent(s), this.handleLeaveEvent(s), this.handleMoveEvent(s);
    }, this.pressed = !1;
    const {
      enable: i
    } = this.options;
    this.enableMoveEvent = i, this.enableLeaveEvent = i, this.enableEnterEvent = i, this.enableOutEvent = i, this.enableOverEvent = i, LT.forEach((s) => e.addEventListener(s, this.handleEvent));
  }
  destroy() {
    LT.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    switch (e) {
      case "pointermove":
        this.enableMoveEvent = t;
        break;
      case "pointerover":
        this.enableOverEvent = t;
        break;
      case "pointerout":
        this.enableOutEvent = t;
        break;
      case "pointerenter":
        this.enableEnterEvent = t;
        break;
      case "pointerleave":
        this.enableLeaveEvent = t;
        break;
    }
  }
  handleOverEvent(e) {
    this.enableOverEvent && e.type === "mouseover" && this._emit("pointerover", e);
  }
  handleOutEvent(e) {
    this.enableOutEvent && e.type === "mouseout" && this._emit("pointerout", e);
  }
  handleEnterEvent(e) {
    this.enableEnterEvent && e.type === "mouseenter" && this._emit("pointerenter", e);
  }
  handleLeaveEvent(e) {
    this.enableLeaveEvent && e.type === "mouseleave" && this._emit("pointerleave", e);
  }
  handleMoveEvent(e) {
    if (this.enableMoveEvent)
      switch (e.type) {
        case "mousedown":
          e.button >= 0 && (this.pressed = !0);
          break;
        case "mousemove":
          e.buttons === 0 && (this.pressed = !1), this.pressed || this._emit("pointermove", e);
          break;
        case "mouseup":
          this.pressed = !1;
          break;
      }
  }
  _emit(e, t) {
    this.callback({
      type: e,
      center: {
        x: t.clientX,
        y: t.clientY
      },
      srcEvent: t,
      pointerType: "mouse",
      target: t.target
    });
  }
}
const OT = ["keydown", "keyup"];
class dF extends Dy {
  constructor(e, t, n) {
    super(e, t, {
      enable: !0,
      tabIndex: 0,
      ...n
    }), this.handleEvent = (i) => {
      const s = i.target || i.srcElement;
      s.tagName === "INPUT" && s.type === "text" || s.tagName === "TEXTAREA" || (this.enableDownEvent && i.type === "keydown" && this.callback({
        type: "keydown",
        srcEvent: i,
        key: i.key,
        target: i.target
      }), this.enableUpEvent && i.type === "keyup" && this.callback({
        type: "keyup",
        srcEvent: i,
        key: i.key,
        target: i.target
      }));
    }, this.enableDownEvent = this.options.enable, this.enableUpEvent = this.options.enable, e.tabIndex = this.options.tabIndex, e.style.outline = "none", OT.forEach((i) => e.addEventListener(i, this.handleEvent));
  }
  destroy() {
    OT.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    e === "keydown" && (this.enableDownEvent = t), e === "keyup" && (this.enableUpEvent = t);
  }
}
class pF extends Dy {
  constructor(e, t, n) {
    super(e, t, n), this.handleEvent = (i) => {
      this.options.enable && this.callback({
        type: "contextmenu",
        center: {
          x: i.clientX,
          y: i.clientY
        },
        srcEvent: i,
        pointerType: "mouse",
        target: i.target
      });
    }, e.addEventListener("contextmenu", this.handleEvent);
  }
  destroy() {
    this.element.removeEventListener("contextmenu", this.handleEvent);
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    e === "contextmenu" && (this.options.enable = t);
  }
}
const kT = 1, iv = 2, NT = 4, gF = {
  pointerdown: kT,
  pointermove: iv,
  pointerup: NT,
  mousedown: kT,
  mousemove: iv,
  mouseup: NT
}, mF = 0, _F = 1, yF = 2, bF = 1, vF = 2, xF = 4;
function wF(r) {
  const e = gF[r.srcEvent.type];
  if (!e)
    return null;
  const {
    buttons: t,
    button: n
  } = r.srcEvent;
  let i = !1, s = !1, l = !1;
  return e === iv ? (i = !!(t & bF), s = !!(t & xF), l = !!(t & vF)) : (i = n === mF, s = n === _F, l = n === yF), {
    leftButton: i,
    middleButton: s,
    rightButton: l
  };
}
function AF(r, e) {
  const t = r.center;
  if (!t)
    return null;
  const n = e.getBoundingClientRect(), i = n.width / e.offsetWidth || 1, s = n.height / e.offsetHeight || 1, l = {
    x: (t.x - n.left - e.clientLeft) / i,
    y: (t.y - n.top - e.clientTop) / s
  };
  return {
    center: t,
    offsetCenter: l
  };
}
const TF = {
  srcElement: "root",
  priority: 0
};
class SF {
  constructor(e, t) {
    this.handleEvent = (n) => {
      if (this.isEmpty())
        return;
      const i = this._normalizeEvent(n);
      let s = n.srcEvent.target;
      for (; s && s !== i.rootElement; ) {
        if (this._emit(i, s), i.handled)
          return;
        s = s.parentNode;
      }
      this._emit(i, "root");
    }, this.eventManager = e, this.recognizerName = t, this.handlers = [], this.handlersByElement = /* @__PURE__ */ new Map(), this._active = !1;
  }
  // Returns true if there are no non-passive handlers
  isEmpty() {
    return !this._active;
  }
  add(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
    const {
      handlers: l,
      handlersByElement: o
    } = this, d = {
      ...TF,
      ...n
    };
    let m = o.get(d.srcElement);
    m || (m = [], o.set(d.srcElement, m));
    const b = {
      type: e,
      handler: t,
      srcElement: d.srcElement,
      priority: d.priority
    };
    i && (b.once = !0), s && (b.passive = !0), l.push(b), this._active = this._active || !b.passive;
    let A = m.length - 1;
    for (; A >= 0 && !(m[A].priority >= b.priority); )
      A--;
    m.splice(A + 1, 0, b);
  }
  remove(e, t) {
    const {
      handlers: n,
      handlersByElement: i
    } = this;
    for (let s = n.length - 1; s >= 0; s--) {
      const l = n[s];
      if (l.type === e && l.handler === t) {
        n.splice(s, 1);
        const o = i.get(l.srcElement);
        o.splice(o.indexOf(l), 1), o.length === 0 && i.delete(l.srcElement);
      }
    }
    this._active = n.some((s) => !s.passive);
  }
  /**
   * Invoke handlers on a particular element
   */
  _emit(e, t) {
    const n = this.handlersByElement.get(t);
    if (n) {
      let i = !1;
      const s = () => {
        e.handled = !0;
      }, l = () => {
        e.handled = !0, i = !0;
      }, o = [];
      for (let d = 0; d < n.length; d++) {
        const {
          type: m,
          handler: b,
          once: A
        } = n[d];
        if (b({
          ...e,
          type: m,
          stopPropagation: s,
          stopImmediatePropagation: l
        }), A && o.push(n[d]), i)
          break;
      }
      for (let d = 0; d < o.length; d++) {
        const {
          type: m,
          handler: b
        } = o[d];
        this.remove(m, b);
      }
    }
  }
  /**
   * Normalizes hammerjs and custom events to have predictable fields.
   */
  _normalizeEvent(e) {
    const t = this.eventManager.getElement();
    return {
      ...e,
      ...wF(e),
      ...AF(e, t),
      preventDefault: () => {
        e.srcEvent.preventDefault();
      },
      stopImmediatePropagation: null,
      stopPropagation: null,
      handled: !1,
      rootElement: t
    };
  }
}
function EF(r) {
  if ("recognizer" in r)
    return r;
  let e;
  const t = Array.isArray(r) ? [...r] : [r];
  if (typeof t[0] == "function") {
    const n = t.shift(), i = t.shift() || {};
    e = new n(i);
  } else
    e = t.shift();
  return {
    recognizer: e,
    recognizeWith: typeof t[0] == "string" ? [t[0]] : t[0],
    requireFailure: typeof t[1] == "string" ? [t[1]] : t[1]
  };
}
class CF {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this._onBasicInput = (n) => {
      this.manager.emit(n.srcEvent.type, n);
    }, this._onOtherEvent = (n) => {
      this.manager.emit(n.type, n);
    }, this.options = {
      recognizers: [],
      events: {},
      touchAction: "compute",
      tabIndex: 0,
      cssProps: {},
      ...t
    }, this.events = /* @__PURE__ */ new Map(), this.element = e, !!e) {
      this.manager = new tF(e, this.options);
      for (const n of this.options.recognizers) {
        const {
          recognizer: i,
          recognizeWith: s,
          requireFailure: l
        } = EF(n);
        this.manager.add(i), s && i.recognizeWith(s), l && i.requireFailure(l);
      }
      this.manager.on("hammer.input", this._onBasicInput), this.wheelInput = new hF(e, this._onOtherEvent, {
        enable: !1
      }), this.moveInput = new fF(e, this._onOtherEvent, {
        enable: !1
      }), this.keyInput = new dF(e, this._onOtherEvent, {
        enable: !1,
        tabIndex: t.tabIndex
      }), this.contextmenuInput = new pF(e, this._onOtherEvent, {
        enable: !1
      }), this.on(this.options.events);
    }
  }
  getElement() {
    return this.element;
  }
  // Tear down internal event management implementations.
  destroy() {
    this.element && (this.wheelInput.destroy(), this.moveInput.destroy(), this.keyInput.destroy(), this.contextmenuInput.destroy(), this.manager.destroy());
  }
  /** Register an event handler function to be called on `event` */
  on(e, t, n) {
    this._addEventHandler(e, t, n, !1);
  }
  once(e, t, n) {
    this._addEventHandler(e, t, n, !0);
  }
  watch(e, t, n) {
    this._addEventHandler(e, t, n, !1, !0);
  }
  off(e, t) {
    this._removeEventHandler(e, t);
  }
  /*
   * Enable/disable recognizer for the given event
   */
  _toggleRecognizer(e, t) {
    var s, l, o, d;
    const {
      manager: n
    } = this;
    if (!n)
      return;
    const i = n.get(e);
    i && (i.set({
      enable: t
    }), n.touchAction.update()), (s = this.wheelInput) == null || s.enableEventType(e, t), (l = this.moveInput) == null || l.enableEventType(e, t), (o = this.keyInput) == null || o.enableEventType(e, t), (d = this.contextmenuInput) == null || d.enableEventType(e, t);
  }
  /**
   * Process the event registration for a single event + handler.
   */
  _addEventHandler(e, t, n, i, s) {
    if (typeof e != "string") {
      n = t;
      for (const [m, b] of Object.entries(e))
        this._addEventHandler(m, b, n, i, s);
      return;
    }
    const {
      manager: l,
      events: o
    } = this;
    if (!l) return;
    let d = o.get(e);
    if (!d) {
      const m = this._getRecognizerName(e) || e;
      d = new SF(this, m), o.set(e, d), l && l.on(e, d.handleEvent);
    }
    d.add(e, t, n, i, s), d.isEmpty() || this._toggleRecognizer(d.recognizerName, !0);
  }
  /**
   * Process the event deregistration for a single event + handler.
   */
  _removeEventHandler(e, t) {
    if (typeof e != "string") {
      for (const [s, l] of Object.entries(e))
        this._removeEventHandler(s, l);
      return;
    }
    const {
      events: n
    } = this, i = n.get(e);
    if (i && (i.remove(e, t), i.isEmpty())) {
      const {
        recognizerName: s
      } = i;
      let l = !1;
      for (const o of n.values())
        if (o.recognizerName === s && !o.isEmpty()) {
          l = !0;
          break;
        }
      l || this._toggleRecognizer(s, !1);
    }
  }
  _getRecognizerName(e) {
    var t;
    return (t = this.manager.recognizers.find((n) => n.getEventNames().includes(e))) == null ? void 0 : t.options.event;
  }
}
const Ln = {
  /**
   * `LNGLAT` if rendering into a geospatial viewport, `CARTESIAN` otherwise
   */
  DEFAULT: -1,
  /**
   * Positions are interpreted as [longitude, latitude, elevation]
   * longitude/latitude are in degrees, elevation is in meters.
   * Dimensions are in meters.
   */
  LNGLAT: 1,
  /**
   * Positions are interpreted as [x, y, z] in meter offsets from the coordinate origin.
   * Dimensions are in meters.
   */
  METER_OFFSETS: 2,
  /**
   * Positions are interpreted as [deltaLng, deltaLat, elevation] from the coordinate origin.
   * deltaLng/deltaLat are in degrees, elevation is in meters.
   * Dimensions are in meters.
   */
  LNGLAT_OFFSETS: 3,
  /**
   * Positions and dimensions are in the common units of the viewport.
   */
  CARTESIAN: 0
};
Object.defineProperty(Ln, "IDENTITY", {
  get: () => (Gn.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")(), 0)
});
const ml = {
  /**
   * Render geospatial data in Web Mercator projection
   */
  WEB_MERCATOR: 1,
  /**
   * Render geospatial data as a 3D globe
   */
  GLOBE: 2,
  /**
   * (Internal use only) Web Mercator projection at high zoom
   */
  WEB_MERCATOR_AUTO_OFFSET: 4,
  /**
   * No transformation
   */
  IDENTITY: 0
}, Lg = {
  common: 0,
  meters: 1,
  pixels: 2
}, sv = {
  click: "onClick",
  panstart: "onDragStart",
  panmove: "onDrag",
  panend: "onDragEnd"
}, DT = {
  multipan: [RT, {
    threshold: 10,
    direction: to.Vertical,
    pointers: 2
  }],
  pinch: [oF, {}, null, ["multipan"]],
  pan: [RT, {
    threshold: 1
  }, ["pinch"], ["multipan"]],
  dblclick: [PT, {
    event: "dblclick",
    taps: 2
  }],
  click: [PT, {
    event: "click"
  }, null, ["dblclick"]]
};
function IF(r, e) {
  if (r === e)
    return !0;
  if (Array.isArray(r)) {
    const t = r.length;
    if (!e || e.length !== t)
      return !1;
    for (let n = 0; n < t; n++)
      if (r[n] !== e[n])
        return !1;
    return !0;
  }
  return !1;
}
function Yg(r) {
  let e = {}, t;
  return (n) => {
    for (const i in n)
      if (!IF(n[i], e[i])) {
        t = r(n), e = n;
        break;
      }
    return t;
  };
}
const FT = [0, 0, 0, 0], MF = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], R5 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], PF = [0, 0, 0], B5 = [0, 0, 0], RF = Yg(OF);
function L5(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : B5;
  t.length < 3 && (t = [t[0], t[1], 0]);
  let n = t, i, s = !0;
  switch (e === Ln.LNGLAT_OFFSETS || e === Ln.METER_OFFSETS ? i = t : i = r.isGeospatial ? (
    // @ts-expect-error longitude and latitude are not defined on the base Viewport, but is expected on geospatial viewports
    [Math.fround(r.longitude), Math.fround(r.latitude), 0]
  ) : null, r.projectionMode) {
    case ml.WEB_MERCATOR:
      (e === Ln.LNGLAT || e === Ln.CARTESIAN) && (i = [0, 0, 0], s = !1);
      break;
    case ml.WEB_MERCATOR_AUTO_OFFSET:
      e === Ln.LNGLAT ? n = i : e === Ln.CARTESIAN && (n = [Math.fround(r.center[0]), Math.fround(r.center[1]), 0], i = r.unprojectPosition(n), n[0] -= t[0], n[1] -= t[1], n[2] -= t[2]);
      break;
    case ml.IDENTITY:
      n = r.position.map(Math.fround), n[2] = n[2] || 0;
      break;
    case ml.GLOBE:
      s = !1, i = null;
      break;
    default:
      s = !1;
  }
  return {
    geospatialOrigin: i,
    shaderCoordinateOrigin: n,
    offsetMode: s
  };
}
function BF(r, e, t) {
  const {
    viewMatrixUncentered: n,
    projectionMatrix: i
  } = r;
  let {
    viewMatrix: s,
    viewProjectionMatrix: l
  } = r, o = FT, d = FT, m = r.cameraPosition;
  const {
    geospatialOrigin: b,
    shaderCoordinateOrigin: A,
    offsetMode: M
  } = L5(r, e, t);
  return M && (d = r.projectPosition(b || A), m = [m[0] - d[0], m[1] - d[1], m[2] - d[2]], d[3] = 1, o = _p([], d, l), s = n || s, l = Nf([], i, s), l = Nf([], l, MF)), {
    viewMatrix: s,
    viewProjectionMatrix: l,
    projectionCenter: o,
    originCommon: d,
    cameraPosCommon: m,
    shaderCoordinateOrigin: A,
    geospatialOrigin: b
  };
}
function LF(r) {
  let {
    viewport: e,
    devicePixelRatio: t = 1,
    modelMatrix: n = null,
    // Match Layer.defaultProps
    coordinateSystem: i = Ln.DEFAULT,
    coordinateOrigin: s = B5,
    autoWrapLongitude: l = !1
  } = r;
  i === Ln.DEFAULT && (i = e.isGeospatial ? Ln.LNGLAT : Ln.CARTESIAN);
  const o = RF({
    viewport: e,
    devicePixelRatio: t,
    coordinateSystem: i,
    coordinateOrigin: s
  });
  return o.wrapLongitude = l, o.modelMatrix = n || R5, o;
}
function OF(r) {
  let {
    viewport: e,
    devicePixelRatio: t,
    coordinateSystem: n,
    coordinateOrigin: i
  } = r;
  const {
    projectionCenter: s,
    viewProjectionMatrix: l,
    originCommon: o,
    cameraPosCommon: d,
    shaderCoordinateOrigin: m,
    geospatialOrigin: b
  } = BF(e, n, i), A = e.getDistanceScales(), M = [e.width * t, e.height * t], E = _p([], [0, 0, -e.focalDistance, 1], e.projectionMatrix)[3] || 1, k = {
    // Projection mode values
    coordinateSystem: n,
    projectionMode: e.projectionMode,
    coordinateOrigin: m,
    commonOrigin: o.slice(0, 3),
    center: s,
    // Backward compatibility
    // TODO: remove in v9
    // @ts-expect-error _pseudoMeters is only defined on WebMercator viewport
    pseudoMeters: !!e._pseudoMeters,
    // Screen size
    viewportSize: M,
    devicePixelRatio: t,
    focalDistance: E,
    commonUnitsPerMeter: A.unitsPerMeter,
    commonUnitsPerWorldUnit: A.unitsPerMeter,
    commonUnitsPerWorldUnit2: PF,
    scale: e.scale,
    // This is the mercator scale (2 ** zoom)
    wrapLongitude: !1,
    viewProjectionMatrix: l,
    modelMatrix: R5,
    // This is for lighting calculations
    cameraPosition: d
  };
  if (b) {
    const U = e.getDistanceScales(b);
    switch (n) {
      case Ln.METER_OFFSETS:
        k.commonUnitsPerWorldUnit = U.unitsPerMeter, k.commonUnitsPerWorldUnit2 = U.unitsPerMeter2;
        break;
      case Ln.LNGLAT:
      case Ln.LNGLAT_OFFSETS:
        e._pseudoMeters || (k.commonUnitsPerMeter = U.unitsPerMeter), k.commonUnitsPerWorldUnit = U.unitsPerDegree, k.commonUnitsPerWorldUnit2 = U.unitsPerDegree2;
        break;
      // a.k.a "preprojected" positions
      case Ln.CARTESIAN:
        k.commonUnitsPerWorldUnit = [1, 1, U.unitsPerMeter[2]], k.commonUnitsPerWorldUnit2 = [0, 0, U.unitsPerMeter2[2]];
        break;
    }
  }
  return k;
}
const kF = Object.keys(Ln).map((r) => `const COORDINATE_SYSTEM_${r}: i32 = ${Ln[r]};`).join(""), NF = Object.keys(ml).map((r) => `const PROJECTION_MODE_${r}: i32 = ${ml[r]};`).join(""), DF = Object.keys(Lg).map((r) => `const UNIT_${r.toUpperCase()}: i32 = ${Lg[r]};`).join(""), FF = (
  /* wgsl */
  `${kF}
${NF}
${DF}

const TILE_SIZE: f32 = 512.0;
const PI: f32 = 3.1415926536;
const WORLD_SCALE: f32 = TILE_SIZE / (PI * 2.0);
const ZERO_64_LOW: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
const EARTH_RADIUS: f32 = 6370972.0; // meters
const GLOBE_RADIUS: f32 = 256.0;

// -----------------------------------------------------------------------------
// Uniform block (converted from GLSL uniform block)
// -----------------------------------------------------------------------------
struct ProjectUniforms {
  wrapLongitude: i32,
  coordinateSystem: i32,
  commonUnitsPerMeter: vec3<f32>,
  projectionMode: i32,
  scale: f32,
  commonUnitsPerWorldUnit: vec3<f32>,
  commonUnitsPerWorldUnit2: vec3<f32>,
  center: vec4<f32>,
  modelMatrix: mat4x4<f32>,
  viewProjectionMatrix: mat4x4<f32>,
  viewportSize: vec2<f32>,
  devicePixelRatio: f32,
  focalDistance: f32,
  cameraPosition: vec3<f32>,
  coordinateOrigin: vec3<f32>,
  commonOrigin: vec3<f32>,
  pseudoMeters: i32,
};

@group(0) @binding(0)
var<uniform> project: ProjectUniforms;

// -----------------------------------------------------------------------------
// Geometry data
// (In your GLSL code, "geometry" was assumed to be available globally. In WGSL,
// you might supply this via vertex attributes or a uniform. Here we define a
// uniform struct for demonstration.)
// -----------------------------------------------------------------------------

// Structure to carry additional geometry data used by deck.gl filters.
struct Geometry {
  worldPosition: vec3<f32>,
  worldPositionAlt: vec3<f32>,
  position: vec4<f32>,
  uv: vec2<f32>,
  pickingColor: vec3<f32>,
};

// @group(0) @binding(1)
var<private> geometry: Geometry;
`
), UF = (
  /* wgsl */
  `${FF}

// -----------------------------------------------------------------------------
// Functions
// -----------------------------------------------------------------------------

// Returns an adjustment factor for commonUnitsPerMeter
fn _project_size_at_latitude(lat: f32) -> f32 {
  let y = clamp(lat, -89.9, 89.9);
  return 1.0 / cos(radians(y));
}

// Overloaded version: scales a value in meters at a given latitude.
fn _project_size_at_latitude_m(meters: f32, lat: f32) -> f32 {
  return meters * project.commonUnitsPerMeter.z * _project_size_at_latitude(lat);
}

// Computes a non-linear scale factor based on geometry.
// (Note: This function relies on "geometry" being provided.)
fn project_size() -> f32 {
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR &&
      project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
      project.pseudoMeters == 0) {
    if (geometry.position.w == 0.0) {
      return _project_size_at_latitude(geometry.worldPosition.y);
    }
    let y: f32 = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
    let y2 = y * y;
    let y4 = y2 * y2;
    let y6 = y4 * y2;
    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
  }
  return 1.0;
}

// Overloads to scale offsets (meters to world units)
fn project_size_float(meters: f32) -> f32 {
  return meters * project.commonUnitsPerMeter.z * project_size();
}

fn project_size_vec2(meters: vec2<f32>) -> vec2<f32> {
  return meters * project.commonUnitsPerMeter.xy * project_size();
}

fn project_size_vec3(meters: vec3<f32>) -> vec3<f32> {
  return meters * project.commonUnitsPerMeter * project_size();
}

fn project_size_vec4(meters: vec4<f32>) -> vec4<f32> {
  return vec4<f32>(meters.xyz * project.commonUnitsPerMeter, meters.w);
}

// Returns a rotation matrix aligning the z‑axis with the given up vector.
fn project_get_orientation_matrix(up: vec3<f32>) -> mat3x3<f32> {
  let uz = normalize(up);
  let ux = select(
    vec3<f32>(1.0, 0.0, 0.0),
    normalize(vec3<f32>(uz.y, -uz.x, 0.0)),
    abs(uz.z) == 1.0
  );
  let uy = cross(uz, ux);
  return mat3x3<f32>(ux, uy, uz);
}

// Since WGSL does not support "out" parameters, we return a struct.
struct RotationResult {
  needsRotation: bool,
  transform: mat3x3<f32>,
};

fn project_needs_rotation(commonPosition: vec3<f32>) -> RotationResult {
  if (project.projectionMode == PROJECTION_MODE_GLOBE) {
    return RotationResult(true, project_get_orientation_matrix(commonPosition));
  } else {
    return RotationResult(false, mat3x3<f32>());  // identity alternative if needed
  };
}

// Projects a normal vector from the current coordinate system to world space.
fn project_normal(vector: vec3<f32>) -> vec3<f32> {
  let normal_modelspace = project.modelMatrix * vec4<f32>(vector, 0.0);
  var n = normalize(normal_modelspace.xyz * project.commonUnitsPerMeter);
  let rotResult = project_needs_rotation(geometry.position.xyz);
  if (rotResult.needsRotation) {
    n = rotResult.transform * n;
  }
  return n;
}

// Applies a scale offset based on y-offset (dy)
fn project_offset_(offset: vec4<f32>) -> vec4<f32> {
  let dy: f32 = offset.y;
  let commonUnitsPerWorldUnit = project.commonUnitsPerWorldUnit + project.commonUnitsPerWorldUnit2 * dy;
  return vec4<f32>(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}

// Projects lng/lat coordinates to a unit tile [0,1]
fn project_mercator_(lnglat: vec2<f32>) -> vec2<f32> {
  var x = lnglat.x;
  if (project.wrapLongitude != 0) {
    x = ((x + 180.0) % 360.0) - 180.0;
  }
  let y = clamp(lnglat.y, -89.9, 89.9);
  return vec2<f32>(
    radians(x) + PI,
    PI + log(tan(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

// Projects lng/lat/z coordinates for a globe projection.
fn project_globe_(lnglatz: vec3<f32>) -> vec3<f32> {
  let lambda = radians(lnglatz.x);
  let phi = radians(lnglatz.y);
  let cosPhi = cos(phi);
  let D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;
  return vec3<f32>(
    sin(lambda) * cosPhi,
    -cos(lambda) * cosPhi,
    sin(phi)
  ) * D;
}

// Projects positions (with an optional 64-bit low part) from the input
// coordinate system to the common space.
fn project_position_vec4_f64(position: vec4<f32>, position64Low: vec3<f32>) -> vec4<f32> {
  var position_world = project.modelMatrix * position;

  // Work around for a Mac+NVIDIA bug:
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4<f32>(
        project_mercator_(position_world.xy),
        _project_size_at_latitude_m(position_world.z, position_world.y),
        position_world.w
      );
    }
    if (project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
      position_world = vec4f(position_world.xyz + project.coordinateOrigin, position_world.w);
    }
  }
  if (project.projectionMode == PROJECTION_MODE_GLOBE) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4<f32>(
        project_globe_(position_world.xyz),
        position_world.w
      );
    }
  }
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      if (abs(position_world.y - project.coordinateOrigin.y) > 0.25) {
        return vec4<f32>(
          project_mercator_(position_world.xy) - project.commonOrigin.xy,
          project_size_float(position_world.z),
          position_world.w
        );
      }
    }
  }
  if (project.projectionMode == PROJECTION_MODE_IDENTITY ||
      (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
       (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
        project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
    position_world = vec4f(position_world.xyz - project.coordinateOrigin, position_world.w);
  }

  return project_offset_(position_world) +
         project_offset_(project.modelMatrix * vec4<f32>(position64Low, 0.0));
}

// Overloaded versions for different input types.
fn project_position_vec4_f32(position: vec4<f32>) -> vec4<f32> {
  return project_position_vec4_f64(position, ZERO_64_LOW);
}

fn project_position_vec3_f64(position: vec3<f32>, position64Low: vec3<f32>) -> vec3<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 1.0), position64Low);
  return projected_position.xyz;
}

fn project_position_vec3_f32(position: vec3<f32>) -> vec3<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 1.0), ZERO_64_LOW);
  return projected_position.xyz;
}

fn project_position_vec2_f32(position: vec2<f32>) -> vec2<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 0.0, 1.0), ZERO_64_LOW);
  return projected_position.xy;
}

// Transforms a common space position to clip space.
fn project_common_position_to_clipspace_with_projection(position: vec4<f32>, viewProjectionMatrix: mat4x4<f32>, center: vec4<f32>) -> vec4<f32> {
  return viewProjectionMatrix * position + center;
}

// Uses the project viewProjectionMatrix and center.
fn project_common_position_to_clipspace(position: vec4<f32>) -> vec4<f32> {
  return project_common_position_to_clipspace_with_projection(position, project.viewProjectionMatrix, project.center);
}

// Returns a clip space offset corresponding to a given number of screen pixels.
fn project_pixel_size_to_clipspace(pixels: vec2<f32>) -> vec2<f32> {
  let offset = pixels / project.viewportSize * project.devicePixelRatio * 2.0;
  return offset * project.focalDistance;
}

fn project_meter_size_to_pixel(meters: f32) -> f32 {
  return project_size_float(meters) * project.scale;
}

fn project_unit_size_to_pixel(size: f32, unit: i32) -> f32 {
  if (unit == UNIT_METERS) {
    return project_meter_size_to_pixel(size);
  } else if (unit == UNIT_COMMON) {
    return size * project.scale;
  }
  // UNIT_PIXELS: no scaling applied.
  return size;
}

fn project_pixel_size_float(pixels: f32) -> f32 {
  return pixels / project.scale;
}

fn project_pixel_size_vec2(pixels: vec2<f32>) -> vec2<f32> {
  return pixels / project.scale;
}
`
), zF = Object.keys(Ln).map((r) => `const int COORDINATE_SYSTEM_${r} = ${Ln[r]};`).join(""), jF = Object.keys(ml).map((r) => `const int PROJECTION_MODE_${r} = ${ml[r]};`).join(""), VF = Object.keys(Lg).map((r) => `const int UNIT_${r.toUpperCase()} = ${Lg[r]};`).join(""), $F = (
  /* glsl */
  `${zF}
${jF}
${VF}
uniform projectUniforms {
bool wrapLongitude;
int coordinateSystem;
vec3 commonUnitsPerMeter;
int projectionMode;
float scale;
vec3 commonUnitsPerWorldUnit;
vec3 commonUnitsPerWorldUnit2;
vec4 center;
mat4 modelMatrix;
mat4 viewProjectionMatrix;
vec2 viewportSize;
float devicePixelRatio;
float focalDistance;
vec3 cameraPosition;
vec3 coordinateOrigin;
vec3 commonOrigin;
bool pseudoMeters;
} project;
const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / (PI * 2.0);
const vec3 ZERO_64_LOW = vec3(0.0);
const float EARTH_RADIUS = 6370972.0;
const float GLOBE_RADIUS = 256.0;
float project_size_at_latitude(float lat) {
float y = clamp(lat, -89.9, 89.9);
return 1.0 / cos(radians(y));
}
float project_size() {
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR &&
project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
project.pseudoMeters == false) {
if (geometry.position.w == 0.0) {
return project_size_at_latitude(geometry.worldPosition.y);
}
float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
float y2 = y * y;
float y4 = y2 * y2;
float y6 = y4 * y2;
return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
}
return 1.0;
}
float project_size_at_latitude(float meters, float lat) {
return meters * project.commonUnitsPerMeter.z * project_size_at_latitude(lat);
}
float project_size(float meters) {
return meters * project.commonUnitsPerMeter.z * project_size();
}
vec2 project_size(vec2 meters) {
return meters * project.commonUnitsPerMeter.xy * project_size();
}
vec3 project_size(vec3 meters) {
return meters * project.commonUnitsPerMeter * project_size();
}
vec4 project_size(vec4 meters) {
return vec4(meters.xyz * project.commonUnitsPerMeter, meters.w);
}
mat3 project_get_orientation_matrix(vec3 up) {
vec3 uz = normalize(up);
vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));
vec3 uy = cross(uz, ux);
return mat3(ux, uy, uz);
}
bool project_needs_rotation(vec3 commonPosition, out mat3 transform) {
if (project.projectionMode == PROJECTION_MODE_GLOBE) {
transform = project_get_orientation_matrix(commonPosition);
return true;
}
return false;
}
vec3 project_normal(vec3 vector) {
vec4 normal_modelspace = project.modelMatrix * vec4(vector, 0.0);
vec3 n = normalize(normal_modelspace.xyz * project.commonUnitsPerMeter);
mat3 rotation;
if (project_needs_rotation(geometry.position.xyz, rotation)) {
n = rotation * n;
}
return n;
}
vec4 project_offset_(vec4 offset) {
float dy = offset.y;
vec3 commonUnitsPerWorldUnit = project.commonUnitsPerWorldUnit + project.commonUnitsPerWorldUnit2 * dy;
return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}
vec2 project_mercator_(vec2 lnglat) {
float x = lnglat.x;
if (project.wrapLongitude) {
x = mod(x + 180., 360.0) - 180.;
}
float y = clamp(lnglat.y, -89.9, 89.9);
return vec2(
radians(x) + PI,
PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))
) * WORLD_SCALE;
}
vec3 project_globe_(vec3 lnglatz) {
float lambda = radians(lnglatz.x);
float phi = radians(lnglatz.y);
float cosPhi = cos(phi);
float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;
return vec3(
sin(lambda) * cosPhi,
-cos(lambda) * cosPhi,
sin(phi)
) * D;
}
vec4 project_position(vec4 position, vec3 position64Low) {
vec4 position_world = project.modelMatrix * position;
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_mercator_(position_world.xy),
project_size_at_latitude(position_world.z, position_world.y),
position_world.w
);
}
if (project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
position_world.xyz += project.coordinateOrigin;
}
}
if (project.projectionMode == PROJECTION_MODE_GLOBE) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_globe_(position_world.xyz),
position_world.w
);
}
}
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
if (abs(position_world.y - project.coordinateOrigin.y) > 0.25) {
return vec4(
project_mercator_(position_world.xy) - project.commonOrigin.xy,
project_size(position_world.z),
position_world.w
);
}
}
}
if (project.projectionMode == PROJECTION_MODE_IDENTITY ||
(project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
(project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
position_world.xyz -= project.coordinateOrigin;
}
return project_offset_(position_world) + project_offset_(project.modelMatrix * vec4(position64Low, 0.0));
}
vec4 project_position(vec4 position) {
return project_position(position, ZERO_64_LOW);
}
vec3 project_position(vec3 position, vec3 position64Low) {
vec4 projected_position = project_position(vec4(position, 1.0), position64Low);
return projected_position.xyz;
}
vec3 project_position(vec3 position) {
vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);
return projected_position.xyz;
}
vec2 project_position(vec2 position) {
vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);
return projected_position.xy;
}
vec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {
return viewProjectionMatrix * position + center;
}
vec4 project_common_position_to_clipspace(vec4 position) {
return project_common_position_to_clipspace(position, project.viewProjectionMatrix, project.center);
}
vec2 project_pixel_size_to_clipspace(vec2 pixels) {
vec2 offset = pixels / project.viewportSize * project.devicePixelRatio * 2.0;
return offset * project.focalDistance;
}
float project_size_to_pixel(float meters) {
return project_size(meters) * project.scale;
}
float project_size_to_pixel(float size, int unit) {
if (unit == UNIT_METERS) return project_size_to_pixel(size);
if (unit == UNIT_COMMON) return size * project.scale;
return size;
}
float project_pixel_size(float pixels) {
return pixels / project.scale;
}
vec2 project_pixel_size(vec2 pixels) {
return pixels / project.scale;
}
`
), qF = {};
function GF() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : qF;
  return "viewport" in r ? LF(r) : {};
}
const U2 = {
  name: "project",
  dependencies: [pD, T5],
  source: UF,
  vs: $F,
  getUniforms: GF,
  uniformTypes: {
    wrapLongitude: "f32",
    coordinateSystem: "i32",
    commonUnitsPerMeter: "vec3<f32>",
    projectionMode: "i32",
    scale: "f32",
    commonUnitsPerWorldUnit: "vec3<f32>",
    commonUnitsPerWorldUnit2: "vec3<f32>",
    center: "vec4<f32>",
    modelMatrix: "mat4x4<f32>",
    viewProjectionMatrix: "mat4x4<f32>",
    viewportSize: "vec2<f32>",
    devicePixelRatio: "f32",
    focalDistance: "f32",
    cameraPosition: "vec3<f32>",
    coordinateOrigin: "vec3<f32>",
    commonOrigin: "vec3<f32>",
    pseudoMeters: "f32"
  }
  // @ts-ignore TODO v9.1
}, HF = (
  /* wgsl */
  `// Define a structure to hold both the clip-space position and the common position.
struct ProjectResult {
  clipPosition: vec4<f32>,
  commonPosition: vec4<f32>,
};

// This function mimics the GLSL version with the 'out' parameter by returning both values.
fn project_position_to_clipspace_and_commonspace(
    position: vec3<f32>,
    position64Low: vec3<f32>,
    offset: vec3<f32>
) -> ProjectResult {
  // Compute the projected position.
  let projectedPosition: vec3<f32> = project_position_vec3_f64(position, position64Low);

  // Start with the provided offset.
  var finalOffset: vec3<f32> = offset;

  // Get whether a rotation is needed and the rotation matrix.
  let rotationResult = project_needs_rotation(projectedPosition);

  // If rotation is needed, update the offset.
  if (rotationResult.needsRotation) {
    finalOffset = rotationResult.transform * offset;
  }

  // Compute the common position.
  let commonPosition: vec4<f32> = vec4<f32>(projectedPosition + finalOffset, 1.0);

  // Convert to clip-space.
  let clipPosition: vec4<f32> = project_common_position_to_clipspace(commonPosition);

  return ProjectResult(clipPosition, commonPosition);
}

// A convenience overload that returns only the clip-space position.
fn project_position_to_clipspace(
    position: vec3<f32>,
    position64Low: vec3<f32>,
    offset: vec3<f32>
) -> vec4<f32> {
  return project_position_to_clipspace_and_commonspace(position, position64Low, offset).clipPosition;
}
`
), WF = (
  /* glsl */
  `vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition
) {
  vec3 projectedPosition = project_position(position, position64Low);
  mat3 rotation;
  if (project_needs_rotation(projectedPosition, rotation)) {
    // offset is specified as ENU
    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe
    offset = rotation * offset;
  }
  commonPosition = vec4(projectedPosition + offset, 1.0);
  return project_common_position_to_clipspace(commonPosition);
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset
) {
  vec4 commonPosition;
  return project_position_to_clipspace(position, position64Low, offset, commonPosition);
}
`
), z2 = {
  name: "project32",
  dependencies: [U2],
  source: HF,
  vs: WF
};
function XF() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function Wd(r, e) {
  const t = _p([], e, r);
  return D2(t, t, 1 / t[3]), t;
}
function UT(r, e) {
  const t = r % e;
  return t < 0 ? e + t : t;
}
function ov(r, e, t) {
  return r < e ? e : r > t ? t : r;
}
function ZF(r) {
  return Math.log(r) * Math.LOG2E;
}
const j2 = Math.log2 || ZF;
function nh(r, e) {
  if (!r)
    throw new Error(e || "@math.gl/web-mercator: assertion failed.");
}
const Ec = Math.PI, O5 = Ec / 4, Ul = Ec / 180, av = 180 / Ec, sp = 512, ey = 4003e4, ty = 85.051129, YF = 1.5;
function KF(r) {
  return j2(r);
}
function Og(r) {
  const [e, t] = r;
  nh(Number.isFinite(e)), nh(Number.isFinite(t) && t >= -90 && t <= 90, "invalid latitude");
  const n = e * Ul, i = t * Ul, s = sp * (n + Ec) / (2 * Ec), l = sp * (Ec + Math.log(Math.tan(O5 + i * 0.5))) / (2 * Ec);
  return [s, l];
}
function op(r) {
  const [e, t] = r, n = e / sp * (2 * Ec) - Ec, i = 2 * (Math.atan(Math.exp(t / sp * (2 * Ec) - Ec)) - O5);
  return [n * av, i * av];
}
function JF(r) {
  const {
    latitude: e
  } = r;
  nh(Number.isFinite(e));
  const t = Math.cos(e * Ul);
  return KF(ey * t) - 9;
}
function g_(r) {
  const e = Math.cos(r * Ul);
  return sp / ey / e;
}
function lv(r) {
  const {
    latitude: e,
    longitude: t,
    highPrecision: n = !1
  } = r;
  nh(Number.isFinite(e) && Number.isFinite(t));
  const i = sp, s = Math.cos(e * Ul), l = i / 360, o = l / s, d = i / ey / s, m = {
    unitsPerMeter: [d, d, d],
    metersPerUnit: [1 / d, 1 / d, 1 / d],
    unitsPerDegree: [l, o, d],
    degreesPerUnit: [1 / l, 1 / o, 1 / d]
  };
  if (n) {
    const b = Ul * Math.tan(e * Ul) / s, A = l * b / 2, M = i / ey * b, E = M / o * d;
    m.unitsPerDegree2 = [0, A, M], m.unitsPerMeter2 = [E, 0, E];
  }
  return m;
}
function k5(r, e) {
  const [t, n, i] = r, [s, l, o] = e, {
    unitsPerMeter: d,
    unitsPerMeter2: m
  } = lv({
    longitude: t,
    latitude: n,
    highPrecision: !0
  }), b = Og(r);
  b[0] += s * (d[0] + m[0] * l), b[1] += l * (d[1] + m[1] * l);
  const A = op(b), M = (i || 0) + (o || 0);
  return Number.isFinite(i) || Number.isFinite(o) ? [A[0], A[1], M] : A;
}
function QF(r) {
  const {
    // Viewport props
    height: e,
    pitch: t,
    bearing: n,
    altitude: i,
    // Pre-calculated parameters
    scale: s,
    center: l
  } = r, o = XF();
  J_(o, o, [0, 0, -i]), u5(o, o, -t * Ul), h5(o, o, n * Ul);
  const d = s / e;
  return N2(o, o, [d, d, d]), l && J_(o, o, nN([], l)), o;
}
function e8(r) {
  const {
    width: e,
    height: t,
    altitude: n,
    pitch: i = 0,
    offset: s,
    center: l,
    scale: o,
    nearZMultiplier: d = 1,
    farZMultiplier: m = 1
  } = r;
  let {
    fovy: b = kg(YF)
  } = r;
  n !== void 0 && (b = kg(n));
  const A = b * Ul, M = i * Ul, E = V2(b);
  let k = E;
  l && (k += l[2] * o / Math.cos(M) / t);
  const U = A * (0.5 + (s ? s[1] : 0) / t), V = Math.sin(U) * k / Math.sin(ov(Math.PI / 2 - M - U, 0.01, Math.PI - 0.01)), q = Math.sin(M) * V + k, Y = k * 10, re = Math.min(q * m, Y);
  return {
    fov: A,
    aspect: e / t,
    focalDistance: E,
    near: d,
    far: re
  };
}
function kg(r) {
  return 2 * Math.atan(0.5 / r) * av;
}
function V2(r) {
  return 0.5 / Math.tan(0.5 * r * Ul);
}
function N5(r, e) {
  const [t, n, i = 0] = r;
  return nh(Number.isFinite(t) && Number.isFinite(n) && Number.isFinite(i)), Wd(e, [t, n, i, 1]);
}
function $2(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const [n, i, s] = r;
  if (nh(Number.isFinite(n) && Number.isFinite(i), "invalid pixel coordinate"), Number.isFinite(s))
    return Wd(e, [n, i, s, 1]);
  const l = Wd(e, [n, i, 0, 1]), o = Wd(e, [n, i, 1, 1]), d = l[2], m = o[2], b = d === m ? 0 : ((t || 0) - d) / (m - d);
  return KC([], l, o, b);
}
function t8(r) {
  const {
    width: e,
    height: t,
    bounds: n,
    minExtent: i = 0,
    // 0.01 would be about 1000 meters (degree is ~110KM)
    maxZoom: s = 24,
    // ~x4,000,000 => About 10 meter extents
    offset: l = [0, 0]
  } = r, [[o, d], [m, b]] = n, A = r8(r.padding), M = Og([o, ov(b, -85.051129, ty)]), E = Og([m, ov(d, -85.051129, ty)]), k = [Math.max(Math.abs(E[0] - M[0]), i), Math.max(Math.abs(E[1] - M[1]), i)], U = [e - A.left - A.right - Math.abs(l[0]) * 2, t - A.top - A.bottom - Math.abs(l[1]) * 2];
  nh(U[0] > 0 && U[1] > 0);
  const V = U[0] / k[0], q = U[1] / k[1], Y = (A.right - A.left) / 2 / V, re = (A.top - A.bottom) / 2 / q, Z = [(E[0] + M[0]) / 2 + Y, (E[1] + M[1]) / 2 + re], K = op(Z), ie = Math.min(s, j2(Math.abs(Math.min(V, q))));
  return nh(Number.isFinite(ie)), {
    longitude: K[0],
    latitude: K[1],
    zoom: ie
  };
}
function r8() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  return typeof r == "number" ? {
    top: r,
    bottom: r,
    left: r,
    right: r
  } : (nh(Number.isFinite(r.top) && Number.isFinite(r.bottom) && Number.isFinite(r.left) && Number.isFinite(r.right)), r);
}
const zT = Math.PI / 180;
function n8(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  const {
    width: t,
    height: n,
    unproject: i
  } = r, s = {
    targetZ: e
  }, l = i([0, n], s), o = i([t, n], s);
  let d, m;
  const b = r.fovy ? 0.5 * r.fovy * zT : Math.atan(0.5 / r.altitude), A = (90 - r.pitch) * zT;
  return b > A - 0.01 ? (d = jT(r, 0, e), m = jT(r, t, e)) : (d = i([0, 0], s), m = i([t, 0], s)), [l, o, m, d];
}
function jT(r, e, t) {
  const {
    pixelUnprojectionMatrix: n
  } = r, i = Wd(n, [e, 0, 1, 1]), s = Wd(n, [e, r.height, 1, 1]), o = (t * r.distanceScales.unitsPerMeter[2] - i[2]) / (s[2] - i[2]), d = KC([], i, s, o), m = op(d);
  return m.push(t), m;
}
const VT = 512;
function i8(r) {
  const {
    width: e,
    height: t,
    pitch: n = 0
  } = r;
  let {
    longitude: i,
    latitude: s,
    zoom: l,
    bearing: o = 0
  } = r;
  (i < -180 || i > 180) && (i = UT(i + 180, 360) - 180), (o < -180 || o > 180) && (o = UT(o + 180, 360) - 180);
  const d = j2(t / VT);
  if (l <= d)
    l = d, s = 0;
  else {
    const m = t / 2 / Math.pow(2, l), b = op([0, m])[1];
    if (s < b)
      s = b;
    else {
      const A = op([0, VT - m])[1];
      s > A && (s = A);
    }
  }
  return {
    width: e,
    height: t,
    longitude: i,
    latitude: s,
    zoom: l,
    pitch: n,
    bearing: o
  };
}
const D5 = (
  /* glsl */
  `
uniform shadowUniforms {
  bool drawShadowMap;
  bool useShadowMap;
  vec4 color;
  highp int lightId;
  float lightCount;
  mat4 viewProjectionMatrix0;
  mat4 viewProjectionMatrix1;
  vec4 projectCenter0;
  vec4 projectCenter1;
} shadow;
`
), s8 = (
  /* glsl */
  `
const int max_lights = 2;

out vec3 shadow_vPosition[max_lights];

vec4 shadow_setVertexPosition(vec4 position_commonspace) {
  mat4 viewProjectionMatrices[max_lights];
  viewProjectionMatrices[0] = shadow.viewProjectionMatrix0;
  viewProjectionMatrices[1] = shadow.viewProjectionMatrix1;
  vec4 projectCenters[max_lights];
  projectCenters[0] = shadow.projectCenter0;
  projectCenters[1] = shadow.projectCenter1;

  if (shadow.drawShadowMap) {
    return project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[shadow.lightId], projectCenters[shadow.lightId]);
  }
  if (shadow.useShadowMap) {
    for (int i = 0; i < max_lights; i++) {
      if(i < int(shadow.lightCount)) {
        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[i], projectCenters[i]);
        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;
      }
    }
  }
  return gl_Position;
}
`
), o8 = `
${D5}
${s8}
`, a8 = (
  /* glsl */
  `
const int max_lights = 2;
uniform sampler2D shadow_uShadowMap0;
uniform sampler2D shadow_uShadowMap1;

in vec3 shadow_vPosition[max_lights];

const vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);
const vec4 bitUnpackShift = 1.0 / bitPackShift;
const vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);

float shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {
  vec4 rgbaDepth = texture(shadowMap, position.xy);

  float z = dot(rgbaDepth, bitUnpackShift);
  return smoothstep(0.001, 0.01, position.z - z);
}

vec4 shadow_filterShadowColor(vec4 color) {
  if (shadow.drawShadowMap) {
    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);
    rgbaDepth -= rgbaDepth.gbaa * bitMask;
    return rgbaDepth;
  }
  if (shadow.useShadowMap) {
    float shadowAlpha = 0.0;
    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);
    if(shadow.lightCount > 1.0) {
      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);
    }
    shadowAlpha *= shadow.color.a / shadow.lightCount;
    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);

    return vec4(
      mix(color.rgb, shadow.color.rgb, shadowAlpha / blendedAlpha),
      blendedAlpha
    );
  }
  return color;
}
`
), l8 = `
${D5}
${a8}
`, c8 = Yg(p8), u8 = Yg(g8), h8 = [0, 0, 0, 1], f8 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
function d8(r, e) {
  const [t, n, i] = r, s = $2([t, n, i], e);
  return Number.isFinite(i) ? s : [s[0], s[1], 0];
}
function p8(r) {
  let {
    viewport: e,
    center: t
  } = r;
  return new Bn(e.viewProjectionMatrix).invert().transform(t);
}
function g8(r) {
  let {
    viewport: e,
    shadowMatrices: t
  } = r;
  const n = [], i = e.pixelUnprojectionMatrix, s = e.isGeospatial ? void 0 : 1, l = [
    [0, 0, s],
    // top left ground
    [e.width, 0, s],
    // top right ground
    [0, e.height, s],
    // bottom left ground
    [e.width, e.height, s],
    // bottom right ground
    [0, 0, -1],
    // top left near
    [e.width, 0, -1],
    // top right near
    [0, e.height, -1],
    // bottom left near
    [e.width, e.height, -1]
    // bottom right near
  ].map((o) => (
    // @ts-expect-error z may be undefined
    d8(o, i)
  ));
  for (const o of t) {
    const d = o.clone().translate(new Ct(e.center).negate()), m = l.map((A) => d.transform(A)), b = new Bn().ortho({
      left: Math.min(...m.map((A) => A[0])),
      right: Math.max(...m.map((A) => A[0])),
      bottom: Math.min(...m.map((A) => A[1])),
      top: Math.max(...m.map((A) => A[1])),
      near: Math.min(...m.map((A) => -A[2])),
      far: Math.max(...m.map((A) => -A[2]))
    });
    n.push(b.multiplyRight(o));
  }
  return n;
}
function m8(r) {
  const {
    shadowEnabled: e = !0,
    project: t
  } = r;
  if (!e || !t || !r.shadowMatrices || !r.shadowMatrices.length)
    return {
      drawShadowMap: !1,
      useShadowMap: !1,
      shadow_uShadowMap0: r.dummyShadowMap,
      shadow_uShadowMap1: r.dummyShadowMap
    };
  const n = U2.getUniforms(t), i = c8({
    viewport: t.viewport,
    center: n.center
  }), s = [], l = u8({
    shadowMatrices: r.shadowMatrices,
    viewport: t.viewport
  }).slice();
  for (let d = 0; d < r.shadowMatrices.length; d++) {
    const m = l[d], b = m.clone().translate(new Ct(t.viewport.center).negate());
    n.coordinateSystem === Ln.LNGLAT && n.projectionMode === ml.WEB_MERCATOR ? (l[d] = b, s[d] = i) : (l[d] = m.clone().multiplyRight(f8), s[d] = b.transform(i));
  }
  const o = {
    drawShadowMap: !!r.drawToShadowMap,
    useShadowMap: r.shadowMaps ? r.shadowMaps.length > 0 : !1,
    color: r.shadowColor || h8,
    lightId: r.shadowLightId || 0,
    lightCount: r.shadowMatrices.length,
    shadow_uShadowMap0: r.dummyShadowMap,
    shadow_uShadowMap1: r.dummyShadowMap
  };
  for (let d = 0; d < l.length; d++)
    o[`viewProjectionMatrix${d}`] = l[d], o[`projectCenter${d}`] = s[d];
  for (let d = 0; d < 2; d++)
    o[`shadow_uShadowMap${d}`] = r.shadowMaps && r.shadowMaps[d] || r.dummyShadowMap;
  return o;
}
const $T = {
  name: "shadow",
  dependencies: [U2],
  vs: o8,
  fs: l8,
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": `
    position = shadow_setVertexPosition(geometry.position);
    `,
    "fs:DECKGL_FILTER_COLOR": `
    color = shadow_filterShadowColor(color);
    `
  },
  getUniforms: m8,
  uniformTypes: {
    drawShadowMap: "f32",
    useShadowMap: "f32",
    color: "vec4<f32>",
    lightId: "i32",
    lightCount: "f32",
    viewProjectionMatrix0: "mat4x4<f32>",
    viewProjectionMatrix1: "mat4x4<f32>",
    projectCenter0: "vec4<f32>",
    projectCenter1: "vec4<f32>"
  }
}, q2 = {
  ...bT,
  defaultUniforms: {
    ...bT.defaultUniforms,
    useFloatColors: !1
  },
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": `
    // for picking depth values
    picking_setPickingAttribute(position.z / position.w);
  `,
    "vs:DECKGL_FILTER_COLOR": `
  picking_setPickingColor(geometry.pickingColor);
  `,
    "fs:DECKGL_FILTER_COLOR": {
      order: 99,
      injection: `
  // use highlight color if this fragment belongs to the selected object.
  color = picking_filterHighlightColor(color);

  // use picking color if rendering to picking FBO.
  color = picking_filterPickingColor(color);
    `
    }
  }
}, _8 = [T5], y8 = ["vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)", "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)", "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)", "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"], b8 = [
  // Not yet supported
];
function v8(r) {
  const e = U_.getDefaultShaderAssembler();
  for (const n of _8)
    e.addDefaultModule(n);
  const t = r === "glsl" ? y8 : b8;
  for (const n of t)
    e.addShaderHook(n);
  return e;
}
const x8 = [255, 255, 255], w8 = 1;
let A8 = 0;
class F5 {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.type = "ambient";
    const {
      color: t = x8
    } = e, {
      intensity: n = w8
    } = e;
    this.id = e.id || `ambient-${A8++}`, this.color = t, this.intensity = n;
  }
}
const T8 = [255, 255, 255], S8 = 1, E8 = [0, 0, -1];
let C8 = 0;
class qT {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.type = "directional";
    const {
      color: t = T8
    } = e, {
      intensity: n = S8
    } = e, {
      direction: i = E8
    } = e, {
      _shadow: s = !1
    } = e;
    this.id = e.id || `directional-${C8++}`, this.color = t, this.intensity = n, this.type = "directional", this.direction = new Ct(i).normalize().toArray(), this.shadow = s;
  }
  getProjectedLight(e) {
    return this;
  }
}
class I8 {
  /** Create a new Pass instance */
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      id: "pass"
    };
    const {
      id: n
    } = t;
    this.id = n, this.device = e, this.props = {
      ...t
    };
  }
  setProps(e) {
    Object.assign(this.props, e);
  }
  render(e) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  cleanup() {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
}
class G2 extends I8 {
  constructor() {
    super(...arguments), this._lastRenderIndex = -1;
  }
  render(e) {
    const [t, n] = this.device.canvasContext.getDrawingBufferSize(), i = e.clearCanvas ?? !0, s = e.clearColor ?? (i ? [0, 0, 0, 0] : !1), l = i ? 1 : !1, o = i ? 0 : !1, d = e.colorMask ?? 15, m = {
      viewport: [0, 0, t, n]
    };
    e.colorMask && (m.colorMask = d), e.scissorRect && (m.scissorRect = e.scissorRect);
    const b = this.device.beginRenderPass({
      framebuffer: e.target,
      parameters: m,
      clearColor: s,
      clearDepth: l,
      clearStencil: o
    });
    try {
      return this._drawLayers(b, e);
    } finally {
      b.end(), this.device.submit();
    }
  }
  /** Draw a list of layers in a list of viewports */
  _drawLayers(e, t) {
    const {
      target: n,
      shaderModuleProps: i,
      viewports: s,
      views: l,
      onViewportActive: o,
      clearStack: d = !0
    } = t;
    t.pass = t.pass || "unknown", d && (this._lastRenderIndex = -1);
    const m = [];
    for (const b of s) {
      const A = l && l[b.id];
      o == null || o(b);
      const M = this._getDrawLayerParams(b, t), E = b.subViewports || [b];
      for (const k of E) {
        const U = this._drawLayersInViewport(e, {
          target: n,
          shaderModuleProps: i,
          viewport: k,
          view: A,
          pass: t.pass,
          layers: t.layers
        }, M);
        m.push(U);
      }
    }
    return m;
  }
  // When a viewport contains multiple subviewports (e.g. repeated web mercator map),
  // this is only done once for the parent viewport
  /* Resolve the parameters needed to draw each layer */
  _getDrawLayerParams(e, t) {
    var U;
    let {
      layers: n,
      pass: i,
      isPicking: s = !1,
      layerFilter: l,
      cullRect: o,
      effects: d,
      shaderModuleProps: m
    } = t, b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    const A = [], M = U5(this._lastRenderIndex + 1), E = {
      layer: n[0],
      viewport: e,
      isPicking: s,
      renderPass: i,
      cullRect: o
    }, k = {};
    for (let V = 0; V < n.length; V++) {
      const q = n[V], Y = this._shouldDrawLayer(q, E, l, k), re = {
        shouldDrawLayer: Y
      };
      Y && !b && (re.shouldDrawLayer = !0, re.layerRenderIndex = M(q, Y), re.shaderModuleProps = this._getShaderModuleProps(q, d, i, m), re.layerParameters = {
        ...(U = q.context.deck) == null ? void 0 : U.props.parameters,
        ...this.getLayerParameters(q, V, e)
      }), A[V] = re;
    }
    return A;
  }
  // Draws a list of layers in one viewport
  // TODO - when picking we could completely skip rendering viewports that dont
  // intersect with the picking rect
  /* eslint-disable max-depth, max-statements */
  _drawLayersInViewport(e, t, n) {
    let {
      layers: i,
      shaderModuleProps: s,
      pass: l,
      target: o,
      viewport: d,
      view: m
    } = t;
    const b = M8(this.device, {
      shaderModuleProps: s,
      target: o,
      viewport: d
    });
    if (m && m.props.clear) {
      const M = m.props.clear === !0 ? {
        color: !0,
        depth: !0
      } : m.props.clear;
      this.device.beginRenderPass({
        framebuffer: o,
        parameters: {
          viewport: b,
          scissorRect: b
        },
        clearColor: M.color ? [0, 0, 0, 0] : !1,
        clearDepth: M.depth ? 1 : !1
      }).end();
    }
    const A = {
      totalCount: i.length,
      visibleCount: 0,
      compositeCount: 0,
      pickableCount: 0
    };
    e.setParameters({
      viewport: b
    });
    for (let M = 0; M < i.length; M++) {
      const E = i[M], k = n[M], {
        shouldDrawLayer: U
      } = k;
      if (U && E.props.pickable && A.pickableCount++, E.isComposite && A.compositeCount++, E.isDrawable && k.shouldDrawLayer) {
        const {
          layerRenderIndex: V,
          shaderModuleProps: q,
          layerParameters: Y
        } = k;
        A.visibleCount++, this._lastRenderIndex = Math.max(this._lastRenderIndex, V), q.project && (q.project.viewport = d), E.context.renderPass = e;
        try {
          E._drawLayer({
            renderPass: e,
            shaderModuleProps: q,
            uniforms: {
              layerIndex: V
            },
            parameters: Y
          });
        } catch (re) {
          E.raiseError(re, `drawing ${E} to ${l}`);
        }
      }
    }
    return A;
  }
  /* eslint-enable max-depth, max-statements */
  /* Methods for subclass overrides */
  shouldDrawLayer(e) {
    return !0;
  }
  getShaderModuleProps(e, t, n) {
    return null;
  }
  getLayerParameters(e, t, n) {
    return e.props.parameters;
  }
  /* Private */
  _shouldDrawLayer(e, t, n, i) {
    if (!(e.props.visible && this.shouldDrawLayer(e)))
      return !1;
    t.layer = e;
    let l = e.parent;
    for (; l; ) {
      if (!l.props.visible || !l.filterSubLayer(t))
        return !1;
      t.layer = l, l = l.parent;
    }
    if (n) {
      const o = t.layer.id;
      if (o in i || (i[o] = n(t)), !i[o])
        return !1;
    }
    return e.activateViewport(t.viewport), !0;
  }
  _getShaderModuleProps(e, t, n, i) {
    var d, m;
    const s = this.device.canvasContext.cssToDeviceRatio(), l = ((d = e.internalState) == null ? void 0 : d.propsInTransition) || e.props, o = {
      layer: l,
      picking: {
        isActive: !1
      },
      project: {
        viewport: e.context.viewport,
        devicePixelRatio: s,
        modelMatrix: l.modelMatrix,
        coordinateSystem: l.coordinateSystem,
        coordinateOrigin: l.coordinateOrigin,
        autoWrapLongitude: e.wrapLongitude
      }
    };
    if (t)
      for (const b of t)
        GT(o, (m = b.getShaderModuleProps) == null ? void 0 : m.call(b, e, o));
    return GT(o, this.getShaderModuleProps(e, t, o), i);
  }
}
function U5() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = {}, n = (i, s) => {
    const l = i.props._offset, o = i.id, d = i.parent && i.parent.id;
    let m;
    if (d && !(d in e) && n(i.parent, !1), d in t) {
      const b = t[d] = t[d] || U5(e[d], e);
      m = b(i, s), t[o] = b;
    } else Number.isFinite(l) ? (m = l + (e[d] || 0), t[o] = null) : m = r;
    return s && m >= r && (r = m + 1), e[o] = m, m;
  };
  return n;
}
function M8(r, e) {
  var m;
  let {
    shaderModuleProps: t,
    target: n,
    viewport: i
  } = e;
  const s = ((m = t == null ? void 0 : t.project) == null ? void 0 : m.devicePixelRatio) ?? // @ts-expect-error TODO - assuming WebGL context
  r.canvasContext.cssToDeviceRatio(), [, l] = r.canvasContext.getDrawingBufferSize(), o = n ? n.height : l, d = i;
  return [d.x * s, o - (d.y + d.height) * s, d.width * s, d.height * s];
}
function GT(r) {
  for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
    t[n - 1] = arguments[n];
  for (const i of t)
    if (i)
      for (const s in i)
        r[s] ? Object.assign(r[s], i[s]) : r[s] = i[s];
  return r;
}
class P8 extends G2 {
  constructor(e, t) {
    super(e, t);
    const n = e.createTexture({
      format: "rgba8unorm",
      width: 1,
      height: 1,
      sampler: {
        minFilter: "linear",
        magFilter: "linear",
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      },
      mipmaps: !0
    }), i = e.createTexture({
      format: "depth16unorm",
      width: 1,
      height: 1,
      mipmaps: !1
    });
    this.fbo = e.createFramebuffer({
      id: "shadowmap",
      width: 1,
      height: 1,
      colorAttachments: [n],
      // Depth attachment has to be specified for depth test to work
      depthStencilAttachment: i
    });
  }
  delete() {
    this.fbo && (this.fbo.destroy(), this.fbo = null);
  }
  getShadowMap() {
    return this.fbo.colorAttachments[0].texture;
  }
  render(e) {
    const t = this.fbo, n = this.device.canvasContext.cssToDeviceRatio(), i = e.viewports[0], s = i.width * n, l = i.height * n, o = [1, 1, 1, 1];
    (s !== t.width || l !== t.height) && t.resize({
      width: s,
      height: l
    }), super.render({
      ...e,
      clearColor: o,
      target: t,
      pass: "shadow"
    });
  }
  getLayerParameters(e, t, n) {
    return {
      ...e.props.parameters,
      blend: !1,
      depthWriteEnabled: !0,
      depthCompare: "less-equal"
    };
  }
  shouldDrawLayer(e) {
    return e.props.shadowEnabled !== !1;
  }
  getShaderModuleProps(e, t, n) {
    return {
      shadow: {
        project: n.project,
        drawToShadowMap: !0
      }
    };
  }
}
const R8 = {
  color: [255, 255, 255],
  intensity: 1
}, HT = [{
  color: [255, 255, 255],
  intensity: 1,
  direction: [-1, 3, -1]
}, {
  color: [255, 255, 255],
  intensity: 0.9,
  direction: [1, -8, -2.5]
}], B8 = [0, 0, 0, 200 / 255];
class H2 {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.id = "lighting-effect", this.shadowColor = B8, this.shadow = !1, this.directionalLights = [], this.pointLights = [], this.shadowPasses = [], this.dummyShadowMap = null, this.setProps(e);
  }
  setup(e) {
    this.context = e;
    const {
      device: t,
      deck: n
    } = e;
    this.shadow && !this.dummyShadowMap && (this._createShadowPasses(t), n._addDefaultShaderModule($T), this.dummyShadowMap = t.createTexture({
      width: 1,
      height: 1
    }));
  }
  setProps(e) {
    this.ambientLight = void 0, this.directionalLights = [], this.pointLights = [];
    for (const t in e) {
      const n = e[t];
      switch (n.type) {
        case "ambient":
          this.ambientLight = n;
          break;
        case "directional":
          this.directionalLights.push(n);
          break;
        case "point":
          this.pointLights.push(n);
          break;
      }
    }
    this._applyDefaultLights(), this.shadow = this.directionalLights.some((t) => t.shadow), this.context && this.setup(this.context), this.props = e;
  }
  preRender(e) {
    let {
      layers: t,
      layerFilter: n,
      viewports: i,
      onViewportActive: s,
      views: l
    } = e;
    if (this.shadow) {
      this.shadowMatrices = this._calculateMatrices();
      for (let o = 0; o < this.shadowPasses.length; o++)
        this.shadowPasses[o].render({
          layers: t,
          layerFilter: n,
          viewports: i,
          onViewportActive: s,
          views: l,
          shaderModuleProps: {
            shadow: {
              shadowLightId: o,
              dummyShadowMap: this.dummyShadowMap,
              shadowMatrices: this.shadowMatrices
            }
          }
        });
    }
  }
  getShaderModuleProps(e, t) {
    const n = this.shadow ? {
      project: t.project,
      shadowMaps: this.shadowPasses.map((l) => l.getShadowMap()),
      dummyShadowMap: this.dummyShadowMap,
      shadowColor: this.shadowColor,
      shadowMatrices: this.shadowMatrices
    } : {}, i = {
      enabled: !0,
      ambientLight: this.ambientLight,
      directionalLights: this.directionalLights.map((l) => l.getProjectedLight({
        layer: e
      })),
      pointLights: this.pointLights.map((l) => l.getProjectedLight({
        layer: e
      }))
    }, s = e.props.material;
    return {
      shadow: n,
      lighting: i,
      phongMaterial: s,
      gouraudMaterial: s
    };
  }
  cleanup(e) {
    for (const t of this.shadowPasses)
      t.delete();
    this.shadowPasses.length = 0, this.dummyShadowMap && (this.dummyShadowMap.destroy(), this.dummyShadowMap = null, e.deck._removeDefaultShaderModule($T));
  }
  _calculateMatrices() {
    const e = [];
    for (const t of this.directionalLights) {
      const n = new Bn().lookAt({
        eye: new Ct(t.direction).negate()
      });
      e.push(n);
    }
    return e;
  }
  _createShadowPasses(e) {
    for (let t = 0; t < this.directionalLights.length; t++) {
      const n = new P8(e);
      this.shadowPasses[t] = n;
    }
  }
  _applyDefaultLights() {
    const {
      ambientLight: e,
      pointLights: t,
      directionalLights: n
    } = this;
    !e && t.length === 0 && n.length === 0 && (this.ambientLight = new F5(R8), this.directionalLights.push(new qT(HT[0]), new qT(HT[1])));
  }
}
class L8 {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._pool = [], this.opts = {
      overAlloc: 2,
      poolSize: 100
    }, this.setOptions(e);
  }
  setOptions(e) {
    Object.assign(this.opts, e);
  }
  allocate(e, t, n) {
    let {
      size: i = 1,
      type: s,
      padding: l = 0,
      copy: o = !1,
      initialize: d = !1,
      maxCount: m
    } = n;
    const b = s || e && e.constructor || Float32Array, A = t * i + l;
    if (ArrayBuffer.isView(e)) {
      if (A <= e.length)
        return e;
      if (A * e.BYTES_PER_ELEMENT <= e.buffer.byteLength)
        return new b(e.buffer, 0, A);
    }
    let M = 1 / 0;
    m && (M = m * i + l);
    const E = this._allocate(b, A, d, M);
    return e && o ? E.set(e) : d || E.fill(0, 0, 4), this._release(e), E;
  }
  release(e) {
    this._release(e);
  }
  _allocate(e, t, n, i) {
    let s = Math.max(Math.ceil(t * this.opts.overAlloc), 1);
    s > i && (s = i);
    const l = this._pool, o = e.BYTES_PER_ELEMENT * s, d = l.findIndex((m) => m.byteLength >= o);
    if (d >= 0) {
      const m = new e(l.splice(d, 1)[0], 0, s);
      return n && m.fill(0), m;
    }
    return new e(s);
  }
  _release(e) {
    if (!ArrayBuffer.isView(e))
      return;
    const t = this._pool, {
      buffer: n
    } = e, {
      byteLength: i
    } = n, s = t.findIndex((l) => l.byteLength >= i);
    s < 0 ? t.push(n) : (s > 0 || t.length < this.opts.poolSize) && t.splice(s, 0, n), t.length > this.opts.poolSize && t.shift();
  }
}
const Ng = new L8();
function ug() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function O8(r, e) {
  const t = r % e;
  return t < 0 ? e + t : t;
}
function k8(r) {
  return [r[12], r[13], r[14]];
}
function N8(r) {
  return {
    left: Td(r[3] + r[0], r[7] + r[4], r[11] + r[8], r[15] + r[12]),
    right: Td(r[3] - r[0], r[7] - r[4], r[11] - r[8], r[15] - r[12]),
    bottom: Td(r[3] + r[1], r[7] + r[5], r[11] + r[9], r[15] + r[13]),
    top: Td(r[3] - r[1], r[7] - r[5], r[11] - r[9], r[15] - r[13]),
    near: Td(r[3] + r[2], r[7] + r[6], r[11] + r[10], r[15] + r[14]),
    far: Td(r[3] - r[2], r[7] - r[6], r[11] - r[10], r[15] - r[14])
  };
}
const WT = new Ct();
function Td(r, e, t, n) {
  WT.set(r, e, t);
  const i = WT.len();
  return {
    distance: n / i,
    normal: new Ct(-r / i, -e / i, -t / i)
  };
}
function D8(r) {
  return r - Math.fround(r);
}
let Xp;
function Tb(r, e) {
  const {
    size: t = 1,
    startIndex: n = 0
  } = e, i = e.endIndex !== void 0 ? e.endIndex : r.length, s = (i - n) / t;
  Xp = Ng.allocate(Xp, s, {
    type: Float32Array,
    size: t * 2
  });
  let l = n, o = 0;
  for (; l < i; ) {
    for (let d = 0; d < t; d++) {
      const m = r[l++];
      Xp[o + d] = m, Xp[o + d + t] = D8(m);
    }
    o += t * 2;
  }
  return Xp.subarray(0, s * t * 2);
}
function F8(r) {
  let e = null, t = !1;
  for (const n of r)
    n && (e ? (t || (e = [[e[0][0], e[0][1]], [e[1][0], e[1][1]]], t = !0), e[0][0] = Math.min(e[0][0], n[0][0]), e[0][1] = Math.min(e[0][1], n[0][1]), e[1][0] = Math.max(e[1][0], n[1][0]), e[1][1] = Math.max(e[1][1], n[1][1])) : e = n);
  return e;
}
const U8 = Math.PI / 180, z8 = ug(), XT = [0, 0, 0], j8 = {
  unitsPerMeter: [1, 1, 1],
  metersPerUnit: [1, 1, 1]
};
function V8(r) {
  let {
    width: e,
    height: t,
    orthographic: n,
    fovyRadians: i,
    focalDistance: s,
    padding: l,
    near: o,
    far: d
  } = r;
  const m = e / t, b = n ? new Bn().orthographic({
    fovy: i,
    aspect: m,
    focalDistance: s,
    near: o,
    far: d
  }) : new Bn().perspective({
    fovy: i,
    aspect: m,
    near: o,
    far: d
  });
  if (l) {
    const {
      left: A = 0,
      right: M = 0,
      top: E = 0,
      bottom: k = 0
    } = l, U = Sc((A + e - M) / 2, 0, e) - e / 2, V = Sc((E + t - k) / 2, 0, t) - t / 2;
    b[8] -= U * 2 / e, b[9] += V * 2 / t;
  }
  return b;
}
class yp {
  // eslint-disable-next-line complexity
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._frustumPlanes = {}, this.id = e.id || this.constructor.displayName || "viewport", this.x = e.x || 0, this.y = e.y || 0, this.width = e.width || 1, this.height = e.height || 1, this.zoom = e.zoom || 0, this.padding = e.padding, this.distanceScales = e.distanceScales || j8, this.focalDistance = e.focalDistance || 1, this.position = e.position || XT, this.modelMatrix = e.modelMatrix || null;
    const {
      longitude: t,
      latitude: n
    } = e;
    this.isGeospatial = Number.isFinite(n) && Number.isFinite(t), this._initProps(e), this._initMatrices(e), this.equals = this.equals.bind(this), this.project = this.project.bind(this), this.unproject = this.unproject.bind(this), this.projectPosition = this.projectPosition.bind(this), this.unprojectPosition = this.unprojectPosition.bind(this), this.projectFlat = this.projectFlat.bind(this), this.unprojectFlat = this.unprojectFlat.bind(this);
  }
  get subViewports() {
    return null;
  }
  get metersPerPixel() {
    return this.distanceScales.metersPerUnit[2] / this.scale;
  }
  get projectionMode() {
    return this.isGeospatial ? this.zoom < 12 ? ml.WEB_MERCATOR : ml.WEB_MERCATOR_AUTO_OFFSET : ml.IDENTITY;
  }
  // Two viewports are equal if width and height are identical, and if
  // their view and projection matrices are (approximately) equal.
  equals(e) {
    return e instanceof yp ? this === e ? !0 : e.width === this.width && e.height === this.height && e.scale === this.scale && Mc(e.projectionMatrix, this.projectionMatrix) && Mc(e.viewMatrix, this.viewMatrix) : !1;
  }
  /**
   * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
   * using viewport projection parameters
   * - [longitude, latitude] to [x, y]
   * - [longitude, latitude, Z] => [x, y, z]
   * Note: By default, returns top-left coordinates for canvas/SVG type render
   *
   * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether projected coords are top left
   * @return {Array} - [x, y] or [x, y, z] in top left coords
   */
  project(e) {
    let {
      topLeft: t = !0
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const n = this.projectPosition(e), i = N5(n, this.pixelProjectionMatrix), [s, l] = i, o = t ? l : this.height - l;
    return e.length === 2 ? [s, o] : [s, o, i[2]];
  }
  /**
   * Unproject pixel coordinates on screen onto world coordinates,
   * (possibly [lon, lat]) on map.
   * - [x, y] => [lng, lat]
   * - [x, y, z] => [lng, lat, Z]
   * @param {Array} xyz -
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether origin is top left
   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
   */
  unproject(e) {
    let {
      topLeft: t = !0,
      targetZ: n
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const [i, s, l] = e, o = t ? s : this.height - s, d = n && n * this.distanceScales.unitsPerMeter[2], m = $2([i, o, l], this.pixelUnprojectionMatrix, d), [b, A, M] = this.unprojectPosition(m);
    return Number.isFinite(l) ? [b, A, M] : Number.isFinite(n) ? [b, A, n] : [b, A];
  }
  // NON_LINEAR PROJECTION HOOKS
  // Used for web meractor projection
  projectPosition(e) {
    const [t, n] = this.projectFlat(e), i = (e[2] || 0) * this.distanceScales.unitsPerMeter[2];
    return [t, n, i];
  }
  unprojectPosition(e) {
    const [t, n] = this.unprojectFlat(e), i = (e[2] || 0) * this.distanceScales.metersPerUnit[2];
    return [t, n, i];
  }
  /**
   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
   * Performs the nonlinear part of the web mercator projection.
   * Remaining projection is done with 4x4 matrices which also handles
   * perspective.
   * @param {Array} lngLat - [lng, lat] coordinates
   *   Specifies a point on the sphere to project onto the map.
   * @return {Array} [x,y] coordinates.
   */
  projectFlat(e) {
    if (this.isGeospatial) {
      const t = Og(e);
      return t[1] = Sc(t[1], -318, 830), t;
    }
    return e;
  }
  /**
   * Unproject world point [x,y] on map onto {lat, lon} on sphere
   * @param {object|Vector} xy - object with {x,y} members
   *  representing point on projected map plane
   * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
   *   Has toArray method if you need a GeoJSON Array.
   *   Per cartographic tradition, lat and lon are specified as degrees.
   */
  unprojectFlat(e) {
    return this.isGeospatial ? op(e) : e;
  }
  /**
   * Get bounds of the current viewport
   * @return {Array} - [minX, minY, maxX, maxY]
   */
  getBounds() {
    const t = {
      targetZ: (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}).z || 0
    }, n = this.unproject([0, 0], t), i = this.unproject([this.width, 0], t), s = this.unproject([0, this.height], t), l = this.unproject([this.width, this.height], t);
    return [Math.min(n[0], i[0], s[0], l[0]), Math.min(n[1], i[1], s[1], l[1]), Math.max(n[0], i[0], s[0], l[0]), Math.max(n[1], i[1], s[1], l[1])];
  }
  getDistanceScales(e) {
    return e && this.isGeospatial ? lv({
      longitude: e[0],
      latitude: e[1],
      highPrecision: !0
    }) : this.distanceScales;
  }
  containsPixel(e) {
    let {
      x: t,
      y: n,
      width: i = 1,
      height: s = 1
    } = e;
    return t < this.x + this.width && this.x < t + i && n < this.y + this.height && this.y < n + s;
  }
  // Extract frustum planes in common space
  getFrustumPlanes() {
    return this._frustumPlanes.near ? this._frustumPlanes : (Object.assign(this._frustumPlanes, N8(this.viewProjectionMatrix)), this._frustumPlanes);
  }
  // EXPERIMENTAL METHODS
  /**
   * Needed by panning and linear transition
   * Pan the viewport to place a given world coordinate at screen point [x, y]
   *
   * @param {Array} coords - world coordinates
   * @param {Array} pixel - [x,y] coordinates on screen
   * @return {Object} props of the new viewport
   */
  panByPosition(e, t) {
    return null;
  }
  // INTERNAL METHODS
  /* eslint-disable complexity, max-statements */
  _initProps(e) {
    const t = e.longitude, n = e.latitude;
    this.isGeospatial && (Number.isFinite(e.zoom) || (this.zoom = JF({
      latitude: n
    }) + Math.log2(this.focalDistance)), this.distanceScales = e.distanceScales || lv({
      latitude: n,
      longitude: t
    }));
    const i = Math.pow(2, this.zoom);
    this.scale = i;
    const {
      position: s,
      modelMatrix: l
    } = e;
    let o = XT;
    if (s && (o = l ? new Bn(l).transformAsVector(s, []) : s), this.isGeospatial) {
      const d = this.projectPosition([t, n, 0]);
      this.center = new Ct(o).scale(this.distanceScales.unitsPerMeter).add(d);
    } else
      this.center = this.projectPosition(o);
  }
  /* eslint-enable complexity, max-statements */
  _initMatrices(e) {
    const {
      // View matrix
      viewMatrix: t = z8,
      // Projection matrix
      projectionMatrix: n = null,
      // Projection matrix parameters, used if projectionMatrix not supplied
      orthographic: i = !1,
      fovyRadians: s,
      fovy: l = 75,
      near: o = 0.1,
      // Distance of near clipping plane
      far: d = 1e3,
      // Distance of far clipping plane
      padding: m = null,
      // Center offset in pixels
      focalDistance: b = 1
    } = e;
    this.viewMatrixUncentered = t, this.viewMatrix = new Bn().multiplyRight(t).translate(new Ct(this.center).negate()), this.projectionMatrix = n || V8({
      width: this.width,
      height: this.height,
      orthographic: i,
      fovyRadians: s || l * U8,
      focalDistance: b,
      padding: m,
      near: o,
      far: d
    });
    const A = ug();
    Nf(A, A, this.projectionMatrix), Nf(A, A, this.viewMatrix), this.viewProjectionMatrix = A, this.viewMatrixInverse = Q1([], this.viewMatrix) || this.viewMatrix, this.cameraPosition = k8(this.viewMatrixInverse);
    const M = ug(), E = ug();
    N2(M, M, [this.width / 2, -this.height / 2, 1]), J_(M, M, [1, -1, 0]), Nf(E, M, this.viewProjectionMatrix), this.pixelProjectionMatrix = E, this.pixelUnprojectionMatrix = Q1(ug(), this.pixelProjectionMatrix), this.pixelUnprojectionMatrix || Gn.warn("Pixel project matrix not invertible")();
  }
}
yp.displayName = "Viewport";
class qf extends yp {
  /* eslint-disable complexity, max-statements */
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      latitude: t = 0,
      longitude: n = 0,
      zoom: i = 0,
      pitch: s = 0,
      bearing: l = 0,
      nearZMultiplier: o = 0.1,
      farZMultiplier: d = 1.01,
      nearZ: m,
      farZ: b,
      orthographic: A = !1,
      projectionMatrix: M,
      repeat: E = !1,
      worldOffset: k = 0,
      position: U,
      padding: V,
      // backward compatibility
      // TODO: remove in v9
      legacyMeterSizes: q = !1
    } = e;
    let {
      width: Y,
      height: re,
      altitude: Z = 1.5
    } = e;
    const K = Math.pow(2, i);
    Y = Y || 1, re = re || 1;
    let ie, be = null;
    if (M)
      Z = M[5] / 2, ie = kg(Z);
    else {
      e.fovy ? (ie = e.fovy, Z = V2(ie)) : ie = kg(Z);
      let Be;
      if (V) {
        const {
          top: ke = 0,
          bottom: pe = 0
        } = V;
        Be = [0, Sc((ke + re - pe) / 2, 0, re) - re / 2];
      }
      be = e8({
        width: Y,
        height: re,
        scale: K,
        center: U && [0, 0, U[2] * g_(t)],
        offset: Be,
        pitch: s,
        fovy: ie,
        nearZMultiplier: o,
        farZMultiplier: d
      }), Number.isFinite(m) && (be.near = m), Number.isFinite(b) && (be.far = b);
    }
    let he = QF({
      height: re,
      pitch: s,
      bearing: l,
      scale: K,
      altitude: Z
    });
    k && (he = new Bn().translate([512 * k, 0, 0]).multiplyLeft(he)), super({
      ...e,
      // x, y,
      width: Y,
      height: re,
      // view matrix
      viewMatrix: he,
      longitude: n,
      latitude: t,
      zoom: i,
      // projection matrix parameters
      ...be,
      fovy: ie,
      focalDistance: Z
    }), this.latitude = t, this.longitude = n, this.zoom = i, this.pitch = s, this.bearing = l, this.altitude = Z, this.fovy = ie, this.orthographic = A, this._subViewports = E ? [] : null, this._pseudoMeters = q, Object.freeze(this);
  }
  /* eslint-enable complexity, max-statements */
  get subViewports() {
    if (this._subViewports && !this._subViewports.length) {
      const e = this.getBounds(), t = Math.floor((e[0] + 180) / 360), n = Math.ceil((e[2] - 180) / 360);
      for (let i = t; i <= n; i++) {
        const s = i ? new qf({
          ...this,
          worldOffset: i
        }) : this;
        this._subViewports.push(s);
      }
    }
    return this._subViewports;
  }
  projectPosition(e) {
    if (this._pseudoMeters)
      return super.projectPosition(e);
    const [t, n] = this.projectFlat(e), i = (e[2] || 0) * g_(e[1]);
    return [t, n, i];
  }
  unprojectPosition(e) {
    if (this._pseudoMeters)
      return super.unprojectPosition(e);
    const [t, n] = this.unprojectFlat(e), i = (e[2] || 0) / g_(n);
    return [t, n, i];
  }
  /**
   * Add a meter delta to a base lnglat coordinate, returning a new lnglat array
   *
   * Note: Uses simple linear approximation around the viewport center
   * Error increases with size of offset (roughly 1% per 100km)
   *
   * @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate
   * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
   * @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas
   */
  addMetersToLngLat(e, t) {
    return k5(e, t);
  }
  panByPosition(e, t) {
    const n = $2(t, this.pixelUnprojectionMatrix), i = this.projectFlat(e), s = fT([], i, Yk([], n)), l = fT([], this.center, s), [o, d] = this.unprojectFlat(l);
    return {
      longitude: o,
      latitude: d
    };
  }
  getBounds() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = n8(this, e.z || 0);
    return [Math.min(t[0][0], t[1][0], t[2][0], t[3][0]), Math.min(t[0][1], t[1][1], t[2][1], t[3][1]), Math.max(t[0][0], t[1][0], t[2][0], t[3][0]), Math.max(t[0][1], t[1][1], t[2][1], t[3][1])];
  }
  /**
   * Returns a new viewport that fit around the given rectangle.
   * Only supports non-perspective mode.
   */
  fitBounds(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      width: n,
      height: i
    } = this, {
      longitude: s,
      latitude: l,
      zoom: o
    } = t8({
      width: n,
      height: i,
      bounds: e,
      ...t
    });
    return new qf({
      width: n,
      height: i,
      longitude: s,
      latitude: l,
      zoom: o
    });
  }
}
qf.displayName = "WebMercatorViewport";
const ZT = [0, 0, 0];
function Sb(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  const n = e.projectPosition(r);
  if (t && e instanceof qf) {
    const [i, s, l = 0] = r, o = e.getDistanceScales([i, s]);
    n[2] = l * o.unitsPerMeter[2];
  }
  return n;
}
function $8(r) {
  const {
    viewport: e,
    modelMatrix: t,
    coordinateOrigin: n
  } = r;
  let {
    coordinateSystem: i,
    fromCoordinateSystem: s,
    fromCoordinateOrigin: l
  } = r;
  return i === Ln.DEFAULT && (i = e.isGeospatial ? Ln.LNGLAT : Ln.CARTESIAN), s === void 0 && (s = i), l === void 0 && (l = n), {
    viewport: e,
    coordinateSystem: i,
    coordinateOrigin: n,
    modelMatrix: t,
    fromCoordinateSystem: s,
    fromCoordinateOrigin: l
  };
}
function z5(r, e) {
  let {
    viewport: t,
    modelMatrix: n,
    coordinateSystem: i,
    coordinateOrigin: s,
    offsetMode: l
  } = e, [o, d, m = 0] = r;
  switch (n && ([o, d, m] = _p([], [o, d, m, 1], n)), i) {
    case Ln.LNGLAT:
      return Sb([o, d, m], t, l);
    case Ln.LNGLAT_OFFSETS:
      return Sb([o + s[0], d + s[1], m + (s[2] || 0)], t, l);
    case Ln.METER_OFFSETS:
      return Sb(k5(s, [o, d, m]), t, l);
    case Ln.CARTESIAN:
    default:
      return t.isGeospatial ? [o + s[0], d + s[1], m + s[2]] : t.projectPosition([o, d, m]);
  }
}
function q8(r, e) {
  const {
    viewport: t,
    coordinateSystem: n,
    coordinateOrigin: i,
    modelMatrix: s,
    fromCoordinateSystem: l,
    fromCoordinateOrigin: o
  } = $8(e), {
    autoOffset: d = !0
  } = e, {
    geospatialOrigin: m = ZT,
    shaderCoordinateOrigin: b = ZT,
    offsetMode: A = !1
  } = d ? L5(t, n, i) : {}, M = z5(r, {
    viewport: t,
    modelMatrix: s,
    coordinateSystem: l,
    coordinateOrigin: o,
    offsetMode: A
  });
  if (A) {
    const E = t.projectPosition(m || b);
    a5(M, M, E);
  }
  return M;
}
let G8 = 1, H8 = 1;
class j5 {
  constructor() {
    H(this, "time", 0);
    H(this, "channels", /* @__PURE__ */ new Map());
    H(this, "animations", /* @__PURE__ */ new Map());
    H(this, "playing", !1);
    H(this, "lastEngineTime", -1);
  }
  addChannel(e) {
    const {
      delay: t = 0,
      duration: n = Number.POSITIVE_INFINITY,
      rate: i = 1,
      repeat: s = 1
    } = e, l = G8++, o = {
      time: 0,
      delay: t,
      duration: n,
      rate: i,
      repeat: s
    };
    return this._setChannelTime(o, this.time), this.channels.set(l, o), l;
  }
  removeChannel(e) {
    this.channels.delete(e);
    for (const [t, n] of this.animations)
      n.channel === e && this.detachAnimation(t);
  }
  isFinished(e) {
    const t = this.channels.get(e);
    return t === void 0 ? !1 : this.time >= t.delay + t.duration * t.repeat;
  }
  getTime(e) {
    if (e === void 0)
      return this.time;
    const t = this.channels.get(e);
    return t === void 0 ? -1 : t.time;
  }
  setTime(e) {
    this.time = Math.max(0, e);
    const t = this.channels.values();
    for (const i of t)
      this._setChannelTime(i, this.time);
    const n = this.animations.values();
    for (const i of n) {
      const {
        animation: s,
        channel: l
      } = i;
      s.setTime(this.getTime(l));
    }
  }
  play() {
    this.playing = !0;
  }
  pause() {
    this.playing = !1, this.lastEngineTime = -1;
  }
  reset() {
    this.setTime(0);
  }
  attachAnimation(e, t) {
    const n = H8++;
    return this.animations.set(n, {
      animation: e,
      channel: t
    }), e.setTime(this.getTime(t)), n;
  }
  detachAnimation(e) {
    this.animations.delete(e);
  }
  update(e) {
    this.playing && (this.lastEngineTime === -1 && (this.lastEngineTime = e), this.setTime(this.time + (e - this.lastEngineTime)), this.lastEngineTime = e);
  }
  _setChannelTime(e, t) {
    const n = t - e.delay, i = e.duration * e.repeat;
    n >= i ? e.time = e.duration * e.rate : (e.time = Math.max(0, n) % e.duration, e.time *= e.rate);
  }
}
function W8(r) {
  return typeof window < "u" && window.requestAnimationFrame ? window.requestAnimationFrame(r) : setTimeout(r, 1e3 / 60);
}
function X8(r) {
  return typeof window < "u" && window.cancelAnimationFrame ? window.cancelAnimationFrame(r) : clearTimeout(r);
}
let Z8 = 0;
const Y8 = {
  device: null,
  onAddHTML: () => "",
  onInitialize: async () => null,
  onRender: () => {
  },
  onFinalize: () => {
  },
  onError: (r) => console.error(r),
  // eslint-disable-line no-console
  stats: j1.stats.get(`animation-loop-${Z8++}`),
  // view parameters
  useDevicePixels: !0,
  autoResizeViewport: !1,
  autoResizeDrawingBuffer: !1
};
class K8 {
  // _gpuTimeQuery: Query | null = null;
  /*
   * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context
   */
  constructor(e) {
    H(this, "device", null);
    H(this, "canvas", null);
    H(this, "props");
    H(this, "animationProps", null);
    H(this, "timeline", null);
    H(this, "stats");
    H(this, "cpuTime");
    H(this, "gpuTime");
    H(this, "frameRate");
    H(this, "display");
    H(this, "needsRedraw", "initialized");
    H(this, "_initialized", !1);
    H(this, "_running", !1);
    H(this, "_animationFrameId", null);
    H(this, "_nextFramePromise", null);
    H(this, "_resolveNextFrame", null);
    H(this, "_cpuStartTime", 0);
    H(this, "_error", null);
    if (this.props = {
      ...Y8,
      ...e
    }, e = this.props, !e.device)
      throw new Error("No device provided");
    const {
      useDevicePixels: t = !0
    } = this.props;
    this.stats = e.stats || new mp({
      id: "animation-loop-stats"
    }), this.cpuTime = this.stats.get("CPU Time"), this.gpuTime = this.stats.get("GPU Time"), this.frameRate = this.stats.get("Frame Rate"), this.setProps({
      autoResizeViewport: e.autoResizeViewport,
      autoResizeDrawingBuffer: e.autoResizeDrawingBuffer,
      useDevicePixels: t
    }), this.start = this.start.bind(this), this.stop = this.stop.bind(this), this._onMousemove = this._onMousemove.bind(this), this._onMouseleave = this._onMouseleave.bind(this);
  }
  destroy() {
    this.stop(), this._setDisplay(null);
  }
  /** @deprecated Use .destroy() */
  delete() {
    this.destroy();
  }
  setError(e) {
    var n, i;
    if (this.props.onError(e), this._error = Error(), ((i = (n = this.device) == null ? void 0 : n.canvasContext) == null ? void 0 : i.canvas) instanceof HTMLCanvasElement) {
      const s = document.createElement("h1");
      s.innerHTML = e.message, s.style.position = "absolute", s.style.top = "20%", s.style.left = "10px", s.style.color = "black", s.style.backgroundColor = "red", document.body.appendChild(s);
    }
  }
  /** Flags this animation loop as needing redraw */
  setNeedsRedraw(e) {
    return this.needsRedraw = this.needsRedraw || e, this;
  }
  /** TODO - move these props to CanvasContext? */
  setProps(e) {
    return "autoResizeViewport" in e && (this.props.autoResizeViewport = e.autoResizeViewport || !1), "autoResizeDrawingBuffer" in e && (this.props.autoResizeDrawingBuffer = e.autoResizeDrawingBuffer || !1), "useDevicePixels" in e && (this.props.useDevicePixels = e.useDevicePixels || !1), this;
  }
  /** Starts a render loop if not already running */
  async start() {
    if (this._running)
      return this;
    this._running = !0;
    try {
      let e;
      return this._initialized || (this._initialized = !0, await this._initDevice(), this._initialize(), await this.props.onInitialize(this._getAnimationProps())), this._running ? (e !== !1 && (this._cancelAnimationFrame(), this._requestAnimationFrame()), this) : null;
    } catch (e) {
      const t = e instanceof Error ? e : new Error("Unknown error");
      throw this.props.onError(t), t;
    }
  }
  /** Stops a render loop if already running, finalizing */
  stop() {
    return this._running && (this.animationProps && !this._error && this.props.onFinalize(this.animationProps), this._cancelAnimationFrame(), this._nextFramePromise = null, this._resolveNextFrame = null, this._running = !1), this;
  }
  /** Explicitly draw a frame */
  redraw() {
    var e;
    return (e = this.device) != null && e.isLost || this._error ? this : (this._beginFrameTimers(), this._setupFrame(), this._updateAnimationProps(), this._renderFrame(this._getAnimationProps()), this._clearNeedsRedraw(), this._resolveNextFrame && (this._resolveNextFrame(this), this._nextFramePromise = null, this._resolveNextFrame = null), this._endFrameTimers(), this);
  }
  /** Add a timeline, it will be automatically updated by the animation loop. */
  attachTimeline(e) {
    return this.timeline = e, this.timeline;
  }
  /** Remove a timeline */
  detachTimeline() {
    this.timeline = null;
  }
  /** Wait until a render completes */
  waitForRender() {
    return this.setNeedsRedraw("waitForRender"), this._nextFramePromise || (this._nextFramePromise = new Promise((e) => {
      this._resolveNextFrame = e;
    })), this._nextFramePromise;
  }
  /** TODO - should use device.deviceContext */
  async toDataURL() {
    if (this.setNeedsRedraw("toDataURL"), await this.waitForRender(), this.canvas instanceof HTMLCanvasElement)
      return this.canvas.toDataURL();
    throw new Error("OffscreenCanvas");
  }
  // PRIVATE METHODS
  _initialize() {
    this._startEventHandling(), this._initializeAnimationProps(), this._updateAnimationProps(), this._resizeCanvasDrawingBuffer(), this._resizeViewport();
  }
  _setDisplay(e) {
    this.display && (this.display.destroy(), this.display.animationLoop = null), e && (e.animationLoop = this), this.display = e;
  }
  _requestAnimationFrame() {
    this._running && (this._animationFrameId = W8(this._animationFrame.bind(this)));
  }
  _cancelAnimationFrame() {
    this._animationFrameId !== null && (X8(this._animationFrameId), this._animationFrameId = null);
  }
  _animationFrame() {
    this._running && (this.redraw(), this._requestAnimationFrame());
  }
  // Called on each frame, can be overridden to call onRender multiple times
  // to support e.g. stereoscopic rendering
  _renderFrame(e) {
    var t;
    if (this.display) {
      this.display._renderFrame(e);
      return;
    }
    this.props.onRender(this._getAnimationProps()), (t = this.device) == null || t.submit();
  }
  _clearNeedsRedraw() {
    this.needsRedraw = !1;
  }
  _setupFrame() {
    this._resizeCanvasDrawingBuffer(), this._resizeViewport();
  }
  // Initialize the  object that will be passed to app callbacks
  _initializeAnimationProps() {
    var t, n;
    const e = (n = (t = this.device) == null ? void 0 : t.canvasContext) == null ? void 0 : n.canvas;
    if (!this.device || !e)
      throw new Error("loop");
    this.animationProps = {
      animationLoop: this,
      device: this.device,
      canvas: e,
      timeline: this.timeline,
      // Initial values
      useDevicePixels: this.props.useDevicePixels,
      needsRedraw: !1,
      // Placeholders
      width: 1,
      height: 1,
      aspect: 1,
      // Animation props
      time: 0,
      startTime: Date.now(),
      engineTime: 0,
      tick: 0,
      tock: 0,
      // Experimental
      _mousePosition: null
      // Event props
    };
  }
  _getAnimationProps() {
    if (!this.animationProps)
      throw new Error("animationProps");
    return this.animationProps;
  }
  // Update the context object that will be passed to app callbacks
  _updateAnimationProps() {
    if (!this.animationProps)
      return;
    const {
      width: e,
      height: t,
      aspect: n
    } = this._getSizeAndAspect();
    (e !== this.animationProps.width || t !== this.animationProps.height) && this.setNeedsRedraw("drawing buffer resized"), n !== this.animationProps.aspect && this.setNeedsRedraw("drawing buffer aspect changed"), this.animationProps.width = e, this.animationProps.height = t, this.animationProps.aspect = n, this.animationProps.needsRedraw = this.needsRedraw, this.animationProps.engineTime = Date.now() - this.animationProps.startTime, this.timeline && this.timeline.update(this.animationProps.engineTime), this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60), this.animationProps.tock++, this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
  }
  /** Wait for supplied device */
  async _initDevice() {
    var e;
    if (this.device = await this.props.device, !this.device)
      throw new Error("No device provided");
    this.canvas = ((e = this.device.canvasContext) == null ? void 0 : e.canvas) || null;
  }
  _createInfoDiv() {
    if (this.canvas && this.props.onAddHTML) {
      const e = document.createElement("div");
      document.body.appendChild(e), e.style.position = "relative";
      const t = document.createElement("div");
      t.style.position = "absolute", t.style.left = "10px", t.style.bottom = "10px", t.style.width = "300px", t.style.background = "white", this.canvas instanceof HTMLCanvasElement && e.appendChild(this.canvas), e.appendChild(t);
      const n = this.props.onAddHTML(t);
      n && (t.innerHTML = n);
    }
  }
  _getSizeAndAspect() {
    var s, l, o, d;
    if (!this.device)
      return {
        width: 1,
        height: 1,
        aspect: 1
      };
    const [e, t] = ((l = (s = this.device) == null ? void 0 : s.canvasContext) == null ? void 0 : l.getPixelSize()) || [1, 1];
    let n = 1;
    const i = (d = (o = this.device) == null ? void 0 : o.canvasContext) == null ? void 0 : d.canvas;
    return i && i.clientHeight ? n = i.clientWidth / i.clientHeight : e > 0 && t > 0 && (n = e / t), {
      width: e,
      height: t,
      aspect: n
    };
  }
  /** Default viewport setup */
  _resizeViewport() {
    this.props.autoResizeViewport && this.device.gl && this.device.gl.viewport(
      0,
      0,
      // @ts-expect-error Expose canvasContext
      this.device.gl.drawingBufferWidth,
      // @ts-expect-error Expose canvasContext
      this.device.gl.drawingBufferHeight
    );
  }
  /**
   * Resize the render buffer of the canvas to match canvas client size
   * Optionally multiplying with devicePixel ratio
   */
  _resizeCanvasDrawingBuffer() {
    var e, t;
    this.props.autoResizeDrawingBuffer && ((t = (e = this.device) == null ? void 0 : e.canvasContext) == null || t.resize({
      useDevicePixels: this.props.useDevicePixels
    }));
  }
  _beginFrameTimers() {
    this.frameRate.timeEnd(), this.frameRate.timeStart(), this.cpuTime.timeStart();
  }
  _endFrameTimers() {
    this.cpuTime.timeEnd();
  }
  // Event handling
  _startEventHandling() {
    this.canvas && (this.canvas.addEventListener("mousemove", this._onMousemove.bind(this)), this.canvas.addEventListener("mouseleave", this._onMouseleave.bind(this)));
  }
  _onMousemove(e) {
    e instanceof MouseEvent && (this._getAnimationProps()._mousePosition = [e.offsetX, e.offsetY]);
  }
  _onMouseleave(e) {
    this._getAnimationProps()._mousePosition = null;
  }
}
const Eb = {};
function Kg() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "id";
  Eb[r] = Eb[r] || 1;
  const e = Eb[r]++;
  return `${r}-${e}`;
}
class YT {
  constructor(e) {
    H(this, "id");
    H(this, "userData", {});
    /** Determines how vertices are read from the 'vertex' attributes */
    H(this, "topology");
    H(this, "bufferLayout", []);
    H(this, "vertexCount");
    H(this, "indices");
    H(this, "attributes");
    if (this.id = e.id || Kg("geometry"), this.topology = e.topology, this.indices = e.indices || null, this.attributes = e.attributes, this.vertexCount = e.vertexCount, this.bufferLayout = e.bufferLayout || [], this.indices && !(this.indices.usage & gs.INDEX))
      throw new Error("Index buffer must have INDEX usage");
  }
  destroy() {
    var e;
    (e = this.indices) == null || e.destroy();
    for (const t of Object.values(this.attributes))
      t.destroy();
  }
  getVertexCount() {
    return this.vertexCount;
  }
  getAttributes() {
    return this.attributes;
  }
  getIndexes() {
    return this.indices || null;
  }
  _calculateVertexCount(e) {
    return e.byteLength / 12;
  }
}
function J8(r, e) {
  if (e instanceof YT)
    return e;
  const t = Q8(r, e), {
    attributes: n,
    bufferLayout: i
  } = eU(r, e);
  return new YT({
    topology: e.topology || "triangle-list",
    bufferLayout: i,
    vertexCount: e.vertexCount,
    indices: t,
    attributes: n
  });
}
function Q8(r, e) {
  if (!e.indices)
    return;
  const t = e.indices.value;
  return r.createBuffer({
    usage: gs.INDEX,
    data: t
  });
}
function eU(r, e) {
  const t = [], n = {};
  for (const [s, l] of Object.entries(e.attributes)) {
    let o = s;
    switch (s) {
      case "POSITION":
        o = "positions";
        break;
      case "NORMAL":
        o = "normals";
        break;
      case "TEXCOORD_0":
        o = "texCoords";
        break;
      case "COLOR_0":
        o = "colors";
        break;
    }
    if (l) {
      n[o] = r.createBuffer({
        data: l.value,
        id: `${s}-buffer`
      });
      const {
        value: d,
        size: m,
        normalized: b
      } = l;
      t.push({
        name: o,
        format: ak(d, m, b)
      });
    }
  }
  const i = e._calculateVertexCount(e.attributes, e.indices);
  return {
    attributes: n,
    bufferLayout: t,
    vertexCount: i
  };
}
const My = class My {
  constructor(e) {
    H(this, "device");
    H(this, "destroyPolicy");
    H(this, "_hashCounter", 0);
    H(this, "_hashes", {});
    H(this, "_renderPipelineCache", {});
    H(this, "_computePipelineCache", {});
    this.device = e, this.destroyPolicy = e.props._factoryDestroyPolicy;
  }
  /** Get the singleton default pipeline factory for the specified device */
  static getDefaultPipelineFactory(e) {
    return e._lumaData.defaultPipelineFactory = e._lumaData.defaultPipelineFactory || new My(e), e._lumaData.defaultPipelineFactory;
  }
  /** Return a RenderPipeline matching props. Reuses a similar pipeline if already created. */
  createRenderPipeline(e) {
    const t = {
      ...np.defaultProps,
      ...e
    }, n = this._hashRenderPipeline(t);
    if (!this._renderPipelineCache[n]) {
      const i = this.device.createRenderPipeline({
        ...t,
        id: t.id ? `${t.id}-cached` : void 0
      });
      i.hash = n, this._renderPipelineCache[n] = {
        pipeline: i,
        useCount: 0
      };
    }
    return this._renderPipelineCache[n].useCount++, this._renderPipelineCache[n].pipeline;
  }
  createComputePipeline(e) {
    const t = {
      ...q_.defaultProps,
      ...e
    }, n = this._hashComputePipeline(t);
    if (!this._computePipelineCache[n]) {
      const i = this.device.createComputePipeline({
        ...t,
        id: t.id ? `${t.id}-cached` : void 0
      });
      i.hash = n, this._computePipelineCache[n] = {
        pipeline: i,
        useCount: 0
      };
    }
    return this._computePipelineCache[n].useCount++, this._computePipelineCache[n].pipeline;
  }
  release(e) {
    const t = e.hash, n = e instanceof q_ ? this._computePipelineCache : this._renderPipelineCache;
    n[t].useCount--, n[t].useCount === 0 && this.destroyPolicy === "unused" && (n[t].pipeline.destroy(), delete n[t]);
  }
  // PRIVATE
  _hashComputePipeline(e) {
    return `${this._getHash(e.shader.source)}`;
  }
  /** Calculate a hash based on all the inputs for a render pipeline */
  _hashRenderPipeline(e) {
    const t = e.vs ? this._getHash(e.vs.source) : 0, n = e.fs ? this._getHash(e.fs.source) : 0, i = "-", s = this._getHash(JSON.stringify(e.bufferLayout));
    switch (this.device.type) {
      case "webgl":
        return `${t}/${n}V${i}BL${s}`;
      default:
        const l = this._getHash(JSON.stringify(e.parameters));
        return `${t}/${n}V${i}T${e.topology}P${l}BL${s}`;
    }
  }
  _getHash(e) {
    return this._hashes[e] === void 0 && (this._hashes[e] = this._hashCounter++), this._hashes[e];
  }
};
H(My, "defaultProps", {
  ...np.defaultProps
});
let cv = My;
const Py = class Py {
  /** @internal */
  constructor(e) {
    H(this, "device");
    H(this, "destroyPolicy");
    H(this, "_cache", {});
    this.device = e, this.destroyPolicy = e.props._factoryDestroyPolicy;
  }
  /** Returns the default ShaderFactory for the given {@link Device}, creating one if necessary. */
  static getDefaultShaderFactory(e) {
    var t;
    return (t = e._lumaData).defaultShaderFactory || (t.defaultShaderFactory = new Py(e)), e._lumaData.defaultShaderFactory;
  }
  /** Requests a {@link Shader} from the cache, creating a new Shader only if necessary. */
  createShader(e) {
    const t = this._hashShader(e);
    let n = this._cache[t];
    if (!n) {
      const i = this.device.createShader({
        ...e,
        id: e.id ? `${e.id}-cached` : void 0
      });
      this._cache[t] = n = {
        shader: i,
        useCount: 0
      };
    }
    return n.useCount++, n.shader;
  }
  /** Releases a previously-requested {@link Shader}, destroying it if no users remain. */
  release(e) {
    const t = this._hashShader(e), n = this._cache[t];
    n && (n.useCount--, n.useCount === 0 && this.destroyPolicy === "unused" && (delete this._cache[t], n.shader.destroy()));
  }
  // PRIVATE
  _hashShader(e) {
    return `${e.stage}:${e.source}`;
  }
};
H(Py, "defaultProps", {
  ...j_.defaultProps
});
let uv = Py;
function tU(r, e) {
  var i;
  const t = {}, n = "Values";
  if (r.attributes.length === 0 && !((i = r.varyings) != null && i.length))
    return {
      "No attributes or varyings": {
        [n]: "N/A"
      }
    };
  for (const s of r.attributes)
    if (s) {
      const l = `${s.location} ${s.name}: ${s.type}`;
      t[`in ${l}`] = {
        [n]: s.stepMode || "vertex"
      };
    }
  for (const s of r.varyings || []) {
    const l = `${s.location} ${s.name}`;
    t[`out ${l}`] = {
      [n]: JSON.stringify(s)
    };
  }
  return t;
}
let go = null, _f = null;
function rU(r, e) {
  let {
    id: t,
    opaque: n,
    top: i = "0",
    left: s = "0",
    rgbaScale: l = 1
  } = e;
  go || (go = document.createElement("canvas"), go.id = t, go.title = t, go.style.zIndex = "100", go.style.position = "absolute", go.style.top = i, go.style.left = s, go.style.border = "blue 5px solid", go.style.transform = "scaleY(-1)", document.body.appendChild(go), _f = go.getContext("2d")), (go.width !== r.width || go.height !== r.height) && (go.width = r.width / 2, go.height = r.height / 2, go.style.width = "400px", go.style.height = "400px");
  const o = r.device.readPixelsToArrayWebGL(r), d = _f == null ? void 0 : _f.createImageData(r.width, r.height);
  if (d) {
    for (let b = 0; b < o.length; b += 4)
      d.data[0 + b + 0] = o[b + 0] * l, d.data[0 + b + 1] = o[b + 1] * l, d.data[0 + b + 2] = o[b + 2] * l, d.data[0 + b + 3] = n ? 255 : o[b + 3] * l;
    _f == null || _f.putImageData(d, 0, 0);
  }
}
function hv(r, e, t) {
  if (r === e)
    return !0;
  if (!t || !r || !e)
    return !1;
  if (Array.isArray(r)) {
    if (!Array.isArray(e) || r.length !== e.length)
      return !1;
    for (let n = 0; n < r.length; n++)
      if (!hv(r[n], e[n], t - 1))
        return !1;
    return !0;
  }
  if (Array.isArray(e))
    return !1;
  if (typeof r == "object" && typeof e == "object") {
    const n = Object.keys(r), i = Object.keys(e);
    if (n.length !== i.length)
      return !1;
    for (const s of n)
      if (!e.hasOwnProperty(s) || !hv(r[s], e[s], t - 1))
        return !1;
    return !0;
  }
  return !1;
}
function nU(r) {
  return ArrayBuffer.isView(r) && !(r instanceof DataView);
}
function iU(r) {
  return Array.isArray(r) ? r.length === 0 || typeof r[0] == "number" : !1;
}
function V5(r) {
  return nU(r) || iU(r);
}
function sU(r) {
  return V5(r) || typeof r == "number" || typeof r == "boolean";
}
function $5(r) {
  const e = {
    bindings: {},
    uniforms: {}
  };
  return Object.keys(r).forEach((t) => {
    const n = r[t];
    sU(n) ? e.uniforms[t] = n : e.bindings[t] = n;
  }), e;
}
class oU {
  /** Tracks if uniforms have changed */
  // moduleUniformsChanged: Record<keyof ShaderPropsT, false | string>;
  /**
   * Create a new UniformStore instance
   * @param modules
   */
  constructor(e, t) {
    H(this, "options", {
      disableWarnings: !1
    });
    /**
     * The map of modules
     * @todo should should this include the resolved dependencies?
     */
    // @ts-ignore Fix typings
    H(this, "modules");
    /** Stores the uniform values for each module */
    H(this, "moduleUniforms");
    /** Stores the uniform bindings for each module  */
    H(this, "moduleBindings");
    Object.assign(this.options, t);
    const n = y2(Object.values(e).filter((i) => i.dependencies));
    for (const i of n)
      e[i.name] = i;
    cr.log(1, "Creating ShaderInputs with modules", Object.keys(e))(), this.modules = e, this.moduleUniforms = {}, this.moduleBindings = {};
    for (const [i, s] of Object.entries(e))
      this._addModule(s), s.name && i !== s.name && !this.options.disableWarnings && cr.warn(`Module name: ${i} vs ${s.name}`)();
  }
  /** Destroy */
  destroy() {
  }
  /**
   * Set module props
   */
  setProps(e) {
    var t;
    for (const n of Object.keys(e)) {
      const i = n, s = e[i] || {}, l = this.modules[i];
      if (!l) {
        this.options.disableWarnings || cr.warn(`Module ${n} not found`)();
        continue;
      }
      const o = this.moduleUniforms[i], d = this.moduleBindings[i], m = ((t = l.getUniforms) == null ? void 0 : t.call(l, s, o)) || s, {
        uniforms: b,
        bindings: A
      } = $5(m);
      this.moduleUniforms[i] = {
        ...o,
        ...b
      }, this.moduleBindings[i] = {
        ...d,
        ...A
      };
    }
  }
  /**
   * Return the map of modules
   * @todo should should this include the resolved dependencies?
   */
  getModules() {
    return Object.values(this.modules);
  }
  /** Get all uniform values for all modules */
  getUniformValues() {
    return this.moduleUniforms;
  }
  /** Merges all bindings for the shader (from the various modules) */
  getBindingValues() {
    const e = {};
    for (const t of Object.values(this.moduleBindings))
      Object.assign(e, t);
    return e;
  }
  // INTERNAL
  /** Return a debug table that can be used for console.table() or log.table() */
  getDebugTable() {
    var t;
    const e = {};
    for (const [n, i] of Object.entries(this.moduleUniforms))
      for (const [s, l] of Object.entries(i))
        e[`${n}.${s}`] = {
          type: (t = this.modules[n].uniformTypes) == null ? void 0 : t[s],
          value: String(l)
        };
    return e;
  }
  _addModule(e) {
    const t = e.name;
    this.moduleUniforms[t] = e.defaultUniforms || {}, this.moduleBindings[t] = {};
  }
}
let aU = "";
async function lU(r, e) {
  const t = new Image();
  return t.crossOrigin = "anonymous", t.src = r.startsWith("http") ? r : aU + r, await t.decode(), e ? await createImageBitmap(t, e) : await createImageBitmap(t);
}
class Cb {
  constructor(e, t) {
    H(this, "device");
    H(this, "id");
    // TODO - should we type these as possibly `null`? It will make usage harder?
    // @ts-expect-error
    H(this, "texture");
    // @ts-expect-error
    H(this, "sampler");
    // @ts-expect-error
    H(this, "view");
    H(this, "ready");
    H(this, "isReady", !1);
    H(this, "destroyed", !1);
    H(this, "resolveReady", () => {
    });
    H(this, "rejectReady", () => {
    });
    this.device = e, this.id = t.id || Kg("async-texture"), typeof (t == null ? void 0 : t.data) == "string" && t.dimension === "2d" && (t = {
      ...t,
      data: lU(t.data)
    }), this.ready = new Promise((n, i) => {
      this.resolveReady = () => {
        this.isReady = !0, n();
      }, this.rejectReady = i;
    }), this.initAsync(t);
  }
  get [Symbol.toStringTag]() {
    return "AsyncTexture";
  }
  toString() {
    return `AsyncTexture:"${this.id}"(${this.isReady ? "ready" : "loading"})`;
  }
  async initAsync(e) {
    const t = e.data;
    let n;
    try {
      n = await q5(t);
    } catch (s) {
      this.rejectReady(s);
    }
    if (this.destroyed)
      return;
    const i = {
      ...e,
      data: n
    };
    this.texture = this.device.createTexture(i), this.sampler = this.texture.sampler, this.view = this.texture.view, this.isReady = !0, this.resolveReady();
  }
  destroy() {
    this.texture && (this.texture.destroy(), this.texture = null), this.destroyed = !0;
  }
  /**
   * Textures are immutable and cannot be resized after creation,
   * but we can create a similar texture with the same parameters but a new size.
   * @note Does not copy contents of the texture
   * @todo Abort pending promise and create a texture with the new size?
   */
  resize(e) {
    if (!this.isReady)
      throw new Error("Cannot resize texture before it is ready");
    if (e.width === this.texture.width && e.height === this.texture.height)
      return !1;
    if (this.texture) {
      const t = this.texture;
      this.texture = t.clone(e), t.destroy();
    }
    return !0;
  }
}
async function q5(r) {
  if (r = await r, Array.isArray(r))
    return await Promise.all(r.map(q5));
  if (r && typeof r == "object" && r.constructor === Object) {
    const e = r, t = await Promise.all(Object.values(e)), n = Object.keys(e), i = {};
    for (let s = 0; s < n.length; s++)
      i[n[s]] = t[s];
    return i;
  }
  return r;
}
const yf = 2, cU = 1e4, Ry = class Ry {
  constructor(e, t) {
    H(this, "device");
    H(this, "id");
    // @ts-expect-error assigned in function called from constructor
    H(this, "source");
    // @ts-expect-error assigned in function called from constructor
    H(this, "vs");
    // @ts-expect-error assigned in function called from constructor
    H(this, "fs");
    H(this, "pipelineFactory");
    H(this, "shaderFactory");
    H(this, "userData", {});
    // Fixed properties (change can trigger pipeline rebuild)
    /** The render pipeline GPU parameters, depth testing etc */
    H(this, "parameters");
    /** The primitive topology */
    H(this, "topology");
    /** Buffer layout */
    H(this, "bufferLayout");
    // Dynamic properties
    /** Use instanced rendering */
    H(this, "isInstanced", void 0);
    /** instance count. `undefined` means not instanced */
    H(this, "instanceCount", 0);
    /** Vertex count */
    H(this, "vertexCount");
    /** Index buffer */
    H(this, "indexBuffer", null);
    /** Buffer-valued attributes */
    H(this, "bufferAttributes", {});
    /** Constant-valued attributes */
    H(this, "constantAttributes", {});
    /** Bindings (textures, samplers, uniform buffers) */
    H(this, "bindings", {});
    /** Sets uniforms @deprecated Use uniform buffers and setBindings() for portability*/
    H(this, "uniforms", {});
    /**
     * VertexArray
     * @note not implemented: if bufferLayout is updated, vertex array has to be rebuilt!
     * @todo - allow application to define multiple vertex arrays?
     * */
    H(this, "vertexArray");
    /** TransformFeedback, WebGL 2 only. */
    H(this, "transformFeedback", null);
    /** The underlying GPU "program". @note May be recreated if parameters change */
    H(this, "pipeline");
    /** ShaderInputs instance */
    // @ts-expect-error Assigned in function called by constructor
    H(this, "shaderInputs");
    // @ts-expect-error Assigned in function called by constructor
    H(this, "_uniformStore");
    H(this, "_attributeInfos", {});
    H(this, "_gpuGeometry", null);
    H(this, "_getModuleUniforms");
    H(this, "props");
    H(this, "_pipelineNeedsUpdate", "newly created");
    H(this, "_needsRedraw", "initializing");
    H(this, "_destroyed", !1);
    /** "Time" of last draw. Monotonically increasing timestamp */
    H(this, "_lastDrawTimestamp", -1);
    /** Throttle draw call logging */
    H(this, "_lastLogTime", 0);
    H(this, "_logOpen", !1);
    H(this, "_drawCount", 0);
    var d, m, b, A;
    this.props = {
      ...Ry.defaultProps,
      ...t
    }, t = this.props, this.id = t.id || Kg("model"), this.device = e, Object.assign(this.userData, t.userData);
    const n = Object.fromEntries(((d = this.props.modules) == null ? void 0 : d.map((M) => [M.name, M])) || []), i = t.shaderInputs || new oU(n, {
      disableWarnings: this.props.disableWarnings
    });
    this.setShaderInputs(i);
    const s = hU(e), l = (
      // @ts-ignore shaderInputs is assigned in setShaderInputs above.
      (((m = this.props.modules) == null ? void 0 : m.length) > 0 ? this.props.modules : (b = this.shaderInputs) == null ? void 0 : b.getModules()) || []
    );
    if (this.device.type === "webgpu" && this.props.source) {
      const {
        source: M,
        getUniforms: E
      } = this.props.shaderAssembler.assembleWGSLShader({
        platformInfo: s,
        ...this.props,
        modules: l
      });
      this.source = M, this._getModuleUniforms = E, (A = this.props).shaderLayout || (A.shaderLayout = Dk(this.source));
    } else {
      const {
        vs: M,
        fs: E,
        getUniforms: k
      } = this.props.shaderAssembler.assembleGLSLShaderPair({
        platformInfo: s,
        ...this.props,
        modules: l
      });
      this.vs = M, this.fs = E, this._getModuleUniforms = k;
    }
    this.vertexCount = this.props.vertexCount, this.instanceCount = this.props.instanceCount, this.topology = this.props.topology, this.bufferLayout = this.props.bufferLayout, this.parameters = this.props.parameters, t.geometry && this.setGeometry(t.geometry), this.pipelineFactory = t.pipelineFactory || cv.getDefaultPipelineFactory(this.device), this.shaderFactory = t.shaderFactory || uv.getDefaultShaderFactory(this.device), this.pipeline = this._updatePipeline(), this.vertexArray = e.createVertexArray({
      renderPipeline: this.pipeline
    }), this._gpuGeometry && this._setGeometryAttributes(this._gpuGeometry), "isInstanced" in t && (this.isInstanced = t.isInstanced), t.instanceCount && this.setInstanceCount(t.instanceCount), t.vertexCount && this.setVertexCount(t.vertexCount), t.indexBuffer && this.setIndexBuffer(t.indexBuffer), t.attributes && this.setAttributes(t.attributes), t.constantAttributes && this.setConstantAttributes(t.constantAttributes), t.bindings && this.setBindings(t.bindings), t.uniforms && this.setUniformsWebGL(t.uniforms), t.moduleSettings && this.updateModuleSettingsWebGL(t.moduleSettings), t.transformFeedback && (this.transformFeedback = t.transformFeedback), Object.seal(this);
  }
  get [Symbol.toStringTag]() {
    return "Model";
  }
  toString() {
    return `Model(${this.id})`;
  }
  destroy() {
    var e;
    this._destroyed || (this.pipelineFactory.release(this.pipeline), this.shaderFactory.release(this.pipeline.vs), this.pipeline.fs && this.shaderFactory.release(this.pipeline.fs), this._uniformStore.destroy(), (e = this._gpuGeometry) == null || e.destroy(), this._destroyed = !0);
  }
  // Draw call
  /** Query redraw status. Clears the status. */
  needsRedraw() {
    this._getBindingsUpdateTimestamp() > this._lastDrawTimestamp && this.setNeedsRedraw("contents of bound textures or buffers updated");
    const e = this._needsRedraw;
    return this._needsRedraw = !1, e;
  }
  /** Mark the model as needing a redraw */
  setNeedsRedraw(e) {
    this._needsRedraw || (this._needsRedraw = e);
  }
  predraw() {
    this.updateShaderInputs(), this.pipeline = this._updatePipeline();
  }
  draw(e) {
    const t = this._areBindingsLoading();
    if (t)
      return cr.info(yf, `>>> DRAWING ABORTED ${this.id}: ${t} not loaded`)(), !1;
    try {
      e.pushDebugGroup(`${this}.predraw(${e})`), this.predraw();
    } finally {
      e.popDebugGroup();
    }
    let n;
    try {
      e.pushDebugGroup(`${this}.draw(${e})`), this._logDrawCallStart(), this.pipeline = this._updatePipeline();
      const i = this._getBindings();
      this.pipeline.setBindings(i, {
        disableWarnings: this.props.disableWarnings
      }), fv(this.uniforms) || this.pipeline.setUniformsWebGL(this.uniforms);
      const {
        indexBuffer: s
      } = this.vertexArray, l = s ? s.byteLength / (s.indexType === "uint32" ? 4 : 2) : void 0;
      n = this.pipeline.draw({
        renderPass: e,
        vertexArray: this.vertexArray,
        isInstanced: this.isInstanced,
        vertexCount: this.vertexCount,
        instanceCount: this.instanceCount,
        indexCount: l,
        transformFeedback: this.transformFeedback || void 0,
        // WebGL shares underlying cached pipelines even for models that have different parameters and topology,
        // so we must provide our unique parameters to each draw
        // (In WebGPU most parameters are encoded in the pipeline and cannot be changed per draw call)
        parameters: this.parameters,
        topology: this.topology
      });
    } finally {
      e.popDebugGroup(), this._logDrawCallEnd();
    }
    return this._logFramebuffer(e), n ? (this._lastDrawTimestamp = this.device.timestamp, this._needsRedraw = !1) : this._needsRedraw = "waiting for resource initialization", n;
  }
  // Update fixed fields (can trigger pipeline rebuild)
  /**
   * Updates the optional geometry
   * Geometry, set topology and bufferLayout
   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  setGeometry(e) {
    var n;
    (n = this._gpuGeometry) == null || n.destroy();
    const t = e && J8(this.device, e);
    if (t) {
      this.setTopology(t.topology || "triangle-list");
      const i = new pb(this.bufferLayout);
      this.bufferLayout = i.mergeBufferLayouts(t.bufferLayout, this.bufferLayout), this.vertexArray && this._setGeometryAttributes(t);
    }
    this._gpuGeometry = t;
  }
  /**
   * Updates the primitive topology ('triangle-list', 'triangle-strip' etc).
   * @note Triggers a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  setTopology(e) {
    e !== this.topology && (this.topology = e, this._setPipelineNeedsUpdate("topology"));
  }
  /**
   * Updates the buffer layout.
   * @note Triggers a pipeline rebuild / pipeline cache fetch
   */
  setBufferLayout(e) {
    const t = new pb(this.bufferLayout);
    this.bufferLayout = this._gpuGeometry ? t.mergeBufferLayouts(e, this._gpuGeometry.bufferLayout) : e, this._setPipelineNeedsUpdate("bufferLayout"), this.pipeline = this._updatePipeline(), this.vertexArray = this.device.createVertexArray({
      renderPipeline: this.pipeline
    }), this._gpuGeometry && this._setGeometryAttributes(this._gpuGeometry);
  }
  /**
   * Set GPU parameters.
   * @note Can trigger a pipeline rebuild / pipeline cache fetch.
   * @param parameters
   */
  setParameters(e) {
    hv(e, this.parameters, 2) || (this.parameters = e, this._setPipelineNeedsUpdate("parameters"));
  }
  // Update dynamic fields
  /**
   * Updates the instance count (used in draw calls)
   * @note Any attributes with stepMode=instance need to be at least this big
   */
  setInstanceCount(e) {
    this.instanceCount = e, this.isInstanced === void 0 && e > 0 && (this.isInstanced = !0), this.setNeedsRedraw("instanceCount");
  }
  /**
   * Updates the vertex count (used in draw calls)
   * @note Any attributes with stepMode=vertex need to be at least this big
   */
  setVertexCount(e) {
    this.vertexCount = e, this.setNeedsRedraw("vertexCount");
  }
  /** Set the shader inputs */
  setShaderInputs(e) {
    this.shaderInputs = e, this._uniformStore = new ok(this.shaderInputs.modules);
    for (const [t, n] of Object.entries(this.shaderInputs.modules))
      if (uU(n)) {
        const i = this._uniformStore.getManagedUniformBuffer(this.device, t);
        this.bindings[`${t}Uniforms`] = i;
      }
    this.setNeedsRedraw("shaderInputs");
  }
  /** Update uniform buffers from the model's shader inputs */
  updateShaderInputs() {
    this._uniformStore.setUniforms(this.shaderInputs.getUniformValues()), this.setBindings(this.shaderInputs.getBindingValues()), this.setNeedsRedraw("shaderInputs");
  }
  /**
   * Sets bindings (textures, samplers, uniform buffers)
   */
  setBindings(e) {
    Object.assign(this.bindings, e), this.setNeedsRedraw("bindings");
  }
  /**
   * Updates optional transform feedback. WebGL only.
   */
  setTransformFeedback(e) {
    this.transformFeedback = e, this.setNeedsRedraw("transformFeedback");
  }
  /**
   * Sets the index buffer
   * @todo - how to unset it if we change geometry?
   */
  setIndexBuffer(e) {
    this.vertexArray.setIndexBuffer(e), this.setNeedsRedraw("indexBuffer");
  }
  /**
   * Sets attributes (buffers)
   * @note Overrides any attributes previously set with the same name
   */
  setAttributes(e, t) {
    const n = (t == null ? void 0 : t.disableWarnings) ?? this.props.disableWarnings;
    e.indices && cr.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)(), this.bufferLayout = lk(this.pipeline.shaderLayout, this.bufferLayout);
    const i = new pb(this.bufferLayout);
    for (const [s, l] of Object.entries(e)) {
      const o = i.getBufferLayout(s);
      if (!o) {
        n || cr.warn(`Model(${this.id}): Missing layout for buffer "${s}".`)();
        continue;
      }
      const d = i.getAttributeNamesForBuffer(o);
      let m = !1;
      for (const b of d) {
        const A = this._attributeInfos[b];
        if (A) {
          const M = this.device.type === "webgpu" ? i.getBufferIndex(A.bufferName) : A.location;
          this.vertexArray.setBuffer(M, l), m = !0;
        }
      }
      !m && !n && cr.warn(`Model(${this.id}): Ignoring buffer "${l.id}" for unknown attribute "${s}"`)();
    }
    this.setNeedsRedraw("attributes");
  }
  /**
   * Sets constant attributes
   * @note Overrides any attributes previously set with the same name
   * Constant attributes are only supported in WebGL, not in WebGPU
   * Any attribute that is disabled in the current vertex array object
   * is read from the context's global constant value for that attribute location.
   * @param constantAttributes
   */
  setConstantAttributes(e, t) {
    for (const [n, i] of Object.entries(e)) {
      const s = this._attributeInfos[n];
      s ? this.vertexArray.setConstantWebGL(s.location, i) : ((t == null ? void 0 : t.disableWarnings) ?? this.props.disableWarnings) || cr.warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${n}"`)();
    }
    this.setNeedsRedraw("constants");
  }
  // DEPRECATED METHODS
  /**
   * Sets individual uniforms
   * @deprecated WebGL only, use uniform buffers for portability
   * @param uniforms
   */
  setUniforms(e) {
    this.setUniformsWebGL(e);
  }
  /**
   * Sets individual uniforms
   * @deprecated WebGL only, use uniform buffers for portability
   * @param uniforms
   */
  setUniformsWebGL(e) {
    fv(e) || (this.pipeline.setUniformsWebGL(e), Object.assign(this.uniforms, e)), this.setNeedsRedraw("uniforms");
  }
  /**
   * @deprecated Updates shader module settings (which results in uniforms being set)
   */
  updateModuleSettingsWebGL(e) {
    const {
      bindings: t,
      uniforms: n
    } = $5(this._getModuleUniforms(e));
    Object.assign(this.bindings, t), Object.assign(this.uniforms, n), this.setNeedsRedraw("moduleSettings");
  }
  // Internal methods
  /** Check that bindings are loaded. Returns id of first binding that is still loading. */
  _areBindingsLoading() {
    for (const e of Object.values(this.bindings))
      if (e instanceof Cb && !e.isReady)
        return e.id;
    return !1;
  }
  /** Extracts texture view from loaded async textures. Returns null if any textures have not yet been loaded. */
  _getBindings() {
    const e = {};
    for (const [t, n] of Object.entries(this.bindings))
      n instanceof Cb ? n.isReady && (e[t] = n.texture) : e[t] = n;
    return e;
  }
  /** Get the timestamp of the latest updated bound GPU memory resource (buffer/texture). */
  _getBindingsUpdateTimestamp() {
    let e = 0;
    for (const t of Object.values(this.bindings))
      t instanceof z_ ? e = Math.max(e, t.texture.updateTimestamp) : t instanceof gs || t instanceof ts ? e = Math.max(e, t.updateTimestamp) : t instanceof Cb ? e = t.texture ? Math.max(e, t.texture.updateTimestamp) : (
        // The texture will become available in the future
        1 / 0
      ) : t instanceof V_ || (e = Math.max(e, t.buffer.updateTimestamp));
    return e;
  }
  /**
   * Updates the optional geometry attributes
   * Geometry, sets several attributes, indexBuffer, and also vertex count
   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  _setGeometryAttributes(e) {
    const t = {
      ...e.attributes
    };
    for (const [n] of Object.entries(t))
      !this.pipeline.shaderLayout.attributes.find((i) => i.name === n) && n !== "positions" && delete t[n];
    this.vertexCount = e.vertexCount, this.setIndexBuffer(e.indices || null), this.setAttributes(e.attributes, {
      disableWarnings: !0
    }), this.setAttributes(t, {
      disableWarnings: this.props.disableWarnings
    }), this.setNeedsRedraw("geometry attributes");
  }
  /** Mark pipeline as needing update */
  _setPipelineNeedsUpdate(e) {
    this._pipelineNeedsUpdate || (this._pipelineNeedsUpdate = e), this.setNeedsRedraw(e);
  }
  /** Update pipeline if needed */
  _updatePipeline() {
    if (this._pipelineNeedsUpdate) {
      let e = null, t = null;
      this.pipeline && (cr.log(1, `Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)(), e = this.pipeline.vs, t = this.pipeline.fs), this._pipelineNeedsUpdate = !1;
      const n = this.shaderFactory.createShader({
        id: `${this.id}-vertex`,
        stage: "vertex",
        source: this.source || this.vs,
        debugShaders: this.props.debugShaders
      });
      let i = null;
      this.source ? i = n : this.fs && (i = this.shaderFactory.createShader({
        id: `${this.id}-fragment`,
        stage: "fragment",
        source: this.source || this.fs,
        debugShaders: this.props.debugShaders
      })), this.pipeline = this.pipelineFactory.createRenderPipeline({
        ...this.props,
        bufferLayout: this.bufferLayout,
        topology: this.topology,
        parameters: this.parameters,
        // TODO - why set bindings here when we reset them every frame?
        // Should we expose a BindGroup abstraction?
        bindings: this._getBindings(),
        vs: n,
        fs: i
      }), this._attributeInfos = EC(this.pipeline.shaderLayout, this.bufferLayout), e && this.shaderFactory.release(e), t && this.shaderFactory.release(t);
    }
    return this.pipeline;
  }
  _logDrawCallStart() {
    const e = cr.level > 3 ? 0 : cU;
    cr.level < 2 || Date.now() - this._lastLogTime < e || (this._lastLogTime = Date.now(), this._logOpen = !0, cr.group(yf, `>>> DRAWING MODEL ${this.id}`, {
      collapsed: cr.level <= 2
    })());
  }
  _logDrawCallEnd() {
    if (this._logOpen) {
      const e = tU(this.pipeline.shaderLayout, this.id);
      cr.table(yf, e)();
      const t = this.shaderInputs.getDebugTable();
      for (const [i, s] of Object.entries(this.uniforms))
        t[i] = {
          value: s
        };
      cr.table(yf, t)();
      const n = this._getAttributeDebugTable();
      cr.table(yf, this._attributeInfos)(), cr.table(yf, n)(), cr.groupEnd(yf)(), this._logOpen = !1;
    }
  }
  _logFramebuffer(e) {
    const t = this.device.props.debugFramebuffers;
    if (this._drawCount++, !t)
      return;
    const n = e.props.framebuffer;
    n && rU(n, {
      id: n.id
    });
  }
  _getAttributeDebugTable() {
    const e = {};
    for (const [t, n] of Object.entries(this._attributeInfos)) {
      const i = this.vertexArray.attributes[n.location];
      e[n.location] = {
        name: t,
        type: n.shaderType,
        values: i ? this._getBufferOrConstantValues(i, n.bufferDataType) : "null"
      };
    }
    if (this.vertexArray.indexBuffer) {
      const {
        indexBuffer: t
      } = this.vertexArray, n = t.indexType === "uint32" ? new Uint32Array(t.debugData) : new Uint16Array(t.debugData);
      e.indices = {
        name: "indices",
        type: t.indexType,
        values: n.toString()
      };
    }
    return e;
  }
  // TODO - fix typing of luma data types
  _getBufferOrConstantValues(e, t) {
    const n = MC(t);
    return (e instanceof gs ? new n(e.debugData) : e).toString();
  }
};
H(Ry, "defaultProps", {
  ...np.defaultProps,
  source: void 0,
  vs: null,
  fs: null,
  id: "unnamed",
  handle: void 0,
  userData: {},
  defines: {},
  modules: [],
  moduleSettings: void 0,
  geometry: null,
  indexBuffer: null,
  attributes: {},
  constantAttributes: {},
  varyings: [],
  isInstanced: void 0,
  instanceCount: 0,
  vertexCount: 0,
  shaderInputs: void 0,
  pipelineFactory: void 0,
  shaderFactory: void 0,
  transformFeedback: void 0,
  shaderAssembler: U_.getDefaultShaderAssembler(),
  debugShaders: void 0,
  disableWarnings: void 0
});
let Xh = Ry;
function uU(r) {
  return !!(r.uniformTypes && !fv(r.uniformTypes));
}
function hU(r) {
  return {
    type: r.type,
    shaderLanguage: r.info.shadingLanguage,
    shaderLanguageVersion: r.info.shadingLanguageVersion,
    gpu: r.info.gpu,
    // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API
    features: r.features
  };
}
function fv(r) {
  for (const e in r)
    return !1;
  return !0;
}
const Ig = class Ig {
  constructor(e) {
    H(this, "device");
    H(this, "model");
    H(this, "transformFeedback");
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ig.defaultProps;
    if (!Ig.isSupported(e))
      throw new Error("BufferTransform not yet implemented on WebGPU");
    this.device = e, this.model = new Xh(this.device, {
      id: t.id || "buffer-transform-model",
      fs: t.fs || c6(),
      topology: t.topology || "point-list",
      varyings: t.outputs || t.varyings,
      ...t
    }), this.transformFeedback = this.device.createTransformFeedback({
      layout: this.model.pipeline.shaderLayout,
      // @ts-expect-error TODO
      buffers: t.feedbackBuffers
    }), this.model.setTransformFeedback(this.transformFeedback), Object.seal(this);
  }
  static isSupported(e) {
    var t;
    return ((t = e == null ? void 0 : e.info) == null ? void 0 : t.type) === "webgl";
  }
  /** Destroy owned resources. */
  destroy() {
    this.model && this.model.destroy();
  }
  /** @deprecated Use {@link destroy}. */
  delete() {
    this.destroy();
  }
  /** Run one transform loop. */
  run(e) {
    e != null && e.inputBuffers && this.model.setAttributes(e.inputBuffers), e != null && e.outputBuffers && this.transformFeedback.setBuffers(e.outputBuffers);
    const t = this.device.beginRenderPass(e);
    this.model.draw(t), t.end();
  }
  // DEPRECATED METHODS
  /** @deprecated App knows what buffers it is passing in - Returns the {@link Buffer} or {@link BufferRange} for given varying name. */
  getBuffer(e) {
    return this.transformFeedback.getBuffer(e);
  }
  /** @deprecated App knows what buffers it is passing in - Reads the {@link Buffer} or {@link BufferRange} for given varying name. */
  readAsync(e) {
    const t = this.getBuffer(e);
    if (!t)
      throw new Error("BufferTransform#getBuffer");
    if (t instanceof gs)
      return t.readAsync();
    const {
      buffer: n,
      byteOffset: i = 0,
      byteLength: s = n.byteLength
    } = t;
    return n.readAsync(i, s);
  }
};
H(Ig, "defaultProps", {
  ...Xh.defaultProps,
  outputs: void 0,
  feedbackBuffers: void 0
});
let Dg = Ig;
class Xd {
  constructor(e) {
    H(this, "id");
    /** Determines how vertices are read from the 'vertex' attributes */
    H(this, "topology");
    H(this, "vertexCount");
    H(this, "indices");
    H(this, "attributes");
    H(this, "userData", {});
    const {
      attributes: t = {},
      indices: n = null,
      vertexCount: i = null
    } = e;
    this.id = e.id || Kg("geometry"), this.topology = e.topology, n && (this.indices = ArrayBuffer.isView(n) ? {
      value: n,
      size: 1
    } : n), this.attributes = {};
    for (const [s, l] of Object.entries(t)) {
      const o = ArrayBuffer.isView(l) ? {
        value: l
      } : l;
      if (!ArrayBuffer.isView(o.value))
        throw new Error(`${this._print(s)}: must be typed array or object with value as typed array`);
      if ((s === "POSITION" || s === "positions") && !o.size && (o.size = 3), s === "indices") {
        if (this.indices)
          throw new Error("Multiple indices detected");
        this.indices = o;
      } else
        this.attributes[s] = o;
    }
    this.indices && this.indices.isIndexed !== void 0 && (this.indices = Object.assign({}, this.indices), delete this.indices.isIndexed), this.vertexCount = i || this._calculateVertexCount(this.attributes, this.indices);
  }
  getVertexCount() {
    return this.vertexCount;
  }
  /**
   * Return an object with all attributes plus indices added as a field.
   * TODO Geometry types are a mess
   */
  getAttributes() {
    return this.indices ? {
      indices: this.indices,
      ...this.attributes
    } : this.attributes;
  }
  // PRIVATE
  _print(e) {
    return `Geometry ${this.id} attribute ${e}`;
  }
  /**
   * GeometryAttribute
   * value: typed array
   * type: indices, vertices, uvs
   * size: elements per vertex
   * target: WebGL buffer type (string or constant)
   *
   * @param attributes
   * @param indices
   * @returns
   */
  _setAttributes(e, t) {
    return this;
  }
  _calculateVertexCount(e, t) {
    if (t)
      return t.value.length;
    let n = 1 / 0;
    for (const i of Object.values(e)) {
      const {
        value: s,
        size: l,
        constant: o
      } = i;
      !o && s && l !== void 0 && l >= 1 && (n = Math.min(n, s.length / l));
    }
    return n;
  }
}
class ry {
  constructor() {
    H(this, "id");
    H(this, "matrix", new Bn());
    H(this, "display", !0);
    H(this, "position", new Ct());
    H(this, "rotation", new Ct());
    H(this, "scale", new Ct(1, 1, 1));
    H(this, "userData", {});
    H(this, "props", {});
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      id: t
    } = e;
    this.id = t || Kg(this.constructor.name), this._setScenegraphNodeProps(e);
  }
  getBounds() {
    return null;
  }
  destroy() {
  }
  /** @deprecated use .destroy() */
  delete() {
    this.destroy();
  }
  setProps(e) {
    return this._setScenegraphNodeProps(e), this;
  }
  toString() {
    return `{type: ScenegraphNode, id: ${this.id})}`;
  }
  setPosition(e) {
    return this.position = e, this;
  }
  setRotation(e) {
    return this.rotation = e, this;
  }
  setScale(e) {
    return this.scale = e, this;
  }
  setMatrix(e) {
    (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0) ? this.matrix.copy(e) : this.matrix = e;
  }
  setMatrixComponents(e) {
    const {
      position: t,
      rotation: n,
      scale: i,
      update: s = !0
    } = e;
    return t && this.setPosition(t), n && this.setRotation(n), i && this.setScale(i), s && this.updateMatrix(), this;
  }
  updateMatrix() {
    const e = this.position, t = this.rotation, n = this.scale;
    return this.matrix.identity(), this.matrix.translate(e), this.matrix.rotateXYZ(t), this.matrix.scale(n), this;
  }
  update() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      position: t,
      rotation: n,
      scale: i
    } = e;
    return t && this.setPosition(t), n && this.setRotation(n), i && this.setScale(i), this.updateMatrix(), this;
  }
  getCoordinateUniforms(e, t) {
    t = t || this.matrix;
    const n = new Bn(e).multiplyRight(t), i = n.invert(), s = i.transpose();
    return {
      viewMatrix: e,
      modelMatrix: t,
      objectMatrix: t,
      worldMatrix: n,
      worldInverseMatrix: i,
      worldInverseTransposeMatrix: s
    };
  }
  // TODO - copied code, not yet vetted
  /*
  transform() {
    if (!this.parent) {
      this.endPosition.set(this.position);
      this.endRotation.set(this.rotation);
      this.endScale.set(this.scale);
    } else {
      const parent = this.parent;
      this.endPosition.set(this.position.add(parent.endPosition));
      this.endRotation.set(this.rotation.add(parent.endRotation));
      this.endScale.set(this.scale.add(parent.endScale));
    }
       const ch = this.children;
    for (let i = 0; i < ch.length; ++i) {
      ch[i].transform();
    }
       return this;
  }
  */
  _setScenegraphNodeProps(e) {
    "position" in e && this.setPosition(e.position), "rotation" in e && this.setRotation(e.rotation), "scale" in e && this.setScale(e.scale), "matrix" in e && this.setMatrix(e.matrix), Object.assign(this.props, e);
  }
}
class Zd extends ry {
  constructor() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    t = Array.isArray(t) ? {
      children: t
    } : t;
    const {
      children: n = []
    } = t;
    cr.assert(n.every((i) => i instanceof ry), "every child must an instance of ScenegraphNode");
    super(t);
    H(this, "children");
    this.children = n;
  }
  getBounds() {
    const t = [[1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]];
    return this.traverse((n, i) => {
      let {
        worldMatrix: s
      } = i;
      const l = n.getBounds();
      if (!l)
        return;
      const [o, d] = l, m = new Ct(o).add(d).divide([2, 2, 2]);
      s.transformAsPoint(m, m);
      const b = new Ct(d).subtract(o).divide([2, 2, 2]);
      s.transformAsVector(b, b);
      for (let A = 0; A < 8; A++) {
        const M = new Ct(A & 1 ? -1 : 1, A & 2 ? -1 : 1, A & 4 ? -1 : 1).multiply(b).add(m);
        for (let E = 0; E < 3; E++)
          t[0][E] = Math.min(t[0][E], M[E]), t[1][E] = Math.max(t[1][E], M[E]);
      }
    }), Number.isFinite(t[0][0]) ? t : null;
  }
  destroy() {
    this.children.forEach((t) => t.destroy()), this.removeAll(), super.destroy();
  }
  // Unpacks arrays and nested arrays of children
  add() {
    for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)
      n[i] = arguments[i];
    for (const s of n)
      Array.isArray(s) ? this.add(...s) : this.children.push(s);
    return this;
  }
  remove(t) {
    const n = this.children, i = n.indexOf(t);
    return i > -1 && n.splice(i, 1), this;
  }
  removeAll() {
    return this.children = [], this;
  }
  traverse(t) {
    let {
      worldMatrix: n = new Bn()
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const i = new Bn(n).multiplyRight(this.matrix);
    for (const s of this.children)
      s instanceof Zd ? s.traverse(t, {
        worldMatrix: i
      }) : t(s, {
        worldMatrix: i
      });
  }
}
class dv extends ry {
  // TODO - is this used? override callbacks to make sure we call them with this
  // onBeforeRender = null;
  // onAfterRender = null;
  // AfterRender = null;
  constructor(t) {
    super(t);
    H(this, "model");
    H(this, "bounds", null);
    H(this, "managedResources");
    this.model = t.model, this.managedResources = t.managedResources || [], this.bounds = t.bounds || null, this.setProps(t);
  }
  destroy() {
    this.model && (this.model.destroy(), this.model = null), this.managedResources.forEach((t) => t.destroy()), this.managedResources = [];
  }
  getBounds() {
    return this.bounds;
  }
  // Expose model methods
  draw(t) {
    return this.model.draw(t);
  }
}
const fU = {
  blendColorOperation: "add",
  blendColorSrcFactor: "one",
  blendColorDstFactor: "zero",
  blendAlphaOperation: "add",
  blendAlphaSrcFactor: "constant-alpha",
  blendAlphaDstFactor: "zero"
};
class G5 extends G2 {
  constructor() {
    super(...arguments), this._colorEncoderState = null;
  }
  render(e) {
    return "pickingFBO" in e ? this._drawPickingBuffer(e) : super.render(e);
  }
  // Private
  // Draws list of layers and viewports into the picking buffer
  // Note: does not sample the buffer, that has to be done by the caller
  _drawPickingBuffer(e) {
    let {
      layers: t,
      layerFilter: n,
      views: i,
      viewports: s,
      onViewportActive: l,
      pickingFBO: o,
      deviceRect: {
        x: d,
        y: m,
        width: b,
        height: A
      },
      cullRect: M,
      effects: E,
      pass: k = "picking",
      pickZ: U,
      shaderModuleProps: V
    } = e;
    this.pickZ = U;
    const q = this._resetColorEncoder(U), Y = [d, m, b, A], re = super.render({
      target: o,
      layers: t,
      layerFilter: n,
      views: i,
      viewports: s,
      onViewportActive: l,
      cullRect: M,
      effects: E == null ? void 0 : E.filter((K) => K.useInPicking),
      pass: k,
      isPicking: !0,
      shaderModuleProps: V,
      clearColor: [0, 0, 0, 0],
      colorMask: 15,
      scissorRect: Y
    });
    return this._colorEncoderState = null, {
      decodePickingColor: q && pU.bind(null, q),
      stats: re
    };
  }
  shouldDrawLayer(e) {
    const {
      pickable: t,
      operation: n
    } = e.props;
    return t && n.includes("draw") || n.includes("terrain") || n.includes("mask");
  }
  getShaderModuleProps(e, t, n) {
    return {
      picking: {
        isActive: 1,
        isAttribute: this.pickZ
      },
      lighting: {
        enabled: !1
      }
    };
  }
  getLayerParameters(e, t, n) {
    const i = {
      ...e.props.parameters
    }, {
      pickable: s,
      operation: l
    } = e.props;
    return !this._colorEncoderState || l.includes("terrain") ? i.blend = !1 : s && l.includes("draw") && (Object.assign(i, fU), i.blend = !0, i.blendColor = dU(this._colorEncoderState, e, n)), i;
  }
  _resetColorEncoder(e) {
    return this._colorEncoderState = e ? null : {
      byLayer: /* @__PURE__ */ new Map(),
      byAlpha: []
    }, this._colorEncoderState;
  }
}
function dU(r, e, t) {
  const {
    byLayer: n,
    byAlpha: i
  } = r;
  let s, l = n.get(e);
  return l ? (l.viewports.push(t), s = l.a) : (s = n.size + 1, s <= 255 ? (l = {
    a: s,
    layer: e,
    viewports: [t]
  }, n.set(e, l), i[s] = l) : (Gn.warn("Too many pickable layers, only picking the first 255")(), s = 0)), [0, 0, 0, s / 255];
}
function pU(r, e) {
  const t = r.byAlpha[e[3]];
  return t && {
    pickedLayer: t.layer,
    pickedViewports: t.viewports,
    pickedObjectIndex: t.layer.decodePickingColor(e)
  };
}
const Rd = {
  NO_STATE: "Awaiting state",
  MATCHED: "Matched. State transferred from previous layer",
  INITIALIZED: "Initialized",
  AWAITING_GC: "Discarded. Awaiting garbage collection",
  AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
  FINALIZED: "Finalized! Awaiting garbage collection"
}, ny = Symbol.for("component"), qh = Symbol.for("propTypes"), Ib = Symbol.for("deprecatedProps"), Yd = Symbol.for("asyncPropDefaults"), Gf = Symbol.for("asyncPropOriginal"), zh = Symbol.for("asyncPropResolved");
function ap(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : () => !0;
  return Array.isArray(r) ? H5(r, e, []) : e(r) ? [r] : [];
}
function H5(r, e, t) {
  let n = -1;
  for (; ++n < r.length; ) {
    const i = r[n];
    Array.isArray(i) ? H5(i, e, t) : e(i) && t.push(i);
  }
  return t;
}
function gU(r) {
  let {
    target: e,
    source: t,
    start: n = 0,
    count: i = 1
  } = r;
  const s = t.length, l = i * s;
  let o = 0;
  for (let d = n; o < s; o++)
    e[d++] = t[o];
  for (; o < l; )
    o < l - o ? (e.copyWithin(n + o, n, n + o), o *= 2) : (e.copyWithin(n + o, n, n + l - o), o = l);
  return e;
}
class mU {
  constructor(e, t, n) {
    this._loadCount = 0, this._subscribers = /* @__PURE__ */ new Set(), this.id = e, this.context = n, this.setData(t);
  }
  // consumer: {onChange: Function}
  subscribe(e) {
    this._subscribers.add(e);
  }
  unsubscribe(e) {
    this._subscribers.delete(e);
  }
  inUse() {
    return this._subscribers.size > 0;
  }
  delete() {
  }
  getData() {
    return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData());
  }
  setData(e, t) {
    if (e === this._data && !t)
      return;
    this._data = e;
    const n = ++this._loadCount;
    let i = e;
    typeof e == "string" && (i = Hh(e)), i instanceof Promise ? (this.isLoaded = !1, this._loader = i.then((s) => {
      this._loadCount === n && (this.isLoaded = !0, this._error = void 0, this._content = s);
    }).catch((s) => {
      this._loadCount === n && (this.isLoaded = !0, this._error = s || !0);
    })) : (this.isLoaded = !0, this._error = void 0, this._content = e);
    for (const s of this._subscribers)
      s.onChange(this.getData());
  }
}
class _U {
  constructor(e) {
    var t;
    this.protocol = e.protocol || "resource://", this._context = {
      device: e.device,
      // @ts-expect-error
      gl: (t = e.device) == null ? void 0 : t.gl,
      resourceManager: this
    }, this._resources = {}, this._consumers = {}, this._pruneRequest = null;
  }
  contains(e) {
    return e.startsWith(this.protocol) ? !0 : e in this._resources;
  }
  add(e) {
    let {
      resourceId: t,
      data: n,
      forceUpdate: i = !1,
      persistent: s = !0
    } = e, l = this._resources[t];
    l ? l.setData(n, i) : (l = new mU(t, n, this._context), this._resources[t] = l), l.persistent = s;
  }
  remove(e) {
    const t = this._resources[e];
    t && (t.delete(), delete this._resources[e]);
  }
  unsubscribe(e) {
    let {
      consumerId: t
    } = e;
    const n = this._consumers[t];
    if (n) {
      for (const i in n) {
        const s = n[i], l = this._resources[s.resourceId];
        l && l.unsubscribe(s);
      }
      delete this._consumers[t], this.prune();
    }
  }
  subscribe(e) {
    let {
      resourceId: t,
      onChange: n,
      consumerId: i,
      requestId: s = "default"
    } = e;
    const {
      _resources: l,
      protocol: o
    } = this;
    t.startsWith(o) && (t = t.replace(o, ""), l[t] || this.add({
      resourceId: t,
      data: null,
      persistent: !1
    }));
    const d = l[t];
    if (this._track(i, s, d, n), d)
      return d.getData();
  }
  prune() {
    this._pruneRequest || (this._pruneRequest = setTimeout(() => this._prune(), 0));
  }
  finalize() {
    for (const e in this._resources)
      this._resources[e].delete();
  }
  _track(e, t, n, i) {
    const s = this._consumers, l = s[e] = s[e] || {};
    let o = l[t];
    const d = o && o.resourceId && this._resources[o.resourceId];
    d && (d.unsubscribe(o), this.prune()), n && (o ? (o.onChange = i, o.resourceId = n.id) : o = {
      onChange: i,
      resourceId: n.id
    }, l[t] = o, n.subscribe(o));
  }
  _prune() {
    this._pruneRequest = null;
    for (const e of Object.keys(this._resources)) {
      const t = this._resources[e];
      !t.persistent && !t.inUse() && (t.delete(), delete this._resources[e]);
    }
  }
}
const yU = "layerManager.setLayers", bU = "layerManager.activateViewport";
class vU {
  /**
   * @param device
   * @param param1
   */
  // eslint-disable-next-line
  constructor(e, t) {
    var o;
    this._lastRenderedLayers = [], this._needsRedraw = !1, this._needsUpdate = !1, this._nextLayers = null, this._debug = !1, this._defaultShaderModulesChanged = !1, this.activateViewport = (d) => {
      ea(bU, this, d), d && (this.context.viewport = d);
    };
    const {
      deck: n,
      stats: i,
      viewport: s,
      timeline: l
    } = t || {};
    this.layers = [], this.resourceManager = new _U({
      device: e,
      protocol: "deck://"
    }), this.context = {
      mousePosition: null,
      userData: {},
      layerManager: this,
      device: e,
      // @ts-expect-error
      gl: e == null ? void 0 : e.gl,
      deck: n,
      shaderAssembler: v8(((o = e == null ? void 0 : e.info) == null ? void 0 : o.shadingLanguage) || "glsl"),
      defaultShaderModules: [PD],
      renderPass: void 0,
      stats: i || new mp({
        id: "deck.gl"
      }),
      // Make sure context.viewport is not empty on the first layer initialization
      viewport: s || new yp({
        id: "DEFAULT-INITIAL-VIEWPORT"
      }),
      // Current viewport, exposed to layers for project* function
      timeline: l || new j5(),
      resourceManager: this.resourceManager,
      onError: void 0
    }, Object.seal(this);
  }
  /** Method to call when the layer manager is not needed anymore. */
  finalize() {
    this.resourceManager.finalize();
    for (const e of this.layers)
      this._finalizeLayer(e);
  }
  /** Check if a redraw is needed */
  needsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    }, t = this._needsRedraw;
    e.clearRedrawFlags && (this._needsRedraw = !1);
    for (const n of this.layers) {
      const i = n.getNeedsRedraw(e);
      t = t || i;
    }
    return t;
  }
  /** Check if a deep update of all layers is needed */
  needsUpdate() {
    return this._nextLayers && this._nextLayers !== this._lastRenderedLayers ? "layers changed" : this._defaultShaderModulesChanged ? "shader modules changed" : this._needsUpdate;
  }
  /** Layers will be redrawn (in next animation frame) */
  setNeedsRedraw(e) {
    this._needsRedraw = this._needsRedraw || e;
  }
  /** Layers will be updated deeply (in next animation frame)
    Potentially regenerating attributes and sub layers */
  setNeedsUpdate(e) {
    this._needsUpdate = this._needsUpdate || e;
  }
  /** Gets a list of currently rendered layers. Optionally filter by id. */
  getLayers() {
    let {
      layerIds: e
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return e ? this.layers.filter((t) => e.find((n) => t.id.indexOf(n) === 0)) : this.layers;
  }
  /** Set props needed for layer rendering and picking. */
  setProps(e) {
    "debug" in e && (this._debug = e.debug), "userData" in e && (this.context.userData = e.userData), "layers" in e && (this._nextLayers = e.layers), "onError" in e && (this.context.onError = e.onError);
  }
  /** Supply a new layer list, initiating sublayer generation and layer matching */
  setLayers(e, t) {
    ea(yU, this, t, e), this._lastRenderedLayers = e;
    const n = ap(e, Boolean);
    for (const i of n)
      i.context = this.context;
    this._updateLayers(this.layers, n);
  }
  /** Update layers from last cycle if `setNeedsUpdate()` has been called */
  updateLayers() {
    const e = this.needsUpdate();
    e && (this.setNeedsRedraw(`updating layers: ${e}`), this.setLayers(this._nextLayers || this._lastRenderedLayers, e)), this._nextLayers = null;
  }
  /** Register a default shader module */
  addDefaultShaderModule(e) {
    const {
      defaultShaderModules: t
    } = this.context;
    t.find((n) => n.name === e.name) || (t.push(e), this._defaultShaderModulesChanged = !0);
  }
  /** Deregister a default shader module */
  removeDefaultShaderModule(e) {
    const {
      defaultShaderModules: t
    } = this.context, n = t.findIndex((i) => i.name === e.name);
    n >= 0 && (t.splice(n, 1), this._defaultShaderModulesChanged = !0);
  }
  _handleError(e, t, n) {
    n.raiseError(t, `${e} of ${n}`);
  }
  // TODO - mark layers with exceptions as bad and remove from rendering cycle?
  /** Match all layers, checking for caught errors
    to avoid having an exception in one layer disrupt other layers */
  _updateLayers(e, t) {
    const n = {};
    for (const l of e)
      n[l.id] ? Gn.warn(`Multiple old layers with same id ${l.id}`)() : n[l.id] = l;
    if (this._defaultShaderModulesChanged) {
      for (const l of e)
        l.setNeedsUpdate(), l.setChangeFlags({
          extensionsChanged: !0
        });
      this._defaultShaderModulesChanged = !1;
    }
    const i = [];
    this._updateSublayersRecursively(t, n, i), this._finalizeOldLayers(n);
    let s = !1;
    for (const l of i)
      if (l.hasUniformTransition()) {
        s = `Uniform transition in ${l}`;
        break;
      }
    this._needsUpdate = s, this.layers = i;
  }
  /* eslint-disable complexity,max-statements */
  // Note: adds generated layers to `generatedLayers` array parameter
  _updateSublayersRecursively(e, t, n) {
    for (const i of e) {
      i.context = this.context;
      const s = t[i.id];
      s === null && Gn.warn(`Multiple new layers with same id ${i.id}`)(), t[i.id] = null;
      let l = null;
      try {
        this._debug && s !== i && i.validateProps(), s ? (this._transferLayerState(s, i), this._updateLayer(i)) : this._initializeLayer(i), n.push(i), l = i.isComposite ? i.getSubLayers() : null;
      } catch (o) {
        this._handleError("matching", o, i);
      }
      l && this._updateSublayersRecursively(l, t, n);
    }
  }
  /* eslint-enable complexity,max-statements */
  // Finalize any old layers that were not matched
  _finalizeOldLayers(e) {
    for (const t in e) {
      const n = e[t];
      n && this._finalizeLayer(n);
    }
  }
  // / EXCEPTION SAFE LAYER ACCESS
  /** Safely initializes a single layer, calling layer methods */
  _initializeLayer(e) {
    try {
      e._initialize(), e.lifecycle = Rd.INITIALIZED;
    } catch (t) {
      this._handleError("initialization", t, e);
    }
  }
  /** Transfer state from one layer to a newer version */
  _transferLayerState(e, t) {
    t._transferState(e), t.lifecycle = Rd.MATCHED, t !== e && (e.lifecycle = Rd.AWAITING_GC);
  }
  /** Safely updates a single layer, cleaning all flags */
  _updateLayer(e) {
    try {
      e._update();
    } catch (t) {
      this._handleError("update", t, e);
    }
  }
  /** Safely finalizes a single layer, removing all resources */
  _finalizeLayer(e) {
    this._needsRedraw = this._needsRedraw || `finalized ${e}`, e.lifecycle = Rd.AWAITING_FINALIZATION;
    try {
      e._finalize(), e.lifecycle = Rd.FINALIZED;
    } catch (t) {
      this._handleError("finalization", t, e);
    }
  }
}
function Cc(r, e, t) {
  if (r === e)
    return !0;
  if (!t || !r || !e)
    return !1;
  if (Array.isArray(r)) {
    if (!Array.isArray(e) || r.length !== e.length)
      return !1;
    for (let n = 0; n < r.length; n++)
      if (!Cc(r[n], e[n], t - 1))
        return !1;
    return !0;
  }
  if (Array.isArray(e))
    return !1;
  if (typeof r == "object" && typeof e == "object") {
    const n = Object.keys(r), i = Object.keys(e);
    if (n.length !== i.length)
      return !1;
    for (const s of n)
      if (!e.hasOwnProperty(s) || !Cc(r[s], e[s], t - 1))
        return !1;
    return !0;
  }
  return !1;
}
class xU {
  constructor(e) {
    this.views = [], this.width = 100, this.height = 100, this.viewState = {}, this.controllers = {}, this.timeline = e.timeline, this._viewports = [], this._viewportMap = {}, this._isUpdating = !1, this._needsRedraw = "First render", this._needsUpdate = "Initialize", this._eventManager = e.eventManager, this._eventCallbacks = {
      onViewStateChange: e.onViewStateChange,
      onInteractionStateChange: e.onInteractionStateChange
    }, Object.seal(this), this.setProps(e);
  }
  /** Remove all resources and event listeners */
  finalize() {
    for (const e in this.controllers) {
      const t = this.controllers[e];
      t && t.finalize();
    }
    this.controllers = {};
  }
  /** Check if a redraw is needed */
  needsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    const t = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), t;
  }
  /** Mark the manager as dirty. Will rebuild all viewports and update controllers. */
  setNeedsUpdate(e) {
    this._needsUpdate = this._needsUpdate || e, this._needsRedraw = this._needsRedraw || e;
  }
  /** Checks each viewport for transition updates */
  updateViewStates() {
    for (const e in this.controllers) {
      const t = this.controllers[e];
      t && t.updateTransition();
    }
  }
  /** Get a set of viewports for a given width and height
   * TODO - Intention is for deck.gl to autodeduce width and height and drop the need for props
   * @param rect (object, optional) - filter the viewports
   *   + not provided - return all viewports
   *   + {x, y} - only return viewports that contain this pixel
   *   + {x, y, width, height} - only return viewports that overlap with this rectangle
   */
  getViewports(e) {
    return e ? this._viewports.filter((t) => t.containsPixel(e)) : this._viewports;
  }
  /** Get a map of all views */
  getViews() {
    const e = {};
    return this.views.forEach((t) => {
      e[t.id] = t;
    }), e;
  }
  /** Resolves a viewId string to a View */
  getView(e) {
    return this.views.find((t) => t.id === e);
  }
  /** Returns the viewState for a specific viewId. Matches the viewState by
    1. view.viewStateId
    2. view.id
    3. root viewState
    then applies the view's filter if any */
  getViewState(e) {
    const t = typeof e == "string" ? this.getView(e) : e, n = t && this.viewState[t.getViewStateId()] || this.viewState;
    return t ? t.filterViewState(n) : n;
  }
  getViewport(e) {
    return this._viewportMap[e];
  }
  /**
   * Unproject pixel coordinates on screen onto world coordinates,
   * (possibly [lon, lat]) on map.
   * - [x, y] => [lng, lat]
   * - [x, y, z] => [lng, lat, Z]
   * @param {Array} xyz -
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether origin is top left
   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
   */
  unproject(e, t) {
    const n = this.getViewports(), i = {
      x: e[0],
      y: e[1]
    };
    for (let s = n.length - 1; s >= 0; --s) {
      const l = n[s];
      if (l.containsPixel(i)) {
        const o = e.slice();
        return o[0] -= l.x, o[1] -= l.y, l.unproject(o, t);
      }
    }
    return null;
  }
  /** Update the manager with new Deck props */
  setProps(e) {
    e.views && this._setViews(e.views), e.viewState && this._setViewState(e.viewState), ("width" in e || "height" in e) && this._setSize(e.width, e.height), this._isUpdating || this._update();
  }
  //
  // PRIVATE METHODS
  //
  _update() {
    this._isUpdating = !0, this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._isUpdating = !1;
  }
  _setSize(e, t) {
    (e !== this.width || t !== this.height) && (this.width = e, this.height = t, this.setNeedsUpdate("Size changed"));
  }
  // Update the view descriptor list and set change flag if needed
  // Does not actually rebuild the `Viewport`s until `getViewports` is called
  _setViews(e) {
    e = ap(e, Boolean), this._diffViews(e, this.views) && this.setNeedsUpdate("views changed"), this.views = e;
  }
  _setViewState(e) {
    e ? (!Cc(e, this.viewState, 3) && this.setNeedsUpdate("viewState changed"), this.viewState = e) : Gn.warn("missing `viewState` or `initialViewState`")();
  }
  _createController(e, t) {
    const n = t.type;
    return new n({
      timeline: this.timeline,
      eventManager: this._eventManager,
      // Set an internal callback that calls the prop callback if provided
      onViewStateChange: this._eventCallbacks.onViewStateChange,
      onStateChange: this._eventCallbacks.onInteractionStateChange,
      makeViewport: (s) => {
        var l;
        return (l = this.getView(e.id)) == null ? void 0 : l.makeViewport({
          viewState: s,
          width: this.width,
          height: this.height
        });
      }
    });
  }
  _updateController(e, t, n, i) {
    const s = e.controller;
    if (s && n) {
      const l = {
        ...t,
        ...s,
        id: e.id,
        x: n.x,
        y: n.y,
        width: n.width,
        height: n.height
      };
      return (!i || i.constructor !== s.type) && (i = this._createController(e, l)), i && i.setProps(l), i;
    }
    return null;
  }
  // Rebuilds viewports from descriptors towards a certain window size
  _rebuildViewports() {
    const {
      views: e
    } = this, t = this.controllers;
    this._viewports = [], this.controllers = {};
    let n = !1;
    for (let i = e.length; i--; ) {
      const s = e[i], l = this.getViewState(s), o = s.makeViewport({
        viewState: l,
        width: this.width,
        height: this.height
      });
      let d = t[s.id];
      const m = !!s.controller;
      m && !d && (n = !0), (n || !m) && d && (d.finalize(), d = null), this.controllers[s.id] = this._updateController(s, l, o, d), o && this._viewports.unshift(o);
    }
    for (const i in t) {
      const s = t[i];
      s && !this.controllers[i] && s.finalize();
    }
    this._buildViewportMap();
  }
  _buildViewportMap() {
    this._viewportMap = {}, this._viewports.forEach((e) => {
      e.id && (this._viewportMap[e.id] = this._viewportMap[e.id] || e);
    });
  }
  // Check if viewport array has changed, returns true if any change
  // Note that descriptors can be the same
  _diffViews(e, t) {
    return e.length !== t.length ? !0 : e.some((n, i) => !e[i].equals(t[i]));
  }
}
const wU = /([0-9]+\.?[0-9]*)(%|px)/;
function Ch(r) {
  switch (typeof r) {
    case "number":
      return {
        position: r,
        relative: !1
      };
    case "string":
      const e = wU.exec(r);
      if (e && e.length >= 3) {
        const t = e[2] === "%", n = parseFloat(e[1]);
        return {
          position: t ? n / 100 : n,
          relative: t
        };
      }
    // fallthrough
    default:
      throw new Error(`Could not parse position string ${r}`);
  }
}
function Ih(r, e) {
  return r.relative ? Math.round(r.position * e) : r.position;
}
class W5 {
  constructor(e) {
    const {
      id: t,
      x: n = 0,
      y: i = 0,
      width: s = "100%",
      height: l = "100%",
      padding: o = null
    } = e;
    this.id = t || this.constructor.displayName || "view", this.props = {
      ...e,
      id: this.id
    }, this._x = Ch(n), this._y = Ch(i), this._width = Ch(s), this._height = Ch(l), this._padding = o && {
      left: Ch(o.left || 0),
      right: Ch(o.right || 0),
      top: Ch(o.top || 0),
      bottom: Ch(o.bottom || 0)
    }, this.equals = this.equals.bind(this), Object.seal(this);
  }
  equals(e) {
    return this === e ? !0 : this.constructor === e.constructor && Cc(this.props, e.props, 2);
  }
  /** Make viewport from canvas dimensions and view state */
  makeViewport(e) {
    let {
      width: t,
      height: n,
      viewState: i
    } = e;
    i = this.filterViewState(i);
    const s = this.getDimensions({
      width: t,
      height: n
    });
    if (!s.height || !s.width)
      return null;
    const l = this.getViewportType(i);
    return new l({
      ...i,
      ...this.props,
      ...s
    });
  }
  getViewStateId() {
    const {
      viewState: e
    } = this.props;
    return typeof e == "string" ? e : (e == null ? void 0 : e.id) || this.id;
  }
  // Allows view to override (or completely define) viewState
  filterViewState(e) {
    if (this.props.viewState && typeof this.props.viewState == "object") {
      if (!this.props.viewState.id)
        return this.props.viewState;
      const t = {
        ...e
      };
      for (const n in this.props.viewState)
        n !== "id" && (t[n] = this.props.viewState[n]);
      return t;
    }
    return e;
  }
  /** Resolve the dimensions of the view from overall canvas dimensions */
  getDimensions(e) {
    let {
      width: t,
      height: n
    } = e;
    const i = {
      x: Ih(this._x, t),
      y: Ih(this._y, n),
      width: Ih(this._width, t),
      height: Ih(this._height, n)
    };
    return this._padding && (i.padding = {
      left: Ih(this._padding.left, t),
      top: Ih(this._padding.top, n),
      right: Ih(this._padding.right, t),
      bottom: Ih(this._padding.bottom, n)
    }), i;
  }
  // Used by sub classes to resolve controller props
  get controller() {
    const e = this.props.controller;
    return e ? e === !0 ? {
      type: this.ControllerType
    } : typeof e == "function" ? {
      type: e
    } : {
      type: this.ControllerType,
      ...e
    } : null;
  }
}
class Fy {
  /**
   * @params timeline {Timeline}
   */
  constructor(e) {
    this._inProgress = !1, this._handle = null, this.time = 0, this.settings = {
      duration: 0
    }, this._timeline = e;
  }
  /* Public API */
  get inProgress() {
    return this._inProgress;
  }
  /**
   * (re)start this transition.
   * @params props {object} - optional overriding props. see constructor
   */
  start(e) {
    var t, n;
    this.cancel(), this.settings = e, this._inProgress = !0, (n = (t = this.settings).onStart) == null || n.call(t, this);
  }
  /**
   * end this transition if it is in progress.
   */
  end() {
    var e, t;
    this._inProgress && (this._timeline.removeChannel(this._handle), this._handle = null, this._inProgress = !1, (t = (e = this.settings).onEnd) == null || t.call(e, this));
  }
  /**
   * cancel this transition if it is in progress.
   */
  cancel() {
    var e, t;
    this._inProgress && ((t = (e = this.settings).onInterrupt) == null || t.call(e, this), this._timeline.removeChannel(this._handle), this._handle = null, this._inProgress = !1);
  }
  /**
   * update this transition. Returns `true` if updated.
   */
  update() {
    var e, t;
    if (!this._inProgress)
      return !1;
    if (this._handle === null) {
      const {
        _timeline: n,
        settings: i
      } = this;
      this._handle = n.addChannel({
        delay: n.getTime(),
        duration: i.duration
      });
    }
    return this.time = this._timeline.getTime(this._handle), this._onUpdate(), (t = (e = this.settings).onUpdate) == null || t.call(e, this), this._timeline.isFinished(this._handle) && this.end(), !0;
  }
  /* Private API */
  _onUpdate() {
  }
}
const KT = () => {
}, pv = {
  BREAK: 1,
  SNAP_TO_END: 2,
  IGNORE: 3
}, AU = (r) => r, TU = pv.BREAK;
class SU {
  constructor(e) {
    this._onTransitionUpdate = (t) => {
      const {
        time: n,
        settings: {
          interpolator: i,
          startProps: s,
          endProps: l,
          duration: o,
          easing: d
        }
      } = t, m = d(n / o), b = i.interpolateProps(s, l, m);
      this.propsInTransition = this.getControllerState({
        ...this.props,
        ...b
      }).getViewportProps(), this.onViewStateChange({
        viewState: this.propsInTransition,
        oldViewState: this.props
      });
    }, this.getControllerState = e.getControllerState, this.propsInTransition = null, this.transition = new Fy(e.timeline), this.onViewStateChange = e.onViewStateChange || KT, this.onStateChange = e.onStateChange || KT;
  }
  finalize() {
    this.transition.cancel();
  }
  // Returns current transitioned viewport.
  getViewportInTransition() {
    return this.propsInTransition;
  }
  // Process the vewiport change, either ignore or trigger a new transition.
  // Return true if a new transition is triggered, false otherwise.
  processViewStateChange(e) {
    let t = !1;
    const n = this.props;
    if (this.props = e, !n || this._shouldIgnoreViewportChange(n, e))
      return !1;
    if (this._isTransitionEnabled(e)) {
      let i = n;
      if (this.transition.inProgress) {
        const {
          interruption: s,
          endProps: l
        } = this.transition.settings;
        i = {
          ...n,
          ...s === pv.SNAP_TO_END ? l : this.propsInTransition || n
        };
      }
      this._triggerTransition(i, e), t = !0;
    } else
      this.transition.cancel();
    return t;
  }
  updateTransition() {
    this.transition.update();
  }
  // Helper methods
  _isTransitionEnabled(e) {
    const {
      transitionDuration: t,
      transitionInterpolator: n
    } = e;
    return (t > 0 || t === "auto") && !!n;
  }
  _isUpdateDueToCurrentTransition(e) {
    return this.transition.inProgress && this.propsInTransition ? this.transition.settings.interpolator.arePropsEqual(e, this.propsInTransition) : !1;
  }
  _shouldIgnoreViewportChange(e, t) {
    return this.transition.inProgress ? this.transition.settings.interruption === pv.IGNORE || // Ignore update if it is due to current active transition.
    this._isUpdateDueToCurrentTransition(t) : this._isTransitionEnabled(t) ? t.transitionInterpolator.arePropsEqual(e, t) : !0;
  }
  _triggerTransition(e, t) {
    const n = this.getControllerState(e), i = this.getControllerState(t).shortestPathFrom(n), s = t.transitionInterpolator, l = s.getDuration ? s.getDuration(e, t) : t.transitionDuration;
    if (l === 0)
      return;
    const o = s.initializeProps(e, i);
    this.propsInTransition = {};
    const d = {
      duration: l,
      easing: t.transitionEasing || AU,
      interpolator: s,
      interruption: t.transitionInterruption || TU,
      startProps: o.start,
      endProps: o.end,
      onStart: t.onTransitionStart,
      onUpdate: this._onTransitionUpdate,
      onInterrupt: this._onTransitionEnd(t.onTransitionInterrupt),
      onEnd: this._onTransitionEnd(t.onTransitionEnd)
    };
    this.transition.start(d), this.onStateChange({
      inTransition: !0
    }), this.updateTransition();
  }
  _onTransitionEnd(e) {
    return (t) => {
      this.propsInTransition = null, this.onStateChange({
        inTransition: !1,
        isZooming: !1,
        isPanning: !1,
        isRotating: !1
      }), e == null || e(t);
    };
  }
}
function ro(r, e) {
  if (!r)
    throw new Error(e || "deck.gl: assertion failed.");
}
class EU {
  /**
   * @param opts {array|object}
   * @param opts.compare {array} - prop names used in equality check
   * @param opts.extract {array} - prop names needed for interpolation
   * @param opts.required {array} - prop names that must be supplied
   * alternatively, supply one list of prop names as `opts` if all of the above are the same.
   */
  constructor(e) {
    const {
      compare: t,
      extract: n,
      required: i
    } = e;
    this._propsToCompare = t, this._propsToExtract = n || t, this._requiredProps = i;
  }
  /**
   * Checks if two sets of props need transition in between
   * @param currentProps {object} - a list of viewport props
   * @param nextProps {object} - a list of viewport props
   * @returns {bool} - true if two props are equivalent
   */
  arePropsEqual(e, t) {
    for (const n of this._propsToCompare)
      if (!(n in e) || !(n in t) || !Mc(e[n], t[n]))
        return !1;
    return !0;
  }
  /**
   * Called before transition starts to validate/pre-process start and end props
   * @param startProps {object} - a list of starting viewport props
   * @param endProps {object} - a list of target viewport props
   * @returns {Object} {start, end} - start and end props to be passed
   *   to `interpolateProps`
   */
  initializeProps(e, t) {
    const n = {}, i = {};
    for (const s of this._propsToExtract)
      (s in e || s in t) && (n[s] = e[s], i[s] = t[s]);
    return this._checkRequiredProps(n), this._checkRequiredProps(i), {
      start: n,
      end: i
    };
  }
  /**
   * Returns transition duration
   * @param startProps {object} - a list of starting viewport props
   * @param endProps {object} - a list of target viewport props
   * @returns {Number} - transition duration in milliseconds
   */
  getDuration(e, t) {
    return t.transitionDuration;
  }
  _checkRequiredProps(e) {
    this._requiredProps && this._requiredProps.forEach((t) => {
      const n = e[t];
      ro(Number.isFinite(n) || Array.isArray(n), `${t} is required for transition`);
    });
  }
}
const CU = ["longitude", "latitude", "zoom", "bearing", "pitch"], IU = ["longitude", "latitude", "zoom"];
class W2 extends EU {
  /**
   * @param {Object} opts
   * @param {Array} opts.transitionProps - list of props to apply linear transition to.
   * @param {Array} opts.around - a screen point to zoom/rotate around.
   * @param {Function} opts.makeViewport - construct a viewport instance with given props.
   */
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = Array.isArray(e) ? e : e.transitionProps, n = Array.isArray(e) ? {} : e;
    n.transitionProps = Array.isArray(t) ? {
      compare: t,
      required: t
    } : t || {
      compare: CU,
      required: IU
    }, super(n.transitionProps), this.opts = n;
  }
  initializeProps(e, t) {
    const n = super.initializeProps(e, t), {
      makeViewport: i,
      around: s
    } = this.opts;
    if (i && s) {
      const l = i(e), o = i(t), d = l.unproject(s);
      n.start.around = s, Object.assign(n.end, {
        around: o.project(d),
        aroundPosition: d,
        width: t.width,
        height: t.height
      });
    }
    return n;
  }
  interpolateProps(e, t, n) {
    const i = {};
    for (const s of this._propsToExtract)
      i[s] = K_(e[s] || 0, t[s] || 0, n);
    if (t.aroundPosition && this.opts.makeViewport) {
      const s = this.opts.makeViewport({
        ...t,
        ...i
      });
      Object.assign(i, s.panByPosition(
        t.aroundPosition,
        // anchor point in current screen coordinates
        K_(e.around, t.around, n)
      ));
    }
    return i;
  }
}
const Mh = {
  transitionDuration: 0
}, MU = 300, km = (r) => 1 - (1 - r) * (1 - r), Sd = {
  WHEEL: ["wheel"],
  PAN: ["panstart", "panmove", "panend"],
  PINCH: ["pinchstart", "pinchmove", "pinchend"],
  MULTI_PAN: ["multipanstart", "multipanmove", "multipanend"],
  DOUBLE_CLICK: ["dblclick"],
  KEYBOARD: ["keydown"]
}, bf = {};
class X5 {
  constructor(e) {
    this.state = {}, this._events = {}, this._interactionState = {
      isDragging: !1
    }, this._customEvents = [], this._eventStartBlocked = null, this._panMove = !1, this.invertPan = !1, this.dragMode = "rotate", this.inertia = 0, this.scrollZoom = !0, this.dragPan = !0, this.dragRotate = !0, this.doubleClickZoom = !0, this.touchZoom = !0, this.touchRotate = !1, this.keyboard = !0, this.transitionManager = new SU({
      ...e,
      getControllerState: (t) => new this.ControllerState(t),
      onViewStateChange: this._onTransition.bind(this),
      onStateChange: this._setInteractionState.bind(this)
    }), this.handleEvent = this.handleEvent.bind(this), this.eventManager = e.eventManager, this.onViewStateChange = e.onViewStateChange || (() => {
    }), this.onStateChange = e.onStateChange || (() => {
    }), this.makeViewport = e.makeViewport;
  }
  set events(e) {
    this.toggleEvents(this._customEvents, !1), this.toggleEvents(e, !0), this._customEvents = e, this.props && this.setProps(this.props);
  }
  finalize() {
    var e;
    for (const t in this._events)
      this._events[t] && ((e = this.eventManager) == null || e.off(t, this.handleEvent));
    this.transitionManager.finalize();
  }
  /**
   * Callback for events
   */
  handleEvent(e) {
    this._controllerState = void 0;
    const t = this._eventStartBlocked;
    switch (e.type) {
      case "panstart":
        return t ? !1 : this._onPanStart(e);
      case "panmove":
        return this._onPan(e);
      case "panend":
        return this._onPanEnd(e);
      case "pinchstart":
        return t ? !1 : this._onPinchStart(e);
      case "pinchmove":
        return this._onPinch(e);
      case "pinchend":
        return this._onPinchEnd(e);
      case "multipanstart":
        return t ? !1 : this._onMultiPanStart(e);
      case "multipanmove":
        return this._onMultiPan(e);
      case "multipanend":
        return this._onMultiPanEnd(e);
      case "dblclick":
        return this._onDoubleClick(e);
      case "wheel":
        return this._onWheel(e);
      case "keydown":
        return this._onKeyDown(e);
      default:
        return !1;
    }
  }
  /* Event utils */
  // Event object: http://hammerjs.github.io/api/#event-object
  get controllerState() {
    return this._controllerState = this._controllerState || new this.ControllerState({
      makeViewport: this.makeViewport,
      ...this.props,
      ...this.state
    }), this._controllerState;
  }
  getCenter(e) {
    const {
      x: t,
      y: n
    } = this.props, {
      offsetCenter: i
    } = e;
    return [i.x - t, i.y - n];
  }
  isPointInBounds(e, t) {
    const {
      width: n,
      height: i
    } = this.props;
    if (t && t.handled)
      return !1;
    const s = e[0] >= 0 && e[0] <= n && e[1] >= 0 && e[1] <= i;
    return s && t && t.stopPropagation(), s;
  }
  isFunctionKeyPressed(e) {
    const {
      srcEvent: t
    } = e;
    return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey);
  }
  isDragging() {
    return this._interactionState.isDragging || !1;
  }
  // When a multi-touch event ends, e.g. pinch, not all pointers are lifted at the same time.
  // This triggers a brief `pan` event.
  // Calling this method will temporarily disable *start events to avoid conflicting transitions.
  blockEvents(e) {
    const t = setTimeout(() => {
      this._eventStartBlocked === t && (this._eventStartBlocked = null);
    }, e);
    this._eventStartBlocked = t;
  }
  /**
   * Extract interactivity options
   */
  setProps(e) {
    e.dragMode && (this.dragMode = e.dragMode), this.props = e, "transitionInterpolator" in e || (e.transitionInterpolator = this._getTransitionProps().transitionInterpolator), this.transitionManager.processViewStateChange(e);
    const {
      inertia: t
    } = e;
    this.inertia = Number.isFinite(t) ? t : t === !0 ? MU : 0;
    const {
      scrollZoom: n = !0,
      dragPan: i = !0,
      dragRotate: s = !0,
      doubleClickZoom: l = !0,
      touchZoom: o = !0,
      touchRotate: d = !1,
      keyboard: m = !0
    } = e, b = !!this.onViewStateChange;
    this.toggleEvents(Sd.WHEEL, b && n), this.toggleEvents(Sd.PAN, b), this.toggleEvents(Sd.PINCH, b && (o || d)), this.toggleEvents(Sd.MULTI_PAN, b && d), this.toggleEvents(Sd.DOUBLE_CLICK, b && l), this.toggleEvents(Sd.KEYBOARD, b && m), this.scrollZoom = n, this.dragPan = i, this.dragRotate = s, this.doubleClickZoom = l, this.touchZoom = o, this.touchRotate = d, this.keyboard = m;
  }
  updateTransition() {
    this.transitionManager.updateTransition();
  }
  toggleEvents(e, t) {
    this.eventManager && e.forEach((n) => {
      this._events[n] !== t && (this._events[n] = t, t ? this.eventManager.on(n, this.handleEvent) : this.eventManager.off(n, this.handleEvent));
    });
  }
  // Private Methods
  /* Callback util */
  // formats map state and invokes callback function
  updateViewport(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const i = {
      ...e.getViewportProps(),
      ...t
    }, s = this.controllerState !== e;
    if (this.state = e.getState(), this._setInteractionState(n), s) {
      const l = this.controllerState && this.controllerState.getViewportProps();
      this.onViewStateChange && this.onViewStateChange({
        viewState: i,
        interactionState: this._interactionState,
        oldViewState: l,
        viewId: this.props.id
      });
    }
  }
  _onTransition(e) {
    this.onViewStateChange({
      ...e,
      interactionState: this._interactionState,
      viewId: this.props.id
    });
  }
  _setInteractionState(e) {
    Object.assign(this._interactionState, e), this.onStateChange(this._interactionState);
  }
  /* Event handlers */
  // Default handler for the `panstart` event.
  _onPanStart(e) {
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    let n = this.isFunctionKeyPressed(e) || e.rightButton || !1;
    (this.invertPan || this.dragMode === "pan") && (n = !n);
    const i = this.controllerState[n ? "panStart" : "rotateStart"]({
      pos: t
    });
    return this._panMove = n, this.updateViewport(i, Mh, {
      isDragging: !0
    }), !0;
  }
  // Default handler for the `panmove` and `panend` event.
  _onPan(e) {
    return this.isDragging() ? this._panMove ? this._onPanMove(e) : this._onPanRotate(e) : !1;
  }
  _onPanEnd(e) {
    return this.isDragging() ? this._panMove ? this._onPanMoveEnd(e) : this._onPanRotateEnd(e) : !1;
  }
  // Default handler for panning to move.
  // Called by `_onPan` when panning without function key pressed.
  _onPanMove(e) {
    if (!this.dragPan)
      return !1;
    const t = this.getCenter(e), n = this.controllerState.pan({
      pos: t
    });
    return this.updateViewport(n, Mh, {
      isDragging: !0,
      isPanning: !0
    }), !0;
  }
  _onPanMoveEnd(e) {
    const {
      inertia: t
    } = this;
    if (this.dragPan && t && e.velocity) {
      const n = this.getCenter(e), i = [n[0] + e.velocityX * t / 2, n[1] + e.velocityY * t / 2], s = this.controllerState.pan({
        pos: i
      }).panEnd();
      this.updateViewport(s, {
        ...this._getTransitionProps(),
        transitionDuration: t,
        transitionEasing: km
      }, {
        isDragging: !1,
        isPanning: !0
      });
    } else {
      const n = this.controllerState.panEnd();
      this.updateViewport(n, null, {
        isDragging: !1,
        isPanning: !1
      });
    }
    return !0;
  }
  // Default handler for panning to rotate.
  // Called by `_onPan` when panning with function key pressed.
  _onPanRotate(e) {
    if (!this.dragRotate)
      return !1;
    const t = this.getCenter(e), n = this.controllerState.rotate({
      pos: t
    });
    return this.updateViewport(n, Mh, {
      isDragging: !0,
      isRotating: !0
    }), !0;
  }
  _onPanRotateEnd(e) {
    const {
      inertia: t
    } = this;
    if (this.dragRotate && t && e.velocity) {
      const n = this.getCenter(e), i = [n[0] + e.velocityX * t / 2, n[1] + e.velocityY * t / 2], s = this.controllerState.rotate({
        pos: i
      }).rotateEnd();
      this.updateViewport(s, {
        ...this._getTransitionProps(),
        transitionDuration: t,
        transitionEasing: km
      }, {
        isDragging: !1,
        isRotating: !0
      });
    } else {
      const n = this.controllerState.rotateEnd();
      this.updateViewport(n, null, {
        isDragging: !1,
        isRotating: !1
      });
    }
    return !0;
  }
  // Default handler for the `wheel` event.
  _onWheel(e) {
    if (!this.scrollZoom)
      return !1;
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    e.srcEvent.preventDefault();
    const {
      speed: n = 0.01,
      smooth: i = !1
    } = this.scrollZoom === !0 ? {} : this.scrollZoom, {
      delta: s
    } = e;
    let l = 2 / (1 + Math.exp(-Math.abs(s * n)));
    s < 0 && l !== 0 && (l = 1 / l);
    const o = this.controllerState.zoom({
      pos: t,
      scale: l
    });
    return this.updateViewport(o, {
      ...this._getTransitionProps({
        around: t
      }),
      transitionDuration: i ? 250 : 1
    }, {
      isZooming: !0,
      isPanning: !0
    }), !0;
  }
  _onMultiPanStart(e) {
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    const n = this.controllerState.rotateStart({
      pos: t
    });
    return this.updateViewport(n, Mh, {
      isDragging: !0
    }), !0;
  }
  _onMultiPan(e) {
    if (!this.touchRotate || !this.isDragging())
      return !1;
    const t = this.getCenter(e);
    t[0] -= e.deltaX;
    const n = this.controllerState.rotate({
      pos: t
    });
    return this.updateViewport(n, Mh, {
      isDragging: !0,
      isRotating: !0
    }), !0;
  }
  _onMultiPanEnd(e) {
    if (!this.isDragging())
      return !1;
    const {
      inertia: t
    } = this;
    if (this.touchRotate && t && e.velocityY) {
      const n = this.getCenter(e), i = [n[0], n[1] += e.velocityY * t / 2], s = this.controllerState.rotate({
        pos: i
      });
      this.updateViewport(s, {
        ...this._getTransitionProps(),
        transitionDuration: t,
        transitionEasing: km
      }, {
        isDragging: !1,
        isRotating: !0
      }), this.blockEvents(t);
    } else {
      const n = this.controllerState.rotateEnd();
      this.updateViewport(n, null, {
        isDragging: !1,
        isRotating: !1
      });
    }
    return !0;
  }
  // Default handler for the `pinchstart` event.
  _onPinchStart(e) {
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    const n = this.controllerState.zoomStart({
      pos: t
    }).rotateStart({
      pos: t
    });
    return bf._startPinchRotation = e.rotation, bf._lastPinchEvent = e, this.updateViewport(n, Mh, {
      isDragging: !0
    }), !0;
  }
  // Default handler for the `pinchmove` and `pinchend` events.
  _onPinch(e) {
    if (!this.touchZoom && !this.touchRotate || !this.isDragging())
      return !1;
    let t = this.controllerState;
    if (this.touchZoom) {
      const {
        scale: n
      } = e, i = this.getCenter(e);
      t = t.zoom({
        pos: i,
        scale: n
      });
    }
    if (this.touchRotate) {
      const {
        rotation: n
      } = e;
      t = t.rotate({
        deltaAngleX: bf._startPinchRotation - n
      });
    }
    return this.updateViewport(t, Mh, {
      isDragging: !0,
      isPanning: this.touchZoom,
      isZooming: this.touchZoom,
      isRotating: this.touchRotate
    }), bf._lastPinchEvent = e, !0;
  }
  _onPinchEnd(e) {
    if (!this.isDragging())
      return !1;
    const {
      inertia: t
    } = this, {
      _lastPinchEvent: n
    } = bf;
    if (this.touchZoom && t && n && e.scale !== n.scale) {
      const i = this.getCenter(e);
      let s = this.controllerState.rotateEnd();
      const l = Math.log2(e.scale), o = (l - Math.log2(n.scale)) / (e.deltaTime - n.deltaTime), d = Math.pow(2, l + o * t / 2);
      s = s.zoom({
        pos: i,
        scale: d
      }).zoomEnd(), this.updateViewport(s, {
        ...this._getTransitionProps({
          around: i
        }),
        transitionDuration: t,
        transitionEasing: km
      }, {
        isDragging: !1,
        isPanning: this.touchZoom,
        isZooming: this.touchZoom,
        isRotating: !1
      }), this.blockEvents(t);
    } else {
      const i = this.controllerState.zoomEnd().rotateEnd();
      this.updateViewport(i, null, {
        isDragging: !1,
        isPanning: !1,
        isZooming: !1,
        isRotating: !1
      });
    }
    return bf._startPinchRotation = null, bf._lastPinchEvent = null, !0;
  }
  // Default handler for the `dblclick` event.
  _onDoubleClick(e) {
    if (!this.doubleClickZoom)
      return !1;
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    const n = this.isFunctionKeyPressed(e), i = this.controllerState.zoom({
      pos: t,
      scale: n ? 0.5 : 2
    });
    return this.updateViewport(i, this._getTransitionProps({
      around: t
    }), {
      isZooming: !0,
      isPanning: !0
    }), this.blockEvents(100), !0;
  }
  // Default handler for the `keydown` event
  _onKeyDown(e) {
    if (!this.keyboard)
      return !1;
    const t = this.isFunctionKeyPressed(e), {
      zoomSpeed: n,
      moveSpeed: i,
      rotateSpeedX: s,
      rotateSpeedY: l
    } = this.keyboard === !0 ? {} : this.keyboard, {
      controllerState: o
    } = this;
    let d;
    const m = {};
    switch (e.srcEvent.code) {
      case "Minus":
        d = t ? o.zoomOut(n).zoomOut(n) : o.zoomOut(n), m.isZooming = !0;
        break;
      case "Equal":
        d = t ? o.zoomIn(n).zoomIn(n) : o.zoomIn(n), m.isZooming = !0;
        break;
      case "ArrowLeft":
        t ? (d = o.rotateLeft(s), m.isRotating = !0) : (d = o.moveLeft(i), m.isPanning = !0);
        break;
      case "ArrowRight":
        t ? (d = o.rotateRight(s), m.isRotating = !0) : (d = o.moveRight(i), m.isPanning = !0);
        break;
      case "ArrowUp":
        t ? (d = o.rotateUp(l), m.isRotating = !0) : (d = o.moveUp(i), m.isPanning = !0);
        break;
      case "ArrowDown":
        t ? (d = o.rotateDown(l), m.isRotating = !0) : (d = o.moveDown(i), m.isPanning = !0);
        break;
      default:
        return !1;
    }
    return this.updateViewport(d, this._getTransitionProps(), m), !0;
  }
  _getTransitionProps(e) {
    const {
      transition: t
    } = this;
    return !t || !t.transitionInterpolator ? Mh : e ? {
      ...t,
      transitionInterpolator: new W2({
        ...e,
        ...t.transitionInterpolator.opts,
        makeViewport: this.controllerState.makeViewport
      })
    } : t;
  }
}
class PU {
  constructor(e, t) {
    this._viewportProps = this.applyConstraints(e), this._state = t;
  }
  getViewportProps() {
    return this._viewportProps;
  }
  getState() {
    return this._state;
  }
}
const JT = 5, RU = 1.2;
class Z5 extends PU {
  constructor(e) {
    const {
      /** Mapbox viewport properties */
      /** The width of the viewport */
      width: t,
      /** The height of the viewport */
      height: n,
      /** The latitude at the center of the viewport */
      latitude: i,
      /** The longitude at the center of the viewport */
      longitude: s,
      /** The tile zoom level of the map. */
      zoom: l,
      /** The bearing of the viewport in degrees */
      bearing: o = 0,
      /** The pitch of the viewport in degrees */
      pitch: d = 0,
      /**
       * Specify the altitude of the viewport camera
       * Unit: map heights, default 1.5
       * Non-public API, see https://github.com/mapbox/mapbox-gl-js/issues/1137
       */
      altitude: m = 1.5,
      /** Viewport position */
      position: b = [0, 0, 0],
      /** Viewport constraints */
      maxZoom: A = 20,
      minZoom: M = 0,
      maxPitch: E = 60,
      minPitch: k = 0,
      /** Interaction states, required to calculate change during transform */
      /* The point on map being grabbed when the operation first started */
      startPanLngLat: U,
      /* Center of the zoom when the operation first started */
      startZoomLngLat: V,
      /* Pointer position when rotation started */
      startRotatePos: q,
      /** Bearing when current perspective rotate operation started */
      startBearing: Y,
      /** Pitch when current perspective rotate operation started */
      startPitch: re,
      /** Zoom when current zoom operation started */
      startZoom: Z,
      /** Normalize viewport props to fit map height into viewport */
      normalize: K = !0
    } = e;
    ro(Number.isFinite(s)), ro(Number.isFinite(i)), ro(Number.isFinite(l)), super({
      width: t,
      height: n,
      latitude: i,
      longitude: s,
      zoom: l,
      bearing: o,
      pitch: d,
      altitude: m,
      maxZoom: A,
      minZoom: M,
      maxPitch: E,
      minPitch: k,
      normalize: K,
      position: b
    }, {
      startPanLngLat: U,
      startZoomLngLat: V,
      startRotatePos: q,
      startBearing: Y,
      startPitch: re,
      startZoom: Z
    }), this.makeViewport = e.makeViewport;
  }
  /**
   * Start panning
   * @param {[Number, Number]} pos - position on screen where the pointer grabs
   */
  panStart(e) {
    let {
      pos: t
    } = e;
    return this._getUpdatedState({
      startPanLngLat: this._unproject(t)
    });
  }
  /**
   * Pan
   * @param {[Number, Number]} pos - position on screen where the pointer is
   * @param {[Number, Number], optional} startPos - where the pointer grabbed at
   *   the start of the operation. Must be supplied of `panStart()` was not called
   */
  pan(e) {
    let {
      pos: t,
      startPos: n
    } = e;
    const i = this.getState().startPanLngLat || this._unproject(n);
    if (!i)
      return this;
    const l = this.makeViewport(this.getViewportProps()).panByPosition(i, t);
    return this._getUpdatedState(l);
  }
  /**
   * End panning
   * Must call if `panStart()` was called
   */
  panEnd() {
    return this._getUpdatedState({
      startPanLngLat: null
    });
  }
  /**
   * Start rotating
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  rotateStart(e) {
    let {
      pos: t
    } = e;
    return this._getUpdatedState({
      startRotatePos: t,
      startBearing: this.getViewportProps().bearing,
      startPitch: this.getViewportProps().pitch
    });
  }
  /**
   * Rotate
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  rotate(e) {
    let {
      pos: t,
      deltaAngleX: n = 0,
      deltaAngleY: i = 0
    } = e;
    const {
      startRotatePos: s,
      startBearing: l,
      startPitch: o
    } = this.getState();
    if (!s || l === void 0 || o === void 0)
      return this;
    let d;
    return t ? d = this._getNewRotation(t, s, o, l) : d = {
      bearing: l + n,
      pitch: o + i
    }, this._getUpdatedState(d);
  }
  /**
   * End rotating
   * Must call if `rotateStart()` was called
   */
  rotateEnd() {
    return this._getUpdatedState({
      startBearing: null,
      startPitch: null
    });
  }
  /**
   * Start zooming
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  zoomStart(e) {
    let {
      pos: t
    } = e;
    return this._getUpdatedState({
      startZoomLngLat: this._unproject(t),
      startZoom: this.getViewportProps().zoom
    });
  }
  /**
   * Zoom
   * @param {[Number, Number]} pos - position on screen where the current center is
   * @param {[Number, Number]} startPos - the center position at
   *   the start of the operation. Must be supplied of `zoomStart()` was not called
   * @param {Number} scale - a number between [0, 1] specifying the accumulated
   *   relative scale.
   */
  zoom(e) {
    let {
      pos: t,
      startPos: n,
      scale: i
    } = e, {
      startZoom: s,
      startZoomLngLat: l
    } = this.getState();
    if (l || (s = this.getViewportProps().zoom, l = this._unproject(n) || this._unproject(t)), !l)
      return this;
    const {
      maxZoom: o,
      minZoom: d
    } = this.getViewportProps();
    let m = s + Math.log2(i);
    m = Sc(m, d, o);
    const b = this.makeViewport({
      ...this.getViewportProps(),
      zoom: m
    });
    return this._getUpdatedState({
      zoom: m,
      ...b.panByPosition(l, t)
    });
  }
  /**
   * End zooming
   * Must call if `zoomStart()` was called
   */
  zoomEnd() {
    return this._getUpdatedState({
      startZoomLngLat: null,
      startZoom: null
    });
  }
  zoomIn() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 2;
    return this._zoomFromCenter(e);
  }
  zoomOut() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 2;
    return this._zoomFromCenter(1 / e);
  }
  moveLeft() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
    return this._panFromCenter([e, 0]);
  }
  moveRight() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
    return this._panFromCenter([-e, 0]);
  }
  moveUp() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
    return this._panFromCenter([0, e]);
  }
  moveDown() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
    return this._panFromCenter([0, -e]);
  }
  rotateLeft() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 15;
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing - e
    });
  }
  rotateRight() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 15;
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing + e
    });
  }
  rotateUp() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch + e
    });
  }
  rotateDown() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch - e
    });
  }
  shortestPathFrom(e) {
    const t = e.getViewportProps(), n = {
      ...this.getViewportProps()
    }, {
      bearing: i,
      longitude: s
    } = n;
    return Math.abs(i - t.bearing) > 180 && (n.bearing = i < 0 ? i + 360 : i - 360), Math.abs(s - t.longitude) > 180 && (n.longitude = s < 0 ? s + 360 : s - 360), n;
  }
  // Apply any constraints (mathematical or defined by _viewportProps) to map state
  applyConstraints(e) {
    const {
      maxZoom: t,
      minZoom: n,
      zoom: i
    } = e;
    e.zoom = Sc(i, n, t);
    const {
      maxPitch: s,
      minPitch: l,
      pitch: o
    } = e;
    e.pitch = Sc(o, l, s);
    const {
      normalize: d = !0
    } = e;
    return d && Object.assign(e, i8(e)), e;
  }
  /* Private methods */
  _zoomFromCenter(e) {
    const {
      width: t,
      height: n
    } = this.getViewportProps();
    return this.zoom({
      pos: [t / 2, n / 2],
      scale: e
    });
  }
  _panFromCenter(e) {
    const {
      width: t,
      height: n
    } = this.getViewportProps();
    return this.pan({
      startPos: [t / 2, n / 2],
      pos: [t / 2 + e[0], n / 2 + e[1]]
    });
  }
  _getUpdatedState(e) {
    return new this.constructor({
      makeViewport: this.makeViewport,
      ...this.getViewportProps(),
      ...this.getState(),
      ...e
    });
  }
  _unproject(e) {
    const t = this.makeViewport(this.getViewportProps());
    return e && t.unproject(e);
  }
  _getNewRotation(e, t, n, i) {
    const s = e[0] - t[0], l = e[1] - t[1], o = e[1], d = t[1], {
      width: m,
      height: b
    } = this.getViewportProps(), A = s / m;
    let M = 0;
    l > 0 ? Math.abs(b - d) > JT && (M = l / (d - b) * RU) : l < 0 && d > JT && (M = 1 - o / d), M = Sc(M, -1, 1);
    const {
      minPitch: E,
      maxPitch: k
    } = this.getViewportProps(), U = i + 180 * A;
    let V = n;
    return M > 0 ? V = n + M * (k - n) : M < 0 && (V = n - M * (E - n)), {
      pitch: V,
      bearing: U
    };
  }
}
class BU extends X5 {
  constructor() {
    super(...arguments), this.ControllerState = Z5, this.transition = {
      transitionDuration: 300,
      transitionInterpolator: new W2({
        transitionProps: {
          compare: ["longitude", "latitude", "zoom", "bearing", "pitch", "position"],
          required: ["longitude", "latitude", "zoom"]
        }
      })
    }, this.dragMode = "pan";
  }
  setProps(e) {
    e.position = e.position || [0, 0, 0];
    const t = this.props;
    super.setProps(e), (!t || t.height !== e.height) && this.updateViewport(new this.ControllerState({
      makeViewport: this.makeViewport,
      ...e,
      ...this.state
    }));
  }
}
class X2 extends W5 {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(e);
  }
  getViewportType() {
    return qf;
  }
  get ControllerType() {
    return BU;
  }
}
X2.displayName = "MapView";
const LU = new H2();
function OU(r, e) {
  const t = r.order ?? 1 / 0, n = e.order ?? 1 / 0;
  return t - n;
}
class kU {
  constructor(e) {
    this._resolvedEffects = [], this._defaultEffects = [], this.effects = [], this._context = e, this._needsRedraw = "Initial render", this._setEffects([]);
  }
  /**
   * Register a new default effect, i.e. an effect presents regardless of user supplied props.effects
   */
  addDefaultEffect(e) {
    const t = this._defaultEffects;
    if (!t.find((n) => n.id === e.id)) {
      const n = t.findIndex((i) => OU(i, e) > 0);
      n < 0 ? t.push(e) : t.splice(n, 0, e), e.setup(this._context), this._setEffects(this.effects);
    }
  }
  setProps(e) {
    "effects" in e && (Cc(e.effects, this.effects, 1) || this._setEffects(e.effects));
  }
  needsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    const t = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), t;
  }
  getEffects() {
    return this._resolvedEffects;
  }
  _setEffects(e) {
    const t = {};
    for (const i of this.effects)
      t[i.id] = i;
    const n = [];
    for (const i of e) {
      const s = t[i.id];
      let l = i;
      s && s !== i ? s.setProps ? (s.setProps(i.props), l = s) : s.cleanup(this._context) : s || i.setup(this._context), n.push(l), delete t[i.id];
    }
    for (const i in t)
      t[i].cleanup(this._context);
    this.effects = n, this._resolvedEffects = n.concat(this._defaultEffects), e.some((i) => i instanceof H2) || this._resolvedEffects.push(LU), this._needsRedraw = "effects changed";
  }
  finalize() {
    for (const e of this._resolvedEffects)
      e.cleanup(this._context);
    this.effects.length = 0, this._resolvedEffects.length = 0, this._defaultEffects.length = 0;
  }
}
class NU extends G2 {
  shouldDrawLayer(e) {
    const {
      operation: t
    } = e.props;
    return t.includes("draw") || t.includes("terrain");
  }
}
const DU = "deckRenderer.renderLayers";
class FU {
  constructor(e) {
    this.device = e, this.layerFilter = null, this.drawPickingColors = !1, this.drawLayersPass = new NU(e), this.pickLayersPass = new G5(e), this.renderCount = 0, this._needsRedraw = "Initial render", this.renderBuffers = [], this.lastPostProcessEffect = null;
  }
  setProps(e) {
    this.layerFilter !== e.layerFilter && (this.layerFilter = e.layerFilter, this._needsRedraw = "layerFilter changed"), this.drawPickingColors !== e.drawPickingColors && (this.drawPickingColors = e.drawPickingColors, this._needsRedraw = "drawPickingColors changed");
  }
  renderLayers(e) {
    if (!e.viewports.length)
      return;
    const t = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass, n = {
      layerFilter: this.layerFilter,
      isPicking: this.drawPickingColors,
      ...e
    };
    n.effects && this._preRender(n.effects, n);
    const i = this.lastPostProcessEffect ? this.renderBuffers[0] : n.target;
    this.lastPostProcessEffect && (n.clearColor = [0, 0, 0, 0], n.clearCanvas = !0);
    const s = t.render({
      ...n,
      target: i
    });
    n.effects && this._postRender(n.effects, n), this.renderCount++, ea(DU, this, s, e);
  }
  needsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    const t = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), t;
  }
  finalize() {
    const {
      renderBuffers: e
    } = this;
    for (const t of e)
      t.delete();
    e.length = 0;
  }
  _preRender(e, t) {
    this.lastPostProcessEffect = null, t.preRenderStats = t.preRenderStats || {};
    for (const n of e)
      t.preRenderStats[n.id] = n.preRender(t), n.postRender && (this.lastPostProcessEffect = n.id);
    this.lastPostProcessEffect && this._resizeRenderBuffers();
  }
  _resizeRenderBuffers() {
    const {
      renderBuffers: e
    } = this, t = this.device.canvasContext.getDrawingBufferSize();
    e.length === 0 && [0, 1].map((n) => {
      const i = this.device.createTexture({
        sampler: {
          minFilter: "linear",
          magFilter: "linear"
        }
      });
      e.push(this.device.createFramebuffer({
        id: `deck-renderbuffer-${n}`,
        colorAttachments: [i]
      }));
    });
    for (const n of e)
      n.resize(t);
  }
  _postRender(e, t) {
    const {
      renderBuffers: n
    } = this, i = {
      ...t,
      inputBuffer: n[0],
      swapBuffer: n[1]
    };
    for (const s of e)
      if (s.postRender) {
        i.target = s.id === this.lastPostProcessEffect ? t.target : void 0;
        const l = s.postRender(i);
        i.inputBuffer = l, i.swapBuffer = l === n[0] ? n[1] : n[0];
      }
  }
}
const UU = {
  pickedColor: null,
  pickedObjectIndex: -1
};
function zU(r) {
  let {
    pickedColors: e,
    decodePickingColor: t,
    deviceX: n,
    deviceY: i,
    deviceRadius: s,
    deviceRect: l
  } = r;
  const {
    x: o,
    y: d,
    width: m,
    height: b
  } = l;
  let A = s * s, M = -1, E = 0;
  for (let k = 0; k < b; k++) {
    const U = k + d - i, V = U * U;
    if (V > A)
      E += 4 * m;
    else
      for (let q = 0; q < m; q++) {
        if (e[E + 3] - 1 >= 0) {
          const re = q + o - n, Z = re * re + V;
          Z <= A && (A = Z, M = E);
        }
        E += 4;
      }
  }
  if (M >= 0) {
    const k = e.slice(M, M + 4), U = t(k);
    if (U) {
      const V = Math.floor(M / 4 / m), q = M / 4 - V * m;
      return {
        ...U,
        pickedColor: k,
        pickedX: o + q,
        pickedY: d + V
      };
    }
    Gn.error("Picked non-existent layer. Is picking buffer corrupt?")();
  }
  return UU;
}
function jU(r) {
  let {
    pickedColors: e,
    decodePickingColor: t
  } = r;
  const n = /* @__PURE__ */ new Map();
  if (e) {
    for (let i = 0; i < e.length; i += 4)
      if (e[i + 3] - 1 >= 0) {
        const l = e.slice(i, i + 4), o = l.join(",");
        if (!n.has(o)) {
          const d = t(l);
          d ? n.set(o, {
            ...d,
            color: l
          }) : Gn.error("Picked non-existent layer. Is picking buffer corrupt?")();
        }
      }
  }
  return Array.from(n.values());
}
function Y5(r) {
  let {
    pickInfo: e,
    viewports: t,
    pixelRatio: n,
    x: i,
    y: s,
    z: l
  } = r, o = t[0];
  t.length > 1 && (o = $U((e == null ? void 0 : e.pickedViewports) || t, {
    x: i,
    y: s
  }));
  let d;
  if (o) {
    const m = [i - o.x, s - o.y];
    l !== void 0 && (m[2] = l), d = o.unproject(m);
  }
  return {
    color: null,
    layer: null,
    viewport: o,
    index: -1,
    picked: !1,
    x: i,
    y: s,
    pixel: [i, s],
    coordinate: d,
    devicePixel: e && "pickedX" in e ? [e.pickedX, e.pickedY] : void 0,
    pixelRatio: n
  };
}
function VU(r) {
  const {
    pickInfo: e,
    lastPickedInfo: t,
    mode: n,
    layers: i
  } = r, {
    pickedColor: s,
    pickedLayer: l,
    pickedObjectIndex: o
  } = e, d = l ? [l] : [];
  if (n === "hover") {
    const A = t.index, M = t.layerId, E = l ? l.props.id : null;
    if (E !== M || o !== A) {
      if (E !== M) {
        const k = i.find((U) => U.props.id === M);
        k && d.unshift(k);
      }
      t.layerId = E, t.index = o, t.info = null;
    }
  }
  const m = Y5(r), b = /* @__PURE__ */ new Map();
  return b.set(null, m), d.forEach((A) => {
    let M = {
      ...m
    };
    A === l && (M.color = s, M.index = o, M.picked = !0), M = K5({
      layer: A,
      info: M,
      mode: n
    });
    const E = M.layer;
    A === l && n === "hover" && (t.info = M), b.set(E.id, M), n === "hover" && E.updateAutoHighlight(M);
  }), b;
}
function K5(r) {
  let {
    layer: e,
    info: t,
    mode: n
  } = r;
  for (; e && t; ) {
    const i = t.layer || null;
    t.sourceLayer = i, t.layer = e, t = e.getPickingInfo({
      info: t,
      mode: n,
      sourceLayer: i
    }), e = e.parent;
  }
  return t;
}
function $U(r, e) {
  for (let t = r.length - 1; t >= 0; t--) {
    const n = r[t];
    if (n.containsPixel(e))
      return n;
  }
  return r[0];
}
class qU {
  constructor(e) {
    this._pickable = !0, this.device = e, this.pickLayersPass = new G5(e), this.lastPickedInfo = {
      index: -1,
      layerId: null,
      info: null
    };
  }
  setProps(e) {
    "layerFilter" in e && (this.layerFilter = e.layerFilter), "_pickable" in e && (this._pickable = e._pickable);
  }
  finalize() {
    this.pickingFBO && this.pickingFBO.destroy(), this.depthFBO && this.depthFBO.destroy();
  }
  /** Pick the closest info at given coordinate */
  pickObject(e) {
    return this._pickClosestObject(e);
  }
  /** Get all unique infos within a bounding box */
  pickObjects(e) {
    return this._pickVisibleObjects(e);
  }
  // Returns a new picking info object by assuming the last picked object is still picked
  getLastPickedObject(e) {
    let {
      x: t,
      y: n,
      layers: i,
      viewports: s
    } = e, l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.lastPickedInfo.info;
    const o = l && l.layer && l.layer.id, d = l && l.viewport && l.viewport.id, m = o ? i.find((E) => E.id === o) : null, b = d && s.find((E) => E.id === d) || s[0], A = b && b.unproject([t - b.x, n - b.y]);
    return {
      ...l,
      ...{
        x: t,
        y: n,
        viewport: b,
        coordinate: A,
        layer: m
      }
    };
  }
  // Private
  /** Ensures that picking framebuffer exists and matches the canvas size */
  _resizeBuffer() {
    var t, n;
    if (!this.pickingFBO && (this.pickingFBO = this.device.createFramebuffer({
      colorAttachments: ["rgba8unorm"],
      depthStencilAttachment: "depth16unorm"
    }), this.device.isTextureFormatRenderable("rgba32float"))) {
      const i = this.device.createFramebuffer({
        colorAttachments: ["rgba32float"],
        depthStencilAttachment: "depth16unorm"
      });
      this.depthFBO = i;
    }
    const {
      canvas: e
    } = this.device.getDefaultCanvasContext();
    (t = this.pickingFBO) == null || t.resize({
      width: e.width,
      height: e.height
    }), (n = this.depthFBO) == null || n.resize({
      width: e.width,
      height: e.height
    });
  }
  /** Preliminary filtering of the layers list. Skid picking pass if no layer is pickable. */
  _getPickable(e) {
    if (this._pickable === !1)
      return null;
    const t = e.filter((n) => this.pickLayersPass.shouldDrawLayer(n) && !n.isComposite);
    return t.length ? t : null;
  }
  /** Pick the closest object at the given coordinate */
  // eslint-disable-next-line max-statements,complexity
  _pickClosestObject(e) {
    let {
      layers: t,
      views: n,
      viewports: i,
      x: s,
      y: l,
      radius: o = 0,
      depth: d = 1,
      mode: m = "query",
      unproject3D: b,
      onViewportActive: A,
      effects: M
    } = e;
    const E = this.device.canvasContext.cssToDeviceRatio(), k = this._getPickable(t);
    if (!k || i.length === 0)
      return {
        result: [],
        emptyInfo: Y5({
          viewports: i,
          x: s,
          y: l,
          pixelRatio: E
        })
      };
    this._resizeBuffer();
    const U = this.device.canvasContext.cssToDevicePixels([s, l], !0), V = [U.x + Math.floor(U.width / 2), U.y + Math.floor(U.height / 2)], q = Math.round(o * E), {
      width: Y,
      height: re
    } = this.pickingFBO, Z = this._getPickingRect({
      deviceX: V[0],
      deviceY: V[1],
      deviceRadius: q,
      deviceWidth: Y,
      deviceHeight: re
    }), K = {
      x: s - o,
      y: l - o,
      width: o * 2 + 1,
      height: o * 2 + 1
    };
    let ie;
    const be = [], he = /* @__PURE__ */ new Set();
    for (let Be = 0; Be < d; Be++) {
      let ke;
      if (Z) {
        const me = this._drawAndSample({
          layers: k,
          views: n,
          viewports: i,
          onViewportActive: A,
          deviceRect: Z,
          cullRect: K,
          effects: M,
          pass: `picking:${m}`
        });
        ke = zU({
          ...me,
          deviceX: V[0],
          deviceY: V[1],
          deviceRadius: q,
          deviceRect: Z
        });
      } else
        ke = {
          pickedColor: null,
          pickedObjectIndex: -1
        };
      let pe;
      if (ke.pickedLayer && b && this.depthFBO) {
        const {
          pickedColors: me
        } = this._drawAndSample({
          layers: [ke.pickedLayer],
          views: n,
          viewports: i,
          onViewportActive: A,
          deviceRect: {
            x: ke.pickedX,
            y: ke.pickedY,
            width: 1,
            height: 1
          },
          cullRect: K,
          effects: M,
          pass: `picking:${m}:z`
        }, !0);
        me[3] && (pe = me[0]);
      }
      ke.pickedLayer && Be + 1 < d && (he.add(ke.pickedLayer), ke.pickedLayer.disablePickingIndex(ke.pickedObjectIndex)), ie = VU({
        pickInfo: ke,
        lastPickedInfo: this.lastPickedInfo,
        mode: m,
        layers: k,
        viewports: i,
        x: s,
        y: l,
        z: pe,
        pixelRatio: E
      });
      for (const me of ie.values())
        me.layer && be.push(me);
      if (!ke.pickedColor)
        break;
    }
    for (const Be of he)
      Be.restorePickingColors();
    return {
      result: be,
      emptyInfo: ie.get(null)
    };
  }
  /** Pick all objects within the given bounding box */
  // eslint-disable-next-line max-statements
  _pickVisibleObjects(e) {
    let {
      layers: t,
      views: n,
      viewports: i,
      x: s,
      y: l,
      width: o = 1,
      height: d = 1,
      mode: m = "query",
      maxObjects: b = null,
      onViewportActive: A,
      effects: M
    } = e;
    const E = this._getPickable(t);
    if (!E || i.length === 0)
      return [];
    this._resizeBuffer();
    const k = this.device.canvasContext.cssToDeviceRatio(), U = this.device.canvasContext.cssToDevicePixels([s, l], !0), V = U.x, q = U.y + U.height, Y = this.device.canvasContext.cssToDevicePixels([s + o, l + d], !0), re = Y.x + Y.width, Z = Y.y, K = {
      x: V,
      y: Z,
      // deviceTop and deviceRight represent the first pixel outside the desired rect
      width: re - V,
      height: q - Z
    }, ie = this._drawAndSample({
      layers: E,
      views: n,
      viewports: i,
      onViewportActive: A,
      deviceRect: K,
      cullRect: {
        x: s,
        y: l,
        width: o,
        height: d
      },
      effects: M,
      pass: `picking:${m}`
    }), be = jU(ie), he = /* @__PURE__ */ new Map(), Be = [], ke = Number.isFinite(b);
    for (let pe = 0; pe < be.length && !(ke && Be.length >= b); pe++) {
      const me = be[pe];
      let je = {
        color: me.pickedColor,
        layer: null,
        index: me.pickedObjectIndex,
        picked: !0,
        x: s,
        y: l,
        pixelRatio: k
      };
      je = K5({
        layer: me.pickedLayer,
        info: je,
        mode: m
      });
      const Pe = je.layer.id;
      he.has(Pe) || he.set(Pe, /* @__PURE__ */ new Set());
      const St = he.get(Pe), Mt = je.object ?? je.index;
      St.has(Mt) || (St.add(Mt), Be.push(je));
    }
    return Be;
  }
  _drawAndSample(e) {
    let {
      layers: t,
      views: n,
      viewports: i,
      onViewportActive: s,
      deviceRect: l,
      cullRect: o,
      effects: d,
      pass: m
    } = e, b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    const A = b ? this.depthFBO : this.pickingFBO, M = {
      layers: t,
      layerFilter: this.layerFilter,
      views: n,
      viewports: i,
      onViewportActive: s,
      pickingFBO: A,
      deviceRect: l,
      cullRect: o,
      effects: d,
      pass: m,
      pickZ: b,
      preRenderStats: {},
      isPicking: !0
    };
    for (const re of d)
      re.useInPicking && (M.preRenderStats[re.id] = re.preRender(M));
    const {
      decodePickingColor: E
    } = this.pickLayersPass.render(M), {
      x: k,
      y: U,
      width: V,
      height: q
    } = l, Y = new (b ? Float32Array : Uint8Array)(V * q * 4);
    return this.device.readPixelsToArrayWebGL(A, {
      sourceX: k,
      sourceY: U,
      sourceWidth: V,
      sourceHeight: q,
      target: Y
    }), {
      pickedColors: Y,
      decodePickingColor: E
    };
  }
  // Calculate a picking rect centered on deviceX and deviceY and clipped to device
  // Returns null if pixel is outside of device
  _getPickingRect(e) {
    let {
      deviceX: t,
      deviceY: n,
      deviceRadius: i,
      deviceWidth: s,
      deviceHeight: l
    } = e;
    const o = Math.max(0, t - i), d = Math.max(0, n - i), m = Math.min(s, t + i + 1) - o, b = Math.min(l, n + i + 1) - d;
    return m <= 0 || b <= 0 ? null : {
      x: o,
      y: d,
      width: m,
      height: b
    };
  }
}
const GU = {
  "top-left": {
    top: 0,
    left: 0
  },
  "top-right": {
    top: 0,
    right: 0
  },
  "bottom-left": {
    bottom: 0,
    left: 0
  },
  "bottom-right": {
    bottom: 0,
    right: 0
  },
  fill: {
    top: 0,
    left: 0,
    bottom: 0,
    right: 0
  }
}, HU = "top-left", QT = "__root";
class WU {
  constructor(e) {
    let {
      deck: t,
      parentElement: n
    } = e;
    this.defaultWidgets = [], this.widgets = [], this.resolvedWidgets = [], this.containers = {}, this.lastViewports = {}, this.deck = t, this.parentElement = n;
  }
  getWidgets() {
    return this.resolvedWidgets;
  }
  /** Declarative API to configure widgets */
  setProps(e) {
    e.widgets && !Cc(e.widgets, this.widgets, 1) && this._setWidgets(e.widgets);
  }
  finalize() {
    for (const e of this.getWidgets())
      this._remove(e);
    this.defaultWidgets.length = 0, this.resolvedWidgets.length = 0;
    for (const e in this.containers)
      this.containers[e].remove();
  }
  /** Imperative API. Widgets added this way are not affected by the declarative prop. */
  addDefault(e) {
    this.defaultWidgets.find((t) => t.id === e.id) || (this._add(e), this.defaultWidgets.push(e), this._setWidgets(this.widgets));
  }
  /** Resolve widgets from the declarative prop */
  _setWidgets(e) {
    const t = {};
    for (const n of this.resolvedWidgets)
      t[n.id] = n;
    this.resolvedWidgets.length = 0;
    for (const n of this.defaultWidgets)
      t[n.id] = null, this.resolvedWidgets.push(n);
    for (let n of e) {
      const i = t[n.id];
      i ? /* Widget placement changed */ i.viewId !== n.viewId || i.placement !== n.placement ? (this._remove(i), this._add(n)) : n !== i && (i.setProps(n.props), n = i) : this._add(n), t[n.id] = null, this.resolvedWidgets.push(n);
    }
    for (const n in t) {
      const i = t[n];
      i && this._remove(i);
    }
    this.widgets = e;
  }
  _add(e) {
    const {
      viewId: t = null,
      placement: n = HU
    } = e, i = e.onAdd({
      deck: this.deck,
      viewId: t
    });
    i && this._getContainer(t, n).append(i), e._element = i;
  }
  _remove(e) {
    var t;
    (t = e.onRemove) == null || t.call(e), e._element && e._element.remove(), e._element = void 0;
  }
  /* global document */
  _getContainer(e, t) {
    var l;
    const n = e || QT;
    let i = this.containers[n];
    i || (i = document.createElement("div"), i.style.pointerEvents = "none", i.style.position = "absolute", i.style.overflow = "hidden", (l = this.parentElement) == null || l.append(i), this.containers[n] = i);
    let s = i.querySelector(`.${t}`);
    return s || (s = document.createElement("div"), s.className = t, s.style.position = "absolute", s.style.zIndex = "2", Object.assign(s.style, GU[t]), i.append(s)), s;
  }
  _updateContainers() {
    const e = this.deck.width, t = this.deck.height;
    for (const n in this.containers) {
      const i = this.lastViewports[n] || null, s = n === QT || i, l = this.containers[n];
      s ? (l.style.display = "block", l.style.left = `${i ? i.x : 0}px`, l.style.top = `${i ? i.y : 0}px`, l.style.width = `${i ? i.width : e}px`, l.style.height = `${i ? i.height : t}px`) : l.style.display = "none";
    }
  }
  onRedraw(e) {
    var s, l;
    let {
      viewports: t,
      layers: n
    } = e;
    const i = t.reduce((o, d) => (o[d.id] = d, o), {});
    for (const o of this.getWidgets()) {
      const {
        viewId: d
      } = o;
      if (d) {
        const m = i[d];
        m && (o.onViewportChange && o.onViewportChange(m), (s = o.onRedraw) == null || s.call(o, {
          viewports: [m],
          layers: n
        }));
      } else {
        if (o.onViewportChange)
          for (const m of t)
            o.onViewportChange(m);
        (l = o.onRedraw) == null || l.call(o, {
          viewports: t,
          layers: n
        });
      }
    }
    this.lastViewports = i, this._updateContainers();
  }
  onHover(e, t) {
    var n, i;
    for (const s of this.getWidgets()) {
      const {
        viewId: l
      } = s;
      (!l || l === ((n = e.viewport) == null ? void 0 : n.id)) && ((i = s.onHover) == null || i.call(s, e, t));
    }
  }
  onEvent(e, t) {
    var i, s;
    const n = sv[t.type];
    if (n)
      for (const l of this.getWidgets()) {
        const {
          viewId: o
        } = l;
        (!o || o === ((i = e.viewport) == null ? void 0 : i.id)) && ((s = l[n]) == null || s.call(l, e, t));
      }
  }
}
const XU = {
  zIndex: "1",
  position: "absolute",
  pointerEvents: "none",
  color: "#a0a7b4",
  backgroundColor: "#29323c",
  padding: "10px",
  top: "0",
  left: "0",
  display: "none"
};
class ZU {
  constructor() {
    this.id = "default-tooltip", this.placement = "fill", this.props = {}, this.isVisible = !1;
  }
  onAdd(e) {
    let {
      deck: t
    } = e;
    const n = document.createElement("div");
    return n.className = "deck-tooltip", Object.assign(n.style, XU), this.deck = t, this.element = n, n;
  }
  onRemove() {
    this.deck = void 0, this.element = void 0;
  }
  setProps() {
  }
  onViewportChange(e) {
    var t;
    this.isVisible && e.id === ((t = this.lastViewport) == null ? void 0 : t.id) && e !== this.lastViewport && this.setTooltip(null);
  }
  onHover(e) {
    const {
      deck: t
    } = this, n = t && t.props.getTooltip;
    if (!n)
      return;
    const i = n(e);
    this.lastViewport = e.viewport, this.setTooltip(i, e.x, e.y);
  }
  setTooltip(e, t, n) {
    const i = this.element;
    if (i) {
      if (typeof e == "string")
        i.innerText = e;
      else if (e)
        e.text && (i.innerText = e.text), e.html && (i.innerHTML = e.html), e.className && (i.className = e.className);
      else {
        this.isVisible = !1, i.style.display = "none";
        return;
      }
      this.isVisible = !0, i.style.display = "block", i.style.transform = `translate(${t}px, ${n}px)`, e && typeof e == "object" && "style" in e && Object.assign(i.style, e.style);
    }
  }
}
var Nd;
(function(r) {
  r[r.DEPTH_BUFFER_BIT = 256] = "DEPTH_BUFFER_BIT", r[r.STENCIL_BUFFER_BIT = 1024] = "STENCIL_BUFFER_BIT", r[r.COLOR_BUFFER_BIT = 16384] = "COLOR_BUFFER_BIT", r[r.POINTS = 0] = "POINTS", r[r.LINES = 1] = "LINES", r[r.LINE_LOOP = 2] = "LINE_LOOP", r[r.LINE_STRIP = 3] = "LINE_STRIP", r[r.TRIANGLES = 4] = "TRIANGLES", r[r.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", r[r.TRIANGLE_FAN = 6] = "TRIANGLE_FAN", r[r.ZERO = 0] = "ZERO", r[r.ONE = 1] = "ONE", r[r.SRC_COLOR = 768] = "SRC_COLOR", r[r.ONE_MINUS_SRC_COLOR = 769] = "ONE_MINUS_SRC_COLOR", r[r.SRC_ALPHA = 770] = "SRC_ALPHA", r[r.ONE_MINUS_SRC_ALPHA = 771] = "ONE_MINUS_SRC_ALPHA", r[r.DST_ALPHA = 772] = "DST_ALPHA", r[r.ONE_MINUS_DST_ALPHA = 773] = "ONE_MINUS_DST_ALPHA", r[r.DST_COLOR = 774] = "DST_COLOR", r[r.ONE_MINUS_DST_COLOR = 775] = "ONE_MINUS_DST_COLOR", r[r.SRC_ALPHA_SATURATE = 776] = "SRC_ALPHA_SATURATE", r[r.CONSTANT_COLOR = 32769] = "CONSTANT_COLOR", r[r.ONE_MINUS_CONSTANT_COLOR = 32770] = "ONE_MINUS_CONSTANT_COLOR", r[r.CONSTANT_ALPHA = 32771] = "CONSTANT_ALPHA", r[r.ONE_MINUS_CONSTANT_ALPHA = 32772] = "ONE_MINUS_CONSTANT_ALPHA", r[r.FUNC_ADD = 32774] = "FUNC_ADD", r[r.FUNC_SUBTRACT = 32778] = "FUNC_SUBTRACT", r[r.FUNC_REVERSE_SUBTRACT = 32779] = "FUNC_REVERSE_SUBTRACT", r[r.BLEND_EQUATION = 32777] = "BLEND_EQUATION", r[r.BLEND_EQUATION_RGB = 32777] = "BLEND_EQUATION_RGB", r[r.BLEND_EQUATION_ALPHA = 34877] = "BLEND_EQUATION_ALPHA", r[r.BLEND_DST_RGB = 32968] = "BLEND_DST_RGB", r[r.BLEND_SRC_RGB = 32969] = "BLEND_SRC_RGB", r[r.BLEND_DST_ALPHA = 32970] = "BLEND_DST_ALPHA", r[r.BLEND_SRC_ALPHA = 32971] = "BLEND_SRC_ALPHA", r[r.BLEND_COLOR = 32773] = "BLEND_COLOR", r[r.ARRAY_BUFFER_BINDING = 34964] = "ARRAY_BUFFER_BINDING", r[r.ELEMENT_ARRAY_BUFFER_BINDING = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING", r[r.LINE_WIDTH = 2849] = "LINE_WIDTH", r[r.ALIASED_POINT_SIZE_RANGE = 33901] = "ALIASED_POINT_SIZE_RANGE", r[r.ALIASED_LINE_WIDTH_RANGE = 33902] = "ALIASED_LINE_WIDTH_RANGE", r[r.CULL_FACE_MODE = 2885] = "CULL_FACE_MODE", r[r.FRONT_FACE = 2886] = "FRONT_FACE", r[r.DEPTH_RANGE = 2928] = "DEPTH_RANGE", r[r.DEPTH_WRITEMASK = 2930] = "DEPTH_WRITEMASK", r[r.DEPTH_CLEAR_VALUE = 2931] = "DEPTH_CLEAR_VALUE", r[r.DEPTH_FUNC = 2932] = "DEPTH_FUNC", r[r.STENCIL_CLEAR_VALUE = 2961] = "STENCIL_CLEAR_VALUE", r[r.STENCIL_FUNC = 2962] = "STENCIL_FUNC", r[r.STENCIL_FAIL = 2964] = "STENCIL_FAIL", r[r.STENCIL_PASS_DEPTH_FAIL = 2965] = "STENCIL_PASS_DEPTH_FAIL", r[r.STENCIL_PASS_DEPTH_PASS = 2966] = "STENCIL_PASS_DEPTH_PASS", r[r.STENCIL_REF = 2967] = "STENCIL_REF", r[r.STENCIL_VALUE_MASK = 2963] = "STENCIL_VALUE_MASK", r[r.STENCIL_WRITEMASK = 2968] = "STENCIL_WRITEMASK", r[r.STENCIL_BACK_FUNC = 34816] = "STENCIL_BACK_FUNC", r[r.STENCIL_BACK_FAIL = 34817] = "STENCIL_BACK_FAIL", r[r.STENCIL_BACK_PASS_DEPTH_FAIL = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL", r[r.STENCIL_BACK_PASS_DEPTH_PASS = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS", r[r.STENCIL_BACK_REF = 36003] = "STENCIL_BACK_REF", r[r.STENCIL_BACK_VALUE_MASK = 36004] = "STENCIL_BACK_VALUE_MASK", r[r.STENCIL_BACK_WRITEMASK = 36005] = "STENCIL_BACK_WRITEMASK", r[r.VIEWPORT = 2978] = "VIEWPORT", r[r.SCISSOR_BOX = 3088] = "SCISSOR_BOX", r[r.COLOR_CLEAR_VALUE = 3106] = "COLOR_CLEAR_VALUE", r[r.COLOR_WRITEMASK = 3107] = "COLOR_WRITEMASK", r[r.UNPACK_ALIGNMENT = 3317] = "UNPACK_ALIGNMENT", r[r.PACK_ALIGNMENT = 3333] = "PACK_ALIGNMENT", r[r.MAX_TEXTURE_SIZE = 3379] = "MAX_TEXTURE_SIZE", r[r.MAX_VIEWPORT_DIMS = 3386] = "MAX_VIEWPORT_DIMS", r[r.SUBPIXEL_BITS = 3408] = "SUBPIXEL_BITS", r[r.RED_BITS = 3410] = "RED_BITS", r[r.GREEN_BITS = 3411] = "GREEN_BITS", r[r.BLUE_BITS = 3412] = "BLUE_BITS", r[r.ALPHA_BITS = 3413] = "ALPHA_BITS", r[r.DEPTH_BITS = 3414] = "DEPTH_BITS", r[r.STENCIL_BITS = 3415] = "STENCIL_BITS", r[r.POLYGON_OFFSET_UNITS = 10752] = "POLYGON_OFFSET_UNITS", r[r.POLYGON_OFFSET_FACTOR = 32824] = "POLYGON_OFFSET_FACTOR", r[r.TEXTURE_BINDING_2D = 32873] = "TEXTURE_BINDING_2D", r[r.SAMPLE_BUFFERS = 32936] = "SAMPLE_BUFFERS", r[r.SAMPLES = 32937] = "SAMPLES", r[r.SAMPLE_COVERAGE_VALUE = 32938] = "SAMPLE_COVERAGE_VALUE", r[r.SAMPLE_COVERAGE_INVERT = 32939] = "SAMPLE_COVERAGE_INVERT", r[r.COMPRESSED_TEXTURE_FORMATS = 34467] = "COMPRESSED_TEXTURE_FORMATS", r[r.VENDOR = 7936] = "VENDOR", r[r.RENDERER = 7937] = "RENDERER", r[r.VERSION = 7938] = "VERSION", r[r.IMPLEMENTATION_COLOR_READ_TYPE = 35738] = "IMPLEMENTATION_COLOR_READ_TYPE", r[r.IMPLEMENTATION_COLOR_READ_FORMAT = 35739] = "IMPLEMENTATION_COLOR_READ_FORMAT", r[r.BROWSER_DEFAULT_WEBGL = 37444] = "BROWSER_DEFAULT_WEBGL", r[r.STATIC_DRAW = 35044] = "STATIC_DRAW", r[r.STREAM_DRAW = 35040] = "STREAM_DRAW", r[r.DYNAMIC_DRAW = 35048] = "DYNAMIC_DRAW", r[r.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", r[r.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", r[r.BUFFER_SIZE = 34660] = "BUFFER_SIZE", r[r.BUFFER_USAGE = 34661] = "BUFFER_USAGE", r[r.CURRENT_VERTEX_ATTRIB = 34342] = "CURRENT_VERTEX_ATTRIB", r[r.VERTEX_ATTRIB_ARRAY_ENABLED = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED", r[r.VERTEX_ATTRIB_ARRAY_SIZE = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE", r[r.VERTEX_ATTRIB_ARRAY_STRIDE = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE", r[r.VERTEX_ATTRIB_ARRAY_TYPE = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE", r[r.VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED", r[r.VERTEX_ATTRIB_ARRAY_POINTER = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER", r[r.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING", r[r.CULL_FACE = 2884] = "CULL_FACE", r[r.FRONT = 1028] = "FRONT", r[r.BACK = 1029] = "BACK", r[r.FRONT_AND_BACK = 1032] = "FRONT_AND_BACK", r[r.BLEND = 3042] = "BLEND", r[r.DEPTH_TEST = 2929] = "DEPTH_TEST", r[r.DITHER = 3024] = "DITHER", r[r.POLYGON_OFFSET_FILL = 32823] = "POLYGON_OFFSET_FILL", r[r.SAMPLE_ALPHA_TO_COVERAGE = 32926] = "SAMPLE_ALPHA_TO_COVERAGE", r[r.SAMPLE_COVERAGE = 32928] = "SAMPLE_COVERAGE", r[r.SCISSOR_TEST = 3089] = "SCISSOR_TEST", r[r.STENCIL_TEST = 2960] = "STENCIL_TEST", r[r.NO_ERROR = 0] = "NO_ERROR", r[r.INVALID_ENUM = 1280] = "INVALID_ENUM", r[r.INVALID_VALUE = 1281] = "INVALID_VALUE", r[r.INVALID_OPERATION = 1282] = "INVALID_OPERATION", r[r.OUT_OF_MEMORY = 1285] = "OUT_OF_MEMORY", r[r.CONTEXT_LOST_WEBGL = 37442] = "CONTEXT_LOST_WEBGL", r[r.CW = 2304] = "CW", r[r.CCW = 2305] = "CCW", r[r.DONT_CARE = 4352] = "DONT_CARE", r[r.FASTEST = 4353] = "FASTEST", r[r.NICEST = 4354] = "NICEST", r[r.GENERATE_MIPMAP_HINT = 33170] = "GENERATE_MIPMAP_HINT", r[r.BYTE = 5120] = "BYTE", r[r.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", r[r.SHORT = 5122] = "SHORT", r[r.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", r[r.INT = 5124] = "INT", r[r.UNSIGNED_INT = 5125] = "UNSIGNED_INT", r[r.FLOAT = 5126] = "FLOAT", r[r.DOUBLE = 5130] = "DOUBLE", r[r.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", r[r.ALPHA = 6406] = "ALPHA", r[r.RGB = 6407] = "RGB", r[r.RGBA = 6408] = "RGBA", r[r.LUMINANCE = 6409] = "LUMINANCE", r[r.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", r[r.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", r[r.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", r[r.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", r[r.FRAGMENT_SHADER = 35632] = "FRAGMENT_SHADER", r[r.VERTEX_SHADER = 35633] = "VERTEX_SHADER", r[r.COMPILE_STATUS = 35713] = "COMPILE_STATUS", r[r.DELETE_STATUS = 35712] = "DELETE_STATUS", r[r.LINK_STATUS = 35714] = "LINK_STATUS", r[r.VALIDATE_STATUS = 35715] = "VALIDATE_STATUS", r[r.ATTACHED_SHADERS = 35717] = "ATTACHED_SHADERS", r[r.ACTIVE_ATTRIBUTES = 35721] = "ACTIVE_ATTRIBUTES", r[r.ACTIVE_UNIFORMS = 35718] = "ACTIVE_UNIFORMS", r[r.MAX_VERTEX_ATTRIBS = 34921] = "MAX_VERTEX_ATTRIBS", r[r.MAX_VERTEX_UNIFORM_VECTORS = 36347] = "MAX_VERTEX_UNIFORM_VECTORS", r[r.MAX_VARYING_VECTORS = 36348] = "MAX_VARYING_VECTORS", r[r.MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS", r[r.MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS", r[r.MAX_TEXTURE_IMAGE_UNITS = 34930] = "MAX_TEXTURE_IMAGE_UNITS", r[r.MAX_FRAGMENT_UNIFORM_VECTORS = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS", r[r.SHADER_TYPE = 35663] = "SHADER_TYPE", r[r.SHADING_LANGUAGE_VERSION = 35724] = "SHADING_LANGUAGE_VERSION", r[r.CURRENT_PROGRAM = 35725] = "CURRENT_PROGRAM", r[r.NEVER = 512] = "NEVER", r[r.LESS = 513] = "LESS", r[r.EQUAL = 514] = "EQUAL", r[r.LEQUAL = 515] = "LEQUAL", r[r.GREATER = 516] = "GREATER", r[r.NOTEQUAL = 517] = "NOTEQUAL", r[r.GEQUAL = 518] = "GEQUAL", r[r.ALWAYS = 519] = "ALWAYS", r[r.KEEP = 7680] = "KEEP", r[r.REPLACE = 7681] = "REPLACE", r[r.INCR = 7682] = "INCR", r[r.DECR = 7683] = "DECR", r[r.INVERT = 5386] = "INVERT", r[r.INCR_WRAP = 34055] = "INCR_WRAP", r[r.DECR_WRAP = 34056] = "DECR_WRAP", r[r.NEAREST = 9728] = "NEAREST", r[r.LINEAR = 9729] = "LINEAR", r[r.NEAREST_MIPMAP_NEAREST = 9984] = "NEAREST_MIPMAP_NEAREST", r[r.LINEAR_MIPMAP_NEAREST = 9985] = "LINEAR_MIPMAP_NEAREST", r[r.NEAREST_MIPMAP_LINEAR = 9986] = "NEAREST_MIPMAP_LINEAR", r[r.LINEAR_MIPMAP_LINEAR = 9987] = "LINEAR_MIPMAP_LINEAR", r[r.TEXTURE_MAG_FILTER = 10240] = "TEXTURE_MAG_FILTER", r[r.TEXTURE_MIN_FILTER = 10241] = "TEXTURE_MIN_FILTER", r[r.TEXTURE_WRAP_S = 10242] = "TEXTURE_WRAP_S", r[r.TEXTURE_WRAP_T = 10243] = "TEXTURE_WRAP_T", r[r.TEXTURE_2D = 3553] = "TEXTURE_2D", r[r.TEXTURE = 5890] = "TEXTURE", r[r.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", r[r.TEXTURE_BINDING_CUBE_MAP = 34068] = "TEXTURE_BINDING_CUBE_MAP", r[r.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", r[r.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", r[r.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", r[r.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", r[r.MAX_CUBE_MAP_TEXTURE_SIZE = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE", r[r.TEXTURE0 = 33984] = "TEXTURE0", r[r.ACTIVE_TEXTURE = 34016] = "ACTIVE_TEXTURE", r[r.REPEAT = 10497] = "REPEAT", r[r.CLAMP_TO_EDGE = 33071] = "CLAMP_TO_EDGE", r[r.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", r[r.TEXTURE_WIDTH = 4096] = "TEXTURE_WIDTH", r[r.TEXTURE_HEIGHT = 4097] = "TEXTURE_HEIGHT", r[r.FLOAT_VEC2 = 35664] = "FLOAT_VEC2", r[r.FLOAT_VEC3 = 35665] = "FLOAT_VEC3", r[r.FLOAT_VEC4 = 35666] = "FLOAT_VEC4", r[r.INT_VEC2 = 35667] = "INT_VEC2", r[r.INT_VEC3 = 35668] = "INT_VEC3", r[r.INT_VEC4 = 35669] = "INT_VEC4", r[r.BOOL = 35670] = "BOOL", r[r.BOOL_VEC2 = 35671] = "BOOL_VEC2", r[r.BOOL_VEC3 = 35672] = "BOOL_VEC3", r[r.BOOL_VEC4 = 35673] = "BOOL_VEC4", r[r.FLOAT_MAT2 = 35674] = "FLOAT_MAT2", r[r.FLOAT_MAT3 = 35675] = "FLOAT_MAT3", r[r.FLOAT_MAT4 = 35676] = "FLOAT_MAT4", r[r.SAMPLER_2D = 35678] = "SAMPLER_2D", r[r.SAMPLER_CUBE = 35680] = "SAMPLER_CUBE", r[r.LOW_FLOAT = 36336] = "LOW_FLOAT", r[r.MEDIUM_FLOAT = 36337] = "MEDIUM_FLOAT", r[r.HIGH_FLOAT = 36338] = "HIGH_FLOAT", r[r.LOW_INT = 36339] = "LOW_INT", r[r.MEDIUM_INT = 36340] = "MEDIUM_INT", r[r.HIGH_INT = 36341] = "HIGH_INT", r[r.FRAMEBUFFER = 36160] = "FRAMEBUFFER", r[r.RENDERBUFFER = 36161] = "RENDERBUFFER", r[r.RGBA4 = 32854] = "RGBA4", r[r.RGB5_A1 = 32855] = "RGB5_A1", r[r.RGB565 = 36194] = "RGB565", r[r.DEPTH_COMPONENT16 = 33189] = "DEPTH_COMPONENT16", r[r.STENCIL_INDEX = 6401] = "STENCIL_INDEX", r[r.STENCIL_INDEX8 = 36168] = "STENCIL_INDEX8", r[r.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", r[r.RENDERBUFFER_WIDTH = 36162] = "RENDERBUFFER_WIDTH", r[r.RENDERBUFFER_HEIGHT = 36163] = "RENDERBUFFER_HEIGHT", r[r.RENDERBUFFER_INTERNAL_FORMAT = 36164] = "RENDERBUFFER_INTERNAL_FORMAT", r[r.RENDERBUFFER_RED_SIZE = 36176] = "RENDERBUFFER_RED_SIZE", r[r.RENDERBUFFER_GREEN_SIZE = 36177] = "RENDERBUFFER_GREEN_SIZE", r[r.RENDERBUFFER_BLUE_SIZE = 36178] = "RENDERBUFFER_BLUE_SIZE", r[r.RENDERBUFFER_ALPHA_SIZE = 36179] = "RENDERBUFFER_ALPHA_SIZE", r[r.RENDERBUFFER_DEPTH_SIZE = 36180] = "RENDERBUFFER_DEPTH_SIZE", r[r.RENDERBUFFER_STENCIL_SIZE = 36181] = "RENDERBUFFER_STENCIL_SIZE", r[r.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE", r[r.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME", r[r.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL", r[r.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE", r[r.COLOR_ATTACHMENT0 = 36064] = "COLOR_ATTACHMENT0", r[r.DEPTH_ATTACHMENT = 36096] = "DEPTH_ATTACHMENT", r[r.STENCIL_ATTACHMENT = 36128] = "STENCIL_ATTACHMENT", r[r.DEPTH_STENCIL_ATTACHMENT = 33306] = "DEPTH_STENCIL_ATTACHMENT", r[r.NONE = 0] = "NONE", r[r.FRAMEBUFFER_COMPLETE = 36053] = "FRAMEBUFFER_COMPLETE", r[r.FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT", r[r.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT", r[r.FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS", r[r.FRAMEBUFFER_UNSUPPORTED = 36061] = "FRAMEBUFFER_UNSUPPORTED", r[r.FRAMEBUFFER_BINDING = 36006] = "FRAMEBUFFER_BINDING", r[r.RENDERBUFFER_BINDING = 36007] = "RENDERBUFFER_BINDING", r[r.READ_FRAMEBUFFER = 36008] = "READ_FRAMEBUFFER", r[r.DRAW_FRAMEBUFFER = 36009] = "DRAW_FRAMEBUFFER", r[r.MAX_RENDERBUFFER_SIZE = 34024] = "MAX_RENDERBUFFER_SIZE", r[r.INVALID_FRAMEBUFFER_OPERATION = 1286] = "INVALID_FRAMEBUFFER_OPERATION", r[r.UNPACK_FLIP_Y_WEBGL = 37440] = "UNPACK_FLIP_Y_WEBGL", r[r.UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL", r[r.UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL", r[r.READ_BUFFER = 3074] = "READ_BUFFER", r[r.UNPACK_ROW_LENGTH = 3314] = "UNPACK_ROW_LENGTH", r[r.UNPACK_SKIP_ROWS = 3315] = "UNPACK_SKIP_ROWS", r[r.UNPACK_SKIP_PIXELS = 3316] = "UNPACK_SKIP_PIXELS", r[r.PACK_ROW_LENGTH = 3330] = "PACK_ROW_LENGTH", r[r.PACK_SKIP_ROWS = 3331] = "PACK_SKIP_ROWS", r[r.PACK_SKIP_PIXELS = 3332] = "PACK_SKIP_PIXELS", r[r.TEXTURE_BINDING_3D = 32874] = "TEXTURE_BINDING_3D", r[r.UNPACK_SKIP_IMAGES = 32877] = "UNPACK_SKIP_IMAGES", r[r.UNPACK_IMAGE_HEIGHT = 32878] = "UNPACK_IMAGE_HEIGHT", r[r.MAX_3D_TEXTURE_SIZE = 32883] = "MAX_3D_TEXTURE_SIZE", r[r.MAX_ELEMENTS_VERTICES = 33e3] = "MAX_ELEMENTS_VERTICES", r[r.MAX_ELEMENTS_INDICES = 33001] = "MAX_ELEMENTS_INDICES", r[r.MAX_TEXTURE_LOD_BIAS = 34045] = "MAX_TEXTURE_LOD_BIAS", r[r.MAX_FRAGMENT_UNIFORM_COMPONENTS = 35657] = "MAX_FRAGMENT_UNIFORM_COMPONENTS", r[r.MAX_VERTEX_UNIFORM_COMPONENTS = 35658] = "MAX_VERTEX_UNIFORM_COMPONENTS", r[r.MAX_ARRAY_TEXTURE_LAYERS = 35071] = "MAX_ARRAY_TEXTURE_LAYERS", r[r.MIN_PROGRAM_TEXEL_OFFSET = 35076] = "MIN_PROGRAM_TEXEL_OFFSET", r[r.MAX_PROGRAM_TEXEL_OFFSET = 35077] = "MAX_PROGRAM_TEXEL_OFFSET", r[r.MAX_VARYING_COMPONENTS = 35659] = "MAX_VARYING_COMPONENTS", r[r.FRAGMENT_SHADER_DERIVATIVE_HINT = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT", r[r.RASTERIZER_DISCARD = 35977] = "RASTERIZER_DISCARD", r[r.VERTEX_ARRAY_BINDING = 34229] = "VERTEX_ARRAY_BINDING", r[r.MAX_VERTEX_OUTPUT_COMPONENTS = 37154] = "MAX_VERTEX_OUTPUT_COMPONENTS", r[r.MAX_FRAGMENT_INPUT_COMPONENTS = 37157] = "MAX_FRAGMENT_INPUT_COMPONENTS", r[r.MAX_SERVER_WAIT_TIMEOUT = 37137] = "MAX_SERVER_WAIT_TIMEOUT", r[r.MAX_ELEMENT_INDEX = 36203] = "MAX_ELEMENT_INDEX", r[r.RED = 6403] = "RED", r[r.RGB8 = 32849] = "RGB8", r[r.RGBA8 = 32856] = "RGBA8", r[r.RGB10_A2 = 32857] = "RGB10_A2", r[r.TEXTURE_3D = 32879] = "TEXTURE_3D", r[r.TEXTURE_WRAP_R = 32882] = "TEXTURE_WRAP_R", r[r.TEXTURE_MIN_LOD = 33082] = "TEXTURE_MIN_LOD", r[r.TEXTURE_MAX_LOD = 33083] = "TEXTURE_MAX_LOD", r[r.TEXTURE_BASE_LEVEL = 33084] = "TEXTURE_BASE_LEVEL", r[r.TEXTURE_MAX_LEVEL = 33085] = "TEXTURE_MAX_LEVEL", r[r.TEXTURE_COMPARE_MODE = 34892] = "TEXTURE_COMPARE_MODE", r[r.TEXTURE_COMPARE_FUNC = 34893] = "TEXTURE_COMPARE_FUNC", r[r.SRGB = 35904] = "SRGB", r[r.SRGB8 = 35905] = "SRGB8", r[r.SRGB8_ALPHA8 = 35907] = "SRGB8_ALPHA8", r[r.COMPARE_REF_TO_TEXTURE = 34894] = "COMPARE_REF_TO_TEXTURE", r[r.RGBA32F = 34836] = "RGBA32F", r[r.RGB32F = 34837] = "RGB32F", r[r.RGBA16F = 34842] = "RGBA16F", r[r.RGB16F = 34843] = "RGB16F", r[r.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", r[r.TEXTURE_BINDING_2D_ARRAY = 35869] = "TEXTURE_BINDING_2D_ARRAY", r[r.R11F_G11F_B10F = 35898] = "R11F_G11F_B10F", r[r.RGB9_E5 = 35901] = "RGB9_E5", r[r.RGBA32UI = 36208] = "RGBA32UI", r[r.RGB32UI = 36209] = "RGB32UI", r[r.RGBA16UI = 36214] = "RGBA16UI", r[r.RGB16UI = 36215] = "RGB16UI", r[r.RGBA8UI = 36220] = "RGBA8UI", r[r.RGB8UI = 36221] = "RGB8UI", r[r.RGBA32I = 36226] = "RGBA32I", r[r.RGB32I = 36227] = "RGB32I", r[r.RGBA16I = 36232] = "RGBA16I", r[r.RGB16I = 36233] = "RGB16I", r[r.RGBA8I = 36238] = "RGBA8I", r[r.RGB8I = 36239] = "RGB8I", r[r.RED_INTEGER = 36244] = "RED_INTEGER", r[r.RGB_INTEGER = 36248] = "RGB_INTEGER", r[r.RGBA_INTEGER = 36249] = "RGBA_INTEGER", r[r.R8 = 33321] = "R8", r[r.RG8 = 33323] = "RG8", r[r.R16F = 33325] = "R16F", r[r.R32F = 33326] = "R32F", r[r.RG16F = 33327] = "RG16F", r[r.RG32F = 33328] = "RG32F", r[r.R8I = 33329] = "R8I", r[r.R8UI = 33330] = "R8UI", r[r.R16I = 33331] = "R16I", r[r.R16UI = 33332] = "R16UI", r[r.R32I = 33333] = "R32I", r[r.R32UI = 33334] = "R32UI", r[r.RG8I = 33335] = "RG8I", r[r.RG8UI = 33336] = "RG8UI", r[r.RG16I = 33337] = "RG16I", r[r.RG16UI = 33338] = "RG16UI", r[r.RG32I = 33339] = "RG32I", r[r.RG32UI = 33340] = "RG32UI", r[r.R8_SNORM = 36756] = "R8_SNORM", r[r.RG8_SNORM = 36757] = "RG8_SNORM", r[r.RGB8_SNORM = 36758] = "RGB8_SNORM", r[r.RGBA8_SNORM = 36759] = "RGBA8_SNORM", r[r.RGB10_A2UI = 36975] = "RGB10_A2UI", r[r.TEXTURE_IMMUTABLE_FORMAT = 37167] = "TEXTURE_IMMUTABLE_FORMAT", r[r.TEXTURE_IMMUTABLE_LEVELS = 33503] = "TEXTURE_IMMUTABLE_LEVELS", r[r.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", r[r.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", r[r.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", r[r.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", r[r.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", r[r.HALF_FLOAT = 5131] = "HALF_FLOAT", r[r.RG = 33319] = "RG", r[r.RG_INTEGER = 33320] = "RG_INTEGER", r[r.INT_2_10_10_10_REV = 36255] = "INT_2_10_10_10_REV", r[r.CURRENT_QUERY = 34917] = "CURRENT_QUERY", r[r.QUERY_RESULT = 34918] = "QUERY_RESULT", r[r.QUERY_RESULT_AVAILABLE = 34919] = "QUERY_RESULT_AVAILABLE", r[r.ANY_SAMPLES_PASSED = 35887] = "ANY_SAMPLES_PASSED", r[r.ANY_SAMPLES_PASSED_CONSERVATIVE = 36202] = "ANY_SAMPLES_PASSED_CONSERVATIVE", r[r.MAX_DRAW_BUFFERS = 34852] = "MAX_DRAW_BUFFERS", r[r.DRAW_BUFFER0 = 34853] = "DRAW_BUFFER0", r[r.DRAW_BUFFER1 = 34854] = "DRAW_BUFFER1", r[r.DRAW_BUFFER2 = 34855] = "DRAW_BUFFER2", r[r.DRAW_BUFFER3 = 34856] = "DRAW_BUFFER3", r[r.DRAW_BUFFER4 = 34857] = "DRAW_BUFFER4", r[r.DRAW_BUFFER5 = 34858] = "DRAW_BUFFER5", r[r.DRAW_BUFFER6 = 34859] = "DRAW_BUFFER6", r[r.DRAW_BUFFER7 = 34860] = "DRAW_BUFFER7", r[r.DRAW_BUFFER8 = 34861] = "DRAW_BUFFER8", r[r.DRAW_BUFFER9 = 34862] = "DRAW_BUFFER9", r[r.DRAW_BUFFER10 = 34863] = "DRAW_BUFFER10", r[r.DRAW_BUFFER11 = 34864] = "DRAW_BUFFER11", r[r.DRAW_BUFFER12 = 34865] = "DRAW_BUFFER12", r[r.DRAW_BUFFER13 = 34866] = "DRAW_BUFFER13", r[r.DRAW_BUFFER14 = 34867] = "DRAW_BUFFER14", r[r.DRAW_BUFFER15 = 34868] = "DRAW_BUFFER15", r[r.MAX_COLOR_ATTACHMENTS = 36063] = "MAX_COLOR_ATTACHMENTS", r[r.COLOR_ATTACHMENT1 = 36065] = "COLOR_ATTACHMENT1", r[r.COLOR_ATTACHMENT2 = 36066] = "COLOR_ATTACHMENT2", r[r.COLOR_ATTACHMENT3 = 36067] = "COLOR_ATTACHMENT3", r[r.COLOR_ATTACHMENT4 = 36068] = "COLOR_ATTACHMENT4", r[r.COLOR_ATTACHMENT5 = 36069] = "COLOR_ATTACHMENT5", r[r.COLOR_ATTACHMENT6 = 36070] = "COLOR_ATTACHMENT6", r[r.COLOR_ATTACHMENT7 = 36071] = "COLOR_ATTACHMENT7", r[r.COLOR_ATTACHMENT8 = 36072] = "COLOR_ATTACHMENT8", r[r.COLOR_ATTACHMENT9 = 36073] = "COLOR_ATTACHMENT9", r[r.COLOR_ATTACHMENT10 = 36074] = "COLOR_ATTACHMENT10", r[r.COLOR_ATTACHMENT11 = 36075] = "COLOR_ATTACHMENT11", r[r.COLOR_ATTACHMENT12 = 36076] = "COLOR_ATTACHMENT12", r[r.COLOR_ATTACHMENT13 = 36077] = "COLOR_ATTACHMENT13", r[r.COLOR_ATTACHMENT14 = 36078] = "COLOR_ATTACHMENT14", r[r.COLOR_ATTACHMENT15 = 36079] = "COLOR_ATTACHMENT15", r[r.SAMPLER_3D = 35679] = "SAMPLER_3D", r[r.SAMPLER_2D_SHADOW = 35682] = "SAMPLER_2D_SHADOW", r[r.SAMPLER_2D_ARRAY = 36289] = "SAMPLER_2D_ARRAY", r[r.SAMPLER_2D_ARRAY_SHADOW = 36292] = "SAMPLER_2D_ARRAY_SHADOW", r[r.SAMPLER_CUBE_SHADOW = 36293] = "SAMPLER_CUBE_SHADOW", r[r.INT_SAMPLER_2D = 36298] = "INT_SAMPLER_2D", r[r.INT_SAMPLER_3D = 36299] = "INT_SAMPLER_3D", r[r.INT_SAMPLER_CUBE = 36300] = "INT_SAMPLER_CUBE", r[r.INT_SAMPLER_2D_ARRAY = 36303] = "INT_SAMPLER_2D_ARRAY", r[r.UNSIGNED_INT_SAMPLER_2D = 36306] = "UNSIGNED_INT_SAMPLER_2D", r[r.UNSIGNED_INT_SAMPLER_3D = 36307] = "UNSIGNED_INT_SAMPLER_3D", r[r.UNSIGNED_INT_SAMPLER_CUBE = 36308] = "UNSIGNED_INT_SAMPLER_CUBE", r[r.UNSIGNED_INT_SAMPLER_2D_ARRAY = 36311] = "UNSIGNED_INT_SAMPLER_2D_ARRAY", r[r.MAX_SAMPLES = 36183] = "MAX_SAMPLES", r[r.SAMPLER_BINDING = 35097] = "SAMPLER_BINDING", r[r.PIXEL_PACK_BUFFER = 35051] = "PIXEL_PACK_BUFFER", r[r.PIXEL_UNPACK_BUFFER = 35052] = "PIXEL_UNPACK_BUFFER", r[r.PIXEL_PACK_BUFFER_BINDING = 35053] = "PIXEL_PACK_BUFFER_BINDING", r[r.PIXEL_UNPACK_BUFFER_BINDING = 35055] = "PIXEL_UNPACK_BUFFER_BINDING", r[r.COPY_READ_BUFFER = 36662] = "COPY_READ_BUFFER", r[r.COPY_WRITE_BUFFER = 36663] = "COPY_WRITE_BUFFER", r[r.COPY_READ_BUFFER_BINDING = 36662] = "COPY_READ_BUFFER_BINDING", r[r.COPY_WRITE_BUFFER_BINDING = 36663] = "COPY_WRITE_BUFFER_BINDING", r[r.FLOAT_MAT2x3 = 35685] = "FLOAT_MAT2x3", r[r.FLOAT_MAT2x4 = 35686] = "FLOAT_MAT2x4", r[r.FLOAT_MAT3x2 = 35687] = "FLOAT_MAT3x2", r[r.FLOAT_MAT3x4 = 35688] = "FLOAT_MAT3x4", r[r.FLOAT_MAT4x2 = 35689] = "FLOAT_MAT4x2", r[r.FLOAT_MAT4x3 = 35690] = "FLOAT_MAT4x3", r[r.UNSIGNED_INT_VEC2 = 36294] = "UNSIGNED_INT_VEC2", r[r.UNSIGNED_INT_VEC3 = 36295] = "UNSIGNED_INT_VEC3", r[r.UNSIGNED_INT_VEC4 = 36296] = "UNSIGNED_INT_VEC4", r[r.UNSIGNED_NORMALIZED = 35863] = "UNSIGNED_NORMALIZED", r[r.SIGNED_NORMALIZED = 36764] = "SIGNED_NORMALIZED", r[r.VERTEX_ATTRIB_ARRAY_INTEGER = 35069] = "VERTEX_ATTRIB_ARRAY_INTEGER", r[r.VERTEX_ATTRIB_ARRAY_DIVISOR = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR", r[r.TRANSFORM_FEEDBACK_BUFFER_MODE = 35967] = "TRANSFORM_FEEDBACK_BUFFER_MODE", r[r.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 35968] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS", r[r.TRANSFORM_FEEDBACK_VARYINGS = 35971] = "TRANSFORM_FEEDBACK_VARYINGS", r[r.TRANSFORM_FEEDBACK_BUFFER_START = 35972] = "TRANSFORM_FEEDBACK_BUFFER_START", r[r.TRANSFORM_FEEDBACK_BUFFER_SIZE = 35973] = "TRANSFORM_FEEDBACK_BUFFER_SIZE", r[r.TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 35976] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN", r[r.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 35978] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS", r[r.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 35979] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS", r[r.INTERLEAVED_ATTRIBS = 35980] = "INTERLEAVED_ATTRIBS", r[r.SEPARATE_ATTRIBS = 35981] = "SEPARATE_ATTRIBS", r[r.TRANSFORM_FEEDBACK_BUFFER = 35982] = "TRANSFORM_FEEDBACK_BUFFER", r[r.TRANSFORM_FEEDBACK_BUFFER_BINDING = 35983] = "TRANSFORM_FEEDBACK_BUFFER_BINDING", r[r.TRANSFORM_FEEDBACK = 36386] = "TRANSFORM_FEEDBACK", r[r.TRANSFORM_FEEDBACK_PAUSED = 36387] = "TRANSFORM_FEEDBACK_PAUSED", r[r.TRANSFORM_FEEDBACK_ACTIVE = 36388] = "TRANSFORM_FEEDBACK_ACTIVE", r[r.TRANSFORM_FEEDBACK_BINDING = 36389] = "TRANSFORM_FEEDBACK_BINDING", r[r.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING", r[r.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE", r[r.FRAMEBUFFER_ATTACHMENT_RED_SIZE = 33298] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE", r[r.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 33299] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE", r[r.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 33300] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE", r[r.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 33301] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE", r[r.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 33302] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE", r[r.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 33303] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE", r[r.FRAMEBUFFER_DEFAULT = 33304] = "FRAMEBUFFER_DEFAULT", r[r.DEPTH24_STENCIL8 = 35056] = "DEPTH24_STENCIL8", r[r.DRAW_FRAMEBUFFER_BINDING = 36006] = "DRAW_FRAMEBUFFER_BINDING", r[r.READ_FRAMEBUFFER_BINDING = 36010] = "READ_FRAMEBUFFER_BINDING", r[r.RENDERBUFFER_SAMPLES = 36011] = "RENDERBUFFER_SAMPLES", r[r.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 36052] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER", r[r.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 36182] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE", r[r.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", r[r.UNIFORM_BUFFER_BINDING = 35368] = "UNIFORM_BUFFER_BINDING", r[r.UNIFORM_BUFFER_START = 35369] = "UNIFORM_BUFFER_START", r[r.UNIFORM_BUFFER_SIZE = 35370] = "UNIFORM_BUFFER_SIZE", r[r.MAX_VERTEX_UNIFORM_BLOCKS = 35371] = "MAX_VERTEX_UNIFORM_BLOCKS", r[r.MAX_FRAGMENT_UNIFORM_BLOCKS = 35373] = "MAX_FRAGMENT_UNIFORM_BLOCKS", r[r.MAX_COMBINED_UNIFORM_BLOCKS = 35374] = "MAX_COMBINED_UNIFORM_BLOCKS", r[r.MAX_UNIFORM_BUFFER_BINDINGS = 35375] = "MAX_UNIFORM_BUFFER_BINDINGS", r[r.MAX_UNIFORM_BLOCK_SIZE = 35376] = "MAX_UNIFORM_BLOCK_SIZE", r[r.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 35377] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS", r[r.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 35379] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS", r[r.UNIFORM_BUFFER_OFFSET_ALIGNMENT = 35380] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT", r[r.ACTIVE_UNIFORM_BLOCKS = 35382] = "ACTIVE_UNIFORM_BLOCKS", r[r.UNIFORM_TYPE = 35383] = "UNIFORM_TYPE", r[r.UNIFORM_SIZE = 35384] = "UNIFORM_SIZE", r[r.UNIFORM_BLOCK_INDEX = 35386] = "UNIFORM_BLOCK_INDEX", r[r.UNIFORM_OFFSET = 35387] = "UNIFORM_OFFSET", r[r.UNIFORM_ARRAY_STRIDE = 35388] = "UNIFORM_ARRAY_STRIDE", r[r.UNIFORM_MATRIX_STRIDE = 35389] = "UNIFORM_MATRIX_STRIDE", r[r.UNIFORM_IS_ROW_MAJOR = 35390] = "UNIFORM_IS_ROW_MAJOR", r[r.UNIFORM_BLOCK_BINDING = 35391] = "UNIFORM_BLOCK_BINDING", r[r.UNIFORM_BLOCK_DATA_SIZE = 35392] = "UNIFORM_BLOCK_DATA_SIZE", r[r.UNIFORM_BLOCK_ACTIVE_UNIFORMS = 35394] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS", r[r.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 35395] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES", r[r.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 35396] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER", r[r.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 35398] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER", r[r.OBJECT_TYPE = 37138] = "OBJECT_TYPE", r[r.SYNC_CONDITION = 37139] = "SYNC_CONDITION", r[r.SYNC_STATUS = 37140] = "SYNC_STATUS", r[r.SYNC_FLAGS = 37141] = "SYNC_FLAGS", r[r.SYNC_FENCE = 37142] = "SYNC_FENCE", r[r.SYNC_GPU_COMMANDS_COMPLETE = 37143] = "SYNC_GPU_COMMANDS_COMPLETE", r[r.UNSIGNALED = 37144] = "UNSIGNALED", r[r.SIGNALED = 37145] = "SIGNALED", r[r.ALREADY_SIGNALED = 37146] = "ALREADY_SIGNALED", r[r.TIMEOUT_EXPIRED = 37147] = "TIMEOUT_EXPIRED", r[r.CONDITION_SATISFIED = 37148] = "CONDITION_SATISFIED", r[r.WAIT_FAILED = 37149] = "WAIT_FAILED", r[r.SYNC_FLUSH_COMMANDS_BIT = 1] = "SYNC_FLUSH_COMMANDS_BIT", r[r.COLOR = 6144] = "COLOR", r[r.DEPTH = 6145] = "DEPTH", r[r.STENCIL = 6146] = "STENCIL", r[r.MIN = 32775] = "MIN", r[r.MAX = 32776] = "MAX", r[r.DEPTH_COMPONENT24 = 33190] = "DEPTH_COMPONENT24", r[r.STREAM_READ = 35041] = "STREAM_READ", r[r.STREAM_COPY = 35042] = "STREAM_COPY", r[r.STATIC_READ = 35045] = "STATIC_READ", r[r.STATIC_COPY = 35046] = "STATIC_COPY", r[r.DYNAMIC_READ = 35049] = "DYNAMIC_READ", r[r.DYNAMIC_COPY = 35050] = "DYNAMIC_COPY", r[r.DEPTH_COMPONENT32F = 36012] = "DEPTH_COMPONENT32F", r[r.DEPTH32F_STENCIL8 = 36013] = "DEPTH32F_STENCIL8", r[r.INVALID_INDEX = 4294967295] = "INVALID_INDEX", r[r.TIMEOUT_IGNORED = -1] = "TIMEOUT_IGNORED", r[r.MAX_CLIENT_WAIT_TIMEOUT_WEBGL = 37447] = "MAX_CLIENT_WAIT_TIMEOUT_WEBGL", r[r.UNMASKED_VENDOR_WEBGL = 37445] = "UNMASKED_VENDOR_WEBGL", r[r.UNMASKED_RENDERER_WEBGL = 37446] = "UNMASKED_RENDERER_WEBGL", r[r.MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047] = "MAX_TEXTURE_MAX_ANISOTROPY_EXT", r[r.TEXTURE_MAX_ANISOTROPY_EXT = 34046] = "TEXTURE_MAX_ANISOTROPY_EXT", r[r.R16_EXT = 33322] = "R16_EXT", r[r.RG16_EXT = 33324] = "RG16_EXT", r[r.RGB16_EXT = 32852] = "RGB16_EXT", r[r.RGBA16_EXT = 32859] = "RGBA16_EXT", r[r.R16_SNORM_EXT = 36760] = "R16_SNORM_EXT", r[r.RG16_SNORM_EXT = 36761] = "RG16_SNORM_EXT", r[r.RGB16_SNORM_EXT = 36762] = "RGB16_SNORM_EXT", r[r.RGBA16_SNORM_EXT = 36763] = "RGBA16_SNORM_EXT", r[r.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", r[r.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", r[r.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", r[r.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", r[r.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", r[r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", r[r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", r[r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", r[r.COMPRESSED_RED_RGTC1_EXT = 36283] = "COMPRESSED_RED_RGTC1_EXT", r[r.COMPRESSED_SIGNED_RED_RGTC1_EXT = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT", r[r.COMPRESSED_RED_GREEN_RGTC2_EXT = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT", r[r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT", r[r.COMPRESSED_RGBA_BPTC_UNORM_EXT = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT", r[r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT", r[r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT", r[r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT", r[r.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", r[r.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", r[r.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", r[r.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", r[r.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", r[r.COMPRESSED_RGBA8_ETC2_EAC = 37493] = "COMPRESSED_RGBA8_ETC2_EAC", r[r.COMPRESSED_SRGB8_ETC2 = 37494] = "COMPRESSED_SRGB8_ETC2", r[r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37495] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", r[r.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37496] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", r[r.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37497] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", r[r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", r[r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", r[r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", r[r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", r[r.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", r[r.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", r[r.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", r[r.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", r[r.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR", r[r.COMPRESSED_RGBA_ASTC_5x4_KHR = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR", r[r.COMPRESSED_RGBA_ASTC_5x5_KHR = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR", r[r.COMPRESSED_RGBA_ASTC_6x5_KHR = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR", r[r.COMPRESSED_RGBA_ASTC_6x6_KHR = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR", r[r.COMPRESSED_RGBA_ASTC_8x5_KHR = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR", r[r.COMPRESSED_RGBA_ASTC_8x6_KHR = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR", r[r.COMPRESSED_RGBA_ASTC_8x8_KHR = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR", r[r.COMPRESSED_RGBA_ASTC_10x5_KHR = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR", r[r.COMPRESSED_RGBA_ASTC_10x6_KHR = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR", r[r.COMPRESSED_RGBA_ASTC_10x8_KHR = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR", r[r.COMPRESSED_RGBA_ASTC_10x10_KHR = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR", r[r.COMPRESSED_RGBA_ASTC_12x10_KHR = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR", r[r.COMPRESSED_RGBA_ASTC_12x12_KHR = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR", r[r.QUERY_COUNTER_BITS_EXT = 34916] = "QUERY_COUNTER_BITS_EXT", r[r.CURRENT_QUERY_EXT = 34917] = "CURRENT_QUERY_EXT", r[r.QUERY_RESULT_EXT = 34918] = "QUERY_RESULT_EXT", r[r.QUERY_RESULT_AVAILABLE_EXT = 34919] = "QUERY_RESULT_AVAILABLE_EXT", r[r.TIME_ELAPSED_EXT = 35007] = "TIME_ELAPSED_EXT", r[r.TIMESTAMP_EXT = 36392] = "TIMESTAMP_EXT", r[r.GPU_DISJOINT_EXT = 36795] = "GPU_DISJOINT_EXT", r[r.COMPLETION_STATUS_KHR = 37297] = "COMPLETION_STATUS_KHR", r[r.DEPTH_CLAMP_EXT = 34383] = "DEPTH_CLAMP_EXT", r[r.FIRST_VERTEX_CONVENTION_WEBGL = 36429] = "FIRST_VERTEX_CONVENTION_WEBGL", r[r.LAST_VERTEX_CONVENTION_WEBGL = 36430] = "LAST_VERTEX_CONVENTION_WEBGL", r[r.PROVOKING_VERTEX_WEBL = 36431] = "PROVOKING_VERTEX_WEBL", r[r.POLYGON_MODE_WEBGL = 2880] = "POLYGON_MODE_WEBGL", r[r.POLYGON_OFFSET_LINE_WEBGL = 10754] = "POLYGON_OFFSET_LINE_WEBGL", r[r.LINE_WEBGL = 6913] = "LINE_WEBGL", r[r.FILL_WEBGL = 6914] = "FILL_WEBGL", r[r.MAX_CLIP_DISTANCES_WEBGL = 3378] = "MAX_CLIP_DISTANCES_WEBGL", r[r.MAX_CULL_DISTANCES_WEBGL = 33529] = "MAX_CULL_DISTANCES_WEBGL", r[r.MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL = 33530] = "MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL", r[r.CLIP_DISTANCE0_WEBGL = 12288] = "CLIP_DISTANCE0_WEBGL", r[r.CLIP_DISTANCE1_WEBGL = 12289] = "CLIP_DISTANCE1_WEBGL", r[r.CLIP_DISTANCE2_WEBGL = 12290] = "CLIP_DISTANCE2_WEBGL", r[r.CLIP_DISTANCE3_WEBGL = 12291] = "CLIP_DISTANCE3_WEBGL", r[r.CLIP_DISTANCE4_WEBGL = 12292] = "CLIP_DISTANCE4_WEBGL", r[r.CLIP_DISTANCE5_WEBGL = 12293] = "CLIP_DISTANCE5_WEBGL", r[r.CLIP_DISTANCE6_WEBGL = 12294] = "CLIP_DISTANCE6_WEBGL", r[r.CLIP_DISTANCE7_WEBGL = 12295] = "CLIP_DISTANCE7_WEBGL", r[r.POLYGON_OFFSET_CLAMP_EXT = 36379] = "POLYGON_OFFSET_CLAMP_EXT", r[r.LOWER_LEFT_EXT = 36001] = "LOWER_LEFT_EXT", r[r.UPPER_LEFT_EXT = 36002] = "UPPER_LEFT_EXT", r[r.NEGATIVE_ONE_TO_ONE_EXT = 37726] = "NEGATIVE_ONE_TO_ONE_EXT", r[r.ZERO_TO_ONE_EXT = 37727] = "ZERO_TO_ONE_EXT", r[r.CLIP_ORIGIN_EXT = 37724] = "CLIP_ORIGIN_EXT", r[r.CLIP_DEPTH_MODE_EXT = 37725] = "CLIP_DEPTH_MODE_EXT", r[r.SRC1_COLOR_WEBGL = 35065] = "SRC1_COLOR_WEBGL", r[r.SRC1_ALPHA_WEBGL = 34185] = "SRC1_ALPHA_WEBGL", r[r.ONE_MINUS_SRC1_COLOR_WEBGL = 35066] = "ONE_MINUS_SRC1_COLOR_WEBGL", r[r.ONE_MINUS_SRC1_ALPHA_WEBGL = 35067] = "ONE_MINUS_SRC1_ALPHA_WEBGL", r[r.MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL = 35068] = "MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL", r[r.MIRROR_CLAMP_TO_EDGE_EXT = 34627] = "MIRROR_CLAMP_TO_EDGE_EXT";
})(Nd || (Nd = {}));
const Z2 = {
  3042: !1,
  32773: new Float32Array([0, 0, 0, 0]),
  32777: 32774,
  34877: 32774,
  32969: 1,
  32968: 0,
  32971: 1,
  32970: 0,
  3106: new Float32Array([0, 0, 0, 0]),
  // TBD
  3107: [!0, !0, !0, !0],
  2884: !1,
  2885: 1029,
  2929: !1,
  2931: 1,
  2932: 513,
  2928: new Float32Array([0, 1]),
  // TBD
  2930: !0,
  3024: !0,
  35725: null,
  // FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
  36006: null,
  36007: null,
  34229: null,
  34964: null,
  2886: 2305,
  33170: 4352,
  2849: 1,
  32823: !1,
  32824: 0,
  10752: 0,
  32926: !1,
  32928: !1,
  32938: 1,
  32939: !1,
  3089: !1,
  // Note: Dynamic value. If scissor test enabled we expect users to set correct scissor box
  3088: new Int32Array([0, 0, 1024, 1024]),
  2960: !1,
  2961: 0,
  2968: 4294967295,
  36005: 4294967295,
  2962: 519,
  2967: 0,
  2963: 4294967295,
  34816: 519,
  36003: 0,
  36004: 4294967295,
  2964: 7680,
  2965: 7680,
  2966: 7680,
  34817: 7680,
  34818: 7680,
  34819: 7680,
  // Dynamic value: We use [0, 0, 1024, 1024] as default, but usually this is updated in each frame.
  2978: [0, 0, 1024, 1024],
  36389: null,
  36662: null,
  36663: null,
  35053: null,
  35055: null,
  35723: 4352,
  36010: null,
  35977: !1,
  3333: 4,
  3317: 4,
  37440: !1,
  37441: !1,
  37443: 37444,
  3330: 0,
  3332: 0,
  3331: 0,
  3314: 0,
  32878: 0,
  3316: 0,
  3315: 0,
  32877: 0
}, Ds = (r, e, t) => e ? r.enable(t) : r.disable(t), e3 = (r, e, t) => r.hint(t, e), ul = (r, e, t) => r.pixelStorei(t, e), t3 = (r, e, t) => {
  const n = t === 36006 ? 36009 : 36008;
  return r.bindFramebuffer(n, e);
}, Zp = (r, e, t) => {
  const i = {
    34964: 34962,
    36662: 36662,
    36663: 36663,
    35053: 35051,
    35055: 35052
  }[t];
  r.bindBuffer(i, e);
};
function Mb(r) {
  return Array.isArray(r) || ArrayBuffer.isView(r) && !(r instanceof DataView);
}
const YU = {
  3042: Ds,
  32773: (r, e) => r.blendColor(...e),
  32777: "blendEquation",
  34877: "blendEquation",
  32969: "blendFunc",
  32968: "blendFunc",
  32971: "blendFunc",
  32970: "blendFunc",
  3106: (r, e) => r.clearColor(...e),
  3107: (r, e) => r.colorMask(...e),
  2884: Ds,
  2885: (r, e) => r.cullFace(e),
  2929: Ds,
  2931: (r, e) => r.clearDepth(e),
  2932: (r, e) => r.depthFunc(e),
  2928: (r, e) => r.depthRange(...e),
  2930: (r, e) => r.depthMask(e),
  3024: Ds,
  35723: e3,
  35725: (r, e) => r.useProgram(e),
  36007: (r, e) => r.bindRenderbuffer(36161, e),
  36389: (r, e) => {
    var t;
    return (t = r.bindTransformFeedback) == null ? void 0 : t.call(r, 36386, e);
  },
  34229: (r, e) => r.bindVertexArray(e),
  // NOTE: FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
  36006: t3,
  36010: t3,
  // Buffers
  34964: Zp,
  36662: Zp,
  36663: Zp,
  35053: Zp,
  35055: Zp,
  2886: (r, e) => r.frontFace(e),
  33170: e3,
  2849: (r, e) => r.lineWidth(e),
  32823: Ds,
  32824: "polygonOffset",
  10752: "polygonOffset",
  35977: Ds,
  32926: Ds,
  32928: Ds,
  32938: "sampleCoverage",
  32939: "sampleCoverage",
  3089: Ds,
  3088: (r, e) => r.scissor(...e),
  2960: Ds,
  2961: (r, e) => r.clearStencil(e),
  2968: (r, e) => r.stencilMaskSeparate(1028, e),
  36005: (r, e) => r.stencilMaskSeparate(1029, e),
  2962: "stencilFuncFront",
  2967: "stencilFuncFront",
  2963: "stencilFuncFront",
  34816: "stencilFuncBack",
  36003: "stencilFuncBack",
  36004: "stencilFuncBack",
  2964: "stencilOpFront",
  2965: "stencilOpFront",
  2966: "stencilOpFront",
  34817: "stencilOpBack",
  34818: "stencilOpBack",
  34819: "stencilOpBack",
  2978: (r, e) => r.viewport(...e),
  // WEBGL2 EXTENSIONS
  // EXT_depth_clamp https://registry.khronos.org/webgl/extensions/EXT_depth_clamp/
  34383: Ds,
  // WEBGL_provoking_vertex https://registry.khronos.org/webgl/extensions/WEBGL_provoking_vertex/
  // [GL.PROVOKING_VERTEX_WEBL]: TODO - extension function needed
  // WEBGL_polygon_mode https://registry.khronos.org/webgl/extensions/WEBGL_polygon_mode/
  // POLYGON_MODE_WEBGL  TODO - extension function needed
  10754: Ds,
  // WEBGL_clip_cull_distance https://registry.khronos.org/webgl/extensions/WEBGL_clip_cull_distance/
  12288: Ds,
  12289: Ds,
  12290: Ds,
  12291: Ds,
  12292: Ds,
  12293: Ds,
  12294: Ds,
  12295: Ds,
  // PIXEL PACK/UNPACK MODES
  3333: ul,
  3317: ul,
  37440: ul,
  37441: ul,
  37443: ul,
  3330: ul,
  3332: ul,
  3331: ul,
  3314: ul,
  32878: ul,
  3316: ul,
  3315: ul,
  32877: ul,
  // Function-style setters
  framebuffer: (r, e) => {
    const t = e && "handle" in e ? e.handle : e;
    return r.bindFramebuffer(36160, t);
  },
  blend: (r, e) => e ? r.enable(3042) : r.disable(3042),
  blendColor: (r, e) => r.blendColor(...e),
  blendEquation: (r, e) => {
    const t = typeof e == "number" ? [e, e] : e;
    r.blendEquationSeparate(...t);
  },
  blendFunc: (r, e) => {
    const t = (e == null ? void 0 : e.length) === 2 ? [...e, ...e] : e;
    r.blendFuncSeparate(...t);
  },
  clearColor: (r, e) => r.clearColor(...e),
  clearDepth: (r, e) => r.clearDepth(e),
  clearStencil: (r, e) => r.clearStencil(e),
  colorMask: (r, e) => r.colorMask(...e),
  cull: (r, e) => e ? r.enable(2884) : r.disable(2884),
  cullFace: (r, e) => r.cullFace(e),
  depthTest: (r, e) => e ? r.enable(2929) : r.disable(2929),
  depthFunc: (r, e) => r.depthFunc(e),
  depthMask: (r, e) => r.depthMask(e),
  depthRange: (r, e) => r.depthRange(...e),
  dither: (r, e) => e ? r.enable(3024) : r.disable(3024),
  derivativeHint: (r, e) => {
    r.hint(35723, e);
  },
  frontFace: (r, e) => r.frontFace(e),
  mipmapHint: (r, e) => r.hint(33170, e),
  lineWidth: (r, e) => r.lineWidth(e),
  polygonOffsetFill: (r, e) => e ? r.enable(32823) : r.disable(32823),
  polygonOffset: (r, e) => r.polygonOffset(...e),
  sampleCoverage: (r, e) => r.sampleCoverage(e[0], e[1] || !1),
  scissorTest: (r, e) => e ? r.enable(3089) : r.disable(3089),
  scissor: (r, e) => r.scissor(...e),
  stencilTest: (r, e) => e ? r.enable(2960) : r.disable(2960),
  stencilMask: (r, e) => {
    e = Mb(e) ? e : [e, e];
    const [t, n] = e;
    r.stencilMaskSeparate(1028, t), r.stencilMaskSeparate(1029, n);
  },
  stencilFunc: (r, e) => {
    e = Mb(e) && e.length === 3 ? [...e, ...e] : e;
    const [t, n, i, s, l, o] = e;
    r.stencilFuncSeparate(1028, t, n, i), r.stencilFuncSeparate(1029, s, l, o);
  },
  stencilOp: (r, e) => {
    e = Mb(e) && e.length === 3 ? [...e, ...e] : e;
    const [t, n, i, s, l, o] = e;
    r.stencilOpSeparate(1028, t, n, i), r.stencilOpSeparate(1029, s, l, o);
  },
  viewport: (r, e) => r.viewport(...e)
};
function hs(r, e, t) {
  return e[r] !== void 0 ? e[r] : t[r];
}
const KU = {
  blendEquation: (r, e, t) => r.blendEquationSeparate(hs(32777, e, t), hs(34877, e, t)),
  blendFunc: (r, e, t) => r.blendFuncSeparate(hs(32969, e, t), hs(32968, e, t), hs(32971, e, t), hs(32970, e, t)),
  polygonOffset: (r, e, t) => r.polygonOffset(hs(32824, e, t), hs(10752, e, t)),
  sampleCoverage: (r, e, t) => r.sampleCoverage(hs(32938, e, t), hs(32939, e, t)),
  stencilFuncFront: (r, e, t) => r.stencilFuncSeparate(1028, hs(2962, e, t), hs(2967, e, t), hs(2963, e, t)),
  stencilFuncBack: (r, e, t) => r.stencilFuncSeparate(1029, hs(34816, e, t), hs(36003, e, t), hs(36004, e, t)),
  stencilOpFront: (r, e, t) => r.stencilOpSeparate(1028, hs(2964, e, t), hs(2965, e, t), hs(2966, e, t)),
  stencilOpBack: (r, e, t) => r.stencilOpSeparate(1029, hs(34817, e, t), hs(34818, e, t), hs(34819, e, t))
}, r3 = {
  // GENERIC SETTERS
  enable: (r, e) => r({
    [e]: !0
  }),
  disable: (r, e) => r({
    [e]: !1
  }),
  pixelStorei: (r, e, t) => r({
    [e]: t
  }),
  hint: (r, e, t) => r({
    [e]: t
  }),
  // SPECIFIC SETTERS
  useProgram: (r, e) => r({
    35725: e
  }),
  bindRenderbuffer: (r, e, t) => r({
    36007: t
  }),
  bindTransformFeedback: (r, e, t) => r({
    36389: t
  }),
  bindVertexArray: (r, e) => r({
    34229: e
  }),
  bindFramebuffer: (r, e, t) => {
    switch (e) {
      case 36160:
        return r({
          36006: t,
          36010: t
        });
      case 36009:
        return r({
          36006: t
        });
      case 36008:
        return r({
          36010: t
        });
      default:
        return null;
    }
  },
  bindBuffer: (r, e, t) => {
    const n = {
      34962: [34964],
      36662: [36662],
      36663: [36663],
      35051: [35053],
      35052: [35055]
    }[e];
    return n ? r({
      [n]: t
    }) : {
      valueChanged: !0
    };
  },
  blendColor: (r, e, t, n, i) => r({
    32773: new Float32Array([e, t, n, i])
  }),
  blendEquation: (r, e) => r({
    32777: e,
    34877: e
  }),
  blendEquationSeparate: (r, e, t) => r({
    32777: e,
    34877: t
  }),
  blendFunc: (r, e, t) => r({
    32969: e,
    32968: t,
    32971: e,
    32970: t
  }),
  blendFuncSeparate: (r, e, t, n, i) => r({
    32969: e,
    32968: t,
    32971: n,
    32970: i
  }),
  clearColor: (r, e, t, n, i) => r({
    3106: new Float32Array([e, t, n, i])
  }),
  clearDepth: (r, e) => r({
    2931: e
  }),
  clearStencil: (r, e) => r({
    2961: e
  }),
  colorMask: (r, e, t, n, i) => r({
    3107: [e, t, n, i]
  }),
  cullFace: (r, e) => r({
    2885: e
  }),
  depthFunc: (r, e) => r({
    2932: e
  }),
  depthRange: (r, e, t) => r({
    2928: new Float32Array([e, t])
  }),
  depthMask: (r, e) => r({
    2930: e
  }),
  frontFace: (r, e) => r({
    2886: e
  }),
  lineWidth: (r, e) => r({
    2849: e
  }),
  polygonOffset: (r, e, t) => r({
    32824: e,
    10752: t
  }),
  sampleCoverage: (r, e, t) => r({
    32938: e,
    32939: t
  }),
  scissor: (r, e, t, n, i) => r({
    3088: new Int32Array([e, t, n, i])
  }),
  stencilMask: (r, e) => r({
    2968: e,
    36005: e
  }),
  stencilMaskSeparate: (r, e, t) => r({
    [e === 1028 ? 2968 : 36005]: t
  }),
  stencilFunc: (r, e, t, n) => r({
    2962: e,
    2967: t,
    2963: n,
    34816: e,
    36003: t,
    36004: n
  }),
  stencilFuncSeparate: (r, e, t, n, i) => r({
    [e === 1028 ? 2962 : 34816]: t,
    [e === 1028 ? 2967 : 36003]: n,
    [e === 1028 ? 2963 : 36004]: i
  }),
  stencilOp: (r, e, t, n) => r({
    2964: e,
    2965: t,
    2966: n,
    34817: e,
    34818: t,
    34819: n
  }),
  stencilOpSeparate: (r, e, t, n, i) => r({
    [e === 1028 ? 2964 : 34817]: t,
    [e === 1028 ? 2965 : 34818]: n,
    [e === 1028 ? 2966 : 34819]: i
  }),
  viewport: (r, e, t, n, i) => r({
    2978: [e, t, n, i]
  })
}, au = (r, e) => r.isEnabled(e), n3 = {
  3042: au,
  2884: au,
  2929: au,
  3024: au,
  32823: au,
  32926: au,
  32928: au,
  3089: au,
  2960: au,
  35977: au
}, JU = /* @__PURE__ */ new Set([34016, 36388, 36387, 35983, 35368, 34965, 35739, 35738, 3074, 34853, 34854, 34855, 34856, 34857, 34858, 34859, 34860, 34861, 34862, 34863, 34864, 34865, 34866, 34867, 34868, 35097, 32873, 35869, 32874, 34068]);
function bp(r, e) {
  if (ez(e))
    return;
  const t = {};
  for (const i in e) {
    const s = Number(i), l = YU[i];
    l && (typeof l == "string" ? t[l] = !0 : l(r, e[i], s));
  }
  const n = r.state && r.state.cache;
  if (n)
    for (const i in t) {
      const s = KU[i];
      s(r, e, n);
    }
}
function J5(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Z2;
  if (typeof e == "number") {
    const i = e, s = n3[i];
    return s ? s(r, i) : r.getParameter(i);
  }
  const t = Array.isArray(e) ? e : Object.keys(e), n = {};
  for (const i of t) {
    const s = n3[i];
    n[i] = s ? s(r, Number(i)) : r.getParameter(Number(i));
  }
  return n;
}
function QU(r) {
  bp(r, Z2);
}
function ez(r) {
  for (const e in r)
    return !1;
  return !0;
}
function tz(r, e) {
  if (r === e)
    return !0;
  const t = Array.isArray(r) || ArrayBuffer.isView(r), n = Array.isArray(e) || ArrayBuffer.isView(e);
  if (t && n && r.length === e.length) {
    for (let i = 0; i < r.length; ++i)
      if (r[i] !== e[i])
        return !1;
    return !0;
  }
  return !1;
}
class Df {
  constructor(e, t) {
    H(this, "gl");
    H(this, "program", null);
    H(this, "stateStack", []);
    H(this, "enable", !0);
    H(this, "cache", null);
    H(this, "log");
    H(this, "initialized", !1);
    this.gl = e, this.log = (t == null ? void 0 : t.log) || (() => {
    }), this._updateCache = this._updateCache.bind(this), Object.seal(this);
  }
  static get(e) {
    return e.state;
  }
  push() {
    this.stateStack.push({});
  }
  pop() {
    const e = this.stateStack[this.stateStack.length - 1];
    bp(this.gl, e), this.stateStack.pop();
  }
  /**
   * Initialize WebGL state caching on a context
   * can be called multiple times to enable/disable
   *
   * @note After calling this function, context state will be cached
   * .push() and .pop() will be available for saving,
   * temporarily modifying, and then restoring state.
   */
  trackState(e, t) {
    if (this.cache = t.copyState ? J5(e) : Object.assign({}, Z2), this.initialized)
      throw new Error("WebGLStateTracker");
    this.initialized = !0, this.gl.state = this, nz(e);
    for (const n in r3) {
      const i = r3[n];
      rz(e, n, i);
    }
    i3(e, "getParameter"), i3(e, "isEnabled");
  }
  /**
  // interceptor for context set functions - update our cache and our stack
  // values (Object) - the key values for this setter
   * @param values
   * @returns
   */
  _updateCache(e) {
    let t = !1, n;
    const i = this.stateStack.length > 0 ? this.stateStack[this.stateStack.length - 1] : null;
    for (const s in e) {
      const l = e[s], o = this.cache[s];
      tz(l, o) || (t = !0, n = o, i && !(s in i) && (i[s] = o), this.cache[s] = l);
    }
    return {
      valueChanged: t,
      oldValue: n
    };
  }
}
function i3(r, e) {
  const t = r[e].bind(r);
  r[e] = function(i) {
    if (i === void 0 || JU.has(i))
      return t(i);
    const s = Df.get(r);
    return i in s.cache || (s.cache[i] = t(i)), s.enable ? (
      // Call the getter the params so that it can e.g. serve from a cache
      s.cache[i]
    ) : (
      // Optionally call the original function to do a "hard" query from the WebGL2RenderingContext
      t(i)
    );
  }, Object.defineProperty(r[e], "name", {
    value: `${e}-from-cache`,
    configurable: !1
  });
}
function rz(r, e, t) {
  if (!r[e])
    return;
  const n = r[e].bind(r);
  r[e] = function() {
    const s = Df.get(r);
    for (var l = arguments.length, o = new Array(l), d = 0; d < l; d++)
      o[d] = arguments[d];
    const {
      valueChanged: m,
      oldValue: b
    } = t(s._updateCache, ...o);
    return m && n(...o), b;
  }, Object.defineProperty(r[e], "name", {
    value: `${e}-to-cache`,
    configurable: !1
  });
}
function nz(r) {
  const e = r.useProgram.bind(r);
  r.useProgram = function(n) {
    const i = Df.get(r);
    i.program !== n && (e(n), i.program = n);
  };
}
function iz(r, e, t) {
  let n = "";
  const i = {
    preserveDrawingBuffer: !0,
    // failIfMajorPerformanceCaveat: true,
    ...t
  };
  let s = null;
  if (s || (s = r.getContext("webgl2", i)), i.failIfMajorPerformanceCaveat && (n || (n = "Only software GPU is available. Set `failIfMajorPerformanceCaveat: false` to allow.")), !s && !t.failIfMajorPerformanceCaveat && (i.failIfMajorPerformanceCaveat = !1, s = r.getContext("webgl2", i), s.luma || (s.luma = {}), s.luma.softwareRenderer = !0), s || (s = r.getContext("webgl", {}), s && (s = null, n || (n = "Your browser only supports WebGL1"))), !s)
    throw n || (n = "Your browser does not support WebGL"), new Error(`Failed to create WebGL context: ${n}`);
  const {
    onContextLost: l,
    onContextRestored: o
  } = e;
  return r.addEventListener("webglcontextlost", (d) => l(d), !1), r.addEventListener("webglcontextrestored", (d) => o(d), !1), s.luma || (s.luma = {}), s;
}
function lp(r, e, t) {
  return t[e] === void 0 && (t[e] = r.getExtension(e) || null), t[e];
}
function sz(r, e) {
  const t = r.getParameter(7936), n = r.getParameter(7937);
  lp(r, "WEBGL_debug_renderer_info", e);
  const i = e.WEBGL_debug_renderer_info, s = r.getParameter(i ? i.UNMASKED_VENDOR_WEBGL : 7936), l = r.getParameter(i ? i.UNMASKED_RENDERER_WEBGL : 7937), o = s || t, d = l || n, m = r.getParameter(7938), b = Q5(o, d), A = oz(o, d), M = az(o, d);
  return {
    type: "webgl",
    gpu: b,
    gpuType: M,
    gpuBackend: A,
    vendor: o,
    renderer: d,
    version: m,
    shadingLanguage: "glsl",
    shadingLanguageVersion: 300
  };
}
function Q5(r, e) {
  return /NVIDIA/i.exec(r) || /NVIDIA/i.exec(e) ? "nvidia" : /INTEL/i.exec(r) || /INTEL/i.exec(e) ? "intel" : /Apple/i.exec(r) || /Apple/i.exec(e) ? "apple" : /AMD/i.exec(r) || /AMD/i.exec(e) || /ATI/i.exec(r) || /ATI/i.exec(e) ? "amd" : /SwiftShader/i.exec(r) || /SwiftShader/i.exec(e) ? "software" : "unknown";
}
function oz(r, e) {
  return /Metal/i.exec(r) || /Metal/i.exec(e) ? "metal" : /ANGLE/i.exec(r) || /ANGLE/i.exec(e) ? "opengl" : "unknown";
}
function az(r, e) {
  if (/SwiftShader/i.exec(r) || /SwiftShader/i.exec(e))
    return "cpu";
  switch (Q5(r, e)) {
    case "intel":
      return "integrated";
    case "software":
      return "cpu";
    case "unknown":
      return "unknown";
    default:
      return "discrete";
  }
}
function eI(r) {
  switch (r) {
    case "uint8":
      return 5121;
    case "sint8":
      return 5120;
    case "unorm8":
      return 5121;
    case "snorm8":
      return 5120;
    case "uint16":
      return 5123;
    case "sint16":
      return 5122;
    case "unorm16":
      return 5123;
    case "snorm16":
      return 5122;
    case "uint32":
      return 5125;
    case "sint32":
      return 5124;
    // WebGPU does not support normalized 32 bit integer attributes
    // case 'unorm32': return GL.UNSIGNED_INT;
    // case 'snorm32': return GL.INT;
    case "float16":
      return 5131;
    case "float32":
      return 5126;
  }
  throw new Error(String(r));
}
const hg = "WEBGL_compressed_texture_s3tc", fg = "WEBGL_compressed_texture_s3tc_srgb", Dd = "EXT_texture_compression_rgtc", Fd = "EXT_texture_compression_bptc", lz = "WEBGL_compressed_texture_etc", cz = "WEBGL_compressed_texture_astc", uz = "WEBGL_compressed_texture_etc1", hz = "WEBGL_compressed_texture_pvrtc", fz = "WEBGL_compressed_texture_atc", s3 = "EXT_texture_norm16", o3 = "EXT_render_snorm", dz = "EXT_color_buffer_float", Y2 = {
  "float32-renderable-webgl": ["EXT_color_buffer_float"],
  "float16-renderable-webgl": ["EXT_color_buffer_half_float"],
  "rgb9e5ufloat-renderable-webgl": ["WEBGL_render_shared_exponent"],
  "snorm8-renderable-webgl": [o3],
  "norm16-renderable-webgl": [s3],
  "snorm16-renderable-webgl": [s3, o3],
  "float32-filterable": ["OES_texture_float_linear"],
  "float16-filterable-webgl": ["OES_texture_half_float_linear"],
  "texture-filterable-anisotropic-webgl": ["EXT_texture_filter_anisotropic"],
  "texture-blend-float-webgl": ["EXT_float_blend"],
  "texture-compression-bc": [hg, fg, Dd, Fd],
  // 'texture-compression-bc3-srgb-webgl': [X_S3TC_SRGB],
  // 'texture-compression-bc3-webgl': [X_S3TC],
  "texture-compression-bc5-webgl": [Dd],
  "texture-compression-bc7-webgl": [Fd],
  "texture-compression-etc2": [lz],
  "texture-compression-astc": [cz],
  "texture-compression-etc1-webgl": [uz],
  "texture-compression-pvrtc-webgl": [hz],
  "texture-compression-atc-webgl": [fz]
};
function pz(r) {
  return r in Y2;
}
function gz(r, e, t) {
  return (Y2[e] || []).every((i) => lp(r, i, t));
}
const K2 = {
  // 8-bit formats
  r8unorm: {
    gl: 33321,
    rb: !0
  },
  r8snorm: {
    gl: 36756
  },
  r8uint: {
    gl: 33330,
    rb: !0
  },
  r8sint: {
    gl: 33329,
    rb: !0
  },
  // 16-bit formats
  rg8unorm: {
    gl: 33323,
    rb: !0
  },
  rg8snorm: {
    gl: 36757
  },
  rg8uint: {
    gl: 33336,
    rb: !0
  },
  rg8sint: {
    gl: 33335,
    rb: !0
  },
  r16uint: {
    gl: 33332,
    rb: !0
  },
  r16sint: {
    gl: 33331,
    rb: !0
  },
  r16float: {
    gl: 33325,
    rb: !0
  },
  "r16unorm-webgl": {
    gl: 33322,
    rb: !0
  },
  "r16snorm-webgl": {
    gl: 36760
  },
  // Packed 16-bit formats
  "rgba4unorm-webgl": {
    gl: 32854,
    rb: !0
  },
  "rgb565unorm-webgl": {
    gl: 36194,
    rb: !0
  },
  "rgb5a1unorm-webgl": {
    gl: 32855,
    rb: !0
  },
  // 24-bit formats
  "rgb8unorm-webgl": {
    gl: 32849
  },
  "rgb8snorm-webgl": {
    gl: 36758
  },
  // 32-bit formats  
  rgba8unorm: {
    gl: 32856
  },
  "rgba8unorm-srgb": {
    gl: 35907
  },
  rgba8snorm: {
    gl: 36759
  },
  rgba8uint: {
    gl: 36220
  },
  rgba8sint: {
    gl: 36238
  },
  // reverse colors, webgpu only
  bgra8unorm: {},
  "bgra8unorm-srgb": {},
  rg16uint: {
    gl: 33338
  },
  rg16sint: {
    gl: 33337
  },
  rg16float: {
    gl: 33327,
    rb: !0
  },
  "rg16unorm-webgl": {
    gl: 33324
  },
  "rg16snorm-webgl": {
    gl: 36761
  },
  r32uint: {
    gl: 33334,
    rb: !0
  },
  r32sint: {
    gl: 33333,
    rb: !0
  },
  r32float: {
    gl: 33326
  },
  // Packed 32-bit formats
  rgb9e5ufloat: {
    gl: 35901
  },
  // , filter: true},
  rg11b10ufloat: {
    gl: 35898,
    rb: !0
  },
  rgb10a2unorm: {
    gl: 32857,
    rb: !0
  },
  "rgb10a2uint-webgl": {
    gl: 36975,
    rb: !0
  },
  // 48-bit formats
  "rgb16unorm-webgl": {
    gl: 32852
  },
  // rgb not renderable
  "rgb16snorm-webgl": {
    gl: 36762
  },
  // rgb not renderable
  // 64-bit formats
  rg32uint: {
    gl: 33340,
    rb: !0
  },
  rg32sint: {
    gl: 33339,
    rb: !0
  },
  rg32float: {
    gl: 33328,
    rb: !0
  },
  rgba16uint: {
    gl: 36214,
    rb: !0
  },
  rgba16sint: {
    gl: 36232,
    rb: !0
  },
  rgba16float: {
    gl: 34842
  },
  "rgba16unorm-webgl": {
    gl: 32859,
    rb: !0
  },
  "rgba16snorm-webgl": {
    gl: 36763
  },
  // 96-bit formats (deprecated!)
  "rgb32float-webgl": {
    gl: 34837,
    x: dz,
    dataFormat: 6407,
    types: [5126]
  },
  // 128-bit formats
  rgba32uint: {
    gl: 36208,
    rb: !0
  },
  rgba32sint: {
    gl: 36226,
    rb: !0
  },
  rgba32float: {
    gl: 34836,
    rb: !0
  },
  // Depth and stencil formats
  stencil8: {
    gl: 36168,
    rb: !0
  },
  // 8 stencil bits
  depth16unorm: {
    gl: 33189,
    dataFormat: 6402,
    types: [5123],
    rb: !0
  },
  // 16 depth bits
  depth24plus: {
    gl: 33190,
    dataFormat: 6402,
    types: [5125]
  },
  depth32float: {
    gl: 36012,
    dataFormat: 6402,
    types: [5126],
    rb: !0
  },
  // The depth component of the "depth24plus" and "depth24plus-stencil8" formats may be implemented as either a 24-bit depth value or a "depth32float" value.
  "depth24plus-stencil8": {
    gl: 35056,
    rb: !0,
    depthTexture: !0,
    dataFormat: 34041,
    types: [34042]
  },
  // "depth32float-stencil8" feature - TODO below is render buffer only?
  "depth32float-stencil8": {
    gl: 36013,
    dataFormat: 34041,
    types: [36269],
    rb: !0
  },
  // BC compressed formats: check device.features.has("texture-compression-bc");
  "bc1-rgb-unorm-webgl": {
    gl: 33776,
    x: hg
  },
  "bc1-rgb-unorm-srgb-webgl": {
    gl: 35916,
    x: fg
  },
  "bc1-rgba-unorm": {
    gl: 33777,
    x: hg
  },
  "bc1-rgba-unorm-srgb": {
    gl: 35916,
    x: fg
  },
  "bc2-rgba-unorm": {
    gl: 33778,
    x: hg
  },
  "bc2-rgba-unorm-srgb": {
    gl: 35918,
    x: fg
  },
  "bc3-rgba-unorm": {
    gl: 33779,
    x: hg
  },
  "bc3-rgba-unorm-srgb": {
    gl: 35919,
    x: fg
  },
  "bc4-r-unorm": {
    gl: 36283,
    x: Dd
  },
  "bc4-r-snorm": {
    gl: 36284,
    x: Dd
  },
  "bc5-rg-unorm": {
    gl: 36285,
    x: Dd
  },
  "bc5-rg-snorm": {
    gl: 36286,
    x: Dd
  },
  "bc6h-rgb-ufloat": {
    gl: 36495,
    x: Fd
  },
  "bc6h-rgb-float": {
    gl: 36494,
    x: Fd
  },
  "bc7-rgba-unorm": {
    gl: 36492,
    x: Fd
  },
  "bc7-rgba-unorm-srgb": {
    gl: 36493,
    x: Fd
  },
  // WEBGL_compressed_texture_etc: device.features.has("texture-compression-etc2")
  // Note: Supposedly guaranteed availability compressed formats in WebGL2, but through CPU decompression
  "etc2-rgb8unorm": {
    gl: 37492
  },
  "etc2-rgb8unorm-srgb": {
    gl: 37494
  },
  "etc2-rgb8a1unorm": {
    gl: 37496
  },
  "etc2-rgb8a1unorm-srgb": {
    gl: 37497
  },
  "etc2-rgba8unorm": {
    gl: 37493
  },
  "etc2-rgba8unorm-srgb": {
    gl: 37495
  },
  "eac-r11unorm": {
    gl: 37488
  },
  "eac-r11snorm": {
    gl: 37489
  },
  "eac-rg11unorm": {
    gl: 37490
  },
  "eac-rg11snorm": {
    gl: 37491
  },
  // X_ASTC compressed formats: device.features.has("texture-compression-astc")
  "astc-4x4-unorm": {
    gl: 37808
  },
  "astc-4x4-unorm-srgb": {
    gl: 37840
  },
  "astc-5x4-unorm": {
    gl: 37809
  },
  "astc-5x4-unorm-srgb": {
    gl: 37841
  },
  "astc-5x5-unorm": {
    gl: 37810
  },
  "astc-5x5-unorm-srgb": {
    gl: 37842
  },
  "astc-6x5-unorm": {
    gl: 37811
  },
  "astc-6x5-unorm-srgb": {
    gl: 37843
  },
  "astc-6x6-unorm": {
    gl: 37812
  },
  "astc-6x6-unorm-srgb": {
    gl: 37844
  },
  "astc-8x5-unorm": {
    gl: 37813
  },
  "astc-8x5-unorm-srgb": {
    gl: 37845
  },
  "astc-8x6-unorm": {
    gl: 37814
  },
  "astc-8x6-unorm-srgb": {
    gl: 37846
  },
  "astc-8x8-unorm": {
    gl: 37815
  },
  "astc-8x8-unorm-srgb": {
    gl: 37847
  },
  "astc-10x5-unorm": {
    gl: 37819
  },
  "astc-10x5-unorm-srgb": {
    gl: 37851
  },
  "astc-10x6-unorm": {
    gl: 37817
  },
  "astc-10x6-unorm-srgb": {
    gl: 37849
  },
  "astc-10x8-unorm": {
    gl: 37818
  },
  "astc-10x8-unorm-srgb": {
    gl: 37850
  },
  "astc-10x10-unorm": {
    gl: 37819
  },
  "astc-10x10-unorm-srgb": {
    gl: 37851
  },
  "astc-12x10-unorm": {
    gl: 37820
  },
  "astc-12x10-unorm-srgb": {
    gl: 37852
  },
  "astc-12x12-unorm": {
    gl: 37821
  },
  "astc-12x12-unorm-srgb": {
    gl: 37853
  },
  // WEBGL_compressed_texture_pvrtc
  "pvrtc-rgb4unorm-webgl": {
    gl: 35840
  },
  "pvrtc-rgba4unorm-webgl": {
    gl: 35842
  },
  "pvrtc-rbg2unorm-webgl": {
    gl: 35841
  },
  "pvrtc-rgba2unorm-webgl": {
    gl: 35843
  },
  // WEBGL_compressed_texture_etc1
  "etc1-rbg-unorm-webgl": {
    gl: 36196
  },
  // WEBGL_compressed_texture_atc
  "atc-rgb-unorm-webgl": {
    gl: 35986
  },
  "atc-rgba-unorm-webgl": {
    gl: 35986
  },
  "atc-rgbai-unorm-webgl": {
    gl: 34798
  }
};
function mz(r, e, t) {
  let n = e.create;
  const i = K2[e.format];
  return (i == null ? void 0 : i.gl) === void 0 && (n = !1), i != null && i.x && (n = n && !!lp(r, i.x, t)), {
    format: e.format,
    // @ts-ignore
    create: n && e.create,
    // @ts-ignore
    render: n && e.render,
    // @ts-ignore
    filter: n && e.filter,
    // @ts-ignore
    blend: n && e.blend,
    // @ts-ignore
    store: n && e.store
  };
}
function tI(r) {
  var i;
  const e = K2[r], t = bz(r), n = b2(r);
  return {
    internalFormat: t,
    format: (e == null ? void 0 : e.dataFormat) || yz(n.channels, n.integer, n.normalized, t),
    // depth formats don't have a type
    type: n.dataType ? eI(n.dataType) : ((i = e == null ? void 0 : e.types) == null ? void 0 : i[0]) || 5121,
    compressed: n.compressed || !1
  };
}
function _z(r) {
  switch (b2(r).attachment) {
    case "depth":
      return 36096;
    case "stencil":
      return 36128;
    case "depth-stencil":
      return 33306;
    default:
      throw new Error(`Not a depth stencil format: ${r}`);
  }
}
function yz(r, e, t, n) {
  if (n === 6408 || n === 6407)
    return n;
  switch (r) {
    case "r":
      return e && !t ? 36244 : 6403;
    case "rg":
      return e && !t ? 33320 : 33319;
    case "rgb":
      return e && !t ? 36248 : 6407;
    case "rgba":
      return e && !t ? 36249 : 6408;
    case "bgra":
      throw new Error("bgra pixels not supported by WebGL");
    default:
      return 6408;
  }
}
function bz(r) {
  const e = K2[r], t = e == null ? void 0 : e.gl;
  if (t === void 0)
    throw new Error(`Unsupported texture format ${r}`);
  return t;
}
const a3 = {
  // optional WebGPU features
  "depth-clip-control": "EXT_depth_clamp",
  // TODO these seem subtly different
  // 'timestamp-query' // GPUQueryType "timestamp-query"
  // "indirect-first-instance"
  // Textures are handled by getTextureFeatures()
  // 'depth32float-stencil8' // GPUTextureFormat 'depth32float-stencil8'
  // optional WebGL features
  "timer-query-webgl": "EXT_disjoint_timer_query_webgl2",
  "compilation-status-async-webgl": "KHR_parallel_shader_compile",
  "polygon-mode-webgl": "WEBGL_polygon_mode",
  "provoking-vertex-webgl": "WEBGL_provoking_vertex",
  "shader-clip-cull-distance-webgl": "WEBGL_clip_cull_distance",
  "shader-noperspective-interpolation-webgl": "NV_shader_noperspective_interpolation",
  "shader-conservative-depth-webgl": "EXT_conservative_depth"
  // Textures are handled by getTextureFeatures()
};
class vz extends S6 {
  constructor(t, n, i) {
    super([], i);
    H(this, "gl");
    H(this, "extensions");
    H(this, "testedFeatures", /* @__PURE__ */ new Set());
    this.gl = t, this.extensions = n, lp(t, "EXT_color_buffer_float", n);
  }
  *[Symbol.iterator]() {
    const t = this.getFeatures();
    for (const n of t)
      this.has(n) && (yield n);
    return [];
  }
  has(t) {
    var n;
    return (n = this.disabledFeatures) != null && n[t] ? !1 : (this.testedFeatures.has(t) || (this.testedFeatures.add(t), pz(t) && gz(this.gl, t, this.extensions) && this.features.add(t), this.getWebGLFeature(t) && this.features.add(t)), this.features.has(t));
  }
  // FOR DEVICE
  initializeFeatures() {
    const t = this.getFeatures().filter((n) => n !== "polygon-mode-webgl");
    for (const n of t)
      this.has(n);
  }
  // IMPLEMENTATION
  getFeatures() {
    return [...Object.keys(a3), ...Object.keys(Y2)];
  }
  /** Extract all WebGL features */
  getWebGLFeature(t) {
    const n = a3[t];
    return typeof n == "string" ? !!lp(this.gl, n, this.extensions) : !!n;
  }
}
class xz extends T6 {
  constructor(t) {
    super();
    // WebGL does not support compute shaders
    // PRIVATE
    H(this, "gl");
    H(this, "limits", {});
    this.gl = t;
  }
  get maxTextureDimension1D() {
    return 0;
  }
  // WebGL does not support 1D textures
  get maxTextureDimension2D() {
    return this.getParameter(3379);
  }
  get maxTextureDimension3D() {
    return this.getParameter(32883);
  }
  get maxTextureArrayLayers() {
    return this.getParameter(35071);
  }
  get maxBindGroups() {
    return 0;
  }
  get maxDynamicUniformBuffersPerPipelineLayout() {
    return 0;
  }
  // TBD
  get maxDynamicStorageBuffersPerPipelineLayout() {
    return 0;
  }
  // TBD
  get maxSampledTexturesPerShaderStage() {
    return this.getParameter(35660);
  }
  // ) TBD
  get maxSamplersPerShaderStage() {
    return this.getParameter(35661);
  }
  get maxStorageBuffersPerShaderStage() {
    return 0;
  }
  // TBD
  get maxStorageTexturesPerShaderStage() {
    return 0;
  }
  // TBD
  get maxUniformBuffersPerShaderStage() {
    return this.getParameter(35375);
  }
  get maxUniformBufferBindingSize() {
    return this.getParameter(35376);
  }
  get maxStorageBufferBindingSize() {
    return 0;
  }
  get minUniformBufferOffsetAlignment() {
    return this.getParameter(35380);
  }
  get minStorageBufferOffsetAlignment() {
    return 0;
  }
  get maxVertexBuffers() {
    return 16;
  }
  // WebGL 2 supports 16 buffers, see https://github.com/gpuweb/gpuweb/issues/4284
  get maxVertexAttributes() {
    return this.getParameter(34921);
  }
  get maxVertexBufferArrayStride() {
    return 2048;
  }
  // TBD, this is just the default value from WebGPU
  get maxInterStageShaderComponents() {
    return this.getParameter(35659);
  }
  get maxComputeWorkgroupStorageSize() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeInvocationsPerWorkgroup() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeX() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeY() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeZ() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupsPerDimension() {
    return 0;
  }
  getParameter(t) {
    return this.limits[t] === void 0 && (this.limits[t] = this.gl.getParameter(t)), this.limits[t] || 0;
  }
}
class wg extends $_ {
  constructor(t, n) {
    super(t, n);
    H(this, "device");
    H(this, "gl");
    H(this, "handle");
    H(this, "colorAttachments", []);
    H(this, "depthStencilAttachment", null);
    const i = n.handle === null;
    this.device = t, this.gl = t.gl, this.handle = this.props.handle || i ? this.props.handle : this.gl.createFramebuffer(), i || (t.setSpectorMetadata(this.handle, {
      id: this.props.id,
      props: this.props
    }), this.autoCreateAttachmentTextures(), this.updateAttachments());
  }
  /** destroys any auto created resources etc. */
  destroy() {
    super.destroy(), !this.destroyed && this.handle !== null && this.gl.deleteFramebuffer(this.handle);
  }
  updateAttachments() {
    const t = this.gl.bindFramebuffer(36160, this.handle);
    for (let n = 0; n < this.colorAttachments.length; ++n) {
      const i = this.colorAttachments[n];
      if (i) {
        const s = 36064 + n;
        this._attachTextureView(s, i);
      }
    }
    if (this.depthStencilAttachment) {
      const n = _z(this.depthStencilAttachment.props.format);
      this._attachTextureView(n, this.depthStencilAttachment);
    }
    if (this.device.props.debug) {
      const n = this.gl.checkFramebufferStatus(36160);
      if (n !== 36053)
        throw new Error(`Framebuffer ${Az(n)}`);
    }
    this.gl.bindFramebuffer(36160, t);
  }
  // PRIVATE
  /** In WebGL we must use renderbuffers for depth/stencil attachments (unless we have extensions) */
  // protected override createDepthStencilTexture(format: TextureFormat): Texture {
  //   // return new WEBGLRenderbuffer(this.device, {
  //   return new WEBGLTexture(this.device, {
  //     id: `${this.id}-depth-stencil`,
  //     format,
  //     width: this.width,
  //     height: this.height,
  //     mipmaps: false
  //   });
  // }
  /**
   * @param attachment
   * @param texture
   * @param layer = 0 - index into WEBGLTextureArray and Texture3D or face for `TextureCubeMap`
   * @param level = 0 - mipmapLevel
   */
  _attachTextureView(t, n) {
    const {
      gl: i
    } = this.device, {
      texture: s
    } = n, l = n.props.baseMipLevel, o = n.props.baseArrayLayer;
    switch (i.bindTexture(s.glTarget, s.handle), s.glTarget) {
      case 35866:
      case 32879:
        i.framebufferTextureLayer(36160, t, s.handle, l, o);
        break;
      case 34067:
        const d = wz(o);
        i.framebufferTexture2D(36160, t, d, s.handle, l);
        break;
      case 3553:
        i.framebufferTexture2D(36160, t, 3553, s.handle, l);
        break;
      default:
        throw new Error("Illegal texture type");
    }
    i.bindTexture(s.glTarget, null);
  }
}
function wz(r) {
  return r < 34069 ? r + 34069 : r;
}
function Az(r) {
  switch (r) {
    case 36053:
      return "success";
    case 36054:
      return "Mismatched attachments";
    case 36055:
      return "No attachments";
    case 36057:
      return "Height/width mismatch";
    case 36061:
      return "Unsupported or split attachments";
    // WebGL2
    case 36182:
      return "Samples mismatch";
    // OVR_multiview2 extension
    // case GL.FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR: return 'baseViewIndex mismatch';
    default:
      return `${r}`;
  }
}
class Tz extends V1 {
  constructor(t, n) {
    super(n);
    H(this, "device");
    H(this, "format", "rgba8unorm");
    H(this, "depthStencilFormat", "depth24plus");
    H(this, "presentationSize");
    H(this, "_framebuffer", null);
    this.device = t, this.presentationSize = [-1, -1], this._setAutoCreatedCanvasId(`${this.device.id}-canvas`), this.update();
  }
  get [Symbol.toStringTag]() {
    return "WebGLCanvasContext";
  }
  getCurrentFramebuffer() {
    return this.update(), this._framebuffer = this._framebuffer || new wg(this.device, {
      handle: null
    }), this._framebuffer;
  }
  /** Resizes and updates render targets if necessary */
  update() {
    const t = this.getPixelSize();
    (t[0] !== this.presentationSize[0] || t[1] !== this.presentationSize[1]) && (this.presentationSize = t, this.resize());
  }
  /**
   * Resize the canvas' drawing buffer.
   *
   * Can match the canvas CSS size, and optionally also consider devicePixelRatio
   * Can be called every frame
   *
   * Regardless of size, the drawing buffer will always be scaled to the viewport, but
   * for best visual results, usually set to either:
   *  canvas CSS width x canvas CSS height
   *  canvas CSS width * devicePixelRatio x canvas CSS height * devicePixelRatio
   * See http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
   */
  resize(t) {
    if (this.device.gl && this.canvas) {
      const n = this.getDevicePixelRatio(t == null ? void 0 : t.useDevicePixels);
      this.setDevicePixelRatio(n, t);
      return;
    }
  }
  commit() {
  }
}
async function rI(r, e) {
  const t = document.getElementsByTagName("head")[0];
  if (!t)
    throw new Error("loadScript");
  const n = document.createElement("script");
  return n.setAttribute("type", "text/javascript"), n.setAttribute("src", r), new Promise((i, s) => {
    n.onload = i, n.onerror = (l) => s(new Error(`Unable to load script '${r}': ${l}`)), t.appendChild(n);
  });
}
const Sz = 1;
let Ci = null, l3 = !1;
const J2 = {
  debugSpectorJS: cr.get("debug-spectorjs"),
  // https://github.com/BabylonJS/Spector.js#basic-usage
  // https://forum.babylonjs.com/t/spectorcdn-is-temporarily-off/48241
  // spectorUrl: 'https://spectorcdn.babylonjs.com/spector.bundle.js';
  debugSpectorJSUrl: "https://cdn.jsdelivr.net/npm/spectorjs@0.9.30/dist/spector.bundle.js",
  gl: void 0
};
async function Ez(r) {
  if (!globalThis.SPECTOR)
    try {
      await rI(r.debugSpectorJSUrl || J2.debugSpectorJSUrl);
    } catch (e) {
      cr.warn(String(e));
    }
}
function Cz(r) {
  var e;
  if (r = {
    ...J2,
    ...r
  }, !r.debugSpectorJS)
    return null;
  if (!Ci && globalThis.SPECTOR && !((e = globalThis.luma) != null && e.spector)) {
    cr.probe(Sz, "SPECTOR found and initialized. Start with `luma.spector.displayUI()`")();
    const {
      Spector: t
    } = globalThis.SPECTOR;
    Ci = new t(), globalThis.luma && (globalThis.luma.spector = Ci);
  }
  if (!Ci)
    return null;
  if (l3 || (l3 = !0, Ci.spyCanvases(), Ci == null || Ci.onCaptureStarted.add((t) => cr.info("Spector capture started:", t)()), Ci == null || Ci.onCapture.add((t) => {
    cr.info("Spector capture complete:", t)(), Ci == null || Ci.getResultUI(), Ci == null || Ci.resultView.display(), Ci == null || Ci.resultView.addCapture(t);
  })), r.gl) {
    const t = r.gl, n = t.device;
    Ci == null || Ci.startCapture(r.gl, 500), t.device = n, new Promise((i) => setTimeout(i, 2e3)).then((i) => {
      cr.info("Spector capture stopped after 2 seconds")(), Ci == null || Ci.stopCapture();
    });
  }
  return Ci;
}
const Iz = "https://unpkg.com/webgl-debug@2.0.1/index.js";
function nI(r) {
  return r.luma = r.luma || {}, r.luma;
}
async function Mz() {
  Wf() && !globalThis.WebGLDebugUtils && (globalThis.global = globalThis.global || globalThis, globalThis.global.module = {}, await rI(Iz));
}
function Pz(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return e.debugWebGL || e.traceWebGL ? Bz(r, e) : Rz(r);
}
function Rz(r) {
  const e = nI(r);
  return e.realContext ? e.realContext : r;
}
function Bz(r, e) {
  if (!globalThis.WebGLDebugUtils)
    return cr.warn("webgl-debug not loaded")(), r;
  const t = nI(r);
  if (t.debugContext)
    return t.debugContext;
  globalThis.WebGLDebugUtils.init({
    ...Nd,
    ...r
  });
  const n = globalThis.WebGLDebugUtils.makeDebugContext(r, Lz.bind(null, e), Oz.bind(null, e));
  for (const l in Nd)
    !(l in n) && typeof Nd[l] == "number" && (n[l] = Nd[l]);
  class i {
  }
  Object.setPrototypeOf(n, Object.getPrototypeOf(r)), Object.setPrototypeOf(i, n);
  const s = Object.create(i);
  return t.realContext = r, t.debugContext = s, s.debug = !0, s;
}
function c3(r, e) {
  e = Array.from(e).map((n) => n === void 0 ? "undefined" : n);
  let t = globalThis.WebGLDebugUtils.glFunctionArgsToString(r, e);
  return t = `${t.slice(0, 100)}${t.length > 100 ? "..." : ""}`, `gl.${r}(${t})`;
}
function Lz(r, e, t, n) {
  n = Array.from(n).map((o) => o === void 0 ? "undefined" : o);
  const i = globalThis.WebGLDebugUtils.glEnumToString(e), s = globalThis.WebGLDebugUtils.glFunctionArgsToString(t, n), l = `${i} in gl.${t}(${s})`;
  cr.error(l)();
  debugger;
}
function Oz(r, e, t) {
  let n = "";
  cr.level >= 1 && (n = c3(e, t), r.traceWebGL && cr.log(1, n)());
  for (const i of t)
    if (i === void 0) {
      n = n || c3(e, t);
      debugger;
    }
}
const Pb = {};
function kz() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "id";
  Pb[r] = Pb[r] || 1;
  const e = Pb[r]++;
  return `${r}-${e}`;
}
class Ag extends gs {
  constructor(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(t, n);
    H(this, "device");
    H(this, "gl");
    H(this, "handle");
    /** Target in OpenGL defines the type of buffer */
    H(this, "glTarget");
    /** Usage is a hint on how frequently the buffer will be updates */
    H(this, "glUsage");
    /** Index type is needed when issuing draw calls, so we pre-compute it */
    H(this, "glIndexType", 5123);
    /** Number of bytes allocated on the GPU for this buffer */
    H(this, "byteLength");
    /** Number of bytes used */
    H(this, "bytesUsed");
    this.device = t, this.gl = this.device.gl;
    const i = typeof n == "object" ? n.handle : void 0;
    this.handle = i || this.gl.createBuffer(), t.setSpectorMetadata(this.handle, {
      ...this.props,
      data: typeof this.props.data
    }), this.glTarget = Nz(this.props.usage), this.glUsage = Dz(this.props.usage), this.glIndexType = this.props.indexType === "uint32" ? 5125 : 5123, n.data ? this._initWithData(n.data, n.byteOffset, n.byteLength) : this._initWithByteLength(n.byteLength || 0);
  }
  // PRIVATE METHODS
  /** Allocate a new buffer and initialize to contents of typed array */
  _initWithData(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : t.byteLength + n;
    const s = this.glTarget;
    this.gl.bindBuffer(s, this.handle), this.gl.bufferData(s, i, this.glUsage), this.gl.bufferSubData(s, n, t), this.gl.bindBuffer(s, null), this.bytesUsed = i, this.byteLength = i, this._setDebugData(t, n, i), this.trackAllocatedMemory(i);
  }
  // Allocate a GPU buffer of specified size.
  _initWithByteLength(t) {
    let n = t;
    t === 0 && (n = new Float32Array(0));
    const i = this.glTarget;
    return this.gl.bindBuffer(i, this.handle), this.gl.bufferData(i, n, this.glUsage), this.gl.bindBuffer(i, null), this.bytesUsed = t, this.byteLength = t, this._setDebugData(null, 0, t), this.trackAllocatedMemory(t), this;
  }
  destroy() {
    !this.destroyed && this.handle && (this.removeStats(), this.trackDeallocatedMemory(), this.gl.deleteBuffer(this.handle), this.destroyed = !0, this.handle = null);
  }
  write(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    const i = 36663;
    this.gl.bindBuffer(i, this.handle), this.gl.bufferSubData(i, n, t), this.gl.bindBuffer(i, null), this._setDebugData(t, n, t.byteLength);
  }
  /** Asynchronously read data from the buffer */
  async readAsync() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, n = arguments.length > 1 ? arguments[1] : void 0;
    return this.readSyncWebGL(t, n);
  }
  /** Synchronously read data from the buffer. WebGL only. */
  readSyncWebGL() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, n = arguments.length > 1 ? arguments[1] : void 0;
    n = n ?? this.byteLength - t;
    const i = new Uint8Array(n), s = 0;
    return this.gl.bindBuffer(36662, this.handle), this.gl.getBufferSubData(36662, t, i, s, n), this.gl.bindBuffer(36662, null), this._setDebugData(i, t, n), i;
  }
}
function Nz(r) {
  return r & gs.INDEX ? 34963 : r & gs.VERTEX ? 34962 : r & gs.UNIFORM ? 35345 : 34962;
}
function Dz(r) {
  return r & gs.INDEX || r & gs.VERTEX ? 35044 : r & gs.UNIFORM ? 35048 : 35044;
}
function Fz(r) {
  const e = r.split(/\r?\n/), t = [];
  for (const n of e) {
    if (n.length <= 1)
      continue;
    const i = n.split(":");
    if (i.length === 2) {
      const [A, M] = i;
      t.push({
        message: M.trim(),
        type: u3(A),
        lineNum: 0,
        linePos: 0
      });
      continue;
    }
    const [s, l, o, ...d] = i;
    let m = parseInt(o, 10);
    isNaN(m) && (m = 0);
    let b = parseInt(l, 10);
    isNaN(b) && (b = 0), t.push({
      message: d.join(":").trim(),
      type: u3(s),
      lineNum: m,
      linePos: b
      // TODO
    });
  }
  return t;
}
function u3(r) {
  const e = ["warning", "error", "info"], t = r.toLowerCase();
  return e.includes(t) ? t : "info";
}
class Uz extends j_ {
  constructor(t, n) {
    super(t, n);
    H(this, "device");
    H(this, "handle");
    switch (this.device = t, this.props.stage) {
      case "vertex":
        this.handle = this.props.handle || this.device.gl.createShader(35633);
        break;
      case "fragment":
        this.handle = this.props.handle || this.device.gl.createShader(35632);
        break;
      default:
        throw new Error(this.props.stage);
    }
    this._compile(this.source);
  }
  destroy() {
    this.handle && (this.removeStats(), this.device.gl.deleteShader(this.handle), this.destroyed = !0);
  }
  get asyncCompilationStatus() {
    return this._waitForCompilationComplete().then(() => this.compilationStatus);
  }
  async getCompilationInfo() {
    return await this._waitForCompilationComplete(), this.getCompilationInfoSync();
  }
  getCompilationInfoSync() {
    const t = this.device.gl.getShaderInfoLog(this.handle);
    return t ? Fz(t) : [];
  }
  getTranslatedSource() {
    const n = this.device.getExtension("WEBGL_debug_shaders").WEBGL_debug_shaders;
    return (n == null ? void 0 : n.getTranslatedShaderSource(this.handle)) || null;
  }
  // PRIVATE METHODS
  /** Compile a shader and get compilation status */
  async _compile(t) {
    t = t.startsWith("#version ") ? t : `#version 300 es
${t}`;
    const {
      gl: n
    } = this.device;
    if (n.shaderSource(this.handle, t), n.compileShader(this.handle), !this.device.props.debug) {
      this.compilationStatus = "pending";
      return;
    }
    if (!this.device.features.has("compilation-status-async-webgl")) {
      if (this._getCompilationStatus(), this.debugShader(), this.compilationStatus === "error")
        throw new Error(`GLSL compilation errors in ${this.props.stage} shader ${this.props.id}`);
      return;
    }
    cr.once(1, "Shader compilation is asynchronous")(), await this._waitForCompilationComplete(), cr.info(2, `Shader ${this.id} - async compilation complete: ${this.compilationStatus}`)(), this._getCompilationStatus(), this.debugShader();
  }
  /** Use KHR_parallel_shader_compile extension if available */
  async _waitForCompilationComplete() {
    const t = async (s) => await new Promise((l) => setTimeout(l, s));
    if (!this.device.features.has("compilation-status-async-webgl")) {
      await t(10);
      return;
    }
    const {
      gl: i
    } = this.device;
    for (; ; ) {
      if (i.getShaderParameter(this.handle, 37297))
        return;
      await t(10);
    }
  }
  /**
   * Get the shader compilation status
   * TODO - Load log even when no error reported, to catch warnings?
   * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
   */
  _getCompilationStatus() {
    this.compilationStatus = this.device.gl.getShaderParameter(this.handle, 35713) ? "success" : "error";
  }
}
function zz(r, e, t, n) {
  if (qz(e))
    return n(r);
  const i = r;
  i.pushState();
  try {
    return jz(r, e), bp(i.gl, t), n(r);
  } finally {
    i.popState();
  }
}
function jz(r, e) {
  const t = r, {
    gl: n
  } = t;
  if (e.cullMode)
    switch (e.cullMode) {
      case "none":
        n.disable(2884);
        break;
      case "front":
        n.enable(2884), n.cullFace(1028);
        break;
      case "back":
        n.enable(2884), n.cullFace(1029);
        break;
    }
  if (e.frontFace && n.frontFace(Ff("frontFace", e.frontFace, {
    ccw: 2305,
    cw: 2304
  })), e.unclippedDepth && r.features.has("depth-clip-control") && n.enable(34383), e.depthBias !== void 0 && (n.enable(32823), n.polygonOffset(e.depthBias, e.depthBiasSlopeScale || 0)), e.provokingVertex && r.features.has("provoking-vertex-webgl")) {
    const s = t.getExtension("WEBGL_provoking_vertex").WEBGL_provoking_vertex, l = Ff("provokingVertex", e.provokingVertex, {
      first: 36429,
      last: 36430
    });
    s == null || s.provokingVertexWEBGL(l);
  }
  if ((e.polygonMode || e.polygonOffsetLine) && r.features.has("polygon-mode-webgl")) {
    if (e.polygonMode) {
      const s = t.getExtension("WEBGL_polygon_mode").WEBGL_polygon_mode, l = Ff("polygonMode", e.polygonMode, {
        fill: 6914,
        line: 6913
      });
      s == null || s.polygonModeWEBGL(1028, l), s == null || s.polygonModeWEBGL(1029, l);
    }
    e.polygonOffsetLine && n.enable(10754);
  }
  if (r.features.has("shader-clip-cull-distance-webgl") && (e.clipDistance0 && n.enable(12288), e.clipDistance1 && n.enable(12289), e.clipDistance2 && n.enable(12290), e.clipDistance3 && n.enable(12291), e.clipDistance4 && n.enable(12292), e.clipDistance5 && n.enable(12293), e.clipDistance6 && n.enable(12294), e.clipDistance7 && n.enable(12295)), e.depthWriteEnabled !== void 0 && n.depthMask($z("depthWriteEnabled", e.depthWriteEnabled)), e.depthCompare && (e.depthCompare !== "always" ? n.enable(2929) : n.disable(2929), n.depthFunc(gv("depthCompare", e.depthCompare))), e.stencilWriteMask) {
    const i = e.stencilWriteMask;
    n.stencilMaskSeparate(1028, i), n.stencilMaskSeparate(1029, i);
  }
  if (e.stencilReadMask && cr.warn("stencilReadMask not supported under WebGL"), e.stencilCompare) {
    const i = e.stencilReadMask || 4294967295, s = gv("depthCompare", e.stencilCompare);
    e.stencilCompare !== "always" ? n.enable(2960) : n.disable(2960), n.stencilFuncSeparate(1028, s, 0, i), n.stencilFuncSeparate(1029, s, 0, i);
  }
  if (e.stencilPassOperation && e.stencilFailOperation && e.stencilDepthFailOperation) {
    const i = Rb("stencilPassOperation", e.stencilPassOperation), s = Rb("stencilFailOperation", e.stencilFailOperation), l = Rb("stencilDepthFailOperation", e.stencilDepthFailOperation);
    n.stencilOpSeparate(1028, s, l, i), n.stencilOpSeparate(1029, s, l, i);
  }
  switch (e.blend) {
    case !0:
      n.enable(3042);
      break;
    case !1:
      n.disable(3042);
      break;
  }
  if (e.blendColorOperation || e.blendAlphaOperation) {
    const i = h3("blendColorOperation", e.blendColorOperation || "add"), s = h3("blendAlphaOperation", e.blendAlphaOperation || "add");
    n.blendEquationSeparate(i, s);
    const l = Nm("blendColorSrcFactor", e.blendColorSrcFactor || "one"), o = Nm("blendColorDstFactor", e.blendColorDstFactor || "zero"), d = Nm("blendAlphaSrcFactor", e.blendAlphaSrcFactor || "one"), m = Nm("blendAlphaDstFactor", e.blendAlphaDstFactor || "zero");
    n.blendFuncSeparate(l, o, d, m);
  }
}
function gv(r, e) {
  return Ff(r, e, {
    never: 512,
    less: 513,
    equal: 514,
    "less-equal": 515,
    greater: 516,
    "not-equal": 517,
    "greater-equal": 518,
    always: 519
  });
}
function Rb(r, e) {
  return Ff(r, e, {
    keep: 7680,
    zero: 0,
    replace: 7681,
    invert: 5386,
    "increment-clamp": 7682,
    "decrement-clamp": 7683,
    "increment-wrap": 34055,
    "decrement-wrap": 34056
  });
}
function h3(r, e) {
  return Ff(r, e, {
    add: 32774,
    subtract: 32778,
    "reverse-subtract": 32779,
    min: 32775,
    max: 32776
  });
}
function Nm(r, e) {
  return Ff(r, e, {
    one: 1,
    zero: 0,
    "src-color": 768,
    "one-minus-src-color": 769,
    "dst-color": 774,
    "one-minus-dst-color": 775,
    "src-alpha": 770,
    "one-minus-src-alpha": 771,
    "dst-alpha": 772,
    "one-minus-dst-alpha": 773,
    "src-alpha-saturated": 776,
    "constant-color": 32769,
    "one-minus-constant-color": 32770,
    "constant-alpha": 32771,
    "one-minus-constant-alpha": 32772
  });
}
function Vz(r, e) {
  return `Illegal parameter ${e} for ${r}`;
}
function Ff(r, e, t) {
  if (!(e in t))
    throw new Error(Vz(r, e));
  return t[e];
}
function $z(r, e) {
  return e;
}
function qz(r) {
  let e = !0;
  for (const t in r) {
    e = !1;
    break;
  }
  return e;
}
function iI(r) {
  const e = {};
  return r.addressModeU && (e[10242] = Bb(r.addressModeU)), r.addressModeV && (e[10243] = Bb(r.addressModeV)), r.addressModeW && (e[32882] = Bb(r.addressModeW)), r.magFilter && (e[10240] = mv(r.magFilter)), (r.minFilter || r.mipmapFilter) && (e[10241] = Gz(r.minFilter || "linear", r.mipmapFilter)), r.lodMinClamp !== void 0 && (e[33082] = r.lodMinClamp), r.lodMaxClamp !== void 0 && (e[33083] = r.lodMaxClamp), r.type === "comparison-sampler" && (e[34892] = 34894), r.compare && (e[34893] = gv("compare", r.compare)), r.maxAnisotropy && (e[34046] = r.maxAnisotropy), e;
}
function Bb(r) {
  switch (r) {
    case "clamp-to-edge":
      return 33071;
    case "repeat":
      return 10497;
    case "mirror-repeat":
      return 33648;
  }
}
function mv(r) {
  switch (r) {
    case "nearest":
      return 9728;
    case "linear":
      return 9729;
  }
}
function Gz(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "none";
  if (!e)
    return mv(r);
  switch (e) {
    case "none":
      return mv(r);
    case "nearest":
      return r === "nearest" ? 9984 : 9986;
    case "linear":
      return r === "nearest" ? 9985 : 9987;
  }
}
class _v extends V_ {
  constructor(t, n) {
    super(t, n);
    H(this, "device");
    H(this, "handle");
    H(this, "parameters");
    this.device = t, this.parameters = iI(n), this.handle = this.handle || this.device.gl.createSampler(), this._setSamplerParameters(this.parameters);
  }
  destroy() {
    this.handle && (this.device.gl.deleteSampler(this.handle), this.handle = void 0);
  }
  toString() {
    return `Sampler(${this.id},${JSON.stringify(this.props)})`;
  }
  /** Set sampler parameters on the sampler */
  _setSamplerParameters(t) {
    for (const [n, i] of Object.entries(t)) {
      const s = Number(n);
      switch (s) {
        case 33082:
        case 33083:
          this.device.gl.samplerParameterf(this.handle, s, i);
          break;
        default:
          this.device.gl.samplerParameteri(this.handle, s, i);
          break;
      }
    }
  }
}
class Ud extends z_ {
  constructor(t, n) {
    super(t, {
      ...ts.defaultProps,
      ...n
    });
    H(this, "device");
    H(this, "gl");
    H(this, "handle");
    // Does not have a WebGL representation
    H(this, "texture");
    this.device = t, this.gl = this.device.gl, this.handle = null, this.texture = n.texture;
  }
}
const Hz = "Failed to deduce GL constant from typed array";
function Wz(r) {
  switch (ArrayBuffer.isView(r) ? r.constructor : r) {
    case Float32Array:
      return 5126;
    case Uint16Array:
      return 5123;
    case Uint32Array:
      return 5125;
    case Uint8Array:
      return 5121;
    case Uint8ClampedArray:
      return 5121;
    case Int8Array:
      return 5120;
    case Int16Array:
      return 5122;
    case Int32Array:
      return 5124;
    default:
      throw new Error(Hz);
  }
}
function Xz(r, e) {
  const {
    clamped: t = !0
  } = e || {};
  switch (r) {
    case 5126:
      return Float32Array;
    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;
    case 5125:
      return Uint32Array;
    case 5121:
      return t ? Uint8ClampedArray : Uint8Array;
    case 5120:
      return Int8Array;
    case 5122:
      return Int16Array;
    case 5124:
      return Int32Array;
    default:
      throw new Error("Failed to deduce typed array type from GL constant");
  }
}
function sI(r) {
  switch (r) {
    case 6406:
    case 33326:
    case 6403:
    case 36244:
      return 1;
    case 33339:
    case 33340:
    case 33328:
    case 33320:
    case 33319:
      return 2;
    case 6407:
    case 36248:
    case 34837:
      return 3;
    case 6408:
    case 36249:
    case 34836:
      return 4;
    // TODO: Add support for additional WebGL2 formats
    default:
      return 0;
  }
}
function Zz(r) {
  switch (r) {
    case 5121:
      return 1;
    case 33635:
    case 32819:
    case 32820:
      return 2;
    case 5126:
      return 4;
    // TODO: Add support for additional WebGL2 types
    default:
      return 0;
  }
}
function iy(r, e, t) {
  if (Yz(e))
    return t(r);
  const {
    nocatch: n = !0
  } = e, i = Df.get(r);
  i.push(), bp(r, e);
  let s;
  if (n)
    s = t(r), i.pop();
  else
    try {
      s = t(r);
    } finally {
      i.pop();
    }
  return s;
}
function Yz(r) {
  for (const e in r)
    return !1;
  return !0;
}
function Kz(r, e, t) {
  const {
    dimension: n,
    width: i,
    height: s,
    depth: l = 0
  } = t, {
    glInternalFormat: o
  } = t, d = t.glTarget;
  switch (n) {
    case "2d-array":
    case "3d":
      r.texStorage3D(d, e, o, i, s, l);
      break;
    default:
      r.texStorage2D(d, e, o, i, s);
  }
}
function f3(r, e, t, n) {
  const {
    width: i,
    height: s
  } = n, {
    dimension: l,
    depth: o = 0,
    mipLevel: d = 0
  } = n, {
    x: m = 0,
    y: b = 0,
    z: A = 0
  } = n, {
    glFormat: M,
    glType: E
  } = n, k = oI(n.glTarget, l, o), U = n.flipY ? {
    37440: !0
  } : {};
  iy(r, U, () => {
    switch (l) {
      case "2d-array":
      case "3d":
        r.bindTexture(k, e), r.texSubImage3D(k, d, m, b, A, i, s, o, M, E, t), r.bindTexture(k, null);
        break;
      case "2d":
      case "cube":
        r.bindTexture(k, e), r.texSubImage2D(k, d, m, b, i, s, M, E, t), r.bindTexture(k, null);
        break;
      default:
        throw new Error(l);
    }
  });
}
function d3(r, e, t) {
  const {
    dimension: n,
    width: i,
    height: s,
    depth: l = 0,
    mipLevel: o = 0,
    byteOffset: d = 0
  } = t, {
    x: m = 0,
    y: b = 0,
    z: A = 0
  } = t, {
    glFormat: M,
    glType: E,
    compressed: k
  } = t, U = oI(t.glTarget, n, l);
  switch (n) {
    case "2d-array":
    case "3d":
      k ? r.compressedTexSubImage3D(U, o, m, b, A, i, s, l, M, e, d) : r.texSubImage3D(U, o, m, b, A, i, s, l, M, E, e, d);
      break;
    case "2d":
    case "cube":
      k ? r.compressedTexSubImage2D(U, o, m, b, i, s, M, e, d) : r.texSubImage2D(U, o, m, b, i, s, M, E, e, d);
      break;
    default:
      throw new Error(n);
  }
}
function Jz(r) {
  switch (r) {
    case "1d":
      break;
    // not supported in any WebGL version
    case "2d":
      return 3553;
    // supported in WebGL1
    case "3d":
      return 32879;
    // supported in WebGL2
    case "cube":
      return 34067;
    // supported in WebGL1
    case "2d-array":
      return 35866;
  }
  throw new Error(r);
}
function oI(r, e, t) {
  return e === "cube" ? 34069 + t : r;
}
function Qz(r, e) {
  var q;
  const {
    sourceX: t = 0,
    sourceY: n = 0,
    sourceAttachment: i = 0
    // TODO - support gl.readBuffer
  } = e || {};
  let {
    target: s = null,
    // following parameters are auto deduced if not provided
    sourceWidth: l,
    sourceHeight: o,
    sourceDepth: d,
    sourceFormat: m,
    sourceType: b
  } = e || {};
  const {
    framebuffer: A,
    deleteFramebuffer: M
  } = aI(r), {
    gl: E,
    handle: k
  } = A;
  l || (l = A.width), o || (o = A.height);
  const U = (q = A.colorAttachments[i]) == null ? void 0 : q.texture;
  if (!U)
    throw new Error(`Invalid framebuffer attachment ${i}`);
  d = (U == null ? void 0 : U.depth) || 1, m || (m = (U == null ? void 0 : U.glFormat) || 6408), b || (b = (U == null ? void 0 : U.glType) || 5121), s = r7(s, b, m, l, o), b = b || Wz(s);
  const V = E.bindFramebuffer(36160, k);
  return E.readBuffer(36064 + i), E.readPixels(t, n, l, o, m, b, s), E.readBuffer(36064), E.bindFramebuffer(36160, V || null), M && A.destroy(), s;
}
function e7(r, e) {
  const {
    target: t,
    sourceX: n = 0,
    sourceY: i = 0,
    sourceFormat: s = 6408,
    targetByteOffset: l = 0
  } = e || {};
  let {
    sourceWidth: o,
    sourceHeight: d,
    sourceType: m
  } = e || {};
  const {
    framebuffer: b,
    deleteFramebuffer: A
  } = aI(r);
  o = o || b.width, d = d || b.height;
  const M = b;
  m = m || 5121;
  let E = t;
  if (!E) {
    const U = sI(s), V = Zz(m), q = l + o * d * U * V;
    E = M.device.createBuffer({
      byteLength: q
    });
  }
  const k = r.device.createCommandEncoder();
  return k.copyTextureToBuffer({
    sourceTexture: r,
    width: o,
    height: d,
    origin: [n, i],
    destinationBuffer: E,
    byteOffset: l
  }), k.destroy(), A && b.destroy(), E;
}
function aI(r) {
  return r instanceof $_ ? {
    framebuffer: r,
    deleteFramebuffer: !1
  } : {
    framebuffer: t7(r),
    deleteFramebuffer: !0
  };
}
function t7(r, e) {
  const {
    device: t,
    width: n,
    height: i,
    id: s
  } = r;
  return t.createFramebuffer({
    ...e,
    id: `framebuffer-for-${s}`,
    width: n,
    height: i,
    colorAttachments: [r]
  });
}
function r7(r, e, t, n, i, s) {
  if (r)
    return r;
  e || (e = 5121);
  const l = Xz(e, {
    clamped: !1
  }), o = sI(t);
  return new l(n * i * o);
}
class Tg extends ts {
  constructor(t, n) {
    super(t, n);
    // readonly MAX_ATTRIBUTES: number;
    H(this, "device");
    H(this, "gl");
    H(this, "handle");
    H(this, "sampler", void 0);
    // TODO - currently unused in WebGL. Create dummy sampler?
    H(this, "view", void 0);
    // TODO - currently unused in WebGL. Create dummy view?
    H(this, "mipmaps");
    // Texture type
    /** Whether the internal format is compressed */
    H(this, "compressed");
    /**
     * The WebGL target corresponding to the texture type
     * @note `target` cannot be modified by bind:
     * textures are special because when you first bind them to a target,
     * When you first bind a texture as a GL_TEXTURE_2D, you are saying that this texture is a 2D texture.
     * And it will always be a 2D texture; this state cannot be changed ever.
     * A texture that was first bound as a GL_TEXTURE_2D, must always be bound as a GL_TEXTURE_2D;
     * attempting to bind it as GL_TEXTURE_3D will give rise to a run-time error
     */
    H(this, "glTarget");
    /** The WebGL format - essentially channel structure */
    H(this, "glFormat");
    /** The WebGL data format - the type of each channel */
    H(this, "glType");
    /** The WebGL constant corresponding to the WebGPU style constant in format */
    H(this, "glInternalFormat");
    // state
    /** Texture binding slot - TODO - move to texture view? */
    H(this, "textureUnit", 0);
    const i = {
      ...this.props
    };
    i.data = n.data, this.device = t, this.gl = this.device.gl, this.glTarget = Jz(this.props.dimension);
    const s = tI(this.props.format);
    this.glInternalFormat = s.internalFormat, this.glFormat = s.format, this.glType = s.type, this.compressed = s.compressed, this.mipmaps = !!this.props.mipmaps, this._initialize(i), Object.seal(this);
  }
  /** Initialize texture with supplied props */
  // eslint-disable-next-line max-statements
  _initialize(t) {
    this.handle = this.props.handle || this.gl.createTexture(), this.device.setSpectorMetadata(this.handle, {
      ...this.props,
      data: t.data
    });
    let {
      width: n,
      height: i
    } = t;
    if (!n || !i) {
      const s = ts.getTextureDataSize(t.data);
      n = (s == null ? void 0 : s.width) || 1, i = (s == null ? void 0 : s.height) || 1;
    }
    if (this.width = n, this.height = i, this.depth = t.depth, this.setSampler(t.sampler), this.view = new Ud(this.device, {
      ...this.props,
      texture: this
    }), this.bind(), Kz(this.gl, this.mipLevels, this), t.data)
      switch (t.dimension) {
        case "1d":
          this.setTexture1DData(t.data);
          break;
        case "2d":
          this.setTexture2DData(t.data);
          break;
        case "3d":
          this.setTexture3DData(t.data);
          break;
        case "cube":
          this.setTextureCubeData(t.data);
          break;
        case "2d-array":
          this.setTextureArrayData(t.data);
          break;
        case "cube-array":
          this.setTextureCubeArrayData(t.data);
          break;
        // @ts-expect-error
        default:
          throw new Error(t.dimension);
      }
    this.mipmaps && this.generateMipmap();
  }
  destroy() {
    this.handle && (this.gl.deleteTexture(this.handle), this.removeStats(), this.trackDeallocatedMemory("Texture"), this.destroyed = !0);
  }
  createView(t) {
    return new Ud(this.device, {
      ...t,
      texture: this
    });
  }
  setSampler() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n;
    t instanceof _v ? (this.sampler = t, n = t.props) : (this.sampler = new _v(this.device, t), n = t);
    const i = iI(n);
    this._setSamplerParameters(i);
  }
  // Call to regenerate mipmaps after modifying texture(s)
  generateMipmap(t) {
    if (!(!(this.device.isTextureFormatRenderable(this.props.format) && this.device.isTextureFormatFilterable(this.props.format)) && (cr.warn(`${this} is not renderable or filterable, may not be able to generate mipmaps`)(), !(t != null && t.force))))
      try {
        this.gl.bindTexture(this.glTarget, this.handle), this.gl.generateMipmap(this.glTarget);
      } catch (i) {
        cr.warn(`Error generating mipmap for ${this}: ${i.message}`)();
      } finally {
        this.gl.bindTexture(this.glTarget, null);
      }
  }
  // Image Data Setters
  copyExternalImage(t) {
    const n = ts.getExternalImageSize(t.image), i = {
      ...ts.defaultCopyExternalImageOptions,
      ...n,
      ...t
    }, {
      image: s,
      depth: l,
      mipLevel: o,
      x: d,
      y: m,
      z: b,
      flipY: A
    } = i;
    let {
      width: M,
      height: E
    } = i;
    const {
      dimension: k,
      glTarget: U,
      glFormat: V,
      glInternalFormat: q,
      glType: Y
    } = this;
    if (M = Math.min(M, this.width - d), E = Math.min(E, this.height - m), t.sourceX || t.sourceY)
      throw new Error("WebGL does not support sourceX/sourceY)");
    return f3(this.device.gl, this.handle, s, {
      dimension: k,
      mipLevel: o,
      x: d,
      y: m,
      z: b,
      width: M,
      height: E,
      depth: l,
      glFormat: V,
      glType: Y,
      glTarget: U,
      flipY: A
    }), {
      width: i.width,
      height: i.height
    };
  }
  setTexture1DData(t) {
    throw new Error("setTexture1DData not supported in WebGL.");
  }
  /** Set a simple texture */
  setTexture2DData(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    this.bind();
    const i = ts.normalizeTextureData(t, this);
    i.length > 1 && this.props.mipmaps !== !1 && cr.warn(`Texture ${this.id} mipmap and multiple LODs.`)();
    for (let s = 0; s < i.length; s++) {
      const l = i[s];
      this._setMipLevel(n, s, l);
    }
    this.unbind();
  }
  /**
   * Sets a 3D texture
   * @param data
   */
  setTexture3DData(t) {
    if (this.props.dimension !== "3d")
      throw new Error(this.id);
    ArrayBuffer.isView(t) && (this.bind(), d3(this.device.gl, t, this), this.unbind());
  }
  /**
   * Set a Texture Cube Data
   * @todo - could support TextureCubeArray with depth
   * @param data
   * @param index
   */
  setTextureCubeData(t) {
    if (this.props.dimension !== "cube")
      throw new Error(this.id);
    for (const n of ts.CubeFaces)
      this.setTextureCubeFaceData(t[n], n);
  }
  /**
   * Sets an entire texture array
   * @param data
   */
  setTextureArrayData(t) {
    throw this.props.dimension !== "2d-array" ? new Error(this.id) : new Error("setTextureArrayData not implemented.");
  }
  /**
   * Sets an entire texture cube array
   * @param data
   */
  setTextureCubeArrayData(t) {
    throw new Error("setTextureCubeArrayData not supported in WebGL2.");
  }
  setTextureCubeFaceData(t, n) {
    Array.isArray(t) && t.length > 1 && this.props.mipmaps !== !1 && cr.warn(`${this.id} has mipmap and multiple LODs.`)();
    const i = ts.CubeFaces.indexOf(n);
    this.setTexture2DData(t, i);
  }
  // DEPRECATED METHODS
  /** Update external texture (video frame or canvas) @deprecated Use ExternalTexture */
  update() {
    throw new Error("Texture.update() not implemented. Use ExternalTexture");
  }
  // INTERNAL METHODS
  /** @todo update this method to accept LODs */
  setImageDataForFace(t) {
    const {
      face: n,
      width: i,
      height: s,
      pixels: l,
      data: o,
      format: d = 6408,
      type: m = 5121
      // generateMipmap = false // TODO
    } = t, {
      gl: b
    } = this, A = l || o;
    this.bind(), A instanceof Promise ? A.then((M) => this.setImageDataForFace(Object.assign({}, t, {
      face: n,
      data: M,
      pixels: M
    }))) : this.width || this.height ? b.texImage2D(n, 0, d, i, s, 0, d, m, A) : b.texImage2D(n, 0, d, d, m, A);
  }
  _getImageDataMap(t) {
    for (let n = 0; n < ts.CubeFaces.length; ++n) {
      const i = ts.CubeFaces[n];
      t[i] && (t[34069 + n] = t[i], delete t[i]);
    }
    return t;
  }
  // RESOURCE METHODS
  /**
   * Sets sampler parameters on texture
   */
  _setSamplerParameters(t) {
    cr.log(1, `${this.id} sampler parameters`, this.device.getGLKeys(t))(), this.gl.bindTexture(this.glTarget, this.handle);
    for (const [n, i] of Object.entries(t)) {
      const s = Number(n), l = i;
      switch (s) {
        case 33082:
        case 33083:
          this.gl.texParameterf(this.glTarget, s, l);
          break;
        case 10241:
          this.gl.texParameteri(this.glTarget, s, l);
          break;
        case 10242:
        case 10243:
          this.gl.texParameteri(this.glTarget, s, l);
          break;
        case 34046:
          this.device.features.has("texture-filterable-anisotropic-webgl") && this.gl.texParameteri(this.glTarget, s, l);
          break;
        default:
          this.gl.texParameteri(this.glTarget, s, l);
          break;
      }
    }
    this.gl.bindTexture(this.glTarget, null);
  }
  // INTERNAL SETTERS
  /**
   * Copy a region of data from a CPU memory buffer into this texture.
   * @todo -   GLUnpackParameters parameters
   */
  _setMipLevel(t, n, i) {
    let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : this.glTarget;
    if (ts.isExternalImage(i)) {
      f3(this.device.gl, this.handle, i, {
        ...this,
        depth: t,
        mipLevel: n,
        glTarget: s,
        flipY: this.props.flipY
      });
      return;
    }
    if (ts.isTextureLevelData(i)) {
      d3(this.device.gl, i.data, {
        ...this,
        depth: t,
        mipLevel: n,
        glTarget: s
      });
      return;
    }
    throw new Error("Texture: invalid image data");
  }
  // HELPERS
  getActiveUnit() {
    return this.gl.getParameter(34016) - 33984;
  }
  bind(t) {
    const {
      gl: n
    } = this;
    return t !== void 0 && (this.textureUnit = t, n.activeTexture(33984 + t)), n.bindTexture(this.glTarget, this.handle), t;
  }
  unbind(t) {
    const {
      gl: n
    } = this;
    return t !== void 0 && (this.textureUnit = t, n.activeTexture(33984 + t)), n.bindTexture(this.glTarget, null), t;
  }
}
const n7 = [1, 2, 4, 8];
class i7 extends $1 {
  constructor(t, n) {
    var l;
    super(t, n);
    H(this, "device");
    /** Parameters that should be applied before each draw call */
    H(this, "glParameters");
    this.device = t;
    let i;
    if (!((l = n == null ? void 0 : n.parameters) != null && l.viewport))
      if (n != null && n.framebuffer) {
        const {
          width: o,
          height: d
        } = n.framebuffer;
        i = [0, 0, o, d];
      } else {
        const [o, d] = t.getCanvasContext().getDrawingBufferSize();
        i = [0, 0, o, d];
      }
    this.device.pushState(), this.setParameters({
      viewport: i,
      ...this.props.parameters
    });
    const s = this.props.framebuffer;
    if (s != null && s.handle)
      if (this.props.framebuffer) {
        const o = this.props.framebuffer.colorAttachments.map((d, m) => 36064 + m);
        this.device.gl.drawBuffers(o);
      } else
        this.device.gl.drawBuffers([1029]);
    this.clear();
  }
  end() {
    this.device.popState();
  }
  pushDebugGroup(t) {
  }
  popDebugGroup() {
  }
  insertDebugMarker(t) {
  }
  // beginOcclusionQuery(queryIndex: number): void;
  // endOcclusionQuery(): void;
  // executeBundles(bundles: Iterable<GPURenderBundle>): void;
  /**
   * Maps RenderPass parameters to GL parameters
   */
  setParameters() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const n = {
      ...this.glParameters
    };
    n.framebuffer = this.props.framebuffer || null, this.props.depthReadOnly && (n.depthMask = !this.props.depthReadOnly), n.stencilMask = this.props.stencilReadOnly ? 0 : 1, n[35977] = this.props.discard, t.viewport && (t.viewport.length >= 6 ? (n.viewport = t.viewport.slice(0, 4), n.depthRange = [t.viewport[4], t.viewport[5]]) : n.viewport = t.viewport), t.scissorRect && (n.scissorTest = !0, n.scissor = t.scissorRect), t.blendConstant && (n.blendColor = t.blendConstant), t.stencilReference && (console.warn("RenderPassParameters.stencilReference not yet implemented in WebGL"), t[2967] = t.stencilReference), t.colorMask && (n.colorMask = n7.map((i) => !!(i & t.colorMask))), this.glParameters = n, bp(this.device.gl, n);
  }
  beginOcclusionQuery(t) {
    const n = this.props.occlusionQuerySet;
    n == null || n.beginOcclusionQuery();
  }
  endOcclusionQuery() {
    const t = this.props.occlusionQuerySet;
    t == null || t.endOcclusionQuery();
  }
  // PRIVATE
  /**
   * Optionally clears depth, color and stencil buffers based on parameters
   */
  clear() {
    const t = {
      ...this.glParameters
    };
    let n = 0;
    this.props.clearColors && this.props.clearColors.forEach((i, s) => {
      i && this.clearColorBuffer(s, i);
    }), this.props.clearColor !== !1 && this.props.clearColors === void 0 && (n |= 16384, t.clearColor = this.props.clearColor), this.props.clearDepth !== !1 && (n |= 256, t.clearDepth = this.props.clearDepth), this.props.clearStencil !== !1 && (n |= 1024, t.clearStencil = this.props.clearStencil), n !== 0 && iy(this.device.gl, t, () => {
      this.device.gl.clear(n);
    });
  }
  /**
   * WebGL2 - clear a specific color buffer
   */
  clearColorBuffer() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0, 0];
    iy(this.device.gl, {
      framebuffer: this.props.framebuffer
    }, () => {
      switch (n.constructor) {
        case Int8Array:
        case Int16Array:
        case Int32Array:
          this.device.gl.clearBufferiv(6144, t, n);
          break;
        case Uint8Array:
        case Uint8ClampedArray:
        case Uint16Array:
        case Uint32Array:
          this.device.gl.clearBufferuiv(6144, t, n);
          break;
        case Float32Array:
          this.device.gl.clearBufferfv(6144, t, n);
          break;
        default:
          throw new Error("clearColorBuffer: color must be typed array");
      }
    });
  }
}
function s7(r) {
  return o7.includes(r);
}
const o7 = [35678, 35680, 35679, 35682, 36289, 36292, 36293, 36298, 36299, 36300, 36303, 36306, 36307, 36308, 36311], lI = {
  5126: [5126, 1, "float", "f32", "float32"],
  35664: [5126, 2, "vec2", "vec2<f32>", "float32x2"],
  35665: [5126, 3, "vec3", "vec3<f32>", "float32x3"],
  35666: [5126, 4, "vec4", "vec4<f32>", "float32x4"],
  5124: [5124, 1, "int", "i32", "sint32"],
  35667: [5124, 2, "ivec2", "vec2<i32>", "sint32x2"],
  35668: [5124, 3, "ivec3", "vec3<i32>", "sint32x3"],
  35669: [5124, 4, "ivec4", "vec4<i32>", "sint32x4"],
  5125: [5125, 1, "uint", "u32", "uint32"],
  36294: [5125, 2, "uvec2", "vec2<u32>", "uint32x2"],
  36295: [5125, 3, "uvec3", "vec3<u32>", "uint32x3"],
  36296: [5125, 4, "uvec4", "vec4<u32>", "uint32x4"],
  35670: [5126, 1, "bool", "f32", "float32"],
  35671: [5126, 2, "bvec2", "vec2<f32>", "float32x2"],
  35672: [5126, 3, "bvec3", "vec3<f32>", "float32x3"],
  35673: [5126, 4, "bvec4", "vec4<f32>", "float32x4"],
  // TODO - are sizes/components below correct?
  35674: [5126, 8, "mat2", "mat2x2<f32>"],
  // 4
  35685: [5126, 8, "mat2x3", "mat2x3<f32>"],
  // 6
  35686: [5126, 8, "mat2x4", "mat2x4<f32>"],
  // 8
  35687: [5126, 12, "mat3x2", "mat3x2<f32>"],
  // 6
  35675: [5126, 12, "mat3", "mat3x3<f32>"],
  // 9
  35688: [5126, 12, "mat3x4", "mat3x4<f32>"],
  // 12
  35689: [5126, 16, "mat4x2", "mat4x2<f32>"],
  // 8
  35690: [5126, 16, "mat4x3", "mat4x3<f32>"],
  // 12
  35676: [5126, 16, "mat4", "mat4x4<f32>"]
  // 16
};
function cI(r) {
  const e = lI[r];
  if (!e)
    throw new Error("uniform");
  const [t, n, , i] = e;
  return {
    format: i,
    components: n,
    glType: t
  };
}
function a7(r) {
  const e = lI[r];
  if (!e)
    throw new Error("attribute");
  const [, t, , n, i] = e;
  return {
    attributeType: n,
    vertexFormat: i,
    components: t
  };
}
function l7(r, e) {
  const t = {
    attributes: [],
    bindings: []
  };
  t.attributes = c7(r, e);
  const n = f7(r, e);
  for (const o of n) {
    const d = o.uniforms.map((m) => ({
      name: m.name,
      format: m.format,
      byteOffset: m.byteOffset,
      byteStride: m.byteStride,
      arrayLength: m.arrayLength
    }));
    t.bindings.push({
      type: "uniform",
      name: o.name,
      group: 0,
      location: o.location,
      visibility: (o.vertex ? 1 : 0) & (o.fragment ? 2 : 0),
      minBindingSize: o.byteLength,
      uniforms: d
    });
  }
  const i = h7(r, e);
  let s = 0;
  for (const o of i)
    if (s7(o.type)) {
      const {
        viewDimension: d,
        sampleType: m
      } = p7(o.type);
      t.bindings.push({
        type: "texture",
        name: o.name,
        group: 0,
        location: s,
        viewDimension: d,
        sampleType: m
      }), o.textureUnit = s, s += 1;
    }
  i.length && (t.uniforms = i);
  const l = u7(r, e);
  return l != null && l.length && (t.varyings = l), t;
}
function c7(r, e) {
  const t = [], n = r.getProgramParameter(e, 35721);
  for (let i = 0; i < n; i++) {
    const s = r.getActiveAttrib(e, i);
    if (!s)
      throw new Error("activeInfo");
    const {
      name: l,
      type: o
      /* , size*/
    } = s, d = r.getAttribLocation(e, l);
    if (d >= 0) {
      const {
        attributeType: m
      } = a7(o), b = /instance/i.test(l) ? "instance" : "vertex";
      t.push({
        name: l,
        location: d,
        stepMode: b,
        type: m
        // size - for arrays, size is the number of elements in the array
      });
    }
  }
  return t.sort((i, s) => i.location - s.location), t;
}
function u7(r, e) {
  const t = [], n = r.getProgramParameter(e, 35971);
  for (let i = 0; i < n; i++) {
    const s = r.getTransformFeedbackVarying(e, i);
    if (!s)
      throw new Error("activeInfo");
    const {
      name: l,
      type: o,
      size: d
    } = s, {
      glType: m,
      components: b
    } = cI(o), A = {
      location: i,
      name: l,
      type: m,
      size: d * b
    };
    t.push(A);
  }
  return t.sort((i, s) => i.location - s.location), t;
}
function h7(r, e) {
  const t = [], n = r.getProgramParameter(e, 35718);
  for (let i = 0; i < n; i++) {
    const s = r.getActiveUniform(e, i);
    if (!s)
      throw new Error("activeInfo");
    const {
      name: l,
      size: o,
      type: d
    } = s, {
      name: m,
      isArray: b
    } = g7(l);
    let A = r.getUniformLocation(e, m);
    const M = {
      // WebGL locations are uniquely typed but just numbers
      location: A,
      name: m,
      size: o,
      type: d,
      isArray: b
    };
    if (t.push(M), M.size > 1)
      for (let E = 0; E < M.size; E++) {
        const k = `${m}[${E}]`;
        A = r.getUniformLocation(e, k);
        const U = {
          ...M,
          name: k,
          location: A
        };
        t.push(U);
      }
  }
  return t;
}
function f7(r, e) {
  const t = (s, l) => r.getActiveUniformBlockParameter(e, s, l), n = [], i = r.getProgramParameter(e, 35382);
  for (let s = 0; s < i; s++) {
    const l = {
      name: r.getActiveUniformBlockName(e, s) || "",
      location: t(s, 35391),
      byteLength: t(s, 35392),
      vertex: t(s, 35396),
      fragment: t(s, 35398),
      uniformCount: t(s, 35394),
      uniforms: []
    }, o = t(s, 35395) || [], d = r.getActiveUniforms(e, o, 35383), m = r.getActiveUniforms(e, o, 35384), b = r.getActiveUniforms(e, o, 35387), A = r.getActiveUniforms(e, o, 35388);
    for (let M = 0; M < l.uniformCount; ++M) {
      const E = r.getActiveUniform(e, o[M]);
      if (!E)
        throw new Error("activeInfo");
      l.uniforms.push({
        name: E.name,
        format: cI(d[M]).format,
        type: d[M],
        arrayLength: m[M],
        byteOffset: b[M],
        byteStride: A[M]
        // matrixStride: uniformStride[i],
        // rowMajor: uniformRowMajor[i]
      });
    }
    n.push(l);
  }
  return n.sort((s, l) => s.location - l.location), n;
}
const d7 = {
  35678: ["2d", "float"],
  35680: ["cube", "float"],
  35679: ["3d", "float"],
  35682: ["3d", "depth"],
  36289: ["2d-array", "float"],
  36292: ["2d-array", "depth"],
  36293: ["cube", "float"],
  36298: ["2d", "sint"],
  36299: ["3d", "sint"],
  36300: ["cube", "sint"],
  36303: ["2d-array", "uint"],
  36306: ["2d", "uint"],
  36307: ["3d", "uint"],
  36308: ["cube", "uint"],
  36311: ["2d-array", "uint"]
};
function p7(r) {
  const e = d7[r];
  if (!e)
    throw new Error("sampler");
  const [t, n] = e;
  return {
    viewDimension: t,
    sampleType: n
  };
}
function g7(r) {
  if (r[r.length - 1] !== "]")
    return {
      name: r,
      length: 1,
      isArray: !1
    };
  const t = /([^[]*)(\[[0-9]+\])?/.exec(r);
  if (!t || t.length < 2)
    throw new Error(`Failed to parse GLSL uniform name ${r}`);
  return {
    name: t[1],
    length: t[2] ? 1 : 0,
    isArray: !!t[2]
  };
}
function m7(r, e, t, n) {
  const i = r;
  let s = n;
  s === !0 && (s = 1), s === !1 && (s = 0);
  const l = typeof s == "number" ? [s] : s;
  switch (t) {
    case 35678:
    case 35680:
    case 35679:
    case 35682:
    case 36289:
    case 36292:
    case 36293:
    case 36298:
    case 36299:
    case 36300:
    case 36303:
    case 36306:
    case 36307:
    case 36308:
    case 36311:
      if (typeof n != "number")
        throw new Error("samplers must be set to integers");
      return r.uniform1i(e, n);
    case 5126:
      return r.uniform1fv(e, l);
    case 35664:
      return r.uniform2fv(e, l);
    case 35665:
      return r.uniform3fv(e, l);
    case 35666:
      return r.uniform4fv(e, l);
    case 5124:
      return r.uniform1iv(e, l);
    case 35667:
      return r.uniform2iv(e, l);
    case 35668:
      return r.uniform3iv(e, l);
    case 35669:
      return r.uniform4iv(e, l);
    case 35670:
      return r.uniform1iv(e, l);
    case 35671:
      return r.uniform2iv(e, l);
    case 35672:
      return r.uniform3iv(e, l);
    case 35673:
      return r.uniform4iv(e, l);
    // WEBGL2 - unsigned integers
    case 5125:
      return i.uniform1uiv(e, l, 1);
    case 36294:
      return i.uniform2uiv(e, l, 2);
    case 36295:
      return i.uniform3uiv(e, l, 3);
    case 36296:
      return i.uniform4uiv(e, l, 4);
    // WebGL2 - quadratic matrices
    // false: don't transpose the matrix
    case 35674:
      return r.uniformMatrix2fv(e, !1, l);
    case 35675:
      return r.uniformMatrix3fv(e, !1, l);
    case 35676:
      return r.uniformMatrix4fv(e, !1, l);
    // WebGL2 - rectangular matrices
    case 35685:
      return i.uniformMatrix2x3fv(e, !1, l);
    case 35686:
      return i.uniformMatrix2x4fv(e, !1, l);
    case 35687:
      return i.uniformMatrix3x2fv(e, !1, l);
    case 35688:
      return i.uniformMatrix3x4fv(e, !1, l);
    case 35689:
      return i.uniformMatrix4x2fv(e, !1, l);
    case 35690:
      return i.uniformMatrix4x3fv(e, !1, l);
  }
  throw new Error("Illegal uniform");
}
function _7(r) {
  return V5(r) !== null || typeof r == "number" || typeof r == "boolean";
}
function y7(r) {
  const e = {
    bindings: {},
    uniforms: {}
  };
  return Object.keys(r).forEach((t) => {
    const n = r[t];
    _7(n) ? e.uniforms[t] = n : e.bindings[t] = n;
  }), e;
}
function b7(r) {
  switch (r) {
    case "point-list":
      return 0;
    case "line-list":
      return 1;
    case "line-strip":
      return 3;
    case "triangle-list":
      return 4;
    case "triangle-strip":
      return 5;
    default:
      throw new Error(r);
  }
}
function v7(r) {
  switch (r) {
    case "point-list":
      return 0;
    case "line-list":
      return 1;
    case "line-strip":
      return 1;
    case "triangle-list":
      return 4;
    case "triangle-strip":
      return 4;
    default:
      throw new Error(r);
  }
}
const p3 = 4;
class x7 extends np {
  // TODO are these used?
  constructor(t, n) {
    super(t, n);
    /** The WebGL device that created this render pipeline */
    H(this, "device");
    /** Handle to underlying WebGL program */
    H(this, "handle");
    /** vertex shader */
    H(this, "vs");
    /** fragment shader */
    H(this, "fs");
    /** The layout extracted from shader by WebGL introspection APIs */
    H(this, "introspectedLayout");
    /** Uniforms set on this model */
    H(this, "uniforms", {});
    /** Bindings set on this model */
    H(this, "bindings", {});
    /** WebGL varyings */
    H(this, "varyings", null);
    H(this, "_uniformCount", 0);
    H(this, "_uniformSetters", {});
    this.device = t, this.handle = this.props.handle || this.device.gl.createProgram(), this.device.setSpectorMetadata(this.handle, {
      id: this.props.id
    }), this.vs = n.vs, this.fs = n.fs;
    const {
      varyings: i,
      bufferMode: s = 35981
    } = n;
    i && i.length > 0 && (this.varyings = i, this.device.gl.transformFeedbackVaryings(this.handle, i, s)), this._linkShaders(), cr.time(1, `RenderPipeline ${this.id} - shaderLayout introspection`)(), this.introspectedLayout = l7(this.device.gl, this.handle), cr.timeEnd(1, `RenderPipeline ${this.id} - shaderLayout introspection`)(), this.shaderLayout = w7(this.introspectedLayout, n.shaderLayout);
  }
  destroy() {
    this.handle && (this.device.gl.deleteProgram(this.handle), this.destroyed = !0);
  }
  /**
   * Bindings include: textures, samplers and uniform buffers
   * @todo needed for portable model
   */
  setBindings(t, n) {
    for (const [i, s] of Object.entries(t)) {
      const l = this.shaderLayout.bindings.find((o) => o.name === i) || this.shaderLayout.bindings.find((o) => o.name === `${i}Uniforms`);
      if (!l) {
        const o = this.shaderLayout.bindings.map((d) => `"${d.name}"`).join(", ");
        n != null && n.disableWarnings || cr.warn(`No binding "${i}" in render pipeline "${this.id}", expected one of ${o}`, s)();
        continue;
      }
      switch (s || cr.warn(`Unsetting binding "${i}" in render pipeline "${this.id}"`)(), l.type) {
        case "uniform":
          if (!(s instanceof Ag) && !(s.buffer instanceof Ag))
            throw new Error("buffer value");
          break;
        case "texture":
          if (!(s instanceof Ud || s instanceof Tg || s instanceof wg))
            throw new Error("texture value");
          break;
        case "sampler":
          cr.warn(`Ignoring sampler ${i}`)();
          break;
        default:
          throw new Error(l.type);
      }
      this.bindings[i] = s;
    }
  }
  /** @todo needed for portable model
   * @note The WebGL API is offers many ways to draw things
   * This function unifies those ways into a single call using common parameters with sane defaults
   */
  draw(t) {
    var V;
    const {
      renderPass: n,
      parameters: i = this.props.parameters,
      topology: s = this.props.topology,
      vertexArray: l,
      vertexCount: o,
      // indexCount,
      instanceCount: d,
      isInstanced: m = !1,
      firstVertex: b = 0,
      // firstIndex,
      // firstInstance,
      // baseVertex,
      transformFeedback: A
    } = t, M = b7(s), E = !!l.indexBuffer, k = (V = l.indexBuffer) == null ? void 0 : V.glIndexType;
    if (this.linkStatus !== "success")
      return cr.info(2, `RenderPipeline:${this.id}.draw() aborted - waiting for shader linking`)(), !1;
    if (!this._areTexturesRenderable())
      return cr.info(2, `RenderPipeline:${this.id}.draw() aborted - textures not yet loaded`)(), !1;
    this.device.gl.useProgram(this.handle), l.bindBeforeRender(n), A && A.begin(this.props.topology), this._applyBindings(), this._applyUniforms();
    const U = n;
    return zz(this.device, i, U.glParameters, () => {
      E && m ? this.device.gl.drawElementsInstanced(
        M,
        o || 0,
        // indexCount?
        k,
        b,
        d || 0
      ) : E ? this.device.gl.drawElements(M, o || 0, k, b) : m ? this.device.gl.drawArraysInstanced(M, b, o || 0, d || 0) : this.device.gl.drawArrays(M, b, o || 0), A && A.end();
    }), l.unbindAfterRender(n), !0;
  }
  // DEPRECATED METHODS
  setUniformsWebGL(t) {
    const {
      bindings: n
    } = y7(t);
    Object.keys(n).forEach((i) => {
      cr.warn(`Unsupported value "${JSON.stringify(n[i])}" used in setUniforms() for key ${i}. Use setBindings() instead?`)();
    }), Object.assign(this.uniforms, t);
  }
  // PRIVATE METHODS
  // setAttributes(attributes: Record<string, Buffer>): void {}
  // setBindings(bindings: Record<string, Binding>): void {}
  async _linkShaders() {
    const {
      gl: t
    } = this.device;
    if (t.attachShader(this.handle, this.vs.handle), t.attachShader(this.handle, this.fs.handle), cr.time(p3, `linkProgram for ${this.id}`)(), t.linkProgram(this.handle), cr.timeEnd(p3, `linkProgram for ${this.id}`)(), cr.level, !this.device.features.has("compilation-status-async-webgl")) {
      const i = this._getLinkStatus();
      this._reportLinkStatus(i);
      return;
    }
    cr.once(1, "RenderPipeline linking is asynchronous")(), await this._waitForLinkComplete(), cr.info(2, `RenderPipeline ${this.id} - async linking complete: ${this.linkStatus}`)();
    const n = this._getLinkStatus();
    this._reportLinkStatus(n);
  }
  /** Report link status. First, check for shader compilation failures if linking fails */
  async _reportLinkStatus(t) {
    var n;
    switch (t) {
      case "success":
        return;
      default:
        switch (this.vs.compilationStatus) {
          case "error":
            throw this.vs.debugShader(), new Error(`Error during compilation of shader ${this.vs.id}`);
          case "pending":
            this.vs.asyncCompilationStatus.then(() => this.vs.debugShader());
            break;
        }
        switch ((n = this.fs) == null ? void 0 : n.compilationStatus) {
          case "error":
            throw this.fs.debugShader(), new Error(`Error during compilation of shader ${this.fs.id}`);
          case "pending":
            this.fs.asyncCompilationStatus.then(() => this.fs.debugShader());
            break;
        }
        const i = this.device.gl.getProgramInfoLog(this.handle);
        throw new Error(`Error during ${t}: ${i}`);
    }
  }
  /**
   * Get the shader compilation status
   * TODO - Load log even when no error reported, to catch warnings?
   * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
   */
  _getLinkStatus() {
    const {
      gl: t
    } = this.device;
    return t.getProgramParameter(this.handle, 35714) ? (t.validateProgram(this.handle), t.getProgramParameter(this.handle, 35715) ? (this.linkStatus = "success", "success") : (this.linkStatus = "error", "validation")) : (this.linkStatus = "error", "linking");
  }
  /** Use KHR_parallel_shader_compile extension if available */
  async _waitForLinkComplete() {
    const t = async (s) => await new Promise((l) => setTimeout(l, s));
    if (!this.device.features.has("compilation-status-async-webgl")) {
      await t(10);
      return;
    }
    const {
      gl: i
    } = this.device;
    for (; ; ) {
      if (i.getProgramParameter(this.handle, 37297))
        return;
      await t(10);
    }
  }
  /**
   * Checks if all texture-values uniforms are renderable (i.e. loaded)
   * Update a texture if needed (e.g. from video)
   * Note: This is currently done before every draw call
   */
  _areTexturesRenderable() {
    let t = !0;
    for (const n of this.shaderLayout.bindings)
      !this.bindings[n.name] && !this.bindings[n.name.replace(/Uniforms$/, "")] && (cr.warn(`Binding ${n.name} not found in ${this.id}`)(), t = !1);
    return t;
  }
  /** Apply any bindings (before each draw call) */
  _applyBindings() {
    if (this.linkStatus !== "success")
      return;
    const {
      gl: t
    } = this.device;
    t.useProgram(this.handle);
    let n = 0, i = 0;
    for (const s of this.shaderLayout.bindings) {
      const l = this.bindings[s.name] || this.bindings[s.name.replace(/Uniforms$/, "")];
      if (!l)
        throw new Error(`No value for binding ${s.name} in ${this.id}`);
      switch (s.type) {
        case "uniform":
          const {
            name: o
          } = s, d = t.getUniformBlockIndex(this.handle, o);
          if (d === 4294967295)
            throw new Error(`Invalid uniform block name ${o}`);
          t.uniformBlockBinding(this.handle, i, d), l instanceof Ag ? t.bindBufferBase(35345, i, l.handle) : t.bindBufferRange(
            35345,
            i,
            // @ts-expect-error
            l.buffer.handle,
            // @ts-expect-error
            l.offset || 0,
            // @ts-expect-error
            l.size || l.buffer.byteLength - l.offset
          ), i += 1;
          break;
        case "texture":
          if (!(l instanceof Ud || l instanceof Tg || l instanceof wg))
            throw new Error("texture");
          let m;
          if (l instanceof Ud)
            m = l.texture;
          else if (l instanceof Tg)
            m = l;
          else if (l instanceof wg && l.colorAttachments[0] instanceof Ud)
            cr.warn("Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead")(), m = l.colorAttachments[0].texture;
          else
            throw new Error("No texture");
          t.activeTexture(33984 + n), t.bindTexture(m.glTarget, m.handle), n += 1;
          break;
        case "sampler":
          break;
        case "storage":
        case "read-only-storage":
          throw new Error(`binding type '${s.type}' not supported in WebGL`);
      }
    }
  }
  /**
   * Due to program sharing, uniforms need to be reset before every draw call
   * (though caching will avoid redundant WebGL calls)
   */
  _applyUniforms() {
    for (const t of this.shaderLayout.uniforms || []) {
      const {
        name: n,
        location: i,
        type: s,
        textureUnit: l
      } = t, o = this.uniforms[n] ?? l;
      o !== void 0 && m7(this.device.gl, i, s, o);
    }
  }
}
function w7(r, e) {
  const t = {
    ...r,
    attributes: r.attributes.map((n) => ({
      ...n
    }))
  };
  for (const n of (e == null ? void 0 : e.attributes) || []) {
    const i = t.attributes.find((s) => s.name === n.name);
    i ? (i.type = n.type || i.type, i.stepMode = n.stepMode || i.stepMode) : cr.warn(`shader layout attribute ${n.name} not present in shader`);
  }
  return t;
}
class A7 extends G1 {
  constructor(t) {
    super(t, {});
    H(this, "device");
    H(this, "commands", []);
    this.device = t;
  }
  submitCommands() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.commands;
    for (const n of t)
      switch (n.name) {
        case "copy-buffer-to-buffer":
          T7(this.device, n.options);
          break;
        case "copy-buffer-to-texture":
          S7(this.device, n.options);
          break;
        case "copy-texture-to-buffer":
          E7(this.device, n.options);
          break;
        case "copy-texture-to-texture":
          C7(this.device, n.options);
          break;
        // case 'clear-texture':
        //   _clearTexture(this.device, command.options);
        //   break;
        default:
          throw new Error(n.name);
      }
  }
}
function T7(r, e) {
  const t = e.sourceBuffer, n = e.destinationBuffer;
  r.gl.bindBuffer(36662, t.handle), r.gl.bindBuffer(36663, n.handle), r.gl.copyBufferSubData(36662, 36663, e.sourceOffset ?? 0, e.destinationOffset ?? 0, e.size), r.gl.bindBuffer(36662, null), r.gl.bindBuffer(36663, null);
}
function S7(r, e) {
  throw new Error("Not implemented");
}
function E7(r, e) {
  const {
    /** Texture to copy to/from. */
    sourceTexture: t,
    /**  Mip-map level of the texture to copy to/from. (Default 0) */
    mipLevel: n = 0,
    /** Defines which aspects of the texture to copy to/from. */
    aspect: i = "all",
    /** Width to copy */
    width: s = e.sourceTexture.width,
    /** Height to copy */
    height: l = e.sourceTexture.height,
    depthOrArrayLayers: o = 0,
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
    origin: d = [0, 0],
    /** Destination buffer */
    destinationBuffer: m,
    /** Offset, in bytes, from the beginning of the buffer to the start of the image data (default 0) */
    byteOffset: b = 0,
    /**
     * The stride, in bytes, between the beginning of each block row and the subsequent block row.
     * Required if there are multiple block rows (i.e. the copy height or depth is more than one block).
     */
    bytesPerRow: A,
    /**
     * Number of block rows per single image of the texture.
     * rowsPerImage &times; bytesPerRow is the stride, in bytes, between the beginning of each image of data and the subsequent image.
     * Required if there are multiple images (i.e. the copy depth is more than one).
     */
    rowsPerImage: M
  } = e;
  if (i !== "all")
    throw new Error("aspect not supported in WebGL");
  if (n !== 0 || o !== 0 || A || M)
    throw new Error("not implemented");
  const {
    framebuffer: E,
    destroyFramebuffer: k
  } = uI(t);
  let U;
  try {
    const V = m, q = s || E.width, Y = l || E.height, re = tI(E.colorAttachments[0].texture.props.format), Z = re.format, K = re.type;
    r.gl.bindBuffer(35051, V.handle), U = r.gl.bindFramebuffer(36160, E.handle), r.gl.readPixels(d[0], d[1], q, Y, Z, K, b);
  } finally {
    r.gl.bindBuffer(35051, null), U !== void 0 && r.gl.bindFramebuffer(36160, U), k && E.destroy();
  }
}
function C7(r, e) {
  const {
    /** Texture to copy to/from. */
    sourceTexture: t,
    /**  Mip-map level of the texture to copy to (Default 0) */
    destinationMipLevel: n = 0,
    /** Defines which aspects of the texture to copy to/from. */
    // aspect = 'all',
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy from. */
    origin: i = [0, 0],
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to. */
    destinationOrigin: s = [0, 0],
    /** Texture to copy to/from. */
    destinationTexture: l
    /**  Mip-map level of the texture to copy to/from. (Default 0) */
    // destinationMipLevel = options.mipLevel,
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
    // destinationOrigin = [0, 0],
    /** Defines which aspects of the texture to copy to/from. */
    // destinationAspect = options.aspect,
  } = e;
  let {
    width: o = e.destinationTexture.width,
    height: d = e.destinationTexture.height
    // depthOrArrayLayers = 0
  } = e;
  const {
    framebuffer: m,
    destroyFramebuffer: b
  } = uI(t), [A, M] = i, [E, k, U] = s, V = r.gl.bindFramebuffer(36160, m.handle);
  let q = null, Y;
  if (l instanceof Tg)
    q = l, o = Number.isFinite(o) ? o : q.width, d = Number.isFinite(d) ? d : q.height, q.bind(0), Y = q.glTarget;
  else
    throw new Error("invalid destination");
  switch (Y) {
    case 3553:
    case 34067:
      r.gl.copyTexSubImage2D(Y, n, E, k, A, M, o, d);
      break;
    case 35866:
    case 32879:
      r.gl.copyTexSubImage3D(Y, n, E, k, U, A, M, o, d);
      break;
  }
  q && q.unbind(), r.gl.bindFramebuffer(36160, V), b && m.destroy();
}
function uI(r) {
  if (r instanceof ts) {
    const {
      width: e,
      height: t,
      id: n
    } = r;
    return {
      framebuffer: r.device.createFramebuffer({
        id: `framebuffer-for-${n}`,
        width: e,
        height: t,
        colorAttachments: [r]
      }),
      destroyFramebuffer: !0
    };
  }
  return {
    framebuffer: r,
    destroyFramebuffer: !1
  };
}
class I7 extends q1 {
  constructor(t, n) {
    super(t, n);
    H(this, "device");
    H(this, "commandBuffer");
    this.device = t, this.commandBuffer = new A7(t);
  }
  destroy() {
  }
  finish() {
    this.commandBuffer.submitCommands();
  }
  // beginRenderPass(GPURenderPassDescriptor descriptor): GPURenderPassEncoder;
  // beginComputePass(optional GPUComputePassDescriptor descriptor = {}): GPUComputePassEncoder;
  // finish(options?: {id?: string}): GPUCommandBuffer;
  copyBufferToBuffer(t) {
    this.commandBuffer.commands.push({
      name: "copy-buffer-to-buffer",
      options: t
    });
  }
  copyBufferToTexture(t) {
    this.commandBuffer.commands.push({
      name: "copy-buffer-to-texture",
      options: t
    });
  }
  copyTextureToBuffer(t) {
    this.commandBuffer.commands.push({
      name: "copy-texture-to-buffer",
      options: t
    });
  }
  copyTextureToTexture(t) {
    this.commandBuffer.commands.push({
      name: "copy-texture-to-texture",
      options: t
    });
  }
  // clearTexture(options: ClearTextureOptions): void {
  //   this.commandBuffer.commands.push({name: 'copy-texture-to-texture', options});
  // }
  pushDebugGroup(t) {
  }
  popDebugGroup() {
  }
  insertDebugMarker(t) {
  }
  resolveQuerySet(t, n, i) {
  }
}
function M7(r) {
  const {
    target: e,
    source: t,
    start: n = 0,
    count: i = 1
  } = r, s = t.length, l = i * s;
  let o = 0;
  for (let d = n; o < s; o++)
    e[d++] = t[o];
  for (; o < l; )
    o < l - o ? (e.copyWithin(n + o, n, n + o), o *= 2) : (e.copyWithin(n + o, n, n + l - o), o = l);
  return r.target;
}
class Q2 extends H1 {
  // Create a VertexArray
  constructor(t, n) {
    super(t, n);
    H(this, "device");
    H(this, "handle");
    /** Attribute 0 buffer constant */
    H(this, "buffer", null);
    H(this, "bufferValue", null);
    this.device = t, this.handle = this.device.gl.createVertexArray();
  }
  get [Symbol.toStringTag]() {
    return "VertexArray";
  }
  /** * Attribute 0 can not be disable on most desktop OpenGL based browsers */
  static isConstantAttributeZeroSupported(t) {
    return j4() === "Chrome";
  }
  destroy() {
    var t;
    super.destroy(), this.buffer && ((t = this.buffer) == null || t.destroy()), this.handle && (this.device.gl.deleteVertexArray(this.handle), this.handle = void 0);
  }
  /**
  // Set (bind/unbind) an elements buffer, for indexed rendering.
  // Must be a Buffer bound to GL.ELEMENT_ARRAY_BUFFER or null. Constants not supported
   *
   * @param elementBuffer
   */
  setIndexBuffer(t) {
    const n = t;
    if (n && n.glTarget !== 34963)
      throw new Error("Use .setBuffer()");
    this.device.gl.bindVertexArray(this.handle), this.device.gl.bindBuffer(34963, n ? n.handle : null), this.indexBuffer = n, this.device.gl.bindVertexArray(null);
  }
  /** Set a location in vertex attributes array to a buffer, enables the location, sets divisor */
  setBuffer(t, n) {
    const i = n;
    if (i.glTarget === 34963)
      throw new Error("Use .setIndexBuffer()");
    const {
      size: s,
      type: l,
      stride: o,
      offset: d,
      normalized: m,
      integer: b,
      divisor: A
    } = this._getAccessor(t);
    this.device.gl.bindVertexArray(this.handle), this.device.gl.bindBuffer(34962, i.handle), b ? this.device.gl.vertexAttribIPointer(t, s, l, o, d) : this.device.gl.vertexAttribPointer(t, s, l, m, o, d), this.device.gl.bindBuffer(34962, null), this.device.gl.enableVertexAttribArray(t), this.device.gl.vertexAttribDivisor(t, A || 0), this.attributes[t] = i, this.device.gl.bindVertexArray(null);
  }
  /** Set a location in vertex attributes array to a constant value, disables the location */
  setConstantWebGL(t, n) {
    this._enable(t, !1), this.attributes[t] = n;
  }
  bindBeforeRender() {
    this.device.gl.bindVertexArray(this.handle), this._applyConstantAttributes();
  }
  unbindAfterRender() {
    this.device.gl.bindVertexArray(null);
  }
  // Internal methods
  /**
   * Constant attributes need to be reset before every draw call
   * Any attribute that is disabled in the current vertex array object
   * is read from the context's global constant value for that attribute location.
   * @note Constant attributes are only supported in WebGL, not in WebGPU
   */
  _applyConstantAttributes() {
    for (let t = 0; t < this.maxVertexAttributes; ++t) {
      const n = this.attributes[t];
      ArrayBuffer.isView(n) && this.device.setConstantAttributeWebGL(t, n);
    }
  }
  /**
   * Set a location in vertex attributes array to a buffer, enables the location, sets divisor
   * @note requires vertex array to be bound
   */
  // protected _setAttributeLayout(location: number): void {
  //   const {size, type, stride, offset, normalized, integer, divisor} = this._getAccessor(location);
  //   // WebGL2 supports *integer* data formats, i.e. GPU will see integer values
  //   if (integer) {
  //     this.device.gl.vertexAttribIPointer(location, size, type, stride, offset);
  //   } else {
  //     // Attaches ARRAY_BUFFER with specified buffer format to location
  //     this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
  //   }
  //   this.device.gl.vertexAttribDivisor(location, divisor || 0);
  // }
  /** Get an accessor from the  */
  _getAccessor(t) {
    const n = this.attributeInfos[t];
    if (!n)
      throw new Error(`Unknown attribute location ${t}`);
    const i = eI(n.bufferDataType);
    return {
      size: n.bufferComponents,
      type: i,
      stride: n.byteStride,
      offset: n.byteOffset,
      normalized: n.normalized,
      // it is the shader attribute declaration, not the vertex memory format,
      // that determines if the data in the buffer will be treated as integers.
      //
      // Also note that WebGL supports assigning non-normalized integer data to floating point attributes,
      // but as far as we can tell, WebGPU does not.
      integer: n.integer,
      divisor: n.stepMode === "instance" ? 1 : 0
    };
  }
  /**
   * Enabling an attribute location makes it reference the currently bound buffer
   * Disabling an attribute location makes it reference the global constant value
   * TODO - handle single values for size 1 attributes?
   * TODO - convert classic arrays based on known type?
   */
  _enable(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    const s = Q2.isConstantAttributeZeroSupported(this.device) || t !== 0;
    (n || s) && (t = Number(t), this.device.gl.bindVertexArray(this.handle), n ? this.device.gl.enableVertexAttribArray(t) : this.device.gl.disableVertexAttribArray(t), this.device.gl.bindVertexArray(null));
  }
  /**
   * Provide a means to create a buffer that is equivalent to a constant.
   * NOTE: Desktop OpenGL cannot disable attribute 0.
   * https://stackoverflow.com/questions/20305231/webgl-warning-attribute-0-is-disabled-
   * this-has-significant-performance-penalty
   */
  getConstantBuffer(t, n) {
    const i = P7(n), s = i.byteLength * t, l = i.length * t;
    if (this.buffer && s !== this.buffer.byteLength)
      throw new Error(`Buffer size is immutable, byte length ${s} !== ${this.buffer.byteLength}.`);
    let o = !this.buffer;
    if (this.buffer = this.buffer || this.device.createBuffer({
      byteLength: s
    }), o = o || !R7(i, this.bufferValue), o) {
      const d = ek(n.constructor, l);
      M7({
        target: d,
        source: i,
        start: 0,
        count: l
      }), this.buffer.write(d), this.bufferValue = n;
    }
    return this.buffer;
  }
}
function P7(r) {
  return Array.isArray(r) ? new Float32Array(r) : r;
}
function R7(r, e) {
  if (!r || !e || r.length !== e.length || r.constructor !== e.constructor)
    return !1;
  for (let t = 0; t < r.length; ++t)
    if (r[t] !== e[t])
      return !1;
  return !0;
}
class B7 extends W1 {
  constructor(t, n) {
    super(t, n);
    H(this, "device");
    H(this, "gl");
    H(this, "handle");
    /**
     * NOTE: The Model already has this information while drawing, but
     * TransformFeedback currently needs it internally, to look up
     * varying information outside of a draw() call.
     */
    H(this, "layout");
    H(this, "buffers", {});
    H(this, "unusedBuffers", {});
    /**
     * Allows us to avoid a Chrome bug where a buffer that is already bound to a
     * different target cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
     * This a major workaround, see: https://github.com/KhronosGroup/WebGL/issues/2346
     */
    H(this, "bindOnUse", !0);
    H(this, "_bound", !1);
    this.device = t, this.gl = t.gl, this.handle = this.props.handle || this.gl.createTransformFeedback(), this.layout = this.props.layout, n.buffers && this.setBuffers(n.buffers), Object.seal(this);
  }
  destroy() {
    this.gl.deleteTransformFeedback(this.handle), super.destroy();
  }
  begin() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "point-list";
    this.gl.bindTransformFeedback(36386, this.handle), this.bindOnUse && this._bindBuffers(), this.gl.beginTransformFeedback(v7(t));
  }
  end() {
    this.gl.endTransformFeedback(), this.bindOnUse && this._unbindBuffers(), this.gl.bindTransformFeedback(36386, null);
  }
  // SUBCLASS
  setBuffers(t) {
    this.buffers = {}, this.unusedBuffers = {}, this.bind(() => {
      for (const n in t)
        this.setBuffer(n, t[n]);
    });
  }
  setBuffer(t, n) {
    const i = this._getVaryingIndex(t), {
      buffer: s,
      byteLength: l,
      byteOffset: o
    } = this._getBufferRange(n);
    if (i < 0) {
      this.unusedBuffers[t] = s, cr.warn(`${this.id} unusedBuffers varying buffer ${t}`)();
      return;
    }
    this.buffers[i] = {
      buffer: s,
      byteLength: l,
      byteOffset: o
    }, this.bindOnUse || this._bindBuffer(i, s, o, l);
  }
  getBuffer(t) {
    if (g3(t))
      return this.buffers[t] || null;
    const n = this._getVaryingIndex(t);
    return n >= 0 ? this.buffers[n] : null;
  }
  bind() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.handle;
    if (typeof t != "function")
      return this.gl.bindTransformFeedback(36386, t), this;
    let n;
    return this._bound ? n = t() : (this.gl.bindTransformFeedback(36386, this.handle), this._bound = !0, n = t(), this._bound = !1, this.gl.bindTransformFeedback(36386, null)), n;
  }
  unbind() {
    this.bind(null);
  }
  // PRIVATE METHODS
  /** Extract offsets for bindBufferRange */
  _getBufferRange(t) {
    if (t instanceof Ag)
      return {
        buffer: t,
        byteOffset: 0,
        byteLength: t.byteLength
      };
    const {
      buffer: n,
      byteOffset: i = 0,
      byteLength: s = t.buffer.byteLength
    } = t;
    return {
      buffer: n,
      byteOffset: i,
      byteLength: s
    };
  }
  _getVaryingIndex(t) {
    if (g3(t))
      return Number(t);
    for (const n of this.layout.varyings)
      if (t === n.name)
        return n.location;
    return -1;
  }
  /**
   * Need to avoid chrome bug where buffer that is already bound to a different target
   * cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
   */
  _bindBuffers() {
    for (const t in this.buffers) {
      const {
        buffer: n,
        byteLength: i,
        byteOffset: s
      } = this._getBufferRange(this.buffers[t]);
      this._bindBuffer(Number(t), n, s, i);
    }
  }
  _unbindBuffers() {
    for (const t in this.buffers)
      this.gl.bindBufferBase(35982, Number(t), null);
  }
  _bindBuffer(t, n) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, s = arguments.length > 3 ? arguments[3] : void 0;
    const l = n && n.handle;
    !l || s === void 0 ? this.gl.bindBufferBase(35982, t, l) : this.gl.bindBufferRange(35982, t, l, i, s);
  }
}
function g3(r) {
  return typeof r == "number" ? Number.isInteger(r) : /^\d+$/.test(r);
}
class L7 extends X1 {
  // Create a query class
  constructor(t, n) {
    super(t, n);
    H(this, "device");
    H(this, "handle");
    H(this, "target", null);
    H(this, "_queryPending", !1);
    H(this, "_pollingPromise", null);
    if (this.device = t, n.count > 1)
      throw new Error("WebGL QuerySet can only have one value");
    this.handle = this.device.gl.createQuery(), Object.seal(this);
  }
  get [Symbol.toStringTag]() {
    return "Query";
  }
  destroy() {
    this.device.gl.deleteQuery(this.handle);
  }
  // FOR RENDER PASS AND COMMAND ENCODER
  /**
   * Shortcut for timer query (dependent on extension in both WebGL1 and 2)
   * Measures GPU time delta between this call and a matching `end` call in the
   * GPU instruction stream.
   */
  beginTimestampQuery() {
    return this._begin(35007);
  }
  endTimestampQuery() {
    this._end();
  }
  // Shortcut for occlusion queries
  beginOcclusionQuery(t) {
    return this._begin(t != null && t.conservative ? 36202 : 35887);
  }
  endOcclusionQuery() {
    this._end();
  }
  // Shortcut for transformFeedbackQuery
  beginTransformFeedbackQuery() {
    return this._begin(35976);
  }
  endTransformFeedbackQuery() {
    this._end();
  }
  async resolveQuery() {
    return [await this.pollQuery()];
  }
  // PRIVATE METHODS
  /**
   * Due to OpenGL API limitations, after calling `begin()` on one Query
   * instance, `end()` must be called on that same instance before
   * calling `begin()` on another query. While there can be multiple
   * outstanding queries representing disjoint `begin()`/`end()` intervals.
   * It is not possible to interleave or overlap `begin` and `end` calls.
   */
  _begin(t) {
    this._queryPending || (this.target = t, this.device.gl.beginQuery(this.target, this.handle));
  }
  // ends the current query
  _end() {
    this._queryPending || this.target && (this.device.gl.endQuery(this.target), this.target = null, this._queryPending = !0);
  }
  // Returns true if the query result is available
  isResultAvailable() {
    if (!this._queryPending)
      return !1;
    const t = this.device.gl.getQueryParameter(this.handle, 34919);
    return t && (this._queryPending = !1), t;
  }
  // Timing query is disjoint, i.e. results are invalid
  isTimerDisjoint() {
    return this.device.gl.getParameter(36795);
  }
  // Returns query result.
  getResult() {
    return this.device.gl.getQueryParameter(this.handle, 34918);
  }
  // Returns the query result, converted to milliseconds to match JavaScript conventions.
  getTimerMilliseconds() {
    return this.getResult() / 1e6;
  }
  // Polls the query
  pollQuery() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Number.POSITIVE_INFINITY;
    if (this._pollingPromise)
      return this._pollingPromise;
    let n = 0;
    return this._pollingPromise = new Promise((i, s) => {
      const l = () => {
        this.isResultAvailable() ? (i(this.getResult()), this._pollingPromise = null) : n++ > t ? (s("Timed out"), this._pollingPromise = null) : requestAnimationFrame(l);
      };
      requestAnimationFrame(l);
    }), this._pollingPromise;
  }
}
class zd extends Vh {
  //
  // Public API
  //
  constructor(t) {
    var A, M;
    super({
      ...t,
      id: t.id || kz("webgl-device")
    });
    //
    // Public `Device` API
    //
    /** type of this device */
    H(this, "type", "webgl");
    // Use the ! assertion to handle the case where _reuseDevices causes the constructor to return early
    /** The underlying WebGL context */
    H(this, "handle");
    H(this, "features");
    H(this, "limits");
    H(this, "info");
    H(this, "canvasContext");
    H(this, "lost");
    H(this, "_resolveContextLost");
    /** WebGL2 context. */
    H(this, "gl");
    H(this, "debug", !1);
    /** State used by luma.gl classes: TODO - move to canvasContext*/
    H(this, "_canvasSizeInfo", {
      clientWidth: 0,
      clientHeight: 0,
      devicePixelRatio: 1
    });
    /** State used by luma.gl classes - TODO - not used? */
    H(this, "_extensions", {});
    H(this, "_polyfilled", !1);
    /** Instance of Spector.js (if initialized) */
    H(this, "spectorJS");
    H(this, "renderPass", null);
    /** Store constants */
    H(this, "_constants");
    const n = Vh._getCanvasContextProps(t);
    if (!n)
      throw new Error("WebGLDevice requires props.createCanvasContext to be set");
    let i = (M = (A = n.canvas) == null ? void 0 : A.gl) == null ? void 0 : M.device;
    if (i)
      throw new Error(`WebGL context already attached to device ${i.id}`);
    this.canvasContext = new Tz(this, n), this.lost = new Promise((E) => {
      this._resolveContextLost = E;
    });
    const s = {
      ...t.webgl
    };
    n.alphaMode === "premultiplied" && (s.premultipliedAlpha = !0), t.powerPreference !== void 0 && (s.powerPreference = t.powerPreference);
    const o = this.props._handle || iz(this.canvasContext.canvas, {
      onContextLost: (E) => {
        var k;
        return (k = this._resolveContextLost) == null ? void 0 : k.call(this, {
          reason: "destroyed",
          message: "Entered sleep mode, or too many apps or browser tabs are using the GPU."
        });
      },
      // eslint-disable-next-line no-console
      onContextRestored: (E) => console.log("WebGL context restored")
    }, s);
    if (!o)
      throw new Error("WebGL context creation failed");
    if (i = o.device, i) {
      if (t._reuseDevices)
        return cr.log(1, `Not creating a new Device, instead returning a reference to Device ${i.id} already attached to WebGL context`, i)(), i._reused = !0, i;
      throw new Error(`WebGL context already attached to device ${i.id}`);
    }
    this.handle = o, this.gl = o, this.spectorJS = Cz({
      ...this.props,
      gl: this.handle
    }), this.gl.device = this, this.gl._version = 2, this.info = sz(this.gl, this._extensions), this.limits = new xz(this.gl), this.features = new vz(this.gl, this._extensions, this.props._disabledFeatures), this.props._initializeFeatures && this.features.initializeFeatures(), n.autoResize !== !1 && this.canvasContext.resize(), new Df(this.gl, {
      log: function() {
        for (var E = arguments.length, k = new Array(E), U = 0; U < E; U++)
          k[U] = arguments[U];
        return cr.log(1, ...k)();
      }
    }).trackState(this.gl, {
      copyState: !1
    });
    const m = t.debugWebGL || t.debug, b = t.debugWebGL;
    m && (this.gl = Pz(this.gl, {
      debugWebGL: m,
      traceWebGL: b
    }), cr.warn("WebGL debug mode activated. Performance reduced.")(), t.debugWebGL && (cr.level = Math.max(cr.level, 1)));
  }
  /**
   * Destroys the device
   *
   * @note "Detaches" from the WebGL context unless _reuseDevices is true.
   *
   * @note The underlying WebGL context is not immediately destroyed,
   * but may be destroyed later through normal JavaScript garbage collection.
   * This is a fundamental limitation since WebGL does not offer any
   * browser API for destroying WebGL contexts.
   */
  destroy() {
    !this.props._reuseDevices && !this._reused && delete this.gl.device;
  }
  get isLost() {
    return this.gl.isContextLost();
  }
  // IMPLEMENTATION OF ABSTRACT DEVICE
  createCanvasContext(t) {
    throw new Error("WebGL only supports a single canvas");
  }
  createBuffer(t) {
    const n = this._normalizeBufferProps(t);
    return new Ag(this, n);
  }
  createTexture(t) {
    return new Tg(this, t);
  }
  createExternalTexture(t) {
    throw new Error("createExternalTexture() not implemented");
  }
  createSampler(t) {
    return new _v(this, t);
  }
  createShader(t) {
    return new Uz(this, t);
  }
  createFramebuffer(t) {
    return new wg(this, t);
  }
  createVertexArray(t) {
    return new Q2(this, t);
  }
  createTransformFeedback(t) {
    return new B7(this, t);
  }
  createQuerySet(t) {
    return new L7(this, t);
  }
  createRenderPipeline(t) {
    return new x7(this, t);
  }
  beginRenderPass(t) {
    return new i7(this, t);
  }
  createComputePipeline(t) {
    throw new Error("ComputePipeline not supported in WebGL");
  }
  beginComputePass(t) {
    throw new Error("ComputePass not supported in WebGL");
  }
  createCommandEncoder() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return new I7(this, t);
  }
  /**
   * Offscreen Canvas Support: Commit the frame
   * https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/commit
   * Chrome's offscreen canvas does not require gl.commit
   */
  submit() {
    var t;
    (t = this.renderPass) == null || t.end(), this.renderPass = null;
  }
  //
  // TEMPORARY HACKS - will be removed in v9.1
  //
  /** @deprecated - should use command encoder */
  readPixelsToArrayWebGL(t, n) {
    return Qz(t, n);
  }
  /** @deprecated - should use command encoder */
  readPixelsToBufferWebGL(t, n) {
    return e7(t, n);
  }
  setParametersWebGL(t) {
    bp(this.gl, t);
  }
  getParametersWebGL(t) {
    return J5(this.gl, t);
  }
  withParametersWebGL(t, n) {
    return iy(this.gl, t, n);
  }
  resetWebGL() {
    cr.warn("WebGLDevice.resetWebGL is deprecated, use only for debugging")(), QU(this.gl);
  }
  _getDeviceSpecificTextureFormatCapabilities(t) {
    return mz(this.gl, t, this._extensions);
  }
  //
  // WebGL-only API (not part of `Device` API)
  //
  /**
   * Triggers device (or WebGL context) loss.
   * @note primarily intended for testing how application reacts to device loss
   */
  loseDevice() {
    var s;
    let t = !1;
    const i = this.getExtension("WEBGL_lose_context").WEBGL_lose_context;
    return i && (t = !0, i.loseContext()), (s = this._resolveContextLost) == null || s.call(this, {
      reason: "destroyed",
      message: "Application triggered context loss"
    }), t;
  }
  /** Save current WebGL context state onto an internal stack */
  pushState() {
    Df.get(this.gl).push();
  }
  /** Restores previously saved context state */
  popState() {
    Df.get(this.gl).pop();
  }
  /**
   * Storing data on a special field on WebGLObjects makes that data visible in SPECTOR chrome debug extension
   * luma.gl ids and props can be inspected
   */
  setSpectorMetadata(t, n) {
    t.__SPECTOR_Metadata = n;
  }
  /**
   * Returns the GL.<KEY> constant that corresponds to a numeric value of a GL constant
   * Be aware that there are some duplicates especially for constants that are 0,
   * so this isn't guaranteed to return the right key in all cases.
   */
  getGLKey(t, n) {
    const i = Number(t);
    for (const s in this.gl)
      if (this.gl[s] === i)
        return `GL.${s}`;
    return n != null && n.emptyIfUnknown ? "" : String(t);
  }
  /**
   * Returns a map with any GL.<KEY> constants mapped to strings, both for keys and values
   */
  getGLKeys(t) {
    const n = {
      emptyIfUnknown: !0
    };
    return Object.entries(t).reduce((i, s) => {
      let [l, o] = s;
      return i[`${l}:${this.getGLKey(l, n)}`] = `${o}:${this.getGLKey(o, n)}`, i;
    }, {});
  }
  /**
   * Set a constant value for a location. Disabled attributes at that location will read from this value
   * @note WebGL constants are stored globally on the WebGL context, not the VertexArray
   * so they need to be updated before every render
   * @todo - remember/cache values to avoid setting them unnecessarily?
   */
  setConstantAttributeWebGL(t, n) {
    const i = this.limits.maxVertexAttributes;
    this._constants = this._constants || new Array(i).fill(null);
    const s = this._constants[t];
    switch (s && D7(s, n) && cr.info(1, `setConstantAttributeWebGL(${t}) could have been skipped, value unchanged`)(), this._constants[t] = n, n.constructor) {
      case Float32Array:
        O7(this, t, n);
        break;
      case Int32Array:
        k7(this, t, n);
        break;
      case Uint32Array:
        N7(this, t, n);
        break;
      default:
        throw new Error("constant");
    }
  }
  /** Ensure extensions are only requested once */
  getExtension(t) {
    return lp(this.gl, t, this._extensions), this._extensions;
  }
}
function O7(r, e, t) {
  switch (t.length) {
    case 1:
      r.gl.vertexAttrib1fv(e, t);
      break;
    case 2:
      r.gl.vertexAttrib2fv(e, t);
      break;
    case 3:
      r.gl.vertexAttrib3fv(e, t);
      break;
    case 4:
      r.gl.vertexAttrib4fv(e, t);
      break;
  }
}
function k7(r, e, t) {
  r.gl.vertexAttribI4iv(e, t);
}
function N7(r, e, t) {
  r.gl.vertexAttribI4uiv(e, t);
}
function D7(r, e) {
  if (!r || !e || r.length !== e.length || r.constructor !== e.constructor)
    return !1;
  for (let t = 0; t < r.length; ++t)
    if (r[t] !== e[t])
      return !1;
  return !0;
}
const F7 = {
  WEBGL_depth_texture: {
    UNSIGNED_INT_24_8_WEBGL: 34042
  },
  OES_element_index_uint: {},
  OES_texture_float: {},
  OES_texture_half_float: {
    // @ts-expect-error different numbers?
    HALF_FLOAT_OES: 5131
  },
  EXT_color_buffer_float: {},
  OES_standard_derivatives: {
    FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 35723
  },
  EXT_frag_depth: {},
  EXT_blend_minmax: {
    MIN_EXT: 32775,
    MAX_EXT: 32776
  },
  EXT_shader_texture_lod: {}
}, U7 = (r) => ({
  drawBuffersWEBGL(e) {
    return r.drawBuffers(e);
  },
  COLOR_ATTACHMENT0_WEBGL: 36064,
  COLOR_ATTACHMENT1_WEBGL: 36065,
  COLOR_ATTACHMENT2_WEBGL: 36066,
  COLOR_ATTACHMENT3_WEBGL: 36067
}), z7 = (r) => ({
  VERTEX_ARRAY_BINDING_OES: 34229,
  createVertexArrayOES() {
    return r.createVertexArray();
  },
  deleteVertexArrayOES(e) {
    return r.deleteVertexArray(e);
  },
  isVertexArrayOES(e) {
    return r.isVertexArray(e);
  },
  bindVertexArrayOES(e) {
    return r.bindVertexArray(e);
  }
}), j7 = (r) => ({
  VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 35070,
  drawArraysInstancedANGLE() {
    return r.drawArraysInstanced(...arguments);
  },
  drawElementsInstancedANGLE() {
    return r.drawElementsInstanced(...arguments);
  },
  vertexAttribDivisorANGLE() {
    return r.vertexAttribDivisor(...arguments);
  }
});
function V7() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
  const e = HTMLCanvasElement.prototype;
  if (!r && e.originalGetContext) {
    e.getContext = e.originalGetContext, e.originalGetContext = void 0;
    return;
  }
  e.originalGetContext = e.getContext, e.getContext = function(t, n) {
    if (t === "webgl" || t === "experimental-webgl") {
      const i = this.originalGetContext("webgl2", n);
      return i instanceof HTMLElement && $7(i), i;
    }
    return this.originalGetContext(t, n);
  };
}
function $7(r) {
  r.getExtension("EXT_color_buffer_float");
  const e = {
    ...F7,
    WEBGL_disjoint_timer_query: r.getExtension("EXT_disjoint_timer_query_webgl2"),
    WEBGL_draw_buffers: U7(r),
    OES_vertex_array_object: z7(r),
    ANGLE_instanced_arrays: j7(r)
  }, t = r.getExtension;
  r.getExtension = function(i) {
    const s = t.call(r, i);
    return s || (i in e ? e[i] : null);
  };
  const n = r.getSupportedExtensions;
  r.getSupportedExtensions = function() {
    const i = n.apply(r) || [];
    return i == null ? void 0 : i.concat(Object.keys(e));
  };
}
const Dm = 1;
class q7 extends P6 {
  constructor() {
    super();
    /** type of device's created by this adapter */
    H(this, "type", "webgl");
    Vh.defaultProps = {
      ...Vh.defaultProps,
      ...J2
    }, zd.adapter = this;
  }
  /** Check if WebGL 2 is available */
  isSupported() {
    return typeof WebGL2RenderingContext < "u";
  }
  /** Force any created WebGL contexts to be WebGL2 contexts, polyfilled with WebGL1 extensions */
  enforceWebGL2(t) {
    V7(t);
  }
  /**
   * Get a device instance from a GL context
   * Creates a WebGLCanvasContext against the contexts canvas
   * @note autoResize will be disabled, assuming that whoever created the external context will be handling resizes.
   * @param gl
   * @returns
   */
  async attach(t) {
    if (t instanceof zd)
      return t;
    if ((t == null ? void 0 : t.device) instanceof Vh)
      return t.device;
    if (!G7(t))
      throw new Error("Invalid WebGL2RenderingContext");
    return new zd({
      _handle: t,
      createCanvasContext: {
        canvas: t.canvas,
        autoResize: !1
      }
    });
  }
  async create() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    cr.groupCollapsed(Dm, "WebGLDevice created")();
    const n = [];
    (t.debugWebGL || t.debug) && n.push(Mz()), t.debugSpectorJS && n.push(Ez(t));
    const i = await Promise.allSettled(n);
    for (const o of i)
      o.status === "rejected" && cr.error(`Failed to initialize debug libraries ${o.reason}`)();
    const s = new zd(t), l = `${s._reused ? "Reusing" : "Created"} device with WebGL2 ${s.debug ? "debug " : ""}context: ${s.info.vendor}, ${s.info.renderer} for canvas: ${s.canvasContext.id}`;
    return cr.probe(Dm, l)(), cr.table(Dm, s.info)(), cr.groupEnd(Dm)(), s;
  }
}
function G7(r) {
  return typeof WebGL2RenderingContext < "u" && r instanceof WebGL2RenderingContext ? !0 : !!(r && Number.isFinite(r._version));
}
const m3 = new q7();
function Ph() {
}
const H7 = (r) => {
  let {
    isDragging: e
  } = r;
  return e ? "grabbing" : "grab";
}, hI = {
  id: "",
  width: "100%",
  height: "100%",
  style: null,
  viewState: null,
  initialViewState: null,
  pickingRadius: 0,
  layerFilter: null,
  parameters: {},
  parent: null,
  device: null,
  deviceProps: {},
  gl: null,
  canvas: null,
  layers: [],
  effects: [],
  views: null,
  controller: null,
  // Rely on external controller, e.g. react-map-gl
  useDevicePixels: !0,
  touchAction: "none",
  eventRecognizerOptions: {},
  _framebuffer: null,
  _animate: !1,
  _pickable: !0,
  _typedArrayManagerProps: {},
  _customRender: null,
  widgets: [],
  onDeviceInitialized: Ph,
  onWebGLInitialized: Ph,
  onResize: Ph,
  onViewStateChange: Ph,
  onInteractionStateChange: Ph,
  onBeforeRender: Ph,
  onAfterRender: Ph,
  onLoad: Ph,
  onError: (r) => Gn.error(r.message, r.cause)(),
  onHover: null,
  onClick: null,
  onDragStart: null,
  onDrag: null,
  onDragEnd: null,
  _onMetrics: null,
  getCursor: H7,
  getTooltip: null,
  debug: !1,
  drawPickingColors: !1
};
class Fg {
  constructor(e) {
    this.width = 0, this.height = 0, this.userData = {}, this.device = null, this.canvas = null, this.viewManager = null, this.layerManager = null, this.effectManager = null, this.deckRenderer = null, this.deckPicker = null, this.eventManager = null, this.widgetManager = null, this.tooltip = null, this.animationLoop = null, this.cursorState = {
      isHovering: !1,
      isDragging: !1
    }, this.stats = new mp({
      id: "deck.gl"
    }), this.metrics = {
      fps: 0,
      setPropsTime: 0,
      updateAttributesTime: 0,
      framesRedrawn: 0,
      pickTime: 0,
      pickCount: 0,
      gpuTime: 0,
      gpuTimePerFrame: 0,
      cpuTime: 0,
      cpuTimePerFrame: 0,
      bufferMemory: 0,
      textureMemory: 0,
      renderbufferMemory: 0,
      gpuMemory: 0
    }, this._metricsCounter = 0, this._needsRedraw = "Initial render", this._pickRequest = {
      mode: "hover",
      x: -1,
      y: -1,
      radius: 0,
      event: null
    }, this._lastPointerDownInfo = null, this._onPointerMove = (n) => {
      const {
        _pickRequest: i
      } = this;
      if (n.type === "pointerleave")
        i.x = -1, i.y = -1, i.radius = 0;
      else {
        if (n.leftButton || n.rightButton)
          return;
        {
          const s = n.offsetCenter;
          if (!s)
            return;
          i.x = s.x, i.y = s.y, i.radius = this.props.pickingRadius;
        }
      }
      this.layerManager && (this.layerManager.context.mousePosition = {
        x: i.x,
        y: i.y
      }), i.event = n;
    }, this._onEvent = (n) => {
      const i = sv[n.type], s = n.offsetCenter;
      if (!i || !s || !this.layerManager)
        return;
      const l = this.layerManager.getLayers(), o = this.deckPicker.getLastPickedObject({
        x: s.x,
        y: s.y,
        layers: l,
        viewports: this.getViewports(s)
      }, this._lastPointerDownInfo), {
        layer: d
      } = o, m = d && (d[i] || d.props[i]), b = this.props[i];
      let A = !1;
      m && (A = m.call(d, o, n)), A || (b == null || b(o, n), this.widgetManager.onEvent(o, n));
    }, this._onPointerDown = (n) => {
      var l;
      if (((l = this.device) == null ? void 0 : l.type) === "webgpu")
        return;
      const i = n.offsetCenter, s = this._pick("pickObject", "pickObject Time", {
        x: i.x,
        y: i.y,
        radius: this.props.pickingRadius
      });
      this._lastPointerDownInfo = s.result[0] || s.emptyInfo;
    }, this.props = {
      ...hI,
      ...e
    }, e = this.props, e.viewState && e.initialViewState && Gn.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")(), this.viewState = this.props.initialViewState, e.device && (this.device = e.device);
    let t = this.device;
    !t && e.gl && (e.gl instanceof WebGLRenderingContext && Gn.error("WebGL1 context not supported.")(), t = m3.attach(e.gl)), t || (t = j1.createDevice({
      type: "best-available",
      // luma by default throws if a device is already attached
      // asynchronous device creation could happen after finalize() is called
      // TODO - createDevice should support AbortController?
      _reuseDevices: !0,
      adapters: [m3],
      ...e.deviceProps,
      createCanvasContext: {
        canvas: this._createCanvas(e),
        useDevicePixels: this.props.useDevicePixels,
        // TODO v9.2 - replace AnimationLoop's `autoResizeDrawingBuffer` with CanvasContext's `autoResize`
        autoResize: !1
      }
    })), this.animationLoop = this._createAnimationLoop(t, e), this.setProps(e), e._typedArrayManagerProps && Ng.setOptions(e._typedArrayManagerProps), this.animationLoop.start();
  }
  /** Stop rendering and dispose all resources */
  finalize() {
    var e, t, n, i, s, l, o, d, m, b;
    (e = this.animationLoop) == null || e.stop(), (t = this.animationLoop) == null || t.destroy(), this.animationLoop = null, this._lastPointerDownInfo = null, (n = this.layerManager) == null || n.finalize(), this.layerManager = null, (i = this.viewManager) == null || i.finalize(), this.viewManager = null, (s = this.effectManager) == null || s.finalize(), this.effectManager = null, (l = this.deckRenderer) == null || l.finalize(), this.deckRenderer = null, (o = this.deckPicker) == null || o.finalize(), this.deckPicker = null, (d = this.eventManager) == null || d.destroy(), this.eventManager = null, (m = this.widgetManager) == null || m.finalize(), this.widgetManager = null, !this.props.canvas && !this.props.device && !this.props.gl && this.canvas && ((b = this.canvas.parentElement) == null || b.removeChild(this.canvas), this.canvas = null);
  }
  /** Partially update props */
  setProps(e) {
    var n;
    this.stats.get("setProps Time").timeStart(), "onLayerHover" in e && Gn.removed("onLayerHover", "onHover")(), "onLayerClick" in e && Gn.removed("onLayerClick", "onClick")(), e.initialViewState && // depth = 3 when comparing viewStates: viewId.position.0
    !Cc(this.props.initialViewState, e.initialViewState, 3) && (this.viewState = e.initialViewState), Object.assign(this.props, e), this._setCanvasSize(this.props);
    const t = Object.create(this.props);
    Object.assign(t, {
      views: this._getViews(),
      width: this.width,
      height: this.height,
      viewState: this._getViewState()
    }), (n = this.animationLoop) == null || n.setProps(t), this.layerManager && (this.viewManager.setProps(t), this.layerManager.activateViewport(this.getViewports()[0]), this.layerManager.setProps(t), this.effectManager.setProps(t), this.deckRenderer.setProps(t), this.deckPicker.setProps(t), this.widgetManager.setProps(t)), this.stats.get("setProps Time").timeEnd();
  }
  // Public API
  /**
   * Check if a redraw is needed
   * @returns `false` or a string summarizing the redraw reason
   */
  needsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    if (!this.layerManager)
      return !1;
    if (this.props._animate)
      return "Deck._animate";
    let t = this._needsRedraw;
    e.clearRedrawFlags && (this._needsRedraw = !1);
    const n = this.viewManager.needsRedraw(e), i = this.layerManager.needsRedraw(e), s = this.effectManager.needsRedraw(e), l = this.deckRenderer.needsRedraw(e);
    return t = t || n || i || s || l, t;
  }
  /**
   * Redraw the GL context
   * @param reason If not provided, only redraw if deemed necessary. Otherwise redraw regardless of internal states.
   * @returns
   */
  redraw(e) {
    if (!this.layerManager)
      return;
    let t = this.needsRedraw({
      clearRedrawFlags: !0
    });
    t = e || t, t && (this.stats.get("Redraw Count").incrementCount(), this.props._customRender ? this.props._customRender(t) : this._drawLayers(t));
  }
  /** Flag indicating that the Deck instance has initialized its resources and it's safe to call public methods. */
  get isInitialized() {
    return this.viewManager !== null;
  }
  /** Get a list of views that are currently rendered */
  getViews() {
    return ro(this.viewManager), this.viewManager.views;
  }
  /** Get a list of viewports that are currently rendered.
   * @param rect If provided, only returns viewports within the given bounding box.
   */
  getViewports(e) {
    return ro(this.viewManager), this.viewManager.getViewports(e);
  }
  /** Get the current canvas element. */
  getCanvas() {
    return this.canvas;
  }
  /** Query the object rendered on top at a given point */
  pickObject(e) {
    const t = this._pick("pickObject", "pickObject Time", e).result;
    return t.length ? t[0] : null;
  }
  /* Query all rendered objects at a given point */
  pickMultipleObjects(e) {
    return e.depth = e.depth || 10, this._pick("pickObject", "pickMultipleObjects Time", e).result;
  }
  /* Query all objects rendered on top within a bounding box */
  pickObjects(e) {
    return this._pick("pickObjects", "pickObjects Time", e);
  }
  /** Experimental
   * Add a global resource for sharing among layers
   */
  _addResources(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    for (const n in e)
      this.layerManager.resourceManager.add({
        resourceId: n,
        data: e[n],
        forceUpdate: t
      });
  }
  /** Experimental
   * Remove a global resource
   */
  _removeResources(e) {
    for (const t of e)
      this.layerManager.resourceManager.remove(t);
  }
  /** Experimental
   * Register a default effect. Effects will be sorted by order, those with a low order will be rendered first
   */
  _addDefaultEffect(e) {
    this.effectManager.addDefaultEffect(e);
  }
  _addDefaultShaderModule(e) {
    this.layerManager.addDefaultShaderModule(e);
  }
  _removeDefaultShaderModule(e) {
    var t;
    (t = this.layerManager) == null || t.removeDefaultShaderModule(e);
  }
  _pick(e, t, n) {
    ro(this.deckPicker);
    const {
      stats: i
    } = this;
    i.get("Pick Count").incrementCount(), i.get(t).timeStart();
    const s = this.deckPicker[e]({
      // layerManager, viewManager and effectManager are always defined if deckPicker is
      layers: this.layerManager.getLayers(n),
      views: this.viewManager.getViews(),
      viewports: this.getViewports(n),
      onViewportActive: this.layerManager.activateViewport,
      effects: this.effectManager.getEffects(),
      ...n
    });
    return i.get(t).timeEnd(), s;
  }
  /** Resolve props.canvas to element */
  _createCanvas(e) {
    let t = e.canvas;
    return typeof t == "string" && (t = document.getElementById(t), ro(t)), t || (t = document.createElement("canvas"), t.id = e.id || "deckgl-overlay", (e.parent || document.body).appendChild(t)), Object.assign(t.style, e.style), t;
  }
  /** Updates canvas width and/or height, if provided as props */
  _setCanvasSize(e) {
    var i;
    if (!this.canvas)
      return;
    const {
      width: t,
      height: n
    } = e;
    if (t || t === 0) {
      const s = Number.isFinite(t) ? `${t}px` : t;
      this.canvas.style.width = s;
    }
    if (n || n === 0) {
      const s = Number.isFinite(n) ? `${n}px` : n;
      this.canvas.style.position = ((i = e.style) == null ? void 0 : i.position) || "absolute", this.canvas.style.height = s;
    }
  }
  /** If canvas size has changed, reads out the new size and update */
  _updateCanvasSize() {
    var i, s;
    const {
      canvas: e
    } = this;
    if (!e)
      return;
    const t = e.clientWidth ?? e.width, n = e.clientHeight ?? e.height;
    (t !== this.width || n !== this.height) && (this.width = t, this.height = n, (i = this.viewManager) == null || i.setProps({
      width: t,
      height: n
    }), (s = this.layerManager) == null || s.activateViewport(this.getViewports()[0]), this.props.onResize({
      width: t,
      height: n
    }));
  }
  _createAnimationLoop(e, t) {
    const {
      // width,
      // height,
      gl: n,
      // debug,
      onError: i,
      // onBeforeRender,
      // onAfterRender,
      useDevicePixels: s
    } = t;
    return new K8({
      device: e,
      useDevicePixels: s,
      // TODO v9
      autoResizeDrawingBuffer: !n,
      // do not auto resize external context
      autoResizeViewport: !1,
      // @ts-expect-error luma.gl needs to accept Promise<void> return value
      onInitialize: (l) => this._setDevice(l.device),
      onRender: this._onRenderFrame.bind(this),
      // @ts-expect-error typing mismatch: AnimationLoop does not accept onError:null
      onError: i
      // onBeforeRender,
      // onAfterRender,
    });
  }
  // Get the most relevant view state: props.viewState, if supplied, shadows internal viewState
  // TODO: For backwards compatibility ensure numeric width and height is added to the viewState
  _getViewState() {
    return this.props.viewState || this.viewState;
  }
  // Get the view descriptor list
  _getViews() {
    const {
      views: e
    } = this.props, t = Array.isArray(e) ? e : (
      // If null, default to a full screen map view port
      e ? [e] : [new X2({
        id: "default-view"
      })]
    );
    return t.length && this.props.controller && (t[0].props.controller = this.props.controller), t;
  }
  _onContextLost() {
    const {
      onError: e
    } = this.props;
    this.animationLoop && e && e(new Error("WebGL context is lost"));
  }
  /** Actually run picking */
  _pickAndCallback() {
    var t, n, i, s;
    if (((t = this.device) == null ? void 0 : t.type) === "webgpu")
      return;
    const {
      _pickRequest: e
    } = this;
    if (e.event) {
      const {
        result: l,
        emptyInfo: o
      } = this._pick("pickObject", "pickObject Time", e);
      this.cursorState.isHovering = l.length > 0;
      let d = o, m = !1;
      for (const b of l)
        d = b, m = ((n = b.layer) == null ? void 0 : n.onHover(b, e.event)) || m;
      m || ((s = (i = this.props).onHover) == null || s.call(i, d, e.event), this.widgetManager.onHover(d, e.event)), e.event = null;
    }
  }
  _updateCursor() {
    const e = this.props.parent || this.canvas;
    e && (e.style.cursor = this.props.getCursor(this.cursorState));
  }
  _setDevice(e) {
    var i, s;
    if (this.device = e, !this.animationLoop)
      return;
    this.canvas || (this.canvas = (i = this.device.canvasContext) == null ? void 0 : i.canvas), this.device.type === "webgl" && this.device.setParametersWebGL({
      blend: !0,
      blendFunc: [770, 771, 1, 771],
      polygonOffsetFill: !0,
      depthTest: !0,
      depthFunc: 515
    }), this.props.onDeviceInitialized(this.device), this.device.type === "webgl" && this.props.onWebGLInitialized(this.device.gl);
    const t = new j5();
    t.play(), this.animationLoop.attachTimeline(t), this.eventManager = new CF(this.props.parent || this.canvas, {
      touchAction: this.props.touchAction,
      recognizers: Object.keys(DT).map((l) => {
        var E;
        const [o, d, m, b] = DT[l], A = (E = this.props.eventRecognizerOptions) == null ? void 0 : E[l], M = {
          ...d,
          ...A,
          event: l
        };
        return {
          recognizer: new o(M),
          recognizeWith: m,
          requestFailure: b
        };
      }),
      events: {
        pointerdown: this._onPointerDown,
        pointermove: this._onPointerMove,
        pointerleave: this._onPointerMove
      }
    });
    for (const l in sv)
      this.eventManager.on(l, this._onEvent);
    this.viewManager = new xU({
      timeline: t,
      eventManager: this.eventManager,
      onViewStateChange: this._onViewStateChange.bind(this),
      onInteractionStateChange: this._onInteractionStateChange.bind(this),
      views: this._getViews(),
      viewState: this._getViewState(),
      width: this.width,
      height: this.height
    });
    const n = this.viewManager.getViewports()[0];
    this.layerManager = new vU(this.device, {
      deck: this,
      stats: this.stats,
      viewport: n,
      timeline: t
    }), this.effectManager = new kU({
      deck: this,
      device: this.device
    }), this.deckRenderer = new FU(this.device), this.deckPicker = new qU(this.device), this.widgetManager = new WU({
      deck: this,
      parentElement: (s = this.canvas) == null ? void 0 : s.parentElement
    }), this.widgetManager.addDefault(new ZU()), this.setProps(this.props), this._updateCanvasSize(), this.props.onLoad();
  }
  /** Internal only: default render function (redraw all layers and views) */
  _drawLayers(e, t) {
    var l;
    const {
      device: n,
      gl: i
    } = this.layerManager.context;
    this.props.onBeforeRender({
      device: n,
      gl: i
    });
    const s = {
      target: this.props._framebuffer,
      layers: this.layerManager.getLayers(),
      viewports: this.viewManager.getViewports(),
      onViewportActive: this.layerManager.activateViewport,
      views: this.viewManager.getViews(),
      pass: "screen",
      effects: this.effectManager.getEffects(),
      ...t
    };
    (l = this.deckRenderer) == null || l.renderLayers(s), s.pass === "screen" && this.widgetManager.onRedraw({
      viewports: s.viewports,
      layers: s.layers
    }), this.props.onAfterRender({
      device: n,
      gl: i
    });
  }
  // Callbacks
  _onRenderFrame() {
    var e;
    this._getFrameStats(), this._metricsCounter++ % 60 === 0 && (this._getMetrics(), this.stats.reset(), Gn.table(4, this.metrics)(), this.props._onMetrics && this.props._onMetrics(this.metrics)), this._updateCanvasSize(), this._updateCursor(), this.layerManager.updateLayers(), ((e = this.device) == null ? void 0 : e.type) !== "webgpu" && this._pickAndCallback(), this.redraw(), this.viewManager && this.viewManager.updateViewStates();
  }
  // Callbacks
  _onViewStateChange(e) {
    const t = this.props.onViewStateChange(e) || e.viewState;
    this.viewState && (this.viewState = {
      ...this.viewState,
      [e.viewId]: t
    }, this.props.viewState || this.viewManager && this.viewManager.setProps({
      viewState: this.viewState
    }));
  }
  _onInteractionStateChange(e) {
    this.cursorState.isDragging = e.isDragging || !1, this.props.onInteractionStateChange(e);
  }
  _getFrameStats() {
    const {
      stats: e
    } = this;
    e.get("frameRate").timeEnd(), e.get("frameRate").timeStart();
    const t = this.animationLoop.stats;
    e.get("GPU Time").addTime(t.get("GPU Time").lastTiming), e.get("CPU Time").addTime(t.get("CPU Time").lastTiming);
  }
  _getMetrics() {
    const {
      metrics: e,
      stats: t
    } = this;
    e.fps = t.get("frameRate").getHz(), e.setPropsTime = t.get("setProps Time").time, e.updateAttributesTime = t.get("Update Attributes").time, e.framesRedrawn = t.get("Redraw Count").count, e.pickTime = t.get("pickObject Time").time + t.get("pickMultipleObjects Time").time + t.get("pickObjects Time").time, e.pickCount = t.get("Pick Count").count, e.gpuTime = t.get("GPU Time").time, e.cpuTime = t.get("CPU Time").time, e.gpuTimePerFrame = t.get("GPU Time").getAverageTime(), e.cpuTimePerFrame = t.get("CPU Time").getAverageTime();
    const n = j1.stats.get("Memory Usage");
    e.bufferMemory = n.get("Buffer Memory").count, e.textureMemory = n.get("Texture Memory").count, e.renderbufferMemory = n.get("Renderbuffer Memory").count, e.gpuMemory = n.get("GPU Memory").count;
  }
}
Fg.defaultProps = hI;
Fg.VERSION = kO;
function W7(r) {
  switch (r) {
    case "float64":
      return Float64Array;
    case "uint8":
    case "unorm8":
      return Uint8ClampedArray;
    default:
      return MC(r);
  }
}
const X7 = IC;
function Fm(r, e, t) {
  const n = t === "webgpu" && e.type === "uint8" ? "unorm8" : e.type;
  return {
    attribute: r,
    // @ts-expect-error Not all combinations are valid vertex formats; it's up to DataColumn to ensure
    format: e.size > 1 ? `${n}x${e.size}` : e.type,
    byteOffset: e.offset || 0
    // Note stride is set on the top level
  };
}
function Mf(r) {
  return r.stride || r.size * r.bytesPerElement;
}
function Z7(r, e) {
  return r.type === e.type && r.size === e.size && Mf(r) === Mf(e) && (r.offset || 0) === (e.offset || 0);
}
function yv(r, e) {
  e.offset && Gn.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
  const t = Mf(r), n = e.vertexOffset !== void 0 ? e.vertexOffset : r.vertexOffset || 0, i = e.elementOffset || 0, s = (
    // offsets defined by the attribute
    n * t + i * r.bytesPerElement + // offsets defined by external buffers if any
    (r.offset || 0)
  );
  return {
    ...e,
    offset: s,
    stride: t
  };
}
function Y7(r, e) {
  const t = yv(r, e);
  return {
    high: t,
    low: {
      ...t,
      offset: t.offset + r.size * 4
    }
  };
}
class K7 {
  /* eslint-disable max-statements */
  constructor(e, t, n) {
    this._buffer = null, this.device = e, this.id = t.id || "", this.size = t.size || 1;
    const i = t.logicalType || t.type, s = i === "float64";
    let {
      defaultValue: l
    } = t;
    l = Number.isFinite(l) ? [l] : l || new Array(this.size).fill(0);
    let o;
    s ? o = "float32" : !i && t.isIndexed ? o = "uint32" : o = i || "float32";
    let d = W7(i || o);
    this.doublePrecision = s, s && t.fp64 === !1 && (d = Float32Array), this.value = null, this.settings = {
      ...t,
      defaultType: d,
      defaultValue: l,
      logicalType: i,
      type: o,
      normalized: o.includes("norm"),
      size: this.size,
      bytesPerElement: d.BYTES_PER_ELEMENT
    }, this.state = {
      ...n,
      externalBuffer: null,
      bufferAccessor: this.settings,
      allocatedValue: null,
      numInstances: 0,
      bounds: null,
      constant: !1
    };
  }
  /* eslint-enable max-statements */
  get isConstant() {
    return this.state.constant;
  }
  get buffer() {
    return this._buffer;
  }
  get byteOffset() {
    const e = this.getAccessor();
    return e.vertexOffset ? e.vertexOffset * Mf(e) : 0;
  }
  get numInstances() {
    return this.state.numInstances;
  }
  set numInstances(e) {
    this.state.numInstances = e;
  }
  delete() {
    this._buffer && (this._buffer.delete(), this._buffer = null), Ng.release(this.state.allocatedValue);
  }
  getBuffer() {
    return this.state.constant ? null : this.state.externalBuffer || this._buffer;
  }
  getValue() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.id, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    const n = {};
    if (this.state.constant) {
      const i = this.value;
      if (t) {
        const s = yv(this.getAccessor(), t), l = s.offset / i.BYTES_PER_ELEMENT, o = s.size || this.size;
        n[e] = i.subarray(l, l + o);
      } else
        n[e] = i;
    } else
      n[e] = this.getBuffer();
    return this.doublePrecision && (this.value instanceof Float64Array ? n[`${e}64Low`] = n[e] : n[`${e}64Low`] = new Float32Array(this.size)), n;
  }
  _getBufferLayout() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.id, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    const n = this.getAccessor(), i = [], s = {
      name: this.id,
      byteStride: Mf(n),
      attributes: i
    };
    if (this.doublePrecision) {
      const l = Y7(n, t || {});
      i.push(Fm(e, {
        ...n,
        ...l.high
      }, this.device.type), Fm(`${e}64Low`, {
        ...n,
        ...l.low
      }, this.device.type));
    } else if (t) {
      const l = yv(n, t);
      i.push(Fm(e, {
        ...n,
        ...l
      }, this.device.type));
    } else
      i.push(Fm(e, n, this.device.type));
    return s;
  }
  setAccessor(e) {
    this.state.bufferAccessor = e;
  }
  getAccessor() {
    return this.state.bufferAccessor;
  }
  // Returns [min: Array(size), max: Array(size)]
  /* eslint-disable max-depth */
  getBounds() {
    if (this.state.bounds)
      return this.state.bounds;
    let e = null;
    if (this.state.constant && this.value) {
      const t = Array.from(this.value);
      e = [t, t];
    } else {
      const {
        value: t,
        numInstances: n,
        size: i
      } = this, s = n * i;
      if (t && s && t.length >= s) {
        const l = new Array(i).fill(1 / 0), o = new Array(i).fill(-1 / 0);
        for (let d = 0; d < s; )
          for (let m = 0; m < i; m++) {
            const b = t[d++];
            b < l[m] && (l[m] = b), b > o[m] && (o[m] = b);
          }
        e = [l, o];
      }
    }
    return this.state.bounds = e, e;
  }
  // returns true if success
  // eslint-disable-next-line max-statements
  setData(e) {
    const {
      state: t
    } = this;
    let n;
    ArrayBuffer.isView(e) ? n = {
      value: e
    } : e instanceof gs ? n = {
      buffer: e
    } : n = e;
    const i = {
      ...this.settings,
      ...n
    };
    if (ArrayBuffer.isView(n.value)) {
      if (!n.type)
        if (this.doublePrecision && n.value instanceof Float64Array)
          i.type = "float32";
        else {
          const l = X7(n.value);
          i.type = i.normalized ? l.replace("int", "norm") : l;
        }
      i.bytesPerElement = n.value.BYTES_PER_ELEMENT, i.stride = Mf(i);
    }
    if (t.bounds = null, n.constant) {
      let s = n.value;
      if (s = this._normalizeValue(s, [], 0), this.settings.normalized && (s = this.normalizeConstant(s)), !(!t.constant || !this._areValuesEqual(s, this.value)))
        return !1;
      t.externalBuffer = null, t.constant = !0, this.value = ArrayBuffer.isView(s) ? s : new Float32Array(s);
    } else if (n.buffer) {
      const s = n.buffer;
      t.externalBuffer = s, t.constant = !1, this.value = n.value || null;
    } else if (n.value) {
      this._checkExternalBuffer(n);
      let s = n.value;
      t.externalBuffer = null, t.constant = !1, this.value = s;
      let {
        buffer: l
      } = this;
      const o = Mf(i), d = (i.vertexOffset || 0) * o;
      if (this.doublePrecision && s instanceof Float64Array && (s = Tb(s, i)), this.settings.isIndexed) {
        const b = this.settings.defaultType;
        s.constructor !== b && (s = new b(s));
      }
      const m = s.byteLength + d + o * 2;
      (!l || l.byteLength < m) && (l = this._createBuffer(m)), l.write(s, d);
    }
    return this.setAccessor(i), !0;
  }
  updateSubBuffer() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.state.bounds = null;
    const t = this.value, {
      startOffset: n = 0,
      endOffset: i
    } = e;
    this.buffer.write(this.doublePrecision && t instanceof Float64Array ? Tb(t, {
      size: this.size,
      startIndex: n,
      endIndex: i
    }) : t.subarray(n, i), n * t.BYTES_PER_ELEMENT + this.byteOffset);
  }
  allocate(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    const {
      state: n
    } = this, i = n.allocatedValue, s = Ng.allocate(i, e + 1, {
      size: this.size,
      type: this.settings.defaultType,
      copy: t
    });
    this.value = s;
    const {
      byteOffset: l
    } = this;
    let {
      buffer: o
    } = this;
    return (!o || o.byteLength < s.byteLength + l) && (o = this._createBuffer(s.byteLength + l), t && i && o.write(i instanceof Float64Array ? Tb(i, this) : i, l)), n.allocatedValue = s, n.constant = !1, n.externalBuffer = null, this.setAccessor(this.settings), !0;
  }
  // PRIVATE HELPER METHODS
  _checkExternalBuffer(e) {
    const {
      value: t
    } = e;
    if (!ArrayBuffer.isView(t))
      throw new Error(`Attribute ${this.id} value is not TypedArray`);
    const n = this.settings.defaultType;
    let i = !1;
    if (this.doublePrecision && (i = t.BYTES_PER_ELEMENT < 4), i)
      throw new Error(`Attribute ${this.id} does not support ${t.constructor.name}`);
    !(t instanceof n) && this.settings.normalized && !("normalized" in e) && Gn.warn(`Attribute ${this.id} is normalized`)();
  }
  // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer
  normalizeConstant(e) {
    switch (this.settings.type) {
      case "snorm8":
        return new Float32Array(e).map((t) => (t + 128) / 255 * 2 - 1);
      case "snorm16":
        return new Float32Array(e).map((t) => (t + 32768) / 65535 * 2 - 1);
      case "unorm8":
        return new Float32Array(e).map((t) => t / 255);
      case "unorm16":
        return new Float32Array(e).map((t) => t / 65535);
      default:
        return e;
    }
  }
  /* check user supplied values and apply fallback */
  _normalizeValue(e, t, n) {
    const {
      defaultValue: i,
      size: s
    } = this.settings;
    if (Number.isFinite(e))
      return t[n] = e, t;
    if (!e) {
      let l = s;
      for (; --l >= 0; )
        t[n + l] = i[l];
      return t;
    }
    switch (s) {
      case 4:
        t[n + 3] = Number.isFinite(e[3]) ? e[3] : i[3];
      case 3:
        t[n + 2] = Number.isFinite(e[2]) ? e[2] : i[2];
      case 2:
        t[n + 1] = Number.isFinite(e[1]) ? e[1] : i[1];
      case 1:
        t[n + 0] = Number.isFinite(e[0]) ? e[0] : i[0];
        break;
      default:
        let l = s;
        for (; --l >= 0; )
          t[n + l] = Number.isFinite(e[l]) ? e[l] : i[l];
    }
    return t;
  }
  _areValuesEqual(e, t) {
    if (!e || !t)
      return !1;
    const {
      size: n
    } = this;
    for (let i = 0; i < n; i++)
      if (e[i] !== t[i])
        return !1;
    return !0;
  }
  _createBuffer(e) {
    var i;
    this._buffer && this._buffer.destroy();
    const {
      isIndexed: t,
      type: n
    } = this.settings;
    return this._buffer = this.device.createBuffer({
      ...(i = this._buffer) == null ? void 0 : i.props,
      id: this.id,
      // TODO(ibgreen) - WebGPU requires COPY_DST and COPY_SRC to allow write / read
      usage: (t ? gs.INDEX : gs.VERTEX) | gs.COPY_DST,
      indexType: t ? n : void 0,
      byteLength: e
    }), this._buffer;
  }
}
const _3 = [], y3 = [];
function fI(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1 / 0, n = _3;
  const i = {
    index: -1,
    data: r,
    // visitor can optionally utilize this to avoid constructing a new array for every object
    target: []
  };
  return r ? typeof r[Symbol.iterator] == "function" ? n = r : r.length > 0 && (y3.length = r.length, n = y3) : n = _3, (e > 0 || Number.isFinite(t)) && (n = (Array.isArray(n) ? n : Array.from(n)).slice(e, t), i.index = e - 1), {
    iterable: n,
    objectInfo: i
  };
}
function dI(r) {
  return r && r[Symbol.asyncIterator];
}
function J7(r, e) {
  const {
    size: t,
    stride: n,
    offset: i,
    startIndices: s,
    nested: l
  } = e, o = r.BYTES_PER_ELEMENT, d = n ? n / o : t, m = i ? i / o : 0, b = Math.floor((r.length - m) / d);
  return (A, M) => {
    let {
      index: E,
      target: k
    } = M;
    if (!s) {
      const Y = E * d + m;
      for (let re = 0; re < t; re++)
        k[re] = r[Y + re];
      return k;
    }
    const U = s[E], V = s[E + 1] || b;
    let q;
    if (l) {
      q = new Array(V - U);
      for (let Y = U; Y < V; Y++) {
        const re = Y * d + m;
        k = new Array(t);
        for (let Z = 0; Z < t; Z++)
          k[Z] = r[re + Z];
        q[Y - U] = k;
      }
    } else if (d === t)
      q = r.subarray(U * t + m, V * t + m);
    else {
      q = new r.constructor((V - U) * t);
      let Y = 0;
      for (let re = U; re < V; re++) {
        const Z = re * d + m;
        for (let K = 0; K < t; K++)
          q[Y++] = r[Z + K];
      }
    }
    return q;
  };
}
const Q7 = [], m_ = [[0, 1 / 0]];
function e9(r, e) {
  if (r === m_ || (e[0] < 0 && (e[0] = 0), e[0] >= e[1]))
    return r;
  const t = [], n = r.length;
  let i = 0;
  for (let s = 0; s < n; s++) {
    const l = r[s];
    l[1] < e[0] ? (t.push(l), i = s + 1) : l[0] > e[1] ? t.push(l) : e = [Math.min(l[0], e[0]), Math.max(l[1], e[1])];
  }
  return t.splice(i, 0, e), t;
}
const t9 = {
  interpolation: {
    duration: 0,
    easing: (r) => r
  },
  spring: {
    stiffness: 0.05,
    damping: 0.5
  }
};
function pI(r, e) {
  if (!r)
    return null;
  Number.isFinite(r) && (r = {
    type: "interpolation",
    duration: r
  });
  const t = r.type || "interpolation";
  return {
    ...t9[t],
    ...e,
    ...r,
    type: t
  };
}
class gI extends K7 {
  constructor(e, t) {
    super(e, t, {
      startIndices: null,
      lastExternalBuffer: null,
      binaryValue: null,
      binaryAccessor: null,
      needsUpdate: !0,
      needsRedraw: !1,
      layoutChanged: !1,
      updateRanges: m_
    }), this.constant = !1, this.settings.update = t.update || (t.accessor ? this._autoUpdater : void 0), Object.seal(this.settings), Object.seal(this.state), this._validateAttributeUpdaters();
  }
  get startIndices() {
    return this.state.startIndices;
  }
  set startIndices(e) {
    this.state.startIndices = e;
  }
  needsUpdate() {
    return this.state.needsUpdate;
  }
  needsRedraw() {
    let {
      clearChangedFlags: e = !1
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = this.state.needsRedraw;
    return this.state.needsRedraw = t && !e, t;
  }
  layoutChanged() {
    return this.state.layoutChanged;
  }
  setAccessor(e) {
    var t;
    (t = this.state).layoutChanged || (t.layoutChanged = !Z7(e, this.getAccessor())), super.setAccessor(e);
  }
  getUpdateTriggers() {
    const {
      accessor: e
    } = this.settings;
    return [this.id].concat(typeof e != "function" && e || []);
  }
  supportsTransition() {
    return !!this.settings.transition;
  }
  // Resolve transition settings object if transition is enabled, otherwise `null`
  getTransitionSetting(e) {
    if (!e || !this.supportsTransition())
      return null;
    const {
      accessor: t
    } = this.settings, n = this.settings.transition, i = Array.isArray(t) ? (
      // @ts-ignore
      e[t.find((s) => e[s])]
    ) : (
      // @ts-ignore
      e[t]
    );
    return pI(i, n);
  }
  setNeedsUpdate() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.id, t = arguments.length > 1 ? arguments[1] : void 0;
    if (this.state.needsUpdate = this.state.needsUpdate || e, this.setNeedsRedraw(e), t) {
      const {
        startRow: n = 0,
        endRow: i = 1 / 0
      } = t;
      this.state.updateRanges = e9(this.state.updateRanges, [n, i]);
    } else
      this.state.updateRanges = m_;
  }
  clearNeedsUpdate() {
    this.state.needsUpdate = !1, this.state.updateRanges = Q7;
  }
  setNeedsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.id;
    this.state.needsRedraw = this.state.needsRedraw || e;
  }
  allocate(e) {
    const {
      state: t,
      settings: n
    } = this;
    return n.noAlloc ? !1 : n.update ? (super.allocate(e, t.updateRanges !== m_), !0) : !1;
  }
  updateBuffer(e) {
    let {
      numInstances: t,
      data: n,
      props: i,
      context: s
    } = e;
    if (!this.needsUpdate())
      return !1;
    const {
      state: {
        updateRanges: l
      },
      settings: {
        update: o,
        noAlloc: d
      }
    } = this;
    let m = !0;
    if (o) {
      for (const [b, A] of l)
        o.call(s, this, {
          data: n,
          startRow: b,
          endRow: A,
          props: i,
          numInstances: t
        });
      if (this.value) if (this.constant || !this.buffer || this.buffer.byteLength < this.value.byteLength + this.byteOffset)
        this.setData({
          value: this.value,
          constant: this.constant
        }), this.constant = !1;
      else
        for (const [b, A] of l) {
          const M = Number.isFinite(b) ? this.getVertexOffset(b) : 0, E = Number.isFinite(A) ? this.getVertexOffset(A) : d || !Number.isFinite(t) ? this.value.length : t * this.size;
          super.updateSubBuffer({
            startOffset: M,
            endOffset: E
          });
        }
      this._checkAttributeArray();
    } else
      m = !1;
    return this.clearNeedsUpdate(), this.setNeedsRedraw(), m;
  }
  // Use generic value
  // Returns true if successful
  setConstantValue(e) {
    return this.device.type === "webgpu" || e === void 0 || typeof e == "function" ? !1 : (this.setData({
      constant: !0,
      value: e
    }) && this.setNeedsRedraw(), this.clearNeedsUpdate(), !0);
  }
  // Use external buffer
  // Returns true if successful
  // eslint-disable-next-line max-statements
  setExternalBuffer(e) {
    const {
      state: t
    } = this;
    return e ? (this.clearNeedsUpdate(), t.lastExternalBuffer === e || (t.lastExternalBuffer = e, this.setNeedsRedraw(), this.setData(e)), !0) : (t.lastExternalBuffer = null, !1);
  }
  // Binary value is a typed array packed from mapping the source data with the accessor
  // If the returned value from the accessor is the same as the attribute value, set it directly
  // Otherwise use the auto updater for transform/normalization
  setBinaryValue(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    const {
      state: n,
      settings: i
    } = this;
    if (!e)
      return n.binaryValue = null, n.binaryAccessor = null, !1;
    if (i.noAlloc)
      return !1;
    if (n.binaryValue === e)
      return this.clearNeedsUpdate(), !0;
    if (n.binaryValue = e, this.setNeedsRedraw(), i.transform || t !== this.startIndices) {
      ArrayBuffer.isView(e) && (e = {
        value: e
      });
      const l = e;
      ro(ArrayBuffer.isView(l.value), `invalid ${i.accessor}`);
      const o = !!l.size && l.size !== this.size;
      return n.binaryAccessor = J7(l.value, {
        size: l.size || this.size,
        stride: l.stride,
        offset: l.offset,
        startIndices: t,
        nested: o
      }), !1;
    }
    return this.clearNeedsUpdate(), this.setData(e), !0;
  }
  getVertexOffset(e) {
    const {
      startIndices: t
    } = this;
    return (t ? e < t.length ? t[e] : this.numInstances : e) * this.size;
  }
  getValue() {
    const e = this.settings.shaderAttributes, t = super.getValue();
    if (!e)
      return t;
    for (const n in e)
      Object.assign(t, super.getValue(n, e[n]));
    return t;
  }
  /** Generate WebGPU-style buffer layout descriptor from this attribute */
  getBufferLayout(e) {
    this.state.layoutChanged = !1;
    const t = this.settings.shaderAttributes, n = super._getBufferLayout(), {
      stepMode: i
    } = this.settings;
    if (i === "dynamic" ? n.stepMode = e ? e.isInstanced ? "instance" : "vertex" : "instance" : n.stepMode = i ?? "vertex", !t)
      return n;
    for (const s in t) {
      const l = super._getBufferLayout(s, t[s]);
      n.attributes.push(...l.attributes);
    }
    return n;
  }
  /* eslint-disable max-depth, max-statements */
  _autoUpdater(e, t) {
    let {
      data: n,
      startRow: i,
      endRow: s,
      props: l,
      numInstances: o
    } = t;
    if (e.constant && this.context.device.type !== "webgpu")
      return;
    const {
      settings: d,
      state: m,
      value: b,
      size: A,
      startIndices: M
    } = e, {
      accessor: E,
      transform: k
    } = d;
    let U = m.binaryAccessor || // @ts-ignore
    (typeof E == "function" ? E : l[E]);
    typeof U != "function" && (U = () => U), ro(typeof U == "function", `accessor "${E}" is not a function`);
    let V = e.getVertexOffset(i);
    const {
      iterable: q,
      objectInfo: Y
    } = fI(n, i, s);
    for (const re of q) {
      Y.index++;
      let Z = U(re, Y);
      if (k && (Z = k.call(this, Z)), M) {
        const K = (Y.index < M.length - 1 ? M[Y.index + 1] : o) - M[Y.index];
        if (Z && Array.isArray(Z[0])) {
          let ie = V;
          for (const be of Z)
            e._normalizeValue(be, b, ie), ie += A;
        } else Z && Z.length > A ? b.set(Z, V) : (e._normalizeValue(Z, Y.target, 0), gU({
          target: b,
          source: Y.target,
          start: V,
          count: K
        }));
        V += K * A;
      } else
        e._normalizeValue(Z, b, V), V += A;
    }
  }
  /* eslint-enable max-depth, max-statements */
  // Validate deck.gl level fields
  _validateAttributeUpdaters() {
    const {
      settings: e
    } = this;
    if (!(e.noAlloc || typeof e.update == "function"))
      throw new Error(`Attribute ${this.id} missing update or accessor`);
  }
  // check that the first few elements of the attribute are reasonable
  /* eslint-disable no-fallthrough */
  _checkAttributeArray() {
    const {
      value: e
    } = this, t = Math.min(4, this.size);
    if (e && e.length >= t) {
      let n = !0;
      switch (t) {
        case 4:
          n = n && Number.isFinite(e[3]);
        case 3:
          n = n && Number.isFinite(e[2]);
        case 2:
          n = n && Number.isFinite(e[1]);
        case 1:
          n = n && Number.isFinite(e[0]);
          break;
        default:
          n = !1;
      }
      if (!n)
        throw new Error(`Illegal attribute generated for ${this.id}`);
    }
  }
}
function Lb(r) {
  const {
    source: e,
    target: t,
    start: n = 0,
    size: i,
    getData: s
  } = r, l = r.end || t.length, o = e.length, d = l - n;
  if (o > d) {
    t.set(e.subarray(0, d), n);
    return;
  }
  if (t.set(e, n), !s)
    return;
  let m = o;
  for (; m < d; ) {
    const b = s(m, e);
    for (let A = 0; A < i; A++)
      t[n + m] = b[A] || 0, m++;
  }
}
function r9(r) {
  let {
    source: e,
    target: t,
    size: n,
    getData: i,
    sourceStartIndices: s,
    targetStartIndices: l
  } = r;
  if (!s || !l)
    return Lb({
      source: e,
      target: t,
      size: n,
      getData: i
    }), t;
  let o = 0, d = 0;
  const m = i && ((A, M) => i(A + d, M)), b = Math.min(s.length, l.length);
  for (let A = 1; A < b; A++) {
    const M = s[A] * n, E = l[A] * n;
    Lb({
      source: e.subarray(o, M),
      target: t,
      start: d,
      end: E,
      size: n,
      getData: m
    }), o = M, d = E;
  }
  return d < t.length && Lb({
    // @ts-ignore
    source: [],
    target: t,
    start: d,
    size: n,
    getData: m
  }), t;
}
function n9(r) {
  const {
    device: e,
    settings: t,
    value: n
  } = r, i = new gI(e, t);
  return i.setData({
    value: n instanceof Float64Array ? new Float64Array(0) : new Float32Array(0),
    normalized: t.normalized
  }), i;
}
function mI(r) {
  switch (r) {
    case 1:
      return "float";
    case 2:
      return "vec2";
    case 3:
      return "vec3";
    case 4:
      return "vec4";
    default:
      throw new Error(`No defined attribute type for size "${r}"`);
  }
}
function _I(r) {
  switch (r) {
    case 1:
      return "float32";
    case 2:
      return "float32x2";
    case 3:
      return "float32x3";
    case 4:
      return "float32x4";
    default:
      throw new Error("invalid type size");
  }
}
function yI(r) {
  r.push(r.shift());
}
function i9(r, e) {
  const {
    doublePrecision: t,
    settings: n,
    value: i,
    size: s
  } = r, l = t && i instanceof Float64Array ? 2 : 1;
  let o = 0;
  const {
    shaderAttributes: d
  } = r.settings;
  if (d)
    for (const m of Object.values(d))
      o = Math.max(o, m.vertexOffset ?? 0);
  return (n.noAlloc ? i.length : (e + o) * s) * l;
}
function bI(r) {
  let {
    device: e,
    source: t,
    target: n
  } = r;
  return (!n || n.byteLength < t.byteLength) && (n == null || n.destroy(), n = e.createBuffer({
    byteLength: t.byteLength,
    usage: t.usage
  })), n;
}
function vI(r) {
  let {
    device: e,
    buffer: t,
    attribute: n,
    fromLength: i,
    toLength: s,
    fromStartIndices: l,
    getData: o = (Z) => Z
  } = r;
  const d = n.doublePrecision && n.value instanceof Float64Array ? 2 : 1, m = n.size * d, b = n.byteOffset, A = n.settings.bytesPerElement < 4 ? b / n.settings.bytesPerElement * 4 : b, M = n.startIndices, E = l && M, k = n.isConstant;
  if (!E && t && i >= s)
    return t;
  const U = n.value instanceof Float64Array ? Float32Array : n.value.constructor, V = k ? n.value : (
    // TODO(v9.1): Avoid non-portable synchronous reads.
    new U(n.getBuffer().readSyncWebGL(b, s * U.BYTES_PER_ELEMENT).buffer)
  );
  if (n.settings.normalized && !k) {
    const Z = o;
    o = (K, ie) => n.normalizeConstant(Z(K, ie));
  }
  const q = k ? (Z, K) => o(V, K) : (Z, K) => o(V.subarray(Z + b, Z + b + m), K), Y = t ? new Float32Array(t.readSyncWebGL(A, i * 4).buffer) : new Float32Array(0), re = new Float32Array(s);
  return r9({
    source: Y,
    target: re,
    sourceStartIndices: l,
    targetStartIndices: M,
    size: m,
    getData: q
  }), (!t || t.byteLength < re.byteLength + A) && (t == null || t.destroy(), t = e.createBuffer({
    byteLength: re.byteLength + A,
    usage: 35050
  })), t.write(re, A), t;
}
class xI {
  constructor(e) {
    let {
      device: t,
      attribute: n,
      timeline: i
    } = e;
    this.buffers = [], this.currentLength = 0, this.device = t, this.transition = new Fy(i), this.attribute = n, this.attributeInTransition = n9(n), this.currentStartIndices = n.startIndices;
  }
  get inProgress() {
    return this.transition.inProgress;
  }
  start(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1 / 0;
    this.settings = e, this.currentStartIndices = this.attribute.startIndices, this.currentLength = i9(this.attribute, t), this.transition.start({
      ...e,
      duration: n
    });
  }
  update() {
    const e = this.transition.update();
    return e && this.onUpdate(), e;
  }
  setBuffer(e) {
    this.attributeInTransition.setData({
      buffer: e,
      normalized: this.attribute.settings.normalized,
      // Retain placeholder value to generate correct shader layout
      value: this.attributeInTransition.value
    });
  }
  cancel() {
    this.transition.cancel();
  }
  delete() {
    this.cancel();
    for (const e of this.buffers)
      e.destroy();
    this.buffers.length = 0;
  }
}
class s9 extends xI {
  constructor(e) {
    let {
      device: t,
      attribute: n,
      timeline: i
    } = e;
    super({
      device: t,
      attribute: n,
      timeline: i
    }), this.type = "interpolation", this.transform = c9(t, n);
  }
  start(e, t) {
    const n = this.currentLength, i = this.currentStartIndices;
    if (super.start(e, t, e.duration), e.duration <= 0) {
      this.transition.cancel();
      return;
    }
    const {
      buffers: s,
      attribute: l
    } = this;
    yI(s), s[0] = vI({
      device: this.device,
      buffer: s[0],
      attribute: l,
      fromLength: n,
      toLength: this.currentLength,
      fromStartIndices: i,
      getData: e.enter
    }), s[1] = bI({
      device: this.device,
      source: s[0],
      target: s[1]
    }), this.setBuffer(s[1]);
    const {
      transform: o
    } = this, d = o.model;
    let m = Math.floor(this.currentLength / l.size);
    wI(l) && (m /= 2), d.setVertexCount(m), l.isConstant ? (d.setAttributes({
      aFrom: s[0]
    }), d.setConstantAttributes({
      aTo: l.value
    })) : d.setAttributes({
      aFrom: s[0],
      aTo: l.getBuffer()
    }), o.transformFeedback.setBuffers({
      vCurrent: s[1]
    });
  }
  onUpdate() {
    const {
      duration: e,
      easing: t
    } = this.settings, {
      time: n
    } = this.transition;
    let i = n / e;
    t && (i = t(i));
    const {
      model: s
    } = this.transform, l = {
      time: i
    };
    s.shaderInputs.setProps({
      interpolation: l
    }), this.transform.run({
      discard: !0
    });
  }
  delete() {
    super.delete(), this.transform.destroy();
  }
}
const o9 = `uniform interpolationUniforms {
  float time;
} interpolation;
`, b3 = {
  name: "interpolation",
  vs: o9,
  uniformTypes: {
    time: "f32"
  }
}, a9 = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vCurrent;

void main(void) {
  vCurrent = mix(aFrom, aTo, interpolation.time);
  gl_Position = vec4(0.0);
}
`, l9 = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aFrom64Low;
in ATTRIBUTE_TYPE aTo;
in ATTRIBUTE_TYPE aTo64Low;
out ATTRIBUTE_TYPE vCurrent;
out ATTRIBUTE_TYPE vCurrent64Low;

vec2 mix_fp64(vec2 a, vec2 b, float x) {
  vec2 range = sub_fp64(b, a);
  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));
}

void main(void) {
  for (int i=0; i<ATTRIBUTE_SIZE; i++) {
    vec2 value = mix_fp64(vec2(aFrom[i], aFrom64Low[i]), vec2(aTo[i], aTo64Low[i]), interpolation.time);
    vCurrent[i] = value.x;
    vCurrent64Low[i] = value.y;
  }
  gl_Position = vec4(0.0);
}
`;
function wI(r) {
  return r.doublePrecision && r.value instanceof Float64Array;
}
function c9(r, e) {
  const t = e.size, n = mI(t), i = _I(t), s = e.getBufferLayout();
  return wI(e) ? new Dg(r, {
    vs: l9,
    bufferLayout: [{
      name: "aFrom",
      byteStride: 8 * t,
      attributes: [{
        attribute: "aFrom",
        format: i,
        byteOffset: 0
      }, {
        attribute: "aFrom64Low",
        format: i,
        byteOffset: 4 * t
      }]
    }, {
      name: "aTo",
      byteStride: 8 * t,
      attributes: [{
        attribute: "aTo",
        format: i,
        byteOffset: 0
      }, {
        attribute: "aTo64Low",
        format: i,
        byteOffset: 4 * t
      }]
    }],
    // @ts-expect-error fp64 module only sets ONE uniform via defaultUniforms
    modules: [_D, b3],
    defines: {
      ATTRIBUTE_TYPE: n,
      ATTRIBUTE_SIZE: t
    },
    // Default uniforms are not set without this
    moduleSettings: {},
    varyings: ["vCurrent", "vCurrent64Low"],
    bufferMode: 35980,
    disableWarnings: !0
  }) : new Dg(r, {
    vs: a9,
    bufferLayout: [{
      name: "aFrom",
      format: i
    }, {
      name: "aTo",
      format: s.attributes[0].format
    }],
    modules: [b3],
    defines: {
      ATTRIBUTE_TYPE: n
    },
    varyings: ["vCurrent"],
    // TODO investigate why this is needed
    disableWarnings: !0
  });
}
class u9 extends xI {
  constructor(e) {
    let {
      device: t,
      attribute: n,
      timeline: i
    } = e;
    super({
      device: t,
      attribute: n,
      timeline: i
    }), this.type = "spring", this.texture = m9(t), this.framebuffer = _9(t, this.texture), this.transform = g9(t, n);
  }
  start(e, t) {
    const n = this.currentLength, i = this.currentStartIndices;
    super.start(e, t);
    const {
      buffers: s,
      attribute: l
    } = this;
    for (let d = 0; d < 2; d++)
      s[d] = vI({
        device: this.device,
        buffer: s[d],
        attribute: l,
        fromLength: n,
        toLength: this.currentLength,
        fromStartIndices: i,
        getData: e.enter
      });
    s[2] = bI({
      device: this.device,
      source: s[0],
      target: s[2]
    }), this.setBuffer(s[1]);
    const {
      model: o
    } = this.transform;
    o.setVertexCount(Math.floor(this.currentLength / l.size)), l.isConstant ? o.setConstantAttributes({
      aTo: l.value
    }) : o.setAttributes({
      aTo: l.getBuffer()
    });
  }
  onUpdate() {
    const {
      buffers: e,
      transform: t,
      framebuffer: n,
      transition: i
    } = this, s = this.settings;
    t.model.setAttributes({
      aPrev: e[0],
      aCur: e[1]
    }), t.transformFeedback.setBuffers({
      vNext: e[2]
    });
    const l = {
      stiffness: s.stiffness,
      damping: s.damping
    };
    t.model.shaderInputs.setProps({
      spring: l
    }), t.run({
      framebuffer: n,
      discard: !1,
      parameters: {
        viewport: [0, 0, 1, 1]
      },
      clearColor: [0, 0, 0, 0]
    }), yI(e), this.setBuffer(e[1]), this.device.readPixelsToArrayWebGL(n)[0] > 0 || i.end();
  }
  delete() {
    super.delete(), this.transform.destroy(), this.texture.destroy(), this.framebuffer.destroy();
  }
}
const h9 = `uniform springUniforms {
  float damping;
  float stiffness;
} spring;
`, f9 = {
  name: "spring",
  vs: h9,
  uniformTypes: {
    damping: "f32",
    stiffness: "f32"
  }
}, d9 = `#version 300 es
#define SHADER_NAME spring-transition-vertex-shader

#define EPSILON 0.00001

in ATTRIBUTE_TYPE aPrev;
in ATTRIBUTE_TYPE aCur;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vNext;
out float vIsTransitioningFlag;

ATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {
  ATTRIBUTE_TYPE velocity = cur - prev;
  ATTRIBUTE_TYPE delta = dest - cur;
  ATTRIBUTE_TYPE force = delta * spring.stiffness;
  ATTRIBUTE_TYPE resistance = velocity * spring.damping;
  return force - resistance + velocity + cur;
}

void main(void) {
  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;
  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;

  vNext = getNextValue(aCur, aPrev, aTo);
  gl_Position = vec4(0, 0, 0, 1);
  gl_PointSize = 100.0;
}
`, p9 = `#version 300 es
#define SHADER_NAME spring-transition-is-transitioning-fragment-shader

in float vIsTransitioningFlag;

out vec4 fragColor;

void main(void) {
  if (vIsTransitioningFlag == 0.0) {
    discard;
  }
  fragColor = vec4(1.0);
}`;
function g9(r, e) {
  const t = mI(e.size), n = _I(e.size);
  return new Dg(r, {
    vs: d9,
    fs: p9,
    bufferLayout: [{
      name: "aPrev",
      format: n
    }, {
      name: "aCur",
      format: n
    }, {
      name: "aTo",
      format: e.getBufferLayout().attributes[0].format
    }],
    varyings: ["vNext"],
    modules: [f9],
    defines: {
      ATTRIBUTE_TYPE: t
    },
    parameters: {
      depthCompare: "always",
      blendColorOperation: "max",
      blendColorSrcFactor: "one",
      blendColorDstFactor: "one",
      blendAlphaOperation: "max",
      blendAlphaSrcFactor: "one",
      blendAlphaDstFactor: "one"
    }
  });
}
function m9(r) {
  return r.createTexture({
    data: new Uint8Array(4),
    format: "rgba8unorm",
    mipmaps: !1,
    width: 1,
    height: 1
  });
}
function _9(r, e) {
  return r.createFramebuffer({
    id: "spring-transition-is-transitioning-framebuffer",
    width: 1,
    height: 1,
    colorAttachments: [e]
  });
}
const y9 = {
  interpolation: s9,
  spring: u9
};
class b9 {
  constructor(e, t) {
    let {
      id: n,
      timeline: i
    } = t;
    if (!e) throw new Error("AttributeTransitionManager is constructed without device");
    this.id = n, this.device = e, this.timeline = i, this.transitions = {}, this.needsRedraw = !1, this.numInstances = 1;
  }
  finalize() {
    for (const e in this.transitions)
      this._removeTransition(e);
  }
  /* Public methods */
  // Called when attribute manager updates
  // Check the latest attributes for updates.
  update(e) {
    let {
      attributes: t,
      transitions: n,
      numInstances: i
    } = e;
    this.numInstances = i || 1;
    for (const s in t) {
      const l = t[s], o = l.getTransitionSetting(n);
      o && this._updateAttribute(s, l, o);
    }
    for (const s in this.transitions) {
      const l = t[s];
      (!l || !l.getTransitionSetting(n)) && this._removeTransition(s);
    }
  }
  // Returns `true` if attribute is transition-enabled
  hasAttribute(e) {
    const t = this.transitions[e];
    return t && t.inProgress;
  }
  // Get all the animated attributes
  getAttributes() {
    const e = {};
    for (const t in this.transitions) {
      const n = this.transitions[t];
      n.inProgress && (e[t] = n.attributeInTransition);
    }
    return e;
  }
  /* eslint-disable max-statements */
  // Called every render cycle, run transform feedback
  // Returns `true` if anything changes
  run() {
    if (this.numInstances === 0)
      return !1;
    for (const t in this.transitions)
      this.transitions[t].update() && (this.needsRedraw = !0);
    const e = this.needsRedraw;
    return this.needsRedraw = !1, e;
  }
  /* eslint-enable max-statements */
  /* Private methods */
  _removeTransition(e) {
    this.transitions[e].delete(), delete this.transitions[e];
  }
  // Check an attributes for updates
  // Returns a transition object if a new transition is triggered.
  _updateAttribute(e, t, n) {
    const i = this.transitions[e];
    let s = !i || i.type !== n.type;
    if (s) {
      i && this._removeTransition(e);
      const l = y9[n.type];
      l ? this.transitions[e] = new l({
        attribute: t,
        timeline: this.timeline,
        device: this.device
      }) : (Gn.error(`unsupported transition type '${n.type}'`)(), s = !1);
    }
    (s || t.needsRedraw()) && (this.needsRedraw = !0, this.transitions[e].start(n, this.numInstances));
  }
}
const v3 = "attributeManager.invalidate", v9 = "attributeManager.updateStart", x9 = "attributeManager.updateEnd", w9 = "attribute.updateStart", A9 = "attribute.allocate", T9 = "attribute.updateEnd";
class S9 {
  constructor(e) {
    let {
      id: t = "attribute-manager",
      stats: n,
      timeline: i
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.mergeBoundsMemoized = Yg(F8), this.id = t, this.device = e, this.attributes = {}, this.updateTriggers = {}, this.needsRedraw = !0, this.userData = {}, this.stats = n, this.attributeTransitionManager = new b9(e, {
      id: `${t}-transitions`,
      timeline: i
    }), Object.seal(this);
  }
  finalize() {
    for (const e in this.attributes)
      this.attributes[e].delete();
    this.attributeTransitionManager.finalize();
  }
  // Returns the redraw flag, optionally clearing it.
  // Redraw flag will be set if any attributes attributes changed since
  // flag was last cleared.
  //
  // @param {String} [clearRedrawFlags=false] - whether to clear the flag
  // @return {false|String} - reason a redraw is needed.
  getNeedsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    const t = this.needsRedraw;
    return this.needsRedraw = this.needsRedraw && !e.clearRedrawFlags, t && this.id;
  }
  // Sets the redraw flag.
  // @param {Boolean} redraw=true
  setNeedsRedraw() {
    this.needsRedraw = !0;
  }
  // Adds attributes
  add(e) {
    this._add(e);
  }
  // Adds attributes
  addInstanced(e) {
    this._add(e, {
      stepMode: "instance"
    });
  }
  /**
   * Removes attributes
   * Takes an array of attribute names and delete them from
   * the attribute map if they exists
   *
   * @example
   * attributeManager.remove(['position']);
   *
   * @param {Object} attributeNameArray - attribute name array (see above)
   */
  remove(e) {
    for (const t of e)
      this.attributes[t] !== void 0 && (this.attributes[t].delete(), delete this.attributes[t]);
  }
  // Marks an attribute for update
  invalidate(e, t) {
    const n = this._invalidateTrigger(e, t);
    ea(v3, this, e, n);
  }
  invalidateAll(e) {
    for (const t in this.attributes)
      this.attributes[t].setNeedsUpdate(t, e);
    ea(v3, this, "all");
  }
  // Ensure all attribute buffers are updated from props or data.
  // eslint-disable-next-line complexity
  update(e) {
    let {
      data: t,
      numInstances: n,
      startIndices: i = null,
      transitions: s,
      props: l = {},
      buffers: o = {},
      context: d = {}
    } = e, m = !1;
    ea(v9, this), this.stats && this.stats.get("Update Attributes").timeStart();
    for (const b in this.attributes) {
      const A = this.attributes[b], M = A.settings.accessor;
      A.startIndices = i, A.numInstances = n, l[b] && Gn.removed(`props.${b}`, `data.attributes.${b}`)(), A.setExternalBuffer(o[b]) || A.setBinaryValue(typeof M == "string" ? o[M] : void 0, t.startIndices) || typeof M == "string" && !o[M] && A.setConstantValue(l[M]) || A.needsUpdate() && (m = !0, this._updateAttribute({
        attribute: A,
        numInstances: n,
        data: t,
        props: l,
        context: d
      })), this.needsRedraw = this.needsRedraw || A.needsRedraw();
    }
    m && ea(x9, this, n), this.stats && this.stats.get("Update Attributes").timeEnd(), this.attributeTransitionManager.update({
      attributes: this.attributes,
      numInstances: n,
      transitions: s
    });
  }
  // Update attribute transition to the current timestamp
  // Returns `true` if any transition is in progress
  updateTransition() {
    const {
      attributeTransitionManager: e
    } = this, t = e.run();
    return this.needsRedraw = this.needsRedraw || t, t;
  }
  /**
   * Returns all attribute descriptors
   * Note: Format matches luma.gl Model/Program.setAttributes()
   * @return {Object} attributes - descriptors
   */
  getAttributes() {
    return {
      ...this.attributes,
      ...this.attributeTransitionManager.getAttributes()
    };
  }
  /**
   * Computes the spatial bounds of a given set of attributes
   */
  getBounds(e) {
    const t = e.map((n) => {
      var i;
      return (i = this.attributes[n]) == null ? void 0 : i.getBounds();
    });
    return this.mergeBoundsMemoized(t);
  }
  /**
   * Returns changed attribute descriptors
   * This indicates which WebGLBuffers need to be updated
   * @return {Object} attributes - descriptors
   */
  getChangedAttributes() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearChangedFlags: !1
    };
    const {
      attributes: t,
      attributeTransitionManager: n
    } = this, i = {
      ...n.getAttributes()
    };
    for (const s in t) {
      const l = t[s];
      l.needsRedraw(e) && !n.hasAttribute(s) && (i[s] = l);
    }
    return i;
  }
  /** Generate WebGPU-style buffer layout descriptors from all attributes */
  getBufferLayouts(e) {
    return Object.values(this.getAttributes()).map((t) => t.getBufferLayout(e));
  }
  // PRIVATE METHODS
  /** Register new attributes */
  _add(e, t) {
    for (const n in e) {
      const i = e[n], s = {
        ...i,
        id: n,
        size: i.isIndexed && 1 || i.size || 1,
        ...t
      };
      this.attributes[n] = new gI(this.device, s);
    }
    this._mapUpdateTriggersToAttributes();
  }
  // build updateTrigger name to attribute name mapping
  _mapUpdateTriggersToAttributes() {
    const e = {};
    for (const t in this.attributes)
      this.attributes[t].getUpdateTriggers().forEach((i) => {
        e[i] || (e[i] = []), e[i].push(t);
      });
    this.updateTriggers = e;
  }
  _invalidateTrigger(e, t) {
    const {
      attributes: n,
      updateTriggers: i
    } = this, s = i[e];
    return s && s.forEach((l) => {
      const o = n[l];
      o && o.setNeedsUpdate(o.id, t);
    }), s;
  }
  _updateAttribute(e) {
    const {
      attribute: t,
      numInstances: n
    } = e;
    if (ea(w9, t), t.constant) {
      t.setConstantValue(t.value);
      return;
    }
    t.allocate(n) && ea(A9, t, n), t.updateBuffer(e) && (this.needsRedraw = !0, ea(T9, t, n));
  }
}
class E9 extends Fy {
  get value() {
    return this._value;
  }
  _onUpdate() {
    const {
      time: e,
      settings: {
        fromValue: t,
        toValue: n,
        duration: i,
        easing: s
      }
    } = this, l = s(e / i);
    this._value = K_(t, n, l);
  }
}
const x3 = 1e-5;
function w3(r, e, t, n, i) {
  const s = e - r, o = (t - e) * i, d = -s * n;
  return o + d + s + e;
}
function C9(r, e, t, n, i) {
  if (Array.isArray(t)) {
    const s = [];
    for (let l = 0; l < t.length; l++)
      s[l] = w3(r[l], e[l], t[l], n, i);
    return s;
  }
  return w3(r, e, t, n, i);
}
function A3(r, e) {
  if (Array.isArray(r)) {
    let t = 0;
    for (let n = 0; n < r.length; n++) {
      const i = r[n] - e[n];
      t += i * i;
    }
    return Math.sqrt(t);
  }
  return Math.abs(r - e);
}
class I9 extends Fy {
  get value() {
    return this._currValue;
  }
  _onUpdate() {
    const {
      fromValue: e,
      toValue: t,
      damping: n,
      stiffness: i
    } = this.settings, {
      _prevValue: s = e,
      _currValue: l = e
    } = this;
    let o = C9(s, l, t, n, i);
    const d = A3(o, t), m = A3(o, l);
    d < x3 && m < x3 && (o = t, this.end()), this._prevValue = l, this._currValue = o;
  }
}
const M9 = {
  interpolation: E9,
  spring: I9
};
class P9 {
  constructor(e) {
    this.transitions = /* @__PURE__ */ new Map(), this.timeline = e;
  }
  get active() {
    return this.transitions.size > 0;
  }
  add(e, t, n, i) {
    const {
      transitions: s
    } = this;
    if (s.has(e)) {
      const d = s.get(e), {
        value: m = d.settings.fromValue
      } = d;
      t = m, this.remove(e);
    }
    if (i = pI(i), !i)
      return;
    const l = M9[i.type];
    if (!l) {
      Gn.error(`unsupported transition type '${i.type}'`)();
      return;
    }
    const o = new l(this.timeline);
    o.start({
      ...i,
      fromValue: t,
      toValue: n
    }), s.set(e, o);
  }
  remove(e) {
    const {
      transitions: t
    } = this;
    t.has(e) && (t.get(e).cancel(), t.delete(e));
  }
  update() {
    const e = {};
    for (const [t, n] of this.transitions)
      n.update(), e[t] = n.value, n.inProgress || this.remove(t);
    return e;
  }
  clear() {
    for (const e of this.transitions.keys())
      this.remove(e);
  }
}
function R9(r) {
  const e = r[qh];
  for (const t in e) {
    const n = e[t], {
      validate: i
    } = n;
    if (i && !i(r[t], n))
      throw new Error(`Invalid prop ${t}: ${r[t]}`);
  }
}
function B9(r, e) {
  const t = AI({
    newProps: r,
    oldProps: e,
    propTypes: r[qh],
    ignoreProps: {
      data: null,
      updateTriggers: null,
      extensions: null,
      transitions: null
    }
  }), n = O9(r, e);
  let i = !1;
  return n || (i = k9(r, e)), {
    dataChanged: n,
    propsChanged: t,
    updateTriggersChanged: i,
    extensionsChanged: N9(r, e),
    transitionsChanged: L9(r, e)
  };
}
function L9(r, e) {
  if (!r.transitions)
    return !1;
  const t = {}, n = r[qh];
  let i = !1;
  for (const s in r.transitions) {
    const l = n[s], o = l && l.type;
    (o === "number" || o === "color" || o === "array") && bv(r[s], e[s], l) && (t[s] = !0, i = !0);
  }
  return i ? t : !1;
}
function AI(r) {
  let {
    newProps: e,
    oldProps: t,
    ignoreProps: n = {},
    propTypes: i = {},
    triggerName: s = "props"
  } = r;
  if (t === e)
    return !1;
  if (typeof e != "object" || e === null)
    return `${s} changed shallowly`;
  if (typeof t != "object" || t === null)
    return `${s} changed shallowly`;
  for (const l of Object.keys(e))
    if (!(l in n)) {
      if (!(l in t))
        return `${s}.${l} added`;
      const o = bv(e[l], t[l], i[l]);
      if (o)
        return `${s}.${l} ${o}`;
    }
  for (const l of Object.keys(t))
    if (!(l in n)) {
      if (!(l in e))
        return `${s}.${l} dropped`;
      if (!Object.hasOwnProperty.call(e, l)) {
        const o = bv(e[l], t[l], i[l]);
        if (o)
          return `${s}.${l} ${o}`;
      }
    }
  return !1;
}
function bv(r, e, t) {
  let n = t && t.equal;
  return n && !n(r, e, t) || !n && (n = r && e && r.equals, n && !n.call(r, e)) ? "changed deeply" : !n && e !== r ? "changed shallowly" : null;
}
function O9(r, e) {
  if (e === null)
    return "oldProps is null, initial diff";
  let t = !1;
  const {
    dataComparator: n,
    _dataDiff: i
  } = r;
  return n ? n(r.data, e.data) || (t = "Data comparator detected a change") : r.data !== e.data && (t = "A new data container was supplied"), t && i && (t = i(r.data, e.data) || t), t;
}
function k9(r, e) {
  if (e === null)
    return {
      all: !0
    };
  if ("all" in r.updateTriggers && T3(r, e, "all"))
    return {
      all: !0
    };
  const t = {};
  let n = !1;
  for (const i in r.updateTriggers)
    i !== "all" && T3(r, e, i) && (t[i] = !0, n = !0);
  return n ? t : !1;
}
function N9(r, e) {
  if (e === null)
    return !0;
  const t = e.extensions, {
    extensions: n
  } = r;
  if (n === t)
    return !1;
  if (!t || !n || n.length !== t.length)
    return !0;
  for (let i = 0; i < n.length; i++)
    if (!n[i].equals(t[i]))
      return !0;
  return !1;
}
function T3(r, e, t) {
  let n = r.updateTriggers[t];
  n = n ?? {};
  let i = e.updateTriggers[t];
  return i = i ?? {}, AI({
    oldProps: i,
    newProps: n,
    triggerName: t
  });
}
const D9 = "count(): argument not an object", F9 = "count(): argument not a container";
function U9(r) {
  if (!j9(r))
    throw new Error(D9);
  if (typeof r.count == "function")
    return r.count();
  if (Number.isFinite(r.size))
    return r.size;
  if (Number.isFinite(r.length))
    return r.length;
  if (z9(r))
    return Object.keys(r).length;
  throw new Error(F9);
}
function z9(r) {
  return r !== null && typeof r == "object" && r.constructor === Object;
}
function j9(r) {
  return r !== null && typeof r == "object";
}
function S3(r, e) {
  if (!e)
    return r;
  const t = {
    ...r,
    ...e
  };
  if ("defines" in e && (t.defines = {
    ...r.defines,
    ...e.defines
  }), "modules" in e && (t.modules = (r.modules || []).concat(e.modules), e.modules.some((n) => n.name === "project64"))) {
    const n = t.modules.findIndex((i) => i.name === "project32");
    n >= 0 && t.modules.splice(n, 1);
  }
  if ("inject" in e)
    if (!r.inject)
      t.inject = e.inject;
    else {
      const n = {
        ...r.inject
      };
      for (const i in e.inject)
        n[i] = (n[i] || "") + e.inject[i];
      t.inject = n;
    }
  return t;
}
const V9 = {
  minFilter: "linear",
  mipmapFilter: "linear",
  magFilter: "linear",
  addressModeU: "clamp-to-edge",
  addressModeV: "clamp-to-edge"
}, vv = {};
function $9(r, e, t, n) {
  if (t instanceof ts)
    return t;
  t.constructor && t.constructor.name !== "Object" && (t = {
    data: t
  });
  let i = null;
  t.compressed && (i = {
    minFilter: "linear",
    mipmapFilter: t.data.length > 1 ? "nearest" : "linear"
  });
  const s = e.createTexture({
    ...t,
    sampler: {
      ...V9,
      ...i,
      ...n
    },
    mipmaps: !0
  });
  return vv[s.id] = r, s;
}
function q9(r, e) {
  !e || !(e instanceof ts) || vv[e.id] === r && (e.delete(), delete vv[e.id]);
}
const G9 = {
  boolean: {
    validate(r, e) {
      return !0;
    },
    equal(r, e, t) {
      return !!r == !!e;
    }
  },
  number: {
    validate(r, e) {
      return Number.isFinite(r) && (!("max" in e) || r <= e.max) && (!("min" in e) || r >= e.min);
    }
  },
  color: {
    validate(r, e) {
      return e.optional && !r || xv(r) && (r.length === 3 || r.length === 4);
    },
    equal(r, e, t) {
      return Cc(r, e, 1);
    }
  },
  accessor: {
    validate(r, e) {
      const t = sy(r);
      return t === "function" || t === sy(e.value);
    },
    equal(r, e, t) {
      return typeof e == "function" ? !0 : Cc(r, e, 1);
    }
  },
  array: {
    validate(r, e) {
      return e.optional && !r || xv(r);
    },
    equal(r, e, t) {
      const {
        compare: n
      } = t, i = Number.isInteger(n) ? n : n ? 1 : 0;
      return n ? Cc(r, e, i) : r === e;
    }
  },
  object: {
    equal(r, e, t) {
      if (t.ignore)
        return !0;
      const {
        compare: n
      } = t, i = Number.isInteger(n) ? n : n ? 1 : 0;
      return n ? Cc(r, e, i) : r === e;
    }
  },
  function: {
    validate(r, e) {
      return e.optional && !r || typeof r == "function";
    },
    equal(r, e, t) {
      return !t.compare && t.ignore !== !1 || r === e;
    }
  },
  data: {
    transform: (r, e, t) => {
      if (!r)
        return r;
      const {
        dataTransform: n
      } = t.props;
      return n ? n(r) : typeof r.shape == "string" && r.shape.endsWith("-table") && Array.isArray(r.data) ? r.data : r;
    }
  },
  image: {
    transform: (r, e, t) => {
      const n = t.context;
      return !n || !n.device ? null : $9(t.id, n.device, r, {
        ...e.parameters,
        ...t.props.textureParameters
      });
    },
    release: (r, e, t) => {
      q9(t.id, r);
    }
  }
};
function H9(r) {
  const e = {}, t = {}, n = {};
  for (const [i, s] of Object.entries(r)) {
    const l = s == null ? void 0 : s.deprecatedFor;
    if (l)
      n[i] = Array.isArray(l) ? l : [l];
    else {
      const o = W9(i, s);
      e[i] = o, t[i] = o.value;
    }
  }
  return {
    propTypes: e,
    defaultProps: t,
    deprecatedProps: n
  };
}
function W9(r, e) {
  switch (sy(e)) {
    case "object":
      return Yp(r, e);
    case "array":
      return Yp(r, {
        type: "array",
        value: e,
        compare: !1
      });
    case "boolean":
      return Yp(r, {
        type: "boolean",
        value: e
      });
    case "number":
      return Yp(r, {
        type: "number",
        value: e
      });
    case "function":
      return Yp(r, {
        type: "function",
        value: e,
        compare: !0
      });
    default:
      return {
        name: r,
        type: "unknown",
        value: e
      };
  }
}
function Yp(r, e) {
  return "type" in e ? {
    name: r,
    ...G9[e.type],
    ...e
  } : "value" in e ? {
    name: r,
    type: sy(e.value),
    ...e
  } : {
    name: r,
    type: "object",
    value: e
  };
}
function xv(r) {
  return Array.isArray(r) || ArrayBuffer.isView(r);
}
function sy(r) {
  return xv(r) ? "array" : r === null ? "null" : typeof r;
}
function X9(r, e) {
  let t;
  for (let s = e.length - 1; s >= 0; s--) {
    const l = e[s];
    "extensions" in l && (t = l.extensions);
  }
  const n = wv(r.constructor, t), i = Object.create(n);
  i[ny] = r, i[Gf] = {}, i[zh] = {};
  for (let s = 0; s < e.length; ++s) {
    const l = e[s];
    for (const o in l)
      i[o] = l[o];
  }
  return Object.freeze(i), i;
}
const Z9 = "_mergedDefaultProps";
function wv(r, e) {
  if (!(r instanceof Uy.constructor)) return {};
  let t = Z9;
  if (e)
    for (const i of e) {
      const s = i.constructor;
      s && (t += `:${s.extensionName || s.name}`);
    }
  const n = TI(r, t);
  return n || (r[t] = Y9(r, e || []));
}
function Y9(r, e) {
  if (!r.prototype)
    return null;
  const n = Object.getPrototypeOf(r), i = wv(n), s = TI(r, "defaultProps") || {}, l = H9(s), o = Object.assign(/* @__PURE__ */ Object.create(null), i, l.defaultProps), d = Object.assign(/* @__PURE__ */ Object.create(null), i == null ? void 0 : i[qh], l.propTypes), m = Object.assign(/* @__PURE__ */ Object.create(null), i == null ? void 0 : i[Ib], l.deprecatedProps);
  for (const b of e) {
    const A = wv(b.constructor);
    A && (Object.assign(o, A), Object.assign(d, A[qh]), Object.assign(m, A[Ib]));
  }
  return K9(o, r), Q9(o, d), J9(o, m), o[qh] = d, o[Ib] = m, e.length === 0 && !ex(r, "_propTypes") && (r._propTypes = d), o;
}
function K9(r, e) {
  const t = tj(e);
  Object.defineProperties(r, {
    // `id` is treated specially because layer might need to override it
    id: {
      writable: !0,
      value: t
    }
  });
}
function J9(r, e) {
  for (const t in e)
    Object.defineProperty(r, t, {
      enumerable: !1,
      set(n) {
        const i = `${this.id}: ${t}`;
        for (const s of e[t])
          ex(this, s) || (this[s] = n);
        Gn.deprecated(i, e[t].join("/"))();
      }
    });
}
function Q9(r, e) {
  const t = {}, n = {};
  for (const i in e) {
    const s = e[i], {
      name: l,
      value: o
    } = s;
    s.async && (t[l] = o, n[l] = ej(l));
  }
  r[Yd] = t, r[Gf] = {}, Object.defineProperties(r, n);
}
function ej(r) {
  return {
    enumerable: !0,
    // Save the provided value for async props in a special map
    set(e) {
      typeof e == "string" || e instanceof Promise || dI(e) ? this[Gf][r] = e : this[zh][r] = e;
    },
    // Only the component's state knows the true value of async prop
    get() {
      if (this[zh]) {
        if (r in this[zh])
          return this[zh][r] || this[Yd][r];
        if (r in this[Gf]) {
          const e = this[ny] && this[ny].internalState;
          if (e && e.hasAsyncProp(r))
            return e.getAsyncProp(r) || this[Yd][r];
        }
      }
      return this[Yd][r];
    }
  };
}
function ex(r, e) {
  return Object.prototype.hasOwnProperty.call(r, e);
}
function TI(r, e) {
  return ex(r, e) && r[e];
}
function tj(r) {
  const e = r.componentName;
  return e || Gn.warn(`${r.name}.componentName not specified`)(), e || r.name;
}
let rj = 0;
class Uy {
  constructor() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    this.props = X9(this, t), this.id = this.props.id, this.count = rj++;
  }
  // clone this layer with modified props
  clone(e) {
    const {
      props: t
    } = this, n = {};
    for (const i in t[Yd])
      i in t[zh] ? n[i] = t[zh][i] : i in t[Gf] && (n[i] = t[Gf][i]);
    return new this.constructor({
      ...t,
      ...n,
      ...e
    });
  }
}
Uy.componentName = "Component";
Uy.defaultProps = {};
const nj = Object.freeze({});
class ij {
  constructor(e) {
    this.component = e, this.asyncProps = {}, this.onAsyncPropUpdated = () => {
    }, this.oldProps = null, this.oldAsyncProps = null;
  }
  finalize() {
    for (const e in this.asyncProps) {
      const t = this.asyncProps[e];
      t && t.type && t.type.release && t.type.release(t.resolvedValue, t.type, this.component);
    }
    this.asyncProps = {}, this.component = null, this.resetOldProps();
  }
  /* Layer-facing props API */
  getOldProps() {
    return this.oldAsyncProps || this.oldProps || nj;
  }
  resetOldProps() {
    this.oldAsyncProps = null, this.oldProps = this.component ? this.component.props : null;
  }
  // Checks if a prop is overridden
  hasAsyncProp(e) {
    return e in this.asyncProps;
  }
  // Returns value of an overriden prop
  getAsyncProp(e) {
    const t = this.asyncProps[e];
    return t && t.resolvedValue;
  }
  isAsyncPropLoading(e) {
    if (e) {
      const t = this.asyncProps[e];
      return !!(t && t.pendingLoadCount > 0 && t.pendingLoadCount !== t.resolvedLoadCount);
    }
    for (const t in this.asyncProps)
      if (this.isAsyncPropLoading(t))
        return !0;
    return !1;
  }
  // Without changing the original prop value, swap out the data resolution under the hood
  reloadAsyncProp(e, t) {
    this._watchPromise(e, Promise.resolve(t));
  }
  // Updates all async/overridden props (when new props come in)
  // Checks if urls have changed, starts loading, or removes override
  setAsyncProps(e) {
    this.component = e[ny] || this.component;
    const t = e[zh] || {}, n = e[Gf] || e, i = e[Yd] || {};
    for (const s in t) {
      const l = t[s];
      this._createAsyncPropData(s, i[s]), this._updateAsyncProp(s, l), t[s] = this.getAsyncProp(s);
    }
    for (const s in n) {
      const l = n[s];
      this._createAsyncPropData(s, i[s]), this._updateAsyncProp(s, l);
    }
  }
  /* Placeholder methods for subclassing */
  _fetch(e, t) {
    return null;
  }
  _onResolve(e, t) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  _onError(e, t) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  // Intercept strings (URLs) and Promises and activates loading and prop rewriting
  _updateAsyncProp(e, t) {
    if (this._didAsyncInputValueChange(e, t)) {
      if (typeof t == "string" && (t = this._fetch(e, t)), t instanceof Promise) {
        this._watchPromise(e, t);
        return;
      }
      if (dI(t)) {
        this._resolveAsyncIterable(e, t);
        return;
      }
      this._setPropValue(e, t);
    }
  }
  // Whenever async props are changing, we need to make a copy of oldProps
  // otherwise the prop rewriting will affect the value both in props and oldProps.
  // While the copy is relatively expensive, this only happens on load completion.
  _freezeAsyncOldProps() {
    if (!this.oldAsyncProps && this.oldProps) {
      this.oldAsyncProps = Object.create(this.oldProps);
      for (const e in this.asyncProps)
        Object.defineProperty(this.oldAsyncProps, e, {
          enumerable: !0,
          value: this.oldProps[e]
        });
    }
  }
  // Checks if an input value actually changed (to avoid reloading/rewatching promises/urls)
  _didAsyncInputValueChange(e, t) {
    const n = this.asyncProps[e];
    return t === n.resolvedValue || t === n.lastValue ? !1 : (n.lastValue = t, !0);
  }
  // Set normal, non-async value
  _setPropValue(e, t) {
    this._freezeAsyncOldProps();
    const n = this.asyncProps[e];
    n && (t = this._postProcessValue(n, t), n.resolvedValue = t, n.pendingLoadCount++, n.resolvedLoadCount = n.pendingLoadCount);
  }
  // Set a just resolved async value, calling onAsyncPropUpdates if value changes asynchronously
  _setAsyncPropValue(e, t, n) {
    const i = this.asyncProps[e];
    i && n >= i.resolvedLoadCount && t !== void 0 && (this._freezeAsyncOldProps(), i.resolvedValue = t, i.resolvedLoadCount = n, this.onAsyncPropUpdated(e, t));
  }
  // Tracks a promise, sets the prop when loaded, handles load count
  _watchPromise(e, t) {
    const n = this.asyncProps[e];
    if (n) {
      n.pendingLoadCount++;
      const i = n.pendingLoadCount;
      t.then((s) => {
        this.component && (s = this._postProcessValue(n, s), this._setAsyncPropValue(e, s, i), this._onResolve(e, s));
      }).catch((s) => {
        this._onError(e, s);
      });
    }
  }
  async _resolveAsyncIterable(e, t) {
    if (e !== "data") {
      this._setPropValue(e, t);
      return;
    }
    const n = this.asyncProps[e];
    if (!n)
      return;
    n.pendingLoadCount++;
    const i = n.pendingLoadCount;
    let s = [], l = 0;
    for await (const o of t) {
      if (!this.component)
        return;
      const {
        dataTransform: d
      } = this.component.props;
      d ? s = d(o, s) : s = s.concat(o), Object.defineProperty(s, "__diff", {
        enumerable: !1,
        value: [{
          startRow: l,
          endRow: s.length
        }]
      }), l = s.length, this._setAsyncPropValue(e, s, i);
    }
    this._onResolve(e, s);
  }
  // Give the app a chance to post process the loaded data
  _postProcessValue(e, t) {
    const n = e.type;
    return n && this.component && (n.release && n.release(e.resolvedValue, n, this.component), n.transform) ? n.transform(t, n, this.component) : t;
  }
  // Creating an asyncProp record if needed
  _createAsyncPropData(e, t) {
    if (!this.asyncProps[e]) {
      const i = this.component && this.component.props[qh];
      this.asyncProps[e] = {
        type: i && i[e],
        lastValue: null,
        resolvedValue: t,
        pendingLoadCount: 0,
        resolvedLoadCount: 0
      };
    }
  }
}
class sj extends ij {
  constructor(e) {
    let {
      attributeManager: t,
      layer: n
    } = e;
    super(n), this.attributeManager = t, this.needsRedraw = !0, this.needsUpdate = !0, this.subLayers = null, this.usesPickingColorCache = !1;
  }
  get layer() {
    return this.component;
  }
  /* Override base Component methods with Layer-specific handling */
  _fetch(e, t) {
    const n = this.layer, i = n == null ? void 0 : n.props.fetch;
    return i ? i(t, {
      propName: e,
      layer: n
    }) : super._fetch(e, t);
  }
  _onResolve(e, t) {
    const n = this.layer;
    if (n) {
      const i = n.props.onDataLoad;
      e === "data" && i && i(t, {
        propName: e,
        layer: n
      });
    }
  }
  _onError(e, t) {
    const n = this.layer;
    n && n.raiseError(t, `loading ${e} of ${this.layer}`);
  }
}
const oj = "layer.changeFlag", aj = "layer.initialize", lj = "layer.update", cj = "layer.finalize", uj = "layer.matched", E3 = 2 ** 24 - 1, hj = Object.freeze([]), fj = Yg((r) => {
  let {
    oldViewport: e,
    viewport: t
  } = r;
  return e.equals(t);
});
let dc = new Uint8ClampedArray(0);
const dj = {
  // data: Special handling for null, see below
  data: {
    type: "data",
    value: hj,
    async: !0
  },
  dataComparator: {
    type: "function",
    value: null,
    optional: !0
  },
  _dataDiff: {
    type: "function",
    // @ts-ignore __diff is not defined on data
    value: (r) => r && r.__diff,
    optional: !0
  },
  dataTransform: {
    type: "function",
    value: null,
    optional: !0
  },
  onDataLoad: {
    type: "function",
    value: null,
    optional: !0
  },
  onError: {
    type: "function",
    value: null,
    optional: !0
  },
  fetch: {
    type: "function",
    value: (r, e) => {
      let {
        propName: t,
        layer: n,
        loaders: i,
        loadOptions: s,
        signal: l
      } = e;
      const {
        resourceManager: o
      } = n.context;
      s = s || n.getLoadOptions(), i = i || n.props.loaders, l && (s = {
        ...s,
        fetch: {
          ...s == null ? void 0 : s.fetch,
          signal: l
        }
      });
      let d = o.contains(r);
      return !d && !s && (o.add({
        resourceId: r,
        data: Hh(r, i),
        persistent: !1
      }), d = !0), d ? o.subscribe({
        resourceId: r,
        onChange: (m) => {
          var b;
          return (b = n.internalState) == null ? void 0 : b.reloadAsyncProp(t, m);
        },
        consumerId: n.id,
        requestId: t
      }) : Hh(r, i, s);
    }
  },
  updateTriggers: {},
  // Update triggers: a core change detection mechanism in deck.gl
  visible: !0,
  pickable: !1,
  opacity: {
    type: "number",
    min: 0,
    max: 1,
    value: 1
  },
  operation: "draw",
  onHover: {
    type: "function",
    value: null,
    optional: !0
  },
  onClick: {
    type: "function",
    value: null,
    optional: !0
  },
  onDragStart: {
    type: "function",
    value: null,
    optional: !0
  },
  onDrag: {
    type: "function",
    value: null,
    optional: !0
  },
  onDragEnd: {
    type: "function",
    value: null,
    optional: !0
  },
  coordinateSystem: Ln.DEFAULT,
  coordinateOrigin: {
    type: "array",
    value: [0, 0, 0],
    compare: !0
  },
  modelMatrix: {
    type: "array",
    value: null,
    compare: !0,
    optional: !0
  },
  wrapLongitude: !1,
  positionFormat: "XYZ",
  colorFormat: "RGBA",
  parameters: {
    type: "object",
    value: {},
    optional: !0,
    compare: 2
  },
  loadOptions: {
    type: "object",
    value: null,
    optional: !0,
    ignore: !0
  },
  transitions: null,
  extensions: [],
  loaders: {
    type: "array",
    value: [],
    optional: !0,
    ignore: !0
  },
  // Offset depth based on layer index to avoid z-fighting.
  // Negative values pull layer towards the camera
  // https://www.opengl.org/archives/resources/faq/technical/polygonoffset.htm
  getPolygonOffset: {
    type: "function",
    value: (r) => {
      let {
        layerIndex: e
      } = r;
      return [0, -e * 100];
    }
  },
  // Selection/Highlighting
  highlightedObjectIndex: null,
  autoHighlight: !1,
  highlightColor: {
    type: "accessor",
    value: [0, 0, 128, 128]
  }
};
class vp extends Uy {
  constructor() {
    super(...arguments), this.internalState = null, this.lifecycle = Rd.NO_STATE, this.parent = null;
  }
  static get componentName() {
    return Object.prototype.hasOwnProperty.call(this, "layerName") ? this.layerName : "";
  }
  get root() {
    let e = this;
    for (; e.parent; )
      e = e.parent;
    return e;
  }
  toString() {
    return `${this.constructor.layerName || this.constructor.name}({id: '${this.props.id}'})`;
  }
  // Public API for users
  /** Projects a point with current view state from the current layer's coordinate system to screen */
  project(e) {
    ro(this.internalState);
    const t = this.internalState.viewport || this.context.viewport, n = z5(e, {
      viewport: t,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem
    }), [i, s, l] = N5(n, t.pixelProjectionMatrix);
    return e.length === 2 ? [i, s] : [i, s, l];
  }
  /** Unprojects a screen pixel to the current view's default coordinate system
      Note: this does not reverse `project`. */
  unproject(e) {
    return ro(this.internalState), (this.internalState.viewport || this.context.viewport).unproject(e);
  }
  /** Projects a point with current view state from the current layer's coordinate system to the world space */
  projectPosition(e, t) {
    ro(this.internalState);
    const n = this.internalState.viewport || this.context.viewport;
    return q8(e, {
      viewport: n,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem,
      ...t
    });
  }
  // Public API for custom layer implementation
  /** `true` if this layer renders other layers */
  get isComposite() {
    return !1;
  }
  /** `true` if the layer renders to screen */
  get isDrawable() {
    return !0;
  }
  /** Updates selected state members and marks the layer for redraw */
  setState(e) {
    this.setChangeFlags({
      stateChanged: !0
    }), Object.assign(this.state, e), this.setNeedsRedraw();
  }
  /** Sets the redraw flag for this layer, will trigger a redraw next animation frame */
  setNeedsRedraw() {
    this.internalState && (this.internalState.needsRedraw = !0);
  }
  /** Mark this layer as needs a deep update */
  setNeedsUpdate() {
    this.internalState && (this.context.layerManager.setNeedsUpdate(String(this)), this.internalState.needsUpdate = !0);
  }
  /** Returns true if all async resources are loaded */
  get isLoaded() {
    return this.internalState ? !this.internalState.isAsyncPropLoading() : !1;
  }
  /** Returns true if using shader-based WGS84 longitude wrapping */
  get wrapLongitude() {
    return this.props.wrapLongitude;
  }
  /** @deprecated Returns true if the layer is visible in the picking pass */
  isPickable() {
    return this.props.pickable && this.props.visible;
  }
  /** Returns an array of models used by this layer, can be overriden by layer subclass */
  getModels() {
    const e = this.state;
    return e && (e.models || e.model && [e.model]) || [];
  }
  /** Update shader input parameters */
  setShaderModuleProps() {
    for (const e of this.getModels())
      e.shaderInputs.setProps(...arguments);
  }
  /** Returns the attribute manager of this layer */
  getAttributeManager() {
    return this.internalState && this.internalState.attributeManager;
  }
  /** Returns the most recent layer that matched to this state
    (When reacting to an async event, this layer may no longer be the latest) */
  getCurrentLayer() {
    return this.internalState && this.internalState.layer;
  }
  /** Returns the default parse options for async props */
  getLoadOptions() {
    return this.props.loadOptions;
  }
  use64bitPositions() {
    const {
      coordinateSystem: e
    } = this.props;
    return e === Ln.DEFAULT || e === Ln.LNGLAT || e === Ln.CARTESIAN;
  }
  // Event handling
  onHover(e, t) {
    return this.props.onHover && this.props.onHover(e, t) || !1;
  }
  onClick(e, t) {
    return this.props.onClick && this.props.onClick(e, t) || !1;
  }
  // Returns the picking color that doesn't match any subfeature
  // Use if some graphics do not belong to any pickable subfeature
  // @return {Array} - a black color
  nullPickingColor() {
    return [0, 0, 0];
  }
  // Returns the picking color that doesn't match any subfeature
  // Use if some graphics do not belong to any pickable subfeature
  encodePickingColor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return t[0] = e + 1 & 255, t[1] = e + 1 >> 8 & 255, t[2] = e + 1 >> 8 >> 8 & 255, t;
  }
  // Returns the index corresponding to a picking color that doesn't match any subfeature
  // @param {Uint8Array} color - color array to be decoded
  // @return {Array} - the decoded picking color
  decodePickingColor(e) {
    ro(e instanceof Uint8Array);
    const [t, n, i] = e;
    return t + n * 256 + i * 65536 - 1;
  }
  /** Deduces number of instances. Intention is to support:
    - Explicit setting of numInstances
    - Auto-deduction for ES6 containers that define a size member
    - Auto-deduction for Classic Arrays via the built-in length attribute
    - Auto-deduction via arrays */
  getNumInstances() {
    return Number.isFinite(this.props.numInstances) ? this.props.numInstances : this.state && this.state.numInstances !== void 0 ? this.state.numInstances : U9(this.props.data);
  }
  /** Buffer layout describes how many attribute values are packed for each data object
      The default (null) is one value each object.
      Some data formats (e.g. paths, polygons) have various length. Their buffer layout
      is in the form of [L0, L1, L2, ...] */
  getStartIndices() {
    return this.props.startIndices ? this.props.startIndices : this.state && this.state.startIndices ? this.state.startIndices : null;
  }
  // Default implementation
  getBounds() {
    var e;
    return (e = this.getAttributeManager()) == null ? void 0 : e.getBounds(["positions", "instancePositions"]);
  }
  getShaders(e) {
    e = S3(e, {
      disableWarnings: !0,
      modules: this.context.defaultShaderModules
    });
    for (const t of this.props.extensions)
      e = S3(e, t.getShaders.call(this, t));
    return e;
  }
  /** Controls if updateState should be called. By default returns true if any prop has changed */
  shouldUpdateState(e) {
    return e.changeFlags.propsOrDataChanged;
  }
  /** Default implementation, all attributes will be invalidated and updated when data changes */
  // eslint-disable-next-line complexity
  updateState(e) {
    const t = this.getAttributeManager(), {
      dataChanged: n
    } = e.changeFlags;
    if (n && t)
      if (Array.isArray(n))
        for (const i of n)
          t.invalidateAll(i);
      else
        t.invalidateAll();
    if (t) {
      const {
        props: i
      } = e, s = this.internalState.hasPickingBuffer, l = Number.isInteger(i.highlightedObjectIndex) || i.pickable || i.extensions.some((o) => o.getNeedsPickingBuffer.call(this, o));
      if (s !== l) {
        this.internalState.hasPickingBuffer = l;
        const {
          pickingColors: o,
          instancePickingColors: d
        } = t.attributes, m = o || d;
        m && (l && m.constant && (m.constant = !1, t.invalidate(m.id)), !m.value && !l && (m.constant = !0, m.value = [0, 0, 0]));
      }
    }
  }
  /** Called once when layer is no longer matched and state will be discarded. Layers can destroy WebGL resources here. */
  finalizeState(e) {
    for (const n of this.getModels())
      n.destroy();
    const t = this.getAttributeManager();
    t && t.finalize(), this.context && this.context.resourceManager.unsubscribe({
      consumerId: this.id
    }), this.internalState && (this.internalState.uniformTransitions.clear(), this.internalState.finalize());
  }
  // If state has a model, draw it with supplied uniforms
  draw(e) {
    for (const t of this.getModels())
      t.draw(e.renderPass);
  }
  // called to populate the info object that is passed to the event handler
  // @return null to cancel event
  getPickingInfo(e) {
    let {
      info: t,
      mode: n,
      sourceLayer: i
    } = e;
    const {
      index: s
    } = t;
    return s >= 0 && Array.isArray(this.props.data) && (t.object = this.props.data[s]), t;
  }
  // END LIFECYCLE METHODS
  // / INTERNAL METHODS - called by LayerManager, DeckRenderer and DeckPicker
  /** (Internal) Propagate an error event through the system */
  raiseError(e, t) {
    var n, i, s, l;
    t && (e = new Error(`${t}: ${e.message}`, {
      cause: e
    })), (i = (n = this.props).onError) != null && i.call(n, e) || (l = (s = this.context) == null ? void 0 : s.onError) == null || l.call(s, e, this);
  }
  /** (Internal) Checks if this layer needs redraw */
  getNeedsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    return this._getNeedsRedraw(e);
  }
  /** (Internal) Checks if this layer needs a deep update */
  needsUpdate() {
    return this.internalState ? this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams()) : !1;
  }
  /** Checks if this layer has ongoing uniform transition */
  hasUniformTransition() {
    var e;
    return ((e = this.internalState) == null ? void 0 : e.uniformTransitions.active) || !1;
  }
  /** Called when this layer is rendered into the given viewport */
  activateViewport(e) {
    if (!this.internalState)
      return;
    const t = this.internalState.viewport;
    this.internalState.viewport = e, (!t || !fj({
      oldViewport: t,
      viewport: e
    })) && (this.setChangeFlags({
      viewportChanged: !0
    }), this.isComposite ? this.needsUpdate() && this.setNeedsUpdate() : this._update());
  }
  /** Default implementation of attribute invalidation, can be redefined */
  invalidateAttribute() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "all";
    const t = this.getAttributeManager();
    t && (e === "all" ? t.invalidateAll() : t.invalidate(e));
  }
  /** Send updated attributes to the WebGL model */
  updateAttributes(e) {
    let t = !1;
    for (const n in e)
      e[n].layoutChanged() && (t = !0);
    for (const n of this.getModels())
      this._setModelAttributes(n, e, t);
  }
  /** Recalculate any attributes if needed */
  _updateAttributes() {
    const e = this.getAttributeManager();
    if (!e)
      return;
    const t = this.props, n = this.getNumInstances(), i = this.getStartIndices();
    e.update({
      data: t.data,
      numInstances: n,
      startIndices: i,
      props: t,
      transitions: t.transitions,
      // @ts-ignore (TS2339) property attribute is not present on some acceptable data types
      buffers: t.data.attributes,
      context: this
    });
    const s = e.getChangedAttributes({
      clearChangedFlags: !0
    });
    this.updateAttributes(s);
  }
  /** Update attribute transitions. This is called in drawLayer, no model updates required. */
  _updateAttributeTransition() {
    const e = this.getAttributeManager();
    e && e.updateTransition();
  }
  /** Update uniform (prop) transitions. This is called in updateState, may result in model updates. */
  _updateUniformTransition() {
    const {
      uniformTransitions: e
    } = this.internalState;
    if (e.active) {
      const t = e.update(), n = Object.create(this.props);
      for (const i in t)
        Object.defineProperty(n, i, {
          value: t[i]
        });
      return n;
    }
    return this.props;
  }
  /** Updater for the automatically populated instancePickingColors attribute */
  calculateInstancePickingColors(e, t) {
    let {
      numInstances: n
    } = t;
    if (e.constant)
      return;
    const i = Math.floor(dc.length / 4);
    if (this.internalState.usesPickingColorCache = !0, i < n) {
      n > E3 && Gn.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")(), dc = Ng.allocate(dc, n, {
        size: 4,
        copy: !0,
        maxCount: Math.max(n, E3)
      });
      const s = Math.floor(dc.length / 4), l = [0, 0, 0];
      for (let o = i; o < s; o++)
        this.encodePickingColor(o, l), dc[o * 4 + 0] = l[0], dc[o * 4 + 1] = l[1], dc[o * 4 + 2] = l[2], dc[o * 4 + 3] = 0;
    }
    e.value = dc.subarray(0, n * 4);
  }
  /** Apply changed attributes to model */
  _setModelAttributes(e, t) {
    var o;
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    if (!Object.keys(t).length)
      return;
    if (n) {
      const d = this.getAttributeManager();
      e.setBufferLayout(d.getBufferLayouts(e)), t = d.getAttributes();
    }
    const i = ((o = e.userData) == null ? void 0 : o.excludeAttributes) || {}, s = {}, l = {};
    for (const d in t) {
      if (i[d])
        continue;
      const m = t[d].getValue();
      for (const b in m) {
        const A = m[b];
        A instanceof gs ? t[d].settings.isIndexed ? e.setIndexBuffer(A) : s[b] = A : A && (l[b] = A);
      }
    }
    e.setAttributes(s), e.setConstantAttributes(l);
  }
  /** (Internal) Sets the picking color at the specified index to null picking color. Used for multi-depth picking.
     This method may be overriden by layer implementations */
  disablePickingIndex(e) {
    const t = this.props.data;
    if (!("attributes" in t)) {
      this._disablePickingIndex(e);
      return;
    }
    const {
      pickingColors: n,
      instancePickingColors: i
    } = this.getAttributeManager().attributes, s = n || i, l = s && t.attributes && t.attributes[s.id];
    if (l && l.value) {
      const o = l.value, d = this.encodePickingColor(e);
      for (let m = 0; m < t.length; m++) {
        const b = s.getVertexOffset(m);
        o[b] === d[0] && o[b + 1] === d[1] && o[b + 2] === d[2] && this._disablePickingIndex(m);
      }
    } else
      this._disablePickingIndex(e);
  }
  // TODO - simplify subclassing interface
  _disablePickingIndex(e) {
    const {
      pickingColors: t,
      instancePickingColors: n
    } = this.getAttributeManager().attributes, i = t || n;
    if (!i)
      return;
    const s = i.getVertexOffset(e), l = i.getVertexOffset(e + 1);
    i.buffer.write(new Uint8Array(l - s), s);
  }
  /** (Internal) Re-enable all picking indices after multi-depth picking */
  restorePickingColors() {
    const {
      pickingColors: e,
      instancePickingColors: t
    } = this.getAttributeManager().attributes, n = e || t;
    n && // @ts-ignore (TS2531) this method is only called internally with internalState defined
    (this.internalState.usesPickingColorCache && n.value.buffer !== dc.buffer && (n.value = dc.subarray(0, n.value.length)), n.updateSubBuffer({
      startOffset: 0
    }));
  }
  /* eslint-disable max-statements */
  /* (Internal) Called by layer manager when a new layer is found */
  _initialize() {
    ro(!this.internalState), ro(Number.isFinite(this.props.coordinateSystem)), ea(aj, this);
    const e = this._getAttributeManager();
    e && e.addInstanced({
      instancePickingColors: {
        type: "uint8",
        size: 4,
        noAlloc: !0,
        // Updaters are always called with `this` pointing to the layer
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateInstancePickingColors
      }
    }), this.internalState = new sj({
      attributeManager: e,
      layer: this
    }), this._clearChangeFlags(), this.state = {}, Object.defineProperty(this.state, "attributeManager", {
      get: () => (Gn.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")(), e)
    }), this.internalState.uniformTransitions = new P9(this.context.timeline), this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this), this.internalState.setAsyncProps(this.props), this.initializeState(this.context);
    for (const t of this.props.extensions)
      t.initializeState.call(this, this.context, t);
    this.setChangeFlags({
      dataChanged: "init",
      propsChanged: "init",
      viewportChanged: !0,
      extensionsChanged: !0
    }), this._update();
  }
  /** (Internal) Called by layer manager to transfer state from an old layer */
  _transferState(e) {
    ea(uj, this, this === e);
    const {
      state: t,
      internalState: n
    } = e;
    this !== e && (this.internalState = n, this.state = t, this.internalState.setAsyncProps(this.props), this._diffProps(this.props, this.internalState.getOldProps()));
  }
  /** (Internal) Called by layer manager when a new layer is added or an existing layer is matched with a new instance */
  _update() {
    const e = this.needsUpdate();
    if (ea(lj, this, e), !e)
      return;
    const t = this.props, n = this.context, i = this.internalState, s = n.viewport, l = this._updateUniformTransition();
    i.propsInTransition = l, n.viewport = i.viewport || s, this.props = l;
    try {
      const o = this._getUpdateParams(), d = this.getModels();
      if (n.device)
        this.updateState(o);
      else
        try {
          this.updateState(o);
        } catch {
        }
      for (const b of this.props.extensions)
        b.updateState.call(this, o, b);
      this.setNeedsRedraw(), this._updateAttributes();
      const m = this.getModels()[0] !== d[0];
      this._postUpdate(o, m);
    } finally {
      n.viewport = s, this.props = t, this._clearChangeFlags(), i.needsUpdate = !1, i.resetOldProps();
    }
  }
  /* eslint-enable max-statements */
  /** (Internal) Called by manager when layer is about to be disposed
      Note: not guaranteed to be called on application shutdown */
  _finalize() {
    ea(cj, this), this.finalizeState(this.context);
    for (const e of this.props.extensions)
      e.finalizeState.call(this, this.context, e);
  }
  // Calculates uniforms
  _drawLayer(e) {
    let {
      renderPass: t,
      shaderModuleProps: n = null,
      uniforms: i = {},
      parameters: s = {}
    } = e;
    this._updateAttributeTransition();
    const l = this.props, o = this.context;
    this.props = this.internalState.propsInTransition || l;
    try {
      n && this.setShaderModuleProps(n);
      const {
        getPolygonOffset: d
      } = this.props, m = d && d(i) || [0, 0];
      o.device instanceof zd && o.device.setParametersWebGL({
        polygonOffset: m
      });
      for (const b of this.getModels())
        b.device.type === "webgpu" ? b.setParameters({
          ...b.parameters,
          ...s
        }) : b.setParameters(s);
      if (o.device instanceof zd)
        o.device.withParametersWebGL(s, () => {
          const b = {
            renderPass: t,
            shaderModuleProps: n,
            uniforms: i,
            parameters: s,
            context: o
          };
          for (const A of this.props.extensions)
            A.draw.call(this, b, A);
          this.draw(b);
        });
      else {
        const b = {
          renderPass: t,
          shaderModuleProps: n,
          uniforms: i,
          parameters: s,
          context: o
        };
        for (const A of this.props.extensions)
          A.draw.call(this, b, A);
        this.draw(b);
      }
    } finally {
      this.props = l;
    }
  }
  // Helper methods
  /** Returns the current change flags */
  getChangeFlags() {
    var e;
    return (e = this.internalState) == null ? void 0 : e.changeFlags;
  }
  /* eslint-disable complexity */
  /** Dirty some change flags, will be handled by updateLayer */
  setChangeFlags(e) {
    if (!this.internalState)
      return;
    const {
      changeFlags: t
    } = this.internalState;
    for (const i in e)
      if (e[i]) {
        let s = !1;
        switch (i) {
          case "dataChanged":
            const l = e[i], o = t[i];
            l && Array.isArray(o) && (t.dataChanged = Array.isArray(l) ? o.concat(l) : l, s = !0);
          default:
            t[i] || (t[i] = e[i], s = !0);
        }
        s && ea(oj, this, i, e);
      }
    const n = !!(t.dataChanged || t.updateTriggersChanged || t.propsChanged || t.extensionsChanged);
    t.propsOrDataChanged = n, t.somethingChanged = n || t.viewportChanged || t.stateChanged;
  }
  /* eslint-enable complexity */
  /** Clear all changeFlags, typically after an update */
  _clearChangeFlags() {
    this.internalState.changeFlags = {
      dataChanged: !1,
      propsChanged: !1,
      updateTriggersChanged: !1,
      viewportChanged: !1,
      stateChanged: !1,
      extensionsChanged: !1,
      propsOrDataChanged: !1,
      somethingChanged: !1
    };
  }
  /** Compares the layers props with old props from a matched older layer
      and extracts change flags that describe what has change so that state
      can be update correctly with minimal effort */
  _diffProps(e, t) {
    var i;
    const n = B9(e, t);
    if (n.updateTriggersChanged)
      for (const s in n.updateTriggersChanged)
        n.updateTriggersChanged[s] && this.invalidateAttribute(s);
    if (n.transitionsChanged)
      for (const s in n.transitionsChanged)
        this.internalState.uniformTransitions.add(s, t[s], e[s], (i = e.transitions) == null ? void 0 : i[s]);
    return this.setChangeFlags(n);
  }
  /** (Internal) called by layer manager to perform extra props validation (in development only) */
  validateProps() {
    R9(this.props);
  }
  /** (Internal) Called by deck picker when the hovered object changes to update the auto highlight */
  updateAutoHighlight(e) {
    this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex) && this._updateAutoHighlight(e);
  }
  // May be overriden by subclasses
  // TODO - simplify subclassing interface
  /** Update picking module parameters to highlight the hovered object */
  _updateAutoHighlight(e) {
    const t = {
      // @ts-ignore
      highlightedObjectColor: e.picked ? e.color : null
    }, {
      highlightColor: n
    } = this.props;
    e.picked && typeof n == "function" && (t.highlightColor = n(e)), this.setShaderModuleProps({
      picking: t
    }), this.setNeedsRedraw();
  }
  /** Create new attribute manager */
  _getAttributeManager() {
    const e = this.context;
    return new S9(e.device, {
      id: this.props.id,
      stats: e.stats,
      timeline: e.timeline
    });
  }
  // Private methods
  /** Called after updateState to perform common tasks */
  _postUpdate(e, t) {
    const {
      props: n,
      oldProps: i
    } = e, s = this.state.model;
    s != null && s.isInstanced && s.setInstanceCount(this.getNumInstances());
    const {
      autoHighlight: l,
      highlightedObjectIndex: o,
      highlightColor: d
    } = n;
    if (t || i.autoHighlight !== l || i.highlightedObjectIndex !== o || i.highlightColor !== d) {
      const m = {};
      Array.isArray(d) && (m.highlightColor = d), (t || i.autoHighlight !== l || o !== i.highlightedObjectIndex) && (m.highlightedObjectColor = Number.isFinite(o) && o >= 0 ? this.encodePickingColor(o) : null), this.setShaderModuleProps({
        picking: m
      });
    }
  }
  _getUpdateParams() {
    return {
      props: this.props,
      // @ts-ignore TS2531 this method can only be called internally with internalState assigned
      oldProps: this.internalState.getOldProps(),
      context: this.context,
      // @ts-ignore TS2531 this method can only be called internally with internalState assigned
      changeFlags: this.internalState.changeFlags
    };
  }
  /** Checks state of attributes and model */
  _getNeedsRedraw(e) {
    if (!this.internalState)
      return !1;
    let t = !1;
    t = t || this.internalState.needsRedraw && this.id;
    const n = this.getAttributeManager(), i = n ? n.getNeedsRedraw(e) : !1;
    if (t = t || i, t)
      for (const s of this.props.extensions)
        s.onNeedsRedraw.call(this, s);
    return this.internalState.needsRedraw = this.internalState.needsRedraw && !e.clearRedrawFlags, t;
  }
  /** Callback when asyn prop is loaded */
  _onAsyncPropUpdated() {
    this._diffProps(this.props, this.internalState.getOldProps()), this.setNeedsUpdate();
  }
}
vp.defaultProps = dj;
vp.layerName = "Layer";
const pj = "compositeLayer.renderLayers";
class SI extends vp {
  /** `true` if this layer renders other layers */
  get isComposite() {
    return !0;
  }
  /** `true` if the layer renders to screen */
  get isDrawable() {
    return !1;
  }
  /** Returns true if all async resources are loaded */
  get isLoaded() {
    return super.isLoaded && this.getSubLayers().every((e) => e.isLoaded);
  }
  /** Return last rendered sub layers */
  getSubLayers() {
    return this.internalState && this.internalState.subLayers || [];
  }
  // initializeState is usually not needed for composite layers
  // Provide empty definition to disable check for missing definition
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  initializeState(e) {
  }
  /** Updates selected state members and marks the composite layer to need rerender */
  setState(e) {
    super.setState(e), this.setNeedsUpdate();
  }
  /** called to augment the info object that is bubbled up from a sublayer
      override Layer.getPickingInfo() because decoding / setting uniform do
      not apply to a composite layer. */
  getPickingInfo(e) {
    let {
      info: t
    } = e;
    const {
      object: n
    } = t;
    return n && n.__source && n.__source.parent && n.__source.parent.id === this.id && (t.object = n.__source.object, t.index = n.__source.index), t;
  }
  /**
   * Filters sub layers at draw time. Return true if the sub layer should be drawn.
   */
  filterSubLayer(e) {
    return !0;
  }
  /** Returns true if sub layer needs to be rendered */
  shouldRenderSubLayer(e, t) {
    return t && t.length;
  }
  /** Returns sub layer class for a specific sublayer */
  getSubLayerClass(e, t) {
    const {
      _subLayerProps: n
    } = this.props;
    return n && n[e] && n[e].type || t;
  }
  /** When casting user data into another format to pass to sublayers,
      add reference to the original object and object index */
  getSubLayerRow(e, t, n) {
    return e.__source = {
      parent: this,
      object: t,
      index: n
    }, e;
  }
  /** Some composite layers cast user data into another format before passing to sublayers
    We need to unwrap them before calling the accessor so that they see the original data
    objects */
  getSubLayerAccessor(e) {
    if (typeof e == "function") {
      const t = {
        index: -1,
        // @ts-ignore accessing resolved data
        data: this.props.data,
        target: []
      };
      return (n, i) => n && n.__source ? (t.index = n.__source.index, e(n.__source.object, t)) : e(n, i);
    }
    return e;
  }
  /** Returns sub layer props for a specific sublayer */
  // eslint-disable-next-line complexity
  getSubLayerProps() {
    var be;
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      opacity: t,
      pickable: n,
      visible: i,
      parameters: s,
      getPolygonOffset: l,
      highlightedObjectIndex: o,
      autoHighlight: d,
      highlightColor: m,
      coordinateSystem: b,
      coordinateOrigin: A,
      wrapLongitude: M,
      positionFormat: E,
      modelMatrix: k,
      extensions: U,
      fetch: V,
      operation: q,
      _subLayerProps: Y
    } = this.props, re = {
      id: "",
      updateTriggers: {},
      opacity: t,
      pickable: n,
      visible: i,
      parameters: s,
      getPolygonOffset: l,
      highlightedObjectIndex: o,
      autoHighlight: d,
      highlightColor: m,
      coordinateSystem: b,
      coordinateOrigin: A,
      wrapLongitude: M,
      positionFormat: E,
      modelMatrix: k,
      extensions: U,
      fetch: V,
      operation: q
    }, Z = Y && e.id && Y[e.id], K = Z && Z.updateTriggers, ie = e.id || "sublayer";
    if (Z) {
      const he = this.props[qh], Be = e.type ? e.type._propTypes : {};
      for (const ke in Z) {
        const pe = Be[ke] || he[ke];
        pe && pe.type === "accessor" && (Z[ke] = this.getSubLayerAccessor(Z[ke]));
      }
    }
    Object.assign(
      re,
      e,
      // experimental feature that allows users to override sublayer props via parent layer prop
      Z
    ), re.id = `${this.props.id}-${ie}`, re.updateTriggers = {
      all: (be = this.props.updateTriggers) == null ? void 0 : be.all,
      ...e.updateTriggers,
      ...K
    };
    for (const he of U) {
      const Be = he.getSubLayerProps.call(this, he);
      Be && Object.assign(re, Be, {
        updateTriggers: Object.assign(re.updateTriggers, Be.updateTriggers)
      });
    }
    return re;
  }
  /** Update sub layers to highlight the hovered object */
  _updateAutoHighlight(e) {
    for (const t of this.getSubLayers())
      t.updateAutoHighlight(e);
  }
  /** Override base Layer method */
  _getAttributeManager() {
    return null;
  }
  /** (Internal) Called after an update to rerender sub layers */
  _postUpdate(e, t) {
    let n = this.internalState.subLayers;
    const i = !n || this.needsUpdate();
    if (i) {
      const s = this.renderLayers();
      n = ap(s, Boolean), this.internalState.subLayers = n;
    }
    ea(pj, this, i, n);
    for (const s of n)
      s.parent = this;
  }
}
SI.layerName = "CompositeLayer";
const Um = Math.PI / 180, C3 = 180 / Math.PI, __ = 6370972, jd = 256;
function gj() {
  const r = jd / __, e = Math.PI / 180 * jd;
  return {
    unitsPerMeter: [r, r, r],
    unitsPerMeter2: [0, 0, 0],
    metersPerUnit: [1 / r, 1 / r, 1 / r],
    unitsPerDegree: [e, e, r],
    unitsPerDegree2: [0, 0, 0],
    degreesPerUnit: [1 / e, 1 / e, 1 / r]
  };
}
class mj extends yp {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      longitude: t = 0,
      zoom: n = 0,
      // Matches Maplibre defaults
      // https://github.com/maplibre/maplibre-gl-js/blob/f8ab4b48d59ab8fe7b068b102538793bbdd4c848/src/geo/projection/globe_transform.ts#L632-L633
      nearZMultiplier: i = 0.5,
      farZMultiplier: s = 1,
      resolution: l = 10
    } = e;
    let {
      latitude: o = 0,
      height: d,
      altitude: m = 1.5,
      fovy: b
    } = e;
    o = Math.max(Math.min(o, ty), -85.051129), d = d || 1, b ? m = V2(b) : b = kg(m);
    const A = 1 / Math.PI / Math.cos(o * Math.PI / 180), M = Math.pow(2, n) * A, E = e.nearZ ?? i, k = e.farZ ?? (m + jd * 2 * M / d) * s, U = new Bn().lookAt({
      eye: [0, -m, 0],
      up: [0, 0, 1]
    });
    U.rotateX(o * Um), U.rotateZ(-t * Um), U.scale(M / d), super({
      ...e,
      // x, y, width,
      height: d,
      // view matrix
      viewMatrix: U,
      longitude: t,
      latitude: o,
      zoom: n,
      // projection matrix parameters
      distanceScales: gj(),
      fovy: b,
      focalDistance: m,
      near: E,
      far: k
    }), this.scale = M, this.latitude = o, this.longitude = t, this.resolution = l;
  }
  get projectionMode() {
    return ml.GLOBE;
  }
  getDistanceScales() {
    return this.distanceScales;
  }
  getBounds() {
    const t = {
      targetZ: (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}).z || 0
    }, n = this.unproject([0, this.height / 2], t), i = this.unproject([this.width / 2, 0], t), s = this.unproject([this.width, this.height / 2], t), l = this.unproject([this.width / 2, this.height], t);
    return s[0] < this.longitude && (s[0] += 360), n[0] > this.longitude && (n[0] -= 360), [Math.min(n[0], s[0], i[0], l[0]), Math.min(n[1], s[1], i[1], l[1]), Math.max(n[0], s[0], i[0], l[0]), Math.max(n[1], s[1], i[1], l[1])];
  }
  unproject(e) {
    let {
      topLeft: t = !0,
      targetZ: n
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const [i, s, l] = e, o = t ? s : this.height - s, {
      pixelUnprojectionMatrix: d
    } = this;
    let m;
    if (Number.isFinite(l))
      m = Ob(d, [i, o, l, 1]);
    else {
      const E = Ob(d, [i, o, -1, 1]), k = Ob(d, [i, o, 1, 1]), U = ((n || 0) / __ + 1) * jd, V = _b(a5([], E, k)), q = _b(E), Y = _b(k), Z = 4 * ((4 * q * Y - (V - q - Y) ** 2) / 16) / V, K = Math.sqrt(q - Z), ie = Math.sqrt(Math.max(0, U * U - Z)), be = (K - ie) / Math.sqrt(V);
      m = sN([], E, k, be);
    }
    const [b, A, M] = this.unprojectPosition(m);
    return Number.isFinite(l) ? [b, A, M] : Number.isFinite(n) ? [b, A, n] : [b, A];
  }
  projectPosition(e) {
    const [t, n, i = 0] = e, s = t * Um, l = n * Um, o = Math.cos(l), d = (i / __ + 1) * jd;
    return [Math.sin(s) * o * d, -Math.cos(s) * o * d, Math.sin(l) * d];
  }
  unprojectPosition(e) {
    const [t, n, i] = e, s = l5(e), l = Math.asin(i / s), d = Math.atan2(t, -n) * C3, m = l * C3, b = (s / jd - 1) * __;
    return [d, m, b];
  }
  projectFlat(e) {
    return e;
  }
  unprojectFlat(e) {
    return e;
  }
  panByPosition(e, t) {
    const n = this.unproject(t);
    return {
      longitude: e[0] - n[0] + this.longitude,
      latitude: e[1] - n[1] + this.latitude
    };
  }
}
function Ob(r, e) {
  const t = _p([], e, r);
  return D2(t, t, 1 / t[3]), t;
}
class _j extends Z5 {
  // Apply any constraints (mathematical or defined by _viewportProps) to map state
  applyConstraints(e) {
    const {
      maxZoom: t,
      minZoom: n,
      zoom: i
    } = e;
    e.zoom = Sc(i, n, t);
    const {
      longitude: s,
      latitude: l
    } = e;
    return (s < -180 || s > 180) && (e.longitude = O8(s + 180, 360) - 180), e.latitude = Sc(l, -85.051129, ty), e;
  }
}
class yj extends X5 {
  constructor() {
    super(...arguments), this.ControllerState = _j, this.transition = {
      transitionDuration: 300,
      transitionInterpolator: new W2(["longitude", "latitude", "zoom"])
    }, this.dragMode = "pan";
  }
  setProps(e) {
    super.setProps(e), this.dragRotate = !1, this.touchRotate = !1;
  }
}
class EI extends W5 {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(e);
  }
  getViewportType(e) {
    return e.zoom > 12 ? qf : mj;
  }
  get ControllerType() {
    return yj;
  }
}
EI.displayName = "GlobeView";
const kb = 512, bj = Math.PI / 180;
function CI(r) {
  let {
    map: e,
    gl: t,
    deck: n
  } = r;
  if (e.__deck)
    return e.__deck;
  const i = n == null ? void 0 : n.props._customRender, s = n == null ? void 0 : n.props.onLoad, l = {
    ...n == null ? void 0 : n.props,
    _customRender: () => {
      e.triggerRepaint(), i == null || i("");
    }
  };
  l.parameters = {
    ...Av(e, !0),
    ...l.parameters
  }, l.views || (l.views = oy(e));
  let o;
  return (!n || n.props.gl === t) && (Object.assign(l, {
    gl: t,
    width: null,
    height: null,
    touchAction: "unset",
    viewState: Ug(e)
  }), n != null && n.isInitialized ? I3(n, e) : l.onLoad = () => {
    s == null || s(), I3(o, e);
  }), n ? (o = n, n.setProps(l), n.userData.isExternal = !0) : (o = new Fg(l), e.on("remove", () => {
    II(e);
  })), o.userData.mapboxLayers = /* @__PURE__ */ new Set(), e.__deck = o, e.on("render", () => {
    o.isInitialized && Sj(o, e);
  }), o;
}
function I3(r, e) {
  const t = () => {
    r.isInitialized ? Ej(r, e) : e.off("move", t);
  };
  e.on("move", t);
}
function II(r) {
  var e;
  (e = r.__deck) == null || e.finalize(), r.__deck = null;
}
function Av(r, e) {
  const t = e ? {
    depthWriteEnabled: !0,
    depthCompare: "less-equal",
    depthBias: 0,
    blend: !0,
    blendColorSrcFactor: "src-alpha",
    blendColorDstFactor: "one-minus-src-alpha",
    blendAlphaSrcFactor: "one",
    blendAlphaDstFactor: "one-minus-src-alpha",
    blendColorOperation: "add",
    blendAlphaOperation: "add"
  } : {};
  return MI(r) === "globe" && (t.cullMode = "back"), t;
}
function vj(r, e) {
  r.userData.mapboxLayers.add(e), tx(r);
}
function xj(r, e) {
  r.userData.mapboxLayers.delete(e), tx(r);
}
function wj(r, e) {
  tx(r);
}
function Aj(r, e, t, n) {
  let {
    currentViewport: i
  } = r.userData, s = !1;
  i || (i = PI(r, e, n), r.userData.currentViewport = i, s = !0), r.isInitialized && r._drawLayers("mapbox-repaint", {
    viewports: [i],
    layerFilter: (l) => {
      let {
        layer: o
      } = l;
      return t.id === o.id || o.props.operation.includes("terrain");
    },
    clearStack: s,
    clearCanvas: !1
  });
}
function MI(r) {
  var n;
  const e = (n = r.getProjection) == null ? void 0 : n.call(r), t = (
    // maplibre projection spec
    (e == null ? void 0 : e.type) || // mapbox projection spec
    (e == null ? void 0 : e.name)
  );
  if (t === "globe")
    return "globe";
  if (t && t !== "mercator")
    throw new Error("Unsupported projection");
  return "mercator";
}
function oy(r) {
  return MI(r) === "globe" ? new EI({
    id: "mapbox"
  }) : new X2({
    id: "mapbox"
  });
}
function Ug(r) {
  var i;
  const {
    lng: e,
    lat: t
  } = r.getCenter(), n = {
    // Longitude returned by getCenter can be outside of [-180, 180] when zooming near the anti meridian
    // https://github.com/visgl/deck.gl/issues/6894
    longitude: (e + 540) % 360 - 180,
    latitude: t,
    zoom: r.getZoom(),
    bearing: r.getBearing(),
    pitch: r.getPitch(),
    padding: r.getPadding(),
    repeat: r.getRenderWorldCopies()
  };
  return (i = r.getTerrain) != null && i.call(r) && Tj(r, n), n;
}
function Tj(r, e) {
  if (r.getFreeCameraOptions) {
    const {
      position: t
    } = r.getFreeCameraOptions();
    if (!t || t.z === void 0)
      return;
    const n = r.transform.height, {
      longitude: i,
      latitude: s,
      pitch: l
    } = e, o = t.x * kb, d = (1 - t.y) * kb, m = t.z * kb, b = Og([i, s]), A = o - b[0], M = d - b[1], E = Math.sqrt(A * A + M * M), k = l * bj, U = 1.5 * n, V = k < 1e-3 ? (
      // Pitch angle too small to deduce the look at point, assume elevation is 0
      U * Math.cos(k) / m
    ) : U * Math.sin(k) / E;
    e.zoom = Math.log2(V);
    const q = U * Math.cos(k) / V, Y = m - q;
    e.position = [0, 0, Y / g_(s)];
  } else typeof r.transform.elevation == "number" && (e.position = [0, 0, r.transform.elevation]);
}
function PI(r, e, t) {
  const n = Ug(e), i = oy(e);
  t && (i.props.nearZMultiplier = 0.2);
  const s = (t == null ? void 0 : t.nearZ) ?? e.transform._nearZ, l = (t == null ? void 0 : t.farZ) ?? e.transform._farZ;
  return Number.isFinite(s) && (n.nearZ = s / e.transform.height, n.farZ = l / e.transform.height), i.makeViewport({
    width: r.width,
    height: r.height,
    viewState: n
  });
}
function Sj(r, e) {
  const {
    mapboxLayers: t,
    isExternal: n
  } = r.userData;
  if (n) {
    const i = Array.from(t, (b) => b.id), l = ap(r.props.layers, Boolean).some((b) => b && !i.includes(b.id));
    let o = r.getViewports();
    const d = o.findIndex((b) => b.id === "mapbox"), m = o.length > 1 || d < 0;
    (l || m) && (d >= 0 && (o = o.slice(), o[d] = PI(r, e)), r._drawLayers("mapbox-repaint", {
      viewports: o,
      layerFilter: (b) => (!r.props.layerFilter || r.props.layerFilter(b)) && (b.viewport.id !== "mapbox" || !i.includes(b.layer.id)),
      clearCanvas: !1
    }));
  }
  r.userData.currentViewport = null;
}
function Ej(r, e) {
  r.setProps({
    viewState: Ug(e)
  }), r.needsRedraw({
    clearRedrawFlags: !0
  });
}
function tx(r) {
  if (r.userData.isExternal)
    return;
  const e = [];
  r.userData.mapboxLayers.forEach((t) => {
    const n = t.props.type, i = new n(t.props);
    e.push(i);
  }), r.setProps({
    layers: e
  });
}
class Cj {
  /* eslint-disable no-this-before-super */
  constructor(e) {
    if (!e.id)
      throw new Error("Layer must have an unique id");
    this.id = e.id, this.type = "custom", this.renderingMode = e.renderingMode || "3d", this.slot = e.slot, this.map = null, this.deck = null, this.props = e;
  }
  /* Mapbox custom layer methods */
  onAdd(e, t) {
    this.map = e, this.deck = CI({
      map: e,
      gl: t,
      deck: this.props.deck
    }), vj(this.deck, this);
  }
  onRemove() {
    this.deck && xj(this.deck, this);
  }
  setProps(e) {
    Object.assign(this.props, e, {
      id: this.id
    }), this.deck && wj(this.deck);
  }
  render(e, t) {
    Aj(this.deck, this.map, this, t);
  }
}
const Nb = "__UNDEFINED__";
function zm(r, e, t, n) {
  if (!r || !e || !r.style || !r.style._loaded)
    return;
  const i = ap(n, Boolean);
  if (t !== n) {
    const o = ap(t, Boolean), d = new Set(o.map((m) => m.id));
    for (const m of i)
      d.delete(m.id);
    for (const m of d)
      r.getLayer(m) && r.removeLayer(m);
  }
  for (const o of i) {
    const d = r.getLayer(o.id);
    d ? (d.implementation || d).setProps(o.props) : r.addLayer(
      new Cj({
        id: o.id,
        deck: e,
        // @ts-expect-error slot is not defined in LayerProps
        slot: o.props.slot
      }),
      // @ts-expect-error beforeId is not defined in LayerProps
      o.props.beforeId
    );
  }
  const s = r.style._order, l = {};
  for (const o of i) {
    let {
      beforeId: d
    } = o.props;
    (!d || !s.includes(d)) && (d = Nb), l[d] = l[d] || [], l[d].push(o.id);
  }
  for (const o in l) {
    const d = l[o];
    let m = o === Nb ? s.length : s.indexOf(o), b = o === Nb ? void 0 : o;
    for (let A = d.length - 1; A >= 0; A--) {
      const M = d[A], E = s.indexOf(M);
      E !== m - 1 && (r.moveLayer(M, b), E > m && m++), m--, b = M;
    }
  }
}
class Ij {
  constructor(e) {
    this._handleStyleChange = () => {
      zm(this._map, this._deck, this._props.layers, this._props.layers);
    }, this._updateContainerSize = () => {
      if (this._map && this._container) {
        const {
          clientWidth: i,
          clientHeight: s
        } = this._map.getContainer();
        Object.assign(this._container.style, {
          width: `${i}px`,
          height: `${s}px`
        });
      }
    }, this._updateViewState = () => {
      const i = this._deck, s = this._map;
      i && s && (i.setProps({
        views: this._props.views || oy(s),
        viewState: Ug(s)
      }), i.isInitialized && i.redraw());
    }, this._handleMouseEvent = (i) => {
      const s = this._deck;
      if (!s || !s.isInitialized)
        return;
      const l = {
        type: i.type,
        offsetCenter: i.point,
        srcEvent: i
      }, o = this._lastMouseDownPoint;
      switch (!i.point && o && (l.deltaX = i.originalEvent.clientX - o.clientX, l.deltaY = i.originalEvent.clientY - o.clientY, l.offsetCenter = {
        x: o.x + l.deltaX,
        y: o.y + l.deltaY
      }), l.type) {
        case "mousedown":
          s._onPointerDown(l), this._lastMouseDownPoint = {
            ...i.point,
            clientX: i.originalEvent.clientX,
            clientY: i.originalEvent.clientY
          };
          break;
        case "dragstart":
          l.type = "panstart", s._onEvent(l);
          break;
        case "drag":
          l.type = "panmove", s._onEvent(l);
          break;
        case "dragend":
          l.type = "panend", s._onEvent(l);
          break;
        case "click":
          l.tapCount = 1, s._onEvent(l);
          break;
        case "dblclick":
          l.type = "click", l.tapCount = 2, s._onEvent(l);
          break;
        case "mousemove":
          l.type = "pointermove", s._onPointerMove(l);
          break;
        case "mouseout":
          l.type = "pointerleave", s._onPointerMove(l);
          break;
        default:
          return;
      }
    };
    const {
      interleaved: t = !1,
      ...n
    } = e;
    this._interleaved = t, this._props = n;
  }
  /** Update (partial) props of the underlying Deck instance. */
  setProps(e) {
    this._interleaved && e.layers && zm(this._map, this._deck, this._props.layers, e.layers), Object.assign(this._props, e), this._deck && this._map && this._deck.setProps({
      ...this._props,
      parameters: {
        ...Av(this._map, this._interleaved),
        ...this._props.parameters
      }
    });
  }
  // The local Map type is for internal typecheck only. It does not necesarily satisefy mapbox/maplibre types at runtime.
  // Do not restrict the argument type here to avoid type conflict.
  /** Called when the control is added to a map */
  onAdd(e) {
    return this._map = e, this._interleaved ? this._onAddInterleaved(e) : this._onAddOverlaid(e);
  }
  _onAddOverlaid(e) {
    const t = document.createElement("div");
    return Object.assign(t.style, {
      position: "absolute",
      left: 0,
      top: 0,
      textAlign: "initial",
      pointerEvents: "none"
    }), this._container = t, this._deck = new Fg({
      ...this._props,
      parent: t,
      parameters: {
        ...Av(e, !1),
        ...this._props.parameters
      },
      views: this._props.views || oy(e),
      viewState: Ug(e)
    }), e.on("resize", this._updateContainerSize), e.on("render", this._updateViewState), e.on("mousedown", this._handleMouseEvent), e.on("dragstart", this._handleMouseEvent), e.on("drag", this._handleMouseEvent), e.on("dragend", this._handleMouseEvent), e.on("mousemove", this._handleMouseEvent), e.on("mouseout", this._handleMouseEvent), e.on("click", this._handleMouseEvent), e.on("dblclick", this._handleMouseEvent), this._updateContainerSize(), t;
  }
  _onAddInterleaved(e) {
    const t = e.painter.context.gl;
    return t instanceof WebGLRenderingContext && Gn.warn("Incompatible basemap library. See: https://deck.gl/docs/api-reference/mapbox/overview#compatibility")(), this._deck = CI({
      map: e,
      gl: t,
      deck: new Fg({
        ...this._props,
        gl: t
      })
    }), e.on("styledata", this._handleStyleChange), zm(e, this._deck, [], this._props.layers), document.createElement("div");
  }
  /** Called when the control is removed from a map */
  onRemove() {
    const e = this._map;
    e && (this._interleaved ? this._onRemoveInterleaved(e) : this._onRemoveOverlaid(e)), this._deck = void 0, this._map = void 0, this._container = void 0;
  }
  _onRemoveOverlaid(e) {
    var t;
    e.off("resize", this._updateContainerSize), e.off("render", this._updateViewState), e.off("mousedown", this._handleMouseEvent), e.off("dragstart", this._handleMouseEvent), e.off("drag", this._handleMouseEvent), e.off("dragend", this._handleMouseEvent), e.off("mousemove", this._handleMouseEvent), e.off("mouseout", this._handleMouseEvent), e.off("click", this._handleMouseEvent), e.off("dblclick", this._handleMouseEvent), (t = this._deck) == null || t.finalize();
  }
  _onRemoveInterleaved(e) {
    e.off("styledata", this._handleStyleChange), zm(e, this._deck, this._props.layers, []), II(e);
  }
  getDefaultPosition() {
    return "top-left";
  }
  /** Forwards the Deck.pickObject method */
  pickObject(e) {
    return ro(this._deck), this._deck.pickObject(e);
  }
  /** Forwards the Deck.pickMultipleObjects method */
  pickMultipleObjects(e) {
    return ro(this._deck), this._deck.pickMultipleObjects(e);
  }
  /** Forwards the Deck.pickObjects method */
  pickObjects(e) {
    return ro(this._deck), this._deck.pickObjects(e);
  }
  /** Remove from map and releases all resources */
  finalize() {
    this._map && this._map.removeControl(this);
  }
  /** If interleaved: true, returns base map's canvas, otherwise forwards the Deck.getCanvas method. */
  getCanvas() {
    return this._map ? this._interleaved ? this._map.getCanvas() : this._deck.getCanvas() : null;
  }
}
const M3 = `uniform pointCloudUniforms {
  float radiusPixels;
  highp int sizeUnits;
} pointCloud;
`, Mj = {
  name: "pointCloud",
  vs: M3,
  fs: M3,
  uniformTypes: {
    radiusPixels: "f32",
    sizeUnits: "i32"
  }
}, Pj = `#version 300 es
#define SHADER_NAME point-cloud-layer-vertex-shader
in vec3 positions;
in vec3 instanceNormals;
in vec4 instanceColors;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec3 instancePickingColors;
out vec4 vColor;
out vec2 unitPosition;
void main(void) {
geometry.worldPosition = instancePositions;
geometry.normal = project_normal(instanceNormals);
unitPosition = positions.xy;
geometry.uv = unitPosition;
geometry.pickingColor = instancePickingColors;
vec3 offset = vec3(positions.xy * project_size_to_pixel(pointCloud.radiusPixels, pointCloud.sizeUnits), 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, instanceColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, Rj = `#version 300 es
#define SHADER_NAME point-cloud-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 unitPosition;
out vec4 fragColor;
void main(void) {
geometry.uv = unitPosition.xy;
float distToCenter = length(unitPosition);
if (distToCenter > 1.0) {
discard;
}
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, RI = [0, 0, 0, 255], BI = [0, 0, 1], Bj = {
  sizeUnits: "pixels",
  pointSize: {
    type: "number",
    min: 0,
    value: 10
  },
  //  point radius in pixels
  getPosition: {
    type: "accessor",
    value: (r) => r.position
  },
  getNormal: {
    type: "accessor",
    value: BI
  },
  getColor: {
    type: "accessor",
    value: RI
  },
  material: !0,
  // Depreated
  radiusPixels: {
    deprecatedFor: "pointSize"
  }
};
function Lj(r) {
  const {
    header: e,
    attributes: t
  } = r;
  if (!(!e || !t) && (r.length = e.vertexCount, t.POSITION && (t.instancePositions = t.POSITION), t.NORMAL && (t.instanceNormals = t.NORMAL), t.COLOR_0)) {
    const {
      size: n,
      value: i
    } = t.COLOR_0;
    t.instanceColors = {
      size: n,
      type: "unorm8",
      value: i
    };
  }
}
class rx extends vp {
  getShaders() {
    return super.getShaders({
      vs: Pj,
      fs: Rj,
      modules: [z2, x5, q2, Mj]
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: !0,
        accessor: "getPosition"
      },
      instanceNormals: {
        size: 3,
        transition: !0,
        accessor: "getNormal",
        defaultValue: BI
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: !0,
        accessor: "getColor",
        defaultValue: RI
      }
    });
  }
  updateState(e) {
    var i;
    const {
      changeFlags: t,
      props: n
    } = e;
    super.updateState(e), t.extensionsChanged && ((i = this.state.model) == null || i.destroy(), this.state.model = this._getModel(), this.getAttributeManager().invalidateAll()), t.dataChanged && Lj(n.data);
  }
  draw(e) {
    let {
      uniforms: t
    } = e;
    const {
      pointSize: n,
      sizeUnits: i
    } = this.props, s = this.state.model, l = {
      sizeUnits: Lg[i],
      radiusPixels: n
    };
    s.shaderInputs.setProps({
      pointCloud: l
    }), s.draw(this.context.renderPass);
  }
  _getModel() {
    const e = [];
    for (let t = 0; t < 3; t++) {
      const n = t / 3 * Math.PI * 2;
      e.push(Math.cos(n) * 2, Math.sin(n) * 2, 0);
    }
    return new Xh(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Xd({
        topology: "triangle-list",
        attributes: {
          positions: new Float32Array(e)
        }
      }),
      isInstanced: !0
    });
  }
}
rx.layerName = "PointCloudLayer";
rx.defaultProps = Bj;
const pl = {
  OUTSIDE: -1,
  // Represents that an object is not contained within the frustum.
  INTERSECTING: 0,
  // Represents that an object intersects one of the frustum's planes.
  INSIDE: 1
  // Represents that an object is fully within the frustum.
};
new Ct();
new Ct();
const Kp = new Ct(), P3 = new Ct();
class Jg {
  /** Creates a bounding sphere */
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [0, 0, 0], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    this.radius = -0, this.center = new Ct(), this.fromCenterRadius(e, t);
  }
  /** Sets the bounding sphere from `center` and `radius`. */
  fromCenterRadius(e, t) {
    return this.center.from(e), this.radius = t, this;
  }
  /**
   * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere
   * tightly and fully encompasses the box.
   */
  fromCornerPoints(e, t) {
    return t = Kp.from(t), this.center = new Ct().from(e).add(t).scale(0.5), this.radius = this.center.distance(t), this;
  }
  /** Compares the provided BoundingSphere component wise */
  equals(e) {
    return this === e || !!e && this.center.equals(e.center) && this.radius === e.radius;
  }
  /** Duplicates a BoundingSphere instance. */
  clone() {
    return new Jg(this.center, this.radius);
  }
  /** Computes a bounding sphere that contains both the left and right bounding spheres. */
  union(e) {
    const t = this.center, n = this.radius, i = e.center, s = e.radius, l = Kp.copy(i).subtract(t), o = l.magnitude();
    if (n >= o + s)
      return this.clone();
    if (s >= o + n)
      return e.clone();
    const d = (n + o + s) * 0.5;
    return P3.copy(l).scale((-n + d) / o).add(t), this.center.copy(P3), this.radius = d, this;
  }
  /** Computes a bounding sphere by enlarging the provided sphere to contain the provided point. */
  expand(e) {
    const n = Kp.from(e).subtract(this.center).magnitude();
    return n > this.radius && (this.radius = n), this;
  }
  // BoundingVolume interface
  /**
   * Applies a 4x4 affine transformation matrix to a bounding sphere.
   * @param sphere The bounding sphere to apply the transformation to.
   * @param transform The transformation matrix to apply to the bounding sphere.
   * @returns self.
   */
  transform(e) {
    this.center.transform(e);
    const t = SN(Kp, e);
    return this.radius = Math.max(t[0], Math.max(t[1], t[2])) * this.radius, this;
  }
  /** Computes the estimated distance squared from the closest point on a bounding sphere to a point. */
  distanceSquaredTo(e) {
    const t = this.distanceTo(e);
    return t * t;
  }
  /** Computes the estimated distance from the closest point on a bounding sphere to a point. */
  distanceTo(e) {
    const n = Kp.from(e).subtract(this.center);
    return Math.max(0, n.len() - this.radius);
  }
  /** Determines which side of a plane a sphere is located. */
  intersectPlane(e) {
    const t = this.center, n = this.radius, s = e.normal.dot(t) + e.distance;
    return s < -n ? pl.OUTSIDE : s < n ? pl.INTERSECTING : pl.INSIDE;
  }
}
const Oj = new Ct(), kj = new Ct(), jm = new Ct(), Vm = new Ct(), $m = new Ct(), Nj = new Ct(), Dj = new Ct(), Hu = {
  COLUMN0ROW0: 0,
  COLUMN0ROW1: 1,
  COLUMN0ROW2: 2,
  COLUMN1ROW0: 3,
  COLUMN1ROW1: 4,
  COLUMN1ROW2: 5,
  COLUMN2ROW0: 6,
  COLUMN2ROW1: 7,
  COLUMN2ROW2: 8
};
class Qg {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [0, 0, 0], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0, 0, 0, 0, 0, 0, 0];
    this.center = new Ct().from(e), this.halfAxes = new ms(t);
  }
  /** Returns an array with three halfSizes for the bounding box */
  get halfSize() {
    const e = this.halfAxes.getColumn(0), t = this.halfAxes.getColumn(1), n = this.halfAxes.getColumn(2);
    return [new Ct(e).len(), new Ct(t).len(), new Ct(n).len()];
  }
  /** Returns a quaternion describing the orientation of the bounding box */
  get quaternion() {
    const e = this.halfAxes.getColumn(0), t = this.halfAxes.getColumn(1), n = this.halfAxes.getColumn(2), i = new Ct(e).normalize(), s = new Ct(t).normalize(), l = new Ct(n).normalize();
    return new Rg().fromMatrix3(new ms([...i, ...s, ...l]));
  }
  /**
   * Create OrientedBoundingBox from quaternion based OBB,
   */
  fromCenterHalfSizeQuaternion(e, t, n) {
    const i = new Rg(n), s = new ms().fromQuaternion(i);
    return s[0] = s[0] * t[0], s[1] = s[1] * t[0], s[2] = s[2] * t[0], s[3] = s[3] * t[1], s[4] = s[4] * t[1], s[5] = s[5] * t[1], s[6] = s[6] * t[2], s[7] = s[7] * t[2], s[8] = s[8] * t[2], this.center = new Ct().from(e), this.halfAxes = s, this;
  }
  /** Duplicates a OrientedBoundingBox instance. */
  clone() {
    return new Qg(this.center, this.halfAxes);
  }
  /** Compares the provided OrientedBoundingBox component wise and returns */
  equals(e) {
    return this === e || !!e && this.center.equals(e.center) && this.halfAxes.equals(e.halfAxes);
  }
  /** Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box. */
  getBoundingSphere() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new Jg();
    const t = this.halfAxes, n = t.getColumn(0, jm), i = t.getColumn(1, Vm), s = t.getColumn(2, $m), l = Oj.copy(n).add(i).add(s);
    return e.center.copy(this.center), e.radius = l.magnitude(), e;
  }
  /** Determines which side of a plane the oriented bounding box is located. */
  intersectPlane(e) {
    const t = this.center, n = e.normal, i = this.halfAxes, s = n.x, l = n.y, o = n.z, d = Math.abs(s * i[Hu.COLUMN0ROW0] + l * i[Hu.COLUMN0ROW1] + o * i[Hu.COLUMN0ROW2]) + Math.abs(s * i[Hu.COLUMN1ROW0] + l * i[Hu.COLUMN1ROW1] + o * i[Hu.COLUMN1ROW2]) + Math.abs(s * i[Hu.COLUMN2ROW0] + l * i[Hu.COLUMN2ROW1] + o * i[Hu.COLUMN2ROW2]), m = n.dot(t) + e.distance;
    return m <= -d ? pl.OUTSIDE : m >= d ? pl.INSIDE : pl.INTERSECTING;
  }
  /** Computes the estimated distance from the closest point on a bounding box to a point. */
  distanceTo(e) {
    return Math.sqrt(this.distanceSquaredTo(e));
  }
  /**
   * Computes the estimated distance squared from the closest point
   * on a bounding box to a point.
   * See Geometric Tools for Computer Graphics 10.4.2
   */
  distanceSquaredTo(e) {
    const t = kj.from(e).subtract(this.center), n = this.halfAxes, i = n.getColumn(0, jm), s = n.getColumn(1, Vm), l = n.getColumn(2, $m), o = i.magnitude(), d = s.magnitude(), m = l.magnitude();
    i.normalize(), s.normalize(), l.normalize();
    let b = 0, A;
    return A = Math.abs(t.dot(i)) - o, A > 0 && (b += A * A), A = Math.abs(t.dot(s)) - d, A > 0 && (b += A * A), A = Math.abs(t.dot(l)) - m, A > 0 && (b += A * A), b;
  }
  /**
   * The distances calculated by the vector from the center of the bounding box
   * to position projected onto direction.
   *
   * - If you imagine the infinite number of planes with normal direction,
   *   this computes the smallest distance to the closest and farthest planes
   *   from `position` that intersect the bounding box.
   *
   * @param position The position to calculate the distance from.
   * @param direction The direction from position.
   * @param result An Interval (array of length 2) to store the nearest and farthest distances.
   * @returns Interval (array of length 2) with nearest and farthest distances
   *   on the bounding box from position in direction.
   */
  // eslint-disable-next-line max-statements
  computePlaneDistances(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [-0, -0], i = Number.POSITIVE_INFINITY, s = Number.NEGATIVE_INFINITY;
    const l = this.center, o = this.halfAxes, d = o.getColumn(0, jm), m = o.getColumn(1, Vm), b = o.getColumn(2, $m), A = Nj.copy(d).add(m).add(b).add(l), M = Dj.copy(A).subtract(e);
    let E = t.dot(M);
    return i = Math.min(E, i), s = Math.max(E, s), A.copy(l).add(d).add(m).subtract(b), M.copy(A).subtract(e), E = t.dot(M), i = Math.min(E, i), s = Math.max(E, s), A.copy(l).add(d).subtract(m).add(b), M.copy(A).subtract(e), E = t.dot(M), i = Math.min(E, i), s = Math.max(E, s), A.copy(l).add(d).subtract(m).subtract(b), M.copy(A).subtract(e), E = t.dot(M), i = Math.min(E, i), s = Math.max(E, s), l.copy(A).subtract(d).add(m).add(b), M.copy(A).subtract(e), E = t.dot(M), i = Math.min(E, i), s = Math.max(E, s), l.copy(A).subtract(d).add(m).subtract(b), M.copy(A).subtract(e), E = t.dot(M), i = Math.min(E, i), s = Math.max(E, s), l.copy(A).subtract(d).subtract(m).add(b), M.copy(A).subtract(e), E = t.dot(M), i = Math.min(E, i), s = Math.max(E, s), l.copy(A).subtract(d).subtract(m).subtract(b), M.copy(A).subtract(e), E = t.dot(M), i = Math.min(E, i), s = Math.max(E, s), n[0] = i, n[1] = s, n;
  }
  /**
   * Applies a 4x4 affine transformation matrix to a bounding sphere.
   * @param transform The transformation matrix to apply to the bounding sphere.
   * @returns itself, i.e. the modified BoundingVolume.
   */
  transform(e) {
    this.center.transformAsPoint(e);
    const t = this.halfAxes.getColumn(0, jm);
    t.transformAsPoint(e);
    const n = this.halfAxes.getColumn(1, Vm);
    n.transformAsPoint(e);
    const i = this.halfAxes.getColumn(2, $m);
    return i.transformAsPoint(e), this.halfAxes = new ms([...t, ...n, ...i]), this;
  }
  getTransform() {
    throw new Error("not implemented");
  }
}
const R3 = new Ct(), B3 = new Ct();
class fu {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [0, 0, 1], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    this.normal = new Ct(), this.distance = -0, this.fromNormalDistance(e, t);
  }
  /** Creates a plane from a normal and a distance from the origin. */
  fromNormalDistance(e, t) {
    return Ac(Number.isFinite(t)), this.normal.from(e).normalize(), this.distance = t, this;
  }
  /** Creates a plane from a normal and a point on the plane. */
  fromPointNormal(e, t) {
    e = R3.from(e), this.normal.from(t).normalize();
    const n = -this.normal.dot(e);
    return this.distance = n, this;
  }
  /** Creates a plane from the general equation */
  fromCoefficients(e, t, n, i) {
    return this.normal.set(e, t, n), Ac(Mc(this.normal.len(), 1)), this.distance = i, this;
  }
  /** Duplicates a Plane instance. */
  clone() {
    return new fu(this.normal, this.distance);
  }
  /** Compares the provided Planes by normal and distance */
  equals(e) {
    return Mc(this.distance, e.distance) && Mc(this.normal, e.normal);
  }
  /** Computes the signed shortest distance of a point to a plane.
   * The sign of the distance determines which side of the plane the point is on.
   */
  getPointDistance(e) {
    return this.normal.dot(e) + this.distance;
  }
  /** Transforms the plane by the given transformation matrix. */
  transform(e) {
    const t = B3.copy(this.normal).transformAsVector(e).normalize(), n = this.normal.scale(-this.distance).transform(e);
    return this.fromPointNormal(n, t);
  }
  projectPointOntoPlane(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    const n = R3.from(e), i = this.getPointDistance(n), s = B3.copy(this.normal).scale(i);
    return n.subtract(s).to(t);
  }
}
const L3 = [new Ct([1, 0, 0]), new Ct([0, 1, 0]), new Ct([0, 0, 1])], O3 = new Ct(), Fj = new Ct();
class Ol {
  /**
   * Create a new `CullingVolume` bounded by an array of clipping planed
   * @param planes Array of clipping planes.
   * */
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    this.planes = e;
  }
  /**
   * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.
   * The planes are aligned to the x, y, and z axes in world coordinates.
   */
  fromBoundingSphere(e) {
    this.planes.length = 2 * L3.length;
    const t = e.center, n = e.radius;
    let i = 0;
    for (const s of L3) {
      let l = this.planes[i], o = this.planes[i + 1];
      l || (l = this.planes[i] = new fu()), o || (o = this.planes[i + 1] = new fu());
      const d = O3.copy(s).scale(-n).add(t);
      l.fromPointNormal(d, s);
      const m = O3.copy(s).scale(n).add(t), b = Fj.copy(s).negate();
      o.fromPointNormal(m, b), i += 2;
    }
    return this;
  }
  /** Determines whether a bounding volume intersects the culling volume. */
  computeVisibility(e) {
    let t = pl.INSIDE;
    for (const n of this.planes)
      switch (e.intersectPlane(n)) {
        case pl.OUTSIDE:
          return pl.OUTSIDE;
        case pl.INTERSECTING:
          t = pl.INTERSECTING;
          break;
      }
    return t;
  }
  /**
   * Determines whether a bounding volume intersects the culling volume.
   *
   * @param parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling
   *   volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then
   *   the parent (and therefore this) volume is completely inside plane[planeIndex]
   *   and that plane check can be skipped.
   */
  computeVisibilityWithPlaneMask(e, t) {
    if (Ac(Number.isFinite(t), "parentPlaneMask is required."), t === Ol.MASK_OUTSIDE || t === Ol.MASK_INSIDE)
      return t;
    let n = Ol.MASK_INSIDE;
    const i = this.planes;
    for (let s = 0; s < this.planes.length; ++s) {
      const l = s < 31 ? 1 << s : 0;
      if (s < 31 && (t & l) === 0)
        continue;
      const o = i[s], d = e.intersectPlane(o);
      if (d === pl.OUTSIDE)
        return Ol.MASK_OUTSIDE;
      d === pl.INTERSECTING && (n |= l);
    }
    return n;
  }
}
Ol.MASK_OUTSIDE = 4294967295;
Ol.MASK_INSIDE = 0;
Ol.MASK_INDETERMINATE = 2147483647;
new Ct();
new Ct();
new Ct();
new Ct();
new Ct();
new Ct();
new Ct();
new Ct();
new Ct();
new Ct();
new Ct();
new Ct();
new Ct();
new Ct();
new Ct();
new Ct();
new Ct();
const cu = new ms(), Uj = new ms(), zj = new ms(), qm = new ms(), k3 = new ms();
function jj(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = uD, n = 10;
  let i = 0, s = 0;
  const l = Uj, o = zj;
  l.identity(), o.copy(r);
  const d = t * Vj(o);
  for (; s < n && $j(o) > d; )
    qj(o, qm), k3.copy(qm).transpose(), o.multiplyRight(qm), o.multiplyLeft(k3), l.multiplyRight(qm), ++i > 2 && (++s, i = 0);
  return e.unitary = l.toTarget(e.unitary), e.diagonal = o.toTarget(e.diagonal), e;
}
function Vj(r) {
  let e = 0;
  for (let t = 0; t < 9; ++t) {
    const n = r[t];
    e += n * n;
  }
  return Math.sqrt(e);
}
const Tv = [1, 0, 0], Sv = [2, 2, 1];
function $j(r) {
  let e = 0;
  for (let t = 0; t < 3; ++t) {
    const n = r[cu.getElementIndex(Sv[t], Tv[t])];
    e += 2 * n * n;
  }
  return Math.sqrt(e);
}
function qj(r, e) {
  const t = g5;
  let n = 0, i = 1;
  for (let m = 0; m < 3; ++m) {
    const b = Math.abs(r[cu.getElementIndex(Sv[m], Tv[m])]);
    b > n && (i = m, n = b);
  }
  const s = Tv[i], l = Sv[i];
  let o = 1, d = 0;
  if (Math.abs(r[cu.getElementIndex(l, s)]) > t) {
    const m = r[cu.getElementIndex(l, l)], b = r[cu.getElementIndex(s, s)], A = r[cu.getElementIndex(l, s)], M = (m - b) / 2 / A;
    let E;
    M < 0 ? E = -1 / (-M + Math.sqrt(1 + M * M)) : E = 1 / (M + Math.sqrt(1 + M * M)), o = 1 / Math.sqrt(1 + E * E), d = E * o;
  }
  return ms.IDENTITY.to(e), e[cu.getElementIndex(s, s)] = e[cu.getElementIndex(l, l)] = o, e[cu.getElementIndex(l, s)] = d, e[cu.getElementIndex(s, l)] = -d, e;
}
const Rh = new Ct(), Gj = new Ct(), Hj = new Ct(), Wj = new Ct(), Xj = new Ct(), Zj = new ms(), Yj = {
  diagonal: new ms(),
  unitary: new ms()
};
function Kj(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Qg();
  if (!r || r.length === 0)
    return e.halfAxes = new ms([0, 0, 0, 0, 0, 0, 0, 0, 0]), e.center = new Ct(), e;
  const t = r.length, n = new Ct(0, 0, 0);
  for (const Be of r)
    n.add(Be);
  const i = 1 / t;
  n.multiplyByScalar(i);
  let s = 0, l = 0, o = 0, d = 0, m = 0, b = 0;
  for (const Be of r) {
    const ke = Rh.copy(Be).subtract(n);
    s += ke.x * ke.x, l += ke.x * ke.y, o += ke.x * ke.z, d += ke.y * ke.y, m += ke.y * ke.z, b += ke.z * ke.z;
  }
  s *= i, l *= i, o *= i, d *= i, m *= i, b *= i;
  const A = Zj;
  A[0] = s, A[1] = l, A[2] = o, A[3] = l, A[4] = d, A[5] = m, A[6] = o, A[7] = m, A[8] = b;
  const {
    unitary: M
  } = jj(A, Yj), E = e.halfAxes.copy(M);
  let k = E.getColumn(0, Hj), U = E.getColumn(1, Wj), V = E.getColumn(2, Xj), q = -Number.MAX_VALUE, Y = -Number.MAX_VALUE, re = -Number.MAX_VALUE, Z = Number.MAX_VALUE, K = Number.MAX_VALUE, ie = Number.MAX_VALUE;
  for (const Be of r)
    Rh.copy(Be), q = Math.max(Rh.dot(k), q), Y = Math.max(Rh.dot(U), Y), re = Math.max(Rh.dot(V), re), Z = Math.min(Rh.dot(k), Z), K = Math.min(Rh.dot(U), K), ie = Math.min(Rh.dot(V), ie);
  k = k.multiplyByScalar(0.5 * (Z + q)), U = U.multiplyByScalar(0.5 * (K + Y)), V = V.multiplyByScalar(0.5 * (ie + re)), e.center.copy(k).add(U).add(V);
  const be = Gj.set(q - Z, Y - K, re - ie).multiplyByScalar(0.5), he = new ms([be[0], 0, 0, 0, be[1], 0, 0, 0, be[2]]);
  return e.halfAxes.multiplyRight(he), e;
}
const Db = Math.PI / 180, Gm = new Float32Array(16), N3 = new Float32Array(12);
function D3(r, e, t) {
  const n = e[0] * Db, i = e[1] * Db, s = e[2] * Db, l = Math.sin(s), o = Math.sin(n), d = Math.sin(i), m = Math.cos(s), b = Math.cos(n), A = Math.cos(i), M = t[0], E = t[1], k = t[2];
  r[0] = M * A * b, r[1] = M * d * b, r[2] = M * -o, r[3] = E * (-d * m + A * o * l), r[4] = E * (A * m + d * o * l), r[5] = E * b * l, r[6] = k * (d * l + A * o * m), r[7] = k * (-A * l + d * o * m), r[8] = k * b * m;
}
function F3(r) {
  return r[0] = r[0], r[1] = r[1], r[2] = r[2], r[3] = r[4], r[4] = r[5], r[5] = r[6], r[6] = r[8], r[7] = r[9], r[8] = r[10], r[9] = r[12], r[10] = r[13], r[11] = r[14], r.subarray(0, 12);
}
const LI = {
  size: 12,
  accessor: ["getOrientation", "getScale", "getTranslation", "getTransformMatrix"],
  shaderAttributes: {
    instanceModelMatrixCol0: {
      size: 3,
      elementOffset: 0
    },
    instanceModelMatrixCol1: {
      size: 3,
      elementOffset: 3
    },
    instanceModelMatrixCol2: {
      size: 3,
      elementOffset: 6
    },
    instanceTranslation: {
      size: 3,
      elementOffset: 9
    }
  },
  update(r, e) {
    let {
      startRow: t,
      endRow: n
    } = e;
    const {
      data: i,
      getOrientation: s,
      getScale: l,
      getTranslation: o,
      getTransformMatrix: d
    } = this.props, m = Array.isArray(d), b = m && d.length === 16, A = Array.isArray(l), M = Array.isArray(s), E = Array.isArray(o), k = b || !m && !!d(i[0]);
    k ? r.constant = b : r.constant = M && A && E;
    const U = r.value;
    if (r.constant) {
      let V;
      k ? (Gm.set(d), V = F3(Gm)) : (V = N3, D3(V, s, l), V.set(o, 9)), r.value = new Float32Array(V);
    } else {
      let V = t * r.size;
      const {
        iterable: q,
        objectInfo: Y
      } = fI(i, t, n);
      for (const re of q) {
        Y.index++;
        let Z;
        if (k)
          Gm.set(b ? d : d(re, Y)), Z = F3(Gm);
        else {
          Z = N3;
          const K = M ? s : s(re, Y), ie = A ? l : l(re, Y);
          D3(Z, K, ie), Z.set(E ? o : o(re, Y), 9);
        }
        U[V++] = Z[0], U[V++] = Z[1], U[V++] = Z[2], U[V++] = Z[3], U[V++] = Z[4], U[V++] = Z[5], U[V++] = Z[6], U[V++] = Z[7], U[V++] = Z[8], U[V++] = Z[9], U[V++] = Z[10], U[V++] = Z[11];
      }
    }
  }
};
function OI(r, e) {
  return e === Ln.CARTESIAN || e === Ln.METER_OFFSETS || e === Ln.DEFAULT && !r.isGeospatial;
}
const U3 = `uniform simpleMeshUniforms {
  float sizeScale;
  bool composeModelMatrix;
  bool hasTexture;
  bool flatShading;
} simpleMesh;
`, Jj = {
  name: "simpleMesh",
  vs: U3,
  fs: U3,
  uniformTypes: {
    sizeScale: "f32",
    composeModelMatrix: "f32",
    hasTexture: "f32",
    flatShading: "f32"
  }
}, Qj = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
in vec3 instanceTranslation;
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = texCoords;
geometry.pickingColor = instancePickingColors;
vTexCoord = texCoords;
cameraPosition = project.cameraPosition;
vColor = vec4(colors * instanceColors.rgb, instanceColors.a);
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vec3 pos = (instanceModelMatrix * positions) * simpleMesh.sizeScale + instanceTranslation;
if (simpleMesh.composeModelMatrix) {
DECKGL_FILTER_SIZE(pos, geometry);
normals_commonspace = project_normal(instanceModelMatrix * normals);
geometry.worldPosition += pos;
gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);
geometry.position = position_commonspace;
}
else {
pos = project_size(pos);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);
geometry.position = position_commonspace;
normals_commonspace = project_normal(instanceModelMatrix * normals);
}
geometry.normal = normals_commonspace;
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, eV = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs
precision highp float;
uniform sampler2D sampler;
in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
geometry.uv = vTexCoord;
vec3 normal;
if (simpleMesh.flatShading) {
normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
} else {
normal = normals_commonspace;
}
vec4 color = simpleMesh.hasTexture ? texture(sampler, vTexCoord) : vColor;
DECKGL_FILTER_COLOR(color, geometry);
vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
fragColor = vec4(lightColor, color.a * layer.opacity);
}
`;
function Fb(r) {
  const e = r.positions || r.POSITION;
  Gn.assert(e, 'no "postions" or "POSITION" attribute in mesh');
  const t = e.value.length / e.size;
  let n = r.COLOR_0 || r.colors;
  n || (n = {
    size: 3,
    value: new Float32Array(t * 3).fill(1)
  });
  let i = r.NORMAL || r.normals;
  i || (i = {
    size: 3,
    value: new Float32Array(t * 3).fill(0)
  });
  let s = r.TEXCOORD_0 || r.texCoords;
  return s || (s = {
    size: 2,
    value: new Float32Array(t * 2).fill(0)
  }), {
    positions: e,
    colors: n,
    normals: i,
    texCoords: s
  };
}
function z3(r) {
  return r instanceof Xd ? (r.attributes = Fb(r.attributes), r) : r.attributes ? new Xd({
    ...r,
    topology: "triangle-list",
    attributes: Fb(r.attributes)
  }) : new Xd({
    topology: "triangle-list",
    attributes: Fb(r)
  });
}
const tV = [0, 0, 0, 255], rV = {
  mesh: {
    type: "object",
    value: null,
    async: !0
  },
  texture: {
    type: "image",
    value: null,
    async: !0
  },
  sizeScale: {
    type: "number",
    value: 1,
    min: 0
  },
  // _instanced is a hack to use world position instead of meter offsets in mesh
  // TODO - formalize API
  _instanced: !0,
  // NOTE(Tarek): Quick and dirty wireframe. Just draws
  // the same mesh with LINE_STRIPS. Won't follow edges
  // of the original mesh.
  wireframe: !1,
  // Optional material for 'lighting' shader module
  material: !0,
  getPosition: {
    type: "accessor",
    value: (r) => r.position
  },
  getColor: {
    type: "accessor",
    value: tV
  },
  // yaw, pitch and roll are in degrees
  // https://en.wikipedia.org/wiki/Euler_angles
  // [pitch, yaw, roll]
  getOrientation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  getScale: {
    type: "accessor",
    value: [1, 1, 1]
  },
  getTranslation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  // 4x4 matrix
  getTransformMatrix: {
    type: "accessor",
    value: []
  },
  textureParameters: {
    type: "object",
    ignore: !0,
    value: null
  }
};
class nx extends vp {
  getShaders() {
    return super.getShaders({
      vs: Qj,
      fs: eV,
      modules: [z2, w5, q2, Jj]
    });
  }
  getBounds() {
    var n;
    if (this.props._instanced)
      return super.getBounds();
    let e = this.state.positionBounds;
    if (e)
      return e;
    const {
      mesh: t
    } = this.props;
    if (!t)
      return null;
    if (e = (n = t.header) == null ? void 0 : n.boundingBox, !e) {
      const {
        attributes: i
      } = z3(t);
      i.POSITION = i.POSITION || i.positions, e = oC(i);
    }
    return this.state.positionBounds = e, e;
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        transition: !0,
        type: "float64",
        fp64: this.use64bitPositions(),
        size: 3,
        accessor: "getPosition"
      },
      instanceColors: {
        type: "unorm8",
        transition: !0,
        size: this.props.colorFormat.length,
        accessor: "getColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceModelMatrix: LI
    }), this.setState({
      // Avoid luma.gl's missing uniform warning
      // TODO - add feature to luma.gl to specify ignored uniforms?
      emptyTexture: this.context.device.createTexture({
        data: new Uint8Array(4),
        width: 1,
        height: 1
      })
    });
  }
  updateState(e) {
    var s;
    super.updateState(e);
    const {
      props: t,
      oldProps: n,
      changeFlags: i
    } = e;
    if (t.mesh !== n.mesh || i.extensionsChanged) {
      if (this.state.positionBounds = null, (s = this.state.model) == null || s.destroy(), t.mesh) {
        this.state.model = this.getModel(t.mesh);
        const l = t.mesh.attributes || t.mesh;
        this.setState({
          hasNormals: !!(l.NORMAL || l.normals)
        });
      }
      this.getAttributeManager().invalidateAll();
    }
    t.texture !== n.texture && t.texture instanceof ts && this.setTexture(t.texture), this.state.model && this.state.model.setTopology(this.props.wireframe ? "line-strip" : "triangle-list");
  }
  finalizeState(e) {
    super.finalizeState(e), this.state.emptyTexture.delete();
  }
  draw(e) {
    let {
      uniforms: t
    } = e;
    const {
      model: n
    } = this.state;
    if (!n)
      return;
    const {
      viewport: i,
      renderPass: s
    } = this.context, {
      sizeScale: l,
      coordinateSystem: o,
      _instanced: d
    } = this.props, m = {
      sizeScale: l,
      composeModelMatrix: !d || OI(i, o),
      flatShading: !this.state.hasNormals
    };
    n.shaderInputs.setProps({
      simpleMesh: m
    }), n.draw(s);
  }
  get isLoaded() {
    var e;
    return !!((e = this.state) != null && e.model && super.isLoaded);
  }
  getModel(e) {
    const t = new Xh(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: z3(e),
      isInstanced: !0
    }), {
      texture: n
    } = this.props, {
      emptyTexture: i
    } = this.state, s = {
      sampler: n || i,
      hasTexture: !!n
    };
    return t.shaderInputs.setProps({
      simpleMesh: s
    }), t;
  }
  setTexture(e) {
    const {
      emptyTexture: t,
      model: n
    } = this.state;
    if (n) {
      const i = {
        sampler: e || t,
        hasTexture: !!e
      };
      n.shaderInputs.setProps({
        simpleMesh: i
      });
    }
  }
}
nx.defaultProps = rV;
nx.layerName = "SimpleMeshLayer";
var Tc;
(function(r) {
  r[r.FUNC_ADD = 32774] = "FUNC_ADD", r[r.ONE = 1] = "ONE", r[r.SRC_ALPHA = 770] = "SRC_ALPHA", r[r.ONE_MINUS_SRC_ALPHA = 771] = "ONE_MINUS_SRC_ALPHA", r[r.TEXTURE_MIN_FILTER = 10241] = "TEXTURE_MIN_FILTER", r[r.LINEAR = 9729] = "LINEAR", r[r.LINEAR_MIPMAP_NEAREST = 9985] = "LINEAR_MIPMAP_NEAREST", r[r.UNPACK_FLIP_Y_WEBGL = 37440] = "UNPACK_FLIP_Y_WEBGL";
})(Tc || (Tc = {}));
function kI(r, e, t, n) {
  const i = {
    defines: {
      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)
      MANUAL_SRGB: 1,
      SRGB_FAST_APPROXIMATION: 1
    },
    bindings: {},
    uniforms: {
      // TODO: find better values?
      camera: [0, 0, 0],
      // Model should override
      metallicRoughnessValues: [1, 1]
      // Default is 1 and 1
    },
    parameters: {},
    glParameters: {},
    generatedTextures: []
  };
  i.defines.USE_TEX_LOD = 1;
  const {
    imageBasedLightingEnvironment: s
  } = n;
  return s && (i.bindings.pbr_diffuseEnvSampler = s.diffuseEnvSampler.texture, i.bindings.pbr_specularEnvSampler = s.specularEnvSampler.texture, i.bindings.pbr_BrdfLUT = s.brdfLutTexture.texture, i.uniforms.scaleIBLAmbient = [1, 1]), n != null && n.pbrDebug && (i.defines.PBR_DEBUG = 1, i.uniforms.scaleDiffBaseMR = [0, 0, 0, 0], i.uniforms.scaleFGDSpec = [0, 0, 0, 0]), t.NORMAL && (i.defines.HAS_NORMALS = 1), t.TANGENT && (n != null && n.useTangents) && (i.defines.HAS_TANGENTS = 1), t.TEXCOORD_0 && (i.defines.HAS_UV = 1), n != null && n.imageBasedLightingEnvironment && (i.defines.USE_IBL = 1), n != null && n.lights && (i.defines.USE_LIGHTS = 1), e && nV(r, e, i), i;
}
function nV(r, e, t) {
  if (t.uniforms.unlit = !!e.unlit, e.pbrMetallicRoughness && iV(r, e.pbrMetallicRoughness, t), e.normalTexture) {
    Sg(r, e.normalTexture, "pbr_normalSampler", "HAS_NORMALMAP", t);
    const {
      scale: n = 1
    } = e.normalTexture;
    t.uniforms.normalScale = n;
  }
  if (e.occlusionTexture) {
    Sg(r, e.occlusionTexture, "pbr_occlusionSampler", "HAS_OCCLUSIONMAP", t);
    const {
      strength: n = 1
    } = e.occlusionTexture;
    t.uniforms.occlusionStrength = n;
  }
  switch (e.emissiveTexture && (Sg(r, e.emissiveTexture, "pbr_emissiveSampler", "HAS_EMISSIVEMAP", t), t.uniforms.emissiveFactor = e.emissiveFactor || [0, 0, 0]), e.alphaMode) {
    case "MASK":
      const {
        alphaCutoff: n = 0.5
      } = e;
      t.defines.ALPHA_CUTOFF = 1, t.uniforms.alphaCutoff = n;
      break;
    case "BLEND":
      cr.warn("glTF BLEND alphaMode might not work well because it requires mesh sorting")(), t.parameters.blendColorOperation = "add", t.parameters.blendColorSrcFactor = "src-alpha", t.parameters.blendColorDstFactor = "one-minus-src-alpha", t.parameters.blendAlphaOperation = "add", t.parameters.blendAlphaSrcFactor = "one", t.parameters.blendAlphaDstFactor = "one-minus-src-alpha", t.glParameters.blend = !0, t.glParameters.blendEquation = Tc.FUNC_ADD, t.glParameters.blendFunc = [Tc.SRC_ALPHA, Tc.ONE_MINUS_SRC_ALPHA, Tc.ONE, Tc.ONE_MINUS_SRC_ALPHA];
      break;
  }
}
function iV(r, e, t) {
  e.baseColorTexture && Sg(r, e.baseColorTexture, "pbr_baseColorSampler", "HAS_BASECOLORMAP", t), t.uniforms.baseColorFactor = e.baseColorFactor || [1, 1, 1, 1], e.metallicRoughnessTexture && Sg(r, e.metallicRoughnessTexture, "pbr_metallicRoughnessSampler", "HAS_METALROUGHNESSMAP", t);
  const {
    metallicFactor: n = 1,
    roughnessFactor: i = 1
  } = e;
  t.uniforms.metallicRoughnessValues = [n, i];
}
function Sg(r, e, t) {
  var b, A;
  let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, i = arguments.length > 4 ? arguments[4] : void 0;
  const s = ((A = (b = e == null ? void 0 : e.texture) == null ? void 0 : b.sampler) == null ? void 0 : A.parameters) || {}, l = e.texture.source.image;
  let o, d = {};
  l.compressed ? (o = l, d = {
    [Tc.TEXTURE_MIN_FILTER]: l.data.length > 1 ? Tc.LINEAR_MIPMAP_NEAREST : Tc.LINEAR
  }) : o = {
    data: l
  };
  const m = r.createTexture({
    id: e.uniformName || e.id,
    parameters: {
      ...s,
      ...d
    },
    pixelStore: {
      [Tc.UNPACK_FLIP_Y_WEBGL]: !1
    },
    ...o
  });
  i.bindings[t] = m, n && (i.defines[n] = 1), i.generatedTextures.push(m);
}
const sV = "4.3.2", ay = {
  /** Basis transcoder, javascript wrapper part */
  TRANSCODER: "basis_transcoder.js",
  /** Basis transcoder, compiled web assembly part */
  TRANSCODER_WASM: "basis_transcoder.wasm",
  /** Basis encoder, javascript wrapper part */
  ENCODER: "basis_encoder.js",
  /** Basis encoder, compiled web assembly part */
  ENCODER_WASM: "basis_encoder.wasm"
};
let j3;
async function V3(r) {
  rB(r.modules);
  const e = nB("basis");
  return e || (j3 || (j3 = oV(r)), await j3);
}
async function oV(r) {
  let e = null, t = null;
  return [e, t] = await Promise.all([await kf(ay.TRANSCODER, "textures", r), await kf(ay.TRANSCODER_WASM, "textures", r)]), e = e || globalThis.BASIS, await aV(e, t);
}
function aV(r, e) {
  const t = {};
  return e && (t.wasmBinary = e), new Promise((n) => {
    r(t).then((i) => {
      const {
        BasisFile: s,
        initializeBasis: l
      } = i;
      l(), n({
        BasisFile: s
      });
    });
  });
}
let Ub;
async function $3(r) {
  const e = r.modules || {};
  return e.basisEncoder ? e.basisEncoder : (Ub = Ub || lV(r), await Ub);
}
async function lV(r) {
  let e = null, t = null;
  return [e, t] = await Promise.all([await kf(ay.ENCODER, "textures", r), await kf(ay.ENCODER_WASM, "textures", r)]), e = e || globalThis.BASIS, await cV(e, t);
}
function cV(r, e) {
  const t = {};
  return e && (t.wasmBinary = e), new Promise((n) => {
    r(t).then((i) => {
      const {
        BasisFile: s,
        KTX2File: l,
        initializeBasis: o,
        BasisEncoder: d
      } = i;
      o(), n({
        BasisFile: s,
        KTX2File: l,
        BasisEncoder: d
      });
    });
  });
}
const Ed = {
  // WEBGL_compressed_texture_s3tc
  COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
  COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
  // WEBGL_compressed_texture_pvrtc
  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
  // WEBGL_compressed_texture_etc1
  COMPRESSED_RGB_ETC1_WEBGL: 36196,
  // WEBGL_compressed_texture_astc
  COMPRESSED_RGBA_ASTC_4X4_KHR: 37808
}, uV = ["", "WEBKIT_", "MOZ_"], q3 = {
  /* eslint-disable camelcase */
  WEBGL_compressed_texture_s3tc: "dxt",
  WEBGL_compressed_texture_s3tc_srgb: "dxt-srgb",
  WEBGL_compressed_texture_etc1: "etc1",
  WEBGL_compressed_texture_etc: "etc2",
  WEBGL_compressed_texture_pvrtc: "pvrtc",
  WEBGL_compressed_texture_atc: "atc",
  WEBGL_compressed_texture_astc: "astc",
  EXT_texture_compression_rgtc: "rgtc"
  /* eslint-enable camelcase */
};
let Hm = null;
function hV(r) {
  if (!Hm) {
    r = r || fV() || void 0, Hm = /* @__PURE__ */ new Set();
    for (const e of uV)
      for (const t in q3)
        if (r && r.getExtension(`${e}${t}`)) {
          const n = q3[t];
          Hm.add(n);
        }
  }
  return Hm;
}
function fV() {
  try {
    return document.createElement("canvas").getContext("webgl");
  } catch {
    return null;
  }
}
const hl = [
  // '´', 'K', 'T', 'X', '2', '0', 'ª', '\r', '\n', '\x1A', '\n'
  171,
  75,
  84,
  88,
  32,
  50,
  48,
  187,
  13,
  10,
  26,
  10
];
function dV(r) {
  const e = new Uint8Array(r);
  return !(e.byteLength < hl.length || e[0] !== hl[0] || // '´'
  e[1] !== hl[1] || // 'K'
  e[2] !== hl[2] || // 'T'
  e[3] !== hl[3] || // 'X'
  e[4] !== hl[4] || // ' '
  e[5] !== hl[5] || // '2'
  e[6] !== hl[6] || // '0'
  e[7] !== hl[7] || // 'ª'
  e[8] !== hl[8] || // '\r'
  e[9] !== hl[9] || // '\n'
  e[10] !== hl[10] || // '\x1A'
  e[11] !== hl[11]);
}
const pV = {
  etc1: {
    basisFormat: 0,
    compressed: !0,
    format: Ed.COMPRESSED_RGB_ETC1_WEBGL
  },
  etc2: {
    basisFormat: 1,
    compressed: !0
  },
  bc1: {
    basisFormat: 2,
    compressed: !0,
    format: Ed.COMPRESSED_RGB_S3TC_DXT1_EXT
  },
  bc3: {
    basisFormat: 3,
    compressed: !0,
    format: Ed.COMPRESSED_RGBA_S3TC_DXT5_EXT
  },
  bc4: {
    basisFormat: 4,
    compressed: !0
  },
  bc5: {
    basisFormat: 5,
    compressed: !0
  },
  "bc7-m6-opaque-only": {
    basisFormat: 6,
    compressed: !0
  },
  "bc7-m5": {
    basisFormat: 7,
    compressed: !0
  },
  "pvrtc1-4-rgb": {
    basisFormat: 8,
    compressed: !0,
    format: Ed.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
  },
  "pvrtc1-4-rgba": {
    basisFormat: 9,
    compressed: !0,
    format: Ed.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
  },
  "astc-4x4": {
    basisFormat: 10,
    compressed: !0,
    format: Ed.COMPRESSED_RGBA_ASTC_4X4_KHR
  },
  "atc-rgb": {
    basisFormat: 11,
    compressed: !0
  },
  "atc-rgba-interpolated-alpha": {
    basisFormat: 12,
    compressed: !0
  },
  rgba32: {
    basisFormat: 13,
    compressed: !1
  },
  rgb565: {
    basisFormat: 14,
    compressed: !1
  },
  bgr565: {
    basisFormat: 15,
    compressed: !1
  },
  rgba4444: {
    basisFormat: 16,
    compressed: !1
  }
};
async function gV(r, e) {
  if (e.basis.containerFormat === "auto") {
    if (dV(r)) {
      const n = await $3(e);
      return G3(n.KTX2File, r, e);
    }
    const {
      BasisFile: t
    } = await V3(e);
    return zb(t, r, e);
  }
  switch (e.basis.module) {
    case "encoder":
      const t = await $3(e);
      switch (e.basis.containerFormat) {
        case "ktx2":
          return G3(t.KTX2File, r, e);
        case "basis":
        default:
          return zb(t.BasisFile, r, e);
      }
    case "transcoder":
    default:
      const {
        BasisFile: n
      } = await V3(e);
      return zb(n, r, e);
  }
}
function zb(r, e, t) {
  const n = new r(new Uint8Array(e));
  try {
    if (!n.startTranscoding())
      throw new Error("Failed to start basis transcoding");
    const i = n.getNumImages(), s = [];
    for (let l = 0; l < i; l++) {
      const o = n.getNumLevels(l), d = [];
      for (let m = 0; m < o; m++)
        d.push(mV(n, l, m, t));
      s.push(d);
    }
    return s;
  } finally {
    n.close(), n.delete();
  }
}
function mV(r, e, t, n) {
  const i = r.getImageWidth(e, t), s = r.getImageHeight(e, t), l = r.getHasAlpha(
    /* imageIndex, levelIndex */
  ), {
    compressed: o,
    format: d,
    basisFormat: m
  } = NI(n, l), b = r.getImageTranscodedSizeInBytes(e, t, m), A = new Uint8Array(b);
  if (!r.transcodeImage(A, e, t, m, 0, 0))
    throw new Error("failed to start Basis transcoding");
  return {
    // standard loaders.gl image category payload
    width: i,
    height: s,
    data: A,
    compressed: o,
    format: d,
    // Additional fields
    // Add levelSize field.
    hasAlpha: l
  };
}
function G3(r, e, t) {
  const n = new r(new Uint8Array(e));
  try {
    if (!n.startTranscoding())
      throw new Error("failed to start KTX2 transcoding");
    const i = n.getLevels(), s = [];
    for (let l = 0; l < i; l++)
      s.push(_V(n, l, t));
    return [s];
  } finally {
    n.close(), n.delete();
  }
}
function _V(r, e, t) {
  const {
    alphaFlag: n,
    height: i,
    width: s
  } = r.getImageLevelInfo(e, 0, 0), {
    compressed: l,
    format: o,
    basisFormat: d
  } = NI(t, n), m = r.getImageTranscodedSizeInBytes(e, 0, 0, d), b = new Uint8Array(m);
  if (!r.transcodeImage(
    b,
    e,
    0,
    0,
    d,
    0,
    -1,
    -1
    /* channel1 */
  ))
    throw new Error("Failed to transcode KTX2 image");
  return {
    // standard loaders.gl image category payload
    width: s,
    height: i,
    data: b,
    compressed: l,
    // Additional fields
    levelSize: m,
    hasAlpha: n,
    format: o
  };
}
function NI(r, e) {
  let t = r && r.basis && r.basis.format;
  return t === "auto" && (t = DI()), typeof t == "object" && (t = e ? t.alpha : t.noAlpha), t = t.toLowerCase(), pV[t];
}
function DI() {
  const r = hV();
  return r.has("astc") ? "astc-4x4" : r.has("dxt") ? {
    alpha: "bc3",
    noAlpha: "bc1"
  } : r.has("pvrtc") ? {
    alpha: "pvrtc1-4-rgba",
    noAlpha: "pvrtc1-4-rgb"
  } : r.has("etc1") ? "etc1" : r.has("etc2") ? "etc2" : "rgb565";
}
const yV = {
  dataType: null,
  batchType: null,
  name: "Basis",
  id: "basis",
  module: "textures",
  version: sV,
  worker: !0,
  extensions: ["basis", "ktx2"],
  mimeTypes: ["application/octet-stream", "image/ktx2"],
  tests: ["sB"],
  binary: !0,
  options: {
    basis: {
      format: "auto",
      libraryPath: "libs/",
      containerFormat: "auto",
      module: "transcoder"
    }
  }
}, bV = {
  ...yV,
  parse: gV
}, vV = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, xV = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
class wV {
  constructor(e) {
    H(this, "name");
    H(this, "startTime", 0);
    H(this, "playing", !0);
    H(this, "speed", 1);
    H(this, "channels", []);
    Object.assign(this, e);
  }
  animate(e) {
    if (!this.playing)
      return;
    const n = (e / 1e3 - this.startTime) * this.speed;
    this.channels.forEach((i) => {
      let {
        sampler: s,
        target: l,
        path: o
      } = i;
      MV(n, s, l, o), SV(l, l._node);
    });
  }
}
class AV {
  constructor(e) {
    H(this, "animations");
    this.animations = e.animations.map((t, n) => {
      const i = t.name || `Animation-${n}`, s = t.samplers.map((o) => {
        let {
          input: d,
          interpolation: m = "LINEAR",
          output: b
        } = o;
        return {
          input: H3(e.accessors[d]),
          interpolation: m,
          output: H3(e.accessors[b])
        };
      }), l = t.channels.map((o) => {
        let {
          sampler: d,
          target: m
        } = o;
        return {
          sampler: s[d],
          target: e.nodes[m.node],
          path: m.path
        };
      });
      return new wV({
        name: i,
        channels: l
      });
    });
  }
  /** @deprecated Use .setTime(). Will be removed (deck.gl is using this) */
  animate(e) {
    this.setTime(e);
  }
  setTime(e) {
    this.animations.forEach((t) => t.animate(e));
  }
  getAnimations() {
    return this.animations;
  }
}
function H3(r) {
  if (!r._animation) {
    const e = xV[r.componentType], t = vV[r.type], n = t * r.count, {
      buffer: i,
      byteOffset: s
    } = r.bufferView.data, l = new e(i, s + (r.byteOffset || 0), n);
    if (t === 1)
      r._animation = Array.from(l);
    else {
      const o = [];
      for (let d = 0; d < l.length; d += t)
        o.push(Array.from(l.slice(d, d + t)));
      r._animation = o;
    }
  }
  return r._animation;
}
const TV = new Bn();
function SV(r, e) {
  if (e.matrix.identity(), r.translation && e.matrix.translate(r.translation), r.rotation) {
    const t = TV.fromQuaternion(r.rotation);
    e.matrix.multiplyRight(t);
  }
  r.scale && e.matrix.scale(r.scale);
}
const jb = new Rg();
function EV(r, e, t, n, i) {
  if (e === "rotation") {
    jb.slerp({
      start: t,
      target: n,
      ratio: i
    });
    for (let s = 0; s < jb.length; s++)
      r[e][s] = jb[s];
  } else
    for (let s = 0; s < t.length; s++)
      r[e][s] = i * n[s] + (1 - i) * t[s];
}
function CV(r, e, t) {
  let {
    p0: n,
    outTangent0: i,
    inTangent1: s,
    p1: l,
    tDiff: o,
    ratio: d
  } = t;
  for (let m = 0; m < r[e].length; m++) {
    const b = i[m] * o, A = s[m] * o;
    r[e][m] = (2 * Math.pow(d, 3) - 3 * Math.pow(d, 2) + 1) * n[m] + (Math.pow(d, 3) - 2 * Math.pow(d, 2) + d) * b + (-2 * Math.pow(d, 3) + 3 * Math.pow(d, 2)) * l[m] + (Math.pow(d, 3) - Math.pow(d, 2)) * A;
  }
}
function IV(r, e, t) {
  for (let n = 0; n < t.length; n++)
    r[e][n] = t[n];
}
function MV(r, e, t, n) {
  let {
    input: i,
    interpolation: s,
    output: l
  } = e;
  const o = i[i.length - 1], d = r % o, m = i.findIndex((E) => E >= d), b = Math.max(0, m - 1);
  if (!Array.isArray(t[n]))
    switch (n) {
      case "translation":
        t[n] = [0, 0, 0];
        break;
      case "rotation":
        t[n] = [0, 0, 0, 1];
        break;
      case "scale":
        t[n] = [1, 1, 1];
        break;
      default:
        cr.warn(`Bad animation path ${n}`)();
    }
  const A = i[b], M = i[m];
  switch (s) {
    case "STEP":
      IV(t, n, l[b]);
      break;
    case "LINEAR":
      if (M > A) {
        const E = (d - A) / (M - A);
        EV(t, n, l[b], l[m], E);
      }
      break;
    case "CUBICSPLINE":
      if (M > A) {
        const E = (d - A) / (M - A), k = M - A, U = l[3 * b + 1], V = l[3 * b + 2], q = l[3 * m + 0], Y = l[3 * m + 1];
        CV(t, n, {
          p0: U,
          outTangent0: V,
          inTangent1: q,
          p1: Y,
          tDiff: k,
          ratio: E
        });
      }
      break;
    default:
      cr.warn(`Interpolation ${s} not supported`)();
      break;
  }
}
const PV = (
  /* WGSL */
  `
layout(0) positions: vec4; // in vec4 POSITION;

  #ifdef HAS_NORMALS
    in vec4 normals; // in vec4 NORMAL;
  #endif

  #ifdef HAS_TANGENTS
    in vec4 TANGENT;
  #endif

  #ifdef HAS_UV
    // in vec2 TEXCOORD_0;
    in vec2 texCoords;
  #endif

@vertex
  void main(void) {
    vec4 _NORMAL = vec4(0.);
    vec4 _TANGENT = vec4(0.);
    vec2 _TEXCOORD_0 = vec2(0.);

    #ifdef HAS_NORMALS
      _NORMAL = normals;
    #endif

    #ifdef HAS_TANGENTS
      _TANGENT = TANGENT;
    #endif

    #ifdef HAS_UV
      _TEXCOORD_0 = texCoords;
    #endif

    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);
    gl_Position = u_MVPMatrix * positions;
  }

@fragment
  out vec4 fragmentColor;

  void main(void) {
    vec3 pos = pbr_vPosition;
    fragmentColor = pbr_filterColor(vec4(1.0));
  }
`
), RV = (
  /* glsl */
  `#version 300 es

  // in vec4 POSITION;
  in vec4 positions;

  #ifdef HAS_NORMALS
    // in vec4 NORMAL;
    in vec4 normals;
  #endif

  #ifdef HAS_TANGENTS
    in vec4 TANGENT;
  #endif

  #ifdef HAS_UV
    // in vec2 TEXCOORD_0;
    in vec2 texCoords;
  #endif

  void main(void) {
    vec4 _NORMAL = vec4(0.);
    vec4 _TANGENT = vec4(0.);
    vec2 _TEXCOORD_0 = vec2(0.);

    #ifdef HAS_NORMALS
      _NORMAL = normals;
    #endif

    #ifdef HAS_TANGENTS
      _TANGENT = TANGENT;
    #endif

    #ifdef HAS_UV
      _TEXCOORD_0 = texCoords;
    #endif

    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);
    gl_Position = pbrProjection.modelViewProjectionMatrix * positions;
  }
`
), BV = (
  /* glsl */
  `#version 300 es
  out vec4 fragmentColor;

  void main(void) {
    vec3 pos = pbr_vPosition;
    fragmentColor = pbr_filterColor(vec4(1.0));
  }
`
);
function LV(r, e) {
  const {
    id: t,
    geometry: n,
    material: i,
    vertexCount: s,
    materialOptions: l,
    modelOptions: o
  } = e, d = kI(r, i, n.attributes, l);
  cr.info(4, "createGLTFModel defines: ", d.defines)();
  const m = [], b = {
    depthWriteEnabled: !0,
    depthCompare: "less",
    depthFormat: "depth24plus",
    cullMode: "back"
  }, A = {
    id: t,
    source: PV,
    vs: RV,
    fs: BV,
    geometry: n,
    topology: n.topology,
    vertexCount: s,
    modules: [F2],
    ...o,
    defines: {
      ...d.defines,
      ...o.defines
    },
    parameters: {
      ...b,
      ...d.parameters,
      ...o.parameters
    }
  }, M = new Xh(r, A), {
    camera: E,
    ...k
  } = {
    ...d.uniforms,
    ...o.uniforms,
    ...d.bindings,
    ...o.bindings
  };
  return M.shaderInputs.setProps({
    pbrMaterial: k,
    pbrProjection: {
      camera: E
    }
  }), new dv({
    managedResources: m,
    model: M
  });
}
var Sf;
(function(r) {
  r[r.POINTS = 0] = "POINTS", r[r.LINES = 1] = "LINES", r[r.LINE_LOOP = 2] = "LINE_LOOP", r[r.LINE_STRIP = 3] = "LINE_STRIP", r[r.TRIANGLES = 4] = "TRIANGLES", r[r.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", r[r.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
})(Sf || (Sf = {}));
function OV(r) {
  switch (r) {
    case Sf.POINTS:
      return "point-list";
    case Sf.LINES:
      return "line-list";
    case Sf.LINE_STRIP:
      return "line-strip";
    case Sf.TRIANGLES:
      return "triangle-list";
    case Sf.TRIANGLE_STRIP:
      return "triangle-strip";
    default:
      throw new Error(String(r));
  }
}
const kV = {
  modelOptions: {},
  pbrDebug: !1,
  imageBasedLightingEnvironment: null,
  lights: !0,
  useTangents: !1
};
class NV {
  constructor(e) {
    H(this, "device");
    H(this, "options");
    H(this, "gltf");
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.device = e, this.options = {
      ...kV,
      ...t
    };
  }
  instantiate(e) {
    return this.gltf = Ev(e), (this.gltf.scenes || []).map((n) => this.createScene(n));
  }
  createAnimator() {
    return Array.isArray(this.gltf.animations) ? new AV(this.gltf) : null;
  }
  createScene(e) {
    const n = (e.nodes || []).map((s) => this.createNode(s));
    return new Zd({
      id: e.name || e.id,
      children: n
    });
  }
  createNode(e) {
    if (!e._node) {
      const i = (e.children || []).map((l) => this.createNode(l));
      e.mesh && i.push(this.createMesh(e.mesh));
      const s = new Zd({
        id: e.name || e.id,
        children: i
      });
      if (e.matrix)
        s.setMatrix(e.matrix);
      else {
        if (s.matrix.identity(), e.translation && s.matrix.translate(e.translation), e.rotation) {
          const l = new Bn().fromQuaternion(e.rotation);
          s.matrix.multiplyRight(l);
        }
        e.scale && s.matrix.scale(e.scale);
      }
      e._node = s;
    }
    const t = this.gltf.nodes.find((n) => n.id === e.id);
    return t._node = e._node, e._node;
  }
  createMesh(e) {
    if (!e._mesh) {
      const n = (e.primitives || []).map((s, l) => this.createPrimitive(s, l, e)), i = new Zd({
        id: e.name || e.id,
        children: n
      });
      e._mesh = i;
    }
    return e._mesh;
  }
  createPrimitive(e, t, n) {
    const i = e.name || `${n.name || n.id}-primitive-${t}`, s = OV(e.mode || 4), l = e.indices ? e.indices.count : this.getVertexCount(e.attributes), o = LV(this.device, {
      id: i,
      geometry: this.createGeometry(i, e, s),
      material: e.material,
      materialOptions: this.options,
      modelOptions: this.options.modelOptions,
      vertexCount: l
    });
    return o.bounds = [e.attributes.POSITION.min, e.attributes.POSITION.max], o;
  }
  getVertexCount(e) {
    throw new Error("getVertexCount not implemented");
  }
  createGeometry(e, t, n) {
    const i = {};
    for (const [s, l] of Object.entries(t.attributes)) {
      const {
        components: o,
        size: d,
        value: m
      } = l;
      i[s] = {
        size: d ?? o,
        value: m
      };
    }
    return new Xd({
      id: e,
      topology: n,
      indices: t.indices.value,
      attributes: i
    });
  }
  createBuffer(e, t) {
    e.bufferView || (e.bufferView = {});
    const {
      bufferView: n
    } = e;
    return n.lumaBuffers || (n.lumaBuffers = {}), n.lumaBuffers[t] || (n.lumaBuffers[t] = this.device.createBuffer({
      id: `from-${n.id}`,
      // Draco decoded files have attribute.value
      data: n.data || e.value
    })), n.lumaBuffers[t];
  }
  // TODO - create sampler in WebGL2
  createSampler(e) {
    return e;
  }
  // Helper methods (move to GLTFLoader.resolve...?)
  needsPOT() {
    return !1;
  }
}
function Ev(r) {
  if (ArrayBuffer.isView(r) || r instanceof ArrayBuffer || r instanceof ImageBitmap)
    return r;
  if (Array.isArray(r))
    return r.map(Ev);
  if (r && typeof r == "object") {
    const e = {};
    for (const t in r)
      e[t] = Ev(r[t]);
    return e;
  }
  return r;
}
function DV(r, e, t) {
  const n = new NV(r, t), i = n.instantiate(e), s = n.createAnimator();
  return {
    scenes: i,
    animator: s
  };
}
function _l(r, e) {
  if (!r)
    throw new Error(e || "assert failed: gltf");
}
const FI = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, UI = {
  5120: 1,
  // BYTE
  5121: 1,
  // UNSIGNED_BYTE
  5122: 2,
  // SHORT
  5123: 2,
  // UNSIGNED_SHORT
  5125: 4,
  // UNSIGNED_INT
  5126: 4
  // FLOAT
}, FV = 1.33, W3 = ["SCALAR", "VEC2", "VEC3", "VEC4"], UV = [[Int8Array, 5120], [Uint8Array, 5121], [Int16Array, 5122], [Uint16Array, 5123], [Uint32Array, 5125], [Float32Array, 5126], [Float64Array, 5130]], zV = new Map(UV), jV = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, VV = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
}, $V = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
function zI(r) {
  return W3[r - 1] || W3[0];
}
function zy(r) {
  const e = zV.get(r.constructor);
  if (!e)
    throw new Error("Illegal typed array");
  return e;
}
function ix(r, e) {
  const t = $V[r.componentType], n = jV[r.type], i = VV[r.componentType], s = r.count * n, l = r.count * n * i;
  _l(l >= 0 && l <= e.byteLength);
  const o = UI[r.componentType], d = FI[r.type];
  return {
    ArrayType: t,
    length: s,
    byteLength: l,
    componentByteSize: o,
    numberOfComponentsInElement: d
  };
}
function jI(r) {
  let {
    images: e,
    bufferViews: t
  } = r;
  e = e || [], t = t || [];
  const n = e.map((l) => l.bufferView);
  t = t.filter((l) => !n.includes(l));
  const i = t.reduce((l, o) => l + o.byteLength, 0), s = e.reduce((l, o) => {
    const {
      width: d,
      height: m
    } = o.image;
    return l + d * m;
  }, 0);
  return i + Math.ceil(4 * s * FV);
}
function qV(r, e, t) {
  const n = r.bufferViews[t];
  _l(n);
  const i = n.buffer, s = e[i];
  _l(s);
  const l = (n.byteOffset || 0) + s.byteOffset;
  return new Uint8Array(s.arrayBuffer, l, n.byteLength);
}
function GV(r, e, t) {
  var U, V;
  const n = typeof t == "number" ? (U = r.accessors) == null ? void 0 : U[t] : t;
  if (!n)
    throw new Error(`No gltf accessor ${JSON.stringify(t)}`);
  const i = (V = r.bufferViews) == null ? void 0 : V[n.bufferView || 0];
  if (!i)
    throw new Error(`No gltf buffer view for accessor ${i}`);
  const {
    arrayBuffer: s,
    byteOffset: l
  } = e[i.buffer], o = (l || 0) + (n.byteOffset || 0) + (i.byteOffset || 0), {
    ArrayType: d,
    length: m,
    componentByteSize: b,
    numberOfComponentsInElement: A
  } = ix(n, i), M = b * A, E = i.byteStride || M;
  if (typeof i.byteStride > "u" || i.byteStride === M)
    return new d(s, o, m);
  const k = new d(m);
  for (let q = 0; q < n.count; q++) {
    const Y = new d(s, o + q * E, A);
    k.set(Y, q * A);
  }
  return k;
}
function HV() {
  return {
    asset: {
      version: "2.0",
      generator: "loaders.gl"
    },
    buffers: [],
    extensions: {},
    extensionsRequired: [],
    extensionsUsed: []
  };
}
class yo {
  // TODO - why is this not GLTFWithBuffers - what happens to images?
  constructor(e) {
    // internal
    H(this, "gltf");
    H(this, "sourceBuffers");
    H(this, "byteLength");
    this.gltf = {
      json: (e == null ? void 0 : e.json) || HV(),
      buffers: (e == null ? void 0 : e.buffers) || [],
      images: (e == null ? void 0 : e.images) || []
    }, this.sourceBuffers = [], this.byteLength = 0, this.gltf.buffers && this.gltf.buffers[0] && (this.byteLength = this.gltf.buffers[0].byteLength, this.sourceBuffers = [this.gltf.buffers[0]]);
  }
  // Accessors
  get json() {
    return this.gltf.json;
  }
  getApplicationData(e) {
    return this.json[e];
  }
  getExtraData(e) {
    return (this.json.extras || {})[e];
  }
  hasExtension(e) {
    const t = this.getUsedExtensions().find((i) => i === e), n = this.getRequiredExtensions().find((i) => i === e);
    return typeof t == "string" || typeof n == "string";
  }
  getExtension(e) {
    const t = this.getUsedExtensions().find((i) => i === e), n = this.json.extensions || {};
    return t ? n[e] : null;
  }
  getRequiredExtension(e) {
    return this.getRequiredExtensions().find((n) => n === e) ? this.getExtension(e) : null;
  }
  getRequiredExtensions() {
    return this.json.extensionsRequired || [];
  }
  getUsedExtensions() {
    return this.json.extensionsUsed || [];
  }
  getRemovedExtensions() {
    return this.json.extensionsRemoved || [];
  }
  getObjectExtension(e, t) {
    return (e.extensions || {})[t];
  }
  getScene(e) {
    return this.getObject("scenes", e);
  }
  getNode(e) {
    return this.getObject("nodes", e);
  }
  getSkin(e) {
    return this.getObject("skins", e);
  }
  getMesh(e) {
    return this.getObject("meshes", e);
  }
  getMaterial(e) {
    return this.getObject("materials", e);
  }
  getAccessor(e) {
    return this.getObject("accessors", e);
  }
  // getCamera(index: number): object | null {
  //   return null; // TODO: fix thi: object  as null;
  // }
  getTexture(e) {
    return this.getObject("textures", e);
  }
  getSampler(e) {
    return this.getObject("samplers", e);
  }
  getImage(e) {
    return this.getObject("images", e);
  }
  getBufferView(e) {
    return this.getObject("bufferViews", e);
  }
  getBuffer(e) {
    return this.getObject("buffers", e);
  }
  getObject(e, t) {
    if (typeof t == "object")
      return t;
    const n = this.json[e] && this.json[e][t];
    if (!n)
      throw new Error(`glTF file error: Could not find ${e}[${t}]`);
    return n;
  }
  /**
   * Accepts buffer view index or buffer view object
   * @returns a `Uint8Array`
   */
  getTypedArrayForBufferView(e) {
    e = this.getBufferView(e);
    const t = e.buffer, n = this.gltf.buffers[t];
    _l(n);
    const i = (e.byteOffset || 0) + n.byteOffset;
    return new Uint8Array(n.arrayBuffer, i, e.byteLength);
  }
  /** Accepts accessor index or accessor object
   * @returns a typed array with type that matches the types
   */
  getTypedArrayForAccessor(e) {
    const t = this.getAccessor(e);
    return GV(this.gltf.json, this.gltf.buffers, t);
  }
  /** accepts accessor index or accessor object
   * returns a `Uint8Array`
   */
  getTypedArrayForImageData(e) {
    e = this.getAccessor(e);
    const t = this.getBufferView(e.bufferView), i = this.getBuffer(t.buffer).data, s = t.byteOffset || 0;
    return new Uint8Array(i, s, t.byteLength);
  }
  // MODIFERS
  /**
   * Add an extra application-defined key to the top-level data structure
   */
  addApplicationData(e, t) {
    return this.json[e] = t, this;
  }
  /**
   * `extras` - Standard GLTF field for storing application specific data
   */
  addExtraData(e, t) {
    return this.json.extras = this.json.extras || {}, this.json.extras[e] = t, this;
  }
  addObjectExtension(e, t, n) {
    return e.extensions = e.extensions || {}, e.extensions[t] = n, this.registerUsedExtension(t), this;
  }
  setObjectExtension(e, t, n) {
    const i = e.extensions || {};
    i[t] = n;
  }
  removeObjectExtension(e, t) {
    const n = (e == null ? void 0 : e.extensions) || {};
    if (n[t]) {
      this.json.extensionsRemoved = this.json.extensionsRemoved || [];
      const i = this.json.extensionsRemoved;
      i.includes(t) || i.push(t);
    }
    delete n[t];
  }
  /**
   * Add to standard GLTF top level extension object, mark as used
   */
  addExtension(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return _l(t), this.json.extensions = this.json.extensions || {}, this.json.extensions[e] = t, this.registerUsedExtension(e), t;
  }
  /**
   * Standard GLTF top level extension object, mark as used and required
   */
  addRequiredExtension(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return _l(t), this.addExtension(e, t), this.registerRequiredExtension(e), t;
  }
  /**
   * Add extensionName to list of used extensions
   */
  registerUsedExtension(e) {
    this.json.extensionsUsed = this.json.extensionsUsed || [], this.json.extensionsUsed.find((t) => t === e) || this.json.extensionsUsed.push(e);
  }
  /**
   * Add extensionName to list of required extensions
   */
  registerRequiredExtension(e) {
    this.registerUsedExtension(e), this.json.extensionsRequired = this.json.extensionsRequired || [], this.json.extensionsRequired.find((t) => t === e) || this.json.extensionsRequired.push(e);
  }
  /**
   * Removes an extension from the top-level list
   */
  removeExtension(e) {
    var t;
    if ((t = this.json.extensions) != null && t[e]) {
      this.json.extensionsRemoved = this.json.extensionsRemoved || [];
      const n = this.json.extensionsRemoved;
      n.includes(e) || n.push(e);
    }
    this.json.extensions && delete this.json.extensions[e], this.json.extensionsRequired && this._removeStringFromArray(this.json.extensionsRequired, e), this.json.extensionsUsed && this._removeStringFromArray(this.json.extensionsUsed, e);
  }
  /**
   *  Set default scene which is to be displayed at load time
   */
  setDefaultScene(e) {
    this.json.scene = e;
  }
  /**
   * @todo: add more properties for scene initialization:
   *   name`, `extensions`, `extras`
   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-scene
   */
  addScene(e) {
    const {
      nodeIndices: t
    } = e;
    return this.json.scenes = this.json.scenes || [], this.json.scenes.push({
      nodes: t
    }), this.json.scenes.length - 1;
  }
  /**
   * @todo: add more properties for node initialization:
   *   `name`, `extensions`, `extras`, `camera`, `children`, `skin`, `rotation`, `scale`, `translation`, `weights`
   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#node
   */
  addNode(e) {
    const {
      meshIndex: t,
      matrix: n
    } = e;
    this.json.nodes = this.json.nodes || [];
    const i = {
      mesh: t
    };
    return n && (i.matrix = n), this.json.nodes.push(i), this.json.nodes.length - 1;
  }
  /** Adds a mesh to the json part */
  addMesh(e) {
    const {
      attributes: t,
      indices: n,
      material: i,
      mode: s = 4
    } = e, o = {
      primitives: [{
        attributes: this._addAttributes(t),
        mode: s
      }]
    };
    if (n) {
      const d = this._addIndices(n);
      o.primitives[0].indices = d;
    }
    return Number.isFinite(i) && (o.primitives[0].material = i), this.json.meshes = this.json.meshes || [], this.json.meshes.push(o), this.json.meshes.length - 1;
  }
  addPointCloud(e) {
    const n = {
      primitives: [{
        attributes: this._addAttributes(e),
        mode: 0
        // GL.POINTS
      }]
    };
    return this.json.meshes = this.json.meshes || [], this.json.meshes.push(n), this.json.meshes.length - 1;
  }
  /**
   * Adds a binary image. Builds glTF "JSON metadata" and saves buffer reference
   * Buffer will be copied into BIN chunk during "pack"
   * Currently encodes as glTF image
   * @param imageData
   * @param mimeType
   */
  addImage(e, t) {
    const n = m2(e), i = t || (n == null ? void 0 : n.mimeType), l = {
      bufferView: this.addBufferView(e),
      mimeType: i
    };
    return this.json.images = this.json.images || [], this.json.images.push(l), this.json.images.length - 1;
  }
  /**
   * Add one untyped source buffer, create a matching glTF `bufferView`, and return its index
   * @param buffer
   */
  addBufferView(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.byteLength;
    const i = e.byteLength;
    _l(Number.isFinite(i)), this.sourceBuffers = this.sourceBuffers || [], this.sourceBuffers.push(e);
    const s = {
      buffer: t,
      // Write offset from the start of the binary body
      byteOffset: n,
      byteLength: i
    };
    return this.byteLength += Wg(i, 4), this.json.bufferViews = this.json.bufferViews || [], this.json.bufferViews.push(s), this.json.bufferViews.length - 1;
  }
  /**
   * Adds an accessor to a bufferView
   * @param bufferViewIndex
   * @param accessor
   */
  addAccessor(e, t) {
    const n = {
      bufferView: e,
      // @ts-ignore
      type: zI(t.size),
      // @ts-ignore
      componentType: t.componentType,
      // @ts-ignore
      count: t.count,
      // @ts-ignore
      max: t.max,
      // @ts-ignore
      min: t.min
    };
    return this.json.accessors = this.json.accessors || [], this.json.accessors.push(n), this.json.accessors.length - 1;
  }
  /**
   * Add a binary buffer. Builds glTF "JSON metadata" and saves buffer reference
   * Buffer will be copied into BIN chunk during "pack"
   * Currently encodes buffers as glTF accessors, but this could be optimized
   * @param sourceBuffer
   * @param accessor
   */
  addBinaryBuffer(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      size: 3
    };
    const n = this.addBufferView(e);
    let i = {
      min: t.min,
      max: t.max
    };
    (!i.min || !i.max) && (i = this._getAccessorMinMax(e, t.size));
    const s = {
      // @ts-ignore
      size: t.size,
      componentType: zy(e),
      // @ts-ignore
      count: Math.round(e.length / t.size),
      min: i.min,
      max: i.max
    };
    return this.addAccessor(n, Object.assign(s, t));
  }
  /**
   * Adds a texture to the json part
   * @todo: add more properties for texture initialization
   * `sampler`, `name`, `extensions`, `extras`
   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture
   */
  addTexture(e) {
    const {
      imageIndex: t
    } = e, n = {
      source: t
    };
    return this.json.textures = this.json.textures || [], this.json.textures.push(n), this.json.textures.length - 1;
  }
  /** Adds a material to the json part */
  addMaterial(e) {
    return this.json.materials = this.json.materials || [], this.json.materials.push(e), this.json.materials.length - 1;
  }
  /** Pack the binary chunk */
  createBinaryChunk() {
    var s, l;
    const e = this.byteLength, t = new ArrayBuffer(e), n = new Uint8Array(t);
    let i = 0;
    for (const o of this.sourceBuffers || [])
      i = IB(o, n, i);
    (l = (s = this.json) == null ? void 0 : s.buffers) != null && l[0] ? this.json.buffers[0].byteLength = e : this.json.buffers = [{
      byteLength: e
    }], this.gltf.binary = t, this.sourceBuffers = [t], this.gltf.buffers = [{
      arrayBuffer: t,
      byteOffset: 0,
      byteLength: t.byteLength
    }];
  }
  // PRIVATE
  _removeStringFromArray(e, t) {
    let n = !0;
    for (; n; ) {
      const i = e.indexOf(t);
      i > -1 ? e.splice(i, 1) : n = !1;
    }
  }
  /**
   * Add attributes to buffers and create `attributes` object which is part of `mesh`
   */
  _addAttributes() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = {};
    for (const n in e) {
      const i = e[n], s = this._getGltfAttributeName(n), l = this.addBinaryBuffer(i.value, i);
      t[s] = l;
    }
    return t;
  }
  /**
   * Add indices to buffers
   */
  _addIndices(e) {
    return this.addBinaryBuffer(e, {
      size: 1
    });
  }
  /**
   * Deduce gltf specific attribue name from input attribute name
   */
  _getGltfAttributeName(e) {
    switch (e.toLowerCase()) {
      case "position":
      case "positions":
      case "vertices":
        return "POSITION";
      case "normal":
      case "normals":
        return "NORMAL";
      case "color":
      case "colors":
        return "COLOR_0";
      case "texcoord":
      case "texcoords":
        return "TEXCOORD_0";
      default:
        return e;
    }
  }
  /**
   * Calculate `min` and `max` arrays of accessor according to spec:
   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-accessor
   */
  _getAccessorMinMax(e, t) {
    const n = {
      min: null,
      max: null
    };
    if (e.length < t)
      return n;
    n.min = [], n.max = [];
    const i = e.subarray(0, t);
    for (const s of i)
      n.min.push(s), n.max.push(s);
    for (let s = t; s < e.length; s += t)
      for (let l = 0; l < t; l++)
        n.min[0 + l] = Math.min(
          // @ts-ignore
          n.min[0 + l],
          e[s + l]
        ), n.max[0 + l] = Math.max(
          // @ts-ignore
          n.max[0 + l],
          e[s + l]
        );
    return n;
  }
}
function X3(r) {
  return (r % 1 + 1) % 1;
}
const VI = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16,
  BOOLEAN: 1,
  STRING: 1,
  ENUM: 1
}, WV = {
  INT8: Int8Array,
  UINT8: Uint8Array,
  INT16: Int16Array,
  UINT16: Uint16Array,
  INT32: Int32Array,
  UINT32: Uint32Array,
  INT64: BigInt64Array,
  UINT64: BigUint64Array,
  FLOAT32: Float32Array,
  FLOAT64: Float64Array
}, $I = {
  INT8: 1,
  UINT8: 1,
  INT16: 2,
  UINT16: 2,
  INT32: 4,
  UINT32: 4,
  INT64: 8,
  UINT64: 8,
  FLOAT32: 4,
  FLOAT64: 8
};
function sx(r, e) {
  return $I[e] * VI[r];
}
function jy(r, e, t, n) {
  if (t !== "UINT8" && t !== "UINT16" && t !== "UINT32" && t !== "UINT64")
    return null;
  const i = r.getTypedArrayForBufferView(e), s = Vy(
    i,
    "SCALAR",
    // offsets consist of ONE component
    t,
    n + 1
    // The number of offsets is equal to the property table `count` plus one.
  );
  return s instanceof BigInt64Array || s instanceof BigUint64Array ? null : s;
}
function Vy(r, e, t) {
  let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  const i = VI[e], s = WV[t], l = $I[t], o = n * i, d = o * l;
  let m = r.buffer, b = r.byteOffset;
  return b % l !== 0 && (m = new Uint8Array(m).slice(b, b + d).buffer, b = 0), new s(m, b, o);
}
function ox(r, e, t) {
  var m, b, A, M, E;
  const n = `TEXCOORD_${e.texCoord || 0}`, i = t.attributes[n], s = r.getTypedArrayForAccessor(i), l = r.gltf.json, o = e.index, d = (b = (m = l.textures) == null ? void 0 : m[o]) == null ? void 0 : b.source;
  if (typeof d < "u") {
    const k = (M = (A = l.images) == null ? void 0 : A[d]) == null ? void 0 : M.mimeType, U = (E = r.gltf.images) == null ? void 0 : E[d];
    if (U && typeof U.width < "u") {
      const V = [];
      for (let q = 0; q < s.length; q += 2) {
        const Y = XV(U, k, s, q, e.channels);
        V.push(Y);
      }
      return V;
    }
  }
  return [];
}
function qI(r, e, t, n, i) {
  if (!(t != null && t.length))
    return;
  const s = [];
  for (const b of t) {
    let A = n.findIndex((M) => M === b);
    A === -1 && (A = n.push(b) - 1), s.push(A);
  }
  const l = new Uint32Array(s), o = r.gltf.buffers.push({
    arrayBuffer: l.buffer,
    byteOffset: l.byteOffset,
    byteLength: l.byteLength
  }) - 1, d = r.addBufferView(l, o, 0), m = r.addAccessor(d, {
    size: 1,
    componentType: zy(l),
    count: l.length
  });
  i.attributes[e] = m;
}
function XV(r, e, t, n) {
  let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [0];
  const s = {
    r: {
      offset: 0,
      shift: 0
    },
    g: {
      offset: 1,
      shift: 8
    },
    b: {
      offset: 2,
      shift: 16
    },
    a: {
      offset: 3,
      shift: 24
    }
  }, l = t[n], o = t[n + 1];
  let d = 1;
  e && (e.indexOf("image/jpeg") !== -1 || e.indexOf("image/png") !== -1) && (d = 4);
  const m = ZV(l, o, r, d);
  let b = 0;
  for (const A of i) {
    const M = typeof A == "number" ? Object.values(s)[A] : s[A], E = m + M.offset, k = aC(r);
    if (k.data.length <= E)
      throw new Error(`${k.data.length} <= ${E}`);
    const U = k.data[E];
    b |= U << M.shift;
  }
  return b;
}
function ZV(r, e, t) {
  let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  const i = t.width, s = X3(r) * (i - 1), l = Math.round(s), o = t.height, d = X3(e) * (o - 1), m = Math.round(d), b = t.components ? t.components : n;
  return (m * i + l) * b;
}
function GI(r, e, t, n, i) {
  const s = [];
  for (let l = 0; l < e; l++) {
    const o = t[l], d = t[l + 1] - t[l];
    if (d + o > n)
      break;
    const m = o / i, b = d / i;
    s.push(r.slice(m, m + b));
  }
  return s;
}
function HI(r, e, t) {
  const n = [];
  for (let i = 0; i < e; i++) {
    const s = i * t;
    n.push(r.slice(s, s + t));
  }
  return n;
}
function WI(r, e, t, n) {
  if (t)
    throw new Error("Not implemented - arrayOffsets for strings is specified");
  if (n) {
    const i = [], s = new TextDecoder("utf8");
    let l = 0;
    for (let o = 0; o < r; o++) {
      const d = n[o + 1] - n[o];
      if (d + l <= e.length) {
        const m = e.subarray(l, d + l), b = s.decode(m);
        i.push(b), l += d;
      }
    }
    return i;
  }
  return [];
}
const Kd = "EXT_mesh_features", YV = Kd;
async function KV(r, e) {
  const t = new yo(r);
  QV(t, e);
}
function JV(r, e) {
  const t = new yo(r);
  return t$(t), t.createBinaryChunk(), t.gltf;
}
function QV(r, e) {
  const t = r.gltf.json;
  if (t.meshes)
    for (const n of t.meshes)
      for (const i of n.primitives)
        e$(r, i, e);
}
function e$(r, e, t) {
  var s, l, o;
  if (!((s = t == null ? void 0 : t.gltf) != null && s.loadBuffers))
    return;
  const n = (l = e.extensions) == null ? void 0 : l[Kd], i = n == null ? void 0 : n.featureIds;
  if (i)
    for (const d of i) {
      let m;
      if (typeof d.attribute < "u") {
        const b = `_FEATURE_ID_${d.attribute}`, A = e.attributes[b];
        m = r.getTypedArrayForAccessor(A);
      } else typeof d.texture < "u" && ((o = t == null ? void 0 : t.gltf) != null && o.loadImages) ? m = ox(r, d.texture, e) : m = [];
      d.data = m;
    }
}
function t$(r, e) {
  const t = r.gltf.json.meshes;
  if (t)
    for (const n of t)
      for (const i of n.primitives)
        n$(r, i);
}
function r$(r, e, t, n) {
  e.extensions || (e.extensions = {});
  let i = e.extensions[Kd];
  i || (i = {
    featureIds: []
  }, e.extensions[Kd] = i);
  const {
    featureIds: s
  } = i, l = {
    featureCount: t.length,
    propertyTable: n,
    data: t
  };
  s.push(l), r.addObjectExtension(e, Kd, i);
}
function n$(r, e) {
  var i;
  const t = (i = e.extensions) == null ? void 0 : i[Kd];
  if (!t)
    return;
  const n = t.featureIds;
  n.forEach((s, l) => {
    if (s.data) {
      const {
        accessorKey: o,
        index: d
      } = i$(e.attributes), m = new Uint32Array(s.data);
      n[l] = {
        featureCount: m.length,
        propertyTable: s.propertyTable,
        attribute: d
      }, r.gltf.buffers.push({
        arrayBuffer: m.buffer,
        byteOffset: m.byteOffset,
        byteLength: m.byteLength
      });
      const b = r.addBufferView(m), A = r.addAccessor(b, {
        size: 1,
        componentType: zy(m),
        count: m.length
      });
      e.attributes[o] = A;
    }
  });
}
function i$(r) {
  const e = "_FEATURE_ID_", t = Object.keys(r).filter((s) => s.indexOf(e) === 0);
  let n = -1;
  for (const s of t) {
    const l = Number(s.substring(e.length));
    l > n && (n = l);
  }
  return n++, {
    accessorKey: `${e}${n}`,
    index: n
  };
}
const s$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createExtMeshFeatures: r$,
  decode: KV,
  encode: JV,
  name: YV
}, Symbol.toStringTag, { value: "Module" })), cp = "EXT_structural_metadata", o$ = cp;
async function a$(r, e) {
  const t = new yo(r);
  c$(t, e);
}
function l$(r, e) {
  const t = new yo(r);
  return S$(t), t.createBinaryChunk(), t.gltf;
}
function c$(r, e) {
  var n, i;
  if (!((n = e.gltf) != null && n.loadBuffers))
    return;
  const t = r.getExtension(cp);
  t && ((i = e.gltf) != null && i.loadImages && u$(r, t), h$(r, t));
}
function u$(r, e) {
  const t = e.propertyTextures, n = r.gltf.json;
  if (t && n.meshes)
    for (const i of n.meshes)
      for (const s of i.primitives)
        d$(r, t, s, e);
}
function h$(r, e) {
  const t = e.schema;
  if (!t)
    return;
  const n = t.classes, i = e.propertyTables;
  if (n && i)
    for (const s in n) {
      const l = f$(i, s);
      l && g$(r, t, l);
    }
}
function f$(r, e) {
  for (const t of r)
    if (t.class === e)
      return t;
  return null;
}
function d$(r, e, t, n) {
  var l;
  if (!e)
    return;
  const i = (l = t.extensions) == null ? void 0 : l[cp], s = i == null ? void 0 : i.propertyTextures;
  if (s)
    for (const o of s) {
      const d = e[o];
      p$(r, d, t, n);
    }
}
function p$(r, e, t, n) {
  var s;
  if (!e.properties)
    return;
  n.dataAttributeNames || (n.dataAttributeNames = []);
  const i = e.class;
  for (const l in e.properties) {
    const o = `${i}_${l}`, d = (s = e.properties) == null ? void 0 : s[l];
    if (!d)
      continue;
    d.data || (d.data = []);
    const m = d.data, b = ox(r, d, t);
    b !== null && (qI(r, o, b, m, t), d.data = m, n.dataAttributeNames.push(o));
  }
}
function g$(r, e, t) {
  var s, l;
  const n = (s = e.classes) == null ? void 0 : s[t.class];
  if (!n)
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${t.class}`);
  const i = t.count;
  for (const o in n.properties) {
    const d = n.properties[o], m = (l = t.properties) == null ? void 0 : l[o];
    if (m) {
      const b = m$(r, e, d, i, m);
      m.data = b;
    }
  }
}
function m$(r, e, t, n, i) {
  let s = [];
  const l = i.values, o = r.getTypedArrayForBufferView(l), d = _$(r, t, i, n), m = y$(r, i, n);
  switch (t.type) {
    case "SCALAR":
    case "VEC2":
    case "VEC3":
    case "VEC4":
    case "MAT2":
    case "MAT3":
    case "MAT4": {
      s = b$(t, n, o, d);
      break;
    }
    case "BOOLEAN":
      throw new Error(`Not implemented - classProperty.type=${t.type}`);
    case "STRING": {
      s = WI(n, o, d, m);
      break;
    }
    case "ENUM": {
      s = v$(e, t, n, o, d);
      break;
    }
    default:
      throw new Error(`Unknown classProperty type ${t.type}`);
  }
  return s;
}
function _$(r, e, t, n) {
  return e.array && // `count` is a number of array elements. May only be defined when `array` is true.
  // If `count` is NOT defined, it's a VARIABLE-length array
  typeof e.count > "u" && // `arrayOffsets` is an index of the buffer view containing offsets for variable-length arrays.
  typeof t.arrayOffsets < "u" ? jy(r, t.arrayOffsets, t.arrayOffsetType || "UINT32", n) : null;
}
function y$(r, e, t) {
  return typeof e.stringOffsets < "u" ? jy(r, e.stringOffsets, e.stringOffsetType || "UINT32", t) : null;
}
function b$(r, e, t, n) {
  const i = r.array, s = r.count, l = sx(r.type, r.componentType), o = t.byteLength / l;
  let d;
  return r.componentType ? d = Vy(
    t,
    r.type,
    // The datatype of the element's components. Only applicable to `SCALAR`, `VECN`, and `MATN` types.
    r.componentType,
    o
  ) : d = t, i ? n ? GI(d, e, n, t.length, l) : s ? HI(d, e, s) : [] : d;
}
function v$(r, e, t, n, i) {
  var A;
  const s = e.enumType;
  if (!s)
    throw new Error("Incorrect data in the EXT_structural_metadata extension: classProperty.enumType is not set for type ENUM");
  const l = (A = r.enums) == null ? void 0 : A[s];
  if (!l)
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: schema.enums does't contain ${s}`);
  const o = l.valueType || "UINT16", d = sx(e.type, o), m = n.byteLength / d;
  let b = Vy(n, e.type, o, m);
  if (b || (b = n), e.array) {
    if (i)
      return x$({
        valuesData: b,
        numberOfElements: t,
        arrayOffsets: i,
        valuesDataBytesLength: n.length,
        elementSize: d,
        enumEntry: l
      });
    const M = e.count;
    return M ? w$(b, t, M, l) : [];
  }
  return ax(b, 0, t, l);
}
function x$(r) {
  const {
    valuesData: e,
    numberOfElements: t,
    arrayOffsets: n,
    valuesDataBytesLength: i,
    elementSize: s,
    enumEntry: l
  } = r, o = [];
  for (let d = 0; d < t; d++) {
    const m = n[d], b = n[d + 1] - n[d];
    if (b + m > i)
      break;
    const A = m / s, M = b / s, E = ax(e, A, M, l);
    o.push(E);
  }
  return o;
}
function w$(r, e, t, n) {
  const i = [];
  for (let s = 0; s < e; s++) {
    const l = t * s, o = ax(r, l, t, n);
    i.push(o);
  }
  return i;
}
function ax(r, e, t, n) {
  const i = [];
  for (let s = 0; s < t; s++)
    if (r instanceof BigInt64Array || r instanceof BigUint64Array)
      i.push("");
    else {
      const l = r[e + s], o = A$(n, l);
      o ? i.push(o.name) : i.push("");
    }
  return i;
}
function A$(r, e) {
  for (const t of r.values)
    if (t.value === e)
      return t;
  return null;
}
const T$ = "schemaClassId";
function S$(r, e) {
  var n, i;
  const t = r.getExtension(cp);
  if (t && t.propertyTables)
    for (const s of t.propertyTables) {
      const l = s.class, o = (i = (n = t.schema) == null ? void 0 : n.classes) == null ? void 0 : i[l];
      s.properties && o && E$(s, o, r);
    }
}
function E$(r, e, t) {
  for (const n in r.properties) {
    const i = r.properties[n].data;
    if (i) {
      const s = e.properties[n];
      if (s) {
        const l = P$(i, s, t);
        r.properties[n] = l;
      }
    }
  }
}
function C$(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : T$, n = r.getExtension(cp);
  n || (n = r.addExtension(cp)), n.schema = I$(e, t, n.schema);
  const i = M$(e, t, n.schema);
  return n.propertyTables || (n.propertyTables = []), n.propertyTables.push(i) - 1;
}
function I$(r, e, t) {
  const n = t ?? {
    id: "schema_id"
  }, i = {
    properties: {}
  };
  for (const s of r) {
    const l = {
      type: s.elementType,
      componentType: s.componentType
    };
    i.properties[s.name] = l;
  }
  return n.classes = {}, n.classes[e] = i, n;
}
function M$(r, e, t) {
  var l;
  const n = {
    class: e,
    count: 0
  };
  let i = 0;
  const s = (l = t.classes) == null ? void 0 : l[e];
  for (const o of r) {
    if (i === 0 && (i = o.values.length), i !== o.values.length && o.values.length)
      throw new Error("Illegal values in attributes");
    (s == null ? void 0 : s.properties[o.name]) && (n.properties || (n.properties = {}), n.properties[o.name] = {
      values: 0,
      data: o.values
    });
  }
  return n.count = i, n;
}
function P$(r, e, t) {
  const n = {
    values: 0
  };
  if (e.type === "STRING") {
    const {
      stringData: i,
      stringOffsets: s
    } = L$(r);
    n.stringOffsets = Vb(s, t), n.values = Vb(i, t);
  } else if (e.type === "SCALAR" && e.componentType) {
    const i = B$(r, e.componentType);
    n.values = Vb(i, t);
  }
  return n;
}
const R$ = {
  INT8: Int8Array,
  UINT8: Uint8Array,
  INT16: Int16Array,
  UINT16: Uint16Array,
  INT32: Int32Array,
  UINT32: Uint32Array,
  INT64: Int32Array,
  UINT64: Uint32Array,
  FLOAT32: Float32Array,
  FLOAT64: Float64Array
};
function B$(r, e) {
  const t = [];
  for (const i of r)
    t.push(Number(i));
  const n = R$[e];
  if (!n)
    throw new Error("Illegal component type");
  return new n(t);
}
function L$(r) {
  const e = new TextEncoder(), t = [];
  let n = 0;
  for (const d of r) {
    const m = e.encode(d);
    n += m.length, t.push(m);
  }
  const i = new Uint8Array(n), s = [];
  let l = 0;
  for (const d of t)
    i.set(d, l), s.push(l), l += d.length;
  s.push(l);
  const o = new Uint32Array(s);
  return {
    stringData: i,
    stringOffsets: o
  };
}
function Vb(r, e) {
  return e.gltf.buffers.push({
    arrayBuffer: r.buffer,
    byteOffset: r.byteOffset,
    byteLength: r.byteLength
  }), e.addBufferView(r);
}
const O$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createExtStructuralMetadata: C$,
  decode: a$,
  encode: l$,
  name: o$
}, Symbol.toStringTag, { value: "Module" })), XI = "EXT_feature_metadata", k$ = XI;
async function N$(r, e) {
  const t = new yo(r);
  D$(t, e);
}
function D$(r, e) {
  var n, i;
  if (!((n = e.gltf) != null && n.loadBuffers))
    return;
  const t = r.getExtension(XI);
  t && ((i = e.gltf) != null && i.loadImages && F$(r, t), U$(r, t));
}
function F$(r, e) {
  const t = e.schema;
  if (!t)
    return;
  const n = t.classes, {
    featureTextures: i
  } = e;
  if (n && i)
    for (const s in n) {
      const l = n[s], o = j$(i, s);
      o && $$(r, o, l);
    }
}
function U$(r, e) {
  const t = e.schema;
  if (!t)
    return;
  const n = t.classes, i = e.featureTables;
  if (n && i)
    for (const s in n) {
      const l = z$(i, s);
      l && V$(r, t, l);
    }
}
function z$(r, e) {
  for (const t in r) {
    const n = r[t];
    if (n.class === e)
      return n;
  }
  return null;
}
function j$(r, e) {
  for (const t in r) {
    const n = r[t];
    if (n.class === e)
      return n;
  }
  return null;
}
function V$(r, e, t) {
  var s, l;
  if (!t.class)
    return;
  const n = (s = e.classes) == null ? void 0 : s[t.class];
  if (!n)
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${t.class}`);
  const i = t.count;
  for (const o in n.properties) {
    const d = n.properties[o], m = (l = t.properties) == null ? void 0 : l[o];
    if (m) {
      const b = q$(r, e, d, i, m);
      m.data = b;
    }
  }
}
function $$(r, e, t) {
  var i;
  const n = e.class;
  for (const s in t.properties) {
    const l = (i = e == null ? void 0 : e.properties) == null ? void 0 : i[s];
    if (l) {
      const o = Z$(r, l, n);
      l.data = o;
    }
  }
}
function q$(r, e, t, n, i) {
  let s = [];
  const l = i.bufferView, o = r.getTypedArrayForBufferView(l), d = G$(r, t, i, n), m = H$(r, t, i, n);
  return t.type === "STRING" || t.componentType === "STRING" ? s = WI(n, o, d, m) : W$(t) && (s = X$(t, n, o, d)), s;
}
function G$(r, e, t, n) {
  return e.type === "ARRAY" && // `componentCount` is a number of fixed-length array elements.
  // If `componentCount` is NOT defined, it's a VARIABLE-length array
  typeof e.componentCount > "u" && // `arrayOffsetBufferView` is an index of the buffer view containing offsets for variable-length arrays.
  typeof t.arrayOffsetBufferView < "u" ? jy(
    r,
    t.arrayOffsetBufferView,
    t.offsetType || "UINT32",
    // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView
    n
  ) : null;
}
function H$(r, e, t, n) {
  return typeof t.stringOffsetBufferView < "u" ? jy(
    r,
    t.stringOffsetBufferView,
    t.offsetType || "UINT32",
    // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView
    n
  ) : null;
}
function W$(r) {
  const e = ["UINT8", "INT16", "UINT16", "INT32", "UINT32", "INT64", "UINT64", "FLOAT32", "FLOAT64"];
  return e.includes(r.type) || typeof r.componentType < "u" && e.includes(r.componentType);
}
function X$(r, e, t, n) {
  const i = r.type === "ARRAY", s = r.componentCount, l = "SCALAR", o = r.componentType || r.type, d = sx(l, o), m = t.byteLength / d, b = Vy(t, l, o, m);
  return i ? n ? GI(b, e, n, t.length, d) : s ? HI(b, e, s) : [] : b;
}
function Z$(r, e, t) {
  const n = r.gltf.json;
  if (!n.meshes)
    return [];
  const i = [];
  for (const s of n.meshes)
    for (const l of s.primitives)
      Y$(r, t, e, i, l);
  return i;
}
function Y$(r, e, t, n, i) {
  const s = {
    channels: t.channels,
    ...t.texture
  }, l = ox(r, s, i);
  l && qI(r, e, l, n, i);
}
const K$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: N$,
  name: k$
}, Symbol.toStringTag, { value: "Module" })), J$ = "4.3.2", up = !0, Z3 = 1735152710, lx = 12, ly = 8, Q$ = 1313821514, eq = 5130562, tq = 0, rq = 0, nq = 1;
function iq(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return `${String.fromCharCode(r.getUint8(e + 0))}${String.fromCharCode(r.getUint8(e + 1))}${String.fromCharCode(r.getUint8(e + 2))}${String.fromCharCode(r.getUint8(e + 3))}`;
}
function sq(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const n = new DataView(r), {
    magic: i = Z3
  } = t, s = n.getUint32(e, !1);
  return s === i || s === Z3;
}
function oq(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const n = new DataView(e), i = iq(n, t + 0), s = n.getUint32(t + 4, up), l = n.getUint32(t + 8, up);
  switch (Object.assign(r, {
    // Put less important stuff in a header, to avoid clutter
    header: {
      byteOffset: t,
      // Byte offset into the initial arrayBuffer
      byteLength: l,
      hasBinChunk: !1
    },
    type: i,
    version: s,
    json: {},
    binChunks: []
  }), t += lx, r.version) {
    case 1:
      return aq(r, n, t);
    case 2:
      return lq(r, n, t, {});
    default:
      throw new Error(`Invalid GLB version ${r.version}. Only supports version 1 and 2.`);
  }
}
function aq(r, e, t) {
  Mi(r.header.byteLength > lx + ly);
  const n = e.getUint32(t + 0, up), i = e.getUint32(t + 4, up);
  return t += ly, Mi(i === tq), Cv(r, e, t, n), t += n, t += Iv(r, e, t, r.header.byteLength), t;
}
function lq(r, e, t, n) {
  return Mi(r.header.byteLength > lx + ly), cq(r, e, t, n), t + r.header.byteLength;
}
function cq(r, e, t, n) {
  for (; t + 8 <= r.header.byteLength; ) {
    const i = e.getUint32(t + 0, up), s = e.getUint32(t + 4, up);
    switch (t += ly, s) {
      case Q$:
        Cv(r, e, t, i);
        break;
      case eq:
        Iv(r, e, t, i);
        break;
      // Backward compatibility for very old xviz files
      case rq:
        n.strict || Cv(r, e, t, i);
        break;
      case nq:
        n.strict || Iv(r, e, t, i);
        break;
    }
    t += Wg(i, 4);
  }
  return t;
}
function Cv(r, e, t, n) {
  const i = new Uint8Array(e.buffer, t, n), l = new TextDecoder("utf8").decode(i);
  return r.json = JSON.parse(l), Wg(n, 4);
}
function Iv(r, e, t, n) {
  return r.header.hasBinChunk = !0, r.binChunks.push({
    byteOffset: t,
    byteLength: n,
    arrayBuffer: e.buffer
    // TODO - copy, or create typed array view?
  }), Wg(n, 4);
}
function ZI(r, e) {
  if (r.startsWith("data:") || r.startsWith("http:") || r.startsWith("https:"))
    return r;
  const n = e.baseUri || e.uri;
  if (!n)
    throw new Error(`'baseUri' must be provided to resolve relative url ${r}`);
  return n.substr(0, n.lastIndexOf("/") + 1) + r;
}
const uq = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB", hq = "B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB", fq = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]), dq = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]), pq = {
  // legacy index-based enums for glTF
  0: "",
  1: "meshopt_decodeFilterOct",
  2: "meshopt_decodeFilterQuat",
  3: "meshopt_decodeFilterExp",
  // string-based enums for glTF
  NONE: "",
  OCTAHEDRAL: "meshopt_decodeFilterOct",
  QUATERNION: "meshopt_decodeFilterQuat",
  EXPONENTIAL: "meshopt_decodeFilterExp"
}, gq = {
  // legacy index-based enums for glTF
  0: "meshopt_decodeVertexBuffer",
  1: "meshopt_decodeIndexBuffer",
  2: "meshopt_decodeIndexSequence",
  // string-based enums for glTF
  ATTRIBUTES: "meshopt_decodeVertexBuffer",
  TRIANGLES: "meshopt_decodeIndexBuffer",
  INDICES: "meshopt_decodeIndexSequence"
};
async function mq(r, e, t, n, i) {
  let s = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "NONE";
  const l = await _q();
  vq(l, l.exports[gq[i]], r, e, t, n, l.exports[pq[s || "NONE"]]);
}
let $b;
async function _q() {
  return $b || ($b = yq()), $b;
}
async function yq() {
  let r = uq;
  WebAssembly.validate(fq) && (r = hq, console.log("Warning: meshopt_decoder is using experimental SIMD support"));
  const e = await WebAssembly.instantiate(bq(r), {});
  return await e.instance.exports.__wasm_call_ctors(), e.instance;
}
function bq(r) {
  const e = new Uint8Array(r.length);
  for (let n = 0; n < r.length; ++n) {
    const i = r.charCodeAt(n);
    e[n] = i > 96 ? i - 71 : i > 64 ? i - 65 : i > 47 ? i + 4 : i > 46 ? 63 : 62;
  }
  let t = 0;
  for (let n = 0; n < r.length; ++n)
    e[t++] = e[n] < 60 ? dq[e[n]] : (e[n] - 60) * 64 + e[++n];
  return e.buffer.slice(0, t);
}
function vq(r, e, t, n, i, s, l) {
  const o = r.exports.sbrk, d = n + 3 & -4, m = o(d * i), b = o(s.length), A = new Uint8Array(r.exports.memory.buffer);
  A.set(s, b);
  const M = e(m, n, i, b, s.length);
  if (M === 0 && l && l(m, d, i), t.set(A.subarray(m, m + n * i)), o(m - o(0)), M !== 0)
    throw new Error(`Malformed buffer data: ${M}`);
}
const cy = "EXT_meshopt_compression", xq = cy;
async function wq(r, e) {
  var i, s;
  const t = new yo(r);
  if (!((i = e == null ? void 0 : e.gltf) != null && i.decompressMeshes) || !((s = e.gltf) != null && s.loadBuffers))
    return;
  const n = [];
  for (const l of r.json.bufferViews || [])
    n.push(Aq(t, l));
  await Promise.all(n), t.removeExtension(cy);
}
async function Aq(r, e) {
  const t = r.getObjectExtension(e, cy);
  if (t) {
    const {
      byteOffset: n = 0,
      byteLength: i = 0,
      byteStride: s,
      count: l,
      mode: o,
      filter: d = "NONE",
      buffer: m
    } = t, b = r.gltf.buffers[m], A = new Uint8Array(b.arrayBuffer, b.byteOffset + n, i), M = new Uint8Array(r.gltf.buffers[e.buffer].arrayBuffer, e.byteOffset, e.byteLength);
    await mq(M, l, s, A, o, d), r.removeObjectExtension(e, cy);
  }
}
const Tq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: wq,
  name: xq
}, Symbol.toStringTag, { value: "Module" })), Bd = "EXT_texture_webp", Sq = Bd;
function Eq(r, e) {
  const t = new yo(r);
  if (!TO("image/webp")) {
    if (t.getRequiredExtensions().includes(Bd))
      throw new Error(`gltf: Required extension ${Bd} not supported by browser`);
    return;
  }
  const {
    json: n
  } = t;
  for (const i of n.textures || []) {
    const s = t.getObjectExtension(i, Bd);
    s && (i.source = s.source), t.removeObjectExtension(i, Bd);
  }
  t.removeExtension(Bd);
}
const Cq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: Sq,
  preprocess: Eq
}, Symbol.toStringTag, { value: "Module" })), y_ = "KHR_texture_basisu", Iq = y_;
function Mq(r, e) {
  const t = new yo(r), {
    json: n
  } = t;
  for (const i of n.textures || []) {
    const s = t.getObjectExtension(i, y_);
    s && (i.source = s.source, t.removeObjectExtension(i, y_));
  }
  t.removeExtension(y_);
}
const Pq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: Iq,
  preprocess: Mq
}, Symbol.toStringTag, { value: "Module" })), Rq = "4.3.2", Bq = {
  dataType: null,
  batchType: null,
  name: "Draco",
  id: "draco",
  module: "draco",
  // shapes: ['mesh'],
  version: Rq,
  worker: !0,
  extensions: ["drc"],
  mimeTypes: ["application/octet-stream"],
  binary: !0,
  tests: ["DRACO"],
  options: {
    draco: {
      decoderType: typeof WebAssembly == "object" ? "wasm" : "js",
      // 'js' for IE11
      libraryPath: "libs/",
      extraAttributes: {},
      attributeNameEntry: void 0
    }
  }
};
function Lq(r, e, t) {
  const n = YI(e.metadata), i = [], s = Oq(e.attributes);
  for (const l in r) {
    const o = r[l], d = Y3(l, o, s[l]);
    i.push(d);
  }
  if (t) {
    const l = Y3("indices", t);
    i.push(l);
  }
  return {
    fields: i,
    metadata: n
  };
}
function Oq(r) {
  const e = {};
  for (const t in r) {
    const n = r[t];
    e[n.name || "undefined"] = n;
  }
  return e;
}
function Y3(r, e, t) {
  const n = t ? YI(t.metadata) : void 0;
  return $L(r, e, n);
}
function YI(r) {
  Object.entries(r);
  const e = {};
  for (const t in r)
    e[`${t}.string`] = JSON.stringify(r[t]);
  return e;
}
const K3 = {
  POSITION: "POSITION",
  NORMAL: "NORMAL",
  COLOR: "COLOR_0",
  TEX_COORD: "TEXCOORD_0"
}, kq = {
  1: Int8Array,
  2: Uint8Array,
  3: Int16Array,
  4: Uint16Array,
  5: Int32Array,
  6: Uint32Array,
  // 7: BigInt64Array,
  // 8: BigUint64Array,
  9: Float32Array
  // 10: Float64Array
  // 11: BOOL - What array type do we use for this?
}, Nq = 4;
class Dq {
  // draco - the draco decoder, either import `draco3d` or load dynamically
  constructor(e) {
    H(this, "draco");
    H(this, "decoder");
    H(this, "metadataQuerier");
    this.draco = e, this.decoder = new this.draco.Decoder(), this.metadataQuerier = new this.draco.MetadataQuerier();
  }
  /**
   * Destroy draco resources
   */
  destroy() {
    this.draco.destroy(this.decoder), this.draco.destroy(this.metadataQuerier);
  }
  /**
   * NOTE: caller must call `destroyGeometry` on the return value after using it
   * @param arrayBuffer
   * @param options
   */
  parseSync(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const n = new this.draco.DecoderBuffer();
    n.Init(new Int8Array(e), e.byteLength), this._disableAttributeTransforms(t);
    const i = this.decoder.GetEncodedGeometryType(n), s = i === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();
    try {
      let l;
      switch (i) {
        case this.draco.TRIANGULAR_MESH:
          l = this.decoder.DecodeBufferToMesh(n, s);
          break;
        case this.draco.POINT_CLOUD:
          l = this.decoder.DecodeBufferToPointCloud(n, s);
          break;
        default:
          throw new Error("DRACO: Unknown geometry type.");
      }
      if (!l.ok() || !s.ptr) {
        const M = `DRACO decompression failed: ${l.error_msg()}`;
        throw new Error(M);
      }
      const o = this._getDracoLoaderData(s, i, t), d = this._getMeshData(s, o, t), m = oC(d.attributes), b = Lq(d.attributes, o, d.indices);
      return {
        loader: "draco",
        loaderData: o,
        header: {
          vertexCount: s.num_points(),
          boundingBox: m
        },
        ...d,
        schema: b
      };
    } finally {
      this.draco.destroy(n), s && this.draco.destroy(s);
    }
  }
  // Draco specific "loader data"
  /**
   * Extract
   * @param dracoGeometry
   * @param geometry_type
   * @param options
   * @returns
   */
  _getDracoLoaderData(e, t, n) {
    const i = this._getTopLevelMetadata(e), s = this._getDracoAttributes(e, n);
    return {
      geometry_type: t,
      num_attributes: e.num_attributes(),
      num_points: e.num_points(),
      num_faces: e instanceof this.draco.Mesh ? e.num_faces() : 0,
      metadata: i,
      attributes: s
    };
  }
  /**
   * Extract all draco provided information and metadata for each attribute
   * @param dracoGeometry
   * @param options
   * @returns
   */
  _getDracoAttributes(e, t) {
    const n = {};
    for (let i = 0; i < e.num_attributes(); i++) {
      const s = this.decoder.GetAttribute(e, i), l = this._getAttributeMetadata(e, i);
      n[s.unique_id()] = {
        unique_id: s.unique_id(),
        attribute_type: s.attribute_type(),
        data_type: s.data_type(),
        num_components: s.num_components(),
        byte_offset: s.byte_offset(),
        byte_stride: s.byte_stride(),
        normalized: s.normalized(),
        attribute_index: i,
        metadata: l
      };
      const o = this._getQuantizationTransform(s, t);
      o && (n[s.unique_id()].quantization_transform = o);
      const d = this._getOctahedronTransform(s, t);
      d && (n[s.unique_id()].octahedron_transform = d);
    }
    return n;
  }
  /**
   * Get standard loaders.gl mesh category data
   * Extracts the geometry from draco
   * @param dracoGeometry
   * @param options
   */
  _getMeshData(e, t, n) {
    const i = this._getMeshAttributes(t, e, n);
    if (!i.POSITION)
      throw new Error("DRACO: No position attribute found.");
    if (e instanceof this.draco.Mesh)
      switch (n.topology) {
        case "triangle-strip":
          return {
            topology: "triangle-strip",
            mode: 4,
            // GL.TRIANGLES
            attributes: i,
            indices: {
              value: this._getTriangleStripIndices(e),
              size: 1
            }
          };
        case "triangle-list":
        default:
          return {
            topology: "triangle-list",
            mode: 5,
            // GL.TRIANGLE_STRIP
            attributes: i,
            indices: {
              value: this._getTriangleListIndices(e),
              size: 1
            }
          };
      }
    return {
      topology: "point-list",
      mode: 0,
      // GL.POINTS
      attributes: i
    };
  }
  _getMeshAttributes(e, t, n) {
    const i = {};
    for (const s of Object.values(e.attributes)) {
      const l = this._deduceAttributeName(s, n);
      s.name = l;
      const o = this._getAttributeValues(t, s);
      if (o) {
        const {
          value: d,
          size: m
        } = o;
        i[l] = {
          value: d,
          size: m,
          byteOffset: s.byte_offset,
          byteStride: s.byte_stride,
          normalized: s.normalized
        };
      }
    }
    return i;
  }
  // MESH INDICES EXTRACTION
  /**
   * For meshes, we need indices to define the faces.
   * @param dracoGeometry
   */
  _getTriangleListIndices(e) {
    const n = e.num_faces() * 3, i = n * Nq, s = this.draco._malloc(i);
    try {
      return this.decoder.GetTrianglesUInt32Array(e, i, s), new Uint32Array(this.draco.HEAPF32.buffer, s, n).slice();
    } finally {
      this.draco._free(s);
    }
  }
  /**
   * For meshes, we need indices to define the faces.
   * @param dracoGeometry
   */
  _getTriangleStripIndices(e) {
    const t = new this.draco.DracoInt32Array();
    try {
      return this.decoder.GetTriangleStripsFromMesh(e, t), zq(t);
    } finally {
      this.draco.destroy(t);
    }
  }
  /**
   *
   * @param dracoGeometry
   * @param dracoAttribute
   * @param attributeName
   */
  _getAttributeValues(e, t) {
    const n = kq[t.data_type];
    if (!n)
      return console.warn(`DRACO: Unsupported attribute type ${t.data_type}`), null;
    const i = t.num_components, l = e.num_points() * i, o = l * n.BYTES_PER_ELEMENT, d = Fq(this.draco, n);
    let m;
    const b = this.draco._malloc(o);
    try {
      const A = this.decoder.GetAttribute(e, t.attribute_index);
      this.decoder.GetAttributeDataArrayForAllPoints(e, A, d, o, b), m = new n(this.draco.HEAPF32.buffer, b, l).slice();
    } finally {
      this.draco._free(b);
    }
    return {
      value: m,
      size: i
    };
  }
  // Attribute names
  /**
   * DRACO does not store attribute names - We need to deduce an attribute name
   * for each attribute
  _getAttributeNames(
    dracoGeometry: Mesh | PointCloud,
    options: DracoParseOptions
  ): {[unique_id: number]: string} {
    const attributeNames: {[unique_id: number]: string} = {};
    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {
      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);
      const attributeName = this._deduceAttributeName(dracoAttribute, options);
      attributeNames[attributeName] = attributeName;
    }
    return attributeNames;
  }
   */
  /**
   * Deduce an attribute name.
   * @note DRACO does not save attribute names, just general type (POSITION, COLOR)
   * to help optimize compression. We generate GLTF compatible names for the Draco-recognized
   * types
   * @param attributeData
   */
  _deduceAttributeName(e, t) {
    const n = e.unique_id;
    for (const [l, o] of Object.entries(t.extraAttributes || {}))
      if (o === n)
        return l;
    const i = e.attribute_type;
    for (const l in K3)
      if (this.draco[l] === i)
        return K3[l];
    const s = t.attributeNameEntry || "name";
    return e.metadata[s] ? e.metadata[s].string : `CUSTOM_ATTRIBUTE_${n}`;
  }
  // METADATA EXTRACTION
  /** Get top level metadata */
  _getTopLevelMetadata(e) {
    const t = this.decoder.GetMetadata(e);
    return this._getDracoMetadata(t);
  }
  /** Get per attribute metadata */
  _getAttributeMetadata(e, t) {
    const n = this.decoder.GetAttributeMetadata(e, t);
    return this._getDracoMetadata(n);
  }
  /**
   * Extract metadata field values
   * @param dracoMetadata
   * @returns
   */
  _getDracoMetadata(e) {
    if (!e || !e.ptr)
      return {};
    const t = {}, n = this.metadataQuerier.NumEntries(e);
    for (let i = 0; i < n; i++) {
      const s = this.metadataQuerier.GetEntryName(e, i);
      t[s] = this._getDracoMetadataField(e, s);
    }
    return t;
  }
  /**
   * Extracts possible values for one metadata entry by name
   * @param dracoMetadata
   * @param entryName
   */
  _getDracoMetadataField(e, t) {
    const n = new this.draco.DracoInt32Array();
    try {
      this.metadataQuerier.GetIntEntryArray(e, t, n);
      const i = Uq(n);
      return {
        int: this.metadataQuerier.GetIntEntry(e, t),
        string: this.metadataQuerier.GetStringEntry(e, t),
        double: this.metadataQuerier.GetDoubleEntry(e, t),
        intArray: i
      };
    } finally {
      this.draco.destroy(n);
    }
  }
  // QUANTIZED ATTRIBUTE SUPPORT (NO DECOMPRESSION)
  /** Skip transforms for specific attribute types */
  _disableAttributeTransforms(e) {
    const {
      quantizedAttributes: t = [],
      octahedronAttributes: n = []
    } = e, i = [...t, ...n];
    for (const s of i)
      this.decoder.SkipAttributeTransform(this.draco[s]);
  }
  /**
   * Extract (and apply?) Position Transform
   * @todo not used
   */
  _getQuantizationTransform(e, t) {
    const {
      quantizedAttributes: n = []
    } = t, i = e.attribute_type();
    if (n.map((l) => this.decoder[l]).includes(i)) {
      const l = new this.draco.AttributeQuantizationTransform();
      try {
        if (l.InitFromAttribute(e))
          return {
            quantization_bits: l.quantization_bits(),
            range: l.range(),
            min_values: new Float32Array([1, 2, 3]).map((o) => l.min_value(o))
          };
      } finally {
        this.draco.destroy(l);
      }
    }
    return null;
  }
  _getOctahedronTransform(e, t) {
    const {
      octahedronAttributes: n = []
    } = t, i = e.attribute_type();
    if (n.map((l) => this.decoder[l]).includes(i)) {
      const l = new this.draco.AttributeQuantizationTransform();
      try {
        if (l.InitFromAttribute(e))
          return {
            quantization_bits: l.quantization_bits()
          };
      } finally {
        this.draco.destroy(l);
      }
    }
    return null;
  }
}
function Fq(r, e) {
  switch (e) {
    case Float32Array:
      return r.DT_FLOAT32;
    case Int8Array:
      return r.DT_INT8;
    case Int16Array:
      return r.DT_INT16;
    case Int32Array:
      return r.DT_INT32;
    case Uint8Array:
      return r.DT_UINT8;
    case Uint16Array:
      return r.DT_UINT16;
    case Uint32Array:
      return r.DT_UINT32;
    default:
      return r.DT_INVALID;
  }
}
function Uq(r) {
  const e = r.size(), t = new Int32Array(e);
  for (let n = 0; n < e; n++)
    t[n] = r.GetValue(n);
  return t;
}
function zq(r) {
  const e = r.size(), t = new Int32Array(e);
  for (let n = 0; n < e; n++)
    t[n] = r.GetValue(n);
  return t;
}
const jq = "1.5.6", Vq = "1.4.1", qb = `https://www.gstatic.com/draco/versioned/decoders/${jq}`, za = {
  /** The primary Draco3D encoder, javascript wrapper part */
  DECODER: "draco_wasm_wrapper.js",
  /** The primary draco decoder, compiled web assembly part */
  DECODER_WASM: "draco_decoder.wasm",
  /** Fallback decoder for non-webassebly environments. Very big bundle, lower performance */
  FALLBACK_DECODER: "draco_decoder.js",
  /** Draco encoder */
  ENCODER: "draco_encoder.js"
}, Gb = {
  [za.DECODER]: `${qb}/${za.DECODER}`,
  [za.DECODER_WASM]: `${qb}/${za.DECODER_WASM}`,
  [za.FALLBACK_DECODER]: `${qb}/${za.FALLBACK_DECODER}`,
  [za.ENCODER]: `https://raw.githubusercontent.com/google/draco/${Vq}/javascript/${za.ENCODER}`
};
let Hb;
async function $q(r) {
  const e = r.modules || {};
  return e.draco3d ? Hb || (Hb = e.draco3d.createDecoderModule({}).then((t) => ({
    draco: t
  }))) : Hb || (Hb = qq(r)), await Hb;
}
async function qq(r) {
  let e, t;
  switch (r.draco && r.draco.decoderType) {
    case "js":
      e = await kf(Gb[za.FALLBACK_DECODER], "draco", r, za.FALLBACK_DECODER);
      break;
    case "wasm":
    default:
      [e, t] = await Promise.all([await kf(Gb[za.DECODER], "draco", r, za.DECODER), await kf(Gb[za.DECODER_WASM], "draco", r, za.DECODER_WASM)]);
  }
  return e = e || globalThis.DracoDecoderModule, await Gq(e, t);
}
function Gq(r, e) {
  const t = {};
  return e && (t.wasmBinary = e), new Promise((n) => {
    r({
      ...t,
      onModuleLoaded: (i) => n({
        draco: i
      })
      // Module is Promise-like. Wrap in object to avoid loop.
    });
  });
}
const KI = {
  ...Bq,
  parse: Hq
};
async function Hq(r, e) {
  const {
    draco: t
  } = await $q(e), n = new Dq(t);
  try {
    return n.parseSync(r, e == null ? void 0 : e.draco);
  } finally {
    n.destroy();
  }
}
function Wq(r) {
  const e = {};
  for (const t in r) {
    const n = r[t];
    if (t !== "indices") {
      const i = JI(n);
      e[t] = i;
    }
  }
  return e;
}
function JI(r) {
  const {
    buffer: e,
    size: t,
    count: n
  } = Xq(r);
  return {
    // glTF Accessor values
    // TODO: Instead of a bufferView index we could have an actual buffer (typed array)
    // bufferView: null,
    // TODO: Deprecate `value` in favor of bufferView?
    // @ts-ignore
    value: e,
    size: t,
    // Decoded `type` (e.g. SCALAR)
    byteOffset: 0,
    count: n,
    type: zI(t),
    componentType: zy(e)
  };
}
function Xq(r) {
  let e = r, t = 1, n = 0;
  return r && r.value && (e = r.value, t = r.size || 1), e && (ArrayBuffer.isView(e) || (e = Zq(e, Float32Array)), n = e.length / t), {
    buffer: e,
    size: t,
    count: n
  };
}
function Zq(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  return r ? Array.isArray(r) ? new e(r) : t && !(r instanceof e) ? new e(r) : r : null;
}
const Zh = "KHR_draco_mesh_compression", Yq = Zh;
function Kq(r, e, t) {
  const n = new yo(r);
  for (const i of QI(n))
    n.getObjectExtension(i, Zh);
}
async function Jq(r, e, t) {
  var s;
  if (!((s = e == null ? void 0 : e.gltf) != null && s.decompressMeshes))
    return;
  const n = new yo(r), i = [];
  for (const l of QI(n))
    n.getObjectExtension(l, Zh) && i.push(eG(n, l, e, t));
  await Promise.all(i), n.removeExtension(Zh);
}
function Qq(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = new yo(r);
  for (const n of t.json.meshes || [])
    tG(n, e), t.addRequiredExtension(Zh);
}
async function eG(r, e, t, n) {
  const i = r.getObjectExtension(e, Zh);
  if (!i)
    return;
  const s = r.getTypedArrayForBufferView(i.bufferView), l = c2(s.buffer, s.byteOffset), o = {
    ...t
  };
  delete o["3d-tiles"];
  const d = await Hg(l, KI, o, n), m = Wq(d.attributes);
  for (const [b, A] of Object.entries(m))
    if (b in e.attributes) {
      const M = e.attributes[b], E = r.getAccessor(M);
      E != null && E.min && (E != null && E.max) && (A.min = E.min, A.max = E.max);
    }
  e.attributes = m, d.indices && (e.indices = JI(d.indices)), r.removeObjectExtension(e, Zh), rG(e);
}
function tG(r, e) {
  var b;
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 4, n = arguments.length > 3 ? arguments[3] : void 0, i = arguments.length > 4 ? arguments[4] : void 0;
  if (!n.DracoWriter)
    throw new Error("options.gltf.DracoWriter not provided");
  const s = n.DracoWriter.encodeSync({
    attributes: r
  }), l = (b = i == null ? void 0 : i.parseSync) == null ? void 0 : b.call(i, {
    attributes: r
  }), o = n._addFauxAttributes(l.attributes), d = n.addBufferView(s);
  return {
    primitives: [{
      attributes: o,
      // TODO - verify with spec
      mode: t,
      // GL.POINTS
      extensions: {
        [Zh]: {
          bufferView: d,
          attributes: o
          // TODO - verify with spec
        }
      }
    }]
  };
}
function rG(r) {
  if (!r.attributes && Object.keys(r.attributes).length > 0)
    throw new Error("glTF: Empty primitive detected: Draco decompression failure?");
}
function* QI(r) {
  for (const e of r.json.meshes || [])
    for (const t of e.primitives)
      yield t;
}
const nG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: Jq,
  encode: Qq,
  name: Yq,
  preprocess: Kq
}, Symbol.toStringTag, { value: "Module" })), $y = "KHR_texture_transform", iG = $y, Wm = new Ct(), sG = new ms(), oG = new ms();
async function aG(r, e) {
  var s;
  if (!new yo(r).hasExtension($y) || !((s = e.gltf) != null && s.loadBuffers))
    return;
  const i = r.json.materials || [];
  for (let l = 0; l < i.length; l++)
    lG(l, r);
}
function lG(r, e) {
  var s, l, o, d;
  const t = (s = e.json.materials) == null ? void 0 : s[r], n = [(l = t == null ? void 0 : t.pbrMetallicRoughness) == null ? void 0 : l.baseColorTexture, t == null ? void 0 : t.emissiveTexture, t == null ? void 0 : t.normalTexture, t == null ? void 0 : t.occlusionTexture, (o = t == null ? void 0 : t.pbrMetallicRoughness) == null ? void 0 : o.metallicRoughnessTexture], i = [];
  for (const m of n)
    m && ((d = m == null ? void 0 : m.extensions) != null && d[$y]) && cG(e, r, m, i);
}
function cG(r, e, t, n) {
  const i = uG(t, n);
  if (!i)
    return;
  const s = r.json.meshes || [];
  for (const l of s)
    for (const o of l.primitives) {
      const d = o.material;
      Number.isFinite(d) && e === d && hG(r, o, i);
    }
}
function uG(r, e) {
  var l;
  const t = (l = r.extensions) == null ? void 0 : l[$y], {
    texCoord: n = 0
  } = r, {
    texCoord: i = n
  } = t;
  if (!(e.findIndex((o) => {
    let [d, m] = o;
    return d === n && m === i;
  }) !== -1)) {
    const o = pG(t);
    return n !== i && (r.texCoord = i), e.push([n, i]), {
      originalTexCoord: n,
      texCoord: i,
      matrix: o
    };
  }
  return null;
}
function hG(r, e, t) {
  var o, d;
  const {
    originalTexCoord: n,
    texCoord: i,
    matrix: s
  } = t, l = e.attributes[`TEXCOORD_${n}`];
  if (Number.isFinite(l)) {
    const m = (o = r.json.accessors) == null ? void 0 : o[l];
    if (m && m.bufferView) {
      const b = (d = r.json.bufferViews) == null ? void 0 : d[m.bufferView];
      if (b) {
        const {
          arrayBuffer: A,
          byteOffset: M
        } = r.buffers[b.buffer], E = (M || 0) + (m.byteOffset || 0) + (b.byteOffset || 0), {
          ArrayType: k,
          length: U
        } = ix(m, b), V = UI[m.componentType], q = FI[m.type], Y = b.byteStride || V * q, re = new Float32Array(U);
        for (let Z = 0; Z < m.count; Z++) {
          const K = new k(A, E + Z * Y, 2);
          Wm.set(K[0], K[1], 1), Wm.transformByMatrix3(s), re.set([Wm[0], Wm[1]], Z * q);
        }
        n === i ? fG(m, b, r.buffers, re) : dG(i, m, e, r, re);
      }
    }
  }
}
function fG(r, e, t, n) {
  r.componentType = 5126, t.push({
    arrayBuffer: n.buffer,
    byteOffset: 0,
    byteLength: n.buffer.byteLength
  }), e.buffer = t.length - 1, e.byteLength = n.buffer.byteLength, e.byteOffset = 0, delete e.byteStride;
}
function dG(r, e, t, n, i) {
  n.buffers.push({
    arrayBuffer: i.buffer,
    byteOffset: 0,
    byteLength: i.buffer.byteLength
  });
  const s = n.json.bufferViews;
  if (!s)
    return;
  s.push({
    buffer: n.buffers.length - 1,
    byteLength: i.buffer.byteLength,
    byteOffset: 0
  });
  const l = n.json.accessors;
  l && (l.push({
    bufferView: (s == null ? void 0 : s.length) - 1,
    byteOffset: 0,
    componentType: 5126,
    count: e.count,
    type: "VEC2"
  }), t.attributes[`TEXCOORD_${r}`] = l.length - 1);
}
function pG(r) {
  const {
    offset: e = [0, 0],
    rotation: t = 0,
    scale: n = [1, 1]
  } = r, i = new ms().set(1, 0, 0, 0, 1, 0, e[0], e[1], 1), s = sG.set(Math.cos(t), Math.sin(t), 0, -Math.sin(t), Math.cos(t), 0, 0, 0, 1), l = oG.set(n[0], 0, 0, 0, n[1], 0, 0, 0, 1);
  return i.multiplyRight(s).multiplyRight(l);
}
const gG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: aG,
  name: iG
}, Symbol.toStringTag, { value: "Module" })), Pf = "KHR_lights_punctual", mG = Pf;
async function _G(r) {
  const e = new yo(r), {
    json: t
  } = e, n = e.getExtension(Pf);
  n && (e.json.lights = n.lights, e.removeExtension(Pf));
  for (const i of t.nodes || []) {
    const s = e.getObjectExtension(i, Pf);
    s && (i.light = s.light), e.removeObjectExtension(i, Pf);
  }
}
async function yG(r) {
  const e = new yo(r), {
    json: t
  } = e;
  if (t.lights) {
    const n = e.addExtension(Pf);
    _l(!n.lights), n.lights = t.lights, delete t.lights;
  }
  if (e.json.lights) {
    for (const n of e.json.lights) {
      const i = n.node;
      e.addObjectExtension(i, Pf, n);
    }
    delete e.json.lights;
  }
}
const bG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: _G,
  encode: yG,
  name: mG
}, Symbol.toStringTag, { value: "Module" })), zg = "KHR_materials_unlit", vG = zg;
async function xG(r) {
  const e = new yo(r), {
    json: t
  } = e;
  for (const n of t.materials || [])
    n.extensions && n.extensions.KHR_materials_unlit && (n.unlit = !0), e.removeObjectExtension(n, zg);
  e.removeExtension(zg);
}
function wG(r) {
  const e = new yo(r), {
    json: t
  } = e;
  if (e.materials)
    for (const n of t.materials || [])
      n.unlit && (delete n.unlit, e.addObjectExtension(n, zg, {}), e.addExtension(zg));
}
const AG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: xG,
  encode: wG,
  name: vG
}, Symbol.toStringTag, { value: "Module" })), dg = "KHR_techniques_webgl", TG = dg;
async function SG(r) {
  const e = new yo(r), {
    json: t
  } = e, n = e.getExtension(dg);
  if (n) {
    const i = CG(n, e);
    for (const s of t.materials || []) {
      const l = e.getObjectExtension(s, dg);
      l && (s.technique = Object.assign(
        {},
        l,
        // @ts-ignore
        i[l.technique]
      ), s.technique.values = IG(s.technique, e)), e.removeObjectExtension(s, dg);
    }
    e.removeExtension(dg);
  }
}
async function EG(r, e) {
}
function CG(r, e) {
  const {
    programs: t = [],
    shaders: n = [],
    techniques: i = []
  } = r, s = new TextDecoder();
  return n.forEach((l) => {
    if (Number.isFinite(l.bufferView))
      l.code = s.decode(e.getTypedArrayForBufferView(l.bufferView));
    else
      throw new Error("KHR_techniques_webgl: no shader code");
  }), t.forEach((l) => {
    l.fragmentShader = n[l.fragmentShader], l.vertexShader = n[l.vertexShader];
  }), i.forEach((l) => {
    l.program = t[l.program];
  }), i;
}
function IG(r, e) {
  const t = Object.assign({}, r.values);
  return Object.keys(r.uniforms || {}).forEach((n) => {
    r.uniforms[n].value && !(n in t) && (t[n] = r.uniforms[n].value);
  }), Object.keys(t).forEach((n) => {
    typeof t[n] == "object" && t[n].index !== void 0 && (t[n].texture = e.getTexture(t[n].index));
  }), t;
}
const MG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: SG,
  encode: EG,
  name: TG
}, Symbol.toStringTag, { value: "Module" })), eM = [
  // 1.0
  // KHR_binary_gltf is handled separately - must be processed before other parsing starts
  // KHR_binary_gltf,
  // 2.0
  O$,
  s$,
  Tq,
  Cq,
  // Basisu should come after webp, we want basisu to be preferred if both are provided
  Pq,
  nG,
  bG,
  AG,
  MG,
  gG,
  K$
];
function PG(r) {
  var i;
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = arguments.length > 2 ? arguments[2] : void 0;
  const n = eM.filter((s) => tM(s.name, e));
  for (const s of n)
    (i = s.preprocess) == null || i.call(s, r, e, t);
}
async function RG(r) {
  var i;
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = arguments.length > 2 ? arguments[2] : void 0;
  const n = eM.filter((s) => tM(s.name, e));
  for (const s of n)
    await ((i = s.decode) == null ? void 0 : i.call(s, r, e, t));
}
function tM(r, e) {
  var i;
  const t = ((i = e == null ? void 0 : e.gltf) == null ? void 0 : i.excludeExtensions) || {};
  return !(r in t && !t[r]);
}
const Wb = "KHR_binary_glTF";
function BG(r) {
  const e = new yo(r), {
    json: t
  } = e;
  for (const n of t.images || []) {
    const i = e.getObjectExtension(n, Wb);
    i && Object.assign(n, i), e.removeObjectExtension(n, Wb);
  }
  t.buffers && t.buffers[0] && delete t.buffers[0].uri, e.removeExtension(Wb);
}
const J3 = {
  accessors: "accessor",
  animations: "animation",
  buffers: "buffer",
  bufferViews: "bufferView",
  images: "image",
  materials: "material",
  meshes: "mesh",
  nodes: "node",
  samplers: "sampler",
  scenes: "scene",
  skins: "skin",
  textures: "texture"
}, LG = {
  accessor: "accessors",
  animations: "animation",
  buffer: "buffers",
  bufferView: "bufferViews",
  image: "images",
  material: "materials",
  mesh: "meshes",
  node: "nodes",
  sampler: "samplers",
  scene: "scenes",
  skin: "skins",
  texture: "textures"
};
class OG {
  constructor() {
    H(this, "idToIndexMap", {
      animations: {},
      accessors: {},
      buffers: {},
      bufferViews: {},
      images: {},
      materials: {},
      meshes: {},
      nodes: {},
      samplers: {},
      scenes: {},
      skins: {},
      textures: {}
    });
    H(this, "json");
  }
  // constructor() {}
  /**
   * Convert (normalize) glTF < 2.0 to glTF 2.0
   * @param gltf - object with json and binChunks
   * @param options
   * @param options normalize Whether to actually normalize
   */
  normalize(e, t) {
    this.json = e.json;
    const n = e.json;
    switch (n.asset && n.asset.version) {
      // We are converting to v2 format. Return if there is nothing to do
      case "2.0":
        return;
      // This class is written to convert 1.0
      case void 0:
      case "1.0":
        break;
      default:
        console.warn(`glTF: Unknown version ${n.asset.version}`);
        return;
    }
    if (!t.normalize)
      throw new Error("glTF v1 is not supported.");
    console.warn("Converting glTF v1 to glTF v2 format. This is experimental and may fail."), this._addAsset(n), this._convertTopLevelObjectsToArrays(n), BG(e), this._convertObjectIdsToArrayIndices(n), this._updateObjects(n), this._updateMaterial(n);
  }
  // asset is now required, #642 https://github.com/KhronosGroup/glTF/issues/639
  _addAsset(e) {
    e.asset = e.asset || {}, e.asset.version = "2.0", e.asset.generator = e.asset.generator || "Normalized to glTF 2.0 by loaders.gl";
  }
  _convertTopLevelObjectsToArrays(e) {
    for (const t in J3)
      this._convertTopLevelObjectToArray(e, t);
  }
  /** Convert one top level object to array */
  _convertTopLevelObjectToArray(e, t) {
    const n = e[t];
    if (!(!n || Array.isArray(n))) {
      e[t] = [];
      for (const i in n) {
        const s = n[i];
        s.id = s.id || i;
        const l = e[t].length;
        e[t].push(s), this.idToIndexMap[t][i] = l;
      }
    }
  }
  /** Go through all objects in all top-level arrays and replace ids with indices */
  _convertObjectIdsToArrayIndices(e) {
    for (const t in J3)
      this._convertIdsToIndices(e, t);
    "scene" in e && (e.scene = this._convertIdToIndex(e.scene, "scene"));
    for (const t of e.textures)
      this._convertTextureIds(t);
    for (const t of e.meshes)
      this._convertMeshIds(t);
    for (const t of e.nodes)
      this._convertNodeIds(t);
    for (const t of e.scenes)
      this._convertSceneIds(t);
  }
  _convertTextureIds(e) {
    e.source && (e.source = this._convertIdToIndex(e.source, "image"));
  }
  _convertMeshIds(e) {
    for (const t of e.primitives) {
      const {
        attributes: n,
        indices: i,
        material: s
      } = t;
      for (const l in n)
        n[l] = this._convertIdToIndex(n[l], "accessor");
      i && (t.indices = this._convertIdToIndex(i, "accessor")), s && (t.material = this._convertIdToIndex(s, "material"));
    }
  }
  _convertNodeIds(e) {
    e.children && (e.children = e.children.map((t) => this._convertIdToIndex(t, "node"))), e.meshes && (e.meshes = e.meshes.map((t) => this._convertIdToIndex(t, "mesh")));
  }
  _convertSceneIds(e) {
    e.nodes && (e.nodes = e.nodes.map((t) => this._convertIdToIndex(t, "node")));
  }
  /** Go through all objects in a top-level array and replace ids with indices */
  _convertIdsToIndices(e, t) {
    e[t] || (console.warn(`gltf v1: json doesn't contain attribute ${t}`), e[t] = []);
    for (const n of e[t])
      for (const i in n) {
        const s = n[i], l = this._convertIdToIndex(s, i);
        n[i] = l;
      }
  }
  _convertIdToIndex(e, t) {
    const n = LG[t];
    if (n in this.idToIndexMap) {
      const i = this.idToIndexMap[n][e];
      if (!Number.isFinite(i))
        throw new Error(`gltf v1: failed to resolve ${t} with id ${e}`);
      return i;
    }
    return e;
  }
  /**
   *
   * @param {*} json
   */
  _updateObjects(e) {
    for (const t of this.json.buffers)
      delete t.type;
  }
  /**
   * Update material (set pbrMetallicRoughness)
   * @param {*} json
   */
  _updateMaterial(e) {
    var t, n, i;
    for (const s of e.materials) {
      s.pbrMetallicRoughness = {
        baseColorFactor: [1, 1, 1, 1],
        metallicFactor: 1,
        roughnessFactor: 1
      };
      const l = ((t = s.values) == null ? void 0 : t.tex) || ((n = s.values) == null ? void 0 : n.texture2d_0) || ((i = s.values) == null ? void 0 : i.diffuseTex), o = e.textures.findIndex((d) => d.id === l);
      o !== -1 && (s.pbrMetallicRoughness.baseColorTexture = {
        index: o
      });
    }
  }
}
function kG(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new OG().normalize(r, e);
}
async function NG(r, e) {
  var s, l, o;
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, n = arguments.length > 3 ? arguments[3] : void 0, i = arguments.length > 4 ? arguments[4] : void 0;
  return DG(r, e, t, n), kG(r, {
    normalize: (s = n == null ? void 0 : n.gltf) == null ? void 0 : s.normalize
  }), PG(r, n, i), (l = n == null ? void 0 : n.gltf) != null && l.loadBuffers && r.json.buffers && await FG(r, n, i), (o = n == null ? void 0 : n.gltf) != null && o.loadImages && await UG(r, n, i), await RG(r, n, i), r;
}
function DG(r, e, t, n) {
  if (n.uri && (r.baseUri = n.uri), e instanceof ArrayBuffer && !sq(e, t, n) && (e = new TextDecoder().decode(e)), typeof e == "string")
    r.json = TB(e);
  else if (e instanceof ArrayBuffer) {
    const l = {};
    t = oq(l, e, t, n.glb), _l(l.type === "glTF", `Invalid GLB magic string ${l.type}`), r._glb = l, r.json = l.json;
  } else
    _l(!1, "GLTF: must be ArrayBuffer or string");
  const i = r.json.buffers || [];
  if (r.buffers = new Array(i.length).fill(null), r._glb && r._glb.header.hasBinChunk) {
    const {
      binChunks: l
    } = r._glb;
    r.buffers[0] = {
      arrayBuffer: l[0].arrayBuffer,
      byteOffset: l[0].byteOffset,
      byteLength: l[0].byteLength
    };
  }
  const s = r.json.images || [];
  r.images = new Array(s.length).fill({});
}
async function FG(r, e, t) {
  var i, s;
  const n = r.json.buffers || [];
  for (let l = 0; l < n.length; ++l) {
    const o = n[l];
    if (o.uri) {
      const {
        fetch: d
      } = t;
      _l(d);
      const m = ZI(o.uri, e), b = await ((i = t == null ? void 0 : t.fetch) == null ? void 0 : i.call(t, m)), A = await ((s = b == null ? void 0 : b.arrayBuffer) == null ? void 0 : s.call(b));
      r.buffers[l] = {
        arrayBuffer: A,
        byteOffset: 0,
        byteLength: A.byteLength
      }, delete o.uri;
    } else r.buffers[l] === null && (r.buffers[l] = {
      arrayBuffer: new ArrayBuffer(o.byteLength),
      byteOffset: 0,
      byteLength: o.byteLength
    });
  }
}
async function UG(r, e, t) {
  const n = zG(r), i = r.json.images || [], s = [];
  for (const l of n)
    s.push(jG(r, i[l], l, e, t));
  return await Promise.all(s);
}
function zG(r) {
  const e = /* @__PURE__ */ new Set(), t = r.json.textures || [];
  for (const n of t)
    n.source !== void 0 && e.add(n.source);
  return Array.from(e).sort();
}
async function jG(r, e, t, n, i) {
  let s;
  if (e.uri && !e.hasOwnProperty("bufferView")) {
    const o = ZI(e.uri, n), {
      fetch: d
    } = i;
    s = await (await d(o)).arrayBuffer(), e.bufferView = {
      data: s
    };
  }
  if (Number.isFinite(e.bufferView)) {
    const o = qV(r.json, r.buffers, e.bufferView);
    s = c2(o.buffer, o.byteOffset, o.byteLength);
  }
  _l(s, "glTF image has no data");
  let l = await Hg(s, [uC, bV], {
    ...n,
    mimeType: e.mimeType,
    basis: n.basis || {
      format: DI()
    }
  }, i);
  l && l[0] && (l = {
    compressed: !0,
    // @ts-expect-error
    mipmaps: !1,
    width: l[0].width,
    height: l[0].height,
    data: l[0]
  }), r.images = r.images || [], r.images[t] = l;
}
const jg = {
  dataType: null,
  batchType: null,
  name: "glTF",
  id: "gltf",
  module: "gltf",
  version: J$,
  extensions: ["gltf", "glb"],
  mimeTypes: ["model/gltf+json", "model/gltf-binary"],
  text: !0,
  binary: !0,
  tests: ["glTF"],
  parse: VG,
  options: {
    gltf: {
      normalize: !0,
      // Normalize glTF v1 to glTF v2 format (not yet stable)
      loadBuffers: !0,
      // Fetch any linked .BIN buffers, decode base64
      loadImages: !0,
      // Create image objects
      decompressMeshes: !0
      // Decompress Draco encoded meshes
    },
    // common?
    log: console
    // eslint-disable-line
  }
};
async function VG(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = arguments.length > 2 ? arguments[2] : void 0;
  e = {
    ...jg.options,
    ...e
  }, e.gltf = {
    ...jg.options.gltf,
    ...e.gltf
  };
  const {
    byteOffset: n = 0
  } = e;
  return await NG({}, r, n, e, t);
}
const $G = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, qG = {
  5120: 1,
  // BYTE
  5121: 1,
  // UNSIGNED_BYTE
  5122: 2,
  // SHORT
  5123: 2,
  // UNSIGNED_SHORT
  5125: 4,
  // UNSIGNED_INT
  5126: 4
  // FLOAT
}, Ll = {
  // Sampler parameters
  TEXTURE_MAG_FILTER: 10240,
  TEXTURE_MIN_FILTER: 10241,
  TEXTURE_WRAP_S: 10242,
  TEXTURE_WRAP_T: 10243,
  // Sampler default values
  REPEAT: 10497,
  LINEAR: 9729,
  NEAREST_MIPMAP_LINEAR: 9986
}, GG = {
  magFilter: Ll.TEXTURE_MAG_FILTER,
  minFilter: Ll.TEXTURE_MIN_FILTER,
  wrapS: Ll.TEXTURE_WRAP_S,
  wrapT: Ll.TEXTURE_WRAP_T
}, HG = {
  [Ll.TEXTURE_MAG_FILTER]: Ll.LINEAR,
  [Ll.TEXTURE_MIN_FILTER]: Ll.NEAREST_MIPMAP_LINEAR,
  [Ll.TEXTURE_WRAP_S]: Ll.REPEAT,
  [Ll.TEXTURE_WRAP_T]: Ll.REPEAT
};
function WG() {
  return {
    id: "default-sampler",
    parameters: HG
  };
}
function XG(r) {
  return qG[r];
}
function ZG(r) {
  return $G[r];
}
class YG {
  constructor() {
    H(this, "baseUri", "");
    // @ts-expect-error
    H(this, "jsonUnprocessed");
    // @ts-expect-error
    H(this, "json");
    H(this, "buffers", []);
    H(this, "images", []);
  }
  postProcess(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      json: n,
      buffers: i = [],
      images: s = []
    } = e, {
      baseUri: l = ""
    } = e;
    return _l(n), this.baseUri = l, this.buffers = i, this.images = s, this.jsonUnprocessed = n, this.json = this._resolveTree(e.json, t), this.json;
  }
  // Convert indexed glTF structure into tree structure
  // cross-link index resolution, enum lookup, convenience calculations
  // eslint-disable-next-line complexity, max-statements
  _resolveTree(e) {
    const t = {
      ...e
    };
    return this.json = t, e.bufferViews && (t.bufferViews = e.bufferViews.map((n, i) => this._resolveBufferView(n, i))), e.images && (t.images = e.images.map((n, i) => this._resolveImage(n, i))), e.samplers && (t.samplers = e.samplers.map((n, i) => this._resolveSampler(n, i))), e.textures && (t.textures = e.textures.map((n, i) => this._resolveTexture(n, i))), e.accessors && (t.accessors = e.accessors.map((n, i) => this._resolveAccessor(n, i))), e.materials && (t.materials = e.materials.map((n, i) => this._resolveMaterial(n, i))), e.meshes && (t.meshes = e.meshes.map((n, i) => this._resolveMesh(n, i))), e.nodes && (t.nodes = e.nodes.map((n, i) => this._resolveNode(n, i)), t.nodes = t.nodes.map((n, i) => this._resolveNodeChildren(n))), e.skins && (t.skins = e.skins.map((n, i) => this._resolveSkin(n, i))), e.scenes && (t.scenes = e.scenes.map((n, i) => this._resolveScene(n, i))), typeof this.json.scene == "number" && t.scenes && (t.scene = t.scenes[this.json.scene]), t;
  }
  getScene(e) {
    return this._get(this.json.scenes, e);
  }
  getNode(e) {
    return this._get(this.json.nodes, e);
  }
  getSkin(e) {
    return this._get(this.json.skins, e);
  }
  getMesh(e) {
    return this._get(this.json.meshes, e);
  }
  getMaterial(e) {
    return this._get(this.json.materials, e);
  }
  getAccessor(e) {
    return this._get(this.json.accessors, e);
  }
  getCamera(e) {
    return this._get(this.json.cameras, e);
  }
  getTexture(e) {
    return this._get(this.json.textures, e);
  }
  getSampler(e) {
    return this._get(this.json.samplers, e);
  }
  getImage(e) {
    return this._get(this.json.images, e);
  }
  getBufferView(e) {
    return this._get(this.json.bufferViews, e);
  }
  getBuffer(e) {
    return this._get(this.json.buffers, e);
  }
  _get(e, t) {
    if (typeof t == "object")
      return t;
    const n = e && e[t];
    return n || console.warn(`glTF file error: Could not find ${e}[${t}]`), n;
  }
  // PARSING HELPERS
  _resolveScene(e, t) {
    return {
      ...e,
      // @ts-ignore
      id: e.id || `scene-${t}`,
      nodes: (e.nodes || []).map((n) => this.getNode(n))
    };
  }
  _resolveNode(e, t) {
    const n = {
      ...e,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: (e == null ? void 0 : e.id) || `node-${t}`
    };
    return e.mesh !== void 0 && (n.mesh = this.getMesh(e.mesh)), e.camera !== void 0 && (n.camera = this.getCamera(e.camera)), e.skin !== void 0 && (n.skin = this.getSkin(e.skin)), e.meshes !== void 0 && e.meshes.length && (n.mesh = e.meshes.reduce((i, s) => {
      const l = this.getMesh(s);
      return i.id = l.id, i.primitives = i.primitives.concat(l.primitives), i;
    }, {
      primitives: []
    })), n;
  }
  _resolveNodeChildren(e) {
    return e.children && (e.children = e.children.map((t) => this.getNode(t))), e;
  }
  _resolveSkin(e, t) {
    const n = typeof e.inverseBindMatrices == "number" ? this.getAccessor(e.inverseBindMatrices) : void 0;
    return {
      ...e,
      id: e.id || `skin-${t}`,
      inverseBindMatrices: n
    };
  }
  _resolveMesh(e, t) {
    const n = {
      ...e,
      id: e.id || `mesh-${t}`,
      primitives: []
    };
    return e.primitives && (n.primitives = e.primitives.map((i) => {
      const s = {
        ...i,
        attributes: {},
        indices: void 0,
        material: void 0
      }, l = i.attributes;
      for (const o in l)
        s.attributes[o] = this.getAccessor(l[o]);
      return i.indices !== void 0 && (s.indices = this.getAccessor(i.indices)), i.material !== void 0 && (s.material = this.getMaterial(i.material)), s;
    })), n;
  }
  _resolveMaterial(e, t) {
    const n = {
      ...e,
      // @ts-expect-error
      id: e.id || `material-${t}`
    };
    if (n.normalTexture && (n.normalTexture = {
      ...n.normalTexture
    }, n.normalTexture.texture = this.getTexture(n.normalTexture.index)), n.occlusionTexture && (n.occlusionTexture = {
      ...n.occlusionTexture
    }, n.occlusionTexture.texture = this.getTexture(n.occlusionTexture.index)), n.emissiveTexture && (n.emissiveTexture = {
      ...n.emissiveTexture
    }, n.emissiveTexture.texture = this.getTexture(n.emissiveTexture.index)), n.emissiveFactor || (n.emissiveFactor = n.emissiveTexture ? [1, 1, 1] : [0, 0, 0]), n.pbrMetallicRoughness) {
      n.pbrMetallicRoughness = {
        ...n.pbrMetallicRoughness
      };
      const i = n.pbrMetallicRoughness;
      i.baseColorTexture && (i.baseColorTexture = {
        ...i.baseColorTexture
      }, i.baseColorTexture.texture = this.getTexture(i.baseColorTexture.index)), i.metallicRoughnessTexture && (i.metallicRoughnessTexture = {
        ...i.metallicRoughnessTexture
      }, i.metallicRoughnessTexture.texture = this.getTexture(i.metallicRoughnessTexture.index));
    }
    return n;
  }
  _resolveAccessor(e, t) {
    const n = XG(e.componentType), i = ZG(e.type), s = n * i, l = {
      ...e,
      // @ts-expect-error
      id: e.id || `accessor-${t}`,
      bytesPerComponent: n,
      components: i,
      bytesPerElement: s,
      value: void 0,
      bufferView: void 0,
      sparse: void 0
    };
    if (e.bufferView !== void 0 && (l.bufferView = this.getBufferView(e.bufferView)), l.bufferView) {
      const o = l.bufferView.buffer, {
        ArrayType: d,
        byteLength: m
      } = ix(l, l.bufferView), b = (l.bufferView.byteOffset || 0) + (l.byteOffset || 0) + o.byteOffset;
      let A = o.arrayBuffer.slice(b, b + m);
      l.bufferView.byteStride && (A = this._getValueFromInterleavedBuffer(o, b, l.bufferView.byteStride, l.bytesPerElement, l.count)), l.value = new d(A);
    }
    return l;
  }
  /**
   * Take values of particular accessor from interleaved buffer
   * various parts of the buffer
   * @param buffer
   * @param byteOffset
   * @param byteStride
   * @param bytesPerElement
   * @param count
   * @returns
   */
  _getValueFromInterleavedBuffer(e, t, n, i, s) {
    const l = new Uint8Array(s * i);
    for (let o = 0; o < s; o++) {
      const d = t + o * n;
      l.set(new Uint8Array(e.arrayBuffer.slice(d, d + i)), o * i);
    }
    return l.buffer;
  }
  _resolveTexture(e, t) {
    return {
      ...e,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e.id || `texture-${t}`,
      sampler: typeof e.sampler == "number" ? this.getSampler(e.sampler) : WG(),
      source: typeof e.source == "number" ? this.getImage(e.source) : void 0
    };
  }
  _resolveSampler(e, t) {
    const n = {
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e.id || `sampler-${t}`,
      ...e,
      parameters: {}
    };
    for (const i in n) {
      const s = this._enumSamplerParameter(i);
      s !== void 0 && (n.parameters[s] = n[i]);
    }
    return n;
  }
  _enumSamplerParameter(e) {
    return GG[e];
  }
  _resolveImage(e, t) {
    const n = {
      ...e,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e.id || `image-${t}`,
      image: null,
      bufferView: e.bufferView !== void 0 ? this.getBufferView(e.bufferView) : void 0
    }, i = this.images[t];
    return i && (n.image = i), n;
  }
  _resolveBufferView(e, t) {
    const n = e.buffer, i = this.buffers[n].arrayBuffer;
    let s = this.buffers[n].byteOffset || 0;
    return e.byteOffset && (s += e.byteOffset), {
      // // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: `bufferView-${t}`,
      ...e,
      // ...this.buffers[bufferIndex],
      buffer: this.buffers[n],
      data: new Uint8Array(i, s, e.byteLength)
    };
  }
  _resolveCamera(e, t) {
    const n = {
      ...e,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e.id || `camera-${t}`
    };
    return n.perspective, n.orthographic, n;
  }
}
function cx(r, e) {
  return new YG().postProcess(r, e);
}
async function KG(r) {
  const e = [];
  return r.scenes.forEach((t) => {
    t.traverse((n) => {
      Object.values(n.model.uniforms).forEach((i) => {
        i.loaded === !1 && e.push(i);
      });
    });
  }), await JG(() => e.some((t) => !t.loaded));
}
async function JG(r) {
  for (; r(); )
    await new Promise((e) => requestAnimationFrame(e));
}
const Q3 = `uniform scenegraphUniforms {
  float sizeScale;
  float sizeMinPixels;
  float sizeMaxPixels;
  mat4 sceneModelMatrix;
  bool composeModelMatrix;
} scenegraph;
`, QG = {
  name: "scenegraph",
  vs: Q3,
  fs: Q3,
  uniformTypes: {
    sizeScale: "f32",
    sizeMinPixels: "f32",
    sizeMaxPixels: "f32",
    sceneModelMatrix: "mat4x4<f32>",
    composeModelMatrix: "f32"
  }
}, eH = `#version 300 es
#define SHADER_NAME scenegraph-layer-vertex-shader
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
in vec3 instanceTranslation;
in vec3 positions;
#ifdef HAS_UV
in vec2 texCoords;
#endif
#ifdef LIGHTING_PBR
#ifdef HAS_NORMALS
in vec3 normals;
#endif
#endif
out vec4 vColor;
#ifndef LIGHTING_PBR
#ifdef HAS_UV
out vec2 vTEXCOORD_0;
#endif
#endif
void main(void) {
#if defined(HAS_UV) && !defined(LIGHTING_PBR)
vTEXCOORD_0 = texCoords;
geometry.uv = texCoords;
#endif
geometry.worldPosition = instancePositions;
geometry.pickingColor = instancePickingColors;
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vec3 normal = vec3(0.0, 0.0, 1.0);
#ifdef LIGHTING_PBR
#ifdef HAS_NORMALS
normal = instanceModelMatrix * (scenegraph.sceneModelMatrix * vec4(normals, 0.0)).xyz;
#endif
#endif
float originalSize = project_size_to_pixel(scenegraph.sizeScale);
float clampedSize = clamp(originalSize, scenegraph.sizeMinPixels, scenegraph.sizeMaxPixels);
vec3 pos = (instanceModelMatrix * (scenegraph.sceneModelMatrix * vec4(positions, 1.0)).xyz) * scenegraph.sizeScale * (clampedSize / originalSize) + instanceTranslation;
if(scenegraph.composeModelMatrix) {
DECKGL_FILTER_SIZE(pos, geometry);
geometry.normal = project_normal(normal);
geometry.worldPosition += pos;
gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
}
else {
pos = project_size(pos);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);
geometry.normal = project_normal(normal);
}
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
#ifdef LIGHTING_PBR
pbr_vPosition = geometry.position.xyz;
#ifdef HAS_NORMALS
pbr_vNormal = geometry.normal;
#endif
#ifdef HAS_UV
pbr_vUV = texCoords;
#else
pbr_vUV = vec2(0., 0.);
#endif
geometry.uv = pbr_vUV;
#endif
vColor = instanceColors;
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, tH = `#version 300 es
#define SHADER_NAME scenegraph-layer-fragment-shader
in vec4 vColor;
out vec4 fragColor;
#ifndef LIGHTING_PBR
#if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
in vec2 vTEXCOORD_0;
uniform sampler2D pbr_baseColorSampler;
#endif
#endif
void main(void) {
#ifdef LIGHTING_PBR
fragColor = vColor * pbr_filterColor(vec4(0));
geometry.uv = pbr_vUV;
#else
#if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
fragColor = vColor * texture(pbr_baseColorSampler, vTEXCOORD_0);
geometry.uv = vTEXCOORD_0;
#else
fragColor = vColor;
#endif
#endif
fragColor.a *= layer.opacity;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, rM = [255, 255, 255, 255], rH = {
  scenegraph: {
    type: "object",
    value: null,
    async: !0
  },
  getScene: (r) => r && r.scenes ? typeof r.scene == "object" ? r.scene : r.scenes[r.scene || 0] : r,
  getAnimator: (r) => r && r.animator,
  _animations: null,
  sizeScale: {
    type: "number",
    value: 1,
    min: 0
  },
  sizeMinPixels: {
    type: "number",
    min: 0,
    value: 0
  },
  sizeMaxPixels: {
    type: "number",
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  getPosition: {
    type: "accessor",
    value: (r) => r.position
  },
  getColor: {
    type: "accessor",
    value: rM
  },
  // flat or pbr
  _lighting: "flat",
  // _lighting must be pbr for this to work
  _imageBasedLightingEnvironment: void 0,
  // yaw, pitch and roll are in degrees
  // https://en.wikipedia.org/wiki/Euler_angles
  // [pitch, yaw, roll]
  getOrientation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  getScale: {
    type: "accessor",
    value: [1, 1, 1]
  },
  getTranslation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  // 4x4 matrix
  getTransformMatrix: {
    type: "accessor",
    value: []
  },
  loaders: [jg]
};
class ux extends vp {
  getShaders() {
    const e = {};
    let t;
    this.props._lighting === "pbr" ? (t = F2, e.LIGHTING_PBR = 1) : t = {
      name: "pbrMaterial"
    };
    const n = [z2, q2, QG, t];
    return super.getShaders({
      defines: e,
      vs: eH,
      fs: tH,
      modules: n
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        accessor: "getPosition",
        transition: !0
      },
      instanceColors: {
        type: "unorm8",
        size: this.props.colorFormat.length,
        accessor: "getColor",
        defaultValue: rM,
        transition: !0
      },
      instanceModelMatrix: LI
    });
  }
  updateState(e) {
    super.updateState(e);
    const {
      props: t,
      oldProps: n
    } = e;
    t.scenegraph !== n.scenegraph ? this._updateScenegraph() : t._animations !== n._animations && this._applyAnimationsProp(this.state.animator, t._animations);
  }
  finalizeState(e) {
    var t;
    super.finalizeState(e), (t = this.state.scenegraph) == null || t.destroy();
  }
  get isLoaded() {
    var e;
    return !!((e = this.state) != null && e.scenegraph && super.isLoaded);
  }
  _updateScenegraph() {
    var o;
    const e = this.props, {
      device: t
    } = this.context;
    let n = null;
    if (e.scenegraph instanceof ry)
      n = {
        scenes: [e.scenegraph]
      };
    else if (e.scenegraph && typeof e.scenegraph == "object") {
      const d = e.scenegraph, m = d.json ? cx(d) : d, b = DV(t, m, this._getModelOptions());
      n = {
        gltf: m,
        ...b
      }, KG(b).then(() => {
        this.setNeedsRedraw();
      }).catch((A) => {
        this.raiseError(A, "loading glTF");
      });
    }
    const i = {
      layer: this,
      device: this.context.device
    }, s = e.getScene(n, i), l = e.getAnimator(n, i);
    if (s instanceof Zd) {
      (o = this.state.scenegraph) == null || o.destroy(), this._applyAnimationsProp(l, e._animations);
      const d = [];
      s.traverse((m) => {
        m instanceof dv && d.push(m.model);
      }), this.setState({
        scenegraph: s,
        animator: l,
        models: d
      }), this.getAttributeManager().invalidateAll();
    } else s !== null && Gn.warn("invalid scenegraph:", s)();
  }
  _applyAnimationsProp(e, t) {
    if (!e || !t)
      return;
    const n = e.getAnimations();
    Object.keys(t).sort().forEach((i) => {
      const s = t[i];
      if (i === "*")
        n.forEach((l) => {
          Object.assign(l, s);
        });
      else if (Number.isFinite(Number(i))) {
        const l = Number(i);
        l >= 0 && l < n.length ? Object.assign(n[l], s) : Gn.warn(`animation ${i} not found`)();
      } else {
        const l = n.find((o) => {
          let {
            name: d
          } = o;
          return d === i;
        });
        l ? Object.assign(l, s) : Gn.warn(`animation ${i} not found`)();
      }
    });
  }
  _getModelOptions() {
    const {
      _imageBasedLightingEnvironment: e
    } = this.props;
    let t;
    return e && (typeof e == "function" ? t = e({
      gl: this.context.gl,
      layer: this
    }) : t = e), {
      imageBasedLightingEnvironment: t,
      modelOptions: {
        id: this.props.id,
        isInstanced: !0,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        ...this.getShaders()
      },
      // tangents are not supported
      useTangents: !1
    };
  }
  draw(e) {
    let {
      context: t
    } = e;
    if (!this.state.scenegraph) return;
    this.props._animations && this.state.animator && (this.state.animator.animate(t.timeline.getTime()), this.setNeedsRedraw());
    const {
      viewport: n,
      renderPass: i
    } = this.context, {
      sizeScale: s,
      sizeMinPixels: l,
      sizeMaxPixels: o,
      coordinateSystem: d
    } = this.props, m = this.getNumInstances();
    this.state.scenegraph.traverse((b, A) => {
      let {
        worldMatrix: M
      } = A;
      if (b instanceof dv) {
        const {
          model: E
        } = b;
        E.setInstanceCount(m);
        const k = {
          // Needed for PBR (TODO: find better way to get it)
          camera: E.uniforms.cameraPosition
        }, U = {
          sizeScale: s,
          sizeMinPixels: l,
          sizeMaxPixels: o,
          composeModelMatrix: OI(n, d),
          sceneModelMatrix: M
        };
        E.shaderInputs.setProps({
          pbrProjection: k,
          scenegraph: U
        }), E.draw(i);
      }
    });
  }
}
ux.defaultProps = rH;
ux.layerName = "ScenegraphLayer";
const eS = `uniform meshUniforms {
  bool pickFeatureIds;
} mesh;
`, nH = {
  name: "mesh",
  vs: eS,
  fs: eS,
  uniformTypes: {
    pickFeatureIds: "f32"
  }
}, iH = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec4 uvRegions;
in vec3 featureIdsPickingColors;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;
vec2 applyUVRegion(vec2 uv) {
#ifdef HAS_UV_REGIONS
return fract(uv) * (uvRegions.zw - uvRegions.xy) + uvRegions.xy;
#else
return uv;
#endif
}
void main(void) {
vec2 uv = applyUVRegion(texCoords);
geometry.uv = uv;
if (mesh.pickFeatureIds) {
geometry.pickingColor = featureIdsPickingColors;
} else {
geometry.pickingColor = instancePickingColors;
}
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vTexCoord = uv;
cameraPosition = project.cameraPosition;
vColor = vec4(colors * instanceColors.rgb, instanceColors.a);
vec3 pos = (instanceModelMatrix * positions) * simpleMesh.sizeScale;
vec3 projectedPosition = project_position(positions);
position_commonspace = vec4(projectedPosition, 1.0);
gl_Position = project_common_position_to_clipspace(position_commonspace);
geometry.position = position_commonspace;
normals_commonspace = project_normal(instanceModelMatrix * normals);
geometry.normal = normals_commonspace;
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
#ifdef MODULE_PBRMATERIAL
pbr_vPosition = geometry.position.xyz;
#ifdef HAS_NORMALS
pbr_vNormal = geometry.normal;
#endif
#ifdef HAS_UV
pbr_vUV = uv;
#else
pbr_vUV = vec2(0., 0.);
#endif
geometry.uv = pbr_vUV;
#endif
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, sH = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs
precision highp float;
uniform sampler2D sampler;
in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
#ifdef MODULE_PBRMATERIAL
fragColor = vColor * pbr_filterColor(vec4(0));
geometry.uv = pbr_vUV;
fragColor.a *= layer.opacity;
#else
geometry.uv = vTexCoord;
vec3 normal;
if (simpleMesh.flatShading) {
normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
} else {
normal = normals_commonspace;
}
vec4 color = simpleMesh.hasTexture ? texture(sampler, vTexCoord) : vColor;
vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
fragColor = vec4(lightColor, color.a * layer.opacity);
#endif
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;
function oH(r) {
  const e = r.positions || r.POSITION, t = e.value.length / e.size;
  r.COLOR_0 || r.colors || (r.colors = {
    size: 4,
    value: new Uint8Array(t * 4).fill(255),
    normalized: !0
  });
}
const aH = {
  pbrMaterial: {
    type: "object",
    value: null
  },
  featureIds: {
    type: "array",
    value: null,
    optional: !0
  }
};
class hx extends nx {
  getShaders() {
    const e = super.getShaders();
    return e.modules.push(F2, nH), {
      ...e,
      vs: iH,
      fs: sH
    };
  }
  initializeState() {
    const {
      featureIds: e
    } = this.props;
    super.initializeState();
    const t = this.getAttributeManager();
    e && t.add({
      featureIdsPickingColors: {
        type: "uint8",
        size: 3,
        noAlloc: !0,
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateFeatureIdsPickingColors
      }
    });
  }
  updateState(e) {
    super.updateState(e);
    const {
      props: t,
      oldProps: n
    } = e;
    t.pbrMaterial !== n.pbrMaterial && this.updatePbrMaterialUniforms(t.pbrMaterial);
  }
  draw(e) {
    const {
      featureIds: t
    } = this.props, {
      model: n
    } = this.state;
    if (!n)
      return;
    const i = {
      pickFeatureIds: !!t
    }, s = {
      // Needed for PBR (TODO: find better way to get it)
      camera: n.uniforms.cameraPosition
    };
    n.shaderInputs.setProps({
      pbrProjection: s,
      mesh: i
    }), super.draw(e);
  }
  getModel(e) {
    const {
      id: t
    } = this.props, n = this.parseMaterial(this.props.pbrMaterial, e);
    this.setState({
      parsedPBRMaterial: n
    });
    const i = this.getShaders();
    return oH(e.attributes), new Xh(this.context.device, {
      ...this.getShaders(),
      id: t,
      geometry: e,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      defines: {
        ...i.defines,
        ...n == null ? void 0 : n.defines,
        HAS_UV_REGIONS: e.attributes.uvRegions ? 1 : 0
      },
      parameters: n == null ? void 0 : n.parameters,
      isInstanced: !0
    });
  }
  updatePbrMaterialUniforms(e) {
    const {
      model: t
    } = this.state;
    if (t) {
      const {
        mesh: n
      } = this.props, i = this.parseMaterial(e, n);
      this.setState({
        parsedPBRMaterial: i
      });
      const {
        pbr_baseColorSampler: s
      } = i.bindings, {
        emptyTexture: l
      } = this.state, o = {
        sampler: s || l,
        hasTexture: !!s
      }, {
        camera: d,
        ...m
      } = {
        ...i.bindings,
        ...i.uniforms
      };
      t.shaderInputs.setProps({
        simpleMesh: o,
        pbrMaterial: m
      });
    }
  }
  parseMaterial(e, t) {
    const n = !!(e.pbrMetallicRoughness && e.pbrMetallicRoughness.baseColorTexture);
    return kI(this.context.device, {
      unlit: n,
      ...e
    }, {
      NORMAL: t.attributes.normals,
      TEXCOORD_0: t.attributes.texCoords
    }, {
      pbrDebug: !1,
      lights: !0,
      useTangents: !1
    });
  }
  calculateFeatureIdsPickingColors(e) {
    const t = this.props.featureIds, n = new Uint8ClampedArray(t.length * e.size), i = [];
    for (let s = 0; s < t.length; s++)
      this.encodePickingColor(t[s], i), n[s * 3] = i[0], n[s * 3 + 1] = i[1], n[s * 3 + 2] = i[2];
    e.value = n;
  }
  finalizeState(e) {
    var t;
    super.finalizeState(e), (t = this.state.parsedPBRMaterial) == null || t.generatedTextures.forEach((n) => n.destroy()), this.setState({
      parsedPBRMaterial: null
    });
  }
}
hx.layerName = "MeshLayer";
hx.defaultProps = aH;
const lH = 6378137, cH = 6378137, uH = 6356752314245179e-9;
function qy(r) {
  return r;
}
new Ct();
function hH(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : qy;
  return "longitude" in r ? (e[0] = t(r.longitude), e[1] = t(r.latitude), e[2] = r.height) : "x" in r ? (e[0] = t(r.x), e[1] = t(r.y), e[2] = r.z) : (e[0] = t(r[0]), e[1] = t(r[1]), e[2] = r[2]), e;
}
function fH(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return hH(r, e, no._cartographicRadians ? qy : $k);
}
function dH(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : qy;
  return "longitude" in e ? (e.longitude = t(r[0]), e.latitude = t(r[1]), e.height = r[2]) : "x" in e ? (e.x = t(r[0]), e.y = t(r[1]), e.z = r[2]) : (e[0] = t(r[0]), e[1] = t(r[1]), e[2] = r[2]), e;
}
function pH(r, e) {
  return dH(r, e, no._cartographicRadians ? qy : qk);
}
const tS = 1e-14, gH = new Ct(), rS = {
  up: {
    south: "east",
    north: "west",
    west: "south",
    east: "north"
  },
  down: {
    south: "west",
    north: "east",
    west: "north",
    east: "south"
  },
  south: {
    up: "west",
    down: "east",
    west: "down",
    east: "up"
  },
  north: {
    up: "east",
    down: "west",
    west: "up",
    east: "down"
  },
  west: {
    up: "north",
    down: "south",
    north: "down",
    south: "up"
  },
  east: {
    up: "south",
    down: "north",
    north: "up",
    south: "down"
  }
}, Xb = {
  north: [-1, 0, 0],
  east: [0, 1, 0],
  up: [0, 0, 1],
  south: [1, 0, 0],
  west: [0, -1, 0],
  down: [0, 0, -1]
}, Jp = {
  east: new Ct(),
  north: new Ct(),
  up: new Ct(),
  west: new Ct(),
  south: new Ct(),
  down: new Ct()
}, mH = new Ct(), _H = new Ct(), yH = new Ct();
function nS(r, e, t, n, i, s) {
  const l = rS[e] && rS[e][t];
  Ac(l && (!n || n === l));
  let o, d, m;
  const b = gH.copy(i);
  if (Mc(b.x, 0, tS) && Mc(b.y, 0, tS)) {
    const M = Math.sign(b.z);
    o = mH.fromArray(Xb[e]), e !== "east" && e !== "west" && o.scale(M), d = _H.fromArray(Xb[t]), t !== "east" && t !== "west" && d.scale(M), m = yH.fromArray(Xb[n]), n !== "east" && n !== "west" && m.scale(M);
  } else {
    const {
      up: M,
      east: E,
      north: k
    } = Jp;
    E.set(-b.y, b.x, 0).normalize(), r.geodeticSurfaceNormal(b, M), k.copy(M).cross(E);
    const {
      down: U,
      west: V,
      south: q
    } = Jp;
    U.copy(M).scale(-1), V.copy(E).scale(-1), q.copy(k).scale(-1), o = Jp[e], d = Jp[t], m = Jp[n];
  }
  return s[0] = o.x, s[1] = o.y, s[2] = o.z, s[3] = 0, s[4] = d.x, s[5] = d.y, s[6] = d.z, s[7] = 0, s[8] = m.x, s[9] = m.y, s[10] = m.z, s[11] = 0, s[12] = b.x, s[13] = b.y, s[14] = b.z, s[15] = 1, s;
}
const Cd = new Ct(), bH = new Ct(), vH = new Ct();
function xH(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  const {
    oneOverRadii: n,
    oneOverRadiiSquared: i,
    centerToleranceSquared: s
  } = e;
  Cd.from(r);
  const l = Cd.x, o = Cd.y, d = Cd.z, m = n.x, b = n.y, A = n.z, M = l * l * m * m, E = o * o * b * b, k = d * d * A * A, U = M + E + k, V = Math.sqrt(1 / U);
  if (!Number.isFinite(V))
    return;
  const q = bH;
  if (q.copy(r).scale(V), U < s)
    return q.to(t);
  const Y = i.x, re = i.y, Z = i.z, K = vH;
  K.set(q.x * Y * 2, q.y * re * 2, q.z * Z * 2);
  let ie = (1 - V) * Cd.len() / (0.5 * K.len()), be = 0, he, Be, ke, pe;
  do {
    ie -= be, he = 1 / (1 + ie * Y), Be = 1 / (1 + ie * re), ke = 1 / (1 + ie * Z);
    const me = he * he, je = Be * Be, Pe = ke * ke, St = me * he, Mt = je * Be, Lt = Pe * ke;
    pe = M * me + E * je + k * Pe - 1;
    const zt = -2 * (M * St * Y + E * Mt * re + k * Lt * Z);
    be = pe / zt;
  } while (Math.abs(pe) > cD);
  return Cd.scale([he, Be, ke]).to(t);
}
const Xm = new Ct(), iS = new Ct(), wH = new Ct(), pc = new Ct(), AH = new Ct(), Zm = new Ct();
class Pi {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    this.centerToleranceSquared = lD, Ac(e >= 0), Ac(t >= 0), Ac(n >= 0), this.radii = new Ct(e, t, n), this.radiiSquared = new Ct(e * e, t * t, n * n), this.radiiToTheFourth = new Ct(e * e * e * e, t * t * t * t, n * n * n * n), this.oneOverRadii = new Ct(e === 0 ? 0 : 1 / e, t === 0 ? 0 : 1 / t, n === 0 ? 0 : 1 / n), this.oneOverRadiiSquared = new Ct(e === 0 ? 0 : 1 / (e * e), t === 0 ? 0 : 1 / (t * t), n === 0 ? 0 : 1 / (n * n)), this.minimumRadius = Math.min(e, t, n), this.maximumRadius = Math.max(e, t, n), this.radiiSquared.z !== 0 && (this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z), Object.freeze(this);
  }
  /** Compares this Ellipsoid against the provided Ellipsoid componentwise */
  equals(e) {
    return this === e || !!(e && this.radii.equals(e.radii));
  }
  /** Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'. */
  toString() {
    return this.radii.toString();
  }
  cartographicToCartesian(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    const n = iS, i = wH, [, , s] = e;
    this.geodeticSurfaceNormalCartographic(e, n), i.copy(this.radiiSquared).scale(n);
    const l = Math.sqrt(n.dot(i));
    return i.scale(1 / l), n.scale(s), i.add(n), i.to(t);
  }
  cartesianToCartographic(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    Zm.from(e);
    const n = this.scaleToGeodeticSurface(Zm, pc);
    if (!n)
      return;
    const i = this.geodeticSurfaceNormal(n, iS), s = AH;
    s.copy(Zm).subtract(n);
    const l = Math.atan2(i.y, i.x), o = Math.asin(i.z), d = Math.sign(L2(s, Zm)) * i5(s);
    return pH([l, o, d], t);
  }
  eastNorthUpToFixedFrame(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Bn();
    return nS(this, "east", "north", "up", e, t);
  }
  // Computes a 4x4 transformation matrix from a reference frame centered at
  // the provided origin to the ellipsoid's fixed reference frame.
  localFrameToFixedFrame(e, t, n, i) {
    let s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : new Bn();
    return nS(this, e, t, n, i, s);
  }
  geocentricSurfaceNormal(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    return Xm.from(e).normalize().to(t);
  }
  geodeticSurfaceNormalCartographic(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    const n = fH(e), i = n[0], s = n[1], l = Math.cos(s);
    return Xm.set(l * Math.cos(i), l * Math.sin(i), Math.sin(s)).normalize(), Xm.to(t);
  }
  geodeticSurfaceNormal(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    return Xm.from(e).scale(this.oneOverRadiiSquared).normalize().to(t);
  }
  /** Scales the provided Cartesian position along the geodetic surface normal
   * so that it is on the surface of this ellipsoid.  If the position is
   * at the center of the ellipsoid, this function returns undefined. */
  scaleToGeodeticSurface(e, t) {
    return xH(e, this, t);
  }
  /** Scales the provided Cartesian position along the geocentric surface normal
   * so that it is on the surface of this ellipsoid. */
  scaleToGeocentricSurface(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    pc.from(e);
    const n = pc.x, i = pc.y, s = pc.z, l = this.oneOverRadiiSquared, o = 1 / Math.sqrt(n * n * l.x + i * i * l.y + s * s * l.z);
    return pc.multiplyScalar(o).to(t);
  }
  /** Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying
   * its components by the result of `Ellipsoid#oneOverRadii` */
  transformPositionToScaledSpace(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    return pc.from(e).scale(this.oneOverRadii).to(t);
  }
  /** Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying
   * its components by the result of `Ellipsoid#radii`. */
  transformPositionFromScaledSpace(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    return pc.from(e).scale(this.radii).to(t);
  }
  /** Computes a point which is the intersection of the surface normal with the z-axis. */
  getSurfaceNormalIntersectionWithZAxis(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [0, 0, 0];
    Ac(Mc(this.radii.x, this.radii.y, g5)), Ac(this.radii.z > 0), pc.from(e);
    const i = pc.z * (1 - this.squaredXOverSquaredZ);
    if (!(Math.abs(i) >= this.radii.z - t))
      return pc.set(0, 0, i).to(n);
  }
}
Pi.WGS84 = new Pi(lH, cH, uH);
class TH {
  constructor(e, t, n) {
    H(this, "item");
    H(this, "previous");
    H(this, "next");
    this.item = e, this.previous = t, this.next = n;
  }
}
class SH {
  constructor() {
    H(this, "head", null);
    H(this, "tail", null);
    H(this, "_length", 0);
  }
  get length() {
    return this._length;
  }
  /**
   * Adds the item to the end of the list
   * @param {*} [item]
   * @return {DoublyLinkedListNode}
   */
  add(e) {
    const t = new TH(e, this.tail, null);
    return this.tail ? (this.tail.next = t, this.tail = t) : (this.head = t, this.tail = t), ++this._length, t;
  }
  /**
   * Removes the given node from the list
   * @param {DoublyLinkedListNode} node
   */
  remove(e) {
    e && (e.previous && e.next ? (e.previous.next = e.next, e.next.previous = e.previous) : e.previous ? (e.previous.next = null, this.tail = e.previous) : e.next ? (e.next.previous = null, this.head = e.next) : (this.head = null, this.tail = null), e.next = null, e.previous = null, --this._length);
  }
  /**
   * Moves nextNode after node
   * @param {DoublyLinkedListNode} node
   * @param {DoublyLinkedListNode} nextNode
   */
  splice(e, t) {
    e !== t && (this.remove(t), this._insert(e, t));
  }
  _insert(e, t) {
    const n = e.next;
    e.next = t, this.tail === e ? this.tail = t : n.previous = t, t.next = n, t.previous = e, ++this._length;
  }
}
class EH {
  constructor() {
    H(this, "_list");
    H(this, "_sentinel");
    H(this, "_trimTiles");
    this._list = new SH(), this._sentinel = this._list.add("sentinel"), this._trimTiles = !1;
  }
  reset() {
    this._list.splice(this._list.tail, this._sentinel);
  }
  touch(e) {
    const t = e._cacheNode;
    t && this._list.splice(this._sentinel, t);
  }
  add(e, t, n) {
    t._cacheNode || (t._cacheNode = this._list.add(t), n && n(e, t));
  }
  unloadTile(e, t, n) {
    const i = t._cacheNode;
    i && (this._list.remove(i), t._cacheNode = null, n && n(e, t));
  }
  unloadTiles(e, t) {
    const n = this._trimTiles;
    this._trimTiles = !1;
    const i = this._list, s = e.maximumMemoryUsage * 1024 * 1024, l = this._sentinel;
    let o = i.head;
    for (; o !== l && (e.gpuMemoryUsageInBytes > s || n); ) {
      const d = o.item;
      o = o.next, this.unloadTile(e, d, t);
    }
  }
  trim() {
    this._trimTiles = !0;
  }
}
function CH(r, e) {
  Mi(r), Mi(e);
  const {
    rtcCenter: t,
    gltfUpAxis: n
  } = e, {
    computedTransform: i,
    boundingVolume: {
      center: s
    }
  } = r;
  let l = new Bn(i);
  switch (t && l.translate(t), n) {
    case "Z":
      break;
    case "Y":
      const A = new Bn().rotateX(Math.PI / 2);
      l = l.multiplyRight(A);
      break;
    case "X":
      const M = new Bn().rotateY(-Math.PI / 2);
      l = l.multiplyRight(M);
      break;
  }
  e.isQuantized && l.translate(e.quantizedVolumeOffset).scale(e.quantizedVolumeScale);
  const o = new Ct(s);
  e.cartesianModelMatrix = l, e.cartesianOrigin = o;
  const d = Pi.WGS84.cartesianToCartographic(o, new Ct()), b = Pi.WGS84.eastNorthUpToFixedFrame(o).invert();
  e.cartographicModelMatrix = b.multiplyRight(l), e.cartographicOrigin = d, e.coordinateSystem || (e.modelMatrix = e.cartographicModelMatrix);
}
const sS = new Ct(), Zb = new Ct(), Mv = new Ol([new fu(), new fu(), new fu(), new fu(), new fu(), new fu()]);
function IH(r, e) {
  const {
    cameraDirection: t,
    cameraUp: n,
    height: i
  } = r, {
    metersPerUnit: s
  } = r.distanceScales, l = b_(r, r.center), o = Pi.WGS84.eastNorthUpToFixedFrame(l), d = r.unprojectPosition(r.cameraPosition), m = Pi.WGS84.cartographicToCartesian(d, new Ct()), b = new Ct(
    // @ts-ignore
    o.transformAsVector(new Ct(t).scale(s))
  ).normalize(), A = new Ct(
    // @ts-ignore
    o.transformAsVector(new Ct(n).scale(s))
  ).normalize();
  PH(r);
  const M = r.constructor, {
    longitude: E,
    latitude: k,
    width: U,
    bearing: V,
    zoom: q
  } = r, Y = new M({
    longitude: E,
    latitude: k,
    height: i,
    width: U,
    bearing: V,
    zoom: q,
    pitch: 0
  });
  return {
    camera: {
      position: m,
      direction: b,
      up: A
    },
    viewport: r,
    topDownViewport: Y,
    height: i,
    cullingVolume: Mv,
    frameNumber: e,
    // TODO: This can be the same between updates, what number is unique for between updates?
    sseDenominator: 1.15
    // Assumes fovy = 60 degrees
  };
}
function MH(r, e, t) {
  if (t === 0 || r.length <= t)
    return [r, []];
  const n = [], {
    longitude: i,
    latitude: s
  } = e.viewport;
  for (const [m, b] of r.entries()) {
    const [A, M] = b.header.mbs, E = Math.abs(i - A), k = Math.abs(s - M), U = Math.sqrt(k * k + E * E);
    n.push([m, U]);
  }
  const l = n.sort((m, b) => m[1] - b[1]), o = [];
  for (let m = 0; m < t; m++)
    o.push(r[l[m][0]]);
  const d = [];
  for (let m = t; m < l.length; m++)
    d.push(r[l[m][0]]);
  return [o, d];
}
function PH(r) {
  const e = r.getFrustumPlanes(), t = oS(e.near, r.cameraPosition), n = b_(r, t), i = b_(r, r.cameraPosition, Zb);
  let s = 0;
  Mv.planes[s++].fromPointNormal(n, sS.copy(n).subtract(i));
  for (const l in e) {
    if (l === "near")
      continue;
    const o = e[l], d = oS(o, t, Zb), m = b_(r, d, Zb);
    Mv.planes[s++].fromPointNormal(
      m,
      // Want the normal to point into the frustum since that's what culling expects
      sS.copy(n).subtract(m)
    );
  }
}
function oS(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Ct();
  const n = r.normal.dot(e);
  return t.copy(r.normal).scale(r.distance - n).add(e), t;
}
function b_(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Ct();
  const n = r.unprojectPosition(e);
  return Pi.WGS84.cartographicToCartesian(n, t);
}
const RH = 6378137, BH = 6378137, Pv = 6356752314245179e-9, Vd = new Ct();
function LH(r, e) {
  if (r instanceof Qg) {
    const {
      halfAxes: t
    } = r, n = kH(t);
    return Math.log2(Pv / (n + e[2]));
  } else if (r instanceof Jg) {
    const {
      radius: t
    } = r;
    return Math.log2(Pv / (t + e[2]));
  } else if (r.width && r.height) {
    const {
      width: t,
      height: n
    } = r, i = Math.log2(RH / t), s = Math.log2(BH / n);
    return (i + s) / 2;
  }
  return 1;
}
function nM(r, e, t) {
  Pi.WGS84.cartographicToCartesian([r.xmax, r.ymax, r.zmax], Vd);
  const n = Math.sqrt(Math.pow(Vd[0] - t[0], 2) + Math.pow(Vd[1] - t[1], 2) + Math.pow(Vd[2] - t[2], 2));
  return Math.log2(Pv / (n + e[2]));
}
function OH(r, e, t) {
  const [n, i, s, l] = r;
  return nM({
    xmax: s,
    ymax: l,
    zmax: 0
  }, e, t);
}
function kH(r) {
  r.getColumn(0, Vd);
  const e = r.getColumn(1), t = r.getColumn(2);
  return Vd.add(e).add(t).len();
}
const fl = {
  UNLOADED: 0,
  // Has never been requested
  LOADING: 1,
  // Is waiting on a pending request
  PROCESSING: 2,
  // Request received.  Contents are being processed for rendering.  Depending on the content, it might make its own requests for external data.
  READY: 3,
  // Ready to render.
  EXPIRED: 4,
  // Is expired and will be unloaded once new content is loaded.
  FAILED: 5
  // Request failed.
};
var Pc;
(function(r) {
  r[r.ADD = 1] = "ADD", r[r.REPLACE = 2] = "REPLACE";
})(Pc || (Pc = {}));
var Qu;
(function(r) {
  r.EMPTY = "empty", r.SCENEGRAPH = "scenegraph", r.POINTCLOUD = "pointcloud", r.MESH = "mesh";
})(Qu || (Qu = {}));
var Ua;
(function(r) {
  r.I3S = "I3S", r.TILES3D = "TILES3D";
})(Ua || (Ua = {}));
var hp;
(function(r) {
  r.GEOMETRIC_ERROR = "geometricError", r.MAX_SCREEN_THRESHOLD = "maxScreenThreshold";
})(hp || (hp = {}));
const NH = {
  USE_OPTIMIZATION: 1
};
function iM(r) {
  return r != null;
}
const ta = new Ct(), v_ = new Ct(), DH = new Ct(), FH = new Ct(), vf = new Ct(), aS = new Ct(), lS = new Ct(), cS = new Ct();
function Yb(r, e, t) {
  if (Mi(r, "3D Tile: boundingVolume must be defined"), r.box)
    return sM(r.box, e, t);
  if (r.region)
    return jH(r.region);
  if (r.sphere)
    return zH(r.sphere, e, t);
  throw new Error("3D Tile: boundingVolume must contain a sphere, region, or box");
}
function UH(r, e) {
  if (r.box)
    return VH(e);
  if (r.region) {
    const [t, n, i, s, l, o] = r.region;
    return [[wc(t), wc(n), l], [wc(i), wc(s), o]];
  }
  if (r.sphere)
    return $H(e);
  throw new Error("Unkown boundingVolume type");
}
function sM(r, e, t) {
  const n = new Ct(r[0], r[1], r[2]);
  e.transform(n, n);
  let i = [];
  if (r.length === 10) {
    const m = r.slice(3, 6), b = new Rg();
    b.fromArray(r, 6);
    const A = new Ct([1, 0, 0]), M = new Ct([0, 1, 0]), E = new Ct([0, 0, 1]);
    A.transformByQuaternion(b), A.scale(m[0]), M.transformByQuaternion(b), M.scale(m[1]), E.transformByQuaternion(b), E.scale(m[2]), i = [...A.toArray(), ...M.toArray(), ...E.toArray()];
  } else
    i = [...r.slice(3, 6), ...r.slice(6, 9), ...r.slice(9, 12)];
  const s = e.transformAsVector(i.slice(0, 3)), l = e.transformAsVector(i.slice(3, 6)), o = e.transformAsVector(i.slice(6, 9)), d = new ms([s[0], s[1], s[2], l[0], l[1], l[2], o[0], o[1], o[2]]);
  return iM(t) ? (t.center = n, t.halfAxes = d, t) : new Qg(n, d);
}
function zH(r, e, t) {
  const n = new Ct(r[0], r[1], r[2]);
  e.transform(n, n);
  const i = e.getScale(v_), s = Math.max(Math.max(i[0], i[1]), i[2]), l = r[3] * s;
  return iM(t) ? (t.center = n, t.radius = l, t) : new Jg(n, l);
}
function jH(r) {
  const [e, t, n, i, s, l] = r, o = Pi.WGS84.cartographicToCartesian([wc(e), wc(i), s], DH), d = Pi.WGS84.cartographicToCartesian([wc(n), wc(t), l], FH), m = new Ct().addVectors(o, d).multiplyByScalar(0.5);
  return Pi.WGS84.cartesianToCartographic(m, vf), Pi.WGS84.cartographicToCartesian([wc(n), vf[1], vf[2]], aS), Pi.WGS84.cartographicToCartesian([vf[0], wc(i), vf[2]], lS), Pi.WGS84.cartographicToCartesian([vf[0], vf[1], l], cS), sM([...m, ...aS.subtract(m), ...lS.subtract(m), ...cS.subtract(m)], new Bn());
}
function VH(r) {
  const e = oM(), {
    halfAxes: t
  } = r, n = new Ct(t.getColumn(0)), i = new Ct(t.getColumn(1)), s = new Ct(t.getColumn(2));
  for (let l = 0; l < 2; l++) {
    for (let o = 0; o < 2; o++) {
      for (let d = 0; d < 2; d++)
        ta.copy(r.center), ta.add(n), ta.add(i), ta.add(s), aM(e, ta), s.negate();
      i.negate();
    }
    n.negate();
  }
  return e;
}
function $H(r) {
  const e = oM(), {
    center: t,
    radius: n
  } = r, i = Pi.WGS84.scaleToGeodeticSurface(t, ta);
  let s;
  i ? s = Pi.WGS84.geodeticSurfaceNormal(i) : s = new Ct(0, 0, 1);
  let l = new Ct(s[2], -s[1], 0);
  l.len() > 0 ? l.normalize() : l = new Ct(0, 1, 0);
  const o = l.clone().cross(s);
  for (const d of [l, o, s]) {
    v_.copy(d).scale(n);
    for (let m = 0; m < 2; m++)
      ta.copy(t), ta.add(v_), aM(e, ta), v_.negate();
  }
  return e;
}
function oM() {
  return [[1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]];
}
function aM(r, e) {
  Pi.WGS84.cartesianToCartographic(e, ta), r[0][0] = Math.min(r[0][0], ta[0]), r[0][1] = Math.min(r[0][1], ta[1]), r[0][2] = Math.min(r[0][2], ta[2]), r[1][0] = Math.max(r[1][0], ta[0]), r[1][1] = Math.max(r[1][1], ta[1]), r[1][2] = Math.max(r[1][2], ta[2]);
}
new Ct();
new Ct();
new Bn();
new Ct();
new Ct();
new Ct();
function qH(r, e) {
  const t = r * e;
  return 1 - Math.exp(-(t * t));
}
function GH(r, e) {
  if (r.dynamicScreenSpaceError && r.dynamicScreenSpaceErrorComputedDensity) {
    const t = r.dynamicScreenSpaceErrorComputedDensity, n = r.dynamicScreenSpaceErrorFactor;
    return qH(e, t) * n;
  }
  return 0;
}
function HH(r, e, t) {
  const n = r.tileset, i = r.parent && r.parent.lodMetricValue || r.lodMetricValue, s = t ? i : r.lodMetricValue;
  if (s === 0)
    return 0;
  const l = Math.max(r._distanceToCamera, 1e-7), {
    height: o,
    sseDenominator: d
  } = e, {
    viewDistanceScale: m
  } = n.options;
  let b = s * o * (m || 1) / (l * d);
  return b -= GH(n, l), b;
}
const Kb = new Ct(), uS = new Ct(), Bh = new Ct(), hS = new Ct(), WH = new Ct(), Jb = new Bn(), fS = new Bn();
function XH(r, e) {
  if (r.lodMetricValue === 0 || isNaN(r.lodMetricValue))
    return "DIG";
  const t = 2 * lM(r, e);
  return t < 2 ? "OUT" : !r.header.children || t <= r.lodMetricValue ? "DRAW" : r.header.children ? "DIG" : "OUT";
}
function lM(r, e) {
  const {
    topDownViewport: t
  } = e, n = r.header.mbs[1], i = r.header.mbs[0], s = r.header.mbs[2], l = r.header.mbs[3], o = [...r.boundingVolume.center], d = t.unprojectPosition(t.cameraPosition);
  Pi.WGS84.cartographicToCartesian(d, Kb), uS.copy(Kb).subtract(o).normalize(), Pi.WGS84.eastNorthUpToFixedFrame(o, Jb), fS.copy(Jb).invert(), Bh.copy(Kb).transform(fS);
  const m = Math.sqrt(Bh[0] * Bh[0] + Bh[1] * Bh[1]), b = m * m / Bh[2];
  hS.copy([Bh[0], Bh[1], b]);
  const M = hS.transform(Jb).subtract(o).normalize(), k = uS.cross(M).normalize().scale(l).add(o), U = Pi.WGS84.cartesianToCartographic(k), V = t.project([i, n, s]), q = t.project(U);
  return WH.copy(V).subtract(q).magnitude();
}
function ZH(r) {
  return {
    assetGltfUpAxis: r.asset && r.asset.gltfUpAxis || "Y"
  };
}
class dS {
  constructor() {
    H(this, "_map", /* @__PURE__ */ new Map());
    H(this, "_array");
    H(this, "_length");
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    this._array = new Array(e), this._length = e;
  }
  /**
   * Gets or sets the length of the array.
   * If the set length is greater than the length of the internal array, the internal array is resized.
   *
   * @memberof ManagedArray.prototype
   * @type Number
   */
  get length() {
    return this._length;
  }
  set length(e) {
    this._length = e, e > this._array.length && (this._array.length = e);
  }
  /**
   * Gets the internal array.
   *
   * @memberof ManagedArray.prototype
   * @type Array
   * @readonly
   */
  get values() {
    return this._array;
  }
  /**
   * Gets the element at an index.
   *
   * @param {Number} index The index to get.
   */
  get(e) {
    return Mi(e < this._array.length), this._array[e];
  }
  /**
   * Sets the element at an index. Resizes the array if index is greater than the length of the array.
   *
   * @param {Number} index The index to set.
   * @param {*} element The element to set at index.
   */
  set(e, t) {
    Mi(e >= 0), e >= this.length && (this.length = e + 1), this._map.has(this._array[e]) && this._map.delete(this._array[e]), this._array[e] = t, this._map.set(t, e);
  }
  delete(e) {
    const t = this._map.get(e);
    t >= 0 && (this._array.splice(t, 1), this._map.delete(e), this.length--);
  }
  /**
   * Returns the last element in the array without modifying the array.
   *
   * @returns {*} The last element in the array.
   */
  peek() {
    return this._array[this._length - 1];
  }
  /**
   * Push an element into the array.
   *
   * @param {*} element The element to push.
   */
  push(e) {
    if (!this._map.has(e)) {
      const t = this.length++;
      this._array[t] = e, this._map.set(e, t);
    }
  }
  /**
   * Pop an element from the array.
   *
   * @returns {*} The last element in the array.
   */
  pop() {
    const e = this._array[--this.length];
    return this._map.delete(e), e;
  }
  /**
   * Resize the internal array if length > _array.length.
   *
   * @param {Number} length The length.
   */
  reserve(e) {
    Mi(e >= 0), e > this._array.length && (this._array.length = e);
  }
  /**
   * Resize the array.
   *
   * @param {Number} length The length.
   */
  resize(e) {
    Mi(e >= 0), this.length = e;
  }
  /**
   * Trim the internal array to the specified length. Defaults to the current length.
   *
   * @param {Number} [length] The length.
   */
  trim(e) {
    e == null && (e = this.length), this._array.length = e;
  }
  reset() {
    this._array = [], this._map = /* @__PURE__ */ new Map(), this._length = 0;
  }
  find(e) {
    return this._map.has(e);
  }
}
const YH = {
  loadSiblings: !1,
  skipLevelOfDetail: !1,
  updateTransforms: !0,
  onTraversalEnd: () => {
  },
  viewportTraversersMap: {},
  basePath: ""
};
class Gy {
  // TODO nested props
  constructor(e) {
    H(this, "options");
    // fulfill in traverse call
    H(this, "root", null);
    // tiles should be rendered
    H(this, "selectedTiles", {});
    // tiles should be loaded from server
    H(this, "requestedTiles", {});
    // tiles does not have render content
    H(this, "emptyTiles", {});
    H(this, "lastUpdate", (/* @__PURE__ */ new Date()).getTime());
    H(this, "updateDebounceTime", 1e3);
    /** temporary storage to hold the traversed tiles during a traversal */
    H(this, "_traversalStack", new dS());
    H(this, "_emptyTraversalStack", new dS());
    /** set in every traverse cycle */
    H(this, "_frameNumber", null);
    this.options = {
      ...YH,
      ...e
    };
  }
  // RESULT
  traversalFinished(e) {
    return !0;
  }
  // tiles should be visible
  traverse(e, t, n) {
    this.root = e, this.options = {
      ...this.options,
      ...n
    }, this.reset(), this.updateTile(e, t), this._frameNumber = t.frameNumber, this.executeTraversal(e, t);
  }
  reset() {
    this.requestedTiles = {}, this.selectedTiles = {}, this.emptyTiles = {}, this._traversalStack.reset(), this._emptyTraversalStack.reset();
  }
  /**
   * Execute traverse
   * Depth-first traversal that traverses all visible tiles and marks tiles for selection.
   * If skipLevelOfDetail is off then a tile does not refine until all children are loaded.
   * This is the traditional replacement refinement approach and is called the base traversal.
   * Tiles that have a greater screen space error than the base screen space error are part of the base traversal,
   * all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree
   * and rendering children and parent tiles simultaneously.
   */
  /* eslint-disable-next-line complexity, max-statements */
  executeTraversal(e, t) {
    const n = this._traversalStack;
    for (e._selectionDepth = 1, n.push(e); n.length > 0; ) {
      const s = n.pop();
      let l = !1;
      this.canTraverse(s, t) && (this.updateChildTiles(s, t), l = this.updateAndPushChildren(s, t, n, s.hasRenderContent ? s._selectionDepth + 1 : s._selectionDepth));
      const o = s.parent, d = !!(!o || o._shouldRefine), m = !l;
      s.hasRenderContent ? s.refine === Pc.ADD ? (this.loadTile(s, t), this.selectTile(s, t)) : s.refine === Pc.REPLACE && (this.loadTile(s, t), m && this.selectTile(s, t)) : (this.emptyTiles[s.id] = s, this.loadTile(s, t), m && this.selectTile(s, t)), this.touchTile(s, t), s._shouldRefine = l && d;
    }
    const i = (/* @__PURE__ */ new Date()).getTime();
    (this.traversalFinished(t) || i - this.lastUpdate > this.updateDebounceTime) && (this.lastUpdate = i, this.options.onTraversalEnd(t));
  }
  updateChildTiles(e, t) {
    const n = e.children;
    for (const i of n)
      this.updateTile(i, t);
  }
  /* eslint-disable complexity, max-statements */
  updateAndPushChildren(e, t, n, i) {
    const {
      loadSiblings: s,
      skipLevelOfDetail: l
    } = this.options, o = e.children;
    o.sort(this.compareDistanceToCamera.bind(this));
    const d = e.refine === Pc.REPLACE && e.hasRenderContent && !l;
    let m = !1, b = !0;
    for (const A of o)
      if (A._selectionDepth = i, A.isVisibleAndInRequestVolume ? (n.find(A) && n.delete(A), n.push(A), m = !0) : (d || s) && (this.loadTile(A, t), this.touchTile(A, t)), d) {
        let M;
        if (A._inRequestVolume ? A.hasRenderContent ? M = A.contentAvailable : M = this.executeEmptyTraversal(A, t) : M = !1, b = b && M, !b)
          return !1;
      }
    return m || (b = !1), b;
  }
  /* eslint-enable complexity, max-statements */
  updateTile(e, t) {
    this.updateTileVisibility(e, t);
  }
  // tile to render in the browser
  selectTile(e, t) {
    this.shouldSelectTile(e) && (e._selectedFrame = t.frameNumber, this.selectedTiles[e.id] = e);
  }
  // tile to load from server
  loadTile(e, t) {
    this.shouldLoadTile(e) && (e._requestedFrame = t.frameNumber, e._priority = e._getPriority(), this.requestedTiles[e.id] = e);
  }
  // cache tile
  touchTile(e, t) {
    e.tileset._cache.touch(e), e._touchedFrame = t.frameNumber;
  }
  // tile should be visible
  // tile should have children
  // tile LoD (level of detail) is not sufficient under current viewport
  canTraverse(e, t) {
    return e.hasChildren ? e.hasTilesetContent ? !e.contentExpired : this.shouldRefine(e, t) : !1;
  }
  shouldLoadTile(e) {
    return e.hasUnloadedContent || e.contentExpired;
  }
  shouldSelectTile(e) {
    return e.contentAvailable && !this.options.skipLevelOfDetail;
  }
  /** Decide if tile LoD (level of detail) is not sufficient under current viewport */
  shouldRefine(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, i = e._screenSpaceError;
    return n && (i = e.getScreenSpaceError(t, !0)), i > e.tileset.memoryAdjustedScreenSpaceError;
  }
  updateTileVisibility(e, t) {
    const n = [];
    if (this.options.viewportTraversersMap)
      for (const i in this.options.viewportTraversersMap)
        this.options.viewportTraversersMap[i] === t.viewport.id && n.push(i);
    else
      n.push(t.viewport.id);
    e.updateVisibility(t, n);
  }
  // UTILITIES
  compareDistanceToCamera(e, t) {
    return e._distanceToCamera - t._distanceToCamera;
  }
  anyChildrenVisible(e, t) {
    let n = !1;
    for (const i of e.children)
      i.updateVisibility(t), n = n || i.isVisibleAndInRequestVolume;
    return n;
  }
  // Depth-first traversal that checks if all nearest descendants with content are loaded.
  // Ignores visibility.
  executeEmptyTraversal(e, t) {
    let n = !0;
    const i = this._emptyTraversalStack;
    for (i.push(e); i.length > 0; ) {
      const s = i.pop(), l = !s.hasRenderContent && this.canTraverse(s, t), o = !s.hasRenderContent && s.children.length === 0;
      if (!l && !s.contentAvailable && !o && (n = !1), this.updateTile(s, t), s.isVisibleAndInRequestVolume || (this.loadTile(s, t), this.touchTile(s, t)), l) {
        const d = s.children;
        for (const m of d)
          i.push(m);
      }
    }
    return n;
  }
}
const pS = new Ct();
function KH(r) {
  return r != null;
}
class Rv {
  // TODO i3s specific, needs to remove
  /**
   * @constructs
   * Create a Tile3D instance
   * @param tileset - Tileset3D instance
   * @param header - tile header - JSON loaded from a dataset
   * @param parentHeader - parent Tile3D instance
   * @param extendedId - optional ID to separate copies of a tile for different viewports.
   *    const extendedId = `${tile.id}-${frameState.viewport.id}`;
   */
  // eslint-disable-next-line max-statements
  constructor(e, t, n) {
    H(this, "tileset");
    H(this, "header");
    H(this, "id");
    H(this, "url");
    H(this, "parent");
    /* Specifies the type of refine that is used when traversing this tile for rendering. */
    H(this, "refine");
    H(this, "type");
    H(this, "contentUrl");
    /** Different refinement algorithms used by I3S and 3D tiles */
    H(this, "lodMetricType", "geometricError");
    /** The error, in meters, introduced if this tile is rendered and its children are not. */
    H(this, "lodMetricValue", 0);
    /** @todo math.gl is not exporting BoundingVolume base type? */
    H(this, "boundingVolume", null);
    /**
     * The tile's content.  This represents the actual tile's payload,
     * not the content's metadata in the tileset JSON file.
     */
    H(this, "content", null);
    H(this, "contentState", fl.UNLOADED);
    H(this, "gpuMemoryUsageInBytes", 0);
    /** The tile's children - an array of Tile3D objects. */
    H(this, "children", []);
    H(this, "depth", 0);
    H(this, "viewportIds", []);
    H(this, "transform", new Bn());
    H(this, "extensions", null);
    /** TODO Cesium 3d tiles specific */
    H(this, "implicitTiling", null);
    /** Container to store application specific data */
    H(this, "userData", {});
    H(this, "computedTransform");
    H(this, "hasEmptyContent", !1);
    H(this, "hasTilesetContent", !1);
    H(this, "traverser", new Gy({}));
    /** Used by TilesetCache */
    H(this, "_cacheNode", null);
    H(this, "_frameNumber", null);
    // TODO Cesium 3d tiles specific
    H(this, "_expireDate", null);
    H(this, "_expiredContent", null);
    H(this, "_boundingBox", void 0);
    /** updated every frame for tree traversal and rendering optimizations: */
    H(this, "_distanceToCamera", 0);
    H(this, "_screenSpaceError", 0);
    H(this, "_visibilityPlaneMask");
    H(this, "_visible", void 0);
    H(this, "_contentBoundingVolume");
    H(this, "_viewerRequestVolume");
    H(this, "_initialTransform", new Bn());
    // Used by traverser, cannot be marked private
    H(this, "_priority", 0);
    H(this, "_selectedFrame", 0);
    H(this, "_requestedFrame", 0);
    H(this, "_selectionDepth", 0);
    H(this, "_touchedFrame", 0);
    H(this, "_centerZDepth", 0);
    H(this, "_shouldRefine", !1);
    H(this, "_stackLength", 0);
    H(this, "_visitedFrame", 0);
    H(this, "_inRequestVolume", !1);
    H(this, "_lodJudge", null);
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
    this.header = t, this.tileset = e, this.id = i || t.id, this.url = t.url, this.parent = n, this.refine = this._getRefine(t.refine), this.type = t.type, this.contentUrl = t.contentUrl, this._initializeLodMetric(t), this._initializeTransforms(t), this._initializeBoundingVolumes(t), this._initializeContent(t), this._initializeRenderingState(t), Object.seal(this);
  }
  destroy() {
    this.header = null;
  }
  isDestroyed() {
    return this.header === null;
  }
  get selected() {
    return this._selectedFrame === this.tileset._frameNumber;
  }
  get isVisible() {
    return this._visible;
  }
  get isVisibleAndInRequestVolume() {
    return this._visible && this._inRequestVolume;
  }
  /** Returns true if tile is not an empty tile and not an external tileset */
  get hasRenderContent() {
    return !this.hasEmptyContent && !this.hasTilesetContent;
  }
  /** Returns true if tile has children */
  get hasChildren() {
    return this.children.length > 0 || this.header.children && this.header.children.length > 0;
  }
  /**
   * Determines if the tile's content is ready. This is automatically `true` for
   * tiles with empty content.
   */
  get contentReady() {
    return this.contentState === fl.READY || this.hasEmptyContent;
  }
  /**
   * Determines if the tile has available content to render.  `true` if the tile's
   * content is ready or if it has expired content this renders while new content loads; otherwise,
   */
  get contentAvailable() {
    return !!(this.contentReady && this.hasRenderContent || this._expiredContent && !this.contentFailed);
  }
  /** Returns true if tile has renderable content but it's unloaded */
  get hasUnloadedContent() {
    return this.hasRenderContent && this.contentUnloaded;
  }
  /**
   * Determines if the tile's content has not be requested. `true` if tile's
   * content has not be requested; otherwise, `false`.
   */
  get contentUnloaded() {
    return this.contentState === fl.UNLOADED;
  }
  /**
   * Determines if the tile's content is expired. `true` if tile's
   * content is expired; otherwise, `false`.
   */
  get contentExpired() {
    return this.contentState === fl.EXPIRED;
  }
  // Determines if the tile's content failed to load.  `true` if the tile's
  // content failed to load; otherwise, `false`.
  get contentFailed() {
    return this.contentState === fl.FAILED;
  }
  /**
   * Distance from the tile's bounding volume center to the camera
   */
  get distanceToCamera() {
    return this._distanceToCamera;
  }
  /**
   * Screen space error for LOD selection
   */
  get screenSpaceError() {
    return this._screenSpaceError;
  }
  /**
   * Get bounding box in cartographic coordinates
   * @returns [min, max] each in [longitude, latitude, altitude]
   */
  get boundingBox() {
    return this._boundingBox || (this._boundingBox = UH(this.header.boundingVolume, this.boundingVolume)), this._boundingBox;
  }
  /** Get the tile's screen space error. */
  getScreenSpaceError(e, t) {
    switch (this.tileset.type) {
      case Ua.I3S:
        return lM(this, e);
      case Ua.TILES3D:
        return HH(this, e, t);
      default:
        throw new Error("Unsupported tileset type");
    }
  }
  /**
   * Make tile unselected than means it won't be shown
   * but it can be still loaded in memory
   */
  unselect() {
    this._selectedFrame = 0;
  }
  /**
   * Memory usage of tile on GPU
   */
  _getGpuMemoryUsageInBytes() {
    return this.content.gpuMemoryUsageInBytes || this.content.byteLength || 0;
  }
  /*
   * If skipLevelOfDetail is off try to load child tiles as soon as possible so that their parent can refine sooner.
   * Tiles are prioritized by screen space error.
   */
  // eslint-disable-next-line complexity
  _getPriority() {
    const e = this.tileset._traverser, {
      skipLevelOfDetail: t
    } = e.options, n = this.refine === Pc.ADD || t;
    if (n && !this.isVisible && this._visible !== void 0 || this.tileset._frameNumber - this._touchedFrame >= 1 || this.contentState === fl.UNLOADED)
      return -1;
    const i = this.parent, l = i && (!n || this._screenSpaceError === 0 || i.hasTilesetContent) ? i._screenSpaceError : this._screenSpaceError, o = e.root ? e.root._screenSpaceError : 0;
    return Math.max(o - l, 0);
  }
  /**
   *  Requests the tile's content.
   * The request may not be made if the Request Scheduler can't prioritize it.
   */
  // eslint-disable-next-line max-statements, complexity
  async loadContent() {
    if (this.hasEmptyContent)
      return !1;
    if (this.content)
      return !0;
    this.contentExpired && (this._expireDate = null), this.contentState = fl.LOADING;
    const t = await this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority.bind(this));
    if (!t)
      return this.contentState = fl.UNLOADED, !1;
    try {
      const n = this.tileset.getTileUrl(this.contentUrl), i = this.tileset.loader, s = {
        ...this.tileset.loadOptions,
        [i.id]: {
          // @ts-expect-error
          ...this.tileset.loadOptions[i.id],
          isTileset: this.type === "json",
          ...this._getLoaderSpecificOptions(i.id)
        }
      };
      return this.content = await Hh(n, i, s), this.tileset.options.contentLoader && await this.tileset.options.contentLoader(this), this._isTileset() && this.tileset._initializeTileHeaders(this.content, this), this.contentState = fl.READY, this._onContentLoaded(), !0;
    } catch (n) {
      throw this.contentState = fl.FAILED, n;
    } finally {
      t.done();
    }
  }
  // Unloads the tile's content.
  unloadContent() {
    return this.content && this.content.destroy && this.content.destroy(), this.content = null, this.header.content && this.header.content.destroy && this.header.content.destroy(), this.header.content = null, this.contentState = fl.UNLOADED, !0;
  }
  /**
   * Update the tile's visibility
   * @param {Object} frameState - frame state for tile culling
   * @param {string[]} viewportIds - a list of viewport ids that show this tile
   * @return {void}
   */
  updateVisibility(e, t) {
    if (this._frameNumber === e.frameNumber)
      return;
    const n = this.parent, i = n ? n._visibilityPlaneMask : Ol.MASK_INDETERMINATE;
    if (this.tileset._traverser.options.updateTransforms) {
      const s = n ? n.computedTransform : this.tileset.modelMatrix;
      this._updateTransform(s);
    }
    this._distanceToCamera = this.distanceToTile(e), this._screenSpaceError = this.getScreenSpaceError(e, !1), this._visibilityPlaneMask = this.visibility(e, i), this._visible = this._visibilityPlaneMask !== Ol.MASK_OUTSIDE, this._inRequestVolume = this.insideViewerRequestVolume(e), this._frameNumber = e.frameNumber, this.viewportIds = t;
  }
  // Determines whether the tile's bounding volume intersects the culling volume.
  // @param {FrameState} frameState The frame state.
  // @param {Number} parentVisibilityPlaneMask The parent's plane mask to speed up the visibility check.
  // @returns {Number} A plane mask as described above in {@link CullingVolume#computeVisibilityWithPlaneMask}.
  visibility(e, t) {
    const {
      cullingVolume: n
    } = e, {
      boundingVolume: i
    } = this;
    return n.computeVisibilityWithPlaneMask(i, t);
  }
  // Assuming the tile's bounding volume intersects the culling volume, determines
  // whether the tile's content's bounding volume intersects the culling volume.
  // @param {FrameState} frameState The frame state.
  // @returns {Intersect} The result of the intersection: the tile's content is completely outside, completely inside, or intersecting the culling volume.
  contentVisibility() {
    return !0;
  }
  /**
   * Computes the (potentially approximate) distance from the closest point of the tile's bounding volume to the camera.
   * @param frameState The frame state.
   * @returns {Number} The distance, in meters, or zero if the camera is inside the bounding volume.
   */
  distanceToTile(e) {
    const t = this.boundingVolume;
    return Math.sqrt(Math.max(t.distanceSquaredTo(e.camera.position), 0));
  }
  /**
   * Computes the tile's camera-space z-depth.
   * @param frameState The frame state.
   * @returns The distance, in meters.
   */
  cameraSpaceZDepth(e) {
    let {
      camera: t
    } = e;
    const n = this.boundingVolume;
    return pS.subVectors(n.center, t.position), t.direction.dot(pS);
  }
  /**
   * Checks if the camera is inside the viewer request volume.
   * @param {FrameState} frameState The frame state.
   * @returns {Boolean} Whether the camera is inside the volume.
   */
  insideViewerRequestVolume(e) {
    const t = this._viewerRequestVolume;
    return !t || t.distanceSquaredTo(e.camera.position) <= 0;
  }
  // TODO Cesium specific
  // Update whether the tile has expired.
  updateExpiration() {
    if (KH(this._expireDate) && this.contentReady && !this.hasEmptyContent) {
      const e = Date.now();
      Date.lessThan(this._expireDate, e) && (this.contentState = fl.EXPIRED, this._expiredContent = this.content);
    }
  }
  get extras() {
    return this.header.extras;
  }
  // INTERNAL METHODS
  _initializeLodMetric(e) {
    "lodMetricType" in e ? this.lodMetricType = e.lodMetricType : (this.lodMetricType = this.parent && this.parent.lodMetricType || this.tileset.lodMetricType, console.warn("3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType")), "lodMetricValue" in e ? this.lodMetricValue = e.lodMetricValue : (this.lodMetricValue = this.parent && this.parent.lodMetricValue || this.tileset.lodMetricValue, console.warn("3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue"));
  }
  _initializeTransforms(e) {
    this.transform = e.transform ? new Bn(e.transform) : new Bn();
    const t = this.parent, n = this.tileset, i = t && t.computedTransform ? t.computedTransform.clone() : n.modelMatrix.clone();
    this.computedTransform = new Bn(i).multiplyRight(this.transform);
    const s = t && t._initialTransform ? t._initialTransform.clone() : new Bn();
    this._initialTransform = new Bn(s).multiplyRight(this.transform);
  }
  _initializeBoundingVolumes(e) {
    this._contentBoundingVolume = null, this._viewerRequestVolume = null, this._updateBoundingVolume(e);
  }
  _initializeContent(e) {
    this.content = {
      _tileset: this.tileset,
      _tile: this
    }, this.hasEmptyContent = !0, this.contentState = fl.UNLOADED, this.hasTilesetContent = !1, e.contentUrl && (this.content = null, this.hasEmptyContent = !1);
  }
  // TODO - remove anything not related to basic visibility detection
  _initializeRenderingState(e) {
    this.depth = e.level || (this.parent ? this.parent.depth + 1 : 0), this._shouldRefine = !1, this._distanceToCamera = 0, this._centerZDepth = 0, this._screenSpaceError = 0, this._visibilityPlaneMask = Ol.MASK_INDETERMINATE, this._visible = void 0, this._inRequestVolume = !1, this._stackLength = 0, this._selectionDepth = 0, this._frameNumber = 0, this._touchedFrame = 0, this._visitedFrame = 0, this._selectedFrame = 0, this._requestedFrame = 0, this._priority = 0;
  }
  _getRefine(e) {
    return e || this.parent && this.parent.refine || Pc.REPLACE;
  }
  _isTileset() {
    return this.contentUrl.indexOf(".json") !== -1;
  }
  _onContentLoaded() {
    switch (this.content && this.content.type) {
      case "vctr":
      case "geom":
        this.tileset._traverser.disableSkipLevelOfDetail = !0;
        break;
    }
    this._isTileset() ? this.hasTilesetContent = !0 : this.gpuMemoryUsageInBytes = this._getGpuMemoryUsageInBytes();
  }
  _updateBoundingVolume(e) {
    this.boundingVolume = Yb(e.boundingVolume, this.computedTransform, this.boundingVolume);
    const t = e.content;
    t && (t.boundingVolume && (this._contentBoundingVolume = Yb(t.boundingVolume, this.computedTransform, this._contentBoundingVolume)), e.viewerRequestVolume && (this._viewerRequestVolume = Yb(e.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume)));
  }
  // Update the tile's transform. The transform is applied to the tile's bounding volumes.
  _updateTransform() {
    const t = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new Bn()).clone().multiplyRight(this.transform);
    t.equals(this.computedTransform) || (this.computedTransform = t, this._updateBoundingVolume(this.header));
  }
  // Get options which are applicable only for the particular loader
  _getLoaderSpecificOptions(e) {
    switch (e) {
      case "i3s":
        return {
          ...this.tileset.options.i3s,
          _tileOptions: {
            attributeUrls: this.header.attributeUrls,
            textureUrl: this.header.textureUrl,
            textureFormat: this.header.textureFormat,
            textureLoaderOptions: this.header.textureLoaderOptions,
            materialDefinition: this.header.materialDefinition,
            isDracoGeometry: this.header.isDracoGeometry,
            mbs: this.header.mbs
          },
          _tilesetOptions: {
            store: this.tileset.tileset.store,
            attributeStorageInfo: this.tileset.tileset.attributeStorageInfo,
            fields: this.tileset.tileset.fields
          },
          isTileHeader: !1
        };
      case "3d-tiles":
      case "cesium-ion":
      default:
        return ZH(this.tileset.tileset);
    }
  }
}
class JH extends Gy {
  compareDistanceToCamera(e, t) {
    return t._distanceToCamera === 0 && e._distanceToCamera === 0 ? t._centerZDepth - e._centerZDepth : t._distanceToCamera - e._distanceToCamera;
  }
  updateTileVisibility(e, t) {
    if (super.updateTileVisibility(e, t), !e.isVisibleAndInRequestVolume)
      return;
    const n = e.children.length > 0;
    if (e.hasTilesetContent && n) {
      const l = e.children[0];
      this.updateTileVisibility(l, t), e._visible = l._visible;
      return;
    }
    if (this.meetsScreenSpaceErrorEarly(e, t)) {
      e._visible = !1;
      return;
    }
    const i = e.refine === Pc.REPLACE, s = e._optimChildrenWithinParent === NH.USE_OPTIMIZATION;
    if (i && s && n && !this.anyChildrenVisible(e, t)) {
      e._visible = !1;
      return;
    }
  }
  meetsScreenSpaceErrorEarly(e, t) {
    const {
      parent: n
    } = e;
    return !n || n.hasTilesetContent || n.refine !== Pc.ADD ? !1 : !this.shouldRefine(e, t, !0);
  }
}
class QH {
  constructor() {
    H(this, "frameNumberMap", /* @__PURE__ */ new Map());
  }
  /**
   * Register a new pending tile header for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   */
  register(e, t) {
    const n = this.frameNumberMap.get(e) || /* @__PURE__ */ new Map(), i = n.get(t) || 0;
    n.set(t, i + 1), this.frameNumberMap.set(e, n);
  }
  /**
   * Deregister a pending tile header for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   */
  deregister(e, t) {
    const n = this.frameNumberMap.get(e);
    if (!n)
      return;
    const i = n.get(t) || 1;
    n.set(t, i - 1);
  }
  /**
   * Check is there are no pending tile headers registered for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   * @returns
   */
  isZero(e, t) {
    var i;
    return (((i = this.frameNumberMap.get(e)) == null ? void 0 : i.get(t)) || 0) === 0;
  }
}
const Qb = {
  REQUESTED: "REQUESTED",
  COMPLETED: "COMPLETED",
  ERROR: "ERROR"
};
class eW {
  constructor() {
    H(this, "_statusMap");
    H(this, "pendingTilesRegister", new QH());
    this._statusMap = {};
  }
  /**
   * Add request to map
   * @param request - node metadata request
   * @param key - unique key
   * @param callback - callback after request completed
   * @param frameState - frameState data
   */
  add(e, t, n, i) {
    if (!this._statusMap[t]) {
      const {
        frameNumber: s,
        viewport: {
          id: l
        }
      } = i;
      this._statusMap[t] = {
        request: e,
        callback: n,
        key: t,
        frameState: i,
        status: Qb.REQUESTED
      }, this.pendingTilesRegister.register(l, s), e().then((o) => {
        this._statusMap[t].status = Qb.COMPLETED;
        const {
          frameNumber: d,
          viewport: {
            id: m
          }
        } = this._statusMap[t].frameState;
        this.pendingTilesRegister.deregister(m, d), this._statusMap[t].callback(o, i);
      }).catch((o) => {
        this._statusMap[t].status = Qb.ERROR;
        const {
          frameNumber: d,
          viewport: {
            id: m
          }
        } = this._statusMap[t].frameState;
        this.pendingTilesRegister.deregister(m, d), n(o);
      });
    }
  }
  /**
   * Update request if it is still actual for the new frameState
   * @param key - unique key
   * @param frameState - frameState data
   */
  update(e, t) {
    if (this._statusMap[e]) {
      const {
        frameNumber: n,
        viewport: {
          id: i
        }
      } = this._statusMap[e].frameState;
      this.pendingTilesRegister.deregister(i, n);
      const {
        frameNumber: s,
        viewport: {
          id: l
        }
      } = t;
      this.pendingTilesRegister.register(l, s), this._statusMap[e].frameState = t;
    }
  }
  /**
   * Find request in the map
   * @param key - unique key
   * @returns
   */
  find(e) {
    return this._statusMap[e];
  }
  /**
   * Check it there are pending tile headers for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   * @returns
   */
  hasPendingTiles(e, t) {
    return !this.pendingTilesRegister.isZero(e, t);
  }
}
class tW extends Gy {
  constructor(t) {
    super(t);
    H(this, "_tileManager");
    this._tileManager = new eW();
  }
  /**
   * Check if there are no penging tile header requests,
   * that means the traversal is finished and we can call
   * following-up callbacks.
   */
  traversalFinished(t) {
    return !this._tileManager.hasPendingTiles(t.viewport.id, this._frameNumber || 0);
  }
  shouldRefine(t, n) {
    return t._lodJudge = XH(t, n), t._lodJudge === "DIG";
  }
  updateChildTiles(t, n) {
    const i = t.header.children || [], s = t.children, l = t.tileset;
    for (const o of i) {
      const d = `${o.id}-${n.viewport.id}`, m = s && s.find((b) => b.id === d);
      if (m)
        m && this.updateTile(m, n);
      else {
        let b = () => this._loadTile(o.id, l);
        this._tileManager.find(d) ? this._tileManager.update(d, n) : (l.tileset.nodePages && (b = () => l.tileset.nodePagesTile.formTileFromNodePages(o.id)), this._tileManager.add(b, d, (M) => this._onTileLoad(M, t, d), n));
      }
    }
    return !1;
  }
  async _loadTile(t, n) {
    const {
      loader: i
    } = n, s = n.getTileUrl(`${n.url}/nodes/${t}`), l = {
      ...n.loadOptions,
      i3s: {
        ...n.loadOptions.i3s,
        isTileHeader: !0
      }
    };
    return await Hh(s, i, l);
  }
  /**
   * The callback to init Tile3D instance after loading the tile JSON
   * @param {Object} header - the tile JSON from a dataset
   * @param {Tile3D} tile - the parent Tile3D instance
   * @param {string} extendedId - optional ID to separate copies of a tile for different viewports.
   *                              const extendedId = `${tile.id}-${frameState.viewport.id}`;
   * @return {void}
   */
  _onTileLoad(t, n, i) {
    const s = new Rv(n.tileset, t, n, i);
    n.children.push(s);
    const l = this._tileManager.find(s.id).frameState;
    this.updateTile(s, l), this._frameNumber === l.frameNumber && (this.traversalFinished(l) || (/* @__PURE__ */ new Date()).getTime() - this.lastUpdate > this.updateDebounceTime) && this.executeTraversal(s, l);
  }
}
const rW = {
  description: "",
  ellipsoid: Pi.WGS84,
  modelMatrix: new Bn(),
  throttleRequests: !0,
  maxRequests: 64,
  /** Default memory values optimized for viewing mesh-based 3D Tiles on both mobile and desktop devices */
  maximumMemoryUsage: 32,
  memoryCacheOverflow: 1,
  maximumTilesSelected: 0,
  debounceTime: 0,
  onTileLoad: () => {
  },
  onTileUnload: () => {
  },
  onTileError: () => {
  },
  onTraversalComplete: (r) => r,
  contentLoader: void 0,
  viewDistanceScale: 1,
  maximumScreenSpaceError: 8,
  memoryAdjustedScreenSpaceError: !1,
  loadTiles: !0,
  updateTransforms: !0,
  viewportTraversersMap: null,
  loadOptions: {
    fetch: {}
  },
  attributions: [],
  basePath: "",
  i3s: {}
}, Ym = "Tiles In Tileset(s)", e1 = "Tiles In Memory", gS = "Tiles In View", mS = "Tiles To Render", _S = "Tiles Loaded", t1 = "Tiles Loading", yS = "Tiles Unloaded", bS = "Failed Tile Loads", vS = "Points/Vertices", r1 = "Tile Memory Use", xS = "Maximum Screen Space Error";
class nW {
  /**
   * Create a new Tileset3D
   * @param json
   * @param props
   */
  // eslint-disable-next-line max-statements
  constructor(e, t) {
    // props: Tileset3DProps;
    H(this, "options");
    H(this, "loadOptions");
    H(this, "type");
    H(this, "tileset");
    H(this, "loader");
    H(this, "url");
    H(this, "basePath");
    H(this, "modelMatrix");
    H(this, "ellipsoid");
    H(this, "lodMetricType");
    H(this, "lodMetricValue");
    H(this, "refine");
    H(this, "root", null);
    H(this, "roots", {});
    /** @todo any->unknown */
    H(this, "asset", {});
    // Metadata for the entire tileset
    H(this, "description", "");
    H(this, "properties");
    H(this, "extras", null);
    H(this, "attributions", {});
    H(this, "credits", {});
    H(this, "stats");
    /** flags that contain information about data types in nested tiles */
    H(this, "contentFormats", {
      draco: !1,
      meshopt: !1,
      dds: !1,
      ktx2: !1
    });
    // view props
    H(this, "cartographicCenter", null);
    H(this, "cartesianCenter", null);
    H(this, "zoom", 1);
    H(this, "boundingVolume", null);
    /** Updated based on the camera position and direction */
    H(this, "dynamicScreenSpaceErrorComputedDensity", 0);
    // METRICS
    /**
     * The maximum amount of GPU memory (in MB) that may be used to cache tiles
     * Tiles not in view are unloaded to enforce private
     */
    H(this, "maximumMemoryUsage", 32);
    /** The total amount of GPU memory in bytes used by the tileset. */
    H(this, "gpuMemoryUsageInBytes", 0);
    /**
     * If loading the level of detail required by maximumScreenSpaceError
     * results in the memory usage exceeding maximumMemoryUsage (GPU), level of detail refinement
     * will instead use this (larger) adjusted screen space error to achieve the
     * best possible visual quality within the available memory.
     */
    H(this, "memoryAdjustedScreenSpaceError", 0);
    H(this, "_cacheBytes", 0);
    H(this, "_cacheOverflowBytes", 0);
    /** Update tracker. increase in each update cycle. */
    H(this, "_frameNumber", 0);
    H(this, "_queryParams", {});
    H(this, "_extensionsUsed", []);
    H(this, "_tiles", {});
    /** counter for tracking tiles requests */
    H(this, "_pendingCount", 0);
    /** Hold traversal results */
    H(this, "selectedTiles", []);
    // TRAVERSAL
    H(this, "traverseCounter", 0);
    H(this, "geometricError", 0);
    H(this, "lastUpdatedVieports", null);
    H(this, "_requestedTiles", []);
    H(this, "_emptyTiles", []);
    H(this, "frameStateData", {});
    H(this, "_traverser");
    H(this, "_cache", new EH());
    H(this, "_requestScheduler");
    // Promise tracking
    H(this, "updatePromise", null);
    H(this, "tilesetInitializationPromise");
    this.options = {
      ...rW,
      ...t
    }, this.tileset = e, this.loader = e.loader, this.type = e.type, this.url = e.url, this.basePath = e.basePath || u2(this.url), this.modelMatrix = this.options.modelMatrix, this.ellipsoid = this.options.ellipsoid, this.lodMetricType = e.lodMetricType, this.lodMetricValue = e.lodMetricValue, this.refine = e.root.refine, this.loadOptions = this.options.loadOptions || {}, this._traverser = this._initializeTraverser(), this._requestScheduler = new NB({
      throttleRequests: this.options.throttleRequests,
      maxRequests: this.options.maxRequests
    }), this.memoryAdjustedScreenSpaceError = this.options.maximumScreenSpaceError, this._cacheBytes = this.options.maximumMemoryUsage * 1024 * 1024, this._cacheOverflowBytes = this.options.memoryCacheOverflow * 1024 * 1024, this.stats = new mp({
      id: this.url
    }), this._initializeStats(), this.tilesetInitializationPromise = this._initializeTileSet(e);
  }
  /** Release resources */
  destroy() {
    this._destroy();
  }
  /** Is the tileset loaded (update needs to have been called at least once) */
  isLoaded() {
    return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;
  }
  get tiles() {
    return Object.values(this._tiles);
  }
  get frameNumber() {
    return this._frameNumber;
  }
  get queryParams() {
    return new URLSearchParams(this._queryParams).toString();
  }
  setProps(e) {
    this.options = {
      ...this.options,
      ...e
    };
  }
  /** @deprecated */
  // setOptions(options: Tileset3DProps): void {
  //   this.options = {...this.options, ...options};
  // }
  /**
   * Return a loadable tile url for a specific tile subpath
   * @param tilePath a tile subpath
   */
  getTileUrl(e) {
    if (e.startsWith("data:"))
      return e;
    let n = e;
    return this.queryParams.length && (n = `${e}${e.includes("?") ? "&" : "?"}${this.queryParams}`), n;
  }
  // TODO CESIUM specific
  hasExtension(e) {
    return this._extensionsUsed.indexOf(e) > -1;
  }
  /**
   * Update visible tiles relying on a list of viewports
   * @param viewports - list of viewports
   * @deprecated
   */
  update() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    this.tilesetInitializationPromise.then(() => {
      !e && this.lastUpdatedVieports ? e = this.lastUpdatedVieports : this.lastUpdatedVieports = e, e && this.doUpdate(e);
    });
  }
  /**
   * Update visible tiles relying on a list of viewports.
   * Do it with debounce delay to prevent update spam
   * @param viewports viewports
   * @returns Promise of new frameNumber
   */
  async selectTiles() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    return await this.tilesetInitializationPromise, e && (this.lastUpdatedVieports = e), this.updatePromise || (this.updatePromise = new Promise((t) => {
      setTimeout(() => {
        this.lastUpdatedVieports && this.doUpdate(this.lastUpdatedVieports), t(this._frameNumber), this.updatePromise = null;
      }, this.options.debounceTime);
    })), this.updatePromise;
  }
  adjustScreenSpaceError() {
    this.gpuMemoryUsageInBytes < this._cacheBytes ? this.memoryAdjustedScreenSpaceError = Math.max(this.memoryAdjustedScreenSpaceError / 1.02, this.options.maximumScreenSpaceError) : this.gpuMemoryUsageInBytes > this._cacheBytes + this._cacheOverflowBytes && (this.memoryAdjustedScreenSpaceError *= 1.02);
  }
  /**
   * Update visible tiles relying on a list of viewports
   * @param viewports viewports
   */
  // eslint-disable-next-line max-statements, complexity
  doUpdate(e) {
    if ("loadTiles" in this.options && !this.options.loadTiles || this.traverseCounter > 0)
      return;
    const t = e instanceof Array ? e : [e];
    this._cache.reset(), this._frameNumber++, this.traverseCounter = t.length;
    const n = [];
    for (const i of t) {
      const s = i.id;
      this._needTraverse(s) ? n.push(s) : this.traverseCounter--;
    }
    for (const i of t) {
      const s = i.id;
      if (this.roots[s] || (this.roots[s] = this._initializeTileHeaders(this.tileset, null)), !n.includes(s))
        continue;
      const l = IH(i, this._frameNumber);
      this._traverser.traverse(this.roots[s], l, this.options);
    }
  }
  /**
   * Check if traversal is needed for particular viewport
   * @param {string} viewportId - id of a viewport
   * @return {boolean}
   */
  _needTraverse(e) {
    let t = e;
    return this.options.viewportTraversersMap && (t = this.options.viewportTraversersMap[e]), t === e;
  }
  /**
   * The callback to post-process tiles after traversal procedure
   * @param frameState - frame state for tile culling
   */
  _onTraversalEnd(e) {
    const t = e.viewport.id;
    this.frameStateData[t] || (this.frameStateData[t] = {
      selectedTiles: [],
      _requestedTiles: [],
      _emptyTiles: []
    });
    const n = this.frameStateData[t], i = Object.values(this._traverser.selectedTiles), [s, l] = MH(i, e, this.options.maximumTilesSelected);
    n.selectedTiles = s;
    for (const o of l)
      o.unselect();
    n._requestedTiles = Object.values(this._traverser.requestedTiles), n._emptyTiles = Object.values(this._traverser.emptyTiles), this.traverseCounter--, !(this.traverseCounter > 0) && this._updateTiles();
  }
  /**
   * Update tiles relying on data from all traversers
   */
  _updateTiles() {
    this.selectedTiles = [], this._requestedTiles = [], this._emptyTiles = [];
    for (const e in this.frameStateData) {
      const t = this.frameStateData[e];
      this.selectedTiles = this.selectedTiles.concat(t.selectedTiles), this._requestedTiles = this._requestedTiles.concat(t._requestedTiles), this._emptyTiles = this._emptyTiles.concat(t._emptyTiles);
    }
    this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);
    for (const e of this.selectedTiles)
      this._tiles[e.id] = e;
    this._loadTiles(), this._unloadTiles(), this._updateStats();
  }
  _tilesChanged(e, t) {
    if (e.length !== t.length)
      return !0;
    const n = new Set(e.map((l) => l.id)), i = new Set(t.map((l) => l.id));
    let s = e.filter((l) => !i.has(l.id)).length > 0;
    return s = s || t.filter((l) => !n.has(l.id)).length > 0, s;
  }
  _loadTiles() {
    for (const e of this._requestedTiles)
      e.contentUnloaded && this._loadTile(e);
  }
  _unloadTiles() {
    this._cache.unloadTiles(this, (e, t) => e._unloadTile(t));
  }
  _updateStats() {
    let e = 0, t = 0;
    for (const n of this.selectedTiles)
      n.contentAvailable && n.content && (e++, n.content.pointCount ? t += n.content.pointCount : t += n.content.vertexCount);
    this.stats.get(gS).count = this.selectedTiles.length, this.stats.get(mS).count = e, this.stats.get(vS).count = t, this.stats.get(xS).count = this.memoryAdjustedScreenSpaceError;
  }
  async _initializeTileSet(e) {
    this.type === Ua.I3S && (this.calculateViewPropsI3S(), e.root = await e.root), this.root = this._initializeTileHeaders(e, null), this.type === Ua.TILES3D && (this._initializeTiles3DTileset(e), this.calculateViewPropsTiles3D()), this.type === Ua.I3S && this._initializeI3STileset();
  }
  /**
   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.
   * These metrics help apps center view on tileset
   * For I3S there is extent (<1.8 version) or fullExtent (>=1.8 version) to calculate view props
   * @returns
   */
  calculateViewPropsI3S() {
    var n;
    const e = this.tileset.fullExtent;
    if (e) {
      const {
        xmin: i,
        xmax: s,
        ymin: l,
        ymax: o,
        zmin: d,
        zmax: m
      } = e;
      this.cartographicCenter = new Ct(i + (s - i) / 2, l + (o - l) / 2, d + (m - d) / 2), this.cartesianCenter = new Ct(), Pi.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter), this.zoom = nM(e, this.cartographicCenter, this.cartesianCenter);
      return;
    }
    const t = (n = this.tileset.store) == null ? void 0 : n.extent;
    if (t) {
      const [i, s, l, o] = t;
      this.cartographicCenter = new Ct(i + (l - i) / 2, s + (o - s) / 2, 0), this.cartesianCenter = new Ct(), Pi.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter), this.zoom = OH(t, this.cartographicCenter, this.cartesianCenter);
      return;
    }
    console.warn("Extent is not defined in the tileset header"), this.cartographicCenter = new Ct(), this.zoom = 1;
  }
  /**
   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.
   * These metrics help apps center view on tileset.
   * For 3DTiles the root tile data is used to calculate view props.
   * @returns
   */
  calculateViewPropsTiles3D() {
    const e = this.root, {
      center: t
    } = e.boundingVolume;
    if (!t) {
      console.warn("center was not pre-calculated for the root tile"), this.cartographicCenter = new Ct(), this.zoom = 1;
      return;
    }
    t[0] !== 0 || t[1] !== 0 || t[2] !== 0 ? (this.cartographicCenter = new Ct(), Pi.WGS84.cartesianToCartographic(t, this.cartographicCenter)) : this.cartographicCenter = new Ct(0, 0, -Pi.WGS84.radii[0]), this.cartesianCenter = t, this.zoom = LH(e.boundingVolume, this.cartographicCenter);
  }
  _initializeStats() {
    this.stats.get(Ym), this.stats.get(t1), this.stats.get(e1), this.stats.get(gS), this.stats.get(mS), this.stats.get(_S), this.stats.get(yS), this.stats.get(bS), this.stats.get(vS), this.stats.get(r1, "memory"), this.stats.get(xS);
  }
  // Installs the main tileset JSON file or a tileset JSON file referenced from a tile.
  // eslint-disable-next-line max-statements
  _initializeTileHeaders(e, t) {
    var i;
    const n = new Rv(this, e.root, t);
    if (t && (t.children.push(n), n.depth = t.depth + 1), this.type === Ua.TILES3D) {
      const s = [];
      for (s.push(n); s.length > 0; ) {
        const l = s.pop();
        this.stats.get(Ym).incrementCount();
        const o = l.header.children || [];
        for (const d of o) {
          const m = new Rv(this, d, l);
          if ((i = m.contentUrl) != null && i.includes("?session=")) {
            const A = new URL(m.contentUrl).searchParams.get("session");
            A && (this._queryParams.session = A);
          }
          l.children.push(m), m.depth = l.depth + 1, s.push(m);
        }
      }
    }
    return n;
  }
  _initializeTraverser() {
    let e;
    switch (this.type) {
      case Ua.TILES3D:
        e = JH;
        break;
      case Ua.I3S:
        e = tW;
        break;
      default:
        e = Gy;
    }
    return new e({
      basePath: this.basePath,
      onTraversalEnd: this._onTraversalEnd.bind(this)
    });
  }
  _destroyTileHeaders(e) {
    this._destroySubtree(e);
  }
  async _loadTile(e) {
    let t;
    try {
      this._onStartTileLoading(), t = await e.loadContent();
    } catch (n) {
      this._onTileLoadError(e, n instanceof Error ? n : new Error("load failed"));
    } finally {
      this._onEndTileLoading(), this._onTileLoad(e, t);
    }
  }
  _onTileLoadError(e, t) {
    this.stats.get(bS).incrementCount();
    const n = t.message || t.toString(), i = e.url;
    console.error(`A 3D tile failed to load: ${e.url} ${n}`), this.options.onTileError(e, n, i);
  }
  _onTileLoad(e, t) {
    var n, i;
    if (t) {
      if (this.type === Ua.I3S) {
        const s = ((i = (n = this.tileset) == null ? void 0 : n.nodePagesTile) == null ? void 0 : i.nodesInNodePages) || 0;
        this.stats.get(Ym).reset(), this.stats.get(Ym).addCount(s);
      }
      e && e.content && CH(e, e.content), this.updateContentTypes(e), this._addTileToCache(e), this.options.onTileLoad(e);
    }
  }
  /**
   * Update information about data types in nested tiles
   * @param tile instance of a nested Tile3D
   */
  updateContentTypes(e) {
    var t;
    if (this.type === Ua.I3S)
      switch (e.header.isDracoGeometry && (this.contentFormats.draco = !0), e.header.textureFormat) {
        case "dds":
          this.contentFormats.dds = !0;
          break;
        case "ktx2":
          this.contentFormats.ktx2 = !0;
          break;
      }
    else if (this.type === Ua.TILES3D) {
      const {
        extensionsRemoved: n = []
      } = ((t = e.content) == null ? void 0 : t.gltf) || {};
      n.includes("KHR_draco_mesh_compression") && (this.contentFormats.draco = !0), n.includes("EXT_meshopt_compression") && (this.contentFormats.meshopt = !0), n.includes("KHR_texture_basisu") && (this.contentFormats.ktx2 = !0);
    }
  }
  _onStartTileLoading() {
    this._pendingCount++, this.stats.get(t1).incrementCount();
  }
  _onEndTileLoading() {
    this._pendingCount--, this.stats.get(t1).decrementCount();
  }
  _addTileToCache(e) {
    this._cache.add(this, e, (t) => t._updateCacheStats(e));
  }
  _updateCacheStats(e) {
    this.stats.get(_S).incrementCount(), this.stats.get(e1).incrementCount(), this.gpuMemoryUsageInBytes += e.gpuMemoryUsageInBytes || 0, this.stats.get(r1).count = this.gpuMemoryUsageInBytes, this.options.memoryAdjustedScreenSpaceError && this.adjustScreenSpaceError();
  }
  _unloadTile(e) {
    this.gpuMemoryUsageInBytes -= e.gpuMemoryUsageInBytes || 0, this.stats.get(e1).decrementCount(), this.stats.get(yS).incrementCount(), this.stats.get(r1).count = this.gpuMemoryUsageInBytes, this.options.onTileUnload(e), e.unloadContent();
  }
  // Traverse the tree and destroy all tiles
  _destroy() {
    const e = [];
    for (this.root && e.push(this.root); e.length > 0; ) {
      const t = e.pop();
      for (const n of t.children)
        e.push(n);
      this._destroyTile(t);
    }
    this.root = null;
  }
  // Traverse the tree and destroy all sub tiles
  _destroySubtree(e) {
    const t = e, n = [];
    for (n.push(t); n.length > 0; ) {
      e = n.pop();
      for (const i of e.children)
        n.push(i);
      e !== t && this._destroyTile(e);
    }
    t.children = [];
  }
  _destroyTile(e) {
    this._cache.unloadTile(this, e), this._unloadTile(e), e.destroy();
  }
  _initializeTiles3DTileset(e) {
    if (e.queryString) {
      const t = new URLSearchParams(e.queryString), n = Object.fromEntries(t.entries());
      this._queryParams = {
        ...this._queryParams,
        ...n
      };
    }
    if (this.asset = e.asset, !this.asset)
      throw new Error("Tileset must have an asset property.");
    if (this.asset.version !== "0.0" && this.asset.version !== "1.0" && this.asset.version !== "1.1")
      throw new Error("The tileset must be 3D Tiles version either 0.0 or 1.0 or 1.1.");
    "tilesetVersion" in this.asset && (this._queryParams.v = this.asset.tilesetVersion), this.credits = {
      attributions: this.options.attributions || []
    }, this.description = this.options.description || "", this.properties = e.properties, this.geometricError = e.geometricError, this._extensionsUsed = e.extensionsUsed || [], this.extras = e.extras;
  }
  _initializeI3STileset() {
    this.loadOptions.i3s && "token" in this.loadOptions.i3s && (this._queryParams.token = this.loadOptions.i3s.token);
  }
}
const cM = "4.3.2", Qp = {
  COMPOSITE: "cmpt",
  POINT_CLOUD: "pnts",
  BATCHED_3D_MODEL: "b3dm",
  INSTANCED_3D_MODEL: "i3dm",
  GLTF: "glTF"
};
function uM(r, e, t) {
  Mi(r instanceof ArrayBuffer);
  const n = new TextDecoder("utf8"), i = new Uint8Array(r, e, t);
  return n.decode(i);
}
function iW(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  const t = new DataView(r);
  return `${String.fromCharCode(t.getUint8(e + 0))}${String.fromCharCode(t.getUint8(e + 1))}${String.fromCharCode(t.getUint8(e + 2))}${String.fromCharCode(t.getUint8(e + 3))}`;
}
const sW = {
  POINTS: 0,
  // Points. single points.
  LINES: 1,
  // Lines. Each vertex connects to the one after it.
  LINE_LOOP: 2,
  // Lines. Each set of two vertices is treated as a separate line segment.
  LINE_STRIP: 3,
  // Lines/ a connected group of line segments from the first vertex to the last
  TRIANGLES: 4,
  // Triangles. Each set of three vertices creates a separate triangle.
  TRIANGLE_STRIP: 5,
  // Triangles. A connected group of triangles.
  TRIANGLE_FAN: 6
  // Triangles. A connected group of triangles.
  // Each vertex connects to the previous and the first vertex in the fan.
}, zs = {
  BYTE: 5120,
  UNSIGNED_BYTE: 5121,
  SHORT: 5122,
  UNSIGNED_SHORT: 5123,
  INT: 5124,
  UNSIGNED_INT: 5125,
  FLOAT: 5126,
  DOUBLE: 5130
}, qn = {
  ...sW,
  ...zs
}, n1 = {
  [zs.DOUBLE]: Float64Array,
  [zs.FLOAT]: Float32Array,
  [zs.UNSIGNED_SHORT]: Uint16Array,
  [zs.UNSIGNED_INT]: Uint32Array,
  [zs.UNSIGNED_BYTE]: Uint8Array,
  [zs.BYTE]: Int8Array,
  [zs.SHORT]: Int16Array,
  [zs.INT]: Int32Array
}, oW = {
  DOUBLE: zs.DOUBLE,
  FLOAT: zs.FLOAT,
  UNSIGNED_SHORT: zs.UNSIGNED_SHORT,
  UNSIGNED_INT: zs.UNSIGNED_INT,
  UNSIGNED_BYTE: zs.UNSIGNED_BYTE,
  BYTE: zs.BYTE,
  SHORT: zs.SHORT,
  INT: zs.INT
}, i1 = "Failed to convert GL type";
class mu {
  // Signature: fromTypedArray(new Uint8Array())
  // Signature: fromTypedArray(Uint8Array)
  /**
   * Returns the size, in bytes, of the corresponding datatype
   * @param arrayOrType
   * @returns glType a a string
   */
  static fromTypedArray(e) {
    e = ArrayBuffer.isView(e) ? e.constructor : e;
    for (const t in n1)
      if (n1[t] === e)
        return t;
    throw new Error(i1);
  }
  /**
   * Extracts name for glType from array NAME_TO_GL_TYPE
   * @param name
   * @returns glType as a number
   */
  static fromName(e) {
    const t = oW[e];
    if (!t)
      throw new Error(i1);
    return t;
  }
  // Converts GL constant to corresponding typed array type
  // eslint-disable-next-line complexity
  static getArrayType(e) {
    switch (e) {
      /*eslint-disable*/
      // @ts-ignore
      case zs.UNSIGNED_SHORT_5_6_5:
      // @ts-ignore
      case zs.UNSIGNED_SHORT_4_4_4_4:
      // @ts-ignore
      case zs.UNSIGNED_SHORT_5_5_5_1:
        return Uint16Array;
      default:
        const t = n1[e];
        if (!t)
          throw new Error(i1);
        return t;
    }
  }
  /**
   * Returns the size in bytes of one element of the provided WebGL type
   * @param glType
   * @returns size of glType
   */
  static getByteSize(e) {
    return mu.getArrayType(e).BYTES_PER_ELEMENT;
  }
  /**
   * Returns `true` if `glType` is a valid WebGL data type.
   * @param glType
   * @returns boolean
   */
  static validate(e) {
    return !!mu.getArrayType(e);
  }
  /**
   * Creates a typed view of an array of bytes
   * @param glType The type of typed array (ArrayBuffer view) to create
   * @param buffer The buffer storage to use for the view.
   * @param byteOffset The offset, in bytes, to the first element in the view
   * @param length The number of elements in the view. Defaults to buffer length
   * @returns A typed array view of the buffer
   */
  static createTypedArray(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, i = arguments.length > 3 ? arguments[3] : void 0;
    i === void 0 && (i = (t.byteLength - n) / mu.getByteSize(e));
    const s = mu.getArrayType(e);
    return new s(t, n, i);
  }
}
function aW(r, e) {
  if (!r)
    throw new Error(`math.gl assertion failed. ${e}`);
}
function lW(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
  const t = r >> 11 & 31, n = r >> 5 & 63, i = r & 31;
  return e[0] = t << 3, e[1] = n << 2, e[2] = i << 3, e;
}
new B2();
new Ct();
new B2();
new B2();
function wS(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 255;
  return Sc(r, 0, e) / e * 2 - 1;
}
function AS(r) {
  return r < 0 ? -1 : 1;
}
function cW(r, e, t, n) {
  if (aW(n), r < 0 || r > t || e < 0 || e > t)
    throw new Error(`x and y must be unsigned normalized integers between 0 and ${t}`);
  if (n.x = wS(r, t), n.y = wS(e, t), n.z = 1 - (Math.abs(n.x) + Math.abs(n.y)), n.z < 0) {
    const i = n.x;
    n.x = (1 - Math.abs(n.y)) * AS(i), n.y = (1 - Math.abs(i)) * AS(n.y);
  }
  return n.normalize();
}
function uW(r, e, t) {
  return cW(r, e, 255, t);
}
class fx {
  constructor(e, t) {
    H(this, "json");
    H(this, "buffer");
    H(this, "featuresLength", 0);
    H(this, "_cachedTypedArrays", {});
    this.json = e, this.buffer = t;
  }
  getExtension(e) {
    return this.json.extensions && this.json.extensions[e];
  }
  hasProperty(e) {
    return !!this.json[e];
  }
  getGlobalProperty(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : qn.UNSIGNED_INT, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    const i = this.json[e];
    return i && Number.isFinite(i.byteOffset) ? this._getTypedArrayFromBinary(e, t, n, 1, i.byteOffset) : i;
  }
  getPropertyArray(e, t, n) {
    const i = this.json[e];
    return i && Number.isFinite(i.byteOffset) ? ("componentType" in i && (t = mu.fromName(i.componentType)), this._getTypedArrayFromBinary(e, t, n, this.featuresLength, i.byteOffset)) : this._getTypedArrayFromArray(e, t, i);
  }
  getProperty(e, t, n, i, s) {
    const l = this.json[e];
    if (!l)
      return l;
    const o = this.getPropertyArray(e, t, n);
    if (n === 1)
      return o[i];
    for (let d = 0; d < n; ++d)
      s[d] = o[n * i + d];
    return s;
  }
  // HELPERS
  _getTypedArrayFromBinary(e, t, n, i, s) {
    const l = this._cachedTypedArrays;
    let o = l[e];
    return o || (o = mu.createTypedArray(t, this.buffer.buffer, this.buffer.byteOffset + s, i * n), l[e] = o), o;
  }
  _getTypedArrayFromArray(e, t, n) {
    const i = this._cachedTypedArrays;
    let s = i[e];
    return s || (s = mu.createTypedArray(t, n), i[e] = s), s;
  }
}
const hW = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, fW = {
  SCALAR: (r, e) => r[e],
  VEC2: (r, e) => [r[2 * e + 0], r[2 * e + 1]],
  VEC3: (r, e) => [r[3 * e + 0], r[3 * e + 1], r[3 * e + 2]],
  VEC4: (r, e) => [r[4 * e + 0], r[4 * e + 1], r[4 * e + 2], r[4 * e + 3]],
  // TODO: check column major
  MAT2: (r, e) => [r[4 * e + 0], r[4 * e + 1], r[4 * e + 2], r[4 * e + 3]],
  MAT3: (r, e) => [r[9 * e + 0], r[9 * e + 1], r[9 * e + 2], r[9 * e + 3], r[9 * e + 4], r[9 * e + 5], r[9 * e + 6], r[9 * e + 7], r[9 * e + 8]],
  MAT4: (r, e) => [r[16 * e + 0], r[16 * e + 1], r[16 * e + 2], r[16 * e + 3], r[16 * e + 4], r[16 * e + 5], r[16 * e + 6], r[16 * e + 7], r[16 * e + 8], r[16 * e + 9], r[16 * e + 10], r[16 * e + 11], r[16 * e + 12], r[16 * e + 13], r[16 * e + 14], r[16 * e + 15]]
}, dW = {
  SCALAR: (r, e, t) => {
    e[t] = r;
  },
  VEC2: (r, e, t) => {
    e[2 * t + 0] = r[0], e[2 * t + 1] = r[1];
  },
  VEC3: (r, e, t) => {
    e[3 * t + 0] = r[0], e[3 * t + 1] = r[1], e[3 * t + 2] = r[2];
  },
  VEC4: (r, e, t) => {
    e[4 * t + 0] = r[0], e[4 * t + 1] = r[1], e[4 * t + 2] = r[2], e[4 * t + 3] = r[3];
  },
  // TODO: check column major correctness
  MAT2: (r, e, t) => {
    e[4 * t + 0] = r[0], e[4 * t + 1] = r[1], e[4 * t + 2] = r[2], e[4 * t + 3] = r[3];
  },
  MAT3: (r, e, t) => {
    e[9 * t + 0] = r[0], e[9 * t + 1] = r[1], e[9 * t + 2] = r[2], e[9 * t + 3] = r[3], e[9 * t + 4] = r[4], e[9 * t + 5] = r[5], e[9 * t + 6] = r[6], e[9 * t + 7] = r[7], e[9 * t + 8] = r[8], e[9 * t + 9] = r[9];
  },
  MAT4: (r, e, t) => {
    e[16 * t + 0] = r[0], e[16 * t + 1] = r[1], e[16 * t + 2] = r[2], e[16 * t + 3] = r[3], e[16 * t + 4] = r[4], e[16 * t + 5] = r[5], e[16 * t + 6] = r[6], e[16 * t + 7] = r[7], e[16 * t + 8] = r[8], e[16 * t + 9] = r[9], e[16 * t + 10] = r[10], e[16 * t + 11] = r[11], e[16 * t + 12] = r[12], e[16 * t + 13] = r[13], e[16 * t + 14] = r[14], e[16 * t + 15] = r[15];
  }
};
function pW(r, e, t, n) {
  const {
    componentType: i
  } = r;
  Mi(r.componentType);
  const s = typeof i == "string" ? mu.fromName(i) : i, l = hW[r.type], o = fW[r.type], d = dW[r.type];
  return t += r.byteOffset, {
    values: mu.createTypedArray(s, e, t, l * n),
    type: s,
    size: l,
    unpacker: o,
    packer: d
  };
}
const pu = (r) => r !== void 0;
function gW(r, e, t) {
  if (!e)
    return null;
  let n = r.getExtension("3DTILES_batch_table_hierarchy");
  const i = e.HIERARCHY;
  return i && (console.warn("3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy."), e.extensions = e.extensions || {}, e.extensions["3DTILES_batch_table_hierarchy"] = i, n = i), n ? mW(n, t) : null;
}
function mW(r, e) {
  let t, n, i;
  const s = r.instancesLength, l = r.classes;
  let o = r.classIds, d = r.parentCounts, m = r.parentIds, b = s;
  pu(o.byteOffset) && (o.componentType = defaultValue(o.componentType, GL.UNSIGNED_SHORT), o.type = AttributeType.SCALAR, i = getBinaryAccessor(o), o = i.createArrayBufferView(e.buffer, e.byteOffset + o.byteOffset, s));
  let A;
  if (pu(d))
    for (pu(d.byteOffset) && (d.componentType = defaultValue(d.componentType, GL.UNSIGNED_SHORT), d.type = AttributeType.SCALAR, i = getBinaryAccessor(d), d = i.createArrayBufferView(e.buffer, e.byteOffset + d.byteOffset, s)), A = new Uint16Array(s), b = 0, t = 0; t < s; ++t)
      A[t] = b, b += d[t];
  pu(m) && pu(m.byteOffset) && (m.componentType = defaultValue(m.componentType, GL.UNSIGNED_SHORT), m.type = AttributeType.SCALAR, i = getBinaryAccessor(m), m = i.createArrayBufferView(e.buffer, e.byteOffset + m.byteOffset, b));
  const M = l.length;
  for (t = 0; t < M; ++t) {
    const V = l[t].length, q = l[t].instances, Y = getBinaryProperties(V, q, e);
    l[t].instances = combine(Y, q);
  }
  const E = new Array(M).fill(0), k = new Uint16Array(s);
  for (t = 0; t < s; ++t)
    n = o[t], k[t] = E[n], ++E[n];
  const U = {
    classes: l,
    classIds: o,
    classIndexes: k,
    parentCounts: d,
    parentIndexes: A,
    parentIds: m
  };
  return bW(U), U;
}
function eg(r, e, t) {
  if (!r)
    return;
  const n = r.parentCounts;
  return r.parentIds ? t(r, e) : n > 0 ? _W(r, e, t) : yW(r, e, t);
}
function _W(r, e, t) {
  const n = r.classIds, i = r.parentCounts, s = r.parentIds, l = r.parentIndexes, o = n.length, d = scratchVisited;
  d.length = Math.max(d.length, o);
  const m = ++marker, b = scratchStack;
  for (b.length = 0, b.push(e); b.length > 0; ) {
    if (e = b.pop(), d[e] === m)
      continue;
    d[e] = m;
    const A = t(r, e);
    if (pu(A))
      return A;
    const M = i[e], E = l[e];
    for (let k = 0; k < M; ++k) {
      const U = s[E + k];
      U !== e && b.push(U);
    }
  }
  return null;
}
function yW(r, e, t) {
  let n = !0;
  for (; n; ) {
    const i = t(r, e);
    if (pu(i))
      return i;
    const s = r.parentIds[e];
    n = s !== e, e = s;
  }
  throw new Error("traverseHierarchySingleParent");
}
function bW(r) {
  const t = r.classIds.length;
  for (let n = 0; n < t; ++n)
    hM(r, n, stack);
}
function hM(r, e, t) {
  const n = r.parentCounts, i = r.parentIds, s = r.parentIndexes, o = r.classIds.length;
  if (!pu(i))
    return;
  assert(e < o, `Parent index ${e} exceeds the total number of instances: ${o}`), assert(t.indexOf(e) === -1, "Circular dependency detected in the batch table hierarchy."), t.push(e);
  const d = pu(n) ? n[e] : 1, m = pu(n) ? s[e] : e;
  for (let b = 0; b < d; ++b) {
    const A = i[m + b];
    A !== e && hM(r, A, t);
  }
  t.pop(e);
}
function Da(r) {
  return r != null;
}
const Km = (r, e) => r, vW = {
  HIERARCHY: !0,
  // Deprecated HIERARCHY property
  extensions: !0,
  extras: !0
};
class fM {
  constructor(e, t, n) {
    H(this, "json");
    H(this, "binary");
    H(this, "featureCount");
    H(this, "_extensions");
    // Copy all top-level property fields from the json object, ignoring special fields
    H(this, "_properties");
    H(this, "_binaryProperties");
    // TODO: hierarchy support is only partially implemented and not tested
    H(this, "_hierarchy");
    var s;
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    Mi(n >= 0), this.json = e || {}, this.binary = t, this.featureCount = n, this._extensions = ((s = this.json) == null ? void 0 : s.extensions) || {}, this._properties = {};
    for (const l in this.json)
      vW[l] || (this._properties[l] = this.json[l]);
    this._binaryProperties = this._initializeBinaryProperties(), i["3DTILES_batch_table_hierarchy"] && (this._hierarchy = gW(this, this.json, this.binary));
  }
  getExtension(e) {
    return this.json && this.json.extensions && this.json.extensions[e];
  }
  memorySizeInBytes() {
    return 0;
  }
  isClass(e, t) {
    if (this._checkBatchId(e), Mi(typeof t == "string", t), this._hierarchy) {
      const n = eg(this._hierarchy, e, (i, s) => {
        const l = i.classIds[s];
        return i.classes[l].name === t;
      });
      return Da(n);
    }
    return !1;
  }
  isExactClass(e, t) {
    return Mi(typeof t == "string", t), this.getExactClassName(e) === t;
  }
  getExactClassName(e) {
    if (this._checkBatchId(e), this._hierarchy) {
      const t = this._hierarchy.classIds[e];
      return this._hierarchy.classes[t].name;
    }
  }
  hasProperty(e, t) {
    return this._checkBatchId(e), Mi(typeof t == "string", t), Da(this._properties[t]) || this._hasPropertyInHierarchy(e, t);
  }
  getPropertyNames(e, t) {
    this._checkBatchId(e), t = Da(t) ? t : [], t.length = 0;
    const n = Object.keys(this._properties);
    return t.push(...n), this._hierarchy && this._getPropertyNamesInHierarchy(e, t), t;
  }
  getProperty(e, t) {
    if (this._checkBatchId(e), Mi(typeof t == "string", t), this._binaryProperties) {
      const i = this._binaryProperties[t];
      if (Da(i))
        return this._getBinaryProperty(i, e);
    }
    const n = this._properties[t];
    if (Da(n))
      return Km(n[e]);
    if (this._hierarchy) {
      const i = this._getHierarchyProperty(e, t);
      if (Da(i))
        return i;
    }
  }
  setProperty(e, t, n) {
    const i = this.featureCount;
    if (this._checkBatchId(e), Mi(typeof t == "string", t), this._binaryProperties) {
      const l = this._binaryProperties[t];
      if (l) {
        this._setBinaryProperty(l, e, n);
        return;
      }
    }
    if (this._hierarchy && this._setHierarchyProperty(this, e, t, n))
      return;
    let s = this._properties[t];
    Da(s) || (this._properties[t] = new Array(i), s = this._properties[t]), s[e] = Km(n);
  }
  // PRIVATE METHODS
  _checkBatchId(e) {
    if (!(e >= 0 && e < this.featureCount))
      throw new Error("batchId not in range [0, featureCount - 1].");
  }
  _getBinaryProperty(e, t) {
    return e.unpack(e.typedArray, t);
  }
  _setBinaryProperty(e, t, n) {
    e.pack(n, e.typedArray, t);
  }
  _initializeBinaryProperties() {
    let e = null;
    for (const t in this._properties) {
      const n = this._properties[t], i = this._initializeBinaryProperty(t, n);
      i && (e = e || {}, e[t] = i);
    }
    return e;
  }
  _initializeBinaryProperty(e, t) {
    if ("byteOffset" in t) {
      const n = t;
      Mi(this.binary, `Property ${e} requires a batch table binary.`), Mi(n.type, `Property ${e} requires a type.`);
      const i = pW(n, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);
      return {
        typedArray: i.values,
        componentCount: i.size,
        unpack: i.unpacker,
        pack: i.packer
      };
    }
    return null;
  }
  //  EXTENSION SUPPORT: 3DTILES_batch_table_hierarchy
  _hasPropertyInHierarchy(e, t) {
    if (!this._hierarchy)
      return !1;
    const n = eg(this._hierarchy, e, (i, s) => {
      const l = i.classIds[s], o = i.classes[l].instances;
      return Da(o[t]);
    });
    return Da(n);
  }
  _getPropertyNamesInHierarchy(e, t) {
    eg(this._hierarchy, e, (n, i) => {
      const s = n.classIds[i], l = n.classes[s].instances;
      for (const o in l)
        l.hasOwnProperty(o) && t.indexOf(o) === -1 && t.push(o);
    });
  }
  _getHierarchyProperty(e, t) {
    return eg(this._hierarchy, e, (n, i) => {
      const s = n.classIds[i], l = n.classes[s], o = n.classIndexes[i], d = l.instances[t];
      return Da(d) ? Da(d.typedArray) ? this._getBinaryProperty(d, o) : Km(d[o]) : null;
    });
  }
  _setHierarchyProperty(e, t, n, i) {
    const s = eg(this._hierarchy, t, (l, o) => {
      const d = l.classIds[o], m = l.classes[d], b = l.classIndexes[o], A = m.instances[n];
      return Da(A) ? (Mi(o === t, `Inherited property "${n}" is read-only.`), Da(A.typedArray) ? this._setBinaryProperty(A, b, i) : A[b] = Km(i), !0) : !1;
    });
    return Da(s);
  }
}
const s1 = 4;
function Hy(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const n = new DataView(e);
  if (r.magic = n.getUint32(t, !0), t += s1, r.version = n.getUint32(t, !0), t += s1, r.byteLength = n.getUint32(t, !0), t += s1, r.version !== 1)
    throw new Error(`3D Tile Version ${r.version} not supported`);
  return t;
}
const Id = 4, TS = "b3dm tile in legacy format.";
function dx(r, e, t) {
  const n = new DataView(e);
  let i;
  r.header = r.header || {};
  let s = n.getUint32(t, !0);
  t += Id;
  let l = n.getUint32(t, !0);
  t += Id;
  let o = n.getUint32(t, !0);
  t += Id;
  let d = n.getUint32(t, !0);
  return t += Id, o >= 570425344 ? (t -= Id * 2, i = s, o = l, d = 0, s = 0, l = 0, console.warn(TS)) : d >= 570425344 && (t -= Id, i = o, o = s, d = l, s = 0, l = 0, console.warn(TS)), r.header.featureTableJsonByteLength = s, r.header.featureTableBinaryByteLength = l, r.header.batchTableJsonByteLength = o, r.header.batchTableBinaryByteLength = d, r.header.batchLength = i, t;
}
function px(r, e, t, n) {
  return t = xW(r, e, t), t = wW(r, e, t), t;
}
function xW(r, e, t, n) {
  const {
    featureTableJsonByteLength: i,
    featureTableBinaryByteLength: s,
    batchLength: l
  } = r.header || {};
  if (r.featureTableJson = {
    BATCH_LENGTH: l || 0
  }, i && i > 0) {
    const o = uM(e, t, i);
    r.featureTableJson = JSON.parse(o);
  }
  return t += i || 0, r.featureTableBinary = new Uint8Array(e, t, s), t += s || 0, t;
}
function wW(r, e, t, n) {
  const {
    batchTableJsonByteLength: i,
    batchTableBinaryByteLength: s
  } = r.header || {};
  if (i && i > 0) {
    const l = uM(e, t, i);
    r.batchTableJson = JSON.parse(l), t += i, s && s > 0 && (r.batchTableBinary = new Uint8Array(e, t, s), r.batchTableBinary = new Uint8Array(r.batchTableBinary), t += s);
  }
  return t;
}
function dM(r, e, t) {
  if (!e && (!r || !r.batchIds || !t))
    return null;
  const {
    batchIds: n,
    isRGB565: i,
    pointCount: s = 0
  } = r;
  if (n && t) {
    const l = new Uint8ClampedArray(s * 3);
    for (let o = 0; o < s; o++) {
      const d = n[o], b = t.getProperty(d, "dimensions").map((A) => A * 255);
      l[o * 3] = b[0], l[o * 3 + 1] = b[1], l[o * 3 + 2] = b[2];
    }
    return {
      type: qn.UNSIGNED_BYTE,
      value: l,
      size: 3,
      normalized: !0
    };
  }
  if (e && i) {
    const l = new Uint8ClampedArray(s * 3);
    for (let o = 0; o < s; o++) {
      const d = lW(e[o]);
      l[o * 3] = d[0], l[o * 3 + 1] = d[1], l[o * 3 + 2] = d[2];
    }
    return {
      type: qn.UNSIGNED_BYTE,
      value: l,
      size: 3,
      normalized: !0
    };
  }
  return e && e.length === s * 3 ? {
    type: qn.UNSIGNED_BYTE,
    value: e,
    size: 3,
    normalized: !0
  } : {
    type: qn.UNSIGNED_BYTE,
    value: e || new Uint8ClampedArray(),
    size: 4,
    normalized: !0
  };
}
const SS = new Ct();
function AW(r, e) {
  if (!e)
    return null;
  if (r.isOctEncoded16P) {
    const t = new Float32Array((r.pointsLength || 0) * 3);
    for (let n = 0; n < (r.pointsLength || 0); n++)
      uW(e[n * 2], e[n * 2 + 1], SS), SS.toArray(t, n * 3);
    return {
      type: qn.FLOAT,
      size: 2,
      value: t
    };
  }
  return {
    type: qn.FLOAT,
    size: 2,
    value: e
  };
}
function TW(r, e, t) {
  return r.isQuantized ? t["3d-tiles"] && t["3d-tiles"].decodeQuantizedPositions ? (r.isQuantized = !1, SW(r, e)) : {
    type: qn.UNSIGNED_SHORT,
    value: e,
    size: 3,
    normalized: !0
  } : e;
}
function SW(r, e) {
  const t = new Ct(), n = new Float32Array(r.pointCount * 3);
  for (let i = 0; i < r.pointCount; i++)
    t.set(e[i * 3], e[i * 3 + 1], e[i * 3 + 2]).scale(1 / r.quantizedRange).multiply(r.quantizedVolumeScale).add(r.quantizedVolumeOffset).toArray(n, i * 3);
  return n;
}
async function EW(r, e, t, n, i) {
  t = Hy(r, e, t), t = dx(r, e, t), t = px(r, e, t), CW(r);
  const {
    featureTable: s,
    batchTable: l
  } = IW(r);
  return await LW(r, s, l, n, i), MW(r, s, n), PW(r, s, l), RW(r, s), t;
}
function CW(r) {
  r.attributes = {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, r.isQuantized = !1, r.isTranslucent = !1, r.isRGB565 = !1, r.isOctEncoded16P = !1;
}
function IW(r) {
  const e = new fx(r.featureTableJson, r.featureTableBinary), t = e.getGlobalProperty("POINTS_LENGTH");
  if (!Number.isFinite(t))
    throw new Error("POINTS_LENGTH must be defined");
  e.featuresLength = t, r.featuresLength = t, r.pointsLength = t, r.pointCount = t, r.rtcCenter = e.getGlobalProperty("RTC_CENTER", qn.FLOAT, 3);
  const n = BW(r, e);
  return {
    featureTable: e,
    batchTable: n
  };
}
function MW(r, e, t) {
  if (r.attributes = r.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, !r.attributes.positions) {
    if (e.hasProperty("POSITION"))
      r.attributes.positions = e.getPropertyArray("POSITION", qn.FLOAT, 3);
    else if (e.hasProperty("POSITION_QUANTIZED")) {
      const n = e.getPropertyArray("POSITION_QUANTIZED", qn.UNSIGNED_SHORT, 3);
      if (r.isQuantized = !0, r.quantizedRange = 65535, r.quantizedVolumeScale = e.getGlobalProperty("QUANTIZED_VOLUME_SCALE", qn.FLOAT, 3), !r.quantizedVolumeScale)
        throw new Error("QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      if (r.quantizedVolumeOffset = e.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", qn.FLOAT, 3), !r.quantizedVolumeOffset)
        throw new Error("QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      r.attributes.positions = TW(r, n, t);
    }
  }
  if (!r.attributes.positions)
    throw new Error("Either POSITION or POSITION_QUANTIZED must be defined.");
}
function PW(r, e, t) {
  if (r.attributes = r.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, !r.attributes.colors) {
    let n = null;
    e.hasProperty("RGBA") ? (n = e.getPropertyArray("RGBA", qn.UNSIGNED_BYTE, 4), r.isTranslucent = !0) : e.hasProperty("RGB") ? n = e.getPropertyArray("RGB", qn.UNSIGNED_BYTE, 3) : e.hasProperty("RGB565") && (n = e.getPropertyArray("RGB565", qn.UNSIGNED_SHORT, 1), r.isRGB565 = !0), r.attributes.colors = dM(r, n, t);
  }
  e.hasProperty("CONSTANT_RGBA") && (r.constantRGBA = e.getGlobalProperty("CONSTANT_RGBA", qn.UNSIGNED_BYTE, 4));
}
function RW(r, e) {
  if (r.attributes = r.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, !r.attributes.normals) {
    let t = null;
    e.hasProperty("NORMAL") ? t = e.getPropertyArray("NORMAL", qn.FLOAT, 3) : e.hasProperty("NORMAL_OCT16P") && (t = e.getPropertyArray("NORMAL_OCT16P", qn.UNSIGNED_BYTE, 2), r.isOctEncoded16P = !0), r.attributes.normals = AW(r, t);
  }
}
function BW(r, e) {
  let t = null;
  if (!r.batchIds && e.hasProperty("BATCH_ID") && (r.batchIds = e.getPropertyArray("BATCH_ID", qn.UNSIGNED_SHORT, 1), r.batchIds)) {
    const n = e.getGlobalProperty("BATCH_LENGTH");
    if (!n)
      throw new Error("Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.");
    const {
      batchTableJson: i,
      batchTableBinary: s
    } = r;
    t = new fM(i, s, n);
  }
  return t;
}
async function LW(r, e, t, n, i) {
  let s, l, o;
  const d = r.batchTableJson && r.batchTableJson.extensions && r.batchTableJson.extensions["3DTILES_draco_point_compression"];
  d && (o = d.properties);
  const m = e.getExtension("3DTILES_draco_point_compression");
  if (m) {
    l = m.properties;
    const A = m.byteOffset, M = m.byteLength;
    if (!l || !Number.isFinite(A) || !M)
      throw new Error("Draco properties, byteOffset, and byteLength must be defined");
    s = (r.featureTableBinary || []).slice(A, A + M), r.hasPositions = Number.isFinite(l.POSITION), r.hasColors = Number.isFinite(l.RGB) || Number.isFinite(l.RGBA), r.hasNormals = Number.isFinite(l.NORMAL), r.hasBatchIds = Number.isFinite(l.BATCH_ID), r.isTranslucent = Number.isFinite(l.RGBA);
  }
  if (!s)
    return !0;
  const b = {
    buffer: s,
    properties: {
      ...l,
      ...o
    },
    batchTableProperties: o
  };
  return await OW(r, b, n, i);
}
async function OW(r, e, t, n) {
  if (!n)
    return;
  const i = {
    ...t,
    draco: {
      ...t == null ? void 0 : t.draco,
      extraAttributes: e.batchTableProperties || {}
    }
  };
  delete i["3d-tiles"];
  const s = await Hg(e.buffer, KI, i, n), l = s.attributes.POSITION && s.attributes.POSITION.value, o = s.attributes.COLOR_0 && s.attributes.COLOR_0.value, d = s.attributes.NORMAL && s.attributes.NORMAL.value, m = s.attributes.BATCH_ID && s.attributes.BATCH_ID.value, b = l && s.attributes.POSITION.value.quantization, A = d && s.attributes.NORMAL.value.quantization;
  if (b) {
    const E = s.POSITION.data.quantization, k = E.range;
    r.quantizedVolumeScale = new Ct(k, k, k), r.quantizedVolumeOffset = new Ct(E.minValues), r.quantizedRange = (1 << E.quantizationBits) - 1, r.isQuantizedDraco = !0;
  }
  A && (r.octEncodedRange = (1 << s.NORMAL.data.quantization.quantizationBits) - 1, r.isOctEncodedDraco = !0);
  const M = {};
  if (e.batchTableProperties)
    for (const E of Object.keys(e.batchTableProperties))
      s.attributes[E] && s.attributes[E].value && (M[E.toLowerCase()] = s.attributes[E].value);
  r.attributes = {
    // @ts-expect-error
    positions: l,
    // @ts-expect-error
    colors: dM(r, o, void 0),
    // @ts-expect-error
    normals: d,
    // @ts-expect-error
    batchIds: m,
    ...M
  };
}
const Bv = {
  URI: 0,
  EMBEDDED: 1
};
function pM(r, e, t, n) {
  r.rotateYtoZ = !0;
  const i = (r.byteOffset || 0) + (r.byteLength || 0) - t;
  if (i === 0)
    throw new Error("glTF byte length must be greater than 0.");
  return r.gltfUpAxis = n != null && n["3d-tiles"] && n["3d-tiles"].assetGltfUpAxis ? n["3d-tiles"].assetGltfUpAxis : "Y", r.gltfArrayBuffer = c2(e, t, i), r.gltfByteOffset = 0, r.gltfByteLength = i, t % 4 === 0 || console.warn(`${r.type}: embedded glb is not aligned to a 4-byte boundary.`), (r.byteOffset || 0) + (r.byteLength || 0);
}
async function gM(r, e, t, n) {
  const i = (t == null ? void 0 : t["3d-tiles"]) || {};
  if (kW(r, e), i.loadGLTF) {
    if (!n)
      return;
    if (r.gltfUrl) {
      const {
        fetch: s
      } = n, l = await s(r.gltfUrl, t);
      r.gltfArrayBuffer = await l.arrayBuffer(), r.gltfByteOffset = 0;
    }
    if (r.gltfArrayBuffer) {
      const s = await Hg(r.gltfArrayBuffer, jg, t, n);
      r.gltf = cx(s), r.gpuMemoryUsageInBytes = jI(r.gltf), delete r.gltfArrayBuffer, delete r.gltfByteOffset, delete r.gltfByteLength;
    }
  }
}
function kW(r, e, t) {
  switch (e) {
    case Bv.URI:
      if (r.gltfArrayBuffer) {
        const n = new Uint8Array(r.gltfArrayBuffer, r.gltfByteOffset), s = new TextDecoder().decode(n);
        r.gltfUrl = s.replace(/[\s\0]+$/, "");
      }
      delete r.gltfArrayBuffer, delete r.gltfByteOffset, delete r.gltfByteLength;
      break;
    case Bv.EMBEDDED:
      break;
    default:
      throw new Error("b3dm: Illegal glTF format field");
  }
}
async function NW(r, e, t, n, i) {
  var l;
  t = DW(r, e, t, n), await gM(r, Bv.EMBEDDED, n, i);
  const s = (l = r == null ? void 0 : r.gltf) == null ? void 0 : l.extensions;
  return s && s.CESIUM_RTC && (r.rtcCenter = s.CESIUM_RTC.center), t;
}
function DW(r, e, t, n, i) {
  t = Hy(r, e, t), t = dx(r, e, t), t = px(r, e, t), t = pM(r, e, t, n);
  const s = new fx(r.featureTableJson, r.featureTableBinary);
  return r.rtcCenter = s.getGlobalProperty("RTC_CENTER", qn.FLOAT, 3), t;
}
async function FW(r, e, t, n, i) {
  return t = UW(r, e, t, n), await gM(r, r.gltfFormat || 0, n, i), t;
}
function UW(r, e, t, n, i) {
  var m;
  if (t = Hy(r, e, t), r.version !== 1)
    throw new Error(`Instanced 3D Model version ${r.version} is not supported`);
  t = dx(r, e, t);
  const s = new DataView(e);
  if (r.gltfFormat = s.getUint32(t, !0), t += 4, t = px(r, e, t), t = pM(r, e, t, n), !((m = r == null ? void 0 : r.header) != null && m.featureTableJsonByteLength) || r.header.featureTableJsonByteLength === 0)
    throw new Error("i3dm parser: featureTableJsonByteLength is zero.");
  const l = new fx(r.featureTableJson, r.featureTableBinary), o = l.getGlobalProperty("INSTANCES_LENGTH");
  if (l.featuresLength = o, !Number.isFinite(o))
    throw new Error("i3dm parser: INSTANCES_LENGTH must be defined");
  r.eastNorthUp = l.getGlobalProperty("EAST_NORTH_UP"), r.rtcCenter = l.getGlobalProperty("RTC_CENTER", qn.FLOAT, 3);
  const d = new fM(r.batchTableJson, r.batchTableBinary, o);
  return zW(r, l, d, o), t;
}
function zW(r, e, t, n) {
  const i = new Array(n), s = new Ct();
  new Ct(), new Ct(), new Ct();
  const l = new ms(), o = new Rg(), d = new Ct(), m = {}, b = new Bn(), A = [], M = [], E = [], k = [];
  for (let U = 0; U < n; U++) {
    let V;
    if (e.hasProperty("POSITION"))
      V = e.getProperty("POSITION", qn.FLOAT, 3, U, s);
    else if (e.hasProperty("POSITION_QUANTIZED")) {
      V = e.getProperty("POSITION_QUANTIZED", qn.UNSIGNED_SHORT, 3, U, s);
      const ie = e.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", qn.FLOAT, 3);
      if (!ie)
        throw new Error("i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      const be = e.getGlobalProperty("QUANTIZED_VOLUME_SCALE", qn.FLOAT, 3);
      if (!be)
        throw new Error("i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      const he = 65535;
      for (let Be = 0; Be < 3; Be++)
        V[Be] = V[Be] / he * be[Be] + ie[Be];
    }
    if (!V)
      throw new Error("i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.");
    if (s.copy(V), m.translation = s, r.normalUp = e.getProperty("NORMAL_UP", qn.FLOAT, 3, U, A), r.normalRight = e.getProperty("NORMAL_RIGHT", qn.FLOAT, 3, U, M), r.normalUp) {
      if (!r.normalRight)
        throw new Error("i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.");
      r.hasCustomOrientation = !0;
    } else {
      if (r.octNormalUp = e.getProperty("NORMAL_UP_OCT32P", qn.UNSIGNED_SHORT, 2, U, A), r.octNormalRight = e.getProperty("NORMAL_RIGHT_OCT32P", qn.UNSIGNED_SHORT, 2, U, M), r.octNormalUp)
        throw r.octNormalRight ? new Error("i3dm: oct-encoded orientation not implemented") : new Error("i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P");
      r.eastNorthUp ? (Pi.WGS84.eastNorthUpToFixedFrame(s, b), b.getRotationMatrix3(l)) : l.identity();
    }
    o.fromMatrix3(l), m.rotation = o, d.set(1, 1, 1);
    const q = e.getProperty("SCALE", qn.FLOAT, 1, U, E);
    Number.isFinite(q) && d.multiplyByScalar(q);
    const Y = e.getProperty("SCALE_NON_UNIFORM", qn.FLOAT, 3, U, A);
    Y && d.scale(Y), m.scale = d;
    let re = e.getProperty("BATCH_ID", qn.UNSIGNED_SHORT, 1, U, k);
    re === void 0 && (re = U);
    const Z = new Bn().fromQuaternion(m.rotation);
    b.identity(), b.translate(m.translation), b.multiplyRight(Z), b.scale(m.scale);
    const K = b.clone();
    i[U] = {
      modelMatrix: K,
      batchId: re
    };
  }
  r.instances = i;
}
async function jW(r, e, t, n, i, s) {
  t = Hy(r, e, t);
  const l = new DataView(e);
  for (r.tilesLength = l.getUint32(t, !0), t += 4, r.tiles = []; r.tiles.length < r.tilesLength && (r.byteLength || 0) - t > 12; ) {
    const o = {
      shape: "tile3d"
    };
    r.tiles.push(o), t = await s(e, t, n, i, o);
  }
  return t;
}
async function VW(r, e, t, n) {
  var i, s;
  if (r.rotateYtoZ = !0, r.gltfUpAxis = (i = t == null ? void 0 : t["3d-tiles"]) != null && i.assetGltfUpAxis ? t["3d-tiles"].assetGltfUpAxis : "Y", (s = t == null ? void 0 : t["3d-tiles"]) != null && s.loadGLTF) {
    if (!n)
      return e.byteLength;
    const l = await Hg(e, jg, t, n);
    r.gltf = cx(l), r.gpuMemoryUsageInBytes = jI(r.gltf);
  } else
    r.gltfArrayBuffer = e;
  return e.byteLength;
}
async function mM(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = arguments.length > 2 ? arguments[2] : void 0, n = arguments.length > 3 ? arguments[3] : void 0, i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
    shape: "tile3d"
  };
  switch (i.byteOffset = e, i.type = iW(r, e), i.type) {
    case Qp.COMPOSITE:
      return await jW(i, r, e, t, n, mM);
    case Qp.BATCHED_3D_MODEL:
      return await NW(i, r, e, t, n);
    case Qp.GLTF:
      return await VW(i, r, t, n);
    case Qp.INSTANCED_3D_MODEL:
      return await FW(i, r, e, t, n);
    case Qp.POINT_CLOUD:
      return await EW(i, r, e, t, n);
    default:
      throw new Error(`3DTileLoader: unknown type ${i.type}`);
  }
}
const $W = 1952609651, qW = 1;
async function GW(r, e, t) {
  if (new Uint32Array(r.slice(0, 4))[0] !== $W)
    throw new Error("Wrong subtree file magic number");
  if (new Uint32Array(r.slice(4, 8))[0] !== qW)
    throw new Error("Wrong subtree file verson, must be 1");
  const s = ES(r.slice(8, 16)), l = new Uint8Array(r, 24, s), d = new TextDecoder("utf8").decode(l), m = JSON.parse(d), b = ES(r.slice(16, 24));
  let A = new ArrayBuffer(0);
  if (b && (A = r.slice(24 + s)), await Jm(m, m.tileAvailability, A, t), Array.isArray(m.contentAvailability))
    for (const M of m.contentAvailability)
      await Jm(m, M, A, t);
  else
    await Jm(m, m.contentAvailability, A, t);
  return await Jm(m, m.childSubtreeAvailability, A, t), m;
}
async function Jm(r, e, t, n) {
  const i = Number.isFinite(e.bitstream) ? e.bitstream : e.bufferView;
  if (typeof i != "number")
    return;
  const s = r.bufferViews[i], l = r.buffers[s.buffer];
  if (!(n != null && n.baseUrl))
    throw new Error("Url is not provided");
  if (!n.fetch)
    throw new Error("fetch is not provided");
  if (l.uri) {
    const d = `${(n == null ? void 0 : n.baseUrl) || ""}/${l.uri}`, b = await (await n.fetch(d)).arrayBuffer();
    e.explicitBitstream = new Uint8Array(b, s.byteOffset, s.byteLength);
    return;
  }
  const o = r.buffers.slice(0, s.buffer).reduce((d, m) => d + m.byteLength, 0);
  e.explicitBitstream = new Uint8Array(t.slice(o, o + l.byteLength), s.byteOffset, s.byteLength);
}
function ES(r) {
  const e = new DataView(r), t = e.getUint32(0, !0), n = e.getUint32(4, !0);
  return t + 2 ** 32 * n;
}
const _M = {
  dataType: null,
  batchType: null,
  id: "3d-tiles-subtree",
  name: "3D Tiles Subtree",
  module: "3d-tiles",
  version: cM,
  extensions: ["subtree"],
  mimeTypes: ["application/octet-stream"],
  tests: ["subtree"],
  parse: GW,
  options: {}
};
/**
 * @license
 * Copyright 2009 The Closure Library Authors
 * Copyright 2020 Daniel Wirtz / The long.js Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
var kl = null;
try {
  kl = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
} catch {
}
function ui(r, e, t) {
  this.low = r | 0, this.high = e | 0, this.unsigned = !!t;
}
ui.prototype.__isLong__;
Object.defineProperty(ui.prototype, "__isLong__", {
  value: !0
});
function ia(r) {
  return (r && r.__isLong__) === !0;
}
function CS(r) {
  var e = Math.clz32(r & -r);
  return r ? 31 - e : e;
}
ui.isLong = ia;
var IS = {}, MS = {};
function Yf(r, e) {
  var t, n, i;
  return e ? (r >>>= 0, (i = 0 <= r && r < 256) && (n = MS[r], n) ? n : (t = Xn(r, 0, !0), i && (MS[r] = t), t)) : (r |= 0, (i = -128 <= r && r < 128) && (n = IS[r], n) ? n : (t = Xn(r, r < 0 ? -1 : 0, !1), i && (IS[r] = t), t));
}
ui.fromInt = Yf;
function Nl(r, e) {
  if (isNaN(r)) return e ? eh : Ic;
  if (e) {
    if (r < 0) return eh;
    if (r >= yM) return xM;
  } else {
    if (r <= -9223372036854776e3) return ja;
    if (r + 1 >= WW) return vM;
  }
  return r < 0 ? Nl(-r, e).neg() : Xn(r % fp | 0, r / fp | 0, e);
}
ui.fromNumber = Nl;
function Xn(r, e, t) {
  return new ui(r, e, t);
}
ui.fromBits = Xn;
var uy = Math.pow;
function gx(r, e, t) {
  if (r.length === 0) throw Error("empty string");
  if (typeof e == "number" ? (t = e, e = !1) : e = !!e, r === "NaN" || r === "Infinity" || r === "+Infinity" || r === "-Infinity") return e ? eh : Ic;
  if (t = t || 10, t < 2 || 36 < t) throw RangeError("radix");
  var n;
  if ((n = r.indexOf("-")) > 0) throw Error("interior hyphen");
  if (n === 0)
    return gx(r.substring(1), e, t).neg();
  for (var i = Nl(uy(t, 8)), s = Ic, l = 0; l < r.length; l += 8) {
    var o = Math.min(8, r.length - l), d = parseInt(r.substring(l, l + o), t);
    if (o < 8) {
      var m = Nl(uy(t, o));
      s = s.mul(m).add(Nl(d));
    } else
      s = s.mul(i), s = s.add(Nl(d));
  }
  return s.unsigned = e, s;
}
ui.fromString = gx;
function Lc(r, e) {
  return typeof r == "number" ? Nl(r, e) : typeof r == "string" ? gx(r, e) : Xn(r.low, r.high, typeof e == "boolean" ? e : r.unsigned);
}
ui.fromValue = Lc;
var PS = 65536, HW = 1 << 24, fp = PS * PS, yM = fp * fp, WW = yM / 2, RS = Yf(HW), Ic = Yf(0);
ui.ZERO = Ic;
var eh = Yf(0, !0);
ui.UZERO = eh;
var $d = Yf(1);
ui.ONE = $d;
var bM = Yf(1, !0);
ui.UONE = bM;
var Lv = Yf(-1);
ui.NEG_ONE = Lv;
var vM = Xn(-1, 2147483647, !1);
ui.MAX_VALUE = vM;
var xM = Xn(-1, -1, !0);
ui.MAX_UNSIGNED_VALUE = xM;
var ja = Xn(0, -2147483648, !1);
ui.MIN_VALUE = ja;
var dr = ui.prototype;
dr.toInt = function() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
dr.toNumber = function() {
  return this.unsigned ? (this.high >>> 0) * fp + (this.low >>> 0) : this.high * fp + (this.low >>> 0);
};
dr.toString = function(e) {
  if (e = e || 10, e < 2 || 36 < e) throw RangeError("radix");
  if (this.isZero()) return "0";
  if (this.isNegative())
    if (this.eq(ja)) {
      var t = Nl(e), n = this.div(t), i = n.mul(t).sub(this);
      return n.toString(e) + i.toInt().toString(e);
    } else return "-" + this.neg().toString(e);
  for (var s = Nl(uy(e, 6), this.unsigned), l = this, o = ""; ; ) {
    var d = l.div(s), m = l.sub(d.mul(s)).toInt() >>> 0, b = m.toString(e);
    if (l = d, l.isZero()) return b + o;
    for (; b.length < 6; ) b = "0" + b;
    o = "" + b + o;
  }
};
dr.getHighBits = function() {
  return this.high;
};
dr.getHighBitsUnsigned = function() {
  return this.high >>> 0;
};
dr.getLowBits = function() {
  return this.low;
};
dr.getLowBitsUnsigned = function() {
  return this.low >>> 0;
};
dr.getNumBitsAbs = function() {
  if (this.isNegative())
    return this.eq(ja) ? 64 : this.neg().getNumBitsAbs();
  for (var e = this.high != 0 ? this.high : this.low, t = 31; t > 0 && (e & 1 << t) == 0; t--) ;
  return this.high != 0 ? t + 33 : t + 1;
};
dr.isZero = function() {
  return this.high === 0 && this.low === 0;
};
dr.eqz = dr.isZero;
dr.isNegative = function() {
  return !this.unsigned && this.high < 0;
};
dr.isPositive = function() {
  return this.unsigned || this.high >= 0;
};
dr.isOdd = function() {
  return (this.low & 1) === 1;
};
dr.isEven = function() {
  return (this.low & 1) === 0;
};
dr.equals = function(e) {
  return ia(e) || (e = Lc(e)), this.unsigned !== e.unsigned && this.high >>> 31 === 1 && e.high >>> 31 === 1 ? !1 : this.high === e.high && this.low === e.low;
};
dr.eq = dr.equals;
dr.notEquals = function(e) {
  return !this.eq(
    /* validates */
    e
  );
};
dr.neq = dr.notEquals;
dr.ne = dr.notEquals;
dr.lessThan = function(e) {
  return this.comp(
    /* validates */
    e
  ) < 0;
};
dr.lt = dr.lessThan;
dr.lessThanOrEqual = function(e) {
  return this.comp(
    /* validates */
    e
  ) <= 0;
};
dr.lte = dr.lessThanOrEqual;
dr.le = dr.lessThanOrEqual;
dr.greaterThan = function(e) {
  return this.comp(
    /* validates */
    e
  ) > 0;
};
dr.gt = dr.greaterThan;
dr.greaterThanOrEqual = function(e) {
  return this.comp(
    /* validates */
    e
  ) >= 0;
};
dr.gte = dr.greaterThanOrEqual;
dr.ge = dr.greaterThanOrEqual;
dr.compare = function(e) {
  if (ia(e) || (e = Lc(e)), this.eq(e)) return 0;
  var t = this.isNegative(), n = e.isNegative();
  return t && !n ? -1 : !t && n ? 1 : this.unsigned ? e.high >>> 0 > this.high >>> 0 || e.high === this.high && e.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e).isNegative() ? -1 : 1;
};
dr.comp = dr.compare;
dr.negate = function() {
  return !this.unsigned && this.eq(ja) ? ja : this.not().add($d);
};
dr.neg = dr.negate;
dr.add = function(e) {
  ia(e) || (e = Lc(e));
  var t = this.high >>> 16, n = this.high & 65535, i = this.low >>> 16, s = this.low & 65535, l = e.high >>> 16, o = e.high & 65535, d = e.low >>> 16, m = e.low & 65535, b = 0, A = 0, M = 0, E = 0;
  return E += s + m, M += E >>> 16, E &= 65535, M += i + d, A += M >>> 16, M &= 65535, A += n + o, b += A >>> 16, A &= 65535, b += t + l, b &= 65535, Xn(M << 16 | E, b << 16 | A, this.unsigned);
};
dr.subtract = function(e) {
  return ia(e) || (e = Lc(e)), this.add(e.neg());
};
dr.sub = dr.subtract;
dr.multiply = function(e) {
  if (this.isZero()) return this;
  if (ia(e) || (e = Lc(e)), kl) {
    var t = kl.mul(this.low, this.high, e.low, e.high);
    return Xn(t, kl.get_high(), this.unsigned);
  }
  if (e.isZero()) return this.unsigned ? eh : Ic;
  if (this.eq(ja)) return e.isOdd() ? ja : Ic;
  if (e.eq(ja)) return this.isOdd() ? ja : Ic;
  if (this.isNegative())
    return e.isNegative() ? this.neg().mul(e.neg()) : this.neg().mul(e).neg();
  if (e.isNegative()) return this.mul(e.neg()).neg();
  if (this.lt(RS) && e.lt(RS)) return Nl(this.toNumber() * e.toNumber(), this.unsigned);
  var n = this.high >>> 16, i = this.high & 65535, s = this.low >>> 16, l = this.low & 65535, o = e.high >>> 16, d = e.high & 65535, m = e.low >>> 16, b = e.low & 65535, A = 0, M = 0, E = 0, k = 0;
  return k += l * b, E += k >>> 16, k &= 65535, E += s * b, M += E >>> 16, E &= 65535, E += l * m, M += E >>> 16, E &= 65535, M += i * b, A += M >>> 16, M &= 65535, M += s * m, A += M >>> 16, M &= 65535, M += l * d, A += M >>> 16, M &= 65535, A += n * b + i * m + s * d + l * o, A &= 65535, Xn(E << 16 | k, A << 16 | M, this.unsigned);
};
dr.mul = dr.multiply;
dr.divide = function(e) {
  if (ia(e) || (e = Lc(e)), e.isZero()) throw Error("division by zero");
  if (kl) {
    if (!this.unsigned && this.high === -2147483648 && e.low === -1 && e.high === -1)
      return this;
    var t = (this.unsigned ? kl.div_u : kl.div_s)(this.low, this.high, e.low, e.high);
    return Xn(t, kl.get_high(), this.unsigned);
  }
  if (this.isZero()) return this.unsigned ? eh : Ic;
  var n, i, s;
  if (this.unsigned) {
    if (e.unsigned || (e = e.toUnsigned()), e.gt(this)) return eh;
    if (e.gt(this.shru(1)))
      return bM;
    s = eh;
  } else {
    if (this.eq(ja)) {
      if (e.eq($d) || e.eq(Lv)) return ja;
      if (e.eq(ja)) return $d;
      var l = this.shr(1);
      return n = l.div(e).shl(1), n.eq(Ic) ? e.isNegative() ? $d : Lv : (i = this.sub(e.mul(n)), s = n.add(i.div(e)), s);
    } else if (e.eq(ja)) return this.unsigned ? eh : Ic;
    if (this.isNegative())
      return e.isNegative() ? this.neg().div(e.neg()) : this.neg().div(e).neg();
    if (e.isNegative()) return this.div(e.neg()).neg();
    s = Ic;
  }
  for (i = this; i.gte(e); ) {
    n = Math.max(1, Math.floor(i.toNumber() / e.toNumber()));
    for (var o = Math.ceil(Math.log(n) / Math.LN2), d = o <= 48 ? 1 : uy(2, o - 48), m = Nl(n), b = m.mul(e); b.isNegative() || b.gt(i); )
      n -= d, m = Nl(n, this.unsigned), b = m.mul(e);
    m.isZero() && (m = $d), s = s.add(m), i = i.sub(b);
  }
  return s;
};
dr.div = dr.divide;
dr.modulo = function(e) {
  if (ia(e) || (e = Lc(e)), kl) {
    var t = (this.unsigned ? kl.rem_u : kl.rem_s)(this.low, this.high, e.low, e.high);
    return Xn(t, kl.get_high(), this.unsigned);
  }
  return this.sub(this.div(e).mul(e));
};
dr.mod = dr.modulo;
dr.rem = dr.modulo;
dr.not = function() {
  return Xn(~this.low, ~this.high, this.unsigned);
};
dr.countLeadingZeros = function() {
  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
};
dr.clz = dr.countLeadingZeros;
dr.countTrailingZeros = function() {
  return this.low ? CS(this.low) : CS(this.high) + 32;
};
dr.ctz = dr.countTrailingZeros;
dr.and = function(e) {
  return ia(e) || (e = Lc(e)), Xn(this.low & e.low, this.high & e.high, this.unsigned);
};
dr.or = function(e) {
  return ia(e) || (e = Lc(e)), Xn(this.low | e.low, this.high | e.high, this.unsigned);
};
dr.xor = function(e) {
  return ia(e) || (e = Lc(e)), Xn(this.low ^ e.low, this.high ^ e.high, this.unsigned);
};
dr.shiftLeft = function(e) {
  return ia(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? Xn(this.low << e, this.high << e | this.low >>> 32 - e, this.unsigned) : Xn(0, this.low << e - 32, this.unsigned);
};
dr.shl = dr.shiftLeft;
dr.shiftRight = function(e) {
  return ia(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? Xn(this.low >>> e | this.high << 32 - e, this.high >> e, this.unsigned) : Xn(this.high >> e - 32, this.high >= 0 ? 0 : -1, this.unsigned);
};
dr.shr = dr.shiftRight;
dr.shiftRightUnsigned = function(e) {
  return ia(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? Xn(this.low >>> e | this.high << 32 - e, this.high >>> e, this.unsigned) : e === 32 ? Xn(this.high, 0, this.unsigned) : Xn(this.high >>> e - 32, 0, this.unsigned);
};
dr.shru = dr.shiftRightUnsigned;
dr.shr_u = dr.shiftRightUnsigned;
dr.rotateLeft = function(e) {
  var t;
  return ia(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e === 32 ? Xn(this.high, this.low, this.unsigned) : e < 32 ? (t = 32 - e, Xn(this.low << e | this.high >>> t, this.high << e | this.low >>> t, this.unsigned)) : (e -= 32, t = 32 - e, Xn(this.high << e | this.low >>> t, this.low << e | this.high >>> t, this.unsigned));
};
dr.rotl = dr.rotateLeft;
dr.rotateRight = function(e) {
  var t;
  return ia(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e === 32 ? Xn(this.high, this.low, this.unsigned) : e < 32 ? (t = 32 - e, Xn(this.high << t | this.low >>> e, this.low << t | this.high >>> e, this.unsigned)) : (e -= 32, t = 32 - e, Xn(this.low << t | this.high >>> e, this.high << t | this.low >>> e, this.unsigned));
};
dr.rotr = dr.rotateRight;
dr.toSigned = function() {
  return this.unsigned ? Xn(this.low, this.high, !1) : this;
};
dr.toUnsigned = function() {
  return this.unsigned ? this : Xn(this.low, this.high, !0);
};
dr.toBytes = function(e) {
  return e ? this.toBytesLE() : this.toBytesBE();
};
dr.toBytesLE = function() {
  var e = this.high, t = this.low;
  return [t & 255, t >>> 8 & 255, t >>> 16 & 255, t >>> 24, e & 255, e >>> 8 & 255, e >>> 16 & 255, e >>> 24];
};
dr.toBytesBE = function() {
  var e = this.high, t = this.low;
  return [e >>> 24, e >>> 16 & 255, e >>> 8 & 255, e & 255, t >>> 24, t >>> 16 & 255, t >>> 8 & 255, t & 255];
};
ui.fromBytes = function(e, t, n) {
  return n ? ui.fromBytesLE(e, t) : ui.fromBytesBE(e, t);
};
ui.fromBytesLE = function(e, t) {
  return new ui(e[0] | e[1] << 8 | e[2] << 16 | e[3] << 24, e[4] | e[5] << 8 | e[6] << 16 | e[7] << 24, t);
};
ui.fromBytesBE = function(e, t) {
  return new ui(e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7], e[0] << 24 | e[1] << 16 | e[2] << 8 | e[3], t);
};
const XW = 16;
function wM(r) {
  r === "X" && (r = "");
  const e = r.padEnd(XW, "0");
  return ui.fromString(e, !0, 16);
}
function ZW(r) {
  if (r.isZero())
    return "X";
  let e = r.countTrailingZeros();
  const t = e % 4;
  e = (e - t) / 4;
  const n = e;
  e *= 4;
  const s = r.shiftRightUnsigned(e).toString(16).replace(/0+$/, "");
  return Array(17 - n - s.length).join("0") + s;
}
function YW(r, e) {
  const t = KW(r).shiftRightUnsigned(2);
  return r.add(ui.fromNumber(2 * e + 1 - 4).multiply(t));
}
function KW(r) {
  return r.and(r.not().add(1));
}
const JW = 3, QW = 30, eX = 2 * QW + 1, BS = 180 / Math.PI;
function tX(r) {
  if (r.length === 0)
    throw new Error(`Invalid Hilbert quad key ${r}`);
  const e = r.split("/"), t = parseInt(e[0], 10), n = e[1], i = n.length;
  let s = 0;
  const l = [0, 0];
  for (let o = i - 1; o >= 0; o--) {
    s = i - o;
    const d = n[o];
    let m = 0, b = 0;
    d === "1" ? b = 1 : d === "2" ? (m = 1, b = 1) : d === "3" && (m = 1);
    const A = Math.pow(2, s - 1);
    nX(A, l, m, b), l[0] += A * m, l[1] += A * b;
  }
  if (t % 2 === 1) {
    const o = l[0];
    l[0] = l[1], l[1] = o;
  }
  return {
    face: t,
    ij: l,
    level: s
  };
}
function rX(r) {
  if (r.isZero())
    return "";
  let e = r.toString(2);
  for (; e.length < JW + eX; )
    e = "0" + e;
  const t = e.lastIndexOf("1"), n = e.substring(0, 3), i = e.substring(3, t), s = i.length / 2, l = ui.fromString(n, !0, 2).toString(10);
  let o = "";
  if (s !== 0)
    for (o = ui.fromString(i, !0, 2).toString(4); o.length < s; )
      o = "0" + o;
  return `${l}/${o}`;
}
function AM(r, e, t) {
  const n = 1 << e;
  return [(r[0] + t[0]) / n, (r[1] + t[1]) / n];
}
function LS(r) {
  return r >= 0.5 ? 1 / 3 * (4 * r * r - 1) : 1 / 3 * (1 - 4 * (1 - r) * (1 - r));
}
function TM(r) {
  return [LS(r[0]), LS(r[1])];
}
function SM(r, e) {
  let [t, n] = e;
  switch (r) {
    case 0:
      return [1, t, n];
    case 1:
      return [-t, 1, n];
    case 2:
      return [-t, -n, 1];
    case 3:
      return [-1, -n, -t];
    case 4:
      return [n, -1, -t];
    case 5:
      return [n, t, -1];
    default:
      throw new Error("Invalid face");
  }
}
function EM(r) {
  let [e, t, n] = r;
  const i = Math.atan2(n, Math.sqrt(e * e + t * t));
  return [Math.atan2(t, e) * BS, i * BS];
}
function nX(r, e, t, n) {
  if (n === 0) {
    t === 1 && (e[0] = r - 1 - e[0], e[1] = r - 1 - e[1]);
    const i = e[0];
    e[0] = e[1], e[1] = i;
  }
}
function iX(r) {
  const e = AM(r.ij, r.level, [0.5, 0.5]), t = TM(e), n = SM(r.face, t);
  return EM(n);
}
const sX = 100;
function OS(r) {
  const {
    face: e,
    ij: t,
    level: n
  } = r, i = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]], s = Math.max(1, Math.ceil(sX * Math.pow(2, -n))), l = new Float64Array(4 * s * 2 + 2);
  let o = 0, d = 0;
  for (let m = 0; m < 4; m++) {
    const b = i[m].slice(0), A = i[m + 1], M = (A[0] - b[0]) / s, E = (A[1] - b[1]) / s;
    for (let k = 0; k < s; k++) {
      b[0] += M, b[1] += E;
      const U = AM(t, n, b), V = TM(U), q = SM(e, V), Y = EM(q);
      Math.abs(Y[1]) > 89.999 && (Y[0] = d);
      const re = Y[0] - d;
      Y[0] += re > 180 ? -360 : re < -180 ? 360 : 0, l[o++] = Y[0], l[o++] = Y[1], d = Y[0];
    }
  }
  return l[o++] = l[0], l[o++] = l[1], l;
}
function mx(r) {
  const e = oX(r);
  return tX(e);
}
function oX(r) {
  if (r.indexOf("/") > 0)
    return r;
  const e = wM(r);
  return rX(e);
}
function aX(r) {
  const e = mx(r);
  return iX(e);
}
function lX(r) {
  let e;
  if (r.face === 2 || r.face === 5) {
    let t = null, n = 0;
    for (let i = 0; i < 4; i++) {
      const s = `${r.face}/${i}`, l = mx(s), o = OS(l);
      (typeof t > "u" || t === null) && (t = new Float64Array(4 * o.length)), t.set(o, n), n += o.length;
    }
    e = kS(t);
  } else {
    const t = OS(r);
    e = kS(t);
  }
  return e;
}
function kS(r) {
  if (r.length % 2 !== 0)
    throw new Error("Invalid corners");
  const e = [], t = [];
  for (let n = 0; n < r.length; n += 2)
    e.push(r[n]), t.push(r[n + 1]);
  return e.sort((n, i) => n - i), t.sort((n, i) => n - i), {
    west: e[0],
    east: e[e.length - 1],
    north: t[t.length - 1],
    south: t[0]
  };
}
function cX(r, e) {
  const t = (e == null ? void 0 : e.minimumHeight) || 0, n = (e == null ? void 0 : e.maximumHeight) || 0, i = mx(r), s = lX(i), l = s.west, o = s.south, d = s.east, m = s.north, b = [];
  return b.push(new Ct(l, m, t)), b.push(new Ct(d, m, t)), b.push(new Ct(d, o, t)), b.push(new Ct(l, o, t)), b.push(new Ct(l, m, n)), b.push(new Ct(d, m, n)), b.push(new Ct(d, o, n)), b.push(new Ct(l, o, n)), b;
}
function CM(r) {
  const e = r.token, t = {
    minimumHeight: r.minimumHeight,
    maximumHeight: r.maximumHeight
  }, n = cX(e, t), i = aX(e), s = i[0], l = i[1], o = Pi.WGS84.cartographicToCartesian([s, l, t.maximumHeight]), d = new Ct(o[0], o[1], o[2]);
  n.push(d);
  const m = Kj(n);
  return [...m.center, ...m.halfAxes];
}
const uX = 4, hX = 8, fX = {
  QUADTREE: uX,
  OCTREE: hX
};
function dX(r, e, t) {
  if (r != null && r.box) {
    const n = wM(r.s2VolumeInfo.token), i = YW(n, e), s = ZW(i), l = {
      ...r.s2VolumeInfo
    };
    switch (l.token = s, t) {
      case "OCTREE":
        const m = r.s2VolumeInfo, b = m.maximumHeight - m.minimumHeight, A = b / 2, M = m.minimumHeight + b / 2;
        m.minimumHeight = M - A, m.maximumHeight = M + A;
        break;
    }
    return {
      box: CM(l),
      s2VolumeInfo: l
    };
  }
}
async function IM(r) {
  const {
    subtree: e,
    subtreeData: t = {
      level: 0,
      x: 0,
      y: 0,
      z: 0
    },
    parentData: n = {
      mortonIndex: 0,
      localLevel: -1,
      localX: 0,
      localY: 0,
      localZ: 0
    },
    childIndex: i = 0,
    implicitOptions: s,
    loaderOptions: l,
    s2VolumeBox: o
  } = r, {
    subdivisionScheme: d,
    subtreeLevels: m,
    maximumLevel: b,
    contentUrlTemplate: A,
    subtreesUriTemplate: M,
    basePath: E
  } = s, k = {
    children: [],
    lodMetricValue: 0,
    contentUrl: ""
  };
  if (!b)
    return jE.once(`Missing 'maximumLevel' or 'availableLevels' property. The subtree ${A} won't be loaded...`), k;
  const U = n.localLevel + 1, V = t.level + U;
  if (V > b)
    return k;
  const q = fX[d], Y = Math.log2(q), re = i & 1, Z = i >> 1 & 1, K = i >> 2 & 1, ie = xf(n.localX, re, 1), be = xf(n.localY, Z, 1), he = xf(n.localZ, K, 1), Be = xf(t.x, ie, U), ke = xf(t.y, be, U), pe = xf(t.z, he, U), me = xf(n.mortonIndex, i, Y), je = U === m && o1(e.childSubtreeAvailability, me);
  let Pe, St, Mt, Lt;
  if (je) {
    const Dt = `${E}/${M}`, hr = Ov(Dt, V, Be, ke, pe);
    Pe = await Hh(hr, _M, l), Lt = 0, St = {
      level: V,
      x: Be,
      y: ke,
      z: pe
    }, Mt = {
      mortonIndex: 0,
      localLevel: 0,
      localX: 0,
      localY: 0,
      localZ: 0
    };
  } else
    Pe = e, Lt = (q ** U - 1) / (q - 1) + me, St = t, Mt = {
      mortonIndex: me,
      localLevel: U,
      localX: ie,
      localY: be,
      localZ: he
    };
  if (!o1(Pe.tileAvailability, Lt))
    return k;
  o1(Pe.contentAvailability, Lt) && (k.contentUrl = Ov(A, V, Be, ke, pe));
  for (let Dt = 0; Dt < q; Dt++) {
    const hr = dX(o, Dt, d), ce = await IM({
      subtree: Pe,
      subtreeData: St,
      parentData: Mt,
      childIndex: Dt,
      implicitOptions: s,
      loaderOptions: l,
      s2VolumeBox: hr
    });
    (ce.contentUrl || ce.children.length) && k.children.push(ce);
  }
  return k.contentUrl || k.children.length ? pX(k, {
    level: V,
    x: Be,
    y: ke,
    z: pe
  }, s, o) : k;
}
function o1(r, e) {
  let t;
  return Array.isArray(r) ? (t = r[0], r.length > 1 && jE.once('Not supported extension "3DTILES_multiple_contents" has been detected')) : t = r, "constant" in t ? !!t.constant : t.explicitBitstream ? _X(e, t.explicitBitstream) : !1;
}
function pX(r, e, t, n) {
  const {
    basePath: i,
    refine: s,
    getRefine: l,
    lodMetricType: o,
    getTileType: d,
    rootLodMetricValue: m,
    rootBoundingVolume: b
  } = t, A = r.contentUrl && r.contentUrl.replace(`${i}/`, ""), M = m / 2 ** e.level, E = n != null && n.box ? {
    box: n.box
  } : b, k = gX(E, e, t.subdivisionScheme);
  return {
    children: r.children,
    contentUrl: r.contentUrl,
    content: {
      uri: A
    },
    id: r.contentUrl,
    refine: l(s),
    type: d(r),
    lodMetricType: o,
    lodMetricValue: M,
    geometricError: M,
    transform: r.transform,
    boundingVolume: k
  };
}
function gX(r, e, t) {
  if (r.region) {
    const {
      level: n,
      x: i,
      y: s,
      z: l
    } = e, [o, d, m, b, A, M] = r.region, E = 2 ** n, k = (m - o) / E, [U, V] = [o + k * i, o + k * (i + 1)], q = (b - d) / E, [Y, re] = [d + q * s, d + q * (s + 1)];
    let Z, K;
    if (t === "OCTREE") {
      const ie = (M - A) / E;
      [Z, K] = [A + ie * l, A + ie * (l + 1)];
    } else
      [Z, K] = [A, M];
    return {
      region: [U, Y, V, re, Z, K]
    };
  }
  if (r.box)
    return r;
  throw new Error(`Unsupported bounding volume type ${JSON.stringify(r)}`);
}
function xf(r, e, t) {
  return (r << t) + e;
}
function Ov(r, e, t, n, i) {
  const s = mX({
    level: e,
    x: t,
    y: n,
    z: i
  });
  return r.replace(/{level}|{x}|{y}|{z}/gi, (l) => s[l]);
}
function mX(r) {
  const e = {};
  for (const t in r)
    e[`{${t}}`] = r[t];
  return e;
}
function _X(r, e) {
  const t = Math.floor(r / 8), n = r % 8;
  return (e[t] >> n & 1) === 1;
}
function _x(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  if (!e)
    return Qu.EMPTY;
  const n = e.split("?")[0].split(".").pop();
  switch (n) {
    case "pnts":
      return Qu.POINTCLOUD;
    case "i3dm":
    case "b3dm":
    case "glb":
    case "gltf":
      return Qu.SCENEGRAPH;
    default:
      return n || Qu.EMPTY;
  }
}
function yx(r) {
  switch (r) {
    case "REPLACE":
    case "replace":
      return Pc.REPLACE;
    case "ADD":
    case "add":
      return Pc.ADD;
    default:
      return r;
  }
}
function kv(r, e) {
  if (/^[a-z][0-9a-z+.-]*:/i.test(e)) {
    const n = new URL(r, `${e}/`);
    return decodeURI(n.toString());
  } else if (r.startsWith("/"))
    return r;
  return jB(e, r);
}
function NS(r, e) {
  var i;
  if (!r)
    return null;
  let t;
  if (r.content) {
    const s = r.content.uri || ((i = r.content) == null ? void 0 : i.url);
    typeof s < "u" && (t = kv(s, e));
  }
  return {
    ...r,
    id: t,
    contentUrl: t,
    lodMetricType: hp.GEOMETRIC_ERROR,
    lodMetricValue: r.geometricError,
    transformMatrix: r.transform,
    type: _x(r, t),
    refine: yx(r.refine)
  };
}
async function yX(r, e, t) {
  let n = null;
  const i = FS(r.root);
  i && r.root ? n = await DS(r.root, r, e, i, t) : n = NS(r.root, e);
  const s = [];
  for (s.push(n); s.length > 0; ) {
    const l = s.pop() || {}, o = l.children || [], d = [];
    for (const m of o) {
      const b = FS(m);
      let A;
      b ? A = await DS(m, r, e, b, t) : A = NS(m, e), A && (d.push(A), s.push(A));
    }
    l.children = d;
  }
  return n;
}
async function DS(r, e, t, n, i) {
  var Z, K, ie;
  const {
    subdivisionScheme: s,
    maximumLevel: l,
    availableLevels: o,
    subtreeLevels: d,
    subtrees: {
      uri: m
    }
  } = n, b = Ov(m, 0, 0, 0, 0), A = kv(b, t), M = await Hh(A, _M, i), E = (Z = r.content) == null ? void 0 : Z.uri, k = E ? kv(E, t) : "", U = (K = e == null ? void 0 : e.root) == null ? void 0 : K.refine, V = r.geometricError, q = (ie = r.boundingVolume.extensions) == null ? void 0 : ie["3DTILES_bounding_volume_S2"];
  if (q) {
    const he = {
      box: CM(q),
      s2VolumeInfo: q
    };
    r.boundingVolume = he;
  }
  const Y = r.boundingVolume, re = {
    contentUrlTemplate: k,
    subtreesUriTemplate: m,
    subdivisionScheme: s,
    subtreeLevels: d,
    maximumLevel: Number.isFinite(o) ? o - 1 : l,
    refine: U,
    basePath: t,
    lodMetricType: hp.GEOMETRIC_ERROR,
    rootLodMetricValue: V,
    rootBoundingVolume: Y,
    getTileType: _x,
    getRefine: yx
  };
  return await bX(r, t, M, re, i);
}
async function bX(r, e, t, n, i) {
  if (!r)
    return null;
  const {
    children: s,
    contentUrl: l
  } = await IM({
    subtree: t,
    implicitOptions: n,
    loaderOptions: i
  });
  let o, d = null;
  return l && (o = l, d = {
    uri: l.replace(`${e}/`, "")
  }), {
    ...r,
    id: o,
    contentUrl: o,
    lodMetricType: hp.GEOMETRIC_ERROR,
    lodMetricValue: r.geometricError,
    transformMatrix: r.transform,
    type: _x(r, o),
    refine: yx(r.refine),
    content: d || r.content,
    children: s
  };
}
function FS(r) {
  var e;
  return ((e = r == null ? void 0 : r.extensions) == null ? void 0 : e["3DTILES_implicit_tiling"]) || (r == null ? void 0 : r.implicitTiling);
}
const bx = {
  dataType: null,
  batchType: null,
  id: "3d-tiles",
  name: "3D Tiles",
  module: "3d-tiles",
  version: cM,
  extensions: ["cmpt", "pnts", "b3dm", "i3dm"],
  mimeTypes: ["application/octet-stream"],
  tests: ["cmpt", "pnts", "b3dm", "i3dm"],
  parse: vX,
  options: {
    "3d-tiles": {
      loadGLTF: !0,
      decodeQuantizedPositions: !1,
      isTileset: "auto",
      assetGltfUpAxis: null
    }
  }
};
async function vX(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = arguments.length > 2 ? arguments[2] : void 0;
  const n = e["3d-tiles"] || {};
  let i;
  return n.isTileset === "auto" ? i = (t == null ? void 0 : t.url) && t.url.indexOf(".json") !== -1 : i = n.isTileset, i ? xX(r, e, t) : wX(r, e, t);
}
async function xX(r, e, t) {
  var d;
  const n = JSON.parse(new TextDecoder().decode(r)), i = (t == null ? void 0 : t.url) || "", s = AX(i), l = await yX(n, s, e || {});
  return {
    ...n,
    shape: "tileset3d",
    loader: bx,
    url: i,
    queryString: (t == null ? void 0 : t.queryString) || "",
    basePath: s,
    root: l || n.root,
    type: Ua.TILES3D,
    lodMetricType: hp.GEOMETRIC_ERROR,
    lodMetricValue: ((d = n.root) == null ? void 0 : d.geometricError) || 0
  };
}
async function wX(r, e, t) {
  const n = {
    content: {
      shape: "tile3d",
      featureIds: null
    }
  };
  return await mM(r, 0, e, t, n.content), n.content;
}
function AX(r) {
  return u2(r);
}
const US = [0], TX = {
  getPointColor: {
    type: "accessor",
    value: [0, 0, 0, 255]
  },
  pointSize: 1,
  // Disable async data loading (handling it in _loadTileSet)
  data: "",
  loader: bx,
  onTilesetLoad: {
    type: "function",
    value: (r) => {
    }
  },
  onTileLoad: {
    type: "function",
    value: (r) => {
    }
  },
  onTileUnload: {
    type: "function",
    value: (r) => {
    }
  },
  onTileError: {
    type: "function",
    value: (r, e, t) => {
    }
  },
  _getMeshColor: {
    type: "function",
    value: (r) => [255, 255, 255]
  }
};
class vx extends SI {
  initializeState() {
    "onTileLoadFail" in this.props && Gn.removed("onTileLoadFail", "onTileError")(), this.state = {
      layerMap: {},
      tileset3d: null,
      activeViewports: {},
      lastUpdatedViewports: null
    };
  }
  get isLoaded() {
    var e, t;
    return !!((t = (e = this.state) == null ? void 0 : e.tileset3d) != null && t.isLoaded() && super.isLoaded);
  }
  shouldUpdateState(e) {
    let {
      changeFlags: t
    } = e;
    return t.somethingChanged;
  }
  updateState(e) {
    let {
      props: t,
      oldProps: n,
      changeFlags: i
    } = e;
    if (t.data && t.data !== n.data && this._loadTileset(t.data), i.viewportChanged) {
      const {
        activeViewports: s
      } = this.state;
      Object.keys(s).length && (this._updateTileset(s), this.state.lastUpdatedViewports = s, this.state.activeViewports = {});
    }
    if (i.propsChanged) {
      const {
        layerMap: s
      } = this.state;
      for (const l in s)
        s[l].needsUpdate = !0;
    }
  }
  activateViewport(e) {
    const {
      activeViewports: t,
      lastUpdatedViewports: n
    } = this.state;
    this.internalState.viewport = e, t[e.id] = e;
    const i = n == null ? void 0 : n[e.id];
    (!i || !e.equals(i)) && (this.setChangeFlags({
      viewportChanged: !0
    }), this.setNeedsUpdate());
  }
  getPickingInfo(e) {
    let {
      info: t,
      sourceLayer: n
    } = e;
    const i = n && n.props.tile;
    return t.picked && (t.object = i), t.sourceTile = i, t;
  }
  filterSubLayer(e) {
    let {
      layer: t,
      viewport: n
    } = e;
    const {
      tile: i
    } = t.props, {
      id: s
    } = n;
    return i.selected && i.viewportIds.includes(s);
  }
  _updateAutoHighlight(e) {
    const t = e.sourceTile, n = this.state.layerMap[t == null ? void 0 : t.id];
    n && n.layer && n.layer.updateAutoHighlight(e);
  }
  async _loadTileset(e) {
    const {
      loadOptions: t = {}
    } = this.props, n = this.props.loader || this.props.loaders, i = Array.isArray(n) ? n[0] : n, s = {
      loadOptions: {
        ...t
      }
    };
    let l = e;
    if (i.preload) {
      const m = await i.preload(e, t);
      m.url && (l = m.url), m.headers && (s.loadOptions.fetch = {
        ...s.loadOptions.fetch,
        headers: m.headers
      }), Object.assign(s, m);
    }
    const o = await Hh(l, i, s.loadOptions), d = new nW(o, {
      onTileLoad: this._onTileLoad.bind(this),
      onTileUnload: this._onTileUnload.bind(this),
      onTileError: this.props.onTileError,
      ...s
    });
    this.setState({
      tileset3d: d,
      layerMap: {}
    }), this._updateTileset(this.state.activeViewports), this.props.onTilesetLoad(d);
  }
  _onTileLoad(e) {
    const {
      lastUpdatedViewports: t
    } = this.state;
    this.props.onTileLoad(e), this._updateTileset(t), this.setNeedsUpdate();
  }
  _onTileUnload(e) {
    delete this.state.layerMap[e.id], this.props.onTileUnload(e);
  }
  _updateTileset(e) {
    if (!e)
      return;
    const {
      tileset3d: t
    } = this.state, {
      timeline: n
    } = this.context, i = Object.keys(e).length;
    !n || !i || !t || t.selectTiles(Object.values(e)).then((s) => {
      this.state.frameNumber !== s && this.setState({
        frameNumber: s
      });
    });
  }
  _getSubLayer(e, t) {
    if (!e.content)
      return null;
    switch (e.type) {
      case Qu.POINTCLOUD:
        return this._makePointCloudLayer(e, t);
      case Qu.SCENEGRAPH:
        return this._make3DModelLayer(e);
      case Qu.MESH:
        return this._makeSimpleMeshLayer(e, t);
      default:
        throw new Error(`Tile3DLayer: Failed to render layer of type ${e.content.type}`);
    }
  }
  _makePointCloudLayer(e, t) {
    const {
      attributes: n,
      pointCount: i,
      constantRGBA: s,
      cartographicOrigin: l,
      modelMatrix: o
    } = e.content, {
      positions: d,
      normals: m,
      colors: b
    } = n;
    if (!d)
      return null;
    const A = t && t.props.data || {
      header: {
        vertexCount: i
      },
      attributes: {
        POSITION: d,
        NORMAL: m,
        COLOR_0: b
      }
    }, {
      pointSize: M,
      getPointColor: E
    } = this.props, k = this.getSubLayerClass("pointcloud", rx);
    return new k({
      pointSize: M
    }, this.getSubLayerProps({
      id: "pointcloud"
    }), {
      id: `${this.id}-pointcloud-${e.id}`,
      tile: e,
      data: A,
      coordinateSystem: Ln.METER_OFFSETS,
      coordinateOrigin: l,
      modelMatrix: o,
      getColor: s || E,
      _offset: 0
    });
  }
  _make3DModelLayer(e) {
    const {
      gltf: t,
      instances: n,
      cartographicOrigin: i,
      modelMatrix: s
    } = e.content, l = this.getSubLayerClass("scenegraph", ux);
    return new l({
      _lighting: "pbr"
    }, this.getSubLayerProps({
      id: "scenegraph"
    }), {
      id: `${this.id}-scenegraph-${e.id}`,
      tile: e,
      data: n || US,
      scenegraph: t,
      coordinateSystem: Ln.METER_OFFSETS,
      coordinateOrigin: i,
      modelMatrix: s,
      getTransformMatrix: (o) => o.modelMatrix,
      getPosition: [0, 0, 0],
      _offset: 0
    });
  }
  _makeSimpleMeshLayer(e, t) {
    const n = e.content, {
      attributes: i,
      indices: s,
      modelMatrix: l,
      cartographicOrigin: o,
      coordinateSystem: d = Ln.METER_OFFSETS,
      material: m,
      featureIds: b
    } = n, {
      _getMeshColor: A
    } = this.props, M = t && t.props.mesh || new Xd({
      topology: "triangle-list",
      attributes: SX(i),
      indices: s
    }), E = this.getSubLayerClass("mesh", hx);
    return new E(this.getSubLayerProps({
      id: "mesh"
    }), {
      id: `${this.id}-mesh-${e.id}`,
      tile: e,
      mesh: M,
      data: US,
      getColor: A(e),
      pbrMaterial: m,
      modelMatrix: l,
      coordinateOrigin: o,
      coordinateSystem: d,
      featureIds: b,
      _offset: 0
    });
  }
  renderLayers() {
    const {
      tileset3d: e,
      layerMap: t
    } = this.state;
    return e ? e.tiles.map((n) => {
      const i = t[n.id] = t[n.id] || {
        tile: n
      };
      let {
        layer: s
      } = i;
      return n.selected && (s ? i.needsUpdate && (s = this._getSubLayer(n, s), i.needsUpdate = !1) : s = this._getSubLayer(n)), i.layer = s, s;
    }).filter(Boolean) : null;
  }
}
vx.defaultProps = TX;
vx.layerName = "Tile3DLayer";
function SX(r) {
  const e = {};
  return e.positions = {
    ...r.positions,
    value: new Float32Array(r.positions.value)
  }, r.normals && (e.normals = r.normals), r.texCoords && (e.texCoords = r.texCoords), r.colors && (e.colors = r.colors), r.uvRegions && (e.uvRegions = r.uvRegions), e;
}
var EX = Object.defineProperty, CX = (r, e, t) => e in r ? EX(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, $n = (r, e, t) => CX(r, typeof e != "symbol" ? e + "" : e, t);
class IX {
  constructor(e) {
    $n(this, "map"), $n(this, "width"), $n(this, "height"), $n(this, "svgCanvas"), $n(this, "xLine"), $n(this, "yLine"), $n(this, "color", "#535353"), this.map = e, this.mapResize = this.mapResize.bind(this);
  }
  create() {
    this.updateValues(), this.map !== void 0 ? (this.map.on("resize", this.mapResize), this.createCanvas(this.map.getCanvasContainer())) : console.error("map object is null");
  }
  updateValues() {
    var e, t;
    this.width = (e = this.map) == null ? void 0 : e.getCanvas().clientWidth, this.height = (t = this.map) == null ? void 0 : t.getCanvas().clientHeight;
  }
  mapResize() {
    this.updateValues(), this.updateCanvas();
  }
  updateCanvas() {
    if (this.svgCanvas !== void 0 && this.yLine !== void 0 && this.xLine !== void 0 && this.width !== void 0 && this.height !== void 0) {
      this.svgCanvas.setAttribute("width", `${this.width}px`), this.svgCanvas.setAttribute("height", `${this.height}px`);
      const e = this.width / 2, t = this.height / 2;
      this.yLine.setAttribute("x1", `${e}px`), this.yLine.setAttribute("y1", "0px"), this.yLine.setAttribute("x2", `${e}px`), this.yLine.setAttribute("y2", `${this.height}px`), this.xLine.setAttribute("x1", "0px"), this.xLine.setAttribute("y1", `${t}px`), this.xLine.setAttribute("x2", `${this.width}px`), this.xLine.setAttribute("y2", `${t}px`);
    } else console.error("element value is null");
  }
  createCanvas(e) {
    if (this.width !== void 0 && this.height !== void 0) {
      const t = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      t.style.position = "relative", t.setAttribute("width", `${this.width}px`), t.setAttribute("height", `${this.height}px`);
      const n = this.width / 2, i = this.height / 2;
      this.yLine = t.appendChild(this.createLine(n, 0, n, this.height, this.color, "2px")), this.xLine = t.appendChild(this.createLine(0, i, this.width, i, this.color, "2px")), e == null || e.appendChild(t), this.svgCanvas = t;
    }
  }
  createLine(e, t, n, i, s, l) {
    const o = document.createElementNS("http://www.w3.org/2000/svg", "line");
    return o.setAttribute("x1", e), o.setAttribute("y1", t), o.setAttribute("x2", n), o.setAttribute("y2", i), o.setAttribute("stroke-dasharray", "5,5"), o.setAttribute("stroke", s), o.setAttribute("stroke-width", l), o;
  }
  destroy() {
    this.xLine !== void 0 && (this.xLine.remove(), this.xLine = void 0), this.yLine !== void 0 && (this.yLine.remove(), this.yLine = void 0), this.svgCanvas !== void 0 && (this.svgCanvas.remove(), this.svgCanvas = void 0), this.map !== void 0 && (this.map.off("resize", this.mapResize), this.map = void 0);
  }
}
const Nv = { 72: 72, 96: 96, 200: 200, 300: 300, 400: 400 }, Ku = { JPEG: "jpg", PNG: "png", PDF: "pdf", SVG: "svg" }, pg = { Landscape: "landscape", Portrait: "portrait" }, Rf = {
  // A0, A1, B0, B1 are not working well.
  // A0: [1189, 841],
  // A1: [841, 594],
  LETTER: [279, 216],
  // 8.5x11 - works
  //TABLOID: [432,279] // 11x17 - not working currently prints to 11.68x8.27 in landscape
  A2: [594, 420],
  A3: [420, 297],
  A4: [297, 210],
  A5: [210, 148],
  A6: [148, 105],
  // B0: [1414, 1000],
  // B1: [1000, 707],
  B2: [707, 500],
  B3: [500, 353],
  B4: [353, 250],
  B5: [250, 176],
  B6: [176, 125]
}, dp = {
  // don't use inch unit. because page size setting is using mm unit.
  mm: "mm"
};
class MX {
  constructor(e) {
    $n(this, "map"), $n(this, "width"), $n(this, "height"), $n(this, "unit"), $n(this, "svgCanvas"), $n(this, "svgPath");
    var t, n, i;
    if (this.map = e, this.map === void 0) return;
    this.mapResize = this.mapResize.bind(this), this.map.on("resize", this.mapResize);
    const s = (t = this.map) == null ? void 0 : t.getCanvas().clientWidth, l = (n = this.map) == null ? void 0 : n.getCanvas().clientHeight, o = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    o.style.position = "absolute", o.style.top = "0px", o.style.left = "0px", o.setAttribute("width", `${s}px`), o.setAttribute("height", `${l}px`);
    const d = document.createElementNS("http://www.w3.org/2000/svg", "path");
    d.setAttribute("style", "fill:#888888;stroke-width:0"), d.setAttribute("fill-opacity", "0.5"), o.append(d), (i = this.map) == null || i.getCanvasContainer().appendChild(o), this.svgCanvas = o, this.svgPath = d;
  }
  mapResize() {
    this.generateCutOut();
  }
  updateArea(e, t) {
    this.width = e, this.height = t, this.unit = dp.mm, this.generateCutOut();
  }
  generateCutOut() {
    var e, t;
    if (this.map === void 0 || this.svgCanvas === void 0 || this.svgPath === void 0) return;
    const n = this.toPixels(this.width), i = this.toPixels(this.height), s = (e = this.map) == null ? void 0 : e.getCanvas().clientWidth, l = (t = this.map) == null ? void 0 : t.getCanvas().clientHeight, o = s / 2 - n / 2, d = o + n, m = l / 2 - i / 2, b = m + i;
    this.svgCanvas.setAttribute("width", `${s}px`), this.svgCanvas.setAttribute("height", `${l}px`), this.svgPath.setAttribute("d", `M 0 0 L ${s} 0 L ${s} ${l} L 0 ${l} M ${o} ${m} L ${o} ${b} L ${d} ${b} L ${d} ${m}`);
  }
  destroy() {
    this.svgCanvas !== void 0 && (this.svgCanvas.remove(), this.svgCanvas = void 0), this.map !== void 0 && (this.map = void 0);
  }
  /**
  * Convert mm/inch to pixel
  * @param length mm/inch length
  * @param conversionFactor DPI value. default is 96.
  */
  toPixels(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 96;
    return this.unit === dp.mm && (t /= 25.4), t * e;
  }
}
const MM = { PageSize: "Page Size", PageOrientation: "Page Orientation", Format: "Format", DPI: "DPI", Generate: "Generate", LanguageName: "English", LanguageCode: "en" }, PX = { PageSize: "Taille de page", PageOrientation: "Orientation de la page", Format: "Format", DPI: "DPI", Generate: "Générer", LanguageName: "Français", LanguageCode: "fr" }, RX = { PageSize: "Sivukoko", PageOrientation: "Sivun suunta", Format: "Muoto", DPI: "DPI", Generate: "Generoi", LanguageName: "Suomalainen", LanguageCode: "fi" }, BX = { PageSize: "Papierformat", PageOrientation: "Papierausrichtung", Format: "Dateiformat", DPI: "Druckauflösung", Generate: "Erstellen", LanguageName: "Deutsch", LanguageCode: "de" }, LX = { PageSize: "Sidstorlek", PageOrientation: "Sidorientering", Format: "Format", DPI: "DPI", Generate: "Generera", LanguageName: "Svenska", LanguageCode: "sv" }, OX = { PageSize: "Tamaño de página", PageOrientation: "Orientación de página", Format: "Formato", DPI: "DPI", Generate: "Generar", LanguageName: "Española", LanguageCode: "es" }, kX = { PageSize: "Mida", PageOrientation: "Orientació", Format: "Format", DPI: "DPI", Generate: "Genera", LanguageName: "Catalan", LanguageCode: "ca" }, NX = { PageSize: "Kích thước trang", PageOrientation: "Loại trang", Format: "Định dạng", DPI: "Mật độ điểm ảnh (DPI)", Generate: "Tạo", LanguageName: "Tiếng Việt", LanguageCode: "vi" }, DX = { PageSize: "Розмір сторінки", PageOrientation: "Орієнтація сторінки", Format: "Формат", DPI: "DPI", Generate: "Згенерувати", LanguageName: "українська", LanguageCode: "uk" }, FX = { PageSize: "页面大小", PageOrientation: "页面方向", Format: "格式", DPI: "像素", Generate: "导出", LanguageName: "简体字", LanguageCode: "zhHans" }, UX = { PageSize: "頁面大小", PageOrientation: "頁面方向", Format: "格式", DPI: "像素", Generate: "導出", LanguageName: "繁体字", LanguageCode: "zhHant" }, zX = { PageSize: "ページサイズ", PageOrientation: "ページ方向", Format: "フォーマット", DPI: "DPI（解像度）", Generate: "出力", LanguageName: "日本語", LanguageCode: "ja" }, jX = { PageSize: "Tamanho da página", PageOrientation: "Orientação da página", Format: "Formato", DPI: "DPI", Generate: "Gerar", LanguageName: "Português", LanguageCode: "pt" }, VX = [MM, PX, RX, BX, LX, OX, kX, NX, DX, FX, UX, zX, jX], $X = (r) => VX.find((e) => e.LanguageCode === r) ?? MM;
function ci(r) {
  "@babel/helpers - typeof";
  return ci = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, ci(r);
}
var ra = Uint8Array, yl = Uint16Array, xx = Int32Array, Wy = new ra([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), Xy = new ra([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), Dv = new ra([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), PM = function(r, e) {
  for (var t = new yl(31), n = 0; n < 31; ++n) t[n] = e += 1 << r[n - 1];
  for (var i = new xx(t[30]), n = 1; n < 30; ++n) for (var s = t[n]; s < t[n + 1]; ++s) i[s] = s - t[n] << 5 | n;
  return { b: t, r: i };
}, RM = PM(Wy, 2), BM = RM.b, Fv = RM.r;
BM[28] = 258, Fv[258] = 28;
var LM = PM(Xy, 0), qX = LM.b, zS = LM.r, Uv = new yl(32768);
for (var zi = 0; zi < 32768; ++zi) {
  var Lh = (zi & 43690) >> 1 | (zi & 21845) << 1;
  Lh = (Lh & 52428) >> 2 | (Lh & 13107) << 2, Lh = (Lh & 61680) >> 4 | (Lh & 3855) << 4, Uv[zi] = ((Lh & 65280) >> 8 | (Lh & 255) << 8) >> 1;
}
var yu = function(r, e, t) {
  for (var n = r.length, i = 0, s = new yl(e); i < n; ++i) r[i] && ++s[r[i] - 1];
  var l = new yl(e);
  for (i = 1; i < e; ++i) l[i] = l[i - 1] + s[i - 1] << 1;
  var o;
  if (t) {
    o = new yl(1 << e);
    var d = 15 - e;
    for (i = 0; i < n; ++i) if (r[i]) for (var m = i << 4 | r[i], b = e - r[i], A = l[r[i] - 1]++ << b, M = A | (1 << b) - 1; A <= M; ++A) o[Uv[A] >> d] = m;
  } else for (o = new yl(n), i = 0; i < n; ++i) r[i] && (o[i] = Uv[l[r[i] - 1]++] >> 15 - r[i]);
  return o;
}, Yh = new ra(288);
for (var zi = 0; zi < 144; ++zi) Yh[zi] = 8;
for (var zi = 144; zi < 256; ++zi) Yh[zi] = 9;
for (var zi = 256; zi < 280; ++zi) Yh[zi] = 7;
for (var zi = 280; zi < 288; ++zi) Yh[zi] = 8;
var Vg = new ra(32);
for (var zi = 0; zi < 32; ++zi) Vg[zi] = 5;
var GX = /* @__PURE__ */ yu(Yh, 9, 0), HX = /* @__PURE__ */ yu(Yh, 9, 1), WX = /* @__PURE__ */ yu(Vg, 5, 0), XX = /* @__PURE__ */ yu(Vg, 5, 1), a1 = function(r) {
  for (var e = r[0], t = 1; t < r.length; ++t) r[t] > e && (e = r[t]);
  return e;
}, gc = function(r, e, t) {
  var n = e / 8 | 0;
  return (r[n] | r[n + 1] << 8) >> (e & 7) & t;
}, l1 = function(r, e) {
  var t = e / 8 | 0;
  return (r[t] | r[t + 1] << 8 | r[t + 2] << 16) >> (e & 7);
}, wx = function(r) {
  return (r + 7) / 8 | 0;
}, OM = function(r, e, t) {
  return (t == null || t > r.length) && (t = r.length), new ra(r.subarray(e, t));
}, ZX = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
], vc = function(r, e, t) {
  var n = new Error(e || ZX[r]);
  if (n.code = r, Error.captureStackTrace && Error.captureStackTrace(n, vc), !t) throw n;
  return n;
}, YX = function(r, e, t, n) {
  var i = r.length, s = 0;
  if (!i || e.f && !e.l) return t || new ra(0);
  var l = !t, o = l || e.i != 2, d = e.i;
  l && (t = new ra(i * 3));
  var m = function(Kt) {
    var vr = t.length;
    if (Kt > vr) {
      var sr = new ra(Math.max(vr * 2, Kt));
      sr.set(t), t = sr;
    }
  }, b = e.f || 0, A = e.p || 0, M = e.b || 0, E = e.l, k = e.d, U = e.m, V = e.n, q = i * 8;
  do {
    if (!E) {
      b = gc(r, A, 1);
      var Y = gc(r, A + 1, 3);
      if (A += 3, Y)
        if (Y == 1) E = HX, k = XX, U = 9, V = 5;
        else if (Y == 2) {
          var re = gc(r, A, 31) + 257, Z = gc(r, A + 10, 15) + 4, K = re + gc(r, A + 5, 31) + 1;
          A += 14;
          for (var ie = new ra(K), be = new ra(19), he = 0; he < Z; ++he) be[Dv[he]] = gc(r, A + he * 3, 7);
          A += Z * 3;
          for (var Be = a1(be), ke = (1 << Be) - 1, pe = yu(be, Be, 1), he = 0; he < K; ) {
            var me = pe[gc(r, A, ke)];
            A += me & 15;
            var je = me >> 4;
            if (je < 16) ie[he++] = je;
            else {
              var Pe = 0, St = 0;
              for (je == 16 ? (St = 3 + gc(r, A, 3), A += 2, Pe = ie[he - 1]) : je == 17 ? (St = 3 + gc(r, A, 7), A += 3) : je == 18 && (St = 11 + gc(r, A, 127), A += 7); St--; ) ie[he++] = Pe;
            }
          }
          var Mt = ie.subarray(0, re), Lt = ie.subarray(re);
          U = a1(Mt), V = a1(Lt), E = yu(Mt, U, 1), k = yu(Lt, V, 1);
        } else vc(1);
      else {
        var je = wx(A) + 4, xt = r[je - 4] | r[je - 3] << 8, zt = je + xt;
        if (zt > i) {
          d && vc(0);
          break;
        }
        o && m(M + xt), t.set(r.subarray(je, zt), M), e.b = M += xt, e.p = A = zt * 8, e.f = b;
        continue;
      }
      if (A > q) {
        d && vc(0);
        break;
      }
    }
    o && m(M + 131072);
    for (var Dt = (1 << U) - 1, hr = (1 << V) - 1, ce = A; ; ce = A) {
      var Pe = E[l1(r, A) & Dt], Oe = Pe >> 4;
      if (A += Pe & 15, A > q) {
        d && vc(0);
        break;
      }
      if (Pe || vc(2), Oe < 256) t[M++] = Oe;
      else if (Oe == 256) {
        ce = A, E = null;
        break;
      } else {
        var $e = Oe - 254;
        if (Oe > 264) {
          var he = Oe - 257, et = Wy[he];
          $e = gc(r, A, (1 << et) - 1) + BM[he], A += et;
        }
        var ot = k[l1(r, A) & hr], ht = ot >> 4;
        ot || vc(3), A += ot & 15;
        var Lt = qX[ht];
        if (ht > 3) {
          var et = Xy[ht];
          Lt += l1(r, A) & (1 << et) - 1, A += et;
        }
        if (A > q) {
          d && vc(0);
          break;
        }
        o && m(M + 131072);
        var It = M + $e;
        if (M < Lt) {
          var yt = s - Lt, ar = Math.min(Lt, It);
          for (yt + M < 0 && vc(3); M < ar; ++M) t[M] = n[yt + M];
        }
        for (; M < It; ++M) t[M] = t[M - Lt];
      }
    }
    e.l = E, e.p = ce, e.b = M, e.f = b, E && (b = 1, e.m = U, e.d = k, e.n = V);
  } while (!b);
  return M != t.length && l ? OM(t, 0, M) : t.subarray(0, M);
}, Wu = function(r, e, t) {
  t <<= e & 7;
  var n = e / 8 | 0;
  r[n] |= t, r[n + 1] |= t >> 8;
}, tg = function(r, e, t) {
  t <<= e & 7;
  var n = e / 8 | 0;
  r[n] |= t, r[n + 1] |= t >> 8, r[n + 2] |= t >> 16;
}, c1 = function(r, e) {
  for (var t = [], n = 0; n < r.length; ++n) r[n] && t.push({ s: n, f: r[n] });
  var i = t.length, s = t.slice();
  if (!i) return { t: NM, l: 0 };
  if (i == 1) {
    var l = new ra(t[0].s + 1);
    return l[t[0].s] = 1, { t: l, l: 1 };
  }
  t.sort(function(K, ie) {
    return K.f - ie.f;
  }), t.push({ s: -1, f: 25001 });
  var o = t[0], d = t[1], m = 0, b = 1, A = 2;
  for (t[0] = { s: -1, f: o.f + d.f, l: o, r: d }; b != i - 1; ) o = t[t[m].f < t[A].f ? m++ : A++], d = t[m != b && t[m].f < t[A].f ? m++ : A++], t[b++] = { s: -1, f: o.f + d.f, l: o, r: d };
  for (var M = s[0].s, n = 1; n < i; ++n) s[n].s > M && (M = s[n].s);
  var E = new yl(M + 1), k = zv(t[b - 1], E, 0);
  if (k > e) {
    var n = 0, U = 0, V = k - e, q = 1 << V;
    for (s.sort(function(ie, be) {
      return E[be.s] - E[ie.s] || ie.f - be.f;
    }); n < i; ++n) {
      var Y = s[n].s;
      if (E[Y] > e) U += q - (1 << k - E[Y]), E[Y] = e;
      else break;
    }
    for (U >>= V; U > 0; ) {
      var re = s[n].s;
      E[re] < e ? U -= 1 << e - E[re]++ - 1 : ++n;
    }
    for (; n >= 0 && U; --n) {
      var Z = s[n].s;
      E[Z] == e && (--E[Z], ++U);
    }
    k = e;
  }
  return { t: new ra(E), l: k };
}, zv = function(r, e, t) {
  return r.s == -1 ? Math.max(zv(r.l, e, t + 1), zv(r.r, e, t + 1)) : e[r.s] = t;
}, jS = function(r) {
  for (var e = r.length; e && !r[--e]; ) ;
  for (var t = new yl(++e), n = 0, i = r[0], s = 1, l = function(d) {
    t[n++] = d;
  }, o = 1; o <= e; ++o) if (r[o] == i && o != e) ++s;
  else {
    if (!i && s > 2) {
      for (; s > 138; s -= 138) l(32754);
      s > 2 && (l(s > 10 ? s - 11 << 5 | 28690 : s - 3 << 5 | 12305), s = 0);
    } else if (s > 3) {
      for (l(i), --s; s > 6; s -= 6) l(8304);
      s > 2 && (l(s - 3 << 5 | 8208), s = 0);
    }
    for (; s--; ) l(i);
    s = 1, i = r[o];
  }
  return { c: t.subarray(0, n), n: e };
}, rg = function(r, e) {
  for (var t = 0, n = 0; n < e.length; ++n) t += r[n] * e[n];
  return t;
}, kM = function(r, e, t) {
  var n = t.length, i = wx(e + 2);
  r[i] = n & 255, r[i + 1] = n >> 8, r[i + 2] = r[i] ^ 255, r[i + 3] = r[i + 1] ^ 255;
  for (var s = 0; s < n; ++s) r[i + s + 4] = t[s];
  return (i + 4 + n) * 8;
}, VS = function(r, e, t, n, i, s, l, o, d, m, b) {
  Wu(e, b++, t), ++i[256];
  for (var A = c1(i, 15), M = A.t, E = A.l, k = c1(s, 15), U = k.t, V = k.l, q = jS(M), Y = q.c, re = q.n, Z = jS(U), K = Z.c, ie = Z.n, be = new yl(19), he = 0; he < Y.length; ++he) ++be[Y[he] & 31];
  for (var he = 0; he < K.length; ++he) ++be[K[he] & 31];
  for (var Be = c1(be, 7), ke = Be.t, pe = Be.l, me = 19; me > 4 && !ke[Dv[me - 1]]; --me) ;
  var je = m + 5 << 3, Pe = rg(i, Yh) + rg(s, Vg) + l, St = rg(i, M) + rg(s, U) + l + 14 + 3 * me + rg(be, ke) + 2 * be[16] + 3 * be[17] + 7 * be[18];
  if (d >= 0 && je <= Pe && je <= St) return kM(e, b, r.subarray(d, d + m));
  var Mt, Lt, xt, zt;
  if (Wu(e, b, 1 + (St < Pe)), b += 2, St < Pe) {
    Mt = yu(M, E, 0), Lt = M, xt = yu(U, V, 0), zt = U;
    var Dt = yu(ke, pe, 0);
    Wu(e, b, re - 257), Wu(e, b + 5, ie - 1), Wu(e, b + 10, me - 4), b += 14;
    for (var he = 0; he < me; ++he) Wu(e, b + 3 * he, ke[Dv[he]]);
    b += 3 * me;
    for (var hr = [Y, K], ce = 0; ce < 2; ++ce) for (var Oe = hr[ce], he = 0; he < Oe.length; ++he) {
      var $e = Oe[he] & 31;
      Wu(e, b, Dt[$e]), b += ke[$e], $e > 15 && (Wu(e, b, Oe[he] >> 5 & 127), b += Oe[he] >> 12);
    }
  } else Mt = GX, Lt = Yh, xt = WX, zt = Vg;
  for (var he = 0; he < o; ++he) {
    var et = n[he];
    if (et > 255) {
      var $e = et >> 18 & 31;
      tg(e, b, Mt[$e + 257]), b += Lt[$e + 257], $e > 7 && (Wu(e, b, et >> 23 & 31), b += Wy[$e]);
      var ot = et & 31;
      tg(e, b, xt[ot]), b += zt[ot], ot > 3 && (tg(e, b, et >> 5 & 8191), b += Xy[ot]);
    } else tg(e, b, Mt[et]), b += Lt[et];
  }
  return tg(e, b, Mt[256]), b + Lt[256];
}, KX = /* @__PURE__ */ new xx([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), NM = /* @__PURE__ */ new ra(0), JX = function(r, e, t, n, i, s) {
  var l = s.z || r.length, o = new ra(n + l + 5 * (1 + Math.ceil(l / 7e3)) + i), d = o.subarray(n, o.length - i), m = s.l, b = (s.r || 0) & 7;
  if (e) {
    b && (d[0] = s.r >> 3);
    for (var A = KX[e - 1], M = A >> 13, E = A & 8191, k = (1 << t) - 1, U = s.p || new yl(32768), V = s.h || new yl(k + 1), q = Math.ceil(t / 3), Y = 2 * q, re = function(Ur) {
      return (r[Ur] ^ r[Ur + 1] << q ^ r[Ur + 2] << Y) & k;
    }, Z = new xx(25e3), K = new yl(288), ie = new yl(32), be = 0, he = 0, Be = s.i || 0, ke = 0, pe = s.w || 0, me = 0; Be + 2 < l; ++Be) {
      var je = re(Be), Pe = Be & 32767, St = V[je];
      if (U[Pe] = St, V[je] = Pe, pe <= Be) {
        var Mt = l - Be;
        if ((be > 7e3 || ke > 24576) && (Mt > 423 || !m)) {
          b = VS(r, d, 0, Z, K, ie, he, ke, me, Be - me, b), ke = be = he = 0, me = Be;
          for (var Lt = 0; Lt < 286; ++Lt) K[Lt] = 0;
          for (var Lt = 0; Lt < 30; ++Lt) ie[Lt] = 0;
        }
        var xt = 2, zt = 0, Dt = E, hr = Pe - St & 32767;
        if (Mt > 2 && je == re(Be - hr)) for (var ce = Math.min(M, Mt) - 1, Oe = Math.min(32767, Be), $e = Math.min(258, Mt); hr <= Oe && --Dt && Pe != St; ) {
          if (r[Be + xt] == r[Be + xt - hr]) {
            for (var et = 0; et < $e && r[Be + et] == r[Be + et - hr]; ++et) ;
            if (et > xt) {
              if (xt = et, zt = hr, et > ce) break;
              for (var ot = Math.min(hr, et - 2), ht = 0, Lt = 0; Lt < ot; ++Lt) {
                var It = Be - hr + Lt & 32767, yt = U[It], ar = It - yt & 32767;
                ar > ht && (ht = ar, St = It);
              }
            }
          }
          Pe = St, St = U[Pe], hr += Pe - St & 32767;
        }
        if (zt) {
          Z[ke++] = 268435456 | Fv[xt] << 18 | zS[zt];
          var Kt = Fv[xt] & 31, vr = zS[zt] & 31;
          he += Wy[Kt] + Xy[vr], ++K[257 + Kt], ++ie[vr], pe = Be + xt, ++be;
        } else Z[ke++] = r[Be], ++K[r[Be]];
      }
    }
    for (Be = Math.max(Be, pe); Be < l; ++Be) Z[ke++] = r[Be], ++K[r[Be]];
    b = VS(r, d, m, Z, K, ie, he, ke, me, Be - me, b), m || (s.r = b & 7 | d[b / 8 | 0] << 3, b -= 7, s.h = V, s.p = U, s.i = Be, s.w = pe);
  } else {
    for (var Be = s.w || 0; Be < l + m; Be += 65535) {
      var sr = Be + 65535;
      sr >= l && (d[b / 8 | 0] = m, sr = l), b = kM(d, b + 1, r.subarray(Be, sr));
    }
    s.i = l;
  }
  return OM(o, 0, n + wx(b) + i);
}, DM = function() {
  var r = 1, e = 0;
  return { p: function(t) {
    for (var n = r, i = e, s = t.length | 0, l = 0; l != s; ) {
      for (var o = Math.min(l + 2655, s); l < o; ++l) i += n += t[l];
      n = (n & 65535) + 15 * (n >> 16), i = (i & 65535) + 15 * (i >> 16);
    }
    r = n, e = i;
  }, d: function() {
    return r %= 65521, e %= 65521, (r & 255) << 24 | (r & 65280) << 8 | (e & 255) << 8 | e >> 8;
  } };
}, QX = function(r, e, t, n, i) {
  if (!i && (i = { l: 1 }, e.dictionary)) {
    var s = e.dictionary.subarray(-32768), l = new ra(s.length + r.length);
    l.set(s), l.set(r, s.length), r = l, i.w = s.length;
  }
  return JX(r, e.level == null ? 6 : e.level, e.mem == null ? i.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(r.length))) * 1.5) : 20 : 12 + e.mem, t, n, i);
}, FM = function(r, e, t) {
  for (; t; ++e) r[e] = t, t >>>= 8;
}, eZ = function(r, e) {
  var t = e.level, n = t == 0 ? 0 : t < 6 ? 1 : t == 9 ? 3 : 2;
  if (r[0] = 120, r[1] = n << 6 | (e.dictionary && 32), r[1] |= 31 - (r[0] << 8 | r[1]) % 31, e.dictionary) {
    var i = DM();
    i.p(e.dictionary), FM(r, 2, i.d());
  }
}, tZ = function(r, e) {
  return ((r[0] & 15) != 8 || r[0] >> 4 > 7 || (r[0] << 8 | r[1]) % 31) && vc(6, "invalid zlib data"), (r[1] >> 5 & 1) == 1 && vc(6, "invalid zlib data: " + (r[1] & 32 ? "need" : "unexpected") + " dictionary"), (r[1] >> 3 & 4) + 2;
};
function jv(r, e) {
  e || (e = {});
  var t = DM();
  t.p(r);
  var n = QX(r, e, e.dictionary ? 6 : 2, 4);
  return eZ(n, e), FM(n, n.length - 4, t.d()), n;
}
function rZ(r, e) {
  return YX(r.subarray(tZ(r), -4), { i: 2 }, e, e);
}
var nZ = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), iZ = 0;
try {
  nZ.decode(NM, { stream: !0 }), iZ = 1;
} catch {
}
/** @license
*
* jsPDF - PDF Document creation from JavaScript
* Version 3.0.0 Built on 2025-02-19T09:26:58.791Z
*                      CommitID 00000000
*
* Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
*               2015-2021 yWorks GmbH, http://www.yworks.com
*               2015-2021 Lukas Holländer <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
*               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
*               2010 Aaron Spike, https://github.com/acspike
*               2012 Willow Systems Corporation, https://github.com/willowsystems
*               2012 Pablo Hess, https://github.com/pablohess
*               2012 Florian Jenett, https://github.com/fjenett
*               2013 Warren Weckesser, https://github.com/warrenweckesser
*               2013 Youssef Beddad, https://github.com/lifof
*               2013 Lee Driscoll, https://github.com/lsdriscoll
*               2013 Stefan Slonevskiy, https://github.com/stefslon
*               2013 Jeremy Morel, https://github.com/jmorel
*               2013 Christoph Hartmann, https://github.com/chris-rock
*               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
*               2014 James Makes, https://github.com/dollaruw
*               2014 Diego Casorran, https://github.com/diegocr
*               2014 Steven Spungin, https://github.com/Flamenco
*               2014 Kenneth Glassey, https://github.com/Gavvers
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*
* Contributor(s):
*    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
*    kim3er, mfo, alnorth, Flamenco
*/
var on = /* @__PURE__ */ function() {
  return typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : this;
}();
function u1() {
  on.console && typeof on.console.log == "function" && on.console.log.apply(on.console, arguments);
}
var Ii = { log: u1, warn: function(r) {
  on.console && (typeof on.console.warn == "function" ? on.console.warn.apply(on.console, arguments) : u1.call(null, arguments));
}, error: function(r) {
  on.console && (typeof on.console.error == "function" ? on.console.error.apply(on.console, arguments) : u1(r));
} };
function h1(r, e, t) {
  var n = new XMLHttpRequest();
  n.open("GET", r), n.responseType = "blob", n.onload = function() {
    Af(n.response, e, t);
  }, n.onerror = function() {
    Ii.error("could not download file");
  }, n.send();
}
function $S(r) {
  var e = new XMLHttpRequest();
  e.open("HEAD", r, !1);
  try {
    e.send();
  } catch {
  }
  return e.status >= 200 && e.status <= 299;
}
function Qm(r) {
  try {
    r.dispatchEvent(new MouseEvent("click"));
  } catch {
    var e = document.createEvent("MouseEvents");
    e.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), r.dispatchEvent(e);
  }
}
var Eg, Vv, Af = on.saveAs || ((typeof window > "u" ? "undefined" : ci(window)) !== "object" || window !== on ? function() {
} : typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype ? function(r, e, t) {
  var n = on.URL || on.webkitURL, i = document.createElement("a");
  e = e || r.name || "download", i.download = e, i.rel = "noopener", typeof r == "string" ? (i.href = r, i.origin !== location.origin ? $S(i.href) ? h1(r, e, t) : Qm(i, i.target = "_blank") : Qm(i)) : (i.href = n.createObjectURL(r), setTimeout(function() {
    n.revokeObjectURL(i.href);
  }, 4e4), setTimeout(function() {
    Qm(i);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(r, e, t) {
  if (e = e || r.name || "download", typeof r == "string")
    if ($S(r)) h1(r, e, t);
    else {
      var n = document.createElement("a");
      n.href = r, n.target = "_blank", setTimeout(function() {
        Qm(n);
      });
    }
  else navigator.msSaveOrOpenBlob(function(i, s) {
    return s === void 0 ? s = { autoBom: !1 } : ci(s) !== "object" && (Ii.warn("Deprecated: Expected third argument to be a object"), s = { autoBom: !s }), s.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(i.type) ? new Blob(["\uFEFF", i], { type: i.type }) : i;
  }(r, t), e);
} : function(r, e, t, n) {
  if ((n = n || open("", "_blank")) && (n.document.title = n.document.body.innerText = "downloading..."), typeof r == "string") return h1(r, e, t);
  var i = r.type === "application/octet-stream", s = /constructor/i.test(on.HTMLElement) || on.safari, l = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((l || i && s) && (typeof FileReader > "u" ? "undefined" : ci(FileReader)) === "object") {
    var o = new FileReader();
    o.onloadend = function() {
      var b = o.result;
      b = l ? b : b.replace(/^data:[^;]*;/, "data:attachment/file;"), n ? n.location.href = b : location = b, n = null;
    }, o.readAsDataURL(r);
  } else {
    var d = on.URL || on.webkitURL, m = d.createObjectURL(r);
    n ? n.location = m : location.href = m, n = null, setTimeout(function() {
      d.revokeObjectURL(m);
    }, 4e4);
  }
});
/**
* A class to parse color values
* @author Stoyan Stefanov <sstoo@gmail.com>
* {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
* @license Use it if you like it
*/
function UM(r) {
  var e;
  r = r || "", this.ok = !1, r.charAt(0) == "#" && (r = r.substr(1, 6)), r = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[r = (r = r.replace(/ /g, "")).toLowerCase()] || r;
  for (var t = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(o) {
    return [parseInt(o[1]), parseInt(o[2]), parseInt(o[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(o) {
    return [parseInt(o[1], 16), parseInt(o[2], 16), parseInt(o[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(o) {
    return [parseInt(o[1] + o[1], 16), parseInt(o[2] + o[2], 16), parseInt(o[3] + o[3], 16)];
  } }], n = 0; n < t.length; n++) {
    var i = t[n].re, s = t[n].process, l = i.exec(r);
    l && (e = s(l), this.r = e[0], this.g = e[1], this.b = e[2], this.ok = !0);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var o = this.r.toString(16), d = this.g.toString(16), m = this.b.toString(16);
    return o.length == 1 && (o = "0" + o), d.length == 1 && (d = "0" + d), m.length == 1 && (m = "0" + m), "#" + o + d + m;
  };
}
/**
* @license
* Joseph Myers does not specify a particular license for his work.
*
* Author: Joseph Myers
* Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
*
* Modified by: Owen Leong
*/
function f1(r, e) {
  var t = r[0], n = r[1], i = r[2], s = r[3];
  t = Xo(t, n, i, s, e[0], 7, -680876936), s = Xo(s, t, n, i, e[1], 12, -389564586), i = Xo(i, s, t, n, e[2], 17, 606105819), n = Xo(n, i, s, t, e[3], 22, -1044525330), t = Xo(t, n, i, s, e[4], 7, -176418897), s = Xo(s, t, n, i, e[5], 12, 1200080426), i = Xo(i, s, t, n, e[6], 17, -1473231341), n = Xo(n, i, s, t, e[7], 22, -45705983), t = Xo(t, n, i, s, e[8], 7, 1770035416), s = Xo(s, t, n, i, e[9], 12, -1958414417), i = Xo(i, s, t, n, e[10], 17, -42063), n = Xo(n, i, s, t, e[11], 22, -1990404162), t = Xo(t, n, i, s, e[12], 7, 1804603682), s = Xo(s, t, n, i, e[13], 12, -40341101), i = Xo(i, s, t, n, e[14], 17, -1502002290), t = Zo(t, n = Xo(n, i, s, t, e[15], 22, 1236535329), i, s, e[1], 5, -165796510), s = Zo(s, t, n, i, e[6], 9, -1069501632), i = Zo(i, s, t, n, e[11], 14, 643717713), n = Zo(n, i, s, t, e[0], 20, -373897302), t = Zo(t, n, i, s, e[5], 5, -701558691), s = Zo(s, t, n, i, e[10], 9, 38016083), i = Zo(i, s, t, n, e[15], 14, -660478335), n = Zo(n, i, s, t, e[4], 20, -405537848), t = Zo(t, n, i, s, e[9], 5, 568446438), s = Zo(s, t, n, i, e[14], 9, -1019803690), i = Zo(i, s, t, n, e[3], 14, -187363961), n = Zo(n, i, s, t, e[8], 20, 1163531501), t = Zo(t, n, i, s, e[13], 5, -1444681467), s = Zo(s, t, n, i, e[2], 9, -51403784), i = Zo(i, s, t, n, e[7], 14, 1735328473), t = Yo(t, n = Zo(n, i, s, t, e[12], 20, -1926607734), i, s, e[5], 4, -378558), s = Yo(s, t, n, i, e[8], 11, -2022574463), i = Yo(i, s, t, n, e[11], 16, 1839030562), n = Yo(n, i, s, t, e[14], 23, -35309556), t = Yo(t, n, i, s, e[1], 4, -1530992060), s = Yo(s, t, n, i, e[4], 11, 1272893353), i = Yo(i, s, t, n, e[7], 16, -155497632), n = Yo(n, i, s, t, e[10], 23, -1094730640), t = Yo(t, n, i, s, e[13], 4, 681279174), s = Yo(s, t, n, i, e[0], 11, -358537222), i = Yo(i, s, t, n, e[3], 16, -722521979), n = Yo(n, i, s, t, e[6], 23, 76029189), t = Yo(t, n, i, s, e[9], 4, -640364487), s = Yo(s, t, n, i, e[12], 11, -421815835), i = Yo(i, s, t, n, e[15], 16, 530742520), t = Ko(t, n = Yo(n, i, s, t, e[2], 23, -995338651), i, s, e[0], 6, -198630844), s = Ko(s, t, n, i, e[7], 10, 1126891415), i = Ko(i, s, t, n, e[14], 15, -1416354905), n = Ko(n, i, s, t, e[5], 21, -57434055), t = Ko(t, n, i, s, e[12], 6, 1700485571), s = Ko(s, t, n, i, e[3], 10, -1894986606), i = Ko(i, s, t, n, e[10], 15, -1051523), n = Ko(n, i, s, t, e[1], 21, -2054922799), t = Ko(t, n, i, s, e[8], 6, 1873313359), s = Ko(s, t, n, i, e[15], 10, -30611744), i = Ko(i, s, t, n, e[6], 15, -1560198380), n = Ko(n, i, s, t, e[13], 21, 1309151649), t = Ko(t, n, i, s, e[4], 6, -145523070), s = Ko(s, t, n, i, e[11], 10, -1120210379), i = Ko(i, s, t, n, e[2], 15, 718787259), n = Ko(n, i, s, t, e[9], 21, -343485551), r[0] = jh(t, r[0]), r[1] = jh(n, r[1]), r[2] = jh(i, r[2]), r[3] = jh(s, r[3]);
}
function Zy(r, e, t, n, i, s) {
  return e = jh(jh(e, r), jh(n, s)), jh(e << i | e >>> 32 - i, t);
}
function Xo(r, e, t, n, i, s, l) {
  return Zy(e & t | ~e & n, r, e, i, s, l);
}
function Zo(r, e, t, n, i, s, l) {
  return Zy(e & n | t & ~n, r, e, i, s, l);
}
function Yo(r, e, t, n, i, s, l) {
  return Zy(e ^ t ^ n, r, e, i, s, l);
}
function Ko(r, e, t, n, i, s, l) {
  return Zy(t ^ (e | ~n), r, e, i, s, l);
}
function zM(r) {
  var e, t = r.length, n = [1732584193, -271733879, -1732584194, 271733878];
  for (e = 64; e <= r.length; e += 64) f1(n, sZ(r.substring(e - 64, e)));
  r = r.substring(e - 64);
  var i = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (e = 0; e < r.length; e++) i[e >> 2] |= r.charCodeAt(e) << (e % 4 << 3);
  if (i[e >> 2] |= 128 << (e % 4 << 3), e > 55) for (f1(n, i), e = 0; e < 16; e++) i[e] = 0;
  return i[14] = 8 * t, f1(n, i), n;
}
function sZ(r) {
  var e, t = [];
  for (e = 0; e < 64; e += 4) t[e >> 2] = r.charCodeAt(e) + (r.charCodeAt(e + 1) << 8) + (r.charCodeAt(e + 2) << 16) + (r.charCodeAt(e + 3) << 24);
  return t;
}
Eg = on.atob.bind(on), Vv = on.btoa.bind(on);
var qS = "0123456789abcdef".split("");
function oZ(r) {
  for (var e = "", t = 0; t < 4; t++) e += qS[r >> 8 * t + 4 & 15] + qS[r >> 8 * t & 15];
  return e;
}
function aZ(r) {
  return String.fromCharCode((255 & r) >> 0, (65280 & r) >> 8, (16711680 & r) >> 16, (4278190080 & r) >> 24);
}
function $v(r) {
  return zM(r).map(aZ).join("");
}
var lZ = function(r) {
  for (var e = 0; e < r.length; e++) r[e] = oZ(r[e]);
  return r.join("");
}(zM("hello")) != "5d41402abc4b2a76b9719d911017c592";
function jh(r, e) {
  if (lZ) {
    var t = (65535 & r) + (65535 & e);
    return (r >> 16) + (e >> 16) + (t >> 16) << 16 | 65535 & t;
  }
  return r + e & 4294967295;
}
/**
* @license
* FPDF is released under a permissive license: there is no usage restriction.
* You may embed it freely in your application (commercial or not), with or
* without modifications.
*
* Reference: http://www.fpdf.org/en/script/script37.php
*/
function qv(r, e) {
  var t, n, i, s;
  if (r !== t) {
    for (var l = (i = r, s = 1 + (256 / r.length >> 0), new Array(s + 1).join(i)), o = [], d = 0; d < 256; d++) o[d] = d;
    var m = 0;
    for (d = 0; d < 256; d++) {
      var b = o[d];
      m = (m + b + l.charCodeAt(d)) % 256, o[d] = o[m], o[m] = b;
    }
    t = r, n = o;
  } else o = n;
  var A = e.length, M = 0, E = 0, k = "";
  for (d = 0; d < A; d++) E = (E + (b = o[M = (M + 1) % 256])) % 256, o[M] = o[E], o[E] = b, l = o[(o[M] + o[E]) % 256], k += String.fromCharCode(e.charCodeAt(d) ^ l);
  return k;
}
/**
* @license
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
* Author: Owen Leong (@owenl131)
* Date: 15 Oct 2020
* References:
* https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
* https://github.com/foliojs/pdfkit/blob/master/lib/security.js
* http://www.fpdf.org/en/script/script37.php
*/
var GS = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function Ld(r, e, t, n) {
  this.v = 1, this.r = 2;
  var i = 192;
  r.forEach(function(o) {
    if (GS.perm !== void 0) throw new Error("Invalid permission: " + o);
    i += GS[o];
  }), this.padding = "(¿N^NuAd\0NVÿú\b..\0¶Ðh>/\f©þdSiz";
  var s = (e + this.padding).substr(0, 32), l = (t + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(s, l), this.P = -(1 + (255 ^ i)), this.encryptionKey = $v(s + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(n)).substr(0, 5), this.U = qv(this.encryptionKey, this.padding);
}
function Od(r) {
  if (/[^\u0000-\u00ff]/.test(r)) throw new Error("Invalid PDF Name Object: " + r + ", Only accept ASCII characters.");
  for (var e = "", t = r.length, n = 0; n < t; n++) {
    var i = r.charCodeAt(n);
    i < 33 || i === 35 || i === 37 || i === 40 || i === 41 || i === 47 || i === 60 || i === 62 || i === 91 || i === 93 || i === 123 || i === 125 || i > 126 ? e += "#" + ("0" + i.toString(16)).slice(-2) : e += r[n];
  }
  return e;
}
function HS(r) {
  if (ci(r) !== "object") throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var e = {};
  this.subscribe = function(t, n, i) {
    if (i = i || !1, typeof t != "string" || typeof n != "function" || typeof i != "boolean") throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    e.hasOwnProperty(t) || (e[t] = {});
    var s = Math.random().toString(35);
    return e[t][s] = [n, !!i], s;
  }, this.unsubscribe = function(t) {
    for (var n in e) if (e[n][t]) return delete e[n][t], Object.keys(e[n]).length === 0 && delete e[n], !0;
    return !1;
  }, this.publish = function(t) {
    if (e.hasOwnProperty(t)) {
      var n = Array.prototype.slice.call(arguments, 1), i = [];
      for (var s in e[t]) {
        var l = e[t][s];
        try {
          l[0].apply(r, n);
        } catch (o) {
          on.console && Ii.error("jsPDF PubSub Error", o.message, o);
        }
        l[1] && i.push(s);
      }
      i.length && i.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return e;
  };
}
function hy(r) {
  if (!(this instanceof hy)) return new hy(r);
  var e = "opacity,stroke-opacity".split(",");
  for (var t in r) r.hasOwnProperty(t) && e.indexOf(t) >= 0 && (this[t] = r[t]);
  this.id = "", this.objectNumber = -1;
}
function jM(r, e) {
  this.gState = r, this.matrix = e, this.id = "", this.objectNumber = -1;
}
function Ef(r, e, t, n, i) {
  if (!(this instanceof Ef)) return new Ef(r, e, t, n, i);
  this.type = r === "axial" ? 2 : 3, this.coords = e, this.colors = t, jM.call(this, n, i);
}
function qd(r, e, t, n, i) {
  if (!(this instanceof qd)) return new qd(r, e, t, n, i);
  this.boundingBox = r, this.xStep = e, this.yStep = t, this.stream = "", this.cloneIndex = 0, jM.call(this, n, i);
}
function rn(r) {
  var e, t = typeof arguments[0] == "string" ? arguments[0] : "p", n = arguments[1], i = arguments[2], s = arguments[3], l = [], o = 1, d = 16, m = "S", b = null;
  ci(r = r || {}) === "object" && (t = r.orientation, n = r.unit || n, i = r.format || i, s = r.compress || r.compressPdf || s, (b = r.encryption || null) !== null && (b.userPassword = b.userPassword || "", b.ownerPassword = b.ownerPassword || "", b.userPermissions = b.userPermissions || []), o = typeof r.userUnit == "number" ? Math.abs(r.userUnit) : 1, r.precision !== void 0 && (e = r.precision), r.floatPrecision !== void 0 && (d = r.floatPrecision), m = r.defaultPathOperation || "S"), l = r.filters || (s === !0 ? ["FlateEncode"] : l), n = n || "mm", t = ("" + (t || "P")).toLowerCase();
  var A = r.putOnlyUsedFonts || !1, M = {}, E = { internal: {}, __private__: {} };
  E.__private__.PubSub = HS;
  var k = "1.3", U = E.__private__.getPdfVersion = function() {
    return k;
  };
  E.__private__.setPdfVersion = function(O) {
    k = O;
  };
  var V = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  E.__private__.getPageFormats = function() {
    return V;
  };
  var q = E.__private__.getPageFormat = function(O) {
    return V[O];
  };
  i = i || "a4";
  var Y = { COMPAT: "compat", ADVANCED: "advanced" }, re = Y.COMPAT;
  function Z() {
    this.saveGraphicsState(), We(new tr(gr, 0, 0, -gr, 0, Lo() * gr).toString() + " cm"), this.setFontSize(this.getFontSize() / gr), m = "n", re = Y.ADVANCED;
  }
  function K() {
    this.restoreGraphicsState(), m = "S", re = Y.COMPAT;
  }
  var ie = E.__private__.combineFontStyleAndFontWeight = function(O, ae) {
    if (O == "bold" && ae == "normal" || O == "bold" && ae == 400 || O == "normal" && ae == "italic" || O == "bold" && ae == "italic") throw new Error("Invalid Combination of fontweight and fontstyle");
    return ae && (O = ae == 400 || ae === "normal" ? O === "italic" ? "italic" : "normal" : ae != 700 && ae !== "bold" || O !== "normal" ? (ae == 700 ? "bold" : ae) + "" + O : "bold"), O;
  };
  E.advancedAPI = function(O) {
    var ae = re === Y.COMPAT;
    return ae && Z.call(this), typeof O != "function" || (O(this), ae && K.call(this)), this;
  }, E.compatAPI = function(O) {
    var ae = re === Y.ADVANCED;
    return ae && K.call(this), typeof O != "function" || (O(this), ae && Z.call(this)), this;
  }, E.isAdvancedAPI = function() {
    return re === Y.ADVANCED;
  };
  var be, he = function(O) {
    if (re !== Y.ADVANCED) throw new Error(O + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, Be = E.roundToPrecision = E.__private__.roundToPrecision = function(O, ae) {
    var Ue = e || ae;
    if (isNaN(O) || isNaN(Ue)) throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return O.toFixed(Ue).replace(/0+$/, "");
  };
  be = E.hpf = E.__private__.hpf = typeof d == "number" ? function(O) {
    if (isNaN(O)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return Be(O, d);
  } : d === "smart" ? function(O) {
    if (isNaN(O)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return Be(O, O > -1 && O < 1 ? 16 : 5);
  } : function(O) {
    if (isNaN(O)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return Be(O, 16);
  };
  var ke = E.f2 = E.__private__.f2 = function(O) {
    if (isNaN(O)) throw new Error("Invalid argument passed to jsPDF.f2");
    return Be(O, 2);
  }, pe = E.__private__.f3 = function(O) {
    if (isNaN(O)) throw new Error("Invalid argument passed to jsPDF.f3");
    return Be(O, 3);
  }, me = E.scale = E.__private__.scale = function(O) {
    if (isNaN(O)) throw new Error("Invalid argument passed to jsPDF.scale");
    return re === Y.COMPAT ? O * gr : re === Y.ADVANCED ? O : void 0;
  }, je = function(O) {
    return re === Y.COMPAT ? Lo() - O : re === Y.ADVANCED ? O : void 0;
  }, Pe = function(O) {
    return me(je(O));
  };
  E.__private__.setPrecision = E.setPrecision = function(O) {
    typeof parseInt(O, 10) == "number" && (e = parseInt(O, 10));
  };
  var St, Mt = "00000000000000000000000000000000", Lt = E.__private__.getFileId = function() {
    return Mt;
  }, xt = E.__private__.setFileId = function(O) {
    return Mt = O !== void 0 && /^[a-fA-F0-9]{32}$/.test(O) ? O.toUpperCase() : Mt.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), b !== null && (hi = new Ld(b.userPermissions, b.userPassword, b.ownerPassword, Mt)), Mt;
  };
  E.setFileId = function(O) {
    return xt(O), this;
  }, E.getFileId = function() {
    return Lt();
  };
  var zt = E.__private__.convertDateToPDFDate = function(O) {
    var ae = O.getTimezoneOffset(), Ue = ae < 0 ? "+" : "-", tt = Math.floor(Math.abs(ae / 60)), mt = Math.abs(ae % 60), jt = [Ue, $e(tt), "'", $e(mt), "'"].join("");
    return ["D:", O.getFullYear(), $e(O.getMonth() + 1), $e(O.getDate()), $e(O.getHours()), $e(O.getMinutes()), $e(O.getSeconds()), jt].join("");
  }, Dt = E.__private__.convertPDFDateToDate = function(O) {
    var ae = parseInt(O.substr(2, 4), 10), Ue = parseInt(O.substr(6, 2), 10) - 1, tt = parseInt(O.substr(8, 2), 10), mt = parseInt(O.substr(10, 2), 10), jt = parseInt(O.substr(12, 2), 10), Jt = parseInt(O.substr(14, 2), 10);
    return new Date(ae, Ue, tt, mt, jt, Jt, 0);
  }, hr = E.__private__.setCreationDate = function(O) {
    var ae;
    if (O === void 0 && (O = /* @__PURE__ */ new Date()), O instanceof Date) ae = zt(O);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(O)) throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      ae = O;
    }
    return St = ae;
  }, ce = E.__private__.getCreationDate = function(O) {
    var ae = St;
    return O === "jsDate" && (ae = Dt(St)), ae;
  };
  E.setCreationDate = function(O) {
    return hr(O), this;
  }, E.getCreationDate = function(O) {
    return ce(O);
  };
  var Oe, $e = E.__private__.padd2 = function(O) {
    return ("0" + parseInt(O)).slice(-2);
  }, et = E.__private__.padd2Hex = function(O) {
    return ("00" + (O = O.toString())).substr(O.length);
  }, ot = 0, ht = [], It = [], yt = 0, ar = [], Kt = [], vr = !1, sr = It, Ur = function() {
    ot = 0, yt = 0, It = [], ht = [], ar = [], oi = zr(), Mn = zr();
  };
  E.__private__.setCustomOutputDestination = function(O) {
    vr = !0, sr = O;
  };
  var Nt = function(O) {
    vr || (sr = O);
  };
  E.__private__.resetCustomOutputDestination = function() {
    vr = !1, sr = It;
  };
  var We = E.__private__.out = function(O) {
    return O = O.toString(), yt += O.length + 1, sr.push(O), sr;
  }, Dr = E.__private__.write = function(O) {
    return We(arguments.length === 1 ? O.toString() : Array.prototype.join.call(arguments, " "));
  }, Tr = E.__private__.getArrayBuffer = function(O) {
    for (var ae = O.length, Ue = new ArrayBuffer(ae), tt = new Uint8Array(Ue); ae--; ) tt[ae] = O.charCodeAt(ae);
    return Ue;
  }, Yt = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  E.__private__.getStandardFonts = function() {
    return Yt;
  };
  var pr = r.fontSize || 16;
  E.__private__.setFontSize = E.setFontSize = function(O) {
    return pr = re === Y.ADVANCED ? O / gr : O, this;
  };
  var mr, _r = E.__private__.getFontSize = E.getFontSize = function() {
    return re === Y.COMPAT ? pr : pr * gr;
  }, Lr = r.R2L || !1;
  E.__private__.setR2L = E.setR2L = function(O) {
    return Lr = O, this;
  }, E.__private__.getR2L = E.getR2L = function() {
    return Lr;
  };
  var qr, Kr = E.__private__.setZoomMode = function(O) {
    var ae = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(O)) mr = O;
    else if (isNaN(O)) {
      if (ae.indexOf(O) === -1) throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + O + '" is not recognized.');
      mr = O;
    } else mr = parseInt(O, 10);
  };
  E.__private__.getZoomMode = function() {
    return mr;
  };
  var en, nn = E.__private__.setPageMode = function(O) {
    if ([void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(O) == -1) throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + O + '" is not recognized.');
    qr = O;
  };
  E.__private__.getPageMode = function() {
    return qr;
  };
  var vn = E.__private__.setLayoutMode = function(O) {
    if ([void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(O) == -1) throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + O + '" is not recognized.');
    en = O;
  };
  E.__private__.getLayoutMode = function() {
    return en;
  }, E.__private__.setDisplayMode = E.setDisplayMode = function(O, ae, Ue) {
    return Kr(O), vn(ae), nn(Ue), this;
  };
  var Hr = { title: "", subject: "", author: "", keywords: "", creator: "" };
  E.__private__.getDocumentProperty = function(O) {
    if (Object.keys(Hr).indexOf(O) === -1) throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return Hr[O];
  }, E.__private__.getDocumentProperties = function() {
    return Hr;
  }, E.__private__.setDocumentProperties = E.setProperties = E.setDocumentProperties = function(O) {
    for (var ae in Hr) Hr.hasOwnProperty(ae) && O[ae] && (Hr[ae] = O[ae]);
    return this;
  }, E.__private__.setDocumentProperty = function(O, ae) {
    if (Object.keys(Hr).indexOf(O) === -1) throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return Hr[O] = ae;
  };
  var fn, gr, nt, oe, fe, ye = {}, Le = {}, Ye = [], Qe = {}, gt = {}, Ke = {}, Bt = {}, Pt = null, st = 0, ft = [], Ge = new HS(E), ur = r.hotfixes || [], Sr = {}, lr = {}, Er = [], tr = function O(ae, Ue, tt, mt, jt, Jt) {
    if (!(this instanceof O)) return new O(ae, Ue, tt, mt, jt, Jt);
    isNaN(ae) && (ae = 1), isNaN(Ue) && (Ue = 0), isNaN(tt) && (tt = 0), isNaN(mt) && (mt = 1), isNaN(jt) && (jt = 0), isNaN(Jt) && (Jt = 0), this._matrix = [ae, Ue, tt, mt, jt, Jt];
  };
  Object.defineProperty(tr.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(O) {
    this._matrix[0] = O;
  } }), Object.defineProperty(tr.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(O) {
    this._matrix[1] = O;
  } }), Object.defineProperty(tr.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(O) {
    this._matrix[2] = O;
  } }), Object.defineProperty(tr.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(O) {
    this._matrix[3] = O;
  } }), Object.defineProperty(tr.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(O) {
    this._matrix[4] = O;
  } }), Object.defineProperty(tr.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(O) {
    this._matrix[5] = O;
  } }), Object.defineProperty(tr.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(O) {
    this._matrix[0] = O;
  } }), Object.defineProperty(tr.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(O) {
    this._matrix[1] = O;
  } }), Object.defineProperty(tr.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(O) {
    this._matrix[2] = O;
  } }), Object.defineProperty(tr.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(O) {
    this._matrix[3] = O;
  } }), Object.defineProperty(tr.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(O) {
    this._matrix[4] = O;
  } }), Object.defineProperty(tr.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(O) {
    this._matrix[5] = O;
  } }), Object.defineProperty(tr.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(tr.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(tr.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(tr.prototype, "isIdentity", { get: function() {
    return this.sx === 1 && this.shy === 0 && this.shx === 0 && this.sy === 1 && this.tx === 0 && this.ty === 0;
  } }), tr.prototype.join = function(O) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(be).join(O);
  }, tr.prototype.multiply = function(O) {
    var ae = O.sx * this.sx + O.shy * this.shx, Ue = O.sx * this.shy + O.shy * this.sy, tt = O.shx * this.sx + O.sy * this.shx, mt = O.shx * this.shy + O.sy * this.sy, jt = O.tx * this.sx + O.ty * this.shx + this.tx, Jt = O.tx * this.shy + O.ty * this.sy + this.ty;
    return new tr(ae, Ue, tt, mt, jt, Jt);
  }, tr.prototype.decompose = function() {
    var O = this.sx, ae = this.shy, Ue = this.shx, tt = this.sy, mt = this.tx, jt = this.ty, Jt = Math.sqrt(O * O + ae * ae), wr = (O /= Jt) * Ue + (ae /= Jt) * tt;
    Ue -= O * wr, tt -= ae * wr;
    var Fr = Math.sqrt(Ue * Ue + tt * tt);
    return wr /= Fr, O * (tt /= Fr) < ae * (Ue /= Fr) && (O = -O, ae = -ae, wr = -wr, Jt = -Jt), { scale: new tr(Jt, 0, 0, Fr, 0, 0), translate: new tr(1, 0, 0, 1, mt, jt), rotate: new tr(O, ae, -ae, O, 0, 0), skew: new tr(1, 0, wr, 1, 0, 0) };
  }, tr.prototype.toString = function(O) {
    return this.join(" ");
  }, tr.prototype.inversed = function() {
    var O = this.sx, ae = this.shy, Ue = this.shx, tt = this.sy, mt = this.tx, jt = this.ty, Jt = 1 / (O * tt - ae * Ue), wr = tt * Jt, Fr = -ae * Jt, sn = -Ue * Jt, Qr = O * Jt;
    return new tr(wr, Fr, sn, Qr, -wr * mt - sn * jt, -Fr * mt - Qr * jt);
  }, tr.prototype.applyToPoint = function(O) {
    var ae = O.x * this.sx + O.y * this.shx + this.tx, Ue = O.x * this.shy + O.y * this.sy + this.ty;
    return new Ca(ae, Ue);
  }, tr.prototype.applyToRectangle = function(O) {
    var ae = this.applyToPoint(O), Ue = this.applyToPoint(new Ca(O.x + O.w, O.y + O.h));
    return new Hl(ae.x, ae.y, Ue.x - ae.x, Ue.y - ae.y);
  }, tr.prototype.clone = function() {
    var O = this.sx, ae = this.shy, Ue = this.shx, tt = this.sy, mt = this.tx, jt = this.ty;
    return new tr(O, ae, Ue, tt, mt, jt);
  }, E.Matrix = tr;
  var xn = E.matrixMult = function(O, ae) {
    return ae.multiply(O);
  }, dn = new tr(1, 0, 0, 1, 0, 0);
  E.unitMatrix = E.identityMatrix = dn;
  var Jr = function(O, ae) {
    if (!gt[O]) {
      var Ue = (ae instanceof Ef ? "Sh" : "P") + (Object.keys(Qe).length + 1).toString(10);
      ae.id = Ue, gt[O] = Ue, Qe[Ue] = ae, Ge.publish("addPattern", ae);
    }
  };
  E.ShadingPattern = Ef, E.TilingPattern = qd, E.addShadingPattern = function(O, ae) {
    return he("addShadingPattern()"), Jr(O, ae), this;
  }, E.beginTilingPattern = function(O) {
    he("beginTilingPattern()"), is(O.boundingBox[0], O.boundingBox[1], O.boundingBox[2] - O.boundingBox[0], O.boundingBox[3] - O.boundingBox[1], O.matrix);
  }, E.endTilingPattern = function(O, ae) {
    he("endTilingPattern()"), ae.stream = Kt[Oe].join(`
`), Jr(O, ae), Ge.publish("endTilingPattern", ae), Er.pop().restore();
  };
  var Cr = E.__private__.newObject = function() {
    var O = zr();
    return Dn(O, !0), O;
  }, zr = E.__private__.newObjectDeferred = function() {
    return ot++, ht[ot] = function() {
      return yt;
    }, ot;
  }, Dn = function(O, ae) {
    return ae = typeof ae == "boolean" && ae, ht[O] = yt, ae && We(O + " 0 obj"), O;
  }, er = E.__private__.newAdditionalObject = function() {
    var O = { objId: zr(), content: "" };
    return ar.push(O), O;
  }, oi = zr(), Mn = zr(), rs = E.__private__.decodeColorString = function(O) {
    var ae = O.split(" ");
    if (ae.length !== 2 || ae[1] !== "g" && ae[1] !== "G") ae.length === 5 && (ae[4] === "k" || ae[4] === "K") && (ae = [(1 - ae[0]) * (1 - ae[3]), (1 - ae[1]) * (1 - ae[3]), (1 - ae[2]) * (1 - ae[3]), "r"]);
    else {
      var Ue = parseFloat(ae[0]);
      ae = [Ue, Ue, Ue, "r"];
    }
    for (var tt = "#", mt = 0; mt < 3; mt++) tt += ("0" + Math.floor(255 * parseFloat(ae[mt])).toString(16)).slice(-2);
    return tt;
  }, _s = E.__private__.encodeColorString = function(O) {
    var ae;
    typeof O == "string" && (O = { ch1: O });
    var Ue = O.ch1, tt = O.ch2, mt = O.ch3, jt = O.ch4, Jt = O.pdfColorType === "draw" ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if (typeof Ue == "string" && Ue.charAt(0) !== "#") {
      var wr = new UM(Ue);
      if (wr.ok) Ue = wr.toHex();
      else if (!/^\d*\.?\d*$/.test(Ue)) throw new Error('Invalid color "' + Ue + '" passed to jsPDF.encodeColorString.');
    }
    if (typeof Ue == "string" && /^#[0-9A-Fa-f]{3}$/.test(Ue) && (Ue = "#" + Ue[1] + Ue[1] + Ue[2] + Ue[2] + Ue[3] + Ue[3]), typeof Ue == "string" && /^#[0-9A-Fa-f]{6}$/.test(Ue)) {
      var Fr = parseInt(Ue.substr(1), 16);
      Ue = Fr >> 16 & 255, tt = Fr >> 8 & 255, mt = 255 & Fr;
    }
    if (tt === void 0 || jt === void 0 && Ue === tt && tt === mt)
      if (typeof Ue == "string") ae = Ue + " " + Jt[0];
      else switch (O.precision) {
        case 2:
          ae = ke(Ue / 255) + " " + Jt[0];
          break;
        case 3:
        default:
          ae = pe(Ue / 255) + " " + Jt[0];
      }
    else if (jt === void 0 || ci(jt) === "object") {
      if (jt && !isNaN(jt.a) && jt.a === 0) return ae = ["1.", "1.", "1.", Jt[1]].join(" ");
      if (typeof Ue == "string") ae = [Ue, tt, mt, Jt[1]].join(" ");
      else switch (O.precision) {
        case 2:
          ae = [ke(Ue / 255), ke(tt / 255), ke(mt / 255), Jt[1]].join(" ");
          break;
        default:
        case 3:
          ae = [pe(Ue / 255), pe(tt / 255), pe(mt / 255), Jt[1]].join(" ");
      }
    } else if (typeof Ue == "string") ae = [Ue, tt, mt, jt, Jt[2]].join(" ");
    else switch (O.precision) {
      case 2:
        ae = [ke(Ue), ke(tt), ke(mt), ke(jt), Jt[2]].join(" ");
        break;
      case 3:
      default:
        ae = [pe(Ue), pe(tt), pe(mt), pe(jt), Jt[2]].join(" ");
    }
    return ae;
  }, rr = E.__private__.getFilters = function() {
    return l;
  }, Vr = E.__private__.putStream = function(O) {
    var ae = (O = O || {}).data || "", Ue = O.filters || rr(), tt = O.alreadyAppliedFilters || [], mt = O.addLength1 || !1, jt = ae.length, Jt = O.objectId, wr = function(Vi) {
      return Vi;
    };
    if (b !== null && Jt === void 0) throw new Error("ObjectId must be passed to putStream for file encryption");
    b !== null && (wr = hi.encryptor(Jt, 0));
    var Fr = {};
    Ue === !0 && (Ue = ["FlateEncode"]);
    var sn = O.additionalKeyValues || [], Qr = (Fr = rn.API.processDataByFilters !== void 0 ? rn.API.processDataByFilters(ae, Ue) : { data: ae, reverseChain: [] }).reverseChain + (Array.isArray(tt) ? tt.join(" ") : tt.toString());
    if (Fr.data.length !== 0 && (sn.push({ key: "Length", value: Fr.data.length }), mt === !0 && sn.push({ key: "Length1", value: jt })), Qr.length != 0) if (Qr.split("/").length - 1 == 1) sn.push({ key: "Filter", value: Qr });
    else {
      sn.push({ key: "Filter", value: "[" + Qr + "]" });
      for (var ln = 0; ln < sn.length; ln += 1) if (sn[ln].key === "DecodeParms") {
        for (var vi = [], xi = 0; xi < Fr.reverseChain.split("/").length - 1; xi += 1) vi.push("null");
        vi.push(sn[ln].value), sn[ln].value = "[" + vi.join(" ") + "]";
      }
    }
    We("<<");
    for (var fi = 0; fi < sn.length; fi++) We("/" + sn[fi].key + " " + sn[fi].value);
    We(">>"), Fr.data.length !== 0 && (We("stream"), We(wr(Fr.data)), We("endstream"));
  }, Gr = E.__private__.putPage = function(O) {
    var ae = O.number, Ue = O.data, tt = O.objId, mt = O.contentsObjId;
    Dn(tt, !0), We("<</Type /Page"), We("/Parent " + O.rootDictionaryObjId + " 0 R"), We("/Resources " + O.resourceDictionaryObjId + " 0 R"), We("/MediaBox [" + parseFloat(be(O.mediaBox.bottomLeftX)) + " " + parseFloat(be(O.mediaBox.bottomLeftY)) + " " + be(O.mediaBox.topRightX) + " " + be(O.mediaBox.topRightY) + "]"), O.cropBox !== null && We("/CropBox [" + be(O.cropBox.bottomLeftX) + " " + be(O.cropBox.bottomLeftY) + " " + be(O.cropBox.topRightX) + " " + be(O.cropBox.topRightY) + "]"), O.bleedBox !== null && We("/BleedBox [" + be(O.bleedBox.bottomLeftX) + " " + be(O.bleedBox.bottomLeftY) + " " + be(O.bleedBox.topRightX) + " " + be(O.bleedBox.topRightY) + "]"), O.trimBox !== null && We("/TrimBox [" + be(O.trimBox.bottomLeftX) + " " + be(O.trimBox.bottomLeftY) + " " + be(O.trimBox.topRightX) + " " + be(O.trimBox.topRightY) + "]"), O.artBox !== null && We("/ArtBox [" + be(O.artBox.bottomLeftX) + " " + be(O.artBox.bottomLeftY) + " " + be(O.artBox.topRightX) + " " + be(O.artBox.topRightY) + "]"), typeof O.userUnit == "number" && O.userUnit !== 1 && We("/UserUnit " + O.userUnit), Ge.publish("putPage", { objId: tt, pageContext: ft[ae], pageNumber: ae, page: Ue }), We("/Contents " + mt + " 0 R"), We(">>"), We("endobj");
    var jt = Ue.join(`
`);
    return re === Y.ADVANCED && (jt += `
Q`), Dn(mt, !0), Vr({ data: jt, filters: rr(), objectId: mt }), We("endobj"), tt;
  }, Hi = E.__private__.putPages = function() {
    var O, ae, Ue = [];
    for (O = 1; O <= st; O++) ft[O].objId = zr(), ft[O].contentsObjId = zr();
    for (O = 1; O <= st; O++) Ue.push(Gr({ number: O, data: Kt[O], objId: ft[O].objId, contentsObjId: ft[O].contentsObjId, mediaBox: ft[O].mediaBox, cropBox: ft[O].cropBox, bleedBox: ft[O].bleedBox, trimBox: ft[O].trimBox, artBox: ft[O].artBox, userUnit: ft[O].userUnit, rootDictionaryObjId: oi, resourceDictionaryObjId: Mn }));
    Dn(oi, !0), We("<</Type /Pages");
    var tt = "/Kids [";
    for (ae = 0; ae < st; ae++) tt += Ue[ae] + " 0 R ";
    We(tt + "]"), We("/Count " + st), We(">>"), We("endobj"), Ge.publish("postPutPages");
  }, Ga = function(O) {
    Ge.publish("putFont", { font: O, out: We, newObject: Cr, putStream: Vr }), O.isAlreadyPutted !== !0 && (O.objectNumber = Cr(), We("<<"), We("/Type /Font"), We("/BaseFont /" + Od(O.postScriptName)), We("/Subtype /Type1"), typeof O.encoding == "string" && We("/Encoding /" + O.encoding), We("/FirstChar 32"), We("/LastChar 255"), We(">>"), We("endobj"));
  }, Vs = function() {
    for (var O in ye) ye.hasOwnProperty(O) && (A === !1 || A === !0 && M.hasOwnProperty(O)) && Ga(ye[O]);
  }, Xr = function(O) {
    O.objectNumber = Cr();
    var ae = [];
    ae.push({ key: "Type", value: "/XObject" }), ae.push({ key: "Subtype", value: "/Form" }), ae.push({ key: "BBox", value: "[" + [be(O.x), be(O.y), be(O.x + O.width), be(O.y + O.height)].join(" ") + "]" }), ae.push({ key: "Matrix", value: "[" + O.matrix.toString() + "]" });
    var Ue = O.pages[1].join(`
`);
    Vr({ data: Ue, additionalKeyValues: ae, objectId: O.objectNumber }), We("endobj");
  }, io = function() {
    for (var O in Sr) Sr.hasOwnProperty(O) && Xr(Sr[O]);
  }, va = function(O, ae) {
    var Ue, tt = [], mt = 1 / (ae - 1);
    for (Ue = 0; Ue < 1; Ue += mt) tt.push(Ue);
    if (tt.push(1), O[0].offset != 0) {
      var jt = { offset: 0, color: O[0].color };
      O.unshift(jt);
    }
    if (O[O.length - 1].offset != 1) {
      var Jt = { offset: 1, color: O[O.length - 1].color };
      O.push(Jt);
    }
    for (var wr = "", Fr = 0, sn = 0; sn < tt.length; sn++) {
      for (Ue = tt[sn]; Ue > O[Fr + 1].offset; ) Fr++;
      var Qr = O[Fr].offset, ln = (Ue - Qr) / (O[Fr + 1].offset - Qr), vi = O[Fr].color, xi = O[Fr + 1].color;
      wr += et(Math.round((1 - ln) * vi[0] + ln * xi[0]).toString(16)) + et(Math.round((1 - ln) * vi[1] + ln * xi[1]).toString(16)) + et(Math.round((1 - ln) * vi[2] + ln * xi[2]).toString(16));
    }
    return wr.trim();
  }, bi = function(O, ae) {
    ae || (ae = 21);
    var Ue = Cr(), tt = va(O.colors, ae), mt = [];
    mt.push({ key: "FunctionType", value: "0" }), mt.push({ key: "Domain", value: "[0.0 1.0]" }), mt.push({ key: "Size", value: "[" + ae + "]" }), mt.push({ key: "BitsPerSample", value: "8" }), mt.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), mt.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), Vr({ data: tt, additionalKeyValues: mt, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: Ue }), We("endobj"), O.objectNumber = Cr(), We("<< /ShadingType " + O.type), We("/ColorSpace /DeviceRGB");
    var jt = "/Coords [" + be(parseFloat(O.coords[0])) + " " + be(parseFloat(O.coords[1])) + " ";
    O.type === 2 ? jt += be(parseFloat(O.coords[2])) + " " + be(parseFloat(O.coords[3])) : jt += be(parseFloat(O.coords[2])) + " " + be(parseFloat(O.coords[3])) + " " + be(parseFloat(O.coords[4])) + " " + be(parseFloat(O.coords[5])), We(jt += "]"), O.matrix && We("/Matrix [" + O.matrix.toString() + "]"), We("/Function " + Ue + " 0 R"), We("/Extend [true true]"), We(">>"), We("endobj");
  }, Vl = function(O, ae) {
    var Ue = zr(), tt = Cr();
    ae.push({ resourcesOid: Ue, objectOid: tt }), O.objectNumber = tt;
    var mt = [];
    mt.push({ key: "Type", value: "/Pattern" }), mt.push({ key: "PatternType", value: "1" }), mt.push({ key: "PaintType", value: "1" }), mt.push({ key: "TilingType", value: "1" }), mt.push({ key: "BBox", value: "[" + O.boundingBox.map(be).join(" ") + "]" }), mt.push({ key: "XStep", value: be(O.xStep) }), mt.push({ key: "YStep", value: be(O.yStep) }), mt.push({ key: "Resources", value: Ue + " 0 R" }), O.matrix && mt.push({ key: "Matrix", value: "[" + O.matrix.toString() + "]" }), Vr({ data: O.stream, additionalKeyValues: mt, objectId: O.objectNumber }), We("endobj");
  }, xa = function(O) {
    var ae;
    for (ae in Qe) Qe.hasOwnProperty(ae) && (Qe[ae] instanceof Ef ? bi(Qe[ae]) : Qe[ae] instanceof qd && Vl(Qe[ae], O));
  }, Po = function(O) {
    for (var ae in O.objectNumber = Cr(), We("<<"), O) switch (ae) {
      case "opacity":
        We("/ca " + ke(O[ae]));
        break;
      case "stroke-opacity":
        We("/CA " + ke(O[ae]));
    }
    We(">>"), We("endobj");
  }, $l = function() {
    var O;
    for (O in Ke) Ke.hasOwnProperty(O) && Po(Ke[O]);
  }, ys = function() {
    for (var O in We("/XObject <<"), Sr) Sr.hasOwnProperty(O) && Sr[O].objectNumber >= 0 && We("/" + O + " " + Sr[O].objectNumber + " 0 R");
    Ge.publish("putXobjectDict"), We(">>");
  }, ti = function() {
    hi.oid = Cr(), We("<<"), We("/Filter /Standard"), We("/V " + hi.v), We("/R " + hi.r), We("/U <" + hi.toHexString(hi.U) + ">"), We("/O <" + hi.toHexString(hi.O) + ">"), We("/P " + hi.P), We(">>"), We("endobj");
  }, vu = function() {
    for (var O in We("/Font <<"), ye) ye.hasOwnProperty(O) && (A === !1 || A === !0 && M.hasOwnProperty(O)) && We("/" + O + " " + ye[O].objectNumber + " 0 R");
    We(">>");
  }, ql = function() {
    if (Object.keys(Qe).length > 0) {
      for (var O in We("/Shading <<"), Qe) Qe.hasOwnProperty(O) && Qe[O] instanceof Ef && Qe[O].objectNumber >= 0 && We("/" + O + " " + Qe[O].objectNumber + " 0 R");
      Ge.publish("putShadingPatternDict"), We(">>");
    }
  }, Ha = function(O) {
    if (Object.keys(Qe).length > 0) {
      for (var ae in We("/Pattern <<"), Qe) Qe.hasOwnProperty(ae) && Qe[ae] instanceof E.TilingPattern && Qe[ae].objectNumber >= 0 && Qe[ae].objectNumber < O && We("/" + ae + " " + Qe[ae].objectNumber + " 0 R");
      Ge.publish("putTilingPatternDict"), We(">>");
    }
  }, Wa = function() {
    if (Object.keys(Ke).length > 0) {
      var O;
      for (O in We("/ExtGState <<"), Ke) Ke.hasOwnProperty(O) && Ke[O].objectNumber >= 0 && We("/" + O + " " + Ke[O].objectNumber + " 0 R");
      Ge.publish("putGStateDict"), We(">>");
    }
  }, Hn = function(O) {
    Dn(O.resourcesOid, !0), We("<<"), We("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), vu(), ql(), Ha(O.objectOid), Wa(), ys(), We(">>"), We("endobj");
  }, xu = function() {
    var O = [];
    Vs(), $l(), io(), xa(O), Ge.publish("putResources"), O.forEach(Hn), Hn({ resourcesOid: Mn, objectOid: Number.MAX_SAFE_INTEGER }), Ge.publish("postPutResources");
  }, wu = function() {
    Ge.publish("putAdditionalObjects");
    for (var O = 0; O < ar.length; O++) {
      var ae = ar[O];
      Dn(ae.objId, !0), We(ae.content), We("endobj");
    }
    Ge.publish("postPutAdditionalObjects");
  }, Au = function(O) {
    Le[O.fontName] = Le[O.fontName] || {}, Le[O.fontName][O.fontStyle] = O.id;
  }, wa = function(O, ae, Ue, tt, mt) {
    var jt = { id: "F" + (Object.keys(ye).length + 1).toString(10), postScriptName: O, fontName: ae, fontStyle: Ue, encoding: tt, isStandardFont: mt || !1, metadata: {} };
    return Ge.publish("addFont", { font: jt, instance: this }), ye[jt.id] = jt, Au(jt), jt.id;
  }, ih = function(O) {
    for (var ae = 0, Ue = Yt.length; ae < Ue; ae++) {
      var tt = wa.call(this, O[ae][0], O[ae][1], O[ae][2], Yt[ae][3], !0);
      A === !1 && (M[tt] = !0);
      var mt = O[ae][0].split("-");
      Au({ id: tt, fontName: mt[0], fontStyle: mt[1] || "" });
    }
    Ge.publish("addFonts", { fonts: ye, dictionary: Le });
  }, Ro = function(O) {
    return O.foo = function() {
      try {
        return O.apply(this, arguments);
      } catch (tt) {
        var ae = tt.stack || "";
        ~ae.indexOf(" at ") && (ae = ae.split(" at ")[1]);
        var Ue = "Error in function " + ae.split(`
`)[0].split("<")[0] + ": " + tt.message;
        if (!on.console) throw new Error(Ue);
        on.console.error(Ue, tt), on.alert && alert(Ue);
      }
    }, O.foo.bar = O, O.foo;
  }, Aa = function(O, ae) {
    var Ue, tt, mt, jt, Jt, wr, Fr, sn, Qr;
    if (mt = (ae = ae || {}).sourceEncoding || "Unicode", Jt = ae.outputEncoding, (ae.autoencode || Jt) && ye[fn].metadata && ye[fn].metadata[mt] && ye[fn].metadata[mt].encoding && (jt = ye[fn].metadata[mt].encoding, !Jt && ye[fn].encoding && (Jt = ye[fn].encoding), !Jt && jt.codePages && (Jt = jt.codePages[0]), typeof Jt == "string" && (Jt = jt[Jt]), Jt)) {
      for (Fr = !1, wr = [], Ue = 0, tt = O.length; Ue < tt; Ue++) (sn = Jt[O.charCodeAt(Ue)]) ? wr.push(String.fromCharCode(sn)) : wr.push(O[Ue]), wr[Ue].charCodeAt(0) >> 8 && (Fr = !0);
      O = wr.join("");
    }
    for (Ue = O.length; Fr === void 0 && Ue !== 0; ) O.charCodeAt(Ue - 1) >> 8 && (Fr = !0), Ue--;
    if (!Fr) return O;
    for (wr = ae.noBOM ? [] : [254, 255], Ue = 0, tt = O.length; Ue < tt; Ue++) {
      if ((Qr = (sn = O.charCodeAt(Ue)) >> 8) >> 8) throw new Error("Character at position " + Ue + " of string '" + O + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      wr.push(Qr), wr.push(sn - (Qr << 8));
    }
    return String.fromCharCode.apply(void 0, wr);
  }, so = E.__private__.pdfEscape = E.pdfEscape = function(O, ae) {
    return Aa(O, ae).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, Dc = E.__private__.beginPage = function(O) {
    Kt[++st] = [], ft[st] = { objId: 0, contentsObjId: 0, userUnit: Number(o), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(O[0]), topRightY: Number(O[1]) } }, Fc(st), Nt(Kt[Oe]);
  }, Xa = function(O, ae) {
    var Ue, tt, mt;
    switch (t = ae || t, typeof O == "string" && (Ue = q(O.toLowerCase()), Array.isArray(Ue) && (tt = Ue[0], mt = Ue[1])), Array.isArray(O) && (tt = O[0] * gr, mt = O[1] * gr), isNaN(tt) && (tt = i[0], mt = i[1]), (tt > 14400 || mt > 14400) && (Ii.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), tt = Math.min(14400, tt), mt = Math.min(14400, mt)), i = [tt, mt], t.substr(0, 1)) {
      case "l":
        mt > tt && (i = [mt, tt]);
        break;
      case "p":
        tt > mt && (i = [mt, tt]);
    }
    Dc(i), zc(Ta), We(Rs), Ea !== 0 && We(Ea + " J"), Iu !== 0 && We(Iu + " j"), Ge.publish("addPage", { pageNumber: st });
  }, Tu = function(O) {
    O > 0 && O <= st && (Kt.splice(O, 1), ft.splice(O, 1), st--, Oe > st && (Oe = st), this.setPage(Oe));
  }, Fc = function(O) {
    O > 0 && O <= st && (Oe = O);
  }, sh = E.__private__.getNumberOfPages = E.getNumberOfPages = function() {
    return Kt.length - 1;
  }, Gl = function(O, ae, Ue) {
    var tt, mt = void 0;
    return Ue = Ue || {}, O = O !== void 0 ? O : ye[fn].fontName, ae = ae !== void 0 ? ae : ye[fn].fontStyle, tt = O.toLowerCase(), Le[tt] !== void 0 && Le[tt][ae] !== void 0 ? mt = Le[tt][ae] : Le[O] !== void 0 && Le[O][ae] !== void 0 ? mt = Le[O][ae] : Ue.disableWarning === !1 && Ii.warn("Unable to look up font label for font '" + O + "', '" + ae + "'. Refer to getFontList() for available fonts."), mt || Ue.noFallback || (mt = Le.times[ae]) == null && (mt = Le.times.normal), mt;
  }, Uc = E.__private__.putInfo = function() {
    var O = Cr(), ae = function(tt) {
      return tt;
    };
    for (var Ue in b !== null && (ae = hi.encryptor(O, 0)), We("<<"), We("/Producer (" + so(ae("jsPDF " + rn.version)) + ")"), Hr) Hr.hasOwnProperty(Ue) && Hr[Ue] && We("/" + Ue.substr(0, 1).toUpperCase() + Ue.substr(1) + " (" + so(ae(Hr[Ue])) + ")");
    We("/CreationDate (" + so(ae(St)) + ")"), We(">>"), We("endobj");
  }, oo = E.__private__.putCatalog = function(O) {
    var ae = (O = O || {}).rootDictionaryObjId || oi;
    switch (Cr(), We("<<"), We("/Type /Catalog"), We("/Pages " + ae + " 0 R"), mr || (mr = "fullwidth"), mr) {
      case "fullwidth":
        We("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        We("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        We("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        We("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var Ue = "" + mr;
        Ue.substr(Ue.length - 1) === "%" && (mr = parseInt(mr) / 100), typeof mr == "number" && We("/OpenAction [3 0 R /XYZ null null " + ke(mr) + "]");
    }
    switch (en || (en = "continuous"), en) {
      case "continuous":
        We("/PageLayout /OneColumn");
        break;
      case "single":
        We("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        We("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        We("/PageLayout /TwoColumnRight");
    }
    qr && We("/PageMode /" + qr), Ge.publish("putCatalog"), We(">>"), We("endobj");
  }, un = E.__private__.putTrailer = function() {
    We("trailer"), We("<<"), We("/Size " + (ot + 1)), We("/Root " + ot + " 0 R"), We("/Info " + (ot - 1) + " 0 R"), b !== null && We("/Encrypt " + hi.oid + " 0 R"), We("/ID [ <" + Mt + "> <" + Mt + "> ]"), We(">>");
  }, sa = E.__private__.putHeader = function() {
    We("%PDF-" + k), We("%ºß¬à");
  }, oa = E.__private__.putXRef = function() {
    var O = "0000000000";
    We("xref"), We("0 " + (ot + 1)), We("0000000000 65535 f ");
    for (var ae = 1; ae <= ot; ae++) typeof ht[ae] == "function" ? We((O + ht[ae]()).slice(-10) + " 00000 n ") : ht[ae] !== void 0 ? We((O + ht[ae]).slice(-10) + " 00000 n ") : We("0000000000 00000 n ");
  }, $s = E.__private__.buildDocument = function() {
    Ur(), Nt(It), Ge.publish("buildDocument"), sa(), Hi(), wu(), xu(), b !== null && ti(), Uc(), oo();
    var O = yt;
    return oa(), un(), We("startxref"), We("" + O), We("%%EOF"), Nt(Kt[Oe]), It.join(`
`);
  }, bl = E.__private__.getBlob = function(O) {
    return new Blob([Tr(O)], { type: "application/pdf" });
  }, vl = E.output = E.__private__.output = Ro(function(O, ae) {
    switch (typeof (ae = ae || {}) == "string" ? ae = { filename: ae } : ae.filename = ae.filename || "generated.pdf", O) {
      case void 0:
        return $s();
      case "save":
        E.save(ae.filename);
        break;
      case "arraybuffer":
        return Tr($s());
      case "blob":
        return bl($s());
      case "bloburi":
      case "bloburl":
        if (on.URL !== void 0 && typeof on.URL.createObjectURL == "function") return on.URL && on.URL.createObjectURL(bl($s())) || void 0;
        Ii.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var Ue = "", tt = $s();
        try {
          Ue = Vv(tt);
        } catch {
          Ue = Vv(unescape(encodeURIComponent(tt)));
        }
        return "data:application/pdf;filename=" + ae.filename + ";base64," + Ue;
      case "pdfobjectnewwindow":
        if (Object.prototype.toString.call(on) === "[object Window]") {
          var mt = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", jt = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          ae.pdfObjectUrl && (mt = ae.pdfObjectUrl, jt = "");
          var Jt = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + mt + '"' + jt + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(ae) + ");<\/script></body></html>", wr = on.open();
          return wr !== null && wr.document.write(Jt), wr;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if (Object.prototype.toString.call(on) === "[object Window]") {
          var Fr = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (ae.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + ae.filename + '" width="500px" height="400px" /></body></html>', sn = on.open();
          if (sn !== null) {
            sn.document.write(Fr);
            var Qr = this;
            sn.document.documentElement.querySelector("#pdfViewer").onload = function() {
              sn.document.title = ae.filename, sn.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(Qr.output("bloburl"));
            };
          }
          return sn;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if (Object.prototype.toString.call(on) !== "[object Window]") throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var ln = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", ae) + '"></iframe></body></html>', vi = on.open();
        if (vi !== null && (vi.document.write(ln), vi.document.title = ae.filename), vi || typeof safari > "u") return vi;
        break;
      case "datauri":
      case "dataurl":
        return on.document.location.href = this.output("datauristring", ae);
      default:
        return null;
    }
  }), qs = function(O) {
    return Array.isArray(ur) === !0 && ur.indexOf(O) > -1;
  };
  switch (n) {
    case "pt":
      gr = 1;
      break;
    case "mm":
      gr = 72 / 25.4;
      break;
    case "cm":
      gr = 72 / 2.54;
      break;
    case "in":
      gr = 72;
      break;
    case "px":
      gr = qs("px_scaling") == 1 ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      gr = 12;
      break;
    case "ex":
      gr = 6;
      break;
    default:
      if (typeof n != "number") throw new Error("Invalid unit: " + n);
      gr = n;
  }
  var hi = null;
  hr(), xt();
  var hn = function(O) {
    return b !== null ? hi.encryptor(O, 0) : function(ae) {
      return ae;
    };
  }, xl = E.__private__.getPageInfo = E.getPageInfo = function(O) {
    if (isNaN(O) || O % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: ft[O].objId, pageNumber: O, pageContext: ft[O] };
  }, Zr = E.__private__.getPageInfoByObjId = function(O) {
    if (isNaN(O) || O % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var ae in ft) if (ft[ae].objId === O) break;
    return xl(ae);
  }, Su = E.__private__.getCurrentPageInfo = E.getCurrentPageInfo = function() {
    return { objId: ft[Oe].objId, pageNumber: Oe, pageContext: ft[Oe] };
  };
  E.addPage = function() {
    return Xa.apply(this, arguments), this;
  }, E.setPage = function() {
    return Fc.apply(this, arguments), Nt.call(this, Kt[Oe]), this;
  }, E.insertPage = function(O) {
    return this.addPage(), this.movePage(Oe, O), this;
  }, E.movePage = function(O, ae) {
    var Ue, tt;
    if (O > ae) {
      Ue = Kt[O], tt = ft[O];
      for (var mt = O; mt > ae; mt--) Kt[mt] = Kt[mt - 1], ft[mt] = ft[mt - 1];
      Kt[ae] = Ue, ft[ae] = tt, this.setPage(ae);
    } else if (O < ae) {
      Ue = Kt[O], tt = ft[O];
      for (var jt = O; jt < ae; jt++) Kt[jt] = Kt[jt + 1], ft[jt] = ft[jt + 1];
      Kt[ae] = Ue, ft[ae] = tt, this.setPage(ae);
    }
    return this;
  }, E.deletePage = function() {
    return Tu.apply(this, arguments), this;
  }, E.__private__.text = E.text = function(O, ae, Ue, tt, mt) {
    var jt, Jt, wr, Fr, sn, Qr, ln, vi, xi, fi = (tt = tt || {}).scope || this;
    if (typeof O == "number" && typeof ae == "number" && (typeof Ue == "string" || Array.isArray(Ue))) {
      var Vi = Ue;
      Ue = ae, ae = O, O = Vi;
    }
    if (arguments[3] instanceof tr ? (he("The transform parameter of text() with a Matrix value"), xi = mt) : (wr = arguments[4], Fr = arguments[5], ci(ln = arguments[3]) === "object" && ln !== null || (typeof wr == "string" && (Fr = wr, wr = null), typeof ln == "string" && (Fr = ln, ln = null), typeof ln == "number" && (wr = ln, ln = null), tt = { flags: ln, angle: wr, align: Fr })), isNaN(ae) || isNaN(Ue) || O == null) throw new Error("Invalid arguments passed to jsPDF.text");
    if (O.length === 0) return fi;
    var Xi = "", Gs = !1, Ao = typeof tt.lineHeightFactor == "number" ? tt.lineHeightFactor : Di, Hs = fi.internal.scaleFactor;
    function oh(Yn) {
      return Yn = Yn.split("	").join(Array(tt.TabLen || 9).join(" ")), so(Yn, ln);
    }
    function jc(Yn) {
      for (var Kn, Ti = Yn.concat(), li = [], No = Ti.length; No--; ) typeof (Kn = Ti.shift()) == "string" ? li.push(Kn) : Array.isArray(Yn) && (Kn.length === 1 || Kn[1] === void 0 && Kn[2] === void 0) ? li.push(Kn[0]) : li.push([Kn[0], Kn[1], Kn[2]]);
      return li;
    }
    function Pu(Yn, Kn) {
      var Ti;
      if (typeof Yn == "string") Ti = Kn(Yn)[0];
      else if (Array.isArray(Yn)) {
        for (var li, No, Il = Yn.concat(), Ba = [], tl = Il.length; tl--; ) typeof (li = Il.shift()) == "string" ? Ba.push(Kn(li)[0]) : Array.isArray(li) && typeof li[0] == "string" && (No = Kn(li[0], li[1], li[2]), Ba.push([No[0], No[1], No[2]]));
        Ti = Ba;
      }
      return Ti;
    }
    var Ka = !1, Xl = !0;
    if (typeof O == "string") Ka = !0;
    else if (Array.isArray(O)) {
      var Vc = O.concat();
      Jt = [];
      for (var Zl, Zi = Vc.length; Zi--; ) (typeof (Zl = Vc.shift()) != "string" || Array.isArray(Zl) && typeof Zl[0] != "string") && (Xl = !1);
      Ka = Xl;
    }
    if (Ka === !1) throw new Error('Type of text must be string or Array. "' + O + '" is not recognized.');
    typeof O == "string" && (O = O.match(/[\r?\n]/) ? O.split(/\r\n|\r|\n/g) : [O]);
    var Sl = pr / fi.internal.scaleFactor, Oo = Sl * (Ao - 1);
    switch (tt.baseline) {
      case "bottom":
        Ue -= Oo;
        break;
      case "top":
        Ue += Sl - Oo;
        break;
      case "hanging":
        Ue += Sl - 2 * Oo;
        break;
      case "middle":
        Ue += Sl / 2 - Oo;
    }
    if ((Qr = tt.maxWidth || 0) > 0 && (typeof O == "string" ? O = fi.splitTextToSize(O, Qr) : Object.prototype.toString.call(O) === "[object Array]" && (O = O.reduce(function(Yn, Kn) {
      return Yn.concat(fi.splitTextToSize(Kn, Qr));
    }, []))), jt = { text: O, x: ae, y: Ue, options: tt, mutex: { pdfEscape: so, activeFontKey: fn, fonts: ye, activeFontSize: pr } }, Ge.publish("preProcessText", jt), O = jt.text, wr = (tt = jt.options).angle, !(xi instanceof tr) && wr && typeof wr == "number") {
      wr *= Math.PI / 180, tt.rotationDirection === 0 && (wr = -wr), re === Y.ADVANCED && (wr = -wr);
      var Yl = Math.cos(wr), Kl = Math.sin(wr);
      xi = new tr(Yl, Kl, -Kl, Yl, 0, 0);
    } else wr && wr instanceof tr && (xi = wr);
    re !== Y.ADVANCED || xi || (xi = dn), (sn = tt.charSpace || Sa) !== void 0 && (Xi += be(me(sn)) + ` Tc
`, this.setCharSpace(this.getCharSpace() || 0)), (vi = tt.horizontalScale) !== void 0 && (Xi += be(100 * vi) + ` Tz
`), tt.lang;
    var Yi = -1, Jh = tt.renderingMode !== void 0 ? tt.renderingMode : tt.stroke, El = fi.internal.getCurrentPageInfo().pageContext;
    switch (Jh) {
      case 0:
      case !1:
      case "fill":
        Yi = 0;
        break;
      case 1:
      case !0:
      case "stroke":
        Yi = 1;
        break;
      case 2:
      case "fillThenStroke":
        Yi = 2;
        break;
      case 3:
      case "invisible":
        Yi = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        Yi = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        Yi = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        Yi = 6;
        break;
      case 7:
      case "addToPathForClipping":
        Yi = 7;
    }
    var ah = El.usedRenderingMode !== void 0 ? El.usedRenderingMode : -1;
    Yi !== -1 ? Xi += Yi + ` Tr
` : ah !== -1 && (Xi += `0 Tr
`), Yi !== -1 && (El.usedRenderingMode = Yi), Fr = tt.align || "left";
    var To, Jl = pr * Ao, Ru = fi.internal.pageSize.getWidth(), Bu = ye[fn];
    sn = tt.charSpace || Sa, Qr = tt.maxWidth || 0, ln = Object.assign({ autoencode: !0, noBOM: !0 }, tt.flags);
    var Ma = [], mn = function(Yn) {
      return fi.getStringUnitWidth(Yn, { font: Bu, charSpace: sn, fontSize: pr, doKerning: !1 }) * pr / Hs;
    };
    if (Object.prototype.toString.call(O) === "[object Array]") {
      var vs;
      Jt = jc(O), Fr !== "left" && (To = Jt.map(mn));
      var wi, Pa = 0;
      if (Fr === "right") {
        ae -= To[0], O = [], Zi = Jt.length;
        for (var la = 0; la < Zi; la++) la === 0 ? (wi = ao(ae), vs = xo(Ue)) : (wi = me(Pa - To[la]), vs = -Jl), O.push([Jt[la], wi, vs]), Pa = To[la];
      } else if (Fr === "center") {
        ae -= To[0] / 2, O = [], Zi = Jt.length;
        for (var ca = 0; ca < Zi; ca++) ca === 0 ? (wi = ao(ae), vs = xo(Ue)) : (wi = me((Pa - To[ca]) / 2), vs = -Jl), O.push([Jt[ca], wi, vs]), Pa = To[ca];
      } else if (Fr === "left") {
        O = [], Zi = Jt.length;
        for (var Ql = 0; Ql < Zi; Ql++) O.push(Jt[Ql]);
      } else if (Fr === "justify" && Bu.encoding === "Identity-H") {
        O = [], Zi = Jt.length, Qr = Qr !== 0 ? Qr : Ru;
        for (var ua = 0, Zn = 0; Zn < Zi; Zn++) if (vs = Zn === 0 ? xo(Ue) : -Jl, wi = Zn === 0 ? ao(ae) : ua, Zn < Zi - 1) {
          var ec = me((Qr - To[Zn]) / (Jt[Zn].split(" ").length - 1)), Ws = Jt[Zn].split(" ");
          O.push([Ws[0] + " ", wi, vs]), ua = 0;
          for (var ko = 1; ko < Ws.length; ko++) {
            var $c = (mn(Ws[ko - 1] + " " + Ws[ko]) - mn(Ws[ko])) * Hs + ec;
            ko == Ws.length - 1 ? O.push([Ws[ko], $c, 0]) : O.push([Ws[ko] + " ", $c, 0]), ua -= $c;
          }
        } else O.push([Jt[Zn], wi, vs]);
        O.push(["", ua, 0]);
      } else {
        if (Fr !== "justify") throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        for (O = [], Zi = Jt.length, Qr = Qr !== 0 ? Qr : Ru, Zn = 0; Zn < Zi; Zn++) vs = Zn === 0 ? xo(Ue) : -Jl, wi = Zn === 0 ? ao(ae) : 0, Zn < Zi - 1 ? Ma.push(be(me((Qr - To[Zn]) / (Jt[Zn].split(" ").length - 1)))) : Ma.push(0), O.push([Jt[Zn], wi, vs]);
      }
    }
    var lh = typeof tt.R2L == "boolean" ? tt.R2L : Lr;
    lh === !0 && (O = Pu(O, function(Yn, Kn, Ti) {
      return [Yn.split("").reverse().join(""), Kn, Ti];
    })), jt = { text: O, x: ae, y: Ue, options: tt, mutex: { pdfEscape: so, activeFontKey: fn, fonts: ye, activeFontSize: pr } }, Ge.publish("postProcessText", jt), O = jt.text, Gs = jt.mutex.isHex || !1;
    var qc = ye[fn].encoding;
    qc !== "WinAnsiEncoding" && qc !== "StandardEncoding" || (O = Pu(O, function(Yn, Kn, Ti) {
      return [oh(Yn), Kn, Ti];
    })), Jt = jc(O), O = [];
    for (var tc, Cl, ha, Ra = 0, Ja = 1, Qa = Array.isArray(Jt[0]) ? Ja : Ra, lo = "", el = function(Yn, Kn, Ti) {
      var li = "";
      return Ti instanceof tr ? (Ti = typeof tt.angle == "number" ? xn(Ti, new tr(1, 0, 0, 1, Yn, Kn)) : xn(new tr(1, 0, 0, 1, Yn, Kn), Ti), re === Y.ADVANCED && (Ti = xn(new tr(1, 0, 0, -1, 0, 0), Ti)), li = Ti.join(" ") + ` Tm
`) : li = be(Yn) + " " + be(Kn) + ` Td
`, li;
    }, xs = 0; xs < Jt.length; xs++) {
      switch (lo = "", Qa) {
        case Ja:
          ha = (Gs ? "<" : "(") + Jt[xs][0] + (Gs ? ">" : ")"), tc = parseFloat(Jt[xs][1]), Cl = parseFloat(Jt[xs][2]);
          break;
        case Ra:
          ha = (Gs ? "<" : "(") + Jt[xs] + (Gs ? ">" : ")"), tc = ao(ae), Cl = xo(Ue);
      }
      Ma !== void 0 && Ma[xs] !== void 0 && (lo = Ma[xs] + ` Tw
`), xs === 0 ? O.push(lo + el(tc, Cl, xi) + ha) : Qa === Ra ? O.push(lo + ha) : Qa === Ja && O.push(lo + el(tc, Cl, xi) + ha);
    }
    O = Qa === Ra ? O.join(` Tj
T* `) : O.join(` Tj
`), O += ` Tj
`;
    var Ai = `BT
/`;
    return Ai += fn + " " + pr + ` Tf
`, Ai += be(pr * Ao) + ` TL
`, Ai += Bo + `
`, Ai += Xi, Ai += O, We(Ai += "ET"), M[fn] = !0, fi;
  };
  var ns = E.__private__.clip = E.clip = function(O) {
    return We(O === "evenodd" ? "W*" : "W"), this;
  };
  E.clipEvenOdd = function() {
    return ns("evenodd");
  }, E.__private__.discardPath = E.discardPath = function() {
    return We("n"), this;
  };
  var zn = E.__private__.isValidStyle = function(O) {
    var ae = !1;
    return [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(O) !== -1 && (ae = !0), ae;
  };
  E.__private__.setDefaultPathOperation = E.setDefaultPathOperation = function(O) {
    return zn(O) && (m = O), this;
  };
  var Wi = E.__private__.getStyle = E.getStyle = function(O) {
    var ae = m;
    switch (O) {
      case "D":
      case "S":
        ae = "S";
        break;
      case "F":
        ae = "f";
        break;
      case "FD":
      case "DF":
        ae = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        ae = O;
    }
    return ae;
  }, Ni = E.close = function() {
    return We("h"), this;
  };
  E.stroke = function() {
    return We("S"), this;
  }, E.fill = function(O) {
    return jn("f", O), this;
  }, E.fillEvenOdd = function(O) {
    return jn("f*", O), this;
  }, E.fillStroke = function(O) {
    return jn("B", O), this;
  }, E.fillStrokeEvenOdd = function(O) {
    return jn("B*", O), this;
  };
  var jn = function(O, ae) {
    ci(ae) === "object" ? Ps(ae, O) : We(O);
  }, wl = function(O) {
    O === null || re === Y.ADVANCED && O === void 0 || (O = Wi(O), We(O));
  };
  function pn(O, ae, Ue, tt, mt) {
    var jt = new qd(ae || this.boundingBox, Ue || this.xStep, tt || this.yStep, this.gState, mt || this.matrix);
    jt.stream = this.stream;
    var Jt = O + "$$" + this.cloneIndex++ + "$$";
    return Jr(Jt, jt), jt;
  }
  var Ps = function(O, ae) {
    var Ue = gt[O.key], tt = Qe[Ue];
    if (tt instanceof Ef) We("q"), We(Wr(ae)), tt.gState && E.setGState(tt.gState), We(O.matrix.toString() + " cm"), We("/" + Ue + " sh"), We("Q");
    else if (tt instanceof qd) {
      var mt = new tr(1, 0, 0, -1, 0, Lo());
      O.matrix && (mt = mt.multiply(O.matrix || dn), Ue = pn.call(tt, O.key, O.boundingBox, O.xStep, O.yStep, mt).id), We("q"), We("/Pattern cs"), We("/" + Ue + " scn"), tt.gState && E.setGState(tt.gState), We(ae), We("Q");
    }
  }, Wr = function(O) {
    switch (O) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  }, Yr = E.moveTo = function(O, ae) {
    return We(be(me(O)) + " " + be(Pe(ae)) + " m"), this;
  }, bo = E.lineTo = function(O, ae) {
    return We(be(me(O)) + " " + be(Pe(ae)) + " l"), this;
  }, Or = E.curveTo = function(O, ae, Ue, tt, mt, jt) {
    return We([be(me(O)), be(Pe(ae)), be(me(Ue)), be(Pe(tt)), be(me(mt)), be(Pe(jt)), "c"].join(" ")), this;
  };
  E.__private__.line = E.line = function(O, ae, Ue, tt, mt) {
    if (isNaN(O) || isNaN(ae) || isNaN(Ue) || isNaN(tt) || !zn(mt)) throw new Error("Invalid arguments passed to jsPDF.line");
    return re === Y.COMPAT ? this.lines([[Ue - O, tt - ae]], O, ae, [1, 1], mt || "S") : this.lines([[Ue - O, tt - ae]], O, ae, [1, 1]).stroke();
  }, E.__private__.lines = E.lines = function(O, ae, Ue, tt, mt, jt) {
    var Jt, wr, Fr, sn, Qr, ln, vi, xi, fi, Vi, Xi, Gs;
    if (typeof O == "number" && (Gs = Ue, Ue = ae, ae = O, O = Gs), tt = tt || [1, 1], jt = jt || !1, isNaN(ae) || isNaN(Ue) || !Array.isArray(O) || !Array.isArray(tt) || !zn(mt) || typeof jt != "boolean") throw new Error("Invalid arguments passed to jsPDF.lines");
    for (Yr(ae, Ue), Jt = tt[0], wr = tt[1], sn = O.length, Vi = ae, Xi = Ue, Fr = 0; Fr < sn; Fr++) (Qr = O[Fr]).length === 2 ? (Vi = Qr[0] * Jt + Vi, Xi = Qr[1] * wr + Xi, bo(Vi, Xi)) : (ln = Qr[0] * Jt + Vi, vi = Qr[1] * wr + Xi, xi = Qr[2] * Jt + Vi, fi = Qr[3] * wr + Xi, Vi = Qr[4] * Jt + Vi, Xi = Qr[5] * wr + Xi, Or(ln, vi, xi, fi, Vi, Xi));
    return jt && Ni(), wl(mt), this;
  }, E.path = function(O) {
    for (var ae = 0; ae < O.length; ae++) {
      var Ue = O[ae], tt = Ue.c;
      switch (Ue.op) {
        case "m":
          Yr(tt[0], tt[1]);
          break;
        case "l":
          bo(tt[0], tt[1]);
          break;
        case "c":
          Or.apply(this, tt);
          break;
        case "h":
          Ni();
      }
    }
    return this;
  }, E.__private__.rect = E.rect = function(O, ae, Ue, tt, mt) {
    if (isNaN(O) || isNaN(ae) || isNaN(Ue) || isNaN(tt) || !zn(mt)) throw new Error("Invalid arguments passed to jsPDF.rect");
    return re === Y.COMPAT && (tt = -tt), We([be(me(O)), be(Pe(ae)), be(me(Ue)), be(me(tt)), "re"].join(" ")), wl(mt), this;
  }, E.__private__.triangle = E.triangle = function(O, ae, Ue, tt, mt, jt, Jt) {
    if (isNaN(O) || isNaN(ae) || isNaN(Ue) || isNaN(tt) || isNaN(mt) || isNaN(jt) || !zn(Jt)) throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[Ue - O, tt - ae], [mt - Ue, jt - tt], [O - mt, ae - jt]], O, ae, [1, 1], Jt, !0), this;
  }, E.__private__.roundedRect = E.roundedRect = function(O, ae, Ue, tt, mt, jt, Jt) {
    if (isNaN(O) || isNaN(ae) || isNaN(Ue) || isNaN(tt) || isNaN(mt) || isNaN(jt) || !zn(Jt)) throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var wr = 4 / 3 * (Math.SQRT2 - 1);
    return mt = Math.min(mt, 0.5 * Ue), jt = Math.min(jt, 0.5 * tt), this.lines([[Ue - 2 * mt, 0], [mt * wr, 0, mt, jt - jt * wr, mt, jt], [0, tt - 2 * jt], [0, jt * wr, -mt * wr, jt, -mt, jt], [2 * mt - Ue, 0], [-mt * wr, 0, -mt, -jt * wr, -mt, -jt], [0, 2 * jt - tt], [0, -jt * wr, mt * wr, -jt, mt, -jt]], O + mt, ae, [1, 1], Jt, !0), this;
  }, E.__private__.ellipse = E.ellipse = function(O, ae, Ue, tt, mt) {
    if (isNaN(O) || isNaN(ae) || isNaN(Ue) || isNaN(tt) || !zn(mt)) throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var jt = 4 / 3 * (Math.SQRT2 - 1) * Ue, Jt = 4 / 3 * (Math.SQRT2 - 1) * tt;
    return Yr(O + Ue, ae), Or(O + Ue, ae - Jt, O + jt, ae - tt, O, ae - tt), Or(O - jt, ae - tt, O - Ue, ae - Jt, O - Ue, ae), Or(O - Ue, ae + Jt, O - jt, ae + tt, O, ae + tt), Or(O + jt, ae + tt, O + Ue, ae + Jt, O + Ue, ae), wl(mt), this;
  }, E.__private__.circle = E.circle = function(O, ae, Ue, tt) {
    if (isNaN(O) || isNaN(ae) || isNaN(Ue) || !zn(tt)) throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(O, ae, Ue, Ue, tt);
  }, E.setFont = function(O, ae, Ue) {
    return Ue && (ae = ie(ae, Ue)), fn = Gl(O, ae, { disableWarning: !1 }), this;
  };
  var Za = E.__private__.getFont = E.getFont = function() {
    return ye[Gl.apply(E, arguments)];
  };
  E.__private__.getFontList = E.getFontList = function() {
    var O, ae, Ue = {};
    for (O in Le) if (Le.hasOwnProperty(O)) for (ae in Ue[O] = [], Le[O]) Le[O].hasOwnProperty(ae) && Ue[O].push(ae);
    return Ue;
  }, E.addFont = function(O, ae, Ue, tt, mt) {
    var jt = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && jt.indexOf(arguments[3]) !== -1 ? mt = arguments[3] : arguments[3] && jt.indexOf(arguments[3]) == -1 && (Ue = ie(Ue, tt)), mt = mt || "Identity-H", wa.call(this, O, ae, Ue, mt);
  };
  var Di, Ta = r.lineWidth || 0.200025, bs = E.__private__.getLineWidth = E.getLineWidth = function() {
    return Ta;
  }, zc = E.__private__.setLineWidth = E.setLineWidth = function(O) {
    return Ta = O, We(be(me(O)) + " w"), this;
  };
  E.__private__.setLineDash = rn.API.setLineDash = rn.API.setLineDashPattern = function(O, ae) {
    if (O = O || [], ae = ae || 0, isNaN(ae) || !Array.isArray(O)) throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return O = O.map(function(Ue) {
      return be(me(Ue));
    }).join(" "), ae = be(me(ae)), We("[" + O + "] " + ae + " d"), this;
  };
  var vo = E.__private__.getLineHeight = E.getLineHeight = function() {
    return pr * Di;
  };
  E.__private__.getLineHeight = E.getLineHeight = function() {
    return pr * Di;
  };
  var Eu = E.__private__.setLineHeightFactor = E.setLineHeightFactor = function(O) {
    return typeof (O = O || 1.15) == "number" && (Di = O), this;
  }, Cu = E.__private__.getLineHeightFactor = E.getLineHeightFactor = function() {
    return Di;
  };
  Eu(r.lineHeight);
  var ao = E.__private__.getHorizontalCoordinate = function(O) {
    return me(O);
  }, xo = E.__private__.getVerticalCoordinate = function(O) {
    return re === Y.ADVANCED ? O : ft[Oe].mediaBox.topRightY - ft[Oe].mediaBox.bottomLeftY - me(O);
  }, wo = E.__private__.getHorizontalCoordinateString = E.getHorizontalCoordinateString = function(O) {
    return be(ao(O));
  }, ai = E.__private__.getVerticalCoordinateString = E.getVerticalCoordinateString = function(O) {
    return be(xo(O));
  }, Rs = r.strokeColor || "0 G";
  E.__private__.getStrokeColor = E.getDrawColor = function() {
    return rs(Rs);
  }, E.__private__.setStrokeColor = E.setDrawColor = function(O, ae, Ue, tt) {
    return Rs = _s({ ch1: O, ch2: ae, ch3: Ue, ch4: tt, pdfColorType: "draw", precision: 2 }), We(Rs), this;
  };
  var Ya = r.fillColor || "0 g";
  E.__private__.getFillColor = E.getFillColor = function() {
    return rs(Ya);
  }, E.__private__.setFillColor = E.setFillColor = function(O, ae, Ue, tt) {
    return Ya = _s({ ch1: O, ch2: ae, ch3: Ue, ch4: tt, pdfColorType: "fill", precision: 2 }), We(Ya), this;
  };
  var Bo = r.textColor || "0 g", Ri = E.__private__.getTextColor = E.getTextColor = function() {
    return rs(Bo);
  };
  E.__private__.setTextColor = E.setTextColor = function(O, ae, Ue, tt) {
    return Bo = _s({ ch1: O, ch2: ae, ch3: Ue, ch4: tt, pdfColorType: "text", precision: 3 }), this;
  };
  var Sa = r.charSpace, Al = E.__private__.getCharSpace = E.getCharSpace = function() {
    return parseFloat(Sa || 0);
  };
  E.__private__.setCharSpace = E.setCharSpace = function(O) {
    if (isNaN(O)) throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return Sa = O, this;
  };
  var Ea = 0;
  E.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, E.__private__.setLineCap = E.setLineCap = function(O) {
    var ae = E.CapJoinStyles[O];
    if (ae === void 0) throw new Error("Line cap style of '" + O + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return Ea = ae, We(ae + " J"), this;
  };
  var Iu = 0;
  E.__private__.setLineJoin = E.setLineJoin = function(O) {
    var ae = E.CapJoinStyles[O];
    if (ae === void 0) throw new Error("Line join style of '" + O + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return Iu = ae, We(ae + " j"), this;
  }, E.__private__.setLineMiterLimit = E.__private__.setMiterLimit = E.setLineMiterLimit = E.setMiterLimit = function(O) {
    if (O = O || 0, isNaN(O)) throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return We(be(me(O)) + " M"), this;
  }, E.GState = hy, E.setGState = function(O) {
    (O = typeof O == "string" ? Ke[Bt[O]] : aa(null, O)).equals(Pt) || (We("/" + O.id + " gs"), Pt = O);
  };
  var aa = function(O, ae) {
    if (!O || !Bt[O]) {
      var Ue = !1;
      for (var tt in Ke) if (Ke.hasOwnProperty(tt) && Ke[tt].equals(ae)) {
        Ue = !0;
        break;
      }
      if (Ue) ae = Ke[tt];
      else {
        var mt = "GS" + (Object.keys(Ke).length + 1).toString(10);
        Ke[mt] = ae, ae.id = mt;
      }
      return O && (Bt[O] = ae.id), Ge.publish("addGState", ae), ae;
    }
  };
  E.addGState = function(O, ae) {
    return aa(O, ae), this;
  }, E.saveGraphicsState = function() {
    return We("q"), Ye.push({ key: fn, size: pr, color: Bo }), this;
  }, E.restoreGraphicsState = function() {
    We("Q");
    var O = Ye.pop();
    return fn = O.key, pr = O.size, Bo = O.color, Pt = null, this;
  }, E.setCurrentTransformationMatrix = function(O) {
    return We(O.toString() + " cm"), this;
  }, E.comment = function(O) {
    return We("#" + O), this;
  };
  var Ca = function(O, ae) {
    var Ue = O || 0;
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return Ue;
    }, set: function(jt) {
      isNaN(jt) || (Ue = parseFloat(jt));
    } });
    var tt = ae || 0;
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return tt;
    }, set: function(jt) {
      isNaN(jt) || (tt = parseFloat(jt));
    } });
    var mt = "pt";
    return Object.defineProperty(this, "type", { enumerable: !0, get: function() {
      return mt;
    }, set: function(jt) {
      mt = jt.toString();
    } }), this;
  }, Hl = function(O, ae, Ue, tt) {
    Ca.call(this, O, ae), this.type = "rect";
    var mt = Ue || 0;
    Object.defineProperty(this, "w", { enumerable: !0, get: function() {
      return mt;
    }, set: function(Jt) {
      isNaN(Jt) || (mt = parseFloat(Jt));
    } });
    var jt = tt || 0;
    return Object.defineProperty(this, "h", { enumerable: !0, get: function() {
      return jt;
    }, set: function(Jt) {
      isNaN(Jt) || (jt = parseFloat(Jt));
    } }), this;
  }, Mu = function() {
    this.page = st, this.currentPage = Oe, this.pages = Kt.slice(0), this.pagesContext = ft.slice(0), this.x = nt, this.y = oe, this.matrix = fe, this.width = ji(Oe), this.height = Lo(Oe), this.outputDestination = sr, this.id = "", this.objectNumber = -1;
  };
  Mu.prototype.restore = function() {
    st = this.page, Oe = this.currentPage, ft = this.pagesContext, Kt = this.pages, nt = this.x, oe = this.y, fe = this.matrix, Wl(Oe, this.width), Ia(Oe, this.height), sr = this.outputDestination;
  };
  var is = function(O, ae, Ue, tt, mt) {
    Er.push(new Mu()), st = Oe = 0, Kt = [], nt = O, oe = ae, fe = mt, Dc([Ue, tt]);
  }, Tl = function(O) {
    if (lr[O]) Er.pop().restore();
    else {
      var ae = new Mu(), Ue = "Xo" + (Object.keys(Sr).length + 1).toString(10);
      ae.id = Ue, lr[O] = Ue, Sr[Ue] = ae, Ge.publish("addFormObject", ae), Er.pop().restore();
    }
  };
  for (var ss in E.beginFormObject = function(O, ae, Ue, tt, mt) {
    return is(O, ae, Ue, tt, mt), this;
  }, E.endFormObject = function(O) {
    return Tl(O), this;
  }, E.doFormObject = function(O, ae) {
    var Ue = Sr[lr[O]];
    return We("q"), We(ae.toString() + " cm"), We("/" + Ue.id + " Do"), We("Q"), this;
  }, E.getFormObject = function(O) {
    var ae = Sr[lr[O]];
    return { x: ae.x, y: ae.y, width: ae.width, height: ae.height, matrix: ae.matrix };
  }, E.save = function(O, ae) {
    return O = O || "generated.pdf", (ae = ae || {}).returnPromise = ae.returnPromise || !1, ae.returnPromise === !1 ? (Af(bl($s()), O), typeof Af.unload == "function" && on.setTimeout && setTimeout(Af.unload, 911), this) : new Promise(function(Ue, tt) {
      try {
        var mt = Af(bl($s()), O);
        typeof Af.unload == "function" && on.setTimeout && setTimeout(Af.unload, 911), Ue(mt);
      } catch (jt) {
        tt(jt.message);
      }
    });
  }, rn.API) rn.API.hasOwnProperty(ss) && (ss === "events" && rn.API.events.length ? function(O, ae) {
    var Ue, tt, mt;
    for (mt = ae.length - 1; mt !== -1; mt--) Ue = ae[mt][0], tt = ae[mt][1], O.subscribe.apply(O, [Ue].concat(typeof tt == "function" ? [tt] : tt));
  }(Ge, rn.API.events) : E[ss] = rn.API[ss]);
  var ji = E.getPageWidth = function(O) {
    return (ft[O = O || Oe].mediaBox.topRightX - ft[O].mediaBox.bottomLeftX) / gr;
  }, Wl = E.setPageWidth = function(O, ae) {
    ft[O].mediaBox.topRightX = ae * gr + ft[O].mediaBox.bottomLeftX;
  }, Lo = E.getPageHeight = function(O) {
    return (ft[O = O || Oe].mediaBox.topRightY - ft[O].mediaBox.bottomLeftY) / gr;
  }, Ia = E.setPageHeight = function(O, ae) {
    ft[O].mediaBox.topRightY = ae * gr + ft[O].mediaBox.bottomLeftY;
  };
  return E.internal = { pdfEscape: so, getStyle: Wi, getFont: Za, getFontSize: _r, getCharSpace: Al, getTextColor: Ri, getLineHeight: vo, getLineHeightFactor: Cu, getLineWidth: bs, write: Dr, getHorizontalCoordinate: ao, getVerticalCoordinate: xo, getCoordinateString: wo, getVerticalCoordinateString: ai, collections: {}, newObject: Cr, newAdditionalObject: er, newObjectDeferred: zr, newObjectDeferredBegin: Dn, getFilters: rr, putStream: Vr, events: Ge, scaleFactor: gr, pageSize: { getWidth: function() {
    return ji(Oe);
  }, setWidth: function(O) {
    Wl(Oe, O);
  }, getHeight: function() {
    return Lo(Oe);
  }, setHeight: function(O) {
    Ia(Oe, O);
  } }, encryptionOptions: b, encryption: hi, getEncryptor: hn, output: vl, getNumberOfPages: sh, pages: Kt, out: We, f2: ke, f3: pe, getPageInfo: xl, getPageInfoByObjId: Zr, getCurrentPageInfo: Su, getPDFVersion: U, Point: Ca, Rectangle: Hl, Matrix: tr, hasHotfix: qs }, Object.defineProperty(E.internal.pageSize, "width", { get: function() {
    return ji(Oe);
  }, set: function(O) {
    Wl(Oe, O);
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(E.internal.pageSize, "height", { get: function() {
    return Lo(Oe);
  }, set: function(O) {
    Ia(Oe, O);
  }, enumerable: !0, configurable: !0 }), ih.call(E, Yt), fn = "F1", Xa(i, t), Ge.publish("initialized"), E;
}
Ld.prototype.lsbFirstWord = function(r) {
  return String.fromCharCode(r >> 0 & 255, r >> 8 & 255, r >> 16 & 255, r >> 24 & 255);
}, Ld.prototype.toHexString = function(r) {
  return r.split("").map(function(e) {
    return ("0" + (255 & e.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, Ld.prototype.hexToBytes = function(r) {
  for (var e = [], t = 0; t < r.length; t += 2) e.push(String.fromCharCode(parseInt(r.substr(t, 2), 16)));
  return e.join("");
}, Ld.prototype.processOwnerPassword = function(r, e) {
  return qv($v(e).substr(0, 5), r);
}, Ld.prototype.encryptor = function(r, e) {
  var t = $v(this.encryptionKey + String.fromCharCode(255 & r, r >> 8 & 255, r >> 16 & 255, 255 & e, e >> 8 & 255)).substr(0, 10);
  return function(n) {
    return qv(t, n);
  };
}, hy.prototype.equals = function(r) {
  var e, t = "id,objectNumber,equals";
  if (!r || ci(r) !== ci(this)) return !1;
  var n = 0;
  for (e in this) if (!(t.indexOf(e) >= 0)) {
    if (this.hasOwnProperty(e) && !r.hasOwnProperty(e) || this[e] !== r[e]) return !1;
    n++;
  }
  for (e in r) r.hasOwnProperty(e) && t.indexOf(e) < 0 && n--;
  return n === 0;
}, rn.API = { events: [] }, rn.version = "3.0.0";
var ds = rn.API, Ax = 1, Kf = function(r) {
  return r.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
}, Md = function(r) {
  return r.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}, gn = function(r) {
  return r.toFixed(2);
}, Oh = function(r) {
  return r.toFixed(5);
};
ds.__acroform__ = {};
var qa = function(r, e) {
  r.prototype = Object.create(e.prototype), r.prototype.constructor = r;
}, WS = function(r) {
  return r * Ax;
}, uu = function(r) {
  var e = new $M(), t = Nr.internal.getHeight(r) || 0, n = Nr.internal.getWidth(r) || 0;
  return e.BBox = [0, 0, Number(gn(n)), Number(gn(t))], e;
}, cZ = ds.__acroform__.setBit = function(r, e) {
  if (r = r || 0, e = e || 0, isNaN(r) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return r |= 1 << e;
}, uZ = ds.__acroform__.clearBit = function(r, e) {
  if (r = r || 0, e = e || 0, isNaN(r) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return r &= ~(1 << e);
}, hZ = ds.__acroform__.getBit = function(r, e) {
  if (isNaN(r) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return (r & 1 << e) == 0 ? 0 : 1;
}, Es = ds.__acroform__.getBitForPdf = function(r, e) {
  if (isNaN(r) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return hZ(r, e - 1);
}, Cs = ds.__acroform__.setBitForPdf = function(r, e) {
  if (isNaN(r) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return cZ(r, e - 1);
}, Is = ds.__acroform__.clearBitForPdf = function(r, e) {
  if (isNaN(r) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return uZ(r, e - 1);
}, fZ = ds.__acroform__.calculateCoordinates = function(r, e) {
  var t = e.internal.getHorizontalCoordinate, n = e.internal.getVerticalCoordinate, i = r[0], s = r[1], l = r[2], o = r[3], d = {};
  return d.lowerLeft_X = t(i) || 0, d.lowerLeft_Y = n(s + o) || 0, d.upperRight_X = t(i + l) || 0, d.upperRight_Y = n(s) || 0, [Number(gn(d.lowerLeft_X)), Number(gn(d.lowerLeft_Y)), Number(gn(d.upperRight_X)), Number(gn(d.upperRight_Y))];
}, dZ = function(r) {
  if (r.appearanceStreamContent) return r.appearanceStreamContent;
  if (r.V || r.DV) {
    var e = [], t = r._V || r.DV, n = Gv(r, t), i = r.scope.internal.getFont(r.fontName, r.fontStyle).id;
    e.push("/Tx BMC"), e.push("q"), e.push("BT"), e.push(r.scope.__private__.encodeColorString(r.color)), e.push("/" + i + " " + gn(n.fontSize) + " Tf"), e.push("1 0 0 1 0 0 Tm"), e.push(n.text), e.push("ET"), e.push("Q"), e.push("EMC");
    var s = uu(r);
    return s.scope = r.scope, s.stream = e.join(`
`), s;
  }
}, Gv = function(r, e) {
  var t = r.fontSize === 0 ? r.maxFontSize : r.fontSize, n = { text: "", fontSize: "" }, i = (e = (e = e.substr(0, 1) == "(" ? e.substr(1) : e).substr(e.length - 1) == ")" ? e.substr(0, e.length - 1) : e).split(" ");
  i = r.multiline ? i.map(function(pe) {
    return pe.split(`
`);
  }) : i.map(function(pe) {
    return [pe];
  });
  var s = t, l = Nr.internal.getHeight(r) || 0;
  l = l < 0 ? -l : l;
  var o = Nr.internal.getWidth(r) || 0;
  o = o < 0 ? -o : o;
  var d = function(pe, me, je) {
    if (pe + 1 < i.length) {
      var Pe = me + " " + i[pe + 1][0];
      return e_(Pe, r, je).width <= o - 4;
    }
    return !1;
  };
  s++;
  e: for (; s > 0; ) {
    e = "", s--;
    var m, b, A = e_("3", r, s).height, M = r.multiline ? l - s : (l - A) / 2, E = M += 2, k = 0, U = 0, V = 0;
    if (s <= 0) {
      e = `(...) Tj
`, e += "% Width of Text: " + e_(e, r, s = 12).width + ", FieldWidth:" + o + `
`;
      break;
    }
    for (var q = "", Y = 0, re = 0; re < i.length; re++) if (i.hasOwnProperty(re)) {
      var Z = !1;
      if (i[re].length !== 1 && V !== i[re].length - 1) {
        if ((A + 2) * (Y + 2) + 2 > l) continue e;
        q += i[re][V], Z = !0, U = re, re--;
      } else {
        q = (q += i[re][V] + " ").substr(q.length - 1) == " " ? q.substr(0, q.length - 1) : q;
        var K = parseInt(re), ie = d(K, q, s), be = re >= i.length - 1;
        if (ie && !be) {
          q += " ", V = 0;
          continue;
        }
        if (ie || be) {
          if (be) U = K;
          else if (r.multiline && (A + 2) * (Y + 2) + 2 > l) continue e;
        } else {
          if (!r.multiline || (A + 2) * (Y + 2) + 2 > l) continue e;
          U = K;
        }
      }
      for (var he = "", Be = k; Be <= U; Be++) {
        var ke = i[Be];
        if (r.multiline) {
          if (Be === U) {
            he += ke[V] + " ", V = (V + 1) % ke.length;
            continue;
          }
          if (Be === k) {
            he += ke[ke.length - 1] + " ";
            continue;
          }
        }
        he += ke[0] + " ";
      }
      switch (he = he.substr(he.length - 1) == " " ? he.substr(0, he.length - 1) : he, b = e_(he, r, s).width, r.textAlign) {
        case "right":
          m = o - b - 2;
          break;
        case "center":
          m = (o - b) / 2;
          break;
        case "left":
        default:
          m = 2;
      }
      e += gn(m) + " " + gn(E) + ` Td
`, e += "(" + Kf(he) + `) Tj
`, e += -gn(m) + ` 0 Td
`, E = -(s + 2), b = 0, k = Z ? U : U + 1, Y++, q = "";
    }
    break;
  }
  return n.text = e, n.fontSize = s, n;
}, e_ = function(r, e, t) {
  var n = e.scope.internal.getFont(e.fontName, e.fontStyle), i = e.scope.getStringUnitWidth(r, { font: n, fontSize: parseFloat(t), charSpace: 0 }) * parseFloat(t);
  return { height: e.scope.getStringUnitWidth("3", { font: n, fontSize: parseFloat(t), charSpace: 0 }) * parseFloat(t) * 1.5, width: i };
}, pZ = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: !1, internal: null, isInitialized: !1 }, gZ = function(r, e) {
  var t = { type: "reference", object: r };
  e.internal.getPageInfo(r.page).pageContext.annotations.find(function(n) {
    return n.type === t.type && n.object === t.object;
  }) === void 0 && e.internal.getPageInfo(r.page).pageContext.annotations.push(t);
}, mZ = function(r, e) {
  for (var t in r) if (r.hasOwnProperty(t)) {
    var n = t, i = r[t];
    e.internal.newObjectDeferredBegin(i.objId, !0), ci(i) === "object" && typeof i.putStream == "function" && i.putStream(), delete r[n];
  }
}, _Z = function(r, e) {
  if (e.scope = r, r.internal !== void 0 && (r.internal.acroformPlugin === void 0 || r.internal.acroformPlugin.isInitialized === !1)) {
    if (Oc.FieldNum = 0, r.internal.acroformPlugin = JSON.parse(JSON.stringify(pZ)), r.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("Exception while creating AcroformDictionary");
    Ax = r.internal.scaleFactor, r.internal.acroformPlugin.acroFormDictionaryRoot = new qM(), r.internal.acroformPlugin.acroFormDictionaryRoot.scope = r, r.internal.acroformPlugin.acroFormDictionaryRoot._eventID = r.internal.events.subscribe("postPutResources", function() {
      (function(t) {
        t.internal.events.unsubscribe(t.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete t.internal.acroformPlugin.acroFormDictionaryRoot._eventID, t.internal.acroformPlugin.printedOut = !0;
      })(r);
    }), r.internal.events.subscribe("buildDocument", function() {
      (function(t) {
        t.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var n = t.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var i in n) if (n.hasOwnProperty(i)) {
          var s = n[i];
          s.objId = void 0, s.hasAnnotation && gZ(s, t);
        }
      })(r);
    }), r.internal.events.subscribe("putCatalog", function() {
      (function(t) {
        if (t.internal.acroformPlugin.acroFormDictionaryRoot === void 0) throw new Error("putCatalogCallback: Root missing.");
        t.internal.write("/AcroForm " + t.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      })(r);
    }), r.internal.events.subscribe("postPutPages", function(t) {
      (function(n, i) {
        var s = !n;
        for (var l in n || (i.internal.newObjectDeferredBegin(i.internal.acroformPlugin.acroFormDictionaryRoot.objId, !0), i.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), n = n || i.internal.acroformPlugin.acroFormDictionaryRoot.Kids) if (n.hasOwnProperty(l)) {
          var o = n[l], d = [], m = o.Rect;
          if (o.Rect && (o.Rect = fZ(o.Rect, i)), i.internal.newObjectDeferredBegin(o.objId, !0), o.DA = Nr.createDefaultAppearanceStream(o), ci(o) === "object" && typeof o.getKeyValueListForStream == "function" && (d = o.getKeyValueListForStream()), o.Rect = m, o.hasAppearanceStream && !o.appearanceStreamContent) {
            var b = dZ(o);
            d.push({ key: "AP", value: "<</N " + b + ">>" }), i.internal.acroformPlugin.xForms.push(b);
          }
          if (o.appearanceStreamContent) {
            var A = "";
            for (var M in o.appearanceStreamContent) if (o.appearanceStreamContent.hasOwnProperty(M)) {
              var E = o.appearanceStreamContent[M];
              if (A += "/" + M + " ", A += "<<", Object.keys(E).length >= 1 || Array.isArray(E)) {
                for (var l in E) if (E.hasOwnProperty(l)) {
                  var k = E[l];
                  typeof k == "function" && (k = k.call(i, o)), A += "/" + l + " " + k + " ", i.internal.acroformPlugin.xForms.indexOf(k) >= 0 || i.internal.acroformPlugin.xForms.push(k);
                }
              } else typeof (k = E) == "function" && (k = k.call(i, o)), A += "/" + l + " " + k, i.internal.acroformPlugin.xForms.indexOf(k) >= 0 || i.internal.acroformPlugin.xForms.push(k);
              A += ">>";
            }
            d.push({ key: "AP", value: `<<
` + A + ">>" });
          }
          i.internal.putStream({ additionalKeyValues: d, objectId: o.objId }), i.internal.out("endobj");
        }
        s && mZ(i.internal.acroformPlugin.xForms, i);
      })(t, r);
    }), r.internal.acroformPlugin.isInitialized = !0;
  }
}, VM = ds.__acroform__.arrayToPdfArray = function(r, e, t) {
  var n = function(l) {
    return l;
  };
  if (Array.isArray(r)) {
    for (var i = "[", s = 0; s < r.length; s++) switch (s !== 0 && (i += " "), ci(r[s])) {
      case "boolean":
      case "number":
      case "object":
        i += r[s].toString();
        break;
      case "string":
        r[s].substr(0, 1) !== "/" ? (e !== void 0 && t && (n = t.internal.getEncryptor(e)), i += "(" + Kf(n(r[s].toString())) + ")") : i += r[s].toString();
    }
    return i += "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
}, d1 = function(r, e, t) {
  var n = function(i) {
    return i;
  };
  return e !== void 0 && t && (n = t.internal.getEncryptor(e)), (r = r || "").toString(), r = "(" + Kf(n(r)) + ")";
}, _u = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (this._objId === void 0) {
      if (this.scope === void 0) return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(r) {
    this._objId = r;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: !0 });
};
_u.prototype.toString = function() {
  return this.objId + " 0 R";
}, _u.prototype.putStream = function() {
  var r = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: r, objectId: this.objId }), this.scope.internal.out("endobj");
}, _u.prototype.getKeyValueListForStream = function() {
  var r = [], e = Object.getOwnPropertyNames(this).filter(function(s) {
    return s != "content" && s != "appearanceStreamContent" && s != "scope" && s != "objId" && s.substring(0, 1) != "_";
  });
  for (var t in e) if (Object.getOwnPropertyDescriptor(this, e[t]).configurable === !1) {
    var n = e[t], i = this[n];
    i && (Array.isArray(i) ? r.push({ key: n, value: VM(i, this.objId, this.scope) }) : i instanceof _u ? (i.scope = this.scope, r.push({ key: n, value: i.objId + " 0 R" })) : typeof i != "function" && r.push({ key: n, value: i }));
  }
  return r;
};
var $M = function() {
  _u.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: !1, writable: !0 }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: !1, writable: !0 }), Object.defineProperty(this, "FormType", { value: 1, configurable: !1, writable: !0 });
  var r, e = [];
  Object.defineProperty(this, "BBox", { configurable: !1, get: function() {
    return e;
  }, set: function(t) {
    e = t;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: !1, writable: !0 }), Object.defineProperty(this, "stream", { enumerable: !1, configurable: !0, set: function(t) {
    r = t.trim();
  }, get: function() {
    return r || null;
  } });
};
qa($M, _u);
var qM = function() {
  _u.call(this);
  var r, e = [];
  Object.defineProperty(this, "Kids", { enumerable: !1, configurable: !0, get: function() {
    return e.length > 0 ? e : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: !1, configurable: !1, get: function() {
    return e;
  } }), Object.defineProperty(this, "DA", { enumerable: !1, configurable: !1, get: function() {
    if (r) {
      var t = function(n) {
        return n;
      };
      return this.scope && (t = this.scope.internal.getEncryptor(this.objId)), "(" + Kf(t(r)) + ")";
    }
  }, set: function(t) {
    r = t;
  } });
};
qa(qM, _u);
var Oc = function r() {
  _u.call(this);
  var e = 4;
  Object.defineProperty(this, "F", { enumerable: !1, configurable: !1, get: function() {
    return e;
  }, set: function(q) {
    if (isNaN(q)) throw new Error('Invalid value "' + q + '" for attribute F supplied.');
    e = q;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: !0, configurable: !0, get: function() {
    return !!Es(e, 3);
  }, set: function(q) {
    q ? this.F = Cs(e, 3) : this.F = Is(e, 3);
  } });
  var t = 0;
  Object.defineProperty(this, "Ff", { enumerable: !1, configurable: !1, get: function() {
    return t;
  }, set: function(q) {
    if (isNaN(q)) throw new Error('Invalid value "' + q + '" for attribute Ff supplied.');
    t = q;
  } });
  var n = [];
  Object.defineProperty(this, "Rect", { enumerable: !1, configurable: !1, get: function() {
    if (n.length !== 0) return n;
  }, set: function(q) {
    n = q !== void 0 ? q : [];
  } }), Object.defineProperty(this, "x", { enumerable: !0, configurable: !0, get: function() {
    return !n || isNaN(n[0]) ? 0 : n[0];
  }, set: function(q) {
    n[0] = q;
  } }), Object.defineProperty(this, "y", { enumerable: !0, configurable: !0, get: function() {
    return !n || isNaN(n[1]) ? 0 : n[1];
  }, set: function(q) {
    n[1] = q;
  } }), Object.defineProperty(this, "width", { enumerable: !0, configurable: !0, get: function() {
    return !n || isNaN(n[2]) ? 0 : n[2];
  }, set: function(q) {
    n[2] = q;
  } }), Object.defineProperty(this, "height", { enumerable: !0, configurable: !0, get: function() {
    return !n || isNaN(n[3]) ? 0 : n[3];
  }, set: function(q) {
    n[3] = q;
  } });
  var i = "";
  Object.defineProperty(this, "FT", { enumerable: !0, configurable: !1, get: function() {
    return i;
  }, set: function(q) {
    switch (q) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        i = q;
        break;
      default:
        throw new Error('Invalid value "' + q + '" for attribute FT supplied.');
    }
  } });
  var s = null;
  Object.defineProperty(this, "T", { enumerable: !0, configurable: !1, get: function() {
    if (!s || s.length < 1) {
      if (this instanceof fy) return;
      s = "FieldObject" + r.FieldNum++;
    }
    var q = function(Y) {
      return Y;
    };
    return this.scope && (q = this.scope.internal.getEncryptor(this.objId)), "(" + Kf(q(s)) + ")";
  }, set: function(q) {
    s = q.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: !0, enumerable: !0, get: function() {
    return s;
  }, set: function(q) {
    s = q;
  } });
  var l = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: !0, configurable: !0, get: function() {
    return l;
  }, set: function(q) {
    l = q;
  } });
  var o = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: !0, configurable: !0, get: function() {
    return o;
  }, set: function(q) {
    o = q;
  } });
  var d = 0;
  Object.defineProperty(this, "fontSize", { enumerable: !0, configurable: !0, get: function() {
    return d;
  }, set: function(q) {
    d = q;
  } });
  var m = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: !0, configurable: !0, get: function() {
    return m === void 0 ? 50 / Ax : m;
  }, set: function(q) {
    m = q;
  } });
  var b = "black";
  Object.defineProperty(this, "color", { enumerable: !0, configurable: !0, get: function() {
    return b;
  }, set: function(q) {
    b = q;
  } });
  var A = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: !0, configurable: !1, get: function() {
    if (!(!A || this instanceof fy || this instanceof Uf)) return d1(A, this.objId, this.scope);
  }, set: function(q) {
    q = q.toString(), A = q;
  } });
  var M = null;
  Object.defineProperty(this, "DV", { enumerable: !1, configurable: !1, get: function() {
    if (M) return this instanceof _o ? M : d1(M, this.objId, this.scope);
  }, set: function(q) {
    q = q.toString(), M = this instanceof _o ? q : q.substr(0, 1) === "(" ? Md(q.substr(1, q.length - 2)) : Md(q);
  } }), Object.defineProperty(this, "defaultValue", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof _o ? Md(M.substr(1, M.length - 1)) : M;
  }, set: function(q) {
    q = q.toString(), M = this instanceof _o ? "/" + q : q;
  } });
  var E = null;
  Object.defineProperty(this, "_V", { enumerable: !1, configurable: !1, get: function() {
    if (E) return E;
  }, set: function(q) {
    this.V = q;
  } }), Object.defineProperty(this, "V", { enumerable: !1, configurable: !1, get: function() {
    if (E) return this instanceof _o ? E : d1(E, this.objId, this.scope);
  }, set: function(q) {
    q = q.toString(), E = this instanceof _o ? q : q.substr(0, 1) === "(" ? Md(q.substr(1, q.length - 2)) : Md(q);
  } }), Object.defineProperty(this, "value", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof _o ? Md(E.substr(1, E.length - 1)) : E;
  }, set: function(q) {
    q = q.toString(), E = this instanceof _o ? "/" + q : q;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: !0, configurable: !0, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var k, U = !1;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return U;
  }, set: function(q) {
    q = !!q, U = q;
  } }), Object.defineProperty(this, "page", { enumerable: !0, configurable: !0, get: function() {
    if (k) return k;
  }, set: function(q) {
    k = q;
  } }), Object.defineProperty(this, "readOnly", { enumerable: !0, configurable: !0, get: function() {
    return !!Es(this.Ff, 1);
  }, set: function(q) {
    q ? this.Ff = Cs(this.Ff, 1) : this.Ff = Is(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: !0, configurable: !0, get: function() {
    return !!Es(this.Ff, 2);
  }, set: function(q) {
    q ? this.Ff = Cs(this.Ff, 2) : this.Ff = Is(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: !0, configurable: !0, get: function() {
    return !!Es(this.Ff, 3);
  }, set: function(q) {
    q ? this.Ff = Cs(this.Ff, 3) : this.Ff = Is(this.Ff, 3);
  } });
  var V = null;
  Object.defineProperty(this, "Q", { enumerable: !0, configurable: !1, get: function() {
    if (V !== null) return V;
  }, set: function(q) {
    if ([0, 1, 2].indexOf(q) === -1) throw new Error('Invalid value "' + q + '" for attribute Q supplied.');
    V = q;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var q;
    switch (V) {
      case 0:
      default:
        q = "left";
        break;
      case 1:
        q = "center";
        break;
      case 2:
        q = "right";
    }
    return q;
  }, configurable: !0, enumerable: !0, set: function(q) {
    switch (q) {
      case "right":
      case 2:
        V = 2;
        break;
      case "center":
      case 1:
        V = 1;
        break;
      case "left":
      case 0:
      default:
        V = 0;
    }
  } });
};
qa(Oc, _u);
var Jd = function() {
  Oc.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var r = 0;
  Object.defineProperty(this, "TI", { enumerable: !0, configurable: !1, get: function() {
    return r;
  }, set: function(t) {
    r = t;
  } }), Object.defineProperty(this, "topIndex", { enumerable: !0, configurable: !0, get: function() {
    return r;
  }, set: function(t) {
    r = t;
  } });
  var e = [];
  Object.defineProperty(this, "Opt", { enumerable: !0, configurable: !1, get: function() {
    return VM(e, this.objId, this.scope);
  }, set: function(t) {
    var n, i;
    i = [], typeof (n = t) == "string" && (i = function(s, l, o) {
      o || (o = 1);
      for (var d, m = []; d = l.exec(s); ) m.push(d[o]);
      return m;
    }(n, /\((.*?)\)/g)), e = i;
  } }), this.getOptions = function() {
    return e;
  }, this.setOptions = function(t) {
    e = t, this.sort && e.sort();
  }, this.addOption = function(t) {
    t = (t = t || "").toString(), e.push(t), this.sort && e.sort();
  }, this.removeOption = function(t, n) {
    for (n = n || !1, t = (t = t || "").toString(); e.indexOf(t) !== -1 && (e.splice(e.indexOf(t), 1), n !== !1); ) ;
  }, Object.defineProperty(this, "combo", { enumerable: !0, configurable: !0, get: function() {
    return !!Es(this.Ff, 18);
  }, set: function(t) {
    t ? this.Ff = Cs(this.Ff, 18) : this.Ff = Is(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: !0, configurable: !0, get: function() {
    return !!Es(this.Ff, 19);
  }, set: function(t) {
    this.combo === !0 && (t ? this.Ff = Cs(this.Ff, 19) : this.Ff = Is(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: !0, configurable: !0, get: function() {
    return !!Es(this.Ff, 20);
  }, set: function(t) {
    t ? (this.Ff = Cs(this.Ff, 20), e.sort()) : this.Ff = Is(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!Es(this.Ff, 22);
  }, set: function(t) {
    t ? this.Ff = Cs(this.Ff, 22) : this.Ff = Is(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!Es(this.Ff, 23);
  }, set: function(t) {
    t ? this.Ff = Cs(this.Ff, 23) : this.Ff = Is(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: !0, configurable: !0, get: function() {
    return !!Es(this.Ff, 27);
  }, set: function(t) {
    t ? this.Ff = Cs(this.Ff, 27) : this.Ff = Is(this.Ff, 27);
  } }), this.hasAppearanceStream = !1;
};
qa(Jd, Oc);
var Qd = function() {
  Jd.call(this), this.fontName = "helvetica", this.combo = !1;
};
qa(Qd, Jd);
var ep = function() {
  Qd.call(this), this.combo = !0;
};
qa(ep, Qd);
var x_ = function() {
  ep.call(this), this.edit = !0;
};
qa(x_, ep);
var _o = function() {
  Oc.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: !0, configurable: !0, get: function() {
    return !!Es(this.Ff, 15);
  }, set: function(t) {
    t ? this.Ff = Cs(this.Ff, 15) : this.Ff = Is(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: !0, configurable: !0, get: function() {
    return !!Es(this.Ff, 16);
  }, set: function(t) {
    t ? this.Ff = Cs(this.Ff, 16) : this.Ff = Is(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: !0, configurable: !0, get: function() {
    return !!Es(this.Ff, 17);
  }, set: function(t) {
    t ? this.Ff = Cs(this.Ff, 17) : this.Ff = Is(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: !0, configurable: !0, get: function() {
    return !!Es(this.Ff, 26);
  }, set: function(t) {
    t ? this.Ff = Cs(this.Ff, 26) : this.Ff = Is(this.Ff, 26);
  } });
  var r, e = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var t = function(s) {
      return s;
    };
    if (this.scope && (t = this.scope.internal.getEncryptor(this.objId)), Object.keys(e).length !== 0) {
      var n, i = [];
      for (n in i.push("<<"), e) i.push("/" + n + " (" + Kf(t(e[n])) + ")");
      return i.push(">>"), i.join(`
`);
    }
  }, set: function(t) {
    ci(t) === "object" && (e = t);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return e.CA || "";
  }, set: function(t) {
    typeof t == "string" && (e.CA = t);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return r;
  }, set: function(t) {
    r = t;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return r.substr(1, r.length - 1);
  }, set: function(t) {
    r = "/" + t;
  } });
};
qa(_o, Oc);
var w_ = function() {
  _o.call(this), this.pushButton = !0;
};
qa(w_, _o);
var tp = function() {
  _o.call(this), this.radio = !0, this.pushButton = !1;
  var r = [];
  Object.defineProperty(this, "Kids", { enumerable: !0, configurable: !1, get: function() {
    return r;
  }, set: function(e) {
    r = e !== void 0 ? e : [];
  } });
};
qa(tp, _o);
var fy = function() {
  var r, e;
  Oc.call(this), Object.defineProperty(this, "Parent", { enumerable: !1, configurable: !1, get: function() {
    return r;
  }, set: function(i) {
    r = i;
  } }), Object.defineProperty(this, "optionName", { enumerable: !1, configurable: !0, get: function() {
    return e;
  }, set: function(i) {
    e = i;
  } });
  var t, n = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var i = function(o) {
      return o;
    };
    this.scope && (i = this.scope.internal.getEncryptor(this.objId));
    var s, l = [];
    for (s in l.push("<<"), n) l.push("/" + s + " (" + Kf(i(n[s])) + ")");
    return l.push(">>"), l.join(`
`);
  }, set: function(i) {
    ci(i) === "object" && (n = i);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return n.CA || "";
  }, set: function(i) {
    typeof i == "string" && (n.CA = i);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return t;
  }, set: function(i) {
    t = i;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return t.substr(1, t.length - 1);
  }, set: function(i) {
    t = "/" + i;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = Nr.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
qa(fy, Oc), tp.prototype.setAppearance = function(r) {
  if (!("createAppearanceStream" in r) || !("getCA" in r)) throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var e in this.Kids) if (this.Kids.hasOwnProperty(e)) {
    var t = this.Kids[e];
    t.appearanceStreamContent = r.createAppearanceStream(t.optionName), t.caption = r.getCA();
  }
}, tp.prototype.createOption = function(r) {
  var e = new fy();
  return e.Parent = this, e.optionName = r, this.Kids.push(e), yZ.call(this.scope, e), e;
};
var A_ = function() {
  _o.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = Nr.CheckBox.createAppearanceStream();
};
qa(A_, _o);
var Uf = function() {
  Oc.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: !0, configurable: !0, get: function() {
    return !!Es(this.Ff, 13);
  }, set: function(e) {
    e ? this.Ff = Cs(this.Ff, 13) : this.Ff = Is(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!Es(this.Ff, 21);
  }, set: function(e) {
    e ? this.Ff = Cs(this.Ff, 21) : this.Ff = Is(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!Es(this.Ff, 23);
  }, set: function(e) {
    e ? this.Ff = Cs(this.Ff, 23) : this.Ff = Is(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: !0, configurable: !0, get: function() {
    return !!Es(this.Ff, 24);
  }, set: function(e) {
    e ? this.Ff = Cs(this.Ff, 24) : this.Ff = Is(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: !0, configurable: !0, get: function() {
    return !!Es(this.Ff, 25);
  }, set: function(e) {
    e ? this.Ff = Cs(this.Ff, 25) : this.Ff = Is(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: !0, configurable: !0, get: function() {
    return !!Es(this.Ff, 26);
  }, set: function(e) {
    e ? this.Ff = Cs(this.Ff, 26) : this.Ff = Is(this.Ff, 26);
  } });
  var r = null;
  Object.defineProperty(this, "MaxLen", { enumerable: !0, configurable: !1, get: function() {
    return r;
  }, set: function(e) {
    r = e;
  } }), Object.defineProperty(this, "maxLength", { enumerable: !0, configurable: !0, get: function() {
    return r;
  }, set: function(e) {
    Number.isInteger(e) && (r = e);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return this.V || this.DV;
  } });
};
qa(Uf, Oc);
var T_ = function() {
  Uf.call(this), Object.defineProperty(this, "password", { enumerable: !0, configurable: !0, get: function() {
    return !!Es(this.Ff, 14);
  }, set: function(r) {
    r ? this.Ff = Cs(this.Ff, 14) : this.Ff = Is(this.Ff, 14);
  } }), this.password = !0;
};
qa(T_, Uf);
var Nr = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: Nr.CheckBox.YesNormal }, D: { On: Nr.CheckBox.YesPushDown, Off: Nr.CheckBox.OffPushDown } };
}, YesPushDown: function(r) {
  var e = uu(r);
  e.scope = r.scope;
  var t = [], n = r.scope.internal.getFont(r.fontName, r.fontStyle).id, i = r.scope.__private__.encodeColorString(r.color), s = Gv(r, r.caption);
  return t.push("0.749023 g"), t.push("0 0 " + gn(Nr.internal.getWidth(r)) + " " + gn(Nr.internal.getHeight(r)) + " re"), t.push("f"), t.push("BMC"), t.push("q"), t.push("0 0 1 rg"), t.push("/" + n + " " + gn(s.fontSize) + " Tf " + i), t.push("BT"), t.push(s.text), t.push("ET"), t.push("Q"), t.push("EMC"), e.stream = t.join(`
`), e;
}, YesNormal: function(r) {
  var e = uu(r);
  e.scope = r.scope;
  var t = r.scope.internal.getFont(r.fontName, r.fontStyle).id, n = r.scope.__private__.encodeColorString(r.color), i = [], s = Nr.internal.getHeight(r), l = Nr.internal.getWidth(r), o = Gv(r, r.caption);
  return i.push("1 g"), i.push("0 0 " + gn(l) + " " + gn(s) + " re"), i.push("f"), i.push("q"), i.push("0 0 1 rg"), i.push("0 0 " + gn(l - 1) + " " + gn(s - 1) + " re"), i.push("W"), i.push("n"), i.push("0 g"), i.push("BT"), i.push("/" + t + " " + gn(o.fontSize) + " Tf " + n), i.push(o.text), i.push("ET"), i.push("Q"), e.stream = i.join(`
`), e;
}, OffPushDown: function(r) {
  var e = uu(r);
  e.scope = r.scope;
  var t = [];
  return t.push("0.749023 g"), t.push("0 0 " + gn(Nr.internal.getWidth(r)) + " " + gn(Nr.internal.getHeight(r)) + " re"), t.push("f"), e.stream = t.join(`
`), e;
} }, RadioButton: { Circle: { createAppearanceStream: function(r) {
  var e = { D: { Off: Nr.RadioButton.Circle.OffPushDown }, N: {} };
  return e.N[r] = Nr.RadioButton.Circle.YesNormal, e.D[r] = Nr.RadioButton.Circle.YesPushDown, e;
}, getCA: function() {
  return "l";
}, YesNormal: function(r) {
  var e = uu(r);
  e.scope = r.scope;
  var t = [], n = Nr.internal.getWidth(r) <= Nr.internal.getHeight(r) ? Nr.internal.getWidth(r) / 4 : Nr.internal.getHeight(r) / 4;
  n = Number((0.9 * n).toFixed(5));
  var i = Nr.internal.Bezier_C, s = Number((n * i).toFixed(5));
  return t.push("q"), t.push("1 0 0 1 " + Oh(Nr.internal.getWidth(r) / 2) + " " + Oh(Nr.internal.getHeight(r) / 2) + " cm"), t.push(n + " 0 m"), t.push(n + " " + s + " " + s + " " + n + " 0 " + n + " c"), t.push("-" + s + " " + n + " -" + n + " " + s + " -" + n + " 0 c"), t.push("-" + n + " -" + s + " -" + s + " -" + n + " 0 -" + n + " c"), t.push(s + " -" + n + " " + n + " -" + s + " " + n + " 0 c"), t.push("f"), t.push("Q"), e.stream = t.join(`
`), e;
}, YesPushDown: function(r) {
  var e = uu(r);
  e.scope = r.scope;
  var t = [], n = Nr.internal.getWidth(r) <= Nr.internal.getHeight(r) ? Nr.internal.getWidth(r) / 4 : Nr.internal.getHeight(r) / 4;
  n = Number((0.9 * n).toFixed(5));
  var i = Number((2 * n).toFixed(5)), s = Number((i * Nr.internal.Bezier_C).toFixed(5)), l = Number((n * Nr.internal.Bezier_C).toFixed(5));
  return t.push("0.749023 g"), t.push("q"), t.push("1 0 0 1 " + Oh(Nr.internal.getWidth(r) / 2) + " " + Oh(Nr.internal.getHeight(r) / 2) + " cm"), t.push(i + " 0 m"), t.push(i + " " + s + " " + s + " " + i + " 0 " + i + " c"), t.push("-" + s + " " + i + " -" + i + " " + s + " -" + i + " 0 c"), t.push("-" + i + " -" + s + " -" + s + " -" + i + " 0 -" + i + " c"), t.push(s + " -" + i + " " + i + " -" + s + " " + i + " 0 c"), t.push("f"), t.push("Q"), t.push("0 g"), t.push("q"), t.push("1 0 0 1 " + Oh(Nr.internal.getWidth(r) / 2) + " " + Oh(Nr.internal.getHeight(r) / 2) + " cm"), t.push(n + " 0 m"), t.push(n + " " + l + " " + l + " " + n + " 0 " + n + " c"), t.push("-" + l + " " + n + " -" + n + " " + l + " -" + n + " 0 c"), t.push("-" + n + " -" + l + " -" + l + " -" + n + " 0 -" + n + " c"), t.push(l + " -" + n + " " + n + " -" + l + " " + n + " 0 c"), t.push("f"), t.push("Q"), e.stream = t.join(`
`), e;
}, OffPushDown: function(r) {
  var e = uu(r);
  e.scope = r.scope;
  var t = [], n = Nr.internal.getWidth(r) <= Nr.internal.getHeight(r) ? Nr.internal.getWidth(r) / 4 : Nr.internal.getHeight(r) / 4;
  n = Number((0.9 * n).toFixed(5));
  var i = Number((2 * n).toFixed(5)), s = Number((i * Nr.internal.Bezier_C).toFixed(5));
  return t.push("0.749023 g"), t.push("q"), t.push("1 0 0 1 " + Oh(Nr.internal.getWidth(r) / 2) + " " + Oh(Nr.internal.getHeight(r) / 2) + " cm"), t.push(i + " 0 m"), t.push(i + " " + s + " " + s + " " + i + " 0 " + i + " c"), t.push("-" + s + " " + i + " -" + i + " " + s + " -" + i + " 0 c"), t.push("-" + i + " -" + s + " -" + s + " -" + i + " 0 -" + i + " c"), t.push(s + " -" + i + " " + i + " -" + s + " " + i + " 0 c"), t.push("f"), t.push("Q"), e.stream = t.join(`
`), e;
} }, Cross: { createAppearanceStream: function(r) {
  var e = { D: { Off: Nr.RadioButton.Cross.OffPushDown }, N: {} };
  return e.N[r] = Nr.RadioButton.Cross.YesNormal, e.D[r] = Nr.RadioButton.Cross.YesPushDown, e;
}, getCA: function() {
  return "8";
}, YesNormal: function(r) {
  var e = uu(r);
  e.scope = r.scope;
  var t = [], n = Nr.internal.calculateCross(r);
  return t.push("q"), t.push("1 1 " + gn(Nr.internal.getWidth(r) - 2) + " " + gn(Nr.internal.getHeight(r) - 2) + " re"), t.push("W"), t.push("n"), t.push(gn(n.x1.x) + " " + gn(n.x1.y) + " m"), t.push(gn(n.x2.x) + " " + gn(n.x2.y) + " l"), t.push(gn(n.x4.x) + " " + gn(n.x4.y) + " m"), t.push(gn(n.x3.x) + " " + gn(n.x3.y) + " l"), t.push("s"), t.push("Q"), e.stream = t.join(`
`), e;
}, YesPushDown: function(r) {
  var e = uu(r);
  e.scope = r.scope;
  var t = Nr.internal.calculateCross(r), n = [];
  return n.push("0.749023 g"), n.push("0 0 " + gn(Nr.internal.getWidth(r)) + " " + gn(Nr.internal.getHeight(r)) + " re"), n.push("f"), n.push("q"), n.push("1 1 " + gn(Nr.internal.getWidth(r) - 2) + " " + gn(Nr.internal.getHeight(r) - 2) + " re"), n.push("W"), n.push("n"), n.push(gn(t.x1.x) + " " + gn(t.x1.y) + " m"), n.push(gn(t.x2.x) + " " + gn(t.x2.y) + " l"), n.push(gn(t.x4.x) + " " + gn(t.x4.y) + " m"), n.push(gn(t.x3.x) + " " + gn(t.x3.y) + " l"), n.push("s"), n.push("Q"), e.stream = n.join(`
`), e;
}, OffPushDown: function(r) {
  var e = uu(r);
  e.scope = r.scope;
  var t = [];
  return t.push("0.749023 g"), t.push("0 0 " + gn(Nr.internal.getWidth(r)) + " " + gn(Nr.internal.getHeight(r)) + " re"), t.push("f"), e.stream = t.join(`
`), e;
} } }, createDefaultAppearanceStream: function(r) {
  var e = r.scope.internal.getFont(r.fontName, r.fontStyle).id, t = r.scope.__private__.encodeColorString(r.color);
  return "/" + e + " " + r.fontSize + " Tf " + t;
} };
Nr.internal = { Bezier_C: 0.551915024494, calculateCross: function(r) {
  var e = Nr.internal.getWidth(r), t = Nr.internal.getHeight(r), n = Math.min(e, t);
  return { x1: { x: (e - n) / 2, y: (t - n) / 2 + n }, x2: { x: (e - n) / 2 + n, y: (t - n) / 2 }, x3: { x: (e - n) / 2, y: (t - n) / 2 }, x4: { x: (e - n) / 2 + n, y: (t - n) / 2 + n } };
} }, Nr.internal.getWidth = function(r) {
  var e = 0;
  return ci(r) === "object" && (e = WS(r.Rect[2])), e;
}, Nr.internal.getHeight = function(r) {
  var e = 0;
  return ci(r) === "object" && (e = WS(r.Rect[3])), e;
};
var yZ = ds.addField = function(r) {
  if (_Z(this, r), !(r instanceof Oc)) throw new Error("Invalid argument passed to jsPDF.addField.");
  var e;
  return (e = r).scope.internal.acroformPlugin.printedOut && (e.scope.internal.acroformPlugin.printedOut = !1, e.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), e.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e), r.page = r.scope.internal.getCurrentPageInfo().pageNumber, this;
};
ds.AcroFormChoiceField = Jd, ds.AcroFormListBox = Qd, ds.AcroFormComboBox = ep, ds.AcroFormEditBox = x_, ds.AcroFormButton = _o, ds.AcroFormPushButton = w_, ds.AcroFormRadioButton = tp, ds.AcroFormCheckBox = A_, ds.AcroFormTextField = Uf, ds.AcroFormPasswordField = T_, ds.AcroFormAppearance = Nr, ds.AcroForm = { ChoiceField: Jd, ListBox: Qd, ComboBox: ep, EditBox: x_, Button: _o, PushButton: w_, RadioButton: tp, CheckBox: A_, TextField: Uf, PasswordField: T_, Appearance: Nr }, rn.AcroForm = { ChoiceField: Jd, ListBox: Qd, ComboBox: ep, EditBox: x_, Button: _o, PushButton: w_, RadioButton: tp, CheckBox: A_, TextField: Uf, PasswordField: T_, Appearance: Nr };
rn.AcroForm;
function GM(r) {
  return r.reduce(function(e, t, n) {
    return e[t] = n, e;
  }, {});
}
(function(r) {
  r.__addimage__ = {};
  var e = "UNKNOWN", t = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, n = r.__addimage__.getImageFileTypeByImageData = function(pe, me) {
    var je, Pe, St, Mt, Lt, xt = e;
    if ((me = me || e) === "RGBA" || pe.data !== void 0 && pe.data instanceof Uint8ClampedArray && "height" in pe && "width" in pe) return "RGBA";
    if (ie(pe)) for (Lt in t) for (St = t[Lt], je = 0; je < St.length; je += 1) {
      for (Mt = !0, Pe = 0; Pe < St[je].length; Pe += 1) if (St[je][Pe] !== void 0 && St[je][Pe] !== pe[Pe]) {
        Mt = !1;
        break;
      }
      if (Mt === !0) {
        xt = Lt;
        break;
      }
    }
    else for (Lt in t) for (St = t[Lt], je = 0; je < St.length; je += 1) {
      for (Mt = !0, Pe = 0; Pe < St[je].length; Pe += 1) if (St[je][Pe] !== void 0 && St[je][Pe] !== pe.charCodeAt(Pe)) {
        Mt = !1;
        break;
      }
      if (Mt === !0) {
        xt = Lt;
        break;
      }
    }
    return xt === e && me !== e && (xt = me), xt;
  }, i = function pe(me) {
    for (var je = this.internal.write, Pe = this.internal.putStream, St = (0, this.internal.getFilters)(); St.indexOf("FlateEncode") !== -1; ) St.splice(St.indexOf("FlateEncode"), 1);
    me.objectId = this.internal.newObject();
    var Mt = [];
    if (Mt.push({ key: "Type", value: "/XObject" }), Mt.push({ key: "Subtype", value: "/Image" }), Mt.push({ key: "Width", value: me.width }), Mt.push({ key: "Height", value: me.height }), me.colorSpace === V.INDEXED ? Mt.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (me.palette.length / 3 - 1) + " " + ("sMask" in me && me.sMask !== void 0 ? me.objectId + 2 : me.objectId + 1) + " 0 R]" }) : (Mt.push({ key: "ColorSpace", value: "/" + me.colorSpace }), me.colorSpace === V.DEVICE_CMYK && Mt.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), Mt.push({ key: "BitsPerComponent", value: me.bitsPerComponent }), "decodeParameters" in me && me.decodeParameters !== void 0 && Mt.push({ key: "DecodeParms", value: "<<" + me.decodeParameters + ">>" }), "transparency" in me && Array.isArray(me.transparency)) {
      for (var Lt = "", xt = 0, zt = me.transparency.length; xt < zt; xt++) Lt += me.transparency[xt] + " " + me.transparency[xt] + " ";
      Mt.push({ key: "Mask", value: "[" + Lt + "]" });
    }
    me.sMask !== void 0 && Mt.push({ key: "SMask", value: me.objectId + 1 + " 0 R" });
    var Dt = me.filter !== void 0 ? ["/" + me.filter] : void 0;
    if (Pe({ data: me.data, additionalKeyValues: Mt, alreadyAppliedFilters: Dt, objectId: me.objectId }), je("endobj"), "sMask" in me && me.sMask !== void 0) {
      var hr = "/Predictor " + me.predictor + " /Colors 1 /BitsPerComponent " + me.bitsPerComponent + " /Columns " + me.width, ce = { width: me.width, height: me.height, colorSpace: "DeviceGray", bitsPerComponent: me.bitsPerComponent, decodeParameters: hr, data: me.sMask };
      "filter" in me && (ce.filter = me.filter), pe.call(this, ce);
    }
    if (me.colorSpace === V.INDEXED) {
      var Oe = this.internal.newObject();
      Pe({ data: he(new Uint8Array(me.palette)), objectId: Oe }), je("endobj");
    }
  }, s = function() {
    var pe = this.internal.collections.addImage_images;
    for (var me in pe) i.call(this, pe[me]);
  }, l = function() {
    var pe, me = this.internal.collections.addImage_images, je = this.internal.write;
    for (var Pe in me) je("/I" + (pe = me[Pe]).index, pe.objectId, "0", "R");
  }, o = function() {
    this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", s), this.internal.events.subscribe("putXobjectDict", l));
  }, d = function() {
    var pe = this.internal.collections.addImage_images;
    return o.call(this), pe;
  }, m = function() {
    return Object.keys(this.internal.collections.addImage_images).length;
  }, b = function(pe) {
    return typeof r["process" + pe.toUpperCase()] == "function";
  }, A = function(pe) {
    return ci(pe) === "object" && pe.nodeType === 1;
  }, M = function(pe, me) {
    if (pe.nodeName === "IMG" && pe.hasAttribute("src")) {
      var je = "" + pe.getAttribute("src");
      if (je.indexOf("data:image/") === 0) return Eg(unescape(je).split("base64,").pop());
      var Pe = r.loadFile(je, !0);
      if (Pe !== void 0) return Pe;
    }
    if (pe.nodeName === "CANVAS") {
      if (pe.width === 0 || pe.height === 0) throw new Error("Given canvas must have data. Canvas width: " + pe.width + ", height: " + pe.height);
      var St;
      switch (me) {
        case "PNG":
          St = "image/png";
          break;
        case "WEBP":
          St = "image/webp";
          break;
        case "JPEG":
        case "JPG":
        default:
          St = "image/jpeg";
      }
      return Eg(pe.toDataURL(St, 1).split("base64,").pop());
    }
  }, E = function(pe) {
    var me = this.internal.collections.addImage_images;
    if (me) {
      for (var je in me) if (pe === me[je].alias) return me[je];
    }
  }, k = function(pe, me, je) {
    return pe || me || (pe = -96, me = -96), pe < 0 && (pe = -1 * je.width * 72 / pe / this.internal.scaleFactor), me < 0 && (me = -1 * je.height * 72 / me / this.internal.scaleFactor), pe === 0 && (pe = me * je.width / je.height), me === 0 && (me = pe * je.height / je.width), [pe, me];
  }, U = function(pe, me, je, Pe, St, Mt) {
    var Lt = k.call(this, je, Pe, St), xt = this.internal.getCoordinateString, zt = this.internal.getVerticalCoordinateString, Dt = d.call(this);
    if (je = Lt[0], Pe = Lt[1], Dt[St.index] = St, Mt) {
      Mt *= Math.PI / 180;
      var hr = Math.cos(Mt), ce = Math.sin(Mt), Oe = function(et) {
        return et.toFixed(4);
      }, $e = [Oe(hr), Oe(ce), Oe(-1 * ce), Oe(hr), 0, 0, "cm"];
    }
    this.internal.write("q"), Mt ? (this.internal.write([1, "0", "0", 1, xt(pe), zt(me + Pe), "cm"].join(" ")), this.internal.write($e.join(" ")), this.internal.write([xt(je), "0", "0", xt(Pe), "0", "0", "cm"].join(" "))) : this.internal.write([xt(je), "0", "0", xt(Pe), xt(pe), zt(me + Pe), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + St.index + " Do"), this.internal.write("Q");
  }, V = r.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  r.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var q = r.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, Y = r.__addimage__.sHashCode = function(pe) {
    var me, je, Pe = 0;
    if (typeof pe == "string") for (je = pe.length, me = 0; me < je; me++) Pe = (Pe << 5) - Pe + pe.charCodeAt(me), Pe |= 0;
    else if (ie(pe)) for (je = pe.byteLength / 2, me = 0; me < je; me++) Pe = (Pe << 5) - Pe + pe[me], Pe |= 0;
    return Pe;
  }, re = r.__addimage__.validateStringAsBase64 = function(pe) {
    (pe = pe || "").toString().trim();
    var me = !0;
    return pe.length === 0 && (me = !1), pe.length % 4 != 0 && (me = !1), /^[A-Za-z0-9+/]+$/.test(pe.substr(0, pe.length - 2)) === !1 && (me = !1), /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(pe.substr(-2)) === !1 && (me = !1), me;
  }, Z = r.__addimage__.extractImageFromDataUrl = function(pe) {
    var me = (pe = pe || "").split("base64,"), je = null;
    if (me.length === 2) {
      var Pe = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(me[0]);
      Array.isArray(Pe) && (je = { mimeType: Pe[1], charset: Pe[2], data: me[1] });
    }
    return je;
  }, K = r.__addimage__.supportsArrayBuffer = function() {
    return typeof ArrayBuffer < "u" && typeof Uint8Array < "u";
  };
  r.__addimage__.isArrayBuffer = function(pe) {
    return K() && pe instanceof ArrayBuffer;
  };
  var ie = r.__addimage__.isArrayBufferView = function(pe) {
    return K() && typeof Uint32Array < "u" && (pe instanceof Int8Array || pe instanceof Uint8Array || typeof Uint8ClampedArray < "u" && pe instanceof Uint8ClampedArray || pe instanceof Int16Array || pe instanceof Uint16Array || pe instanceof Int32Array || pe instanceof Uint32Array || pe instanceof Float32Array || pe instanceof Float64Array);
  }, be = r.__addimage__.binaryStringToUint8Array = function(pe) {
    for (var me = pe.length, je = new Uint8Array(me), Pe = 0; Pe < me; Pe++) je[Pe] = pe.charCodeAt(Pe);
    return je;
  }, he = r.__addimage__.arrayBufferToBinaryString = function(pe) {
    for (var me = "", je = ie(pe) ? pe : new Uint8Array(pe), Pe = 0; Pe < je.length; Pe += 8192) me += String.fromCharCode.apply(null, je.subarray(Pe, Pe + 8192));
    return me;
  };
  r.addImage = function() {
    var pe, me, je, Pe, St, Mt, Lt, xt, zt;
    if (typeof arguments[1] == "number" ? (me = e, je = arguments[1], Pe = arguments[2], St = arguments[3], Mt = arguments[4], Lt = arguments[5], xt = arguments[6], zt = arguments[7]) : (me = arguments[1], je = arguments[2], Pe = arguments[3], St = arguments[4], Mt = arguments[5], Lt = arguments[6], xt = arguments[7], zt = arguments[8]), ci(pe = arguments[0]) === "object" && !A(pe) && "imageData" in pe) {
      var Dt = pe;
      pe = Dt.imageData, me = Dt.format || me || e, je = Dt.x || je || 0, Pe = Dt.y || Pe || 0, St = Dt.w || Dt.width || St, Mt = Dt.h || Dt.height || Mt, Lt = Dt.alias || Lt, xt = Dt.compression || xt, zt = Dt.rotation || Dt.angle || zt;
    }
    var hr = this.internal.getFilters();
    if (xt === void 0 && hr.indexOf("FlateEncode") !== -1 && (xt = "SLOW"), isNaN(je) || isNaN(Pe)) throw new Error("Invalid coordinates passed to jsPDF.addImage");
    o.call(this);
    var ce = Be.call(this, pe, me, Lt, xt);
    return U.call(this, je, Pe, St, Mt, ce, zt), this;
  };
  var Be = function(pe, me, je, Pe) {
    var St, Mt, Lt;
    if (typeof pe == "string" && n(pe) === e) {
      pe = unescape(pe);
      var xt = ke(pe, !1);
      (xt !== "" || (xt = r.loadFile(pe, !0)) !== void 0) && (pe = xt);
    }
    if (A(pe) && (pe = M(pe, me)), me = n(pe, me), !b(me)) throw new Error("addImage does not support files of type '" + me + "', please ensure that a plugin for '" + me + "' support is added.");
    if (((Lt = je) == null || Lt.length === 0) && (je = function(zt) {
      return typeof zt == "string" || ie(zt) ? Y(zt) : ie(zt.data) ? Y(zt.data) : null;
    }(pe)), (St = E.call(this, je)) || (K() && (pe instanceof Uint8Array || me === "RGBA" || (Mt = pe, pe = be(pe))), St = this["process" + me.toUpperCase()](pe, m.call(this), je, function(zt) {
      return zt && typeof zt == "string" && (zt = zt.toUpperCase()), zt in r.image_compression ? zt : q.NONE;
    }(Pe), Mt)), !St) throw new Error("An unknown error occurred whilst processing the image.");
    return St;
  }, ke = r.__addimage__.convertBase64ToBinaryString = function(pe, me) {
    var je;
    me = typeof me != "boolean" || me;
    var Pe, St = "";
    if (typeof pe == "string") {
      Pe = (je = Z(pe)) !== null ? je.data : pe;
      try {
        St = Eg(Pe);
      } catch (Mt) {
        if (me) throw re(Pe) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + Mt.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return St;
  };
  r.getImageProperties = function(pe) {
    var me, je, Pe = "";
    if (A(pe) && (pe = M(pe)), typeof pe == "string" && n(pe) === e && ((Pe = ke(pe, !1)) === "" && (Pe = r.loadFile(pe) || ""), pe = Pe), je = n(pe), !b(je)) throw new Error("addImage does not support files of type '" + je + "', please ensure that a plugin for '" + je + "' support is added.");
    if (!K() || pe instanceof Uint8Array || (pe = be(pe)), !(me = this["process" + je.toUpperCase()](pe))) throw new Error("An unknown error occurred whilst processing the image");
    return me.fileType = je, me;
  };
})(rn.API), /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  var e = function(t) {
    if (t !== void 0 && t != "") return !0;
  };
  rn.API.events.push(["addPage", function(t) {
    this.internal.getPageInfo(t.pageNumber).pageContext.annotations = [];
  }]), r.events.push(["putPage", function(t) {
    for (var n, i, s, l = this.internal.getCoordinateString, o = this.internal.getVerticalCoordinateString, d = this.internal.getPageInfoByObjId(t.objId), m = t.pageContext.annotations, b = !1, A = 0; A < m.length && !b; A++) switch ((n = m[A]).type) {
      case "link":
        (e(n.options.url) || e(n.options.pageNumber)) && (b = !0);
        break;
      case "reference":
      case "text":
      case "freetext":
        b = !0;
    }
    if (b != 0) {
      this.internal.write("/Annots [");
      for (var M = 0; M < m.length; M++) {
        n = m[M];
        var E = this.internal.pdfEscape, k = this.internal.getEncryptor(t.objId);
        switch (n.type) {
          case "reference":
            this.internal.write(" " + n.object.objId + " 0 R ");
            break;
          case "text":
            var U = this.internal.newAdditionalObject(), V = this.internal.newAdditionalObject(), q = this.internal.getEncryptor(U.objId), Y = n.title || "Note";
            s = "<</Type /Annot /Subtype /Text " + (i = "/Rect [" + l(n.bounds.x) + " " + o(n.bounds.y + n.bounds.h) + " " + l(n.bounds.x + n.bounds.w) + " " + o(n.bounds.y) + "] ") + "/Contents (" + E(q(n.contents)) + ")", s += " /Popup " + V.objId + " 0 R", s += " /P " + d.objId + " 0 R", s += " /T (" + E(q(Y)) + ") >>", U.content = s;
            var re = U.objId + " 0 R";
            s = "<</Type /Annot /Subtype /Popup " + (i = "/Rect [" + l(n.bounds.x + 30) + " " + o(n.bounds.y + n.bounds.h) + " " + l(n.bounds.x + n.bounds.w + 30) + " " + o(n.bounds.y) + "] ") + " /Parent " + re, n.open && (s += " /Open true"), s += " >>", V.content = s, this.internal.write(U.objId, "0 R", V.objId, "0 R");
            break;
          case "freetext":
            i = "/Rect [" + l(n.bounds.x) + " " + o(n.bounds.y) + " " + l(n.bounds.x + n.bounds.w) + " " + o(n.bounds.y + n.bounds.h) + "] ";
            var Z = n.color || "#000000";
            s = "<</Type /Annot /Subtype /FreeText " + i + "/Contents (" + E(k(n.contents)) + ")", s += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + Z + ")", s += " /Border [0 0 0]", s += " >>", this.internal.write(s);
            break;
          case "link":
            if (n.options.name) {
              var K = this.annotations._nameMap[n.options.name];
              n.options.pageNumber = K.page, n.options.top = K.y;
            } else n.options.top || (n.options.top = 0);
            if (i = "/Rect [" + n.finalBounds.x + " " + n.finalBounds.y + " " + n.finalBounds.w + " " + n.finalBounds.h + "] ", s = "", n.options.url) s = "<</Type /Annot /Subtype /Link " + i + "/Border [0 0 0] /A <</S /URI /URI (" + E(k(n.options.url)) + ") >>";
            else if (n.options.pageNumber) switch (s = "<</Type /Annot /Subtype /Link " + i + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(n.options.pageNumber).objId + " 0 R", n.options.magFactor = n.options.magFactor || "XYZ", n.options.magFactor) {
              case "Fit":
                s += " /Fit]";
                break;
              case "FitH":
                s += " /FitH " + n.options.top + "]";
                break;
              case "FitV":
                n.options.left = n.options.left || 0, s += " /FitV " + n.options.left + "]";
                break;
              case "XYZ":
              default:
                var ie = o(n.options.top);
                n.options.left = n.options.left || 0, n.options.zoom === void 0 && (n.options.zoom = 0), s += " /XYZ " + n.options.left + " " + ie + " " + n.options.zoom + "]";
            }
            s != "" && (s += " >>", this.internal.write(s));
        }
      }
      this.internal.write("]");
    }
  }]), r.createAnnotation = function(t) {
    var n = this.internal.getCurrentPageInfo();
    switch (t.type) {
      case "link":
        this.link(t.bounds.x, t.bounds.y, t.bounds.w, t.bounds.h, t);
        break;
      case "text":
      case "freetext":
        n.pageContext.annotations.push(t);
    }
  }, r.link = function(t, n, i, s, l) {
    var o = this.internal.getCurrentPageInfo(), d = this.internal.getCoordinateString, m = this.internal.getVerticalCoordinateString;
    o.pageContext.annotations.push({ finalBounds: { x: d(t), y: m(n), w: d(t + i), h: m(n + s) }, options: l, type: "link" });
  }, r.textWithLink = function(t, n, i, s) {
    var l, o, d = this.getTextWidth(t), m = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (s.maxWidth !== void 0) {
      o = s.maxWidth;
      var b = this.splitTextToSize(t, o).length;
      l = Math.ceil(m * b);
    } else o = d, l = m;
    return this.text(t, n, i, s), i += 0.2 * m, s.align === "center" && (n -= d / 2), s.align === "right" && (n -= d), this.link(n, i - m, o, l, s), d;
  }, r.getTextWidth = function(t) {
    var n = this.internal.getFontSize();
    return this.getStringUnitWidth(t) * n / this.internal.scaleFactor;
  };
}(rn.API), /**
* @license
* Copyright (c) 2017 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  var e = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, t = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, n = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, i = [1570, 1571, 1573, 1575];
  r.__arabicParser__ = {};
  var s = r.__arabicParser__.isInArabicSubstitutionA = function(U) {
    return e[U.charCodeAt(0)] !== void 0;
  }, l = r.__arabicParser__.isArabicLetter = function(U) {
    return typeof U == "string" && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(U);
  }, o = r.__arabicParser__.isArabicEndLetter = function(U) {
    return l(U) && s(U) && e[U.charCodeAt(0)].length <= 2;
  }, d = r.__arabicParser__.isArabicAlfLetter = function(U) {
    return l(U) && i.indexOf(U.charCodeAt(0)) >= 0;
  };
  r.__arabicParser__.arabicLetterHasIsolatedForm = function(U) {
    return l(U) && s(U) && e[U.charCodeAt(0)].length >= 1;
  };
  var m = r.__arabicParser__.arabicLetterHasFinalForm = function(U) {
    return l(U) && s(U) && e[U.charCodeAt(0)].length >= 2;
  };
  r.__arabicParser__.arabicLetterHasInitialForm = function(U) {
    return l(U) && s(U) && e[U.charCodeAt(0)].length >= 3;
  };
  var b = r.__arabicParser__.arabicLetterHasMedialForm = function(U) {
    return l(U) && s(U) && e[U.charCodeAt(0)].length == 4;
  }, A = r.__arabicParser__.resolveLigatures = function(U) {
    var V = 0, q = t, Y = "", re = 0;
    for (V = 0; V < U.length; V += 1) q[U.charCodeAt(V)] !== void 0 ? (re++, typeof (q = q[U.charCodeAt(V)]) == "number" && (Y += String.fromCharCode(q), q = t, re = 0), V === U.length - 1 && (q = t, Y += U.charAt(V - (re - 1)), V -= re - 1, re = 0)) : (q = t, Y += U.charAt(V - re), V -= re, re = 0);
    return Y;
  };
  r.__arabicParser__.isArabicDiacritic = function(U) {
    return U !== void 0 && n[U.charCodeAt(0)] !== void 0;
  };
  var M = r.__arabicParser__.getCorrectForm = function(U, V, q) {
    return l(U) ? s(U) === !1 ? -1 : !m(U) || !l(V) && !l(q) || !l(q) && o(V) || o(U) && !l(V) || o(U) && d(V) || o(U) && o(V) ? 0 : b(U) && l(V) && !o(V) && l(q) && m(q) ? 3 : o(U) || !l(q) ? 1 : 2 : -1;
  }, E = function(U) {
    var V = 0, q = 0, Y = 0, re = "", Z = "", K = "", ie = (U = U || "").split("\\s+"), be = [];
    for (V = 0; V < ie.length; V += 1) {
      for (be.push(""), q = 0; q < ie[V].length; q += 1) re = ie[V][q], Z = ie[V][q - 1], K = ie[V][q + 1], l(re) ? (Y = M(re, Z, K), be[V] += Y !== -1 ? String.fromCharCode(e[re.charCodeAt(0)][Y]) : re) : be[V] += re;
      be[V] = A(be[V]);
    }
    return be.join(" ");
  }, k = r.__arabicParser__.processArabic = r.processArabic = function() {
    var U, V = typeof arguments[0] == "string" ? arguments[0] : arguments[0].text, q = [];
    if (Array.isArray(V)) {
      var Y = 0;
      for (q = [], Y = 0; Y < V.length; Y += 1) Array.isArray(V[Y]) ? q.push([E(V[Y][0]), V[Y][1], V[Y][2]]) : q.push([E(V[Y])]);
      U = q;
    } else U = E(V);
    return typeof arguments[0] == "string" ? U : (arguments[0].text = U, arguments[0]);
  };
  r.events.push(["preProcessText", k]);
}(rn.API), rn.API.autoPrint = function(r) {
  var e;
  switch ((r = r || {}).variant = r.variant || "non-conform", r.variant) {
    case "javascript":
      this.addJS("print({});");
      break;
    case "non-conform":
    default:
      this.internal.events.subscribe("postPutResources", function() {
        e = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + e + " 0 R");
      });
  }
  return this;
}, /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  var e = function() {
    var t = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return t;
    }, set: function(o) {
      t = o;
    } });
    var n = 150;
    Object.defineProperty(this, "width", { get: function() {
      return n;
    }, set: function(o) {
      n = isNaN(o) || Number.isInteger(o) === !1 || o < 0 ? 150 : o, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = n + 1);
    } });
    var i = 300;
    Object.defineProperty(this, "height", { get: function() {
      return i;
    }, set: function(o) {
      i = isNaN(o) || Number.isInteger(o) === !1 || o < 0 ? 300 : o, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = i + 1);
    } });
    var s = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return s;
    }, set: function(o) {
      s = o;
    } });
    var l = {};
    Object.defineProperty(this, "style", { get: function() {
      return l;
    }, set: function(o) {
      l = o;
    } }), Object.defineProperty(this, "parentNode", {});
  };
  e.prototype.getContext = function(t, n) {
    var i;
    if ((t = t || "2d") !== "2d") return null;
    for (i in n) this.pdf.context2d.hasOwnProperty(i) && (this.pdf.context2d[i] = n[i]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, e.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, r.events.push(["initialized", function() {
    this.canvas = new e(), this.canvas.pdf = this;
  }]);
}(rn.API), function(r) {
  var e = { left: 0, top: 0, bottom: 0, right: 0 }, t = !1, n = function() {
    this.internal.__cell__ === void 0 && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, e), this.internal.__cell__.margins.width = this.getPageWidth(), i.call(this));
  }, i = function() {
    this.internal.__cell__.lastCell = new s(), this.internal.__cell__.pages = 1;
  }, s = function() {
    var d = arguments[0];
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return d;
    }, set: function(U) {
      d = U;
    } });
    var m = arguments[1];
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return m;
    }, set: function(U) {
      m = U;
    } });
    var b = arguments[2];
    Object.defineProperty(this, "width", { enumerable: !0, get: function() {
      return b;
    }, set: function(U) {
      b = U;
    } });
    var A = arguments[3];
    Object.defineProperty(this, "height", { enumerable: !0, get: function() {
      return A;
    }, set: function(U) {
      A = U;
    } });
    var M = arguments[4];
    Object.defineProperty(this, "text", { enumerable: !0, get: function() {
      return M;
    }, set: function(U) {
      M = U;
    } });
    var E = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: !0, get: function() {
      return E;
    }, set: function(U) {
      E = U;
    } });
    var k = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: !0, get: function() {
      return k;
    }, set: function(U) {
      k = U;
    } }), this;
  };
  s.prototype.clone = function() {
    return new s(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, s.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, r.setHeaderFunction = function(d) {
    return n.call(this), this.internal.__cell__.headerFunction = typeof d == "function" ? d : void 0, this;
  }, r.getTextDimensions = function(d, m) {
    n.call(this);
    var b = (m = m || {}).fontSize || this.getFontSize(), A = m.font || this.getFont(), M = m.scaleFactor || this.internal.scaleFactor, E = 0, k = 0, U = 0, V = this;
    if (!Array.isArray(d) && typeof d != "string") {
      if (typeof d != "number") throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      d = String(d);
    }
    var q = m.maxWidth;
    q > 0 ? typeof d == "string" ? d = this.splitTextToSize(d, q) : Object.prototype.toString.call(d) === "[object Array]" && (d = d.reduce(function(re, Z) {
      return re.concat(V.splitTextToSize(Z, q));
    }, [])) : d = Array.isArray(d) ? d : [d];
    for (var Y = 0; Y < d.length; Y++) E < (U = this.getStringUnitWidth(d[Y], { font: A }) * b) && (E = U);
    return E !== 0 && (k = d.length), { w: E /= M, h: Math.max((k * b * this.getLineHeightFactor() - b * (this.getLineHeightFactor() - 1)) / M, 0) };
  }, r.cellAddPage = function() {
    n.call(this), this.addPage();
    var d = this.internal.__cell__.margins || e;
    return this.internal.__cell__.lastCell = new s(d.left, d.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var l = r.cell = function() {
    var d;
    d = arguments[0] instanceof s ? arguments[0] : new s(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), n.call(this);
    var m = this.internal.__cell__.lastCell, b = this.internal.__cell__.padding, A = this.internal.__cell__.margins || e, M = this.internal.__cell__.tableHeaderRow, E = this.internal.__cell__.printHeaders;
    return m.lineNumber !== void 0 && (m.lineNumber === d.lineNumber ? (d.x = (m.x || 0) + (m.width || 0), d.y = m.y || 0) : m.y + m.height + d.height + A.bottom > this.getPageHeight() ? (this.cellAddPage(), d.y = A.top, E && M && (this.printHeaderRow(d.lineNumber, !0), d.y += M[0].height)) : d.y = m.y + m.height || d.y), d.text[0] !== void 0 && (this.rect(d.x, d.y, d.width, d.height, t === !0 ? "FD" : void 0), d.align === "right" ? this.text(d.text, d.x + d.width - b, d.y + b, { align: "right", baseline: "top" }) : d.align === "center" ? this.text(d.text, d.x + d.width / 2, d.y + b, { align: "center", baseline: "top", maxWidth: d.width - b - b }) : this.text(d.text, d.x + b, d.y + b, { align: "left", baseline: "top", maxWidth: d.width - b - b })), this.internal.__cell__.lastCell = d, this;
  };
  r.table = function(d, m, b, A, M) {
    if (n.call(this), !b) throw new Error("No data for PDF table.");
    var E, k, U, V, q = [], Y = [], re = [], Z = {}, K = {}, ie = [], be = [], he = (M = M || {}).autoSize || !1, Be = M.printHeaders !== !1, ke = M.css && M.css["font-size"] !== void 0 ? 16 * M.css["font-size"] : M.fontSize || 12, pe = M.margins || Object.assign({ width: this.getPageWidth() }, e), me = typeof M.padding == "number" ? M.padding : 3, je = M.headerBackgroundColor || "#c8c8c8", Pe = M.headerTextColor || "#000";
    if (i.call(this), this.internal.__cell__.printHeaders = Be, this.internal.__cell__.margins = pe, this.internal.__cell__.table_font_size = ke, this.internal.__cell__.padding = me, this.internal.__cell__.headerBackgroundColor = je, this.internal.__cell__.headerTextColor = Pe, this.setFontSize(ke), A == null) Y = q = Object.keys(b[0]), re = q.map(function() {
      return "left";
    });
    else if (Array.isArray(A) && ci(A[0]) === "object") for (q = A.map(function(Dt) {
      return Dt.name;
    }), Y = A.map(function(Dt) {
      return Dt.prompt || Dt.name || "";
    }), re = A.map(function(Dt) {
      return Dt.align || "left";
    }), E = 0; E < A.length; E += 1) K[A[E].name] = A[E].width * (19.049976 / 25.4);
    else Array.isArray(A) && typeof A[0] == "string" && (Y = q = A, re = q.map(function() {
      return "left";
    }));
    if (he || Array.isArray(A) && typeof A[0] == "string") for (E = 0; E < q.length; E += 1) {
      for (Z[V = q[E]] = b.map(function(Dt) {
        return Dt[V];
      }), this.setFont(void 0, "bold"), ie.push(this.getTextDimensions(Y[E], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), k = Z[V], this.setFont(void 0, "normal"), U = 0; U < k.length; U += 1) ie.push(this.getTextDimensions(k[U], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
      K[V] = Math.max.apply(null, ie) + me + me, ie = [];
    }
    if (Be) {
      var St = {};
      for (E = 0; E < q.length; E += 1) St[q[E]] = {}, St[q[E]].text = Y[E], St[q[E]].align = re[E];
      var Mt = o.call(this, St, K);
      be = q.map(function(Dt) {
        return new s(d, m, K[Dt], Mt, St[Dt].text, void 0, St[Dt].align);
      }), this.setTableHeaderRow(be), this.printHeaderRow(1, !1);
    }
    var Lt = A.reduce(function(Dt, hr) {
      return Dt[hr.name] = hr.align, Dt;
    }, {});
    for (E = 0; E < b.length; E += 1) {
      "rowStart" in M && M.rowStart instanceof Function && M.rowStart({ row: E, data: b[E] }, this);
      var xt = o.call(this, b[E], K);
      for (U = 0; U < q.length; U += 1) {
        var zt = b[E][q[U]];
        "cellStart" in M && M.cellStart instanceof Function && M.cellStart({ row: E, col: U, data: zt }, this), l.call(this, new s(d, m, K[q[U]], xt, zt, E + 2, Lt[q[U]]));
      }
    }
    return this.internal.__cell__.table_x = d, this.internal.__cell__.table_y = m, this;
  };
  var o = function(d, m) {
    var b = this.internal.__cell__.padding, A = this.internal.__cell__.table_font_size, M = this.internal.scaleFactor;
    return Object.keys(d).map(function(E) {
      var k = d[E];
      return this.splitTextToSize(k.hasOwnProperty("text") ? k.text : k, m[E] - b - b);
    }, this).map(function(E) {
      return this.getLineHeightFactor() * E.length * A / M + b + b;
    }, this).reduce(function(E, k) {
      return Math.max(E, k);
    }, 0);
  };
  r.setTableHeaderRow = function(d) {
    n.call(this), this.internal.__cell__.tableHeaderRow = d;
  }, r.printHeaderRow = function(d, m) {
    if (n.call(this), !this.internal.__cell__.tableHeaderRow) throw new Error("Property tableHeaderRow does not exist.");
    var b;
    if (t = !0, typeof this.internal.__cell__.headerFunction == "function") {
      var A = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new s(A[0], A[1], A[2], A[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var M = [], E = 0; E < this.internal.__cell__.tableHeaderRow.length; E += 1) {
      b = this.internal.__cell__.tableHeaderRow[E].clone(), m && (b.y = this.internal.__cell__.margins.top || 0, M.push(b)), b.lineNumber = d;
      var k = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), l.call(this, b), this.setTextColor(k);
    }
    M.length > 0 && this.setTableHeaderRow(M), this.setFont(void 0, "normal"), t = !1;
  };
}(rn.API);
var HM = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] }, WM = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"], Hv = GM(WM), XM = [100, 200, 300, 400, 500, 600, 700, 800, 900], bZ = GM(XM);
function Wv(r) {
  var e = r.family.replace(/"|'/g, "").toLowerCase(), t = function(s) {
    return HM[s = s || "normal"] ? s : "normal";
  }(r.style), n = function(s) {
    if (!s) return 400;
    if (typeof s == "number") return s >= 100 && s <= 900 && s % 100 == 0 ? s : 400;
    if (/^\d00$/.test(s)) return parseInt(s);
    switch (s) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
  }(r.weight), i = function(s) {
    return typeof Hv[s = s || "normal"] == "number" ? s : "normal";
  }(r.stretch);
  return { family: e, style: t, weight: n, stretch: i, src: r.src || [], ref: r.ref || { name: e, style: [i, t, n].join(" ") } };
}
function XS(r, e, t, n) {
  var i;
  for (i = t; i >= 0 && i < e.length; i += n) if (r[e[i]]) return r[e[i]];
  for (i = t; i >= 0 && i < e.length; i -= n) if (r[e[i]]) return r[e[i]];
}
var vZ = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" }, ZS = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function YS(r) {
  return [r.stretch, r.style, r.weight, r.family].join(" ");
}
function xZ(r, e, t) {
  for (var n = (t = t || {}).defaultFontFamily || "times", i = Object.assign({}, vZ, t.genericFontFamilies || {}), s = null, l = null, o = 0; o < e.length; ++o) if (i[(s = Wv(e[o])).family] && (s.family = i[s.family]), r.hasOwnProperty(s.family)) {
    l = r[s.family];
    break;
  }
  if (!(l = l || r[n])) throw new Error("Could not find a font-family for the rule '" + YS(s) + "' and default family '" + n + "'.");
  if (l = function(d, m) {
    if (m[d]) return m[d];
    var b = Hv[d], A = b <= Hv.normal ? -1 : 1, M = XS(m, WM, b, A);
    if (!M) throw new Error("Could not find a matching font-stretch value for " + d);
    return M;
  }(s.stretch, l), l = function(d, m) {
    if (m[d]) return m[d];
    for (var b = HM[d], A = 0; A < b.length; ++A) if (m[b[A]]) return m[b[A]];
    throw new Error("Could not find a matching font-style for " + d);
  }(s.style, l), !(l = function(d, m) {
    if (m[d]) return m[d];
    if (d === 400 && m[500]) return m[500];
    if (d === 500 && m[400]) return m[400];
    var b = bZ[d], A = XS(m, XM, b, d < 400 ? -1 : 1);
    if (!A) throw new Error("Could not find a matching font-weight for value " + d);
    return A;
  }(s.weight, l))) throw new Error("Failed to resolve a font for the rule '" + YS(s) + "'.");
  return l;
}
function KS(r) {
  return r.trimLeft();
}
function wZ(r, e) {
  for (var t = 0; t < r.length; ) {
    if (r.charAt(t) === e) return [r.substring(0, t), r.substring(t + 1)];
    t += 1;
  }
  return null;
}
function AZ(r) {
  var e = r.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return e === null ? null : [e[0], r.substring(e[0].length)];
}
var t_, JS, QS, eE = ["times"];
(function(r) {
  var e, t, n, i, s, l, o, d, m, b = function(ce) {
    return ce = ce || {}, this.isStrokeTransparent = ce.isStrokeTransparent || !1, this.strokeOpacity = ce.strokeOpacity || 1, this.strokeStyle = ce.strokeStyle || "#000000", this.fillStyle = ce.fillStyle || "#000000", this.isFillTransparent = ce.isFillTransparent || !1, this.fillOpacity = ce.fillOpacity || 1, this.font = ce.font || "10px sans-serif", this.textBaseline = ce.textBaseline || "alphabetic", this.textAlign = ce.textAlign || "left", this.lineWidth = ce.lineWidth || 1, this.lineJoin = ce.lineJoin || "miter", this.lineCap = ce.lineCap || "butt", this.path = ce.path || [], this.transform = ce.transform !== void 0 ? ce.transform.clone() : new d(), this.globalCompositeOperation = ce.globalCompositeOperation || "normal", this.globalAlpha = ce.globalAlpha || 1, this.clip_path = ce.clip_path || [], this.currentPoint = ce.currentPoint || new l(), this.miterLimit = ce.miterLimit || 10, this.lastPoint = ce.lastPoint || new l(), this.lineDashOffset = ce.lineDashOffset || 0, this.lineDash = ce.lineDash || [], this.margin = ce.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = ce.prevPageLastElemOffset || 0, this.ignoreClearRect = typeof ce.ignoreClearRect != "boolean" || ce.ignoreClearRect, this;
  };
  r.events.push(["initialized", function() {
    this.context2d = new A(this), e = this.internal.f2, t = this.internal.getCoordinateString, n = this.internal.getVerticalCoordinateString, i = this.internal.getHorizontalCoordinate, s = this.internal.getVerticalCoordinate, l = this.internal.Point, o = this.internal.Rectangle, d = this.internal.Matrix, m = new b();
  }]);
  var A = function(ce) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: !1, style: !1 };
    } });
    var Oe = ce;
    Object.defineProperty(this, "pdf", { get: function() {
      return Oe;
    } });
    var $e = !1;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return $e;
    }, set: function(Nt) {
      $e = !!Nt;
    } });
    var et = !1;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return et;
    }, set: function(Nt) {
      et = !!Nt;
    } });
    var ot = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return ot;
    }, set: function(Nt) {
      isNaN(Nt) || (ot = Nt);
    } });
    var ht = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return ht;
    }, set: function(Nt) {
      isNaN(Nt) || (ht = Nt);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return m.margin;
    }, set: function(Nt) {
      var We;
      typeof Nt == "number" ? We = [Nt, Nt, Nt, Nt] : ((We = new Array(4))[0] = Nt[0], We[1] = Nt.length >= 2 ? Nt[1] : We[0], We[2] = Nt.length >= 3 ? Nt[2] : We[0], We[3] = Nt.length >= 4 ? Nt[3] : We[1]), m.margin = We;
    } });
    var It = !1;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return It;
    }, set: function(Nt) {
      It = Nt;
    } });
    var yt = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return yt;
    }, set: function(Nt) {
      yt = Nt;
    } });
    var ar = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return ar;
    }, set: function(Nt) {
      ar = Nt;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return m;
    }, set: function(Nt) {
      Nt instanceof b && (m = Nt);
    } }), Object.defineProperty(this, "path", { get: function() {
      return m.path;
    }, set: function(Nt) {
      m.path = Nt;
    } });
    var Kt = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return Kt;
    }, set: function(Nt) {
      Kt = Nt;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(Nt) {
      var We;
      We = M(Nt), this.ctx.fillStyle = We.style, this.ctx.isFillTransparent = We.a === 0, this.ctx.fillOpacity = We.a, this.pdf.setFillColor(We.r, We.g, We.b, { a: We.a }), this.pdf.setTextColor(We.r, We.g, We.b, { a: We.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(Nt) {
      var We = M(Nt);
      this.ctx.strokeStyle = We.style, this.ctx.isStrokeTransparent = We.a === 0, this.ctx.strokeOpacity = We.a, We.a === 0 ? this.pdf.setDrawColor(255, 255, 255) : (We.a, this.pdf.setDrawColor(We.r, We.g, We.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(Nt) {
      ["butt", "round", "square"].indexOf(Nt) !== -1 && (this.ctx.lineCap = Nt, this.pdf.setLineCap(Nt));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(Nt) {
      isNaN(Nt) || (this.ctx.lineWidth = Nt, this.pdf.setLineWidth(Nt));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(Nt) {
      ["bevel", "round", "miter"].indexOf(Nt) !== -1 && (this.ctx.lineJoin = Nt, this.pdf.setLineJoin(Nt));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(Nt) {
      isNaN(Nt) || (this.ctx.miterLimit = Nt, this.pdf.setMiterLimit(Nt));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(Nt) {
      this.ctx.textBaseline = Nt;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(Nt) {
      ["right", "end", "center", "left", "start"].indexOf(Nt) !== -1 && (this.ctx.textAlign = Nt);
    } });
    var vr = null;
    function sr(Nt, We) {
      if (vr === null) {
        var Dr = function(Tr) {
          var Yt = [];
          return Object.keys(Tr).forEach(function(pr) {
            Tr[pr].forEach(function(mr) {
              var _r = null;
              switch (mr) {
                case "bold":
                  _r = { family: pr, weight: "bold" };
                  break;
                case "italic":
                  _r = { family: pr, style: "italic" };
                  break;
                case "bolditalic":
                  _r = { family: pr, weight: "bold", style: "italic" };
                  break;
                case "":
                case "normal":
                  _r = { family: pr };
              }
              _r !== null && (_r.ref = { name: pr, style: mr }, Yt.push(_r));
            });
          }), Yt;
        }(Nt.getFontList());
        vr = function(Tr) {
          for (var Yt = {}, pr = 0; pr < Tr.length; ++pr) {
            var mr = Wv(Tr[pr]), _r = mr.family, Lr = mr.stretch, qr = mr.style, Kr = mr.weight;
            Yt[_r] = Yt[_r] || {}, Yt[_r][Lr] = Yt[_r][Lr] || {}, Yt[_r][Lr][qr] = Yt[_r][Lr][qr] || {}, Yt[_r][Lr][qr][Kr] = mr;
          }
          return Yt;
        }(Dr.concat(We));
      }
      return vr;
    }
    var Ur = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return Ur;
    }, set: function(Nt) {
      vr = null, Ur = Nt;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(Nt) {
      var We;
      if (this.ctx.font = Nt, (We = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(Nt)) !== null) {
        var Dr = We[1], Tr = (We[2], We[3]), Yt = We[4], pr = (We[5], We[6]), mr = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(Yt)[2];
        Yt = Math.floor(mr === "px" ? parseFloat(Yt) * this.pdf.internal.scaleFactor : mr === "em" ? parseFloat(Yt) * this.pdf.getFontSize() : parseFloat(Yt) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(Yt);
        var _r = function(Hr) {
          var fn, gr, nt = [], oe = Hr.trim();
          if (oe === "") return eE;
          if (oe in ZS) return [ZS[oe]];
          for (; oe !== ""; ) {
            switch (gr = null, fn = (oe = KS(oe)).charAt(0)) {
              case '"':
              case "'":
                gr = wZ(oe.substring(1), fn);
                break;
              default:
                gr = AZ(oe);
            }
            if (gr === null || (nt.push(gr[0]), (oe = KS(gr[1])) !== "" && oe.charAt(0) !== ",")) return eE;
            oe = oe.replace(/^,/, "");
          }
          return nt;
        }(pr);
        if (this.fontFaces) {
          var Lr = xZ(sr(this.pdf, this.fontFaces), _r.map(function(Hr) {
            return { family: Hr, stretch: "normal", weight: Tr, style: Dr };
          }));
          this.pdf.setFont(Lr.ref.name, Lr.ref.style);
        } else {
          var qr = "";
          (Tr === "bold" || parseInt(Tr, 10) >= 700 || Dr === "bold") && (qr = "bold"), Dr === "italic" && (qr += "italic"), qr.length === 0 && (qr = "normal");
          for (var Kr = "", en = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, nn = 0; nn < _r.length; nn++) {
            if (this.pdf.internal.getFont(_r[nn], qr, { noFallback: !0, disableWarning: !0 }) !== void 0) {
              Kr = _r[nn];
              break;
            }
            if (qr === "bolditalic" && this.pdf.internal.getFont(_r[nn], "bold", { noFallback: !0, disableWarning: !0 }) !== void 0) Kr = _r[nn], qr = "bold";
            else if (this.pdf.internal.getFont(_r[nn], "normal", { noFallback: !0, disableWarning: !0 }) !== void 0) {
              Kr = _r[nn], qr = "normal";
              break;
            }
          }
          if (Kr === "") {
            for (var vn = 0; vn < _r.length; vn++) if (en[_r[vn]]) {
              Kr = en[_r[vn]];
              break;
            }
          }
          Kr = Kr === "" ? "Times" : Kr, this.pdf.setFont(Kr, qr);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(Nt) {
      this.ctx.globalCompositeOperation = Nt;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(Nt) {
      this.ctx.globalAlpha = Nt;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(Nt) {
      this.ctx.lineDashOffset = Nt, hr.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(Nt) {
      this.ctx.lineDash = Nt, hr.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(Nt) {
      this.ctx.ignoreClearRect = !!Nt;
    } });
  };
  A.prototype.setLineDash = function(ce) {
    this.lineDash = ce;
  }, A.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, A.prototype.fill = function() {
    Z.call(this, "fill", !1);
  }, A.prototype.stroke = function() {
    Z.call(this, "stroke", !1);
  }, A.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, A.prototype.moveTo = function(ce, Oe) {
    if (isNaN(ce) || isNaN(Oe)) throw Ii.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var $e = this.ctx.transform.applyToPoint(new l(ce, Oe));
    this.path.push({ type: "mt", x: $e.x, y: $e.y }), this.ctx.lastPoint = new l(ce, Oe);
  }, A.prototype.closePath = function() {
    var ce = new l(0, 0), Oe = 0;
    for (Oe = this.path.length - 1; Oe !== -1; Oe--) if (this.path[Oe].type === "begin" && ci(this.path[Oe + 1]) === "object" && typeof this.path[Oe + 1].x == "number") {
      ce = new l(this.path[Oe + 1].x, this.path[Oe + 1].y);
      break;
    }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new l(ce.x, ce.y);
  }, A.prototype.lineTo = function(ce, Oe) {
    if (isNaN(ce) || isNaN(Oe)) throw Ii.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var $e = this.ctx.transform.applyToPoint(new l(ce, Oe));
    this.path.push({ type: "lt", x: $e.x, y: $e.y }), this.ctx.lastPoint = new l($e.x, $e.y);
  }, A.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), Z.call(this, null, !0);
  }, A.prototype.quadraticCurveTo = function(ce, Oe, $e, et) {
    if (isNaN($e) || isNaN(et) || isNaN(ce) || isNaN(Oe)) throw Ii.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var ot = this.ctx.transform.applyToPoint(new l($e, et)), ht = this.ctx.transform.applyToPoint(new l(ce, Oe));
    this.path.push({ type: "qct", x1: ht.x, y1: ht.y, x: ot.x, y: ot.y }), this.ctx.lastPoint = new l(ot.x, ot.y);
  }, A.prototype.bezierCurveTo = function(ce, Oe, $e, et, ot, ht) {
    if (isNaN(ot) || isNaN(ht) || isNaN(ce) || isNaN(Oe) || isNaN($e) || isNaN(et)) throw Ii.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var It = this.ctx.transform.applyToPoint(new l(ot, ht)), yt = this.ctx.transform.applyToPoint(new l(ce, Oe)), ar = this.ctx.transform.applyToPoint(new l($e, et));
    this.path.push({ type: "bct", x1: yt.x, y1: yt.y, x2: ar.x, y2: ar.y, x: It.x, y: It.y }), this.ctx.lastPoint = new l(It.x, It.y);
  }, A.prototype.arc = function(ce, Oe, $e, et, ot, ht) {
    if (isNaN(ce) || isNaN(Oe) || isNaN($e) || isNaN(et) || isNaN(ot)) throw Ii.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if (ht = !!ht, !this.ctx.transform.isIdentity) {
      var It = this.ctx.transform.applyToPoint(new l(ce, Oe));
      ce = It.x, Oe = It.y;
      var yt = this.ctx.transform.applyToPoint(new l(0, $e)), ar = this.ctx.transform.applyToPoint(new l(0, 0));
      $e = Math.sqrt(Math.pow(yt.x - ar.x, 2) + Math.pow(yt.y - ar.y, 2));
    }
    Math.abs(ot - et) >= 2 * Math.PI && (et = 0, ot = 2 * Math.PI), this.path.push({ type: "arc", x: ce, y: Oe, radius: $e, startAngle: et, endAngle: ot, counterclockwise: ht });
  }, A.prototype.arcTo = function(ce, Oe, $e, et, ot) {
    throw new Error("arcTo not implemented.");
  }, A.prototype.rect = function(ce, Oe, $e, et) {
    if (isNaN(ce) || isNaN(Oe) || isNaN($e) || isNaN(et)) throw Ii.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(ce, Oe), this.lineTo(ce + $e, Oe), this.lineTo(ce + $e, Oe + et), this.lineTo(ce, Oe + et), this.lineTo(ce, Oe), this.lineTo(ce + $e, Oe), this.lineTo(ce, Oe);
  }, A.prototype.fillRect = function(ce, Oe, $e, et) {
    if (isNaN(ce) || isNaN(Oe) || isNaN($e) || isNaN(et)) throw Ii.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!E.call(this)) {
      var ot = {};
      this.lineCap !== "butt" && (ot.lineCap = this.lineCap, this.lineCap = "butt"), this.lineJoin !== "miter" && (ot.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(ce, Oe, $e, et), this.fill(), ot.hasOwnProperty("lineCap") && (this.lineCap = ot.lineCap), ot.hasOwnProperty("lineJoin") && (this.lineJoin = ot.lineJoin);
    }
  }, A.prototype.strokeRect = function(ce, Oe, $e, et) {
    if (isNaN(ce) || isNaN(Oe) || isNaN($e) || isNaN(et)) throw Ii.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    k.call(this) || (this.beginPath(), this.rect(ce, Oe, $e, et), this.stroke());
  }, A.prototype.clearRect = function(ce, Oe, $e, et) {
    if (isNaN(ce) || isNaN(Oe) || isNaN($e) || isNaN(et)) throw Ii.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(ce, Oe, $e, et));
  }, A.prototype.save = function(ce) {
    ce = typeof ce != "boolean" || ce;
    for (var Oe = this.pdf.internal.getCurrentPageInfo().pageNumber, $e = 0; $e < this.pdf.internal.getNumberOfPages(); $e++) this.pdf.setPage($e + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(Oe), ce) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var et = new b(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = et;
    }
  }, A.prototype.restore = function(ce) {
    ce = typeof ce != "boolean" || ce;
    for (var Oe = this.pdf.internal.getCurrentPageInfo().pageNumber, $e = 0; $e < this.pdf.internal.getNumberOfPages(); $e++) this.pdf.setPage($e + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(Oe), ce && this.ctxStack.length !== 0 && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, A.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var M = function(ce) {
    var Oe, $e, et, ot;
    if (ce.isCanvasGradient === !0 && (ce = ce.getColor()), !ce) return { r: 0, g: 0, b: 0, a: 0, style: ce };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(ce)) Oe = 0, $e = 0, et = 0, ot = 0;
    else {
      var ht = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(ce);
      if (ht !== null) Oe = parseInt(ht[1]), $e = parseInt(ht[2]), et = parseInt(ht[3]), ot = 1;
      else if ((ht = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(ce)) !== null) Oe = parseInt(ht[1]), $e = parseInt(ht[2]), et = parseInt(ht[3]), ot = parseFloat(ht[4]);
      else {
        if (ot = 1, typeof ce == "string" && ce.charAt(0) !== "#") {
          var It = new UM(ce);
          ce = It.ok ? It.toHex() : "#000000";
        }
        ce.length === 4 ? (Oe = ce.substring(1, 2), Oe += Oe, $e = ce.substring(2, 3), $e += $e, et = ce.substring(3, 4), et += et) : (Oe = ce.substring(1, 3), $e = ce.substring(3, 5), et = ce.substring(5, 7)), Oe = parseInt(Oe, 16), $e = parseInt($e, 16), et = parseInt(et, 16);
      }
    }
    return { r: Oe, g: $e, b: et, a: ot, style: ce };
  }, E = function() {
    return this.ctx.isFillTransparent || this.globalAlpha == 0;
  }, k = function() {
    return !!(this.ctx.isStrokeTransparent || this.globalAlpha == 0);
  };
  A.prototype.fillText = function(ce, Oe, $e, et) {
    if (isNaN(Oe) || isNaN($e) || typeof ce != "string") throw Ii.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (et = isNaN(et) ? void 0 : et, !E.call(this)) {
      var ot = xt(this.ctx.transform.rotation), ht = this.ctx.transform.scaleX;
      me.call(this, { text: ce, x: Oe, y: $e, scale: ht, angle: ot, align: this.textAlign, maxWidth: et });
    }
  }, A.prototype.strokeText = function(ce, Oe, $e, et) {
    if (isNaN(Oe) || isNaN($e) || typeof ce != "string") throw Ii.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!k.call(this)) {
      et = isNaN(et) ? void 0 : et;
      var ot = xt(this.ctx.transform.rotation), ht = this.ctx.transform.scaleX;
      me.call(this, { text: ce, x: Oe, y: $e, scale: ht, renderingMode: "stroke", angle: ot, align: this.textAlign, maxWidth: et });
    }
  }, A.prototype.measureText = function(ce) {
    if (typeof ce != "string") throw Ii.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var Oe = this.pdf, $e = this.pdf.internal.scaleFactor, et = Oe.internal.getFontSize(), ot = Oe.getStringUnitWidth(ce) * et / Oe.internal.scaleFactor, ht = function(It) {
      var yt = (It = It || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return yt;
      } }), this;
    };
    return new ht({ width: ot *= Math.round(96 * $e / 72 * 1e4) / 1e4 });
  }, A.prototype.scale = function(ce, Oe) {
    if (isNaN(ce) || isNaN(Oe)) throw Ii.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var $e = new d(ce, 0, 0, Oe, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply($e);
  }, A.prototype.rotate = function(ce) {
    if (isNaN(ce)) throw Ii.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var Oe = new d(Math.cos(ce), Math.sin(ce), -Math.sin(ce), Math.cos(ce), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(Oe);
  }, A.prototype.translate = function(ce, Oe) {
    if (isNaN(ce) || isNaN(Oe)) throw Ii.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var $e = new d(1, 0, 0, 1, ce, Oe);
    this.ctx.transform = this.ctx.transform.multiply($e);
  }, A.prototype.transform = function(ce, Oe, $e, et, ot, ht) {
    if (isNaN(ce) || isNaN(Oe) || isNaN($e) || isNaN(et) || isNaN(ot) || isNaN(ht)) throw Ii.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var It = new d(ce, Oe, $e, et, ot, ht);
    this.ctx.transform = this.ctx.transform.multiply(It);
  }, A.prototype.setTransform = function(ce, Oe, $e, et, ot, ht) {
    ce = isNaN(ce) ? 1 : ce, Oe = isNaN(Oe) ? 0 : Oe, $e = isNaN($e) ? 0 : $e, et = isNaN(et) ? 1 : et, ot = isNaN(ot) ? 0 : ot, ht = isNaN(ht) ? 0 : ht, this.ctx.transform = new d(ce, Oe, $e, et, ot, ht);
  };
  var U = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  A.prototype.drawImage = function(ce, Oe, $e, et, ot, ht, It, yt, ar) {
    var Kt = this.pdf.getImageProperties(ce), vr = 1, sr = 1, Ur = 1, Nt = 1;
    et !== void 0 && yt !== void 0 && (Ur = yt / et, Nt = ar / ot, vr = Kt.width / et * yt / et, sr = Kt.height / ot * ar / ot), ht === void 0 && (ht = Oe, It = $e, Oe = 0, $e = 0), et !== void 0 && yt === void 0 && (yt = et, ar = ot), et === void 0 && yt === void 0 && (yt = Kt.width, ar = Kt.height);
    for (var We, Dr = this.ctx.transform.decompose(), Tr = xt(Dr.rotate.shx), Yt = new d(), pr = (Yt = (Yt = (Yt = Yt.multiply(Dr.translate)).multiply(Dr.skew)).multiply(Dr.scale)).applyToRectangle(new o(ht - Oe * Ur, It - $e * Nt, et * vr, ot * sr)), mr = V.call(this, pr), _r = [], Lr = 0; Lr < mr.length; Lr += 1) _r.indexOf(mr[Lr]) === -1 && _r.push(mr[Lr]);
    if (re(_r), this.autoPaging) for (var qr = _r[0], Kr = _r[_r.length - 1], en = qr; en < Kr + 1; en++) {
      this.pdf.setPage(en);
      var nn = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], vn = en === 1 ? this.posY + this.margin[0] : this.margin[0], Hr = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], fn = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], gr = en === 1 ? 0 : Hr + (en - 2) * fn;
      if (this.ctx.clip_path.length !== 0) {
        var nt = this.path;
        We = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = Y(We, this.posX + this.margin[3], -gr + vn + this.ctx.prevPageLastElemOffset), K.call(this, "fill", !0), this.path = nt;
      }
      var oe = JSON.parse(JSON.stringify(pr));
      oe = Y([oe], this.posX + this.margin[3], -gr + vn + this.ctx.prevPageLastElemOffset)[0];
      var fe = (en > qr || en < Kr) && U.call(this);
      fe && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], nn, fn, null).clip().discardPath()), this.pdf.addImage(ce, "JPEG", oe.x, oe.y, oe.w, oe.h, null, null, Tr), fe && this.pdf.restoreGraphicsState();
    }
    else this.pdf.addImage(ce, "JPEG", pr.x, pr.y, pr.w, pr.h, null, null, Tr);
  };
  var V = function(ce, Oe, $e) {
    var et = [];
    Oe = Oe || this.pdf.internal.pageSize.width, $e = $e || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var ot = this.posY + this.ctx.prevPageLastElemOffset;
    switch (ce.type) {
      default:
      case "mt":
      case "lt":
        et.push(Math.floor((ce.y + ot) / $e) + 1);
        break;
      case "arc":
        et.push(Math.floor((ce.y + ot - ce.radius) / $e) + 1), et.push(Math.floor((ce.y + ot + ce.radius) / $e) + 1);
        break;
      case "qct":
        var ht = zt(this.ctx.lastPoint.x, this.ctx.lastPoint.y, ce.x1, ce.y1, ce.x, ce.y);
        et.push(Math.floor((ht.y + ot) / $e) + 1), et.push(Math.floor((ht.y + ht.h + ot) / $e) + 1);
        break;
      case "bct":
        var It = Dt(this.ctx.lastPoint.x, this.ctx.lastPoint.y, ce.x1, ce.y1, ce.x2, ce.y2, ce.x, ce.y);
        et.push(Math.floor((It.y + ot) / $e) + 1), et.push(Math.floor((It.y + It.h + ot) / $e) + 1);
        break;
      case "rect":
        et.push(Math.floor((ce.y + ot) / $e) + 1), et.push(Math.floor((ce.y + ce.h + ot) / $e) + 1);
    }
    for (var yt = 0; yt < et.length; yt += 1) for (; this.pdf.internal.getNumberOfPages() < et[yt]; ) q.call(this);
    return et;
  }, q = function() {
    var ce = this.fillStyle, Oe = this.strokeStyle, $e = this.font, et = this.lineCap, ot = this.lineWidth, ht = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = ce, this.strokeStyle = Oe, this.font = $e, this.lineCap = et, this.lineWidth = ot, this.lineJoin = ht;
  }, Y = function(ce, Oe, $e) {
    for (var et = 0; et < ce.length; et++) switch (ce[et].type) {
      case "bct":
        ce[et].x2 += Oe, ce[et].y2 += $e;
      case "qct":
        ce[et].x1 += Oe, ce[et].y1 += $e;
      case "mt":
      case "lt":
      case "arc":
      default:
        ce[et].x += Oe, ce[et].y += $e;
    }
    return ce;
  }, re = function(ce) {
    return ce.sort(function(Oe, $e) {
      return Oe - $e;
    });
  }, Z = function(ce, Oe) {
    for (var $e, et, ot = this.fillStyle, ht = this.strokeStyle, It = this.lineCap, yt = this.lineWidth, ar = Math.abs(yt * this.ctx.transform.scaleX), Kt = this.lineJoin, vr = JSON.parse(JSON.stringify(this.path)), sr = JSON.parse(JSON.stringify(this.path)), Ur = [], Nt = 0; Nt < sr.length; Nt++) if (sr[Nt].x !== void 0) for (var We = V.call(this, sr[Nt]), Dr = 0; Dr < We.length; Dr += 1) Ur.indexOf(We[Dr]) === -1 && Ur.push(We[Dr]);
    for (var Tr = 0; Tr < Ur.length; Tr++) for (; this.pdf.internal.getNumberOfPages() < Ur[Tr]; ) q.call(this);
    if (re(Ur), this.autoPaging) for (var Yt = Ur[0], pr = Ur[Ur.length - 1], mr = Yt; mr < pr + 1; mr++) {
      this.pdf.setPage(mr), this.fillStyle = ot, this.strokeStyle = ht, this.lineCap = It, this.lineWidth = ar, this.lineJoin = Kt;
      var _r = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], Lr = mr === 1 ? this.posY + this.margin[0] : this.margin[0], qr = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], Kr = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], en = mr === 1 ? 0 : qr + (mr - 2) * Kr;
      if (this.ctx.clip_path.length !== 0) {
        var nn = this.path;
        $e = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = Y($e, this.posX + this.margin[3], -en + Lr + this.ctx.prevPageLastElemOffset), K.call(this, ce, !0), this.path = nn;
      }
      if (et = JSON.parse(JSON.stringify(vr)), this.path = Y(et, this.posX + this.margin[3], -en + Lr + this.ctx.prevPageLastElemOffset), Oe === !1 || mr === 0) {
        var vn = (mr > Yt || mr < pr) && U.call(this);
        vn && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], _r, Kr, null).clip().discardPath()), K.call(this, ce, Oe), vn && this.pdf.restoreGraphicsState();
      }
      this.lineWidth = yt;
    }
    else this.lineWidth = ar, K.call(this, ce, Oe), this.lineWidth = yt;
    this.path = vr;
  }, K = function(ce, Oe) {
    if ((ce !== "stroke" || Oe || !k.call(this)) && (ce === "stroke" || Oe || !E.call(this))) {
      for (var $e, et, ot = [], ht = this.path, It = 0; It < ht.length; It++) {
        var yt = ht[It];
        switch (yt.type) {
          case "begin":
            ot.push({ begin: !0 });
            break;
          case "close":
            ot.push({ close: !0 });
            break;
          case "mt":
            ot.push({ start: yt, deltas: [], abs: [] });
            break;
          case "lt":
            var ar = ot.length;
            if (ht[It - 1] && !isNaN(ht[It - 1].x) && ($e = [yt.x - ht[It - 1].x, yt.y - ht[It - 1].y], ar > 0)) {
              for (; ar >= 0; ar--) if (ot[ar - 1].close !== !0 && ot[ar - 1].begin !== !0) {
                ot[ar - 1].deltas.push($e), ot[ar - 1].abs.push(yt);
                break;
              }
            }
            break;
          case "bct":
            $e = [yt.x1 - ht[It - 1].x, yt.y1 - ht[It - 1].y, yt.x2 - ht[It - 1].x, yt.y2 - ht[It - 1].y, yt.x - ht[It - 1].x, yt.y - ht[It - 1].y], ot[ot.length - 1].deltas.push($e);
            break;
          case "qct":
            var Kt = ht[It - 1].x + 2 / 3 * (yt.x1 - ht[It - 1].x), vr = ht[It - 1].y + 2 / 3 * (yt.y1 - ht[It - 1].y), sr = yt.x + 2 / 3 * (yt.x1 - yt.x), Ur = yt.y + 2 / 3 * (yt.y1 - yt.y), Nt = yt.x, We = yt.y;
            $e = [Kt - ht[It - 1].x, vr - ht[It - 1].y, sr - ht[It - 1].x, Ur - ht[It - 1].y, Nt - ht[It - 1].x, We - ht[It - 1].y], ot[ot.length - 1].deltas.push($e);
            break;
          case "arc":
            ot.push({ deltas: [], abs: [], arc: !0 }), Array.isArray(ot[ot.length - 1].abs) && ot[ot.length - 1].abs.push(yt);
        }
      }
      et = Oe ? null : ce === "stroke" ? "stroke" : "fill";
      for (var Dr = !1, Tr = 0; Tr < ot.length; Tr++) if (ot[Tr].arc) for (var Yt = ot[Tr].abs, pr = 0; pr < Yt.length; pr++) {
        var mr = Yt[pr];
        mr.type === "arc" ? he.call(this, mr.x, mr.y, mr.radius, mr.startAngle, mr.endAngle, mr.counterclockwise, void 0, Oe, !Dr) : je.call(this, mr.x, mr.y), Dr = !0;
      }
      else if (ot[Tr].close === !0) this.pdf.internal.out("h"), Dr = !1;
      else if (ot[Tr].begin !== !0) {
        var _r = ot[Tr].start.x, Lr = ot[Tr].start.y;
        Pe.call(this, ot[Tr].deltas, _r, Lr), Dr = !0;
      }
      et && Be.call(this, et), Oe && ke.call(this);
    }
  }, ie = function(ce) {
    var Oe = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, $e = Oe * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return ce - $e;
      case "top":
        return ce + Oe - $e;
      case "hanging":
        return ce + Oe - 2 * $e;
      case "middle":
        return ce + Oe / 2 - $e;
      case "ideographic":
        return ce;
      case "alphabetic":
      default:
        return ce;
    }
  }, be = function(ce) {
    return ce + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  A.prototype.createLinearGradient = function() {
    var ce = function() {
    };
    return ce.colorStops = [], ce.addColorStop = function(Oe, $e) {
      this.colorStops.push([Oe, $e]);
    }, ce.getColor = function() {
      return this.colorStops.length === 0 ? "#000000" : this.colorStops[0][1];
    }, ce.isCanvasGradient = !0, ce;
  }, A.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, A.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var he = function(ce, Oe, $e, et, ot, ht, It, yt, ar) {
    for (var Kt = Mt.call(this, $e, et, ot, ht), vr = 0; vr < Kt.length; vr++) {
      var sr = Kt[vr];
      vr === 0 && (ar ? pe.call(this, sr.x1 + ce, sr.y1 + Oe) : je.call(this, sr.x1 + ce, sr.y1 + Oe)), St.call(this, ce, Oe, sr.x2, sr.y2, sr.x3, sr.y3, sr.x4, sr.y4);
    }
    yt ? ke.call(this) : Be.call(this, It);
  }, Be = function(ce) {
    switch (ce) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, ke = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, pe = function(ce, Oe) {
    this.pdf.internal.out(t(ce) + " " + n(Oe) + " m");
  }, me = function(ce) {
    var Oe;
    switch (ce.align) {
      case "right":
      case "end":
        Oe = "right";
        break;
      case "center":
        Oe = "center";
        break;
      case "left":
      case "start":
      default:
        Oe = "left";
    }
    var $e = this.pdf.getTextDimensions(ce.text), et = ie.call(this, ce.y), ot = be.call(this, et) - $e.h, ht = this.ctx.transform.applyToPoint(new l(ce.x, et)), It = this.ctx.transform.decompose(), yt = new d();
    yt = (yt = (yt = yt.multiply(It.translate)).multiply(It.skew)).multiply(It.scale);
    for (var ar, Kt, vr, sr = this.ctx.transform.applyToRectangle(new o(ce.x, et, $e.w, $e.h)), Ur = yt.applyToRectangle(new o(ce.x, ot, $e.w, $e.h)), Nt = V.call(this, Ur), We = [], Dr = 0; Dr < Nt.length; Dr += 1) We.indexOf(Nt[Dr]) === -1 && We.push(Nt[Dr]);
    if (re(We), this.autoPaging) for (var Tr = We[0], Yt = We[We.length - 1], pr = Tr; pr < Yt + 1; pr++) {
      this.pdf.setPage(pr);
      var mr = pr === 1 ? this.posY + this.margin[0] : this.margin[0], _r = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], Lr = this.pdf.internal.pageSize.height - this.margin[2], qr = Lr - this.margin[0], Kr = this.pdf.internal.pageSize.width - this.margin[1], en = Kr - this.margin[3], nn = pr === 1 ? 0 : _r + (pr - 2) * qr;
      if (this.ctx.clip_path.length !== 0) {
        var vn = this.path;
        ar = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = Y(ar, this.posX + this.margin[3], -1 * nn + mr), K.call(this, "fill", !0), this.path = vn;
      }
      var Hr = Y([JSON.parse(JSON.stringify(Ur))], this.posX + this.margin[3], -nn + mr + this.ctx.prevPageLastElemOffset)[0];
      ce.scale >= 0.01 && (Kt = this.pdf.internal.getFontSize(), this.pdf.setFontSize(Kt * ce.scale), vr = this.lineWidth, this.lineWidth = vr * ce.scale);
      var fn = this.autoPaging !== "text";
      if (fn || Hr.y + Hr.h <= Lr) {
        if (fn || Hr.y >= mr && Hr.x <= Kr) {
          var gr = fn ? ce.text : this.pdf.splitTextToSize(ce.text, ce.maxWidth || Kr - Hr.x)[0], nt = Y([JSON.parse(JSON.stringify(sr))], this.posX + this.margin[3], -nn + mr + this.ctx.prevPageLastElemOffset)[0], oe = fn && (pr > Tr || pr < Yt) && U.call(this);
          oe && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], en, qr, null).clip().discardPath()), this.pdf.text(gr, nt.x, nt.y, { angle: ce.angle, align: Oe, renderingMode: ce.renderingMode }), oe && this.pdf.restoreGraphicsState();
        }
      } else Hr.y < Lr && (this.ctx.prevPageLastElemOffset += Lr - Hr.y);
      ce.scale >= 0.01 && (this.pdf.setFontSize(Kt), this.lineWidth = vr);
    }
    else ce.scale >= 0.01 && (Kt = this.pdf.internal.getFontSize(), this.pdf.setFontSize(Kt * ce.scale), vr = this.lineWidth, this.lineWidth = vr * ce.scale), this.pdf.text(ce.text, ht.x + this.posX, ht.y + this.posY, { angle: ce.angle, align: Oe, renderingMode: ce.renderingMode, maxWidth: ce.maxWidth }), ce.scale >= 0.01 && (this.pdf.setFontSize(Kt), this.lineWidth = vr);
  }, je = function(ce, Oe, $e, et) {
    $e = $e || 0, et = et || 0, this.pdf.internal.out(t(ce + $e) + " " + n(Oe + et) + " l");
  }, Pe = function(ce, Oe, $e) {
    return this.pdf.lines(ce, Oe, $e, null, null);
  }, St = function(ce, Oe, $e, et, ot, ht, It, yt) {
    this.pdf.internal.out([e(i($e + ce)), e(s(et + Oe)), e(i(ot + ce)), e(s(ht + Oe)), e(i(It + ce)), e(s(yt + Oe)), "c"].join(" "));
  }, Mt = function(ce, Oe, $e, et) {
    for (var ot = 2 * Math.PI, ht = Math.PI / 2; Oe > $e; ) Oe -= ot;
    var It = Math.abs($e - Oe);
    It < ot && et && (It = ot - It);
    for (var yt = [], ar = et ? -1 : 1, Kt = Oe; It > 1e-5; ) {
      var vr = Kt + ar * Math.min(It, ht);
      yt.push(Lt.call(this, ce, Kt, vr)), It -= Math.abs(vr - Kt), Kt = vr;
    }
    return yt;
  }, Lt = function(ce, Oe, $e) {
    var et = ($e - Oe) / 2, ot = ce * Math.cos(et), ht = ce * Math.sin(et), It = ot, yt = -ht, ar = It * It + yt * yt, Kt = ar + It * ot + yt * ht, vr = 4 / 3 * (Math.sqrt(2 * ar * Kt) - Kt) / (It * ht - yt * ot), sr = It - vr * yt, Ur = yt + vr * It, Nt = sr, We = -Ur, Dr = et + Oe, Tr = Math.cos(Dr), Yt = Math.sin(Dr);
    return { x1: ce * Math.cos(Oe), y1: ce * Math.sin(Oe), x2: sr * Tr - Ur * Yt, y2: sr * Yt + Ur * Tr, x3: Nt * Tr - We * Yt, y3: Nt * Yt + We * Tr, x4: ce * Math.cos($e), y4: ce * Math.sin($e) };
  }, xt = function(ce) {
    return 180 * ce / Math.PI;
  }, zt = function(ce, Oe, $e, et, ot, ht) {
    var It = ce + 0.5 * ($e - ce), yt = Oe + 0.5 * (et - Oe), ar = ot + 0.5 * ($e - ot), Kt = ht + 0.5 * (et - ht), vr = Math.min(ce, ot, It, ar), sr = Math.max(ce, ot, It, ar), Ur = Math.min(Oe, ht, yt, Kt), Nt = Math.max(Oe, ht, yt, Kt);
    return new o(vr, Ur, sr - vr, Nt - Ur);
  }, Dt = function(ce, Oe, $e, et, ot, ht, It, yt) {
    var ar, Kt, vr, sr, Ur, Nt, We, Dr, Tr, Yt, pr, mr, _r, Lr, qr = $e - ce, Kr = et - Oe, en = ot - $e, nn = ht - et, vn = It - ot, Hr = yt - ht;
    for (Kt = 0; Kt < 41; Kt++) Tr = (We = (vr = ce + (ar = Kt / 40) * qr) + ar * ((Ur = $e + ar * en) - vr)) + ar * (Ur + ar * (ot + ar * vn - Ur) - We), Yt = (Dr = (sr = Oe + ar * Kr) + ar * ((Nt = et + ar * nn) - sr)) + ar * (Nt + ar * (ht + ar * Hr - Nt) - Dr), Kt == 0 ? (pr = Tr, mr = Yt, _r = Tr, Lr = Yt) : (pr = Math.min(pr, Tr), mr = Math.min(mr, Yt), _r = Math.max(_r, Tr), Lr = Math.max(Lr, Yt));
    return new o(Math.round(pr), Math.round(mr), Math.round(_r - pr), Math.round(Lr - mr));
  }, hr = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var ce, Oe, $e = (ce = this.ctx.lineDash, Oe = this.ctx.lineDashOffset, JSON.stringify({ lineDash: ce, lineDashOffset: Oe }));
      this.prevLineDash !== $e && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = $e);
    }
  };
})(rn.API), /**
* @license
* jsPDF filters PlugIn
* Copyright (c) 2014 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  var e = function(s) {
    var l, o, d, m, b, A, M, E, k, U;
    for (o = [], d = 0, m = (s += l = "\0\0\0\0".slice(s.length % 4 || 4)).length; m > d; d += 4) (b = (s.charCodeAt(d) << 24) + (s.charCodeAt(d + 1) << 16) + (s.charCodeAt(d + 2) << 8) + s.charCodeAt(d + 3)) !== 0 ? (A = (b = ((b = ((b = ((b = (b - (U = b % 85)) / 85) - (k = b % 85)) / 85) - (E = b % 85)) / 85) - (M = b % 85)) / 85) % 85, o.push(A + 33, M + 33, E + 33, k + 33, U + 33)) : o.push(122);
    return function(V, q) {
      for (var Y = q; Y > 0; Y--) V.pop();
    }(o, l.length), String.fromCharCode.apply(String, o) + "~>";
  }, t = function(s) {
    var l, o, d, m, b, A = String, M = "length", E = 255, k = "charCodeAt", U = "slice", V = "replace";
    for (s[U](-2), s = s[U](0, -2)[V](/\s/g, "")[V]("z", "!!!!!"), d = [], m = 0, b = (s += l = "uuuuu"[U](s[M] % 5 || 5))[M]; b > m; m += 5) o = 52200625 * (s[k](m) - 33) + 614125 * (s[k](m + 1) - 33) + 7225 * (s[k](m + 2) - 33) + 85 * (s[k](m + 3) - 33) + (s[k](m + 4) - 33), d.push(E & o >> 24, E & o >> 16, E & o >> 8, E & o);
    return function(q, Y) {
      for (var re = Y; re > 0; re--) q.pop();
    }(d, l[M]), A.fromCharCode.apply(A, d);
  }, n = function(s) {
    var l = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if ((s = s.replace(/\s/g, "")).indexOf(">") !== -1 && (s = s.substr(0, s.indexOf(">"))), s.length % 2 && (s += "0"), l.test(s) === !1) return "";
    for (var o = "", d = 0; d < s.length; d += 2) o += String.fromCharCode("0x" + (s[d] + s[d + 1]));
    return o;
  }, i = function(s) {
    for (var l = new Uint8Array(s.length), o = s.length; o--; ) l[o] = s.charCodeAt(o);
    return s = (l = jv(l)).reduce(function(d, m) {
      return d + String.fromCharCode(m);
    }, "");
  };
  r.processDataByFilters = function(s, l) {
    var o = 0, d = s || "", m = [];
    for (typeof (l = l || []) == "string" && (l = [l]), o = 0; o < l.length; o += 1) switch (l[o]) {
      case "ASCII85Decode":
      case "/ASCII85Decode":
        d = t(d), m.push("/ASCII85Encode");
        break;
      case "ASCII85Encode":
      case "/ASCII85Encode":
        d = e(d), m.push("/ASCII85Decode");
        break;
      case "ASCIIHexDecode":
      case "/ASCIIHexDecode":
        d = n(d), m.push("/ASCIIHexEncode");
        break;
      case "ASCIIHexEncode":
      case "/ASCIIHexEncode":
        d = d.split("").map(function(b) {
          return ("0" + b.charCodeAt().toString(16)).slice(-2);
        }).join("") + ">", m.push("/ASCIIHexDecode");
        break;
      case "FlateEncode":
      case "/FlateEncode":
        d = i(d), m.push("/FlateDecode");
        break;
      default:
        throw new Error('The filter: "' + l[o] + '" is not implemented');
    }
    return { data: d, reverseChain: m.reverse().join(" ") };
  };
}(rn.API), /**
* @license
* jsPDF fileloading PlugIn
* Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  r.loadFile = function(e, t, n) {
    return function(i, s, l) {
      s = s !== !1, l = typeof l == "function" ? l : function() {
      };
      var o = void 0;
      try {
        o = function(d, m, b) {
          var A = new XMLHttpRequest(), M = 0, E = function(k) {
            var U = k.length, V = [], q = String.fromCharCode;
            for (M = 0; M < U; M += 1) V.push(q(255 & k.charCodeAt(M)));
            return V.join("");
          };
          if (A.open("GET", d, !m), A.overrideMimeType("text/plain; charset=x-user-defined"), m === !1 && (A.onload = function() {
            A.status === 200 ? b(E(this.responseText)) : b(void 0);
          }), A.send(null), m && A.status === 200) return E(A.responseText);
        }(i, s, l);
      } catch {
      }
      return o;
    }(e, t, n);
  }, r.loadImageFile = r.loadFile;
}(rn.API), function(r) {
  function e() {
    return (on.html2canvas ? Promise.resolve(on.html2canvas) : import("./html2canvas.esm-DgdJBc_o-DJc3y-dg.mjs")).catch(function(l) {
      return Promise.reject(new Error("Could not load html2canvas: " + l));
    }).then(function(l) {
      return l.default ? l.default : l;
    });
  }
  function t() {
    return (on.DOMPurify ? Promise.resolve(on.DOMPurify) : import("./purify.es-BGDLgQxM-BpzlfVQe.mjs")).catch(function(l) {
      return Promise.reject(new Error("Could not load dompurify: " + l));
    }).then(function(l) {
      return l.default ? l.default : l;
    });
  }
  var n = function(l) {
    var o = ci(l);
    return o === "undefined" ? "undefined" : o === "string" || l instanceof String ? "string" : o === "number" || l instanceof Number ? "number" : o === "function" || l instanceof Function ? "function" : l && l.constructor === Array ? "array" : l && l.nodeType === 1 ? "element" : o === "object" ? "object" : "unknown";
  }, i = function(l, o) {
    var d = document.createElement(l);
    for (var m in o.className && (d.className = o.className), o.innerHTML && o.dompurify && (d.innerHTML = o.dompurify.sanitize(o.innerHTML)), o.style) d.style[m] = o.style[m];
    return d;
  }, s = function l(o) {
    var d = Object.assign(l.convert(Promise.resolve()), JSON.parse(JSON.stringify(l.template))), m = l.convert(Promise.resolve(), d);
    return m = (m = m.setProgress(1, l, 1, [l])).set(o);
  };
  (s.prototype = Object.create(Promise.prototype)).constructor = s, s.convert = function(l, o) {
    return l.__proto__ = o || s.prototype, l;
  }, s.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: !0, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, s.prototype.from = function(l, o) {
    return this.then(function() {
      switch (o = o || function(d) {
        switch (n(d)) {
          case "string":
            return "string";
          case "element":
            return d.nodeName.toLowerCase() === "canvas" ? "canvas" : "element";
          default:
            return "unknown";
        }
      }(l)) {
        case "string":
          return this.then(t).then(function(d) {
            return this.set({ src: i("div", { innerHTML: l, dompurify: d }) });
          });
        case "element":
          return this.set({ src: l });
        case "canvas":
          return this.set({ canvas: l });
        case "img":
          return this.set({ img: l });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, s.prototype.to = function(l) {
    switch (l) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, s.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var l = { position: "relative", display: "inline-block", width: (typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, o = function d(m, b) {
        for (var A = m.nodeType === 3 ? document.createTextNode(m.nodeValue) : m.cloneNode(!1), M = m.firstChild; M; M = M.nextSibling) b !== !0 && M.nodeType === 1 && M.nodeName === "SCRIPT" || A.appendChild(d(M, b));
        return m.nodeType === 1 && (m.nodeName === "CANVAS" ? (A.width = m.width, A.height = m.height, A.getContext("2d").drawImage(m, 0, 0)) : m.nodeName !== "TEXTAREA" && m.nodeName !== "SELECT" || (A.value = m.value), A.addEventListener("load", function() {
          A.scrollTop = m.scrollTop, A.scrollLeft = m.scrollLeft;
        }, !0)), A;
      }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      o.tagName === "BODY" && (l.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = i("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = i("div", { className: "html2pdf__container", style: l }), this.prop.container.appendChild(o), this.prop.container.firstChild.appendChild(i("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, s.prototype.toCanvas = function() {
    var l = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(l).then(e).then(function(o) {
      var d = Object.assign({}, this.opt.html2canvas);
      return delete d.onrendered, o(this.prop.container, d);
    }).then(function(o) {
      (this.opt.html2canvas.onrendered || function() {
      })(o), this.prop.canvas = o, document.body.removeChild(this.prop.overlay);
    });
  }, s.prototype.toContext2d = function() {
    var l = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(l).then(e).then(function(o) {
      var d = this.opt.jsPDF, m = this.opt.fontFaces, b = typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, A = Object.assign({ async: !0, allowTaint: !0, scale: b, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: !0, proxy: null, removeContainer: !0, foreignObjectRendering: !1, useCORS: !1 }, this.opt.html2canvas);
      if (delete A.onrendered, d.context2d.autoPaging = this.opt.autoPaging === void 0 || this.opt.autoPaging, d.context2d.posX = this.opt.x, d.context2d.posY = this.opt.y, d.context2d.margin = this.opt.margin, d.context2d.fontFaces = m, m) for (var M = 0; M < m.length; ++M) {
        var E = m[M], k = E.src.find(function(U) {
          return U.format === "truetype";
        });
        k && d.addFont(k.url, E.ref.name, E.ref.style);
      }
      return A.windowHeight = A.windowHeight || 0, A.windowHeight = A.windowHeight == 0 ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : A.windowHeight, d.context2d.save(!0), o(this.prop.container, A);
    }).then(function(o) {
      this.opt.jsPDF.context2d.restore(!0), (this.opt.html2canvas.onrendered || function() {
      })(o), this.prop.canvas = o, document.body.removeChild(this.prop.overlay);
    });
  }, s.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var l = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = l;
    });
  }, s.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, s.prototype.output = function(l, o, d) {
    return (d = d || "pdf").toLowerCase() === "img" || d.toLowerCase() === "image" ? this.outputImg(l, o) : this.outputPdf(l, o);
  }, s.prototype.outputPdf = function(l, o) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(l, o);
    });
  }, s.prototype.outputImg = function(l) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (l) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + l + '" is not supported.';
      }
    });
  }, s.prototype.save = function(l) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(l ? { filename: l } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, s.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, s.prototype.set = function(l) {
    if (n(l) !== "object") return this;
    var o = Object.keys(l || {}).map(function(d) {
      if (d in s.template.prop) return function() {
        this.prop[d] = l[d];
      };
      switch (d) {
        case "margin":
          return this.setMargin.bind(this, l.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = l.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, l.pageSize);
        default:
          return function() {
            this.opt[d] = l[d];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(o);
    });
  }, s.prototype.get = function(l, o) {
    return this.then(function() {
      var d = l in s.template.prop ? this.prop[l] : this.opt[l];
      return o ? o(d) : d;
    });
  }, s.prototype.setMargin = function(l) {
    return this.then(function() {
      switch (n(l)) {
        case "number":
          l = [l, l, l, l];
        case "array":
          if (l.length === 2 && (l = [l[0], l[1], l[0], l[1]]), l.length === 4) break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = l;
    }).then(this.setPageSize);
  }, s.prototype.setPageSize = function(l) {
    function o(d, m) {
      return Math.floor(d * m / 72 * 96);
    }
    return this.then(function() {
      (l = l || rn.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (l.inner = { width: l.width - this.opt.margin[1] - this.opt.margin[3], height: l.height - this.opt.margin[0] - this.opt.margin[2] }, l.inner.px = { width: o(l.inner.width, l.k), height: o(l.inner.height, l.k) }, l.inner.ratio = l.inner.height / l.inner.width), this.prop.pageSize = l;
    });
  }, s.prototype.setProgress = function(l, o, d, m) {
    return l != null && (this.progress.val = l), o != null && (this.progress.state = o), d != null && (this.progress.n = d), m != null && (this.progress.stack = m), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, s.prototype.updateProgress = function(l, o, d, m) {
    return this.setProgress(l ? this.progress.val + l : null, o || null, d ? this.progress.n + d : null, m ? this.progress.stack.concat(m) : null);
  }, s.prototype.then = function(l, o) {
    var d = this;
    return this.thenCore(l, o, function(m, b) {
      return d.updateProgress(null, null, 1, [m]), Promise.prototype.then.call(this, function(A) {
        return d.updateProgress(null, m), A;
      }).then(m, b).then(function(A) {
        return d.updateProgress(1), A;
      });
    });
  }, s.prototype.thenCore = function(l, o, d) {
    d = d || Promise.prototype.then, l && (l = l.bind(this)), o && (o = o.bind(this));
    var m = Promise.toString().indexOf("[native code]") !== -1 && Promise.name === "Promise" ? this : s.convert(Object.assign({}, this), Promise.prototype), b = d.call(m, l, o);
    return s.convert(b, this.__proto__);
  }, s.prototype.thenExternal = function(l, o) {
    return Promise.prototype.then.call(this, l, o);
  }, s.prototype.thenList = function(l) {
    var o = this;
    return l.forEach(function(d) {
      o = o.thenCore(d);
    }), o;
  }, s.prototype.catch = function(l) {
    l && (l = l.bind(this));
    var o = Promise.prototype.catch.call(this, l);
    return s.convert(o, this);
  }, s.prototype.catchExternal = function(l) {
    return Promise.prototype.catch.call(this, l);
  }, s.prototype.error = function(l) {
    return this.then(function() {
      throw new Error(l);
    });
  }, s.prototype.using = s.prototype.set, s.prototype.saveAs = s.prototype.save, s.prototype.export = s.prototype.output, s.prototype.run = s.prototype.then, rn.getPageSize = function(l, o, d) {
    if (ci(l) === "object") {
      var m = l;
      l = m.orientation, o = m.unit || o, d = m.format || d;
    }
    o = o || "mm", d = d || "a4", l = ("" + (l || "P")).toLowerCase();
    var b, A = ("" + d).toLowerCase(), M = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (o) {
      case "pt":
        b = 1;
        break;
      case "mm":
        b = 72 / 25.4;
        break;
      case "cm":
        b = 72 / 2.54;
        break;
      case "in":
        b = 72;
        break;
      case "px":
        b = 0.75;
        break;
      case "pc":
      case "em":
        b = 12;
        break;
      case "ex":
        b = 6;
        break;
      default:
        throw "Invalid unit: " + o;
    }
    var E, k = 0, U = 0;
    if (M.hasOwnProperty(A)) k = M[A][1] / b, U = M[A][0] / b;
    else try {
      k = d[1], U = d[0];
    } catch {
      throw new Error("Invalid format: " + d);
    }
    if (l === "p" || l === "portrait") l = "p", U > k && (E = U, U = k, k = E);
    else {
      if (l !== "l" && l !== "landscape") throw "Invalid orientation: " + l;
      l = "l", k > U && (E = U, U = k, k = E);
    }
    return { width: U, height: k, unit: o, k: b, orientation: l };
  }, r.html = function(l, o) {
    (o = o || {}).callback = o.callback || function() {
    }, o.html2canvas = o.html2canvas || {}, o.html2canvas.canvas = o.html2canvas.canvas || this.canvas, o.jsPDF = o.jsPDF || this, o.fontFaces = o.fontFaces ? o.fontFaces.map(Wv) : null;
    var d = new s(o);
    return o.worker ? d : d.from(l).doCallback();
  };
}(rn.API), rn.API.addJS = function(r) {
  return QS = r, this.internal.events.subscribe("postPutResources", function() {
    t_ = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (t_ + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), JS = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + QS + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    t_ !== void 0 && JS !== void 0 && this.internal.out("/Names <</JavaScript " + t_ + " 0 R>>");
  }), this;
}, /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  var e;
  r.events.push(["postPutResources", function() {
    var t = this, n = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0) for (var i = t.outline.render().split(/\r\n/), s = 0; s < i.length; s++) {
      var l = i[s], o = n.exec(l);
      if (o != null) {
        var d = o[1];
        t.internal.newObjectDeferredBegin(d, !1);
      }
      t.internal.write(l);
    }
    if (this.outline.createNamedDestinations) {
      var m = this.internal.pages.length, b = [];
      for (s = 0; s < m; s++) {
        var A = t.internal.newObject();
        b.push(A);
        var M = t.internal.getPageInfo(s + 1);
        t.internal.write("<< /D[" + M.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var E = t.internal.newObject();
      for (t.internal.write("<< /Names [ "), s = 0; s < b.length; s++) t.internal.write("(page_" + (s + 1) + ")" + b[s] + " 0 R");
      t.internal.write(" ] >>", "endobj"), e = t.internal.newObject(), t.internal.write("<< /Dests " + E + " 0 R"), t.internal.write(">>", "endobj");
    }
  }]), r.events.push(["putCatalog", function() {
    this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + e + " 0 R"));
  }]), r.events.push(["initialized", function() {
    var t = this;
    t.outline = { createNamedDestinations: !1, root: { children: [] } }, t.outline.add = function(n, i, s) {
      var l = { title: i, options: s, children: [] };
      return n == null && (n = this.root), n.children.push(l), l;
    }, t.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = t, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, t.outline.genIds_r = function(n) {
      n.id = t.internal.newObjectDeferred();
      for (var i = 0; i < n.children.length; i++) this.genIds_r(n.children[i]);
    }, t.outline.renderRoot = function(n) {
      this.objStart(n), this.line("/Type /Outlines"), n.children.length > 0 && (this.line("/First " + this.makeRef(n.children[0])), this.line("/Last " + this.makeRef(n.children[n.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, n)), this.objEnd();
    }, t.outline.renderItems = function(n) {
      for (var i = this.ctx.pdf.internal.getVerticalCoordinateString, s = 0; s < n.children.length; s++) {
        var l = n.children[s];
        this.objStart(l), this.line("/Title " + this.makeString(l.title)), this.line("/Parent " + this.makeRef(n)), s > 0 && this.line("/Prev " + this.makeRef(n.children[s - 1])), s < n.children.length - 1 && this.line("/Next " + this.makeRef(n.children[s + 1])), l.children.length > 0 && (this.line("/First " + this.makeRef(l.children[0])), this.line("/Last " + this.makeRef(l.children[l.children.length - 1])));
        var o = this.count = this.count_r({ count: 0 }, l);
        if (o > 0 && this.line("/Count " + o), l.options && l.options.pageNumber) {
          var d = t.internal.getPageInfo(l.options.pageNumber);
          this.line("/Dest [" + d.objId + " 0 R /XYZ 0 " + i(0) + " 0]");
        }
        this.objEnd();
      }
      for (var m = 0; m < n.children.length; m++) this.renderItems(n.children[m]);
    }, t.outline.line = function(n) {
      this.ctx.val += n + `\r
`;
    }, t.outline.makeRef = function(n) {
      return n.id + " 0 R";
    }, t.outline.makeString = function(n) {
      return "(" + t.internal.pdfEscape(n) + ")";
    }, t.outline.objStart = function(n) {
      this.ctx.val += `\r
` + n.id + ` 0 obj\r
<<\r
`;
    }, t.outline.objEnd = function() {
      this.ctx.val += `>> \r
endobj\r
`;
    }, t.outline.count_r = function(n, i) {
      for (var s = 0; s < i.children.length; s++) n.count++, this.count_r(n, i.children[s]);
      return n.count;
    };
  }]);
}(rn.API), /**
* @license
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  var e = [192, 193, 194, 195, 196, 197, 198, 199];
  r.processJPEG = function(t, n, i, s, l, o) {
    var d, m = this.decode.DCT_DECODE, b = null;
    if (typeof t == "string" || this.__addimage__.isArrayBuffer(t) || this.__addimage__.isArrayBufferView(t)) {
      switch (t = l || t, t = this.__addimage__.isArrayBuffer(t) ? new Uint8Array(t) : t, (d = function(A) {
        for (var M, E = 256 * A.charCodeAt(4) + A.charCodeAt(5), k = A.length, U = { width: 0, height: 0, numcomponents: 1 }, V = 4; V < k; V += 2) {
          if (V += E, e.indexOf(A.charCodeAt(V + 1)) !== -1) {
            M = 256 * A.charCodeAt(V + 5) + A.charCodeAt(V + 6), U = { width: 256 * A.charCodeAt(V + 7) + A.charCodeAt(V + 8), height: M, numcomponents: A.charCodeAt(V + 9) };
            break;
          }
          E = 256 * A.charCodeAt(V + 2) + A.charCodeAt(V + 3);
        }
        return U;
      }(t = this.__addimage__.isArrayBufferView(t) ? this.__addimage__.arrayBufferToBinaryString(t) : t)).numcomponents) {
        case 1:
          o = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          o = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          o = this.color_spaces.DEVICE_RGB;
      }
      b = { data: t, width: d.width, height: d.height, colorSpace: o, bitsPerComponent: 8, filter: m, index: n, alias: i };
    }
    return b;
  };
}(rn.API);
var Pd, r_, tE, rE, nE, TZ = function() {
  var r, e, t;
  function n(s) {
    var l, o, d, m, b, A, M, E, k, U, V, q, Y, re;
    for (this.data = s, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, A = null; ; ) {
      switch (l = this.readUInt32(), k = (function() {
        var Z, K;
        for (K = [], Z = 0; Z < 4; ++Z) K.push(String.fromCharCode(this.data[this.pos++]));
        return K;
      }).call(this).join("")) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(l);
          break;
        case "fcTL":
          A && this.animation.frames.push(A), this.pos += 4, A = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, b = this.readUInt16(), m = this.readUInt16() || 100, A.delay = 1e3 * b / m, A.disposeOp = this.data[this.pos++], A.blendOp = this.data[this.pos++], A.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for (k === "fdAT" && (this.pos += 4, l -= 4), s = (A != null ? A.data : void 0) || this.imgData, q = 0; 0 <= l ? q < l : q > l; 0 <= l ? ++q : --q) s.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (d = this.palette.length / 3, this.transparency.indexed = this.read(l), this.transparency.indexed.length > d) throw new Error("More transparent colors than palette size");
              if ((U = d - this.transparency.indexed.length) > 0) for (Y = 0; 0 <= U ? Y < U : Y > U; 0 <= U ? ++Y : --Y) this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(l)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(l);
          }
          break;
        case "tEXt":
          M = (V = this.read(l)).indexOf(0), E = String.fromCharCode.apply(String, V.slice(0, M)), this.text[E] = String.fromCharCode.apply(String, V.slice(M + 1));
          break;
        case "IEND":
          return A && this.animation.frames.push(A), this.colors = (function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }).call(this), this.hasAlphaChannel = (re = this.colorType) === 4 || re === 6, o = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * o, this.colorSpace = (function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }).call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += l;
      }
      if (this.pos += 4, this.pos > this.data.length) throw new Error("Incomplete or corrupt PNG file");
    }
  }
  n.prototype.read = function(s) {
    var l, o;
    for (o = [], l = 0; 0 <= s ? l < s : l > s; 0 <= s ? ++l : --l) o.push(this.data[this.pos++]);
    return o;
  }, n.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, n.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, n.prototype.decodePixels = function(s) {
    var l = this.pixelBitlength / 8, o = new Uint8Array(this.width * this.height * l), d = 0, m = this;
    if (s == null && (s = this.imgData), s.length === 0) return new Uint8Array(0);
    function b(A, M, E, k) {
      var U, V, q, Y, re, Z, K, ie, be, he, Be, ke, pe, me, je, Pe, St, Mt, Lt, xt, zt, Dt = Math.ceil((m.width - A) / E), hr = Math.ceil((m.height - M) / k), ce = m.width == Dt && m.height == hr;
      for (me = l * Dt, ke = ce ? o : new Uint8Array(me * hr), Z = s.length, pe = 0, V = 0; pe < hr && d < Z; ) {
        switch (s[d++]) {
          case 0:
            for (Y = St = 0; St < me; Y = St += 1) ke[V++] = s[d++];
            break;
          case 1:
            for (Y = Mt = 0; Mt < me; Y = Mt += 1) U = s[d++], re = Y < l ? 0 : ke[V - l], ke[V++] = (U + re) % 256;
            break;
          case 2:
            for (Y = Lt = 0; Lt < me; Y = Lt += 1) U = s[d++], q = (Y - Y % l) / l, je = pe && ke[(pe - 1) * me + q * l + Y % l], ke[V++] = (je + U) % 256;
            break;
          case 3:
            for (Y = xt = 0; xt < me; Y = xt += 1) U = s[d++], q = (Y - Y % l) / l, re = Y < l ? 0 : ke[V - l], je = pe && ke[(pe - 1) * me + q * l + Y % l], ke[V++] = (U + Math.floor((re + je) / 2)) % 256;
            break;
          case 4:
            for (Y = zt = 0; zt < me; Y = zt += 1) U = s[d++], q = (Y - Y % l) / l, re = Y < l ? 0 : ke[V - l], pe === 0 ? je = Pe = 0 : (je = ke[(pe - 1) * me + q * l + Y % l], Pe = q && ke[(pe - 1) * me + (q - 1) * l + Y % l]), K = re + je - Pe, ie = Math.abs(K - re), he = Math.abs(K - je), Be = Math.abs(K - Pe), be = ie <= he && ie <= Be ? re : he <= Be ? je : Pe, ke[V++] = (U + be) % 256;
            break;
          default:
            throw new Error("Invalid filter algorithm: " + s[d - 1]);
        }
        if (!ce) {
          var Oe = ((M + pe * k) * m.width + A) * l, $e = pe * me;
          for (Y = 0; Y < Dt; Y += 1) {
            for (var et = 0; et < l; et += 1) o[Oe++] = ke[$e++];
            Oe += (E - 1) * l;
          }
        }
        pe++;
      }
    }
    return s = rZ(s), m.interlaceMethod == 1 ? (b(0, 0, 8, 8), b(4, 0, 8, 8), b(0, 4, 4, 8), b(2, 0, 4, 4), b(0, 2, 2, 4), b(1, 0, 2, 2), b(0, 1, 1, 2)) : b(0, 0, 1, 1), o;
  }, n.prototype.decodePalette = function() {
    var s, l, o, d, m, b, A, M, E;
    for (o = this.palette, b = this.transparency.indexed || [], m = new Uint8Array((b.length || 0) + o.length), d = 0, s = 0, l = A = 0, M = o.length; A < M; l = A += 3) m[d++] = o[l], m[d++] = o[l + 1], m[d++] = o[l + 2], m[d++] = (E = b[s++]) != null ? E : 255;
    return m;
  }, n.prototype.copyToImageData = function(s, l) {
    var o, d, m, b, A, M, E, k, U, V, q;
    if (d = this.colors, U = null, o = this.hasAlphaChannel, this.palette.length && (U = (q = this._decodedPalette) != null ? q : this._decodedPalette = this.decodePalette(), d = 4, o = !0), k = (m = s.data || s).length, A = U || l, b = M = 0, d === 1) for (; b < k; ) E = U ? 4 * l[b / 4] : M, V = A[E++], m[b++] = V, m[b++] = V, m[b++] = V, m[b++] = o ? A[E++] : 255, M = E;
    else for (; b < k; ) E = U ? 4 * l[b / 4] : M, m[b++] = A[E++], m[b++] = A[E++], m[b++] = A[E++], m[b++] = o ? A[E++] : 255, M = E;
  }, n.prototype.decode = function() {
    var s;
    return s = new Uint8Array(this.width * this.height * 4), this.copyToImageData(s, this.decodePixels()), s;
  };
  var i = function() {
    if (Object.prototype.toString.call(on) === "[object Window]") {
      try {
        e = on.document.createElement("canvas"), t = e.getContext("2d");
      } catch {
        return !1;
      }
      return !0;
    }
    return !1;
  };
  return i(), r = function(s) {
    var l;
    if (i() === !0) return t.width = s.width, t.height = s.height, t.clearRect(0, 0, s.width, s.height), t.putImageData(s, 0, 0), (l = new Image()).src = e.toDataURL(), l;
    throw new Error("This method requires a Browser with Canvas-capability.");
  }, n.prototype.decodeFrames = function(s) {
    var l, o, d, m, b, A, M, E;
    if (this.animation) {
      for (E = [], o = b = 0, A = (M = this.animation.frames).length; b < A; o = ++b) l = M[o], d = s.createImageData(l.width, l.height), m = this.decodePixels(new Uint8Array(l.data)), this.copyToImageData(d, m), l.imageData = d, E.push(l.image = r(d));
      return E;
    }
  }, n.prototype.renderFrame = function(s, l) {
    var o, d, m;
    return o = (d = this.animation.frames)[l], m = d[l - 1], l === 0 && s.clearRect(0, 0, this.width, this.height), (m != null ? m.disposeOp : void 0) === 1 ? s.clearRect(m.xOffset, m.yOffset, m.width, m.height) : (m != null ? m.disposeOp : void 0) === 2 && s.putImageData(m.imageData, m.xOffset, m.yOffset), o.blendOp === 0 && s.clearRect(o.xOffset, o.yOffset, o.width, o.height), s.drawImage(o.image, o.xOffset, o.yOffset);
  }, n.prototype.animate = function(s) {
    var l, o, d, m, b, A, M = this;
    return o = 0, A = this.animation, m = A.numFrames, d = A.frames, b = A.numPlays, (l = function() {
      var E, k;
      if (E = o++ % m, k = d[E], M.renderFrame(s, E), m > 1 && o / m < b) return M.animation._timeout = setTimeout(l, k.delay);
    })();
  }, n.prototype.stopAnimation = function() {
    var s;
    return clearTimeout((s = this.animation) != null ? s._timeout : void 0);
  }, n.prototype.render = function(s) {
    var l, o;
    return s._png && s._png.stopAnimation(), s._png = this, s.width = this.width, s.height = this.height, l = s.getContext("2d"), this.animation ? (this.decodeFrames(l), this.animate(l)) : (o = l.createImageData(this.width, this.height), this.copyToImageData(o, this.decodePixels()), l.putImageData(o, 0, 0));
  }, n;
}();
/**
* @license
*
* Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
/**
* @license
* (c) Dean McNamee <dean@gmail.com>, 2013.
*
* https://github.com/deanm/omggif
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*
* omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
* including animation and compression.  It does not rely on any specific
* underlying system, so should run in the browser, Node, or Plask.
*/
function SZ(r) {
  var e = 0;
  if (r[e++] !== 71 || r[e++] !== 73 || r[e++] !== 70 || r[e++] !== 56 || (r[e++] + 1 & 253) != 56 || r[e++] !== 97) throw new Error("Invalid GIF 87a/89a header.");
  var t = r[e++] | r[e++] << 8, n = r[e++] | r[e++] << 8, i = r[e++], s = i >> 7, l = 1 << (7 & i) + 1;
  r[e++], r[e++];
  var o = null, d = null;
  s && (o = e, d = l, e += 3 * l);
  var m = !0, b = [], A = 0, M = null, E = 0, k = null;
  for (this.width = t, this.height = n; m && e < r.length; ) switch (r[e++]) {
    case 33:
      switch (r[e++]) {
        case 255:
          if (r[e] !== 11 || r[e + 1] == 78 && r[e + 2] == 69 && r[e + 3] == 84 && r[e + 4] == 83 && r[e + 5] == 67 && r[e + 6] == 65 && r[e + 7] == 80 && r[e + 8] == 69 && r[e + 9] == 50 && r[e + 10] == 46 && r[e + 11] == 48 && r[e + 12] == 3 && r[e + 13] == 1 && r[e + 16] == 0) e += 14, k = r[e++] | r[e++] << 8, e++;
          else for (e += 12; ; ) {
            if (!((pe = r[e++]) >= 0)) throw Error("Invalid block size");
            if (pe === 0) break;
            e += pe;
          }
          break;
        case 249:
          if (r[e++] !== 4 || r[e + 4] !== 0) throw new Error("Invalid graphics extension block.");
          var U = r[e++];
          A = r[e++] | r[e++] << 8, M = r[e++], (1 & U) == 0 && (M = null), E = U >> 2 & 7, e++;
          break;
        case 254:
          for (; ; ) {
            if (!((pe = r[e++]) >= 0)) throw Error("Invalid block size");
            if (pe === 0) break;
            e += pe;
          }
          break;
        default:
          throw new Error("Unknown graphic control label: 0x" + r[e - 1].toString(16));
      }
      break;
    case 44:
      var V = r[e++] | r[e++] << 8, q = r[e++] | r[e++] << 8, Y = r[e++] | r[e++] << 8, re = r[e++] | r[e++] << 8, Z = r[e++], K = Z >> 6 & 1, ie = 1 << (7 & Z) + 1, be = o, he = d, Be = !1;
      Z >> 7 && (Be = !0, be = e, he = ie, e += 3 * ie);
      var ke = e;
      for (e++; ; ) {
        var pe;
        if (!((pe = r[e++]) >= 0)) throw Error("Invalid block size");
        if (pe === 0) break;
        e += pe;
      }
      b.push({ x: V, y: q, width: Y, height: re, has_local_palette: Be, palette_offset: be, palette_size: he, data_offset: ke, data_length: e - ke, transparent_index: M, interlaced: !!K, delay: A, disposal: E });
      break;
    case 59:
      m = !1;
      break;
    default:
      throw new Error("Unknown gif block: 0x" + r[e - 1].toString(16));
  }
  this.numFrames = function() {
    return b.length;
  }, this.loopCount = function() {
    return k;
  }, this.frameInfo = function(me) {
    if (me < 0 || me >= b.length) throw new Error("Frame index out of range.");
    return b[me];
  }, this.decodeAndBlitFrameBGRA = function(me, je) {
    var Pe = this.frameInfo(me), St = Pe.width * Pe.height, Mt = new Uint8Array(St);
    iE(r, Pe.data_offset, Mt, St);
    var Lt = Pe.palette_offset, xt = Pe.transparent_index;
    xt === null && (xt = 256);
    var zt = Pe.width, Dt = t - zt, hr = zt, ce = 4 * (Pe.y * t + Pe.x), Oe = 4 * ((Pe.y + Pe.height) * t + Pe.x), $e = ce, et = 4 * Dt;
    Pe.interlaced === !0 && (et += 4 * t * 7);
    for (var ot = 8, ht = 0, It = Mt.length; ht < It; ++ht) {
      var yt = Mt[ht];
      if (hr === 0 && (hr = zt, ($e += et) >= Oe && (et = 4 * Dt + 4 * t * (ot - 1), $e = ce + (zt + Dt) * (ot << 1), ot >>= 1)), yt === xt) $e += 4;
      else {
        var ar = r[Lt + 3 * yt], Kt = r[Lt + 3 * yt + 1], vr = r[Lt + 3 * yt + 2];
        je[$e++] = vr, je[$e++] = Kt, je[$e++] = ar, je[$e++] = 255;
      }
      --hr;
    }
  }, this.decodeAndBlitFrameRGBA = function(me, je) {
    var Pe = this.frameInfo(me), St = Pe.width * Pe.height, Mt = new Uint8Array(St);
    iE(r, Pe.data_offset, Mt, St);
    var Lt = Pe.palette_offset, xt = Pe.transparent_index;
    xt === null && (xt = 256);
    var zt = Pe.width, Dt = t - zt, hr = zt, ce = 4 * (Pe.y * t + Pe.x), Oe = 4 * ((Pe.y + Pe.height) * t + Pe.x), $e = ce, et = 4 * Dt;
    Pe.interlaced === !0 && (et += 4 * t * 7);
    for (var ot = 8, ht = 0, It = Mt.length; ht < It; ++ht) {
      var yt = Mt[ht];
      if (hr === 0 && (hr = zt, ($e += et) >= Oe && (et = 4 * Dt + 4 * t * (ot - 1), $e = ce + (zt + Dt) * (ot << 1), ot >>= 1)), yt === xt) $e += 4;
      else {
        var ar = r[Lt + 3 * yt], Kt = r[Lt + 3 * yt + 1], vr = r[Lt + 3 * yt + 2];
        je[$e++] = ar, je[$e++] = Kt, je[$e++] = vr, je[$e++] = 255;
      }
      --hr;
    }
  };
}
function iE(r, e, t, n) {
  for (var i = r[e++], s = 1 << i, l = s + 1, o = l + 1, d = i + 1, m = (1 << d) - 1, b = 0, A = 0, M = 0, E = r[e++], k = new Int32Array(4096), U = null; ; ) {
    for (; b < 16 && E !== 0; ) A |= r[e++] << b, b += 8, E === 1 ? E = r[e++] : --E;
    if (b < d) break;
    var V = A & m;
    if (A >>= d, b -= d, V !== s) {
      if (V === l) break;
      for (var q = V < o ? V : U, Y = 0, re = q; re > s; ) re = k[re] >> 8, ++Y;
      var Z = re;
      if (M + Y + (q !== V ? 1 : 0) > n) return void Ii.log("Warning, gif stream longer than expected.");
      t[M++] = Z;
      var K = M += Y;
      for (q !== V && (t[M++] = Z), re = q; Y--; ) re = k[re], t[--K] = 255 & re, re >>= 8;
      U !== null && o < 4096 && (k[o++] = U << 8 | Z, o >= m + 1 && d < 12 && (++d, m = m << 1 | 1)), U = V;
    } else o = l + 1, m = (1 << (d = i + 1)) - 1, U = null;
  }
  return M !== n && Ii.log("Warning, gif stream shorter than expected."), t;
}
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function p1(r) {
  var e, t, n, i, s, l = Math.floor, o = new Array(64), d = new Array(64), m = new Array(64), b = new Array(64), A = new Array(65535), M = new Array(65535), E = new Array(64), k = new Array(64), U = [], V = 0, q = 7, Y = new Array(64), re = new Array(64), Z = new Array(64), K = new Array(256), ie = new Array(2048), be = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], he = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], Be = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], ke = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], pe = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], me = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], je = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], Pe = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], St = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function Mt(ce, Oe) {
    for (var $e = 0, et = 0, ot = new Array(), ht = 1; ht <= 16; ht++) {
      for (var It = 1; It <= ce[ht]; It++) ot[Oe[et]] = [], ot[Oe[et]][0] = $e, ot[Oe[et]][1] = ht, et++, $e++;
      $e *= 2;
    }
    return ot;
  }
  function Lt(ce) {
    for (var Oe = ce[0], $e = ce[1] - 1; $e >= 0; ) Oe & 1 << $e && (V |= 1 << q), $e--, --q < 0 && (V == 255 ? (xt(255), xt(0)) : xt(V), q = 7, V = 0);
  }
  function xt(ce) {
    U.push(ce);
  }
  function zt(ce) {
    xt(ce >> 8 & 255), xt(255 & ce);
  }
  function Dt(ce, Oe, $e, et, ot) {
    for (var ht, It = ot[0], yt = ot[240], ar = function(Yt, pr) {
      var mr, _r, Lr, qr, Kr, en, nn, vn, Hr, fn, gr = 0;
      for (Hr = 0; Hr < 8; ++Hr) {
        mr = Yt[gr], _r = Yt[gr + 1], Lr = Yt[gr + 2], qr = Yt[gr + 3], Kr = Yt[gr + 4], en = Yt[gr + 5], nn = Yt[gr + 6];
        var nt = mr + (vn = Yt[gr + 7]), oe = mr - vn, fe = _r + nn, ye = _r - nn, Le = Lr + en, Ye = Lr - en, Qe = qr + Kr, gt = qr - Kr, Ke = nt + Qe, Bt = nt - Qe, Pt = fe + Le, st = fe - Le;
        Yt[gr] = Ke + Pt, Yt[gr + 4] = Ke - Pt;
        var ft = 0.707106781 * (st + Bt);
        Yt[gr + 2] = Bt + ft, Yt[gr + 6] = Bt - ft;
        var Ge = 0.382683433 * ((Ke = gt + Ye) - (st = ye + oe)), ur = 0.5411961 * Ke + Ge, Sr = 1.306562965 * st + Ge, lr = 0.707106781 * (Pt = Ye + ye), Er = oe + lr, tr = oe - lr;
        Yt[gr + 5] = tr + ur, Yt[gr + 3] = tr - ur, Yt[gr + 1] = Er + Sr, Yt[gr + 7] = Er - Sr, gr += 8;
      }
      for (gr = 0, Hr = 0; Hr < 8; ++Hr) {
        mr = Yt[gr], _r = Yt[gr + 8], Lr = Yt[gr + 16], qr = Yt[gr + 24], Kr = Yt[gr + 32], en = Yt[gr + 40], nn = Yt[gr + 48];
        var xn = mr + (vn = Yt[gr + 56]), dn = mr - vn, Jr = _r + nn, Cr = _r - nn, zr = Lr + en, Dn = Lr - en, er = qr + Kr, oi = qr - Kr, Mn = xn + er, rs = xn - er, _s = Jr + zr, rr = Jr - zr;
        Yt[gr] = Mn + _s, Yt[gr + 32] = Mn - _s;
        var Vr = 0.707106781 * (rr + rs);
        Yt[gr + 16] = rs + Vr, Yt[gr + 48] = rs - Vr;
        var Gr = 0.382683433 * ((Mn = oi + Dn) - (rr = Cr + dn)), Hi = 0.5411961 * Mn + Gr, Ga = 1.306562965 * rr + Gr, Vs = 0.707106781 * (_s = Dn + Cr), Xr = dn + Vs, io = dn - Vs;
        Yt[gr + 40] = io + Hi, Yt[gr + 24] = io - Hi, Yt[gr + 8] = Xr + Ga, Yt[gr + 56] = Xr - Ga, gr++;
      }
      for (Hr = 0; Hr < 64; ++Hr) fn = Yt[Hr] * pr[Hr], E[Hr] = fn > 0 ? fn + 0.5 | 0 : fn - 0.5 | 0;
      return E;
    }(ce, Oe), Kt = 0; Kt < 64; ++Kt) k[be[Kt]] = ar[Kt];
    var vr = k[0] - $e;
    $e = k[0], vr == 0 ? Lt(et[0]) : (Lt(et[M[ht = 32767 + vr]]), Lt(A[ht]));
    for (var sr = 63; sr > 0 && k[sr] == 0; ) sr--;
    if (sr == 0) return Lt(It), $e;
    for (var Ur, Nt = 1; Nt <= sr; ) {
      for (var We = Nt; k[Nt] == 0 && Nt <= sr; ) ++Nt;
      var Dr = Nt - We;
      if (Dr >= 16) {
        Ur = Dr >> 4;
        for (var Tr = 1; Tr <= Ur; ++Tr) Lt(yt);
        Dr &= 15;
      }
      ht = 32767 + k[Nt], Lt(ot[(Dr << 4) + M[ht]]), Lt(A[ht]), Nt++;
    }
    return sr != 63 && Lt(It), $e;
  }
  function hr(ce) {
    ce = Math.min(Math.max(ce, 1), 100), s != ce && (function(Oe) {
      for (var $e = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], et = 0; et < 64; et++) {
        var ot = l(($e[et] * Oe + 50) / 100);
        ot = Math.min(Math.max(ot, 1), 255), o[be[et]] = ot;
      }
      for (var ht = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], It = 0; It < 64; It++) {
        var yt = l((ht[It] * Oe + 50) / 100);
        yt = Math.min(Math.max(yt, 1), 255), d[be[It]] = yt;
      }
      for (var ar = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], Kt = 0, vr = 0; vr < 8; vr++) for (var sr = 0; sr < 8; sr++) m[Kt] = 1 / (o[be[Kt]] * ar[vr] * ar[sr] * 8), b[Kt] = 1 / (d[be[Kt]] * ar[vr] * ar[sr] * 8), Kt++;
    }(ce < 50 ? Math.floor(5e3 / ce) : Math.floor(200 - 2 * ce)), s = ce);
  }
  this.encode = function(ce, Oe) {
    Oe && hr(Oe), U = new Array(), V = 0, q = 7, zt(65496), zt(65504), zt(16), xt(74), xt(70), xt(73), xt(70), xt(0), xt(1), xt(1), xt(0), zt(1), zt(1), xt(0), xt(0), function() {
      zt(65499), zt(132), xt(0);
      for (var _r = 0; _r < 64; _r++) xt(o[_r]);
      xt(1);
      for (var Lr = 0; Lr < 64; Lr++) xt(d[Lr]);
    }(), function(_r, Lr) {
      zt(65472), zt(17), xt(8), zt(Lr), zt(_r), xt(3), xt(1), xt(17), xt(0), xt(2), xt(17), xt(1), xt(3), xt(17), xt(1);
    }(ce.width, ce.height), function() {
      zt(65476), zt(418), xt(0);
      for (var _r = 0; _r < 16; _r++) xt(he[_r + 1]);
      for (var Lr = 0; Lr <= 11; Lr++) xt(Be[Lr]);
      xt(16);
      for (var qr = 0; qr < 16; qr++) xt(ke[qr + 1]);
      for (var Kr = 0; Kr <= 161; Kr++) xt(pe[Kr]);
      xt(1);
      for (var en = 0; en < 16; en++) xt(me[en + 1]);
      for (var nn = 0; nn <= 11; nn++) xt(je[nn]);
      xt(17);
      for (var vn = 0; vn < 16; vn++) xt(Pe[vn + 1]);
      for (var Hr = 0; Hr <= 161; Hr++) xt(St[Hr]);
    }(), zt(65498), zt(12), xt(3), xt(1), xt(0), xt(2), xt(17), xt(3), xt(17), xt(0), xt(63), xt(0);
    var $e = 0, et = 0, ot = 0;
    V = 0, q = 7, this.encode.displayName = "_encode_";
    for (var ht, It, yt, ar, Kt, vr, sr, Ur, Nt, We = ce.data, Dr = ce.width, Tr = ce.height, Yt = 4 * Dr, pr = 0; pr < Tr; ) {
      for (ht = 0; ht < Yt; ) {
        for (Kt = Yt * pr + ht, sr = -1, Ur = 0, Nt = 0; Nt < 64; Nt++) vr = Kt + (Ur = Nt >> 3) * Yt + (sr = 4 * (7 & Nt)), pr + Ur >= Tr && (vr -= Yt * (pr + 1 + Ur - Tr)), ht + sr >= Yt && (vr -= ht + sr - Yt + 4), It = We[vr++], yt = We[vr++], ar = We[vr++], Y[Nt] = (ie[It] + ie[yt + 256 >> 0] + ie[ar + 512 >> 0] >> 16) - 128, re[Nt] = (ie[It + 768 >> 0] + ie[yt + 1024 >> 0] + ie[ar + 1280 >> 0] >> 16) - 128, Z[Nt] = (ie[It + 1280 >> 0] + ie[yt + 1536 >> 0] + ie[ar + 1792 >> 0] >> 16) - 128;
        $e = Dt(Y, m, $e, e, n), et = Dt(re, b, et, t, i), ot = Dt(Z, b, ot, t, i), ht += 32;
      }
      pr += 8;
    }
    if (q >= 0) {
      var mr = [];
      mr[1] = q + 1, mr[0] = (1 << q + 1) - 1, Lt(mr);
    }
    return zt(65497), new Uint8Array(U);
  }, r = r || 50, function() {
    for (var ce = String.fromCharCode, Oe = 0; Oe < 256; Oe++) K[Oe] = ce(Oe);
  }(), e = Mt(he, Be), t = Mt(me, je), n = Mt(ke, pe), i = Mt(Pe, St), function() {
    for (var ce = 1, Oe = 2, $e = 1; $e <= 15; $e++) {
      for (var et = ce; et < Oe; et++) M[32767 + et] = $e, A[32767 + et] = [], A[32767 + et][1] = $e, A[32767 + et][0] = et;
      for (var ot = -(Oe - 1); ot <= -ce; ot++) M[32767 + ot] = $e, A[32767 + ot] = [], A[32767 + ot][1] = $e, A[32767 + ot][0] = Oe - 1 + ot;
      ce <<= 1, Oe <<= 1;
    }
  }(), function() {
    for (var ce = 0; ce < 256; ce++) ie[ce] = 19595 * ce, ie[ce + 256 >> 0] = 38470 * ce, ie[ce + 512 >> 0] = 7471 * ce + 32768, ie[ce + 768 >> 0] = -11059 * ce, ie[ce + 1024 >> 0] = -21709 * ce, ie[ce + 1280 >> 0] = 32768 * ce + 8421375, ie[ce + 1536 >> 0] = -27439 * ce, ie[ce + 1792 >> 0] = -5329 * ce;
  }(), hr(r);
}
/**
* @license
* Copyright (c) 2017 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function mc(r, e) {
  if (this.pos = 0, this.buffer = r, this.datav = new DataView(r.buffer), this.is_with_alpha = !!e, this.bottom_up = !0, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag) === -1) throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function sE(r) {
  function e(he) {
    if (!he) throw Error("assert :P");
  }
  function t(he, Be, ke) {
    for (var pe = 0; 4 > pe; pe++) if (he[Be + pe] != ke.charCodeAt(pe)) return !0;
    return !1;
  }
  function n(he, Be, ke, pe, me) {
    for (var je = 0; je < me; je++) he[Be + je] = ke[pe + je];
  }
  function i(he, Be, ke, pe) {
    for (var me = 0; me < pe; me++) he[Be + me] = ke;
  }
  function s(he) {
    return new Int32Array(he);
  }
  function l(he, Be) {
    for (var ke = [], pe = 0; pe < he; pe++) ke.push(new Be());
    return ke;
  }
  function o(he, Be) {
    var ke = [];
    return function pe(me, je, Pe) {
      for (var St = Pe[je], Mt = 0; Mt < St && (me.push(Pe.length > je + 1 ? [] : new Be()), !(Pe.length < je + 1)); Mt++) pe(me[Mt], je + 1, Pe);
    }(ke, 0, he), ke;
  }
  var d = function() {
    var he = this;
    function Be(S, R) {
      for (var D = 1 << R - 1 >>> 0; S & D; ) D >>>= 1;
      return D ? (S & D - 1) + D : S;
    }
    function ke(S, R, D, W, se) {
      e(!(W % D));
      do
        S[R + (W -= D)] = se;
      while (0 < W);
    }
    function pe(S, R, D, W, se) {
      if (e(2328 >= se), 512 >= se) var de = s(512);
      else if ((de = s(se)) == null) return 0;
      return function(ge, _e, xe, Ie, Re, At) {
        var vt, at, Gt = _e, kt = 1 << xe, rt = s(16), Xe = s(16);
        for (e(Re != 0), e(Ie != null), e(ge != null), e(0 < xe), at = 0; at < Re; ++at) {
          if (15 < Ie[at]) return 0;
          ++rt[Ie[at]];
        }
        if (rt[0] == Re) return 0;
        for (Xe[1] = 0, vt = 1; 15 > vt; ++vt) {
          if (rt[vt] > 1 << vt) return 0;
          Xe[vt + 1] = Xe[vt] + rt[vt];
        }
        for (at = 0; at < Re; ++at) vt = Ie[at], 0 < Ie[at] && (At[Xe[vt]++] = at);
        if (Xe[15] == 1) return (Ie = new me()).g = 0, Ie.value = At[0], ke(ge, Gt, 1, kt, Ie), kt;
        var qt, Zt = -1, Ht = kt - 1, Mr = 0, yr = 1, $r = 1, br = 1 << xe;
        for (at = 0, vt = 1, Re = 2; vt <= xe; ++vt, Re <<= 1) {
          if (yr += $r <<= 1, 0 > ($r -= rt[vt])) return 0;
          for (; 0 < rt[vt]; --rt[vt]) (Ie = new me()).g = vt, Ie.value = At[at++], ke(ge, Gt + Mr, Re, br, Ie), Mr = Be(Mr, vt);
        }
        for (vt = xe + 1, Re = 2; 15 >= vt; ++vt, Re <<= 1) {
          if (yr += $r <<= 1, 0 > ($r -= rt[vt])) return 0;
          for (; 0 < rt[vt]; --rt[vt]) {
            if (Ie = new me(), (Mr & Ht) != Zt) {
              for (Gt += br, qt = 1 << (Zt = vt) - xe; 15 > Zt && !(0 >= (qt -= rt[Zt])); ) ++Zt, qt <<= 1;
              kt += br = 1 << (qt = Zt - xe), ge[_e + (Zt = Mr & Ht)].g = qt + xe, ge[_e + Zt].value = Gt - _e - Zt;
            }
            Ie.g = vt - xe, Ie.value = At[at++], ke(ge, Gt + (Mr >> xe), Re, br, Ie), Mr = Be(Mr, vt);
          }
        }
        return yr != 2 * Xe[15] - 1 ? 0 : kt;
      }(S, R, D, W, se, de);
    }
    function me() {
      this.value = this.g = 0;
    }
    function je() {
      this.value = this.g = 0;
    }
    function Pe() {
      this.G = l(5, me), this.H = s(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = l(Zi, je);
    }
    function St(S, R, D, W) {
      e(S != null), e(R != null), e(2147483648 > W), S.Ca = 254, S.I = 0, S.b = -8, S.Ka = 0, S.oa = R, S.pa = D, S.Jd = R, S.Yc = D + W, S.Zc = 4 <= W ? D + W - 4 + 1 : D, ht(S);
    }
    function Mt(S, R) {
      for (var D = 0; 0 < R--; ) D |= yt(S, 128) << R;
      return D;
    }
    function Lt(S, R) {
      var D = Mt(S, R);
      return It(S) ? -D : D;
    }
    function xt(S, R, D, W) {
      var se, de = 0;
      for (e(S != null), e(R != null), e(4294967288 > W), S.Sb = W, S.Ra = 0, S.u = 0, S.h = 0, 4 < W && (W = 4), se = 0; se < W; ++se) de += R[D + se] << 8 * se;
      S.Ra = de, S.bb = W, S.oa = R, S.pa = D;
    }
    function zt(S) {
      for (; 8 <= S.u && S.bb < S.Sb; ) S.Ra >>>= 8, S.Ra += S.oa[S.pa + S.bb] << Yl - 8 >>> 0, ++S.bb, S.u -= 8;
      $e(S) && (S.h = 1, S.u = 0);
    }
    function Dt(S, R) {
      if (e(0 <= R), !S.h && R <= Oo) {
        var D = Oe(S) & Sl[R];
        return S.u += R, zt(S), D;
      }
      return S.h = 1, S.u = 0;
    }
    function hr() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function ce() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function Oe(S) {
      return S.Ra >>> (S.u & Yl - 1) >>> 0;
    }
    function $e(S) {
      return e(S.bb <= S.Sb), S.h || S.bb == S.Sb && S.u > Yl;
    }
    function et(S, R) {
      S.u = R, S.h = $e(S);
    }
    function ot(S) {
      S.u >= Kl && (e(S.u >= Kl), zt(S));
    }
    function ht(S) {
      e(S != null && S.oa != null), S.pa < S.Zc ? (S.I = (S.oa[S.pa++] | S.I << 8) >>> 0, S.b += 8) : (e(S != null && S.oa != null), S.pa < S.Yc ? (S.b += 8, S.I = S.oa[S.pa++] | S.I << 8) : S.Ka ? S.b = 0 : (S.I <<= 8, S.b += 8, S.Ka = 1));
    }
    function It(S) {
      return Mt(S, 1);
    }
    function yt(S, R) {
      var D = S.Ca;
      0 > S.b && ht(S);
      var W = S.b, se = D * R >>> 8, de = (S.I >>> W > se) + 0;
      for (de ? (D -= se, S.I -= se + 1 << W >>> 0) : D = se + 1, W = D, se = 0; 256 <= W; ) se += 8, W >>= 8;
      return W = 7 ^ se + Yi[W], S.b -= W, S.Ca = (D << W) - 1, de;
    }
    function ar(S, R, D) {
      S[R + 0] = D >> 24 & 255, S[R + 1] = D >> 16 & 255, S[R + 2] = D >> 8 & 255, S[R + 3] = D >> 0 & 255;
    }
    function Kt(S, R) {
      return S[R + 0] << 0 | S[R + 1] << 8;
    }
    function vr(S, R) {
      return Kt(S, R) | S[R + 2] << 16;
    }
    function sr(S, R) {
      return Kt(S, R) | Kt(S, R + 2) << 16;
    }
    function Ur(S, R) {
      var D = 1 << R;
      return e(S != null), e(0 < R), S.X = s(D), S.X == null ? 0 : (S.Mb = 32 - R, S.Xa = R, 1);
    }
    function Nt(S, R) {
      e(S != null), e(R != null), e(S.Xa == R.Xa), n(R.X, 0, S.X, 0, 1 << R.Xa);
    }
    function We() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function Dr(S, R, D, W) {
      e(D != null), e(W != null);
      var se = D[0], de = W[0];
      return se == 0 && (se = (S * de + R / 2) / R), de == 0 && (de = (R * se + S / 2) / S), 0 >= se || 0 >= de ? 0 : (D[0] = se, W[0] = de, 1);
    }
    function Tr(S, R) {
      return S + (1 << R) - 1 >>> R;
    }
    function Yt(S, R) {
      return ((4278255360 & S) + (4278255360 & R) >>> 0 & 4278255360) + ((16711935 & S) + (16711935 & R) >>> 0 & 16711935) >>> 0;
    }
    function pr(S, R) {
      he[R] = function(D, W, se, de, ge, _e, xe) {
        var Ie;
        for (Ie = 0; Ie < ge; ++Ie) {
          var Re = he[S](_e[xe + Ie - 1], se, de + Ie);
          _e[xe + Ie] = Yt(D[W + Ie], Re);
        }
      };
    }
    function mr() {
      this.ud = this.hd = this.jd = 0;
    }
    function _r(S, R) {
      return ((4278124286 & (S ^ R)) >>> 1) + (S & R) >>> 0;
    }
    function Lr(S) {
      return 0 <= S && 256 > S ? S : 0 > S ? 0 : 255 < S ? 255 : void 0;
    }
    function qr(S, R) {
      return Lr(S + (S - R + 0.5 >> 1));
    }
    function Kr(S, R, D) {
      return Math.abs(R - D) - Math.abs(S - D);
    }
    function en(S, R, D, W, se, de, ge) {
      for (W = de[ge - 1], D = 0; D < se; ++D) de[ge + D] = W = Yt(S[R + D], W);
    }
    function nn(S, R, D, W, se) {
      var de;
      for (de = 0; de < D; ++de) {
        var ge = S[R + de], _e = ge >> 8 & 255, xe = 16711935 & (xe = (xe = 16711935 & ge) + ((_e << 16) + _e));
        W[se + de] = (4278255360 & ge) + xe >>> 0;
      }
    }
    function vn(S, R) {
      R.jd = S >> 0 & 255, R.hd = S >> 8 & 255, R.ud = S >> 16 & 255;
    }
    function Hr(S, R, D, W, se, de) {
      var ge;
      for (ge = 0; ge < W; ++ge) {
        var _e = R[D + ge], xe = _e >>> 8, Ie = _e, Re = 255 & (Re = (Re = _e >>> 16) + ((S.jd << 24 >> 24) * (xe << 24 >> 24) >>> 5));
        Ie = 255 & (Ie = (Ie = Ie + ((S.hd << 24 >> 24) * (xe << 24 >> 24) >>> 5)) + ((S.ud << 24 >> 24) * (Re << 24 >> 24) >>> 5)), se[de + ge] = (4278255360 & _e) + (Re << 16) + Ie;
      }
    }
    function fn(S, R, D, W, se) {
      he[R] = function(de, ge, _e, xe, Ie, Re, At, vt, at) {
        for (xe = At; xe < vt; ++xe) for (At = 0; At < at; ++At) Ie[Re++] = se(_e[W(de[ge++])]);
      }, he[S] = function(de, ge, _e, xe, Ie, Re, At) {
        var vt = 8 >> de.b, at = de.Ea, Gt = de.K[0], kt = de.w;
        if (8 > vt) for (de = (1 << de.b) - 1, kt = (1 << vt) - 1; ge < _e; ++ge) {
          var rt, Xe = 0;
          for (rt = 0; rt < at; ++rt) rt & de || (Xe = W(xe[Ie++])), Re[At++] = se(Gt[Xe & kt]), Xe >>= vt;
        }
        else he["VP8LMapColor" + D](xe, Ie, Gt, kt, Re, At, ge, _e, at);
      };
    }
    function gr(S, R, D, W, se) {
      for (D = R + D; R < D; ) {
        var de = S[R++];
        W[se++] = de >> 16 & 255, W[se++] = de >> 8 & 255, W[se++] = de >> 0 & 255;
      }
    }
    function nt(S, R, D, W, se) {
      for (D = R + D; R < D; ) {
        var de = S[R++];
        W[se++] = de >> 16 & 255, W[se++] = de >> 8 & 255, W[se++] = de >> 0 & 255, W[se++] = de >> 24 & 255;
      }
    }
    function oe(S, R, D, W, se) {
      for (D = R + D; R < D; ) {
        var de = (ge = S[R++]) >> 16 & 240 | ge >> 12 & 15, ge = ge >> 0 & 240 | ge >> 28 & 15;
        W[se++] = de, W[se++] = ge;
      }
    }
    function fe(S, R, D, W, se) {
      for (D = R + D; R < D; ) {
        var de = (ge = S[R++]) >> 16 & 248 | ge >> 13 & 7, ge = ge >> 5 & 224 | ge >> 3 & 31;
        W[se++] = de, W[se++] = ge;
      }
    }
    function ye(S, R, D, W, se) {
      for (D = R + D; R < D; ) {
        var de = S[R++];
        W[se++] = de >> 0 & 255, W[se++] = de >> 8 & 255, W[se++] = de >> 16 & 255;
      }
    }
    function Le(S, R, D, W, se, de) {
      if (de == 0) for (D = R + D; R < D; ) ar(W, ((de = S[R++])[0] >> 24 | de[1] >> 8 & 65280 | de[2] << 8 & 16711680 | de[3] << 24) >>> 0), se += 32;
      else n(W, se, S, R, D);
    }
    function Ye(S, R) {
      he[R][0] = he[S + "0"], he[R][1] = he[S + "1"], he[R][2] = he[S + "2"], he[R][3] = he[S + "3"], he[R][4] = he[S + "4"], he[R][5] = he[S + "5"], he[R][6] = he[S + "6"], he[R][7] = he[S + "7"], he[R][8] = he[S + "8"], he[R][9] = he[S + "9"], he[R][10] = he[S + "10"], he[R][11] = he[S + "11"], he[R][12] = he[S + "12"], he[R][13] = he[S + "13"], he[R][14] = he[S + "0"], he[R][15] = he[S + "0"];
    }
    function Qe(S) {
      return S == Qh || S == uh || S == ku || S == Hc;
    }
    function gt() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function Ke() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function Bt() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new gt(), this.f.kb = new Ke(), this.sd = null;
    }
    function Pt() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function st() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function ft(S) {
      return alert("todo:WebPSamplerProcessPlane"), S.T;
    }
    function Ge(S, R) {
      var D = S.T, W = R.ba.f.RGBA, se = W.eb, de = W.fb + S.ka * W.A, ge = Xs[R.ba.S], _e = S.y, xe = S.O, Ie = S.f, Re = S.N, At = S.ea, vt = S.W, at = R.cc, Gt = R.dc, kt = R.Mc, rt = R.Nc, Xe = S.ka, qt = S.ka + S.T, Zt = S.U, Ht = Zt + 1 >> 1;
      for (Xe == 0 ? ge(_e, xe, null, null, Ie, Re, At, vt, Ie, Re, At, vt, se, de, null, null, Zt) : (ge(R.ec, R.fc, _e, xe, at, Gt, kt, rt, Ie, Re, At, vt, se, de - W.A, se, de, Zt), ++D); Xe + 2 < qt; Xe += 2) at = Ie, Gt = Re, kt = At, rt = vt, Re += S.Rc, vt += S.Rc, de += 2 * W.A, ge(_e, (xe += 2 * S.fa) - S.fa, _e, xe, at, Gt, kt, rt, Ie, Re, At, vt, se, de - W.A, se, de, Zt);
      return xe += S.fa, S.j + qt < S.o ? (n(R.ec, R.fc, _e, xe, Zt), n(R.cc, R.dc, Ie, Re, Ht), n(R.Mc, R.Nc, At, vt, Ht), D--) : 1 & qt || ge(_e, xe, null, null, Ie, Re, At, vt, Ie, Re, At, vt, se, de + W.A, null, null, Zt), D;
    }
    function ur(S, R, D) {
      var W = S.F, se = [S.J];
      if (W != null) {
        var de = S.U, ge = R.ba.S, _e = ge == Ou || ge == ku;
        R = R.ba.f.RGBA;
        var xe = [0], Ie = S.ka;
        xe[0] = S.T, S.Kb && (Ie == 0 ? --xe[0] : (--Ie, se[0] -= S.width), S.j + S.ka + S.T == S.o && (xe[0] = S.o - S.j - Ie));
        var Re = R.eb;
        Ie = R.fb + Ie * R.A, S = Kn(W, se[0], S.width, de, xe, Re, Ie + (_e ? 0 : 3), R.A), e(D == xe), S && Qe(ge) && Ai(Re, Ie, _e, de, xe, R.A);
      }
      return 0;
    }
    function Sr(S) {
      var R = S.ma, D = R.ba.S, W = 11 > D, se = D == cn || D == Lu || D == Ou || D == rc || D == 12 || Qe(D);
      if (R.memory = null, R.Ib = null, R.Jb = null, R.Nd = null, !Xl(R.Oa, S, se ? 11 : 12)) return 0;
      if (se && Qe(D) && Jt(), S.da) alert("todo:use_scaling");
      else {
        if (W) {
          if (R.Ib = ft, S.Kb) {
            if (D = S.U + 1 >> 1, R.memory = s(S.U + 2 * D), R.memory == null) return 0;
            R.ec = R.memory, R.fc = 0, R.cc = R.ec, R.dc = R.fc + S.U, R.Mc = R.cc, R.Nc = R.dc + D, R.Ib = Ge, Jt();
          }
        } else alert("todo:EmitYUV");
        se && (R.Jb = ur, W && mt());
      }
      if (W && !mh) {
        for (S = 0; 256 > S; ++S) nd[S] = 89858 * (S - 128) + il >> ju, rf[S] = -22014 * (S - 128) + il, Jc[S] = -45773 * (S - 128), id[S] = 113618 * (S - 128) + il >> ju;
        for (S = Oa; S < Bs; ++S) R = 76283 * (S - 16) + il >> ju, _h[S - Oa] = Ao(R, 255), sd[S - Oa] = Ao(R + 8 >> 4, 15);
        mh = 1;
      }
      return 1;
    }
    function lr(S) {
      var R = S.ma, D = S.U, W = S.T;
      return e(!(1 & S.ka)), 0 >= D || 0 >= W ? 0 : (D = R.Ib(S, R), R.Jb != null && R.Jb(S, R, D), R.Dc += D, 1);
    }
    function Er(S) {
      S.ma.memory = null;
    }
    function tr(S, R, D, W) {
      return Dt(S, 8) != 47 ? 0 : (R[0] = Dt(S, 14) + 1, D[0] = Dt(S, 14) + 1, W[0] = Dt(S, 1), Dt(S, 3) != 0 ? 0 : !S.h);
    }
    function xn(S, R) {
      if (4 > S) return S + 1;
      var D = S - 2 >> 1;
      return (2 + (1 & S) << D) + Dt(R, D) + 1;
    }
    function dn(S, R) {
      return 120 < R ? R - 120 : 1 <= (D = ((D = Nu[R - 1]) >> 4) * S + (8 - (15 & D))) ? D : 1;
      var D;
    }
    function Jr(S, R, D) {
      var W = Oe(D), se = S[R += 255 & W].g - 8;
      return 0 < se && (et(D, D.u + 8), W = Oe(D), R += S[R].value, R += W & (1 << se) - 1), et(D, D.u + S[R].g), S[R].value;
    }
    function Cr(S, R, D) {
      return D.g += S.g, D.value += S.value << R >>> 0, e(8 >= D.g), S.g;
    }
    function zr(S, R, D) {
      var W = S.xc;
      return e((R = W == 0 ? 0 : S.vc[S.md * (D >> W) + (R >> W)]) < S.Wb), S.Ya[R];
    }
    function Dn(S, R, D, W) {
      var se = S.ab, de = S.c * R, ge = S.C;
      R = ge + R;
      var _e = D, xe = W;
      for (W = S.Ta, D = S.Ua; 0 < se--; ) {
        var Ie = S.gc[se], Re = ge, At = R, vt = _e, at = xe, Gt = (xe = W, _e = D, Ie.Ea);
        switch (e(Re < At), e(At <= Ie.nc), Ie.hc) {
          case 2:
            ah(vt, at, (At - Re) * Gt, xe, _e);
            break;
          case 0:
            var kt = Re, rt = At, Xe = xe, qt = _e, Zt = (br = Ie).Ea;
            kt == 0 && (Jh(vt, at, null, null, 1, Xe, qt), en(vt, at + 1, 0, 0, Zt - 1, Xe, qt + 1), at += Zt, qt += Zt, ++kt);
            for (var Ht = 1 << br.b, Mr = Ht - 1, yr = Tr(Zt, br.b), $r = br.K, br = br.w + (kt >> br.b) * yr; kt < rt; ) {
              var Pn = $r, Fn = br, wn = 1;
              for (El(vt, at, Xe, qt - Zt, 1, Xe, qt); wn < Zt; ) {
                var Sn = (wn & ~Mr) + Ht;
                Sn > Zt && (Sn = Zt), (0, Ma[Pn[Fn++] >> 8 & 15])(vt, at + +wn, Xe, qt + wn - Zt, Sn - wn, Xe, qt + wn), wn = Sn;
              }
              at += Zt, qt += Zt, ++kt & Mr || (br += yr);
            }
            At != Ie.nc && n(xe, _e - Gt, xe, _e + (At - Re - 1) * Gt, Gt);
            break;
          case 1:
            for (Gt = vt, rt = at, Zt = (vt = Ie.Ea) - (qt = vt & ~(Xe = (at = 1 << Ie.b) - 1)), kt = Tr(vt, Ie.b), Ht = Ie.K, Ie = Ie.w + (Re >> Ie.b) * kt; Re < At; ) {
              for (Mr = Ht, yr = Ie, $r = new mr(), br = rt + qt, Pn = rt + vt; rt < br; ) vn(Mr[yr++], $r), mn($r, Gt, rt, at, xe, _e), rt += at, _e += at;
              rt < Pn && (vn(Mr[yr++], $r), mn($r, Gt, rt, Zt, xe, _e), rt += Zt, _e += Zt), ++Re & Xe || (Ie += kt);
            }
            break;
          case 3:
            if (vt == xe && at == _e && 0 < Ie.b) {
              for (rt = xe, vt = Gt = _e + (At - Re) * Gt - (qt = (At - Re) * Tr(Ie.Ea, Ie.b)), at = xe, Xe = _e, kt = [], qt = (Zt = qt) - 1; 0 <= qt; --qt) kt[qt] = at[Xe + qt];
              for (qt = Zt - 1; 0 <= qt; --qt) rt[vt + qt] = kt[qt];
              To(Ie, Re, At, xe, Gt, xe, _e);
            } else To(Ie, Re, At, vt, at, xe, _e);
        }
        _e = W, xe = D;
      }
      xe != D && n(W, D, _e, xe, de);
    }
    function er(S, R) {
      var D = S.V, W = S.Ba + S.c * S.C, se = R - S.C;
      if (e(R <= S.l.o), e(16 >= se), 0 < se) {
        var de = S.l, ge = S.Ta, _e = S.Ua, xe = de.width;
        if (Dn(S, se, D, W), se = _e = [_e], e((D = S.C) < (W = R)), e(de.v < de.va), W > de.o && (W = de.o), D < de.j) {
          var Ie = de.j - D;
          D = de.j, se[0] += Ie * xe;
        }
        if (D >= W ? D = 0 : (se[0] += 4 * de.v, de.ka = D - de.j, de.U = de.va - de.v, de.T = W - D, D = 1), D) {
          if (_e = _e[0], 11 > (D = S.ca).S) {
            var Re = D.f.RGBA, At = (W = D.S, se = de.U, de = de.T, Ie = Re.eb, Re.A), vt = de;
            for (Re = Re.fb + S.Ma * Re.A; 0 < vt--; ) {
              var at = ge, Gt = _e, kt = se, rt = Ie, Xe = Re;
              switch (W) {
                case Gc:
                  vs(at, Gt, kt, rt, Xe);
                  break;
                case cn:
                  wi(at, Gt, kt, rt, Xe);
                  break;
                case Qh:
                  wi(at, Gt, kt, rt, Xe), Ai(rt, Xe, 0, kt, 1, 0);
                  break;
                case Ml:
                  ca(at, Gt, kt, rt, Xe);
                  break;
                case Lu:
                  Le(at, Gt, kt, rt, Xe, 1);
                  break;
                case uh:
                  Le(at, Gt, kt, rt, Xe, 1), Ai(rt, Xe, 0, kt, 1, 0);
                  break;
                case Ou:
                  Le(at, Gt, kt, rt, Xe, 0);
                  break;
                case ku:
                  Le(at, Gt, kt, rt, Xe, 0), Ai(rt, Xe, 1, kt, 1, 0);
                  break;
                case rc:
                  Pa(at, Gt, kt, rt, Xe);
                  break;
                case Hc:
                  Pa(at, Gt, kt, rt, Xe), Yn(rt, Xe, kt, 1, 0);
                  break;
                case Jf:
                  la(at, Gt, kt, rt, Xe);
                  break;
                default:
                  e(0);
              }
              _e += xe, Re += At;
            }
            S.Ma += de;
          } else alert("todo:EmitRescaledRowsYUVA");
          e(S.Ma <= D.height);
        }
      }
      S.C = R, e(S.C <= S.i);
    }
    function oi(S) {
      var R;
      if (0 < S.ua) return 0;
      for (R = 0; R < S.Wb; ++R) {
        var D = S.Ya[R].G, W = S.Ya[R].H;
        if (0 < D[1][W[1] + 0].g || 0 < D[2][W[2] + 0].g || 0 < D[3][W[3] + 0].g) return 0;
      }
      return 1;
    }
    function Mn(S, R, D, W, se, de) {
      if (S.Z != 0) {
        var ge = S.qd, _e = S.rd;
        for (e(Ki[S.Z] != null); R < D; ++R) Ki[S.Z](ge, _e, W, se, W, se, de), ge = W, _e = se, se += de;
        S.qd = ge, S.rd = _e;
      }
    }
    function rs(S, R) {
      var D = S.l.ma, W = D.Z == 0 || D.Z == 1 ? S.l.j : S.C;
      if (W = S.C < W ? W : S.C, e(R <= S.l.o), R > W) {
        var se = S.l.width, de = D.ca, ge = D.tb + se * W, _e = S.V, xe = S.Ba + S.c * W, Ie = S.gc;
        e(S.ab == 1), e(Ie[0].hc == 3), Ru(Ie[0], W, R, _e, xe, de, ge), Mn(D, W, R, de, ge, se);
      }
      S.C = S.Ma = R;
    }
    function _s(S, R, D, W, se, de, ge) {
      var _e = S.$ / W, xe = S.$ % W, Ie = S.m, Re = S.s, At = D + S.$, vt = At;
      se = D + W * se;
      var at = D + W * de, Gt = 280 + Re.ua, kt = S.Pb ? _e : 16777216, rt = 0 < Re.ua ? Re.Wa : null, Xe = Re.wc, qt = At < at ? zr(Re, xe, _e) : null;
      e(S.C < de), e(at <= se);
      var Zt = !1;
      e: for (; ; ) {
        for (; Zt || At < at; ) {
          var Ht = 0;
          if (_e >= kt) {
            var Mr = At - D;
            e((kt = S).Pb), kt.wd = kt.m, kt.xd = Mr, 0 < kt.s.ua && Nt(kt.s.Wa, kt.s.vb), kt = _e + Zc;
          }
          if (xe & Xe || (qt = zr(Re, xe, _e)), e(qt != null), qt.Qb && (R[At] = qt.qb, Zt = !0), !Zt) if (ot(Ie), qt.jc) {
            Ht = Ie, Mr = R;
            var yr = At, $r = qt.pd[Oe(Ht) & Zi - 1];
            e(qt.jc), 256 > $r.g ? (et(Ht, Ht.u + $r.g), Mr[yr] = $r.value, Ht = 0) : (et(Ht, Ht.u + $r.g - 256), e(256 <= $r.value), Ht = $r.value), Ht == 0 && (Zt = !0);
          } else Ht = Jr(qt.G[0], qt.H[0], Ie);
          if (Ie.h) break;
          if (Zt || 256 > Ht) {
            if (!Zt) if (qt.nd) R[At] = (qt.qb | Ht << 8) >>> 0;
            else {
              if (ot(Ie), Zt = Jr(qt.G[1], qt.H[1], Ie), ot(Ie), Mr = Jr(qt.G[2], qt.H[2], Ie), yr = Jr(qt.G[3], qt.H[3], Ie), Ie.h) break;
              R[At] = (yr << 24 | Zt << 16 | Ht << 8 | Mr) >>> 0;
            }
            if (Zt = !1, ++At, ++xe >= W && (xe = 0, ++_e, ge != null && _e <= de && !(_e % 16) && ge(S, _e), rt != null)) for (; vt < At; ) Ht = R[vt++], rt.X[(506832829 * Ht & 4294967295) >>> rt.Mb] = Ht;
          } else if (280 > Ht) {
            if (Ht = xn(Ht - 256, Ie), Mr = Jr(qt.G[4], qt.H[4], Ie), ot(Ie), Mr = dn(W, Mr = xn(Mr, Ie)), Ie.h) break;
            if (At - D < Mr || se - At < Ht) break e;
            for (yr = 0; yr < Ht; ++yr) R[At + yr] = R[At + yr - Mr];
            for (At += Ht, xe += Ht; xe >= W; ) xe -= W, ++_e, ge != null && _e <= de && !(_e % 16) && ge(S, _e);
            if (e(At <= se), xe & Xe && (qt = zr(Re, xe, _e)), rt != null) for (; vt < At; ) Ht = R[vt++], rt.X[(506832829 * Ht & 4294967295) >>> rt.Mb] = Ht;
          } else {
            if (!(Ht < Gt)) break e;
            for (Zt = Ht - 280, e(rt != null); vt < At; ) Ht = R[vt++], rt.X[(506832829 * Ht & 4294967295) >>> rt.Mb] = Ht;
            Ht = At, e(!(Zt >>> (Mr = rt).Xa)), R[Ht] = Mr.X[Zt], Zt = !0;
          }
          Zt || e(Ie.h == $e(Ie));
        }
        if (S.Pb && Ie.h && At < se) e(S.m.h), S.a = 5, S.m = S.wd, S.$ = S.xd, 0 < S.s.ua && Nt(S.s.vb, S.s.Wa);
        else {
          if (Ie.h) break e;
          ge != null && ge(S, _e > de ? de : _e), S.a = 0, S.$ = At - D;
        }
        return 1;
      }
      return S.a = 3, 0;
    }
    function rr(S) {
      e(S != null), S.vc = null, S.yc = null, S.Ya = null;
      var R = S.Wa;
      R != null && (R.X = null), S.vb = null, e(S != null);
    }
    function Vr() {
      var S = new Tl();
      return S == null ? null : (S.a = 0, S.xb = nl, Ye("Predictor", "VP8LPredictors"), Ye("Predictor", "VP8LPredictors_C"), Ye("PredictorAdd", "VP8LPredictorsAdd"), Ye("PredictorAdd", "VP8LPredictorsAdd_C"), ah = nn, mn = Hr, vs = gr, wi = nt, Pa = oe, la = fe, ca = ye, he.VP8LMapColor32b = Jl, he.VP8LMapColor8b = Bu, S);
    }
    function Gr(S, R, D, W, se) {
      var de = 1, ge = [S], _e = [R], xe = W.m, Ie = W.s, Re = null, At = 0;
      e: for (; ; ) {
        if (D) for (; de && Dt(xe, 1); ) {
          var vt = ge, at = _e, Gt = W, kt = 1, rt = Gt.m, Xe = Gt.gc[Gt.ab], qt = Dt(rt, 2);
          if (Gt.Oc & 1 << qt) de = 0;
          else {
            switch (Gt.Oc |= 1 << qt, Xe.hc = qt, Xe.Ea = vt[0], Xe.nc = at[0], Xe.K = [null], ++Gt.ab, e(4 >= Gt.ab), qt) {
              case 0:
              case 1:
                Xe.b = Dt(rt, 3) + 2, kt = Gr(Tr(Xe.Ea, Xe.b), Tr(Xe.nc, Xe.b), 0, Gt, Xe.K), Xe.K = Xe.K[0];
                break;
              case 3:
                var Zt, Ht = Dt(rt, 8) + 1, Mr = 16 < Ht ? 0 : 4 < Ht ? 1 : 2 < Ht ? 2 : 3;
                if (vt[0] = Tr(Xe.Ea, Mr), Xe.b = Mr, Zt = kt = Gr(Ht, 1, 0, Gt, Xe.K)) {
                  var yr, $r = Ht, br = Xe, Pn = 1 << (8 >> br.b), Fn = s(Pn);
                  if (Fn == null) Zt = 0;
                  else {
                    var wn = br.K[0], Sn = br.w;
                    for (Fn[0] = br.K[0][0], yr = 1; yr < 1 * $r; ++yr) Fn[yr] = Yt(wn[Sn + yr], Fn[yr - 1]);
                    for (; yr < 4 * Pn; ++yr) Fn[yr] = 0;
                    br.K[0] = null, br.K[0] = Fn, Zt = 1;
                  }
                }
                kt = Zt;
                break;
              case 2:
                break;
              default:
                e(0);
            }
            de = kt;
          }
        }
        if (ge = ge[0], _e = _e[0], de && Dt(xe, 1) && !(de = 1 <= (At = Dt(xe, 4)) && 11 >= At)) {
          W.a = 3;
          break e;
        }
        var Vn;
        if (Vn = de) t: {
          var Cn, Br, di, ws = W, Bi = ge, Zs = _e, Un = At, So = D, Li = ws.m, Fi = ws.s, fr = [null], Ir = 1, Ys = 0, zo = Xc[Un];
          r: for (; ; ) {
            if (So && Dt(Li, 1)) {
              var Oi = Dt(Li, 3) + 2, Ei = Tr(Bi, Oi), Pl = Tr(Zs, Oi), ki = Ei * Pl;
              if (!Gr(Ei, Pl, 0, ws, fr)) break r;
              for (fr = fr[0], Fi.xc = Oi, Cn = 0; Cn < ki; ++Cn) {
                var sl = fr[Cn] >> 8 & 65535;
                fr[Cn] = sl, sl >= Ir && (Ir = sl + 1);
              }
            }
            if (Li.h) break r;
            for (Br = 0; 5 > Br; ++Br) {
              var Wn = Wc[Br];
              !Br && 0 < Un && (Wn += 1 << Un), Ys < Wn && (Ys = Wn);
            }
            var ri = l(Ir * zo, me), pi = Ir, nf = l(pi, Pe);
            if (nf == null) var pa = null;
            else e(65536 >= pi), pa = nf;
            var jo = s(Ys);
            if (pa == null || jo == null || ri == null) {
              ws.a = 1;
              break r;
            }
            var eu = ri;
            for (Cn = di = 0; Cn < Ir; ++Cn) {
              var ho = pa[Cn], Vo = ho.G, ka = ho.H, yh = 0, oc = 1, bh = 0;
              for (Br = 0; 5 > Br; ++Br) {
                Wn = Wc[Br], Vo[Br] = eu, ka[Br] = di, !Br && 0 < Un && (Wn += 1 << Un);
                i: {
                  var v, a = Wn, h = ws, g = jo, y = eu, w = di, C = 0, P = h.m, L = Dt(P, 1);
                  if (i(g, 0, 0, a), L) {
                    var F = Dt(P, 1) + 1, j = Dt(P, 1), X = Dt(P, j == 0 ? 1 : 8);
                    g[X] = 1, F == 2 && (g[X = Dt(P, 8)] = 1);
                    var G = 1;
                  } else {
                    var Q = s(19), le = Dt(P, 4) + 4;
                    if (19 < le) {
                      h.a = 3;
                      var Ae = 0;
                      break i;
                    }
                    for (v = 0; v < le; ++v) Q[ef[v]] = Dt(P, 3);
                    var we = void 0, Te = void 0, Me = h, Ve = Q, De = a, He = g, Ze = 0, Fe = Me.m, it = 8, bt = l(128, me);
                    n: for (; pe(bt, 0, 7, Ve, 19); ) {
                      if (Dt(Fe, 1)) {
                        var dt = 2 + 2 * Dt(Fe, 3);
                        if ((we = 2 + Dt(Fe, dt)) > De) break n;
                      } else we = De;
                      for (Te = 0; Te < De && we--; ) {
                        ot(Fe);
                        var Tt = bt[0 + (127 & Oe(Fe))];
                        et(Fe, Fe.u + Tt.g);
                        var wt = Tt.value;
                        if (16 > wt) He[Te++] = wt, wt != 0 && (it = wt);
                        else {
                          var ir = wt == 16, or = wt - 16, Vt = fh[or], xr = Dt(Fe, hh[or]) + Vt;
                          if (Te + xr > De) break n;
                          for (var an = ir ? it : 0; 0 < xr--; ) He[Te++] = an;
                        }
                      }
                      Ze = 1;
                      break n;
                    }
                    Ze || (Me.a = 3), G = Ze;
                  }
                  (G = G && !P.h) && (C = pe(y, w, 8, g, a)), G && C != 0 ? Ae = C : (h.a = 3, Ae = 0);
                }
                if (Ae == 0) break r;
                if (oc && dh[Br] == 1 && (oc = eu[di].g == 0), yh += eu[di].g, di += Ae, 3 >= Br) {
                  var An, ni = jo[0];
                  for (An = 1; An < Wn; ++An) jo[An] > ni && (ni = jo[An]);
                  bh += ni;
                }
              }
              if (ho.nd = oc, ho.Qb = 0, oc && (ho.qb = (Vo[3][ka[3] + 0].value << 24 | Vo[1][ka[1] + 0].value << 16 | Vo[2][ka[2] + 0].value) >>> 0, yh == 0 && 256 > Vo[0][ka[0] + 0].value && (ho.Qb = 1, ho.qb += Vo[0][ka[0] + 0].value << 8)), ho.jc = !ho.Qb && 6 > bh, ho.jc) {
                var On, kn = ho;
                for (On = 0; On < Zi; ++On) {
                  var In = On, En = kn.pd[In], Nn = kn.G[0][kn.H[0] + In];
                  256 <= Nn.value ? (En.g = Nn.g + 256, En.value = Nn.value) : (En.g = 0, En.value = 0, In >>= Cr(Nn, 8, En), In >>= Cr(kn.G[1][kn.H[1] + In], 16, En), In >>= Cr(kn.G[2][kn.H[2] + In], 0, En), Cr(kn.G[3][kn.H[3] + In], 24, En));
                }
              }
            }
            Fi.vc = fr, Fi.Wb = Ir, Fi.Ya = pa, Fi.yc = ri, Vn = 1;
            break t;
          }
          Vn = 0;
        }
        if (!(de = Vn)) {
          W.a = 3;
          break e;
        }
        if (0 < At) {
          if (Ie.ua = 1 << At, !Ur(Ie.Wa, At)) {
            W.a = 1, de = 0;
            break e;
          }
        } else Ie.ua = 0;
        var Ji = W, yn = ge, as = _e, Qi = Ji.s, Na = Qi.xc;
        if (Ji.c = yn, Ji.i = as, Qi.md = Tr(yn, Na), Qi.wc = Na == 0 ? -1 : (1 << Na) - 1, D) {
          W.xb = Si;
          break e;
        }
        if ((Re = s(ge * _e)) == null) {
          W.a = 1, de = 0;
          break e;
        }
        de = (de = _s(W, Re, 0, ge, _e, _e, null)) && !xe.h;
        break e;
      }
      return de ? (se != null ? se[0] = Re : (e(Re == null), e(D)), W.$ = 0, D || rr(Ie)) : rr(Ie), de;
    }
    function Hi(S, R) {
      var D = S.c * S.i, W = D + R + 16 * R;
      return e(S.c <= R), S.V = s(W), S.V == null ? (S.Ta = null, S.Ua = 0, S.a = 1, 0) : (S.Ta = S.V, S.Ua = S.Ba + D + R, 1);
    }
    function Ga(S, R) {
      var D = S.C, W = R - D, se = S.V, de = S.Ba + S.c * D;
      for (e(R <= S.l.o); 0 < W; ) {
        var ge = 16 < W ? 16 : W, _e = S.l.ma, xe = S.l.width, Ie = xe * ge, Re = _e.ca, At = _e.tb + xe * D, vt = S.Ta, at = S.Ua;
        Dn(S, ge, se, de), Ti(vt, at, Re, At, Ie), Mn(_e, D, D + ge, Re, At, xe), W -= ge, se += ge * S.c, D += ge;
      }
      e(D == R), S.C = S.Ma = R;
    }
    function Vs() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function Xr() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function io() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = s(4), this.Lb = s(4);
    }
    function va() {
      this.Yb = function() {
        var S = [];
        return function R(D, W, se) {
          for (var de = se[W], ge = 0; ge < de && (D.push(se.length > W + 1 ? [] : 0), !(se.length < W + 1)); ge++) R(D[ge], W + 1, se);
        }(S, 0, [3, 11]), S;
      }();
    }
    function bi() {
      this.jb = s(3), this.Wc = o([4, 8], va), this.Xc = o([4, 17], va);
    }
    function Vl() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new s(4), this.od = new s(4);
    }
    function xa() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Po() {
      this.Na = this.la = 0;
    }
    function $l() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function ys() {
      this.ad = s(384), this.Za = 0, this.Ob = s(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function ti() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new xa()), this.Y = 0, this.ya = Array(new ys()), this.aa = 0, this.l = new Ha();
    }
    function vu() {
      this.y = s(16), this.f = s(8), this.ea = s(8);
    }
    function ql() {
      this.cb = this.a = 0, this.sc = "", this.m = new hr(), this.Od = new Vs(), this.Kc = new Xr(), this.ed = new Vl(), this.Qa = new io(), this.Ic = this.$c = this.Aa = 0, this.D = new ti(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = l(8, hr), this.ia = 0, this.pb = l(4, $l), this.Pa = new bi(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new vu()), this.Hd = 0, this.rb = Array(new Po()), this.sb = 0, this.wa = Array(new xa()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new ys()), this.L = this.aa = 0, this.gd = o([4, 2], xa), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function Ha() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function Wa() {
      var S = new ql();
      return S != null && (S.a = 0, S.sc = "OK", S.cb = 0, S.Xb = 0, Do || (Do = Au)), S;
    }
    function Hn(S, R, D) {
      return S.a == 0 && (S.a = R, S.sc = D, S.cb = 0), 0;
    }
    function xu(S, R, D) {
      return 3 <= D && S[R + 0] == 157 && S[R + 1] == 1 && S[R + 2] == 42;
    }
    function wu(S, R) {
      if (S == null) return 0;
      if (S.a = 0, S.sc = "OK", R == null) return Hn(S, 2, "null VP8Io passed to VP8GetHeaders()");
      var D = R.data, W = R.w, se = R.ha;
      if (4 > se) return Hn(S, 7, "Truncated header.");
      var de = D[W + 0] | D[W + 1] << 8 | D[W + 2] << 16, ge = S.Od;
      if (ge.Rb = !(1 & de), ge.td = de >> 1 & 7, ge.yd = de >> 4 & 1, ge.ub = de >> 5, 3 < ge.td) return Hn(S, 3, "Incorrect keyframe parameters.");
      if (!ge.yd) return Hn(S, 4, "Frame not displayable.");
      W += 3, se -= 3;
      var _e = S.Kc;
      if (ge.Rb) {
        if (7 > se) return Hn(S, 7, "cannot parse picture header");
        if (!xu(D, W, se)) return Hn(S, 3, "Bad code word");
        _e.c = 16383 & (D[W + 4] << 8 | D[W + 3]), _e.Td = D[W + 4] >> 6, _e.i = 16383 & (D[W + 6] << 8 | D[W + 5]), _e.Ud = D[W + 6] >> 6, W += 7, se -= 7, S.za = _e.c + 15 >> 4, S.Ub = _e.i + 15 >> 4, R.width = _e.c, R.height = _e.i, R.Da = 0, R.j = 0, R.v = 0, R.va = R.width, R.o = R.height, R.da = 0, R.ib = R.width, R.hb = R.height, R.U = R.width, R.T = R.height, i((de = S.Pa).jb, 0, 255, de.jb.length), e((de = S.Qa) != null), de.Cb = 0, de.Bb = 0, de.Fb = 1, i(de.Zb, 0, 0, de.Zb.length), i(de.Lb, 0, 0, de.Lb);
      }
      if (ge.ub > se) return Hn(S, 7, "bad partition length");
      St(de = S.m, D, W, ge.ub), W += ge.ub, se -= ge.ub, ge.Rb && (_e.Ld = It(de), _e.Kd = It(de)), _e = S.Qa;
      var xe, Ie = S.Pa;
      if (e(de != null), e(_e != null), _e.Cb = It(de), _e.Cb) {
        if (_e.Bb = It(de), It(de)) {
          for (_e.Fb = It(de), xe = 0; 4 > xe; ++xe) _e.Zb[xe] = It(de) ? Lt(de, 7) : 0;
          for (xe = 0; 4 > xe; ++xe) _e.Lb[xe] = It(de) ? Lt(de, 6) : 0;
        }
        if (_e.Bb) for (xe = 0; 3 > xe; ++xe) Ie.jb[xe] = It(de) ? Mt(de, 8) : 255;
      } else _e.Bb = 0;
      if (de.Ka) return Hn(S, 3, "cannot parse segment header");
      if ((_e = S.ed).zd = It(de), _e.Tb = Mt(de, 6), _e.wb = Mt(de, 3), _e.Pc = It(de), _e.Pc && It(de)) {
        for (Ie = 0; 4 > Ie; ++Ie) It(de) && (_e.vd[Ie] = Lt(de, 6));
        for (Ie = 0; 4 > Ie; ++Ie) It(de) && (_e.od[Ie] = Lt(de, 6));
      }
      if (S.L = _e.Tb == 0 ? 0 : _e.zd ? 1 : 2, de.Ka) return Hn(S, 3, "cannot parse filter header");
      var Re = se;
      if (se = xe = W, W = xe + Re, _e = Re, S.Xb = (1 << Mt(S.m, 2)) - 1, Re < 3 * (Ie = S.Xb)) D = 7;
      else {
        for (xe += 3 * Ie, _e -= 3 * Ie, Re = 0; Re < Ie; ++Re) {
          var At = D[se + 0] | D[se + 1] << 8 | D[se + 2] << 16;
          At > _e && (At = _e), St(S.Jc[+Re], D, xe, At), xe += At, _e -= At, se += 3;
        }
        St(S.Jc[+Ie], D, xe, _e), D = xe < W ? 0 : 5;
      }
      if (D != 0) return Hn(S, D, "cannot parse partitions");
      for (D = Mt(xe = S.m, 7), se = It(xe) ? Lt(xe, 4) : 0, W = It(xe) ? Lt(xe, 4) : 0, _e = It(xe) ? Lt(xe, 4) : 0, Ie = It(xe) ? Lt(xe, 4) : 0, xe = It(xe) ? Lt(xe, 4) : 0, Re = S.Qa, At = 0; 4 > At; ++At) {
        if (Re.Cb) {
          var vt = Re.Zb[At];
          Re.Fb || (vt += D);
        } else {
          if (0 < At) {
            S.pb[At] = S.pb[0];
            continue;
          }
          vt = D;
        }
        var at = S.pb[At];
        at.Sc[0] = nc[Ao(vt + se, 127)], at.Sc[1] = Du[Ao(vt + 0, 127)], at.Eb[0] = 2 * nc[Ao(vt + W, 127)], at.Eb[1] = 101581 * Du[Ao(vt + _e, 127)] >> 16, 8 > at.Eb[1] && (at.Eb[1] = 8), at.Qc[0] = nc[Ao(vt + Ie, 117)], at.Qc[1] = Du[Ao(vt + xe, 127)], at.lc = vt + xe;
      }
      if (!ge.Rb) return Hn(S, 4, "Not a key frame.");
      for (It(de), ge = S.Pa, D = 0; 4 > D; ++D) {
        for (se = 0; 8 > se; ++se) for (W = 0; 3 > W; ++W) for (_e = 0; 11 > _e; ++_e) Ie = yt(de, td[D][se][W][_e]) ? Mt(de, 8) : tf[D][se][W][_e], ge.Wc[D][se].Yb[W][_e] = Ie;
        for (se = 0; 17 > se; ++se) ge.Xc[D][se] = ge.Wc[D][Uu[se]];
      }
      return S.kc = It(de), S.kc && (S.Bd = Mt(de, 8)), S.cb = 1;
    }
    function Au(S, R, D, W, se, de, ge) {
      var _e = R[se].Yb[D];
      for (D = 0; 16 > se; ++se) {
        if (!yt(S, _e[D + 0])) return se;
        for (; !yt(S, _e[D + 1]); ) if (_e = R[++se].Yb[0], D = 0, se == 16) return 16;
        var xe = R[se + 1].Yb;
        if (yt(S, _e[D + 2])) {
          var Ie = S, Re = 0;
          if (yt(Ie, (vt = _e)[(At = D) + 3]))
            if (yt(Ie, vt[At + 6])) {
              for (_e = 0, At = 2 * (Re = yt(Ie, vt[At + 8])) + (vt = yt(Ie, vt[At + 9 + Re])), Re = 0, vt = Ap[At]; vt[_e]; ++_e) Re += Re + yt(Ie, vt[_e]);
              Re += 3 + (8 << At);
            } else yt(Ie, vt[At + 7]) ? (Re = 7 + 2 * yt(Ie, 165), Re += yt(Ie, 145)) : Re = 5 + yt(Ie, 159);
          else Re = yt(Ie, vt[At + 4]) ? 3 + yt(Ie, vt[At + 5]) : 2;
          _e = xe[2];
        } else Re = 1, _e = xe[1];
        xe = ge + Qf[se], 0 > (Ie = S).b && ht(Ie);
        var At, vt = Ie.b, at = (At = Ie.Ca >> 1) - (Ie.I >> vt) >> 31;
        --Ie.b, Ie.Ca += at, Ie.Ca |= 1, Ie.I -= (At + 1 & at) << vt, de[xe] = ((Re ^ at) - at) * W[(0 < se) + 0];
      }
      return 16;
    }
    function wa(S) {
      var R = S.rb[S.sb - 1];
      R.la = 0, R.Na = 0, i(S.zc, 0, 0, S.zc.length), S.ja = 0;
    }
    function ih(S, R) {
      if (S == null) return 0;
      if (R == null) return Hn(S, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!S.cb && !wu(S, R)) return 0;
      if (e(S.cb), R.ac == null || R.ac(R)) {
        R.ob && (S.L = 0);
        var D = sc[S.L];
        if (S.L == 2 ? (S.yb = 0, S.zb = 0) : (S.yb = R.v - D >> 4, S.zb = R.j - D >> 4, 0 > S.yb && (S.yb = 0), 0 > S.zb && (S.zb = 0)), S.Va = R.o + 15 + D >> 4, S.Hb = R.va + 15 + D >> 4, S.Hb > S.za && (S.Hb = S.za), S.Va > S.Ub && (S.Va = S.Ub), 0 < S.L) {
          var W = S.ed;
          for (D = 0; 4 > D; ++D) {
            var se;
            if (S.Qa.Cb) {
              var de = S.Qa.Lb[D];
              S.Qa.Fb || (de += W.Tb);
            } else de = W.Tb;
            for (se = 0; 1 >= se; ++se) {
              var ge = S.gd[D][se], _e = de;
              if (W.Pc && (_e += W.vd[0], se && (_e += W.od[0])), 0 < (_e = 0 > _e ? 0 : 63 < _e ? 63 : _e)) {
                var xe = _e;
                0 < W.wb && (xe = 4 < W.wb ? xe >> 2 : xe >> 1) > 9 - W.wb && (xe = 9 - W.wb), 1 > xe && (xe = 1), ge.dd = xe, ge.tc = 2 * _e + xe, ge.ld = 40 <= _e ? 2 : 15 <= _e ? 1 : 0;
              } else ge.tc = 0;
              ge.La = se;
            }
          }
        }
        D = 0;
      } else Hn(S, 6, "Frame setup failed"), D = S.a;
      if (D = D == 0) {
        if (D) {
          S.$c = 0, 0 < S.Aa || (S.Ic = Fo);
          e: {
            D = S.Ic, W = 4 * (xe = S.za);
            var Ie = 32 * xe, Re = xe + 1, At = 0 < S.L ? xe * (0 < S.Aa ? 2 : 1) : 0, vt = (S.Aa == 2 ? 2 : 1) * xe;
            if ((ge = W + 832 + (se = 3 * (16 * D + sc[S.L]) / 2 * Ie) + (de = S.Fa != null && 0 < S.Fa.length ? S.Kc.c * S.Kc.i : 0)) != ge) D = 0;
            else {
              if (ge > S.Vb) {
                if (S.Vb = 0, S.Ec = s(ge), S.Fc = 0, S.Ec == null) {
                  D = Hn(S, 1, "no memory during frame initialization.");
                  break e;
                }
                S.Vb = ge;
              }
              ge = S.Ec, _e = S.Fc, S.Ac = ge, S.Bc = _e, _e += W, S.Gd = l(Ie, vu), S.Hd = 0, S.rb = l(Re + 1, Po), S.sb = 1, S.wa = At ? l(At, xa) : null, S.Y = 0, S.D.Nb = 0, S.D.wa = S.wa, S.D.Y = S.Y, 0 < S.Aa && (S.D.Y += xe), e(!0), S.oc = ge, S.pc = _e, _e += 832, S.ya = l(vt, ys), S.aa = 0, S.D.ya = S.ya, S.D.aa = S.aa, S.Aa == 2 && (S.D.aa += xe), S.R = 16 * xe, S.B = 8 * xe, xe = (Ie = sc[S.L]) * S.R, Ie = Ie / 2 * S.B, S.sa = ge, S.ta = _e + xe, S.qa = S.sa, S.ra = S.ta + 16 * D * S.R + Ie, S.Ha = S.qa, S.Ia = S.ra + 8 * D * S.B + Ie, S.$c = 0, _e += se, S.mb = de ? ge : null, S.nb = de ? _e : null, e(_e + de <= S.Fc + S.Vb), wa(S), i(S.Ac, S.Bc, 0, W), D = 1;
            }
          }
          if (D) {
            if (R.ka = 0, R.y = S.sa, R.O = S.ta, R.f = S.qa, R.N = S.ra, R.ea = S.Ha, R.Vd = S.Ia, R.fa = S.R, R.Rc = S.B, R.F = null, R.J = 0, !tl) {
              for (D = -255; 255 >= D; ++D) li[255 + D] = 0 > D ? -D : D;
              for (D = -1020; 1020 >= D; ++D) No[1020 + D] = -128 > D ? -128 : 127 < D ? 127 : D;
              for (D = -112; 112 >= D; ++D) Il[112 + D] = -16 > D ? -16 : 15 < D ? 15 : D;
              for (D = -255; 510 >= D; ++D) Ba[255 + D] = 0 > D ? 0 : 255 < D ? 255 : D;
              tl = 1;
            }
            Ql = Uc, ua = Tu, ec = Fc, Ws = sh, ko = Gl, Zn = Xa, $c = Ya, lh = Bo, qc = Al, tc = Ea, Cl = Ri, ha = Sa, Ra = Iu, Ja = aa, Qa = Cu, lo = ao, el = xo, xs = wo, uo[0] = zn, uo[1] = un, uo[2] = Su, uo[3] = ns, uo[4] = Wi, uo[5] = jn, uo[6] = Ni, uo[7] = wl, uo[8] = Ps, uo[9] = pn, fa[0] = qs, fa[1] = oa, fa[2] = $s, fa[3] = bl, fa[4] = hi, fa[5] = hn, fa[6] = xl, La[0] = Or, La[1] = sa, La[2] = Wr, La[3] = Yr, La[4] = Di, La[5] = Za, La[6] = Ta, D = 1;
          } else D = 0;
        }
        D && (D = function(at, Gt) {
          for (at.M = 0; at.M < at.Va; ++at.M) {
            var kt, rt = at.Jc[at.M & at.Xb], Xe = at.m, qt = at;
            for (kt = 0; kt < qt.za; ++kt) {
              var Zt = Xe, Ht = qt, Mr = Ht.Ac, yr = Ht.Bc + 4 * kt, $r = Ht.zc, br = Ht.ya[Ht.aa + kt];
              if (Ht.Qa.Bb ? br.$b = yt(Zt, Ht.Pa.jb[0]) ? 2 + yt(Zt, Ht.Pa.jb[2]) : yt(Zt, Ht.Pa.jb[1]) : br.$b = 0, Ht.kc && (br.Ad = yt(Zt, Ht.Bd)), br.Za = !yt(Zt, 145) + 0, br.Za) {
                var Pn = br.Ob, Fn = 0;
                for (Ht = 0; 4 > Ht; ++Ht) {
                  var wn, Sn = $r[0 + Ht];
                  for (wn = 0; 4 > wn; ++wn) {
                    Sn = ed[Mr[yr + wn]][Sn];
                    for (var Vn = Fu[yt(Zt, Sn[0])]; 0 < Vn; ) Vn = Fu[2 * Vn + yt(Zt, Sn[Vn])];
                    Sn = -Vn, Mr[yr + wn] = Sn;
                  }
                  n(Pn, Fn, Mr, yr, 4), Fn += 4, $r[0 + Ht] = Sn;
                }
              } else Sn = yt(Zt, 156) ? yt(Zt, 128) ? 1 : 3 : yt(Zt, 163) ? 2 : 0, br.Ob[0] = Sn, i(Mr, yr, Sn, 4), i($r, 0, Sn, 4);
              br.Dd = yt(Zt, 142) ? yt(Zt, 114) ? yt(Zt, 183) ? 1 : 3 : 2 : 0;
            }
            if (qt.m.Ka) return Hn(at, 7, "Premature end-of-partition0 encountered.");
            for (; at.ja < at.za; ++at.ja) {
              if (qt = rt, Zt = (Xe = at).rb[Xe.sb - 1], Mr = Xe.rb[Xe.sb + Xe.ja], kt = Xe.ya[Xe.aa + Xe.ja], yr = Xe.kc ? kt.Ad : 0) Zt.la = Mr.la = 0, kt.Za || (Zt.Na = Mr.Na = 0), kt.Hc = 0, kt.Gc = 0, kt.ia = 0;
              else {
                var Cn, Br;
                if (Zt = Mr, Mr = qt, yr = Xe.Pa.Xc, $r = Xe.ya[Xe.aa + Xe.ja], br = Xe.pb[$r.$b], Ht = $r.ad, Pn = 0, Fn = Xe.rb[Xe.sb - 1], Sn = wn = 0, i(Ht, Pn, 0, 384), $r.Za) var di = 0, ws = yr[3];
                else {
                  Vn = s(16);
                  var Bi = Zt.Na + Fn.Na;
                  if (Bi = Do(Mr, yr[1], Bi, br.Eb, 0, Vn, 0), Zt.Na = Fn.Na = (0 < Bi) + 0, 1 < Bi) Ql(Vn, 0, Ht, Pn);
                  else {
                    var Zs = Vn[0] + 3 >> 3;
                    for (Vn = 0; 256 > Vn; Vn += 16) Ht[Pn + Vn] = Zs;
                  }
                  di = 1, ws = yr[0];
                }
                var Un = 15 & Zt.la, So = 15 & Fn.la;
                for (Vn = 0; 4 > Vn; ++Vn) {
                  var Li = 1 & So;
                  for (Zs = Br = 0; 4 > Zs; ++Zs) Un = Un >> 1 | (Li = (Bi = Do(Mr, ws, Bi = Li + (1 & Un), br.Sc, di, Ht, Pn)) > di) << 7, Br = Br << 2 | (3 < Bi ? 3 : 1 < Bi ? 2 : Ht[Pn + 0] != 0), Pn += 16;
                  Un >>= 4, So = So >> 1 | Li << 7, wn = (wn << 8 | Br) >>> 0;
                }
                for (ws = Un, di = So >> 4, Cn = 0; 4 > Cn; Cn += 2) {
                  for (Br = 0, Un = Zt.la >> 4 + Cn, So = Fn.la >> 4 + Cn, Vn = 0; 2 > Vn; ++Vn) {
                    for (Li = 1 & So, Zs = 0; 2 > Zs; ++Zs) Bi = Li + (1 & Un), Un = Un >> 1 | (Li = 0 < (Bi = Do(Mr, yr[2], Bi, br.Qc, 0, Ht, Pn))) << 3, Br = Br << 2 | (3 < Bi ? 3 : 1 < Bi ? 2 : Ht[Pn + 0] != 0), Pn += 16;
                    Un >>= 2, So = So >> 1 | Li << 5;
                  }
                  Sn |= Br << 4 * Cn, ws |= Un << 4 << Cn, di |= (240 & So) << Cn;
                }
                Zt.la = ws, Fn.la = di, $r.Hc = wn, $r.Gc = Sn, $r.ia = 43690 & Sn ? 0 : br.ia, yr = !(wn | Sn);
              }
              if (0 < Xe.L && (Xe.wa[Xe.Y + Xe.ja] = Xe.gd[kt.$b][kt.Za], Xe.wa[Xe.Y + Xe.ja].La |= !yr), qt.Ka) return Hn(at, 7, "Premature end-of-file encountered.");
            }
            if (wa(at), Xe = Gt, qt = 1, kt = (rt = at).D, Zt = 0 < rt.L && rt.M >= rt.zb && rt.M <= rt.Va, rt.Aa == 0) e: {
              if (kt.M = rt.M, kt.uc = Zt, Pu(rt, kt), qt = 1, kt = (Br = rt.D).Nb, Zt = (Sn = sc[rt.L]) * rt.R, Mr = Sn / 2 * rt.B, Vn = 16 * kt * rt.R, Zs = 8 * kt * rt.B, yr = rt.sa, $r = rt.ta - Zt + Vn, br = rt.qa, Ht = rt.ra - Mr + Zs, Pn = rt.Ha, Fn = rt.Ia - Mr + Zs, So = (Un = Br.M) == 0, wn = Un >= rt.Va - 1, rt.Aa == 2 && Pu(rt, Br), Br.uc) for (Li = (Bi = rt).D.M, e(Bi.D.uc), Br = Bi.yb; Br < Bi.Hb; ++Br) {
                di = Br, ws = Li;
                var Fi = (fr = (Wn = Bi).D).Nb;
                Cn = Wn.R;
                var fr = fr.wa[fr.Y + di], Ir = Wn.sa, Ys = Wn.ta + 16 * Fi * Cn + 16 * di, zo = fr.dd, Oi = fr.tc;
                if (Oi != 0) if (e(3 <= Oi), Wn.L == 1) 0 < di && lo(Ir, Ys, Cn, Oi + 4), fr.La && xs(Ir, Ys, Cn, Oi), 0 < ws && Qa(Ir, Ys, Cn, Oi + 4), fr.La && el(Ir, Ys, Cn, Oi);
                else {
                  var Ei = Wn.B, Pl = Wn.qa, ki = Wn.ra + 8 * Fi * Ei + 8 * di, sl = Wn.Ha, Wn = Wn.Ia + 8 * Fi * Ei + 8 * di;
                  Fi = fr.ld, 0 < di && (lh(Ir, Ys, Cn, Oi + 4, zo, Fi), tc(Pl, ki, sl, Wn, Ei, Oi + 4, zo, Fi)), fr.La && (ha(Ir, Ys, Cn, Oi, zo, Fi), Ja(Pl, ki, sl, Wn, Ei, Oi, zo, Fi)), 0 < ws && ($c(Ir, Ys, Cn, Oi + 4, zo, Fi), qc(Pl, ki, sl, Wn, Ei, Oi + 4, zo, Fi)), fr.La && (Cl(Ir, Ys, Cn, Oi, zo, Fi), Ra(Pl, ki, sl, Wn, Ei, Oi, zo, Fi));
                }
              }
              if (rt.ia && alert("todo:DitherRow"), Xe.put != null) {
                if (Br = 16 * Un, Un = 16 * (Un + 1), So ? (Xe.y = rt.sa, Xe.O = rt.ta + Vn, Xe.f = rt.qa, Xe.N = rt.ra + Zs, Xe.ea = rt.Ha, Xe.W = rt.Ia + Zs) : (Br -= Sn, Xe.y = yr, Xe.O = $r, Xe.f = br, Xe.N = Ht, Xe.ea = Pn, Xe.W = Fn), wn || (Un -= Sn), Un > Xe.o && (Un = Xe.o), Xe.F = null, Xe.J = null, rt.Fa != null && 0 < rt.Fa.length && Br < Un && (Xe.J = Ia(rt, Xe, Br, Un - Br), Xe.F = rt.mb, Xe.F == null && Xe.F.length == 0)) {
                  qt = Hn(rt, 3, "Could not decode alpha data.");
                  break e;
                }
                Br < Xe.j && (Sn = Xe.j - Br, Br = Xe.j, e(!(1 & Sn)), Xe.O += rt.R * Sn, Xe.N += rt.B * (Sn >> 1), Xe.W += rt.B * (Sn >> 1), Xe.F != null && (Xe.J += Xe.width * Sn)), Br < Un && (Xe.O += Xe.v, Xe.N += Xe.v >> 1, Xe.W += Xe.v >> 1, Xe.F != null && (Xe.J += Xe.v), Xe.ka = Br - Xe.j, Xe.U = Xe.va - Xe.v, Xe.T = Un - Br, qt = Xe.put(Xe));
              }
              kt + 1 != rt.Ic || wn || (n(rt.sa, rt.ta - Zt, yr, $r + 16 * rt.R, Zt), n(rt.qa, rt.ra - Mr, br, Ht + 8 * rt.B, Mr), n(rt.Ha, rt.Ia - Mr, Pn, Fn + 8 * rt.B, Mr));
            }
            if (!qt) return Hn(at, 6, "Output aborted.");
          }
          return 1;
        }(S, R)), R.bc != null && R.bc(R), D &= 1;
      }
      return D ? (S.cb = 0, D) : 0;
    }
    function Ro(S, R, D, W, se) {
      se = S[R + D + 32 * W] + (se >> 3), S[R + D + 32 * W] = -256 & se ? 0 > se ? 0 : 255 : se;
    }
    function Aa(S, R, D, W, se, de) {
      Ro(S, R, 0, D, W + se), Ro(S, R, 1, D, W + de), Ro(S, R, 2, D, W - de), Ro(S, R, 3, D, W - se);
    }
    function so(S) {
      return (20091 * S >> 16) + S;
    }
    function Dc(S, R, D, W) {
      var se, de = 0, ge = s(16);
      for (se = 0; 4 > se; ++se) {
        var _e = S[R + 0] + S[R + 8], xe = S[R + 0] - S[R + 8], Ie = (35468 * S[R + 4] >> 16) - so(S[R + 12]), Re = so(S[R + 4]) + (35468 * S[R + 12] >> 16);
        ge[de + 0] = _e + Re, ge[de + 1] = xe + Ie, ge[de + 2] = xe - Ie, ge[de + 3] = _e - Re, de += 4, R++;
      }
      for (se = de = 0; 4 > se; ++se) _e = (S = ge[de + 0] + 4) + ge[de + 8], xe = S - ge[de + 8], Ie = (35468 * ge[de + 4] >> 16) - so(ge[de + 12]), Ro(D, W, 0, 0, _e + (Re = so(ge[de + 4]) + (35468 * ge[de + 12] >> 16))), Ro(D, W, 1, 0, xe + Ie), Ro(D, W, 2, 0, xe - Ie), Ro(D, W, 3, 0, _e - Re), de++, W += 32;
    }
    function Xa(S, R, D, W) {
      var se = S[R + 0] + 4, de = 35468 * S[R + 4] >> 16, ge = so(S[R + 4]), _e = 35468 * S[R + 1] >> 16;
      Aa(D, W, 0, se + ge, S = so(S[R + 1]), _e), Aa(D, W, 1, se + de, S, _e), Aa(D, W, 2, se - de, S, _e), Aa(D, W, 3, se - ge, S, _e);
    }
    function Tu(S, R, D, W, se) {
      Dc(S, R, D, W), se && Dc(S, R + 16, D, W + 4);
    }
    function Fc(S, R, D, W) {
      ua(S, R + 0, D, W, 1), ua(S, R + 32, D, W + 128, 1);
    }
    function sh(S, R, D, W) {
      var se;
      for (S = S[R + 0] + 4, se = 0; 4 > se; ++se) for (R = 0; 4 > R; ++R) Ro(D, W, R, se, S);
    }
    function Gl(S, R, D, W) {
      S[R + 0] && Ws(S, R + 0, D, W), S[R + 16] && Ws(S, R + 16, D, W + 4), S[R + 32] && Ws(S, R + 32, D, W + 128), S[R + 48] && Ws(S, R + 48, D, W + 128 + 4);
    }
    function Uc(S, R, D, W) {
      var se, de = s(16);
      for (se = 0; 4 > se; ++se) {
        var ge = S[R + 0 + se] + S[R + 12 + se], _e = S[R + 4 + se] + S[R + 8 + se], xe = S[R + 4 + se] - S[R + 8 + se], Ie = S[R + 0 + se] - S[R + 12 + se];
        de[0 + se] = ge + _e, de[8 + se] = ge - _e, de[4 + se] = Ie + xe, de[12 + se] = Ie - xe;
      }
      for (se = 0; 4 > se; ++se) ge = (S = de[0 + 4 * se] + 3) + de[3 + 4 * se], _e = de[1 + 4 * se] + de[2 + 4 * se], xe = de[1 + 4 * se] - de[2 + 4 * se], Ie = S - de[3 + 4 * se], D[W + 0] = ge + _e >> 3, D[W + 16] = Ie + xe >> 3, D[W + 32] = ge - _e >> 3, D[W + 48] = Ie - xe >> 3, W += 64;
    }
    function oo(S, R, D) {
      var W, se = R - 32, de = os, ge = 255 - S[se - 1];
      for (W = 0; W < D; ++W) {
        var _e, xe = de, Ie = ge + S[R - 1];
        for (_e = 0; _e < D; ++_e) S[R + _e] = xe[Ie + S[se + _e]];
        R += 32;
      }
    }
    function un(S, R) {
      oo(S, R, 4);
    }
    function sa(S, R) {
      oo(S, R, 8);
    }
    function oa(S, R) {
      oo(S, R, 16);
    }
    function $s(S, R) {
      var D;
      for (D = 0; 16 > D; ++D) n(S, R + 32 * D, S, R - 32, 16);
    }
    function bl(S, R) {
      var D;
      for (D = 16; 0 < D; --D) i(S, R, S[R - 1], 16), R += 32;
    }
    function vl(S, R, D) {
      var W;
      for (W = 0; 16 > W; ++W) i(R, D + 32 * W, S, 16);
    }
    function qs(S, R) {
      var D, W = 16;
      for (D = 0; 16 > D; ++D) W += S[R - 1 + 32 * D] + S[R + D - 32];
      vl(W >> 5, S, R);
    }
    function hi(S, R) {
      var D, W = 8;
      for (D = 0; 16 > D; ++D) W += S[R - 1 + 32 * D];
      vl(W >> 4, S, R);
    }
    function hn(S, R) {
      var D, W = 8;
      for (D = 0; 16 > D; ++D) W += S[R + D - 32];
      vl(W >> 4, S, R);
    }
    function xl(S, R) {
      vl(128, S, R);
    }
    function Zr(S, R, D) {
      return S + 2 * R + D + 2 >> 2;
    }
    function Su(S, R) {
      var D, W = R - 32;
      for (W = new Uint8Array([Zr(S[W - 1], S[W + 0], S[W + 1]), Zr(S[W + 0], S[W + 1], S[W + 2]), Zr(S[W + 1], S[W + 2], S[W + 3]), Zr(S[W + 2], S[W + 3], S[W + 4])]), D = 0; 4 > D; ++D) n(S, R + 32 * D, W, 0, W.length);
    }
    function ns(S, R) {
      var D = S[R - 1], W = S[R - 1 + 32], se = S[R - 1 + 64], de = S[R - 1 + 96];
      ar(S, R + 0, 16843009 * Zr(S[R - 1 - 32], D, W)), ar(S, R + 32, 16843009 * Zr(D, W, se)), ar(S, R + 64, 16843009 * Zr(W, se, de)), ar(S, R + 96, 16843009 * Zr(se, de, de));
    }
    function zn(S, R) {
      var D, W = 4;
      for (D = 0; 4 > D; ++D) W += S[R + D - 32] + S[R - 1 + 32 * D];
      for (W >>= 3, D = 0; 4 > D; ++D) i(S, R + 32 * D, W, 4);
    }
    function Wi(S, R) {
      var D = S[R - 1 + 0], W = S[R - 1 + 32], se = S[R - 1 + 64], de = S[R - 1 - 32], ge = S[R + 0 - 32], _e = S[R + 1 - 32], xe = S[R + 2 - 32], Ie = S[R + 3 - 32];
      S[R + 0 + 96] = Zr(W, se, S[R - 1 + 96]), S[R + 1 + 96] = S[R + 0 + 64] = Zr(D, W, se), S[R + 2 + 96] = S[R + 1 + 64] = S[R + 0 + 32] = Zr(de, D, W), S[R + 3 + 96] = S[R + 2 + 64] = S[R + 1 + 32] = S[R + 0 + 0] = Zr(ge, de, D), S[R + 3 + 64] = S[R + 2 + 32] = S[R + 1 + 0] = Zr(_e, ge, de), S[R + 3 + 32] = S[R + 2 + 0] = Zr(xe, _e, ge), S[R + 3 + 0] = Zr(Ie, xe, _e);
    }
    function Ni(S, R) {
      var D = S[R + 1 - 32], W = S[R + 2 - 32], se = S[R + 3 - 32], de = S[R + 4 - 32], ge = S[R + 5 - 32], _e = S[R + 6 - 32], xe = S[R + 7 - 32];
      S[R + 0 + 0] = Zr(S[R + 0 - 32], D, W), S[R + 1 + 0] = S[R + 0 + 32] = Zr(D, W, se), S[R + 2 + 0] = S[R + 1 + 32] = S[R + 0 + 64] = Zr(W, se, de), S[R + 3 + 0] = S[R + 2 + 32] = S[R + 1 + 64] = S[R + 0 + 96] = Zr(se, de, ge), S[R + 3 + 32] = S[R + 2 + 64] = S[R + 1 + 96] = Zr(de, ge, _e), S[R + 3 + 64] = S[R + 2 + 96] = Zr(ge, _e, xe), S[R + 3 + 96] = Zr(_e, xe, xe);
    }
    function jn(S, R) {
      var D = S[R - 1 + 0], W = S[R - 1 + 32], se = S[R - 1 + 64], de = S[R - 1 - 32], ge = S[R + 0 - 32], _e = S[R + 1 - 32], xe = S[R + 2 - 32], Ie = S[R + 3 - 32];
      S[R + 0 + 0] = S[R + 1 + 64] = de + ge + 1 >> 1, S[R + 1 + 0] = S[R + 2 + 64] = ge + _e + 1 >> 1, S[R + 2 + 0] = S[R + 3 + 64] = _e + xe + 1 >> 1, S[R + 3 + 0] = xe + Ie + 1 >> 1, S[R + 0 + 96] = Zr(se, W, D), S[R + 0 + 64] = Zr(W, D, de), S[R + 0 + 32] = S[R + 1 + 96] = Zr(D, de, ge), S[R + 1 + 32] = S[R + 2 + 96] = Zr(de, ge, _e), S[R + 2 + 32] = S[R + 3 + 96] = Zr(ge, _e, xe), S[R + 3 + 32] = Zr(_e, xe, Ie);
    }
    function wl(S, R) {
      var D = S[R + 0 - 32], W = S[R + 1 - 32], se = S[R + 2 - 32], de = S[R + 3 - 32], ge = S[R + 4 - 32], _e = S[R + 5 - 32], xe = S[R + 6 - 32], Ie = S[R + 7 - 32];
      S[R + 0 + 0] = D + W + 1 >> 1, S[R + 1 + 0] = S[R + 0 + 64] = W + se + 1 >> 1, S[R + 2 + 0] = S[R + 1 + 64] = se + de + 1 >> 1, S[R + 3 + 0] = S[R + 2 + 64] = de + ge + 1 >> 1, S[R + 0 + 32] = Zr(D, W, se), S[R + 1 + 32] = S[R + 0 + 96] = Zr(W, se, de), S[R + 2 + 32] = S[R + 1 + 96] = Zr(se, de, ge), S[R + 3 + 32] = S[R + 2 + 96] = Zr(de, ge, _e), S[R + 3 + 64] = Zr(ge, _e, xe), S[R + 3 + 96] = Zr(_e, xe, Ie);
    }
    function pn(S, R) {
      var D = S[R - 1 + 0], W = S[R - 1 + 32], se = S[R - 1 + 64], de = S[R - 1 + 96];
      S[R + 0 + 0] = D + W + 1 >> 1, S[R + 2 + 0] = S[R + 0 + 32] = W + se + 1 >> 1, S[R + 2 + 32] = S[R + 0 + 64] = se + de + 1 >> 1, S[R + 1 + 0] = Zr(D, W, se), S[R + 3 + 0] = S[R + 1 + 32] = Zr(W, se, de), S[R + 3 + 32] = S[R + 1 + 64] = Zr(se, de, de), S[R + 3 + 64] = S[R + 2 + 64] = S[R + 0 + 96] = S[R + 1 + 96] = S[R + 2 + 96] = S[R + 3 + 96] = de;
    }
    function Ps(S, R) {
      var D = S[R - 1 + 0], W = S[R - 1 + 32], se = S[R - 1 + 64], de = S[R - 1 + 96], ge = S[R - 1 - 32], _e = S[R + 0 - 32], xe = S[R + 1 - 32], Ie = S[R + 2 - 32];
      S[R + 0 + 0] = S[R + 2 + 32] = D + ge + 1 >> 1, S[R + 0 + 32] = S[R + 2 + 64] = W + D + 1 >> 1, S[R + 0 + 64] = S[R + 2 + 96] = se + W + 1 >> 1, S[R + 0 + 96] = de + se + 1 >> 1, S[R + 3 + 0] = Zr(_e, xe, Ie), S[R + 2 + 0] = Zr(ge, _e, xe), S[R + 1 + 0] = S[R + 3 + 32] = Zr(D, ge, _e), S[R + 1 + 32] = S[R + 3 + 64] = Zr(W, D, ge), S[R + 1 + 64] = S[R + 3 + 96] = Zr(se, W, D), S[R + 1 + 96] = Zr(de, se, W);
    }
    function Wr(S, R) {
      var D;
      for (D = 0; 8 > D; ++D) n(S, R + 32 * D, S, R - 32, 8);
    }
    function Yr(S, R) {
      var D;
      for (D = 0; 8 > D; ++D) i(S, R, S[R - 1], 8), R += 32;
    }
    function bo(S, R, D) {
      var W;
      for (W = 0; 8 > W; ++W) i(R, D + 32 * W, S, 8);
    }
    function Or(S, R) {
      var D, W = 8;
      for (D = 0; 8 > D; ++D) W += S[R + D - 32] + S[R - 1 + 32 * D];
      bo(W >> 4, S, R);
    }
    function Za(S, R) {
      var D, W = 4;
      for (D = 0; 8 > D; ++D) W += S[R + D - 32];
      bo(W >> 3, S, R);
    }
    function Di(S, R) {
      var D, W = 4;
      for (D = 0; 8 > D; ++D) W += S[R - 1 + 32 * D];
      bo(W >> 3, S, R);
    }
    function Ta(S, R) {
      bo(128, S, R);
    }
    function bs(S, R, D) {
      var W = S[R - D], se = S[R + 0], de = 3 * (se - W) + ch[1020 + S[R - 2 * D] - S[R + D]], ge = rl[112 + (de + 4 >> 3)];
      S[R - D] = os[255 + W + rl[112 + (de + 3 >> 3)]], S[R + 0] = os[255 + se - ge];
    }
    function zc(S, R, D, W) {
      var se = S[R + 0], de = S[R + D];
      return co[255 + S[R - 2 * D] - S[R - D]] > W || co[255 + de - se] > W;
    }
    function vo(S, R, D, W) {
      return 4 * co[255 + S[R - D] - S[R + 0]] + co[255 + S[R - 2 * D] - S[R + D]] <= W;
    }
    function Eu(S, R, D, W, se) {
      var de = S[R - 3 * D], ge = S[R - 2 * D], _e = S[R - D], xe = S[R + 0], Ie = S[R + D], Re = S[R + 2 * D], At = S[R + 3 * D];
      return 4 * co[255 + _e - xe] + co[255 + ge - Ie] > W ? 0 : co[255 + S[R - 4 * D] - de] <= se && co[255 + de - ge] <= se && co[255 + ge - _e] <= se && co[255 + At - Re] <= se && co[255 + Re - Ie] <= se && co[255 + Ie - xe] <= se;
    }
    function Cu(S, R, D, W) {
      var se = 2 * W + 1;
      for (W = 0; 16 > W; ++W) vo(S, R + W, D, se) && bs(S, R + W, D);
    }
    function ao(S, R, D, W) {
      var se = 2 * W + 1;
      for (W = 0; 16 > W; ++W) vo(S, R + W * D, 1, se) && bs(S, R + W * D, 1);
    }
    function xo(S, R, D, W) {
      var se;
      for (se = 3; 0 < se; --se) Cu(S, R += 4 * D, D, W);
    }
    function wo(S, R, D, W) {
      var se;
      for (se = 3; 0 < se; --se) ao(S, R += 4, D, W);
    }
    function ai(S, R, D, W, se, de, ge, _e) {
      for (de = 2 * de + 1; 0 < se--; ) {
        if (Eu(S, R, D, de, ge)) if (zc(S, R, D, _e)) bs(S, R, D);
        else {
          var xe = S, Ie = R, Re = D, At = xe[Ie - 2 * Re], vt = xe[Ie - Re], at = xe[Ie + 0], Gt = xe[Ie + Re], kt = xe[Ie + 2 * Re], rt = 27 * (qt = ch[1020 + 3 * (at - vt) + ch[1020 + At - Gt]]) + 63 >> 7, Xe = 18 * qt + 63 >> 7, qt = 9 * qt + 63 >> 7;
          xe[Ie - 3 * Re] = os[255 + xe[Ie - 3 * Re] + qt], xe[Ie - 2 * Re] = os[255 + At + Xe], xe[Ie - Re] = os[255 + vt + rt], xe[Ie + 0] = os[255 + at - rt], xe[Ie + Re] = os[255 + Gt - Xe], xe[Ie + 2 * Re] = os[255 + kt - qt];
        }
        R += W;
      }
    }
    function Rs(S, R, D, W, se, de, ge, _e) {
      for (de = 2 * de + 1; 0 < se--; ) {
        if (Eu(S, R, D, de, ge)) if (zc(S, R, D, _e)) bs(S, R, D);
        else {
          var xe = S, Ie = R, Re = D, At = xe[Ie - Re], vt = xe[Ie + 0], at = xe[Ie + Re], Gt = rl[112 + ((kt = 3 * (vt - At)) + 4 >> 3)], kt = rl[112 + (kt + 3 >> 3)], rt = Gt + 1 >> 1;
          xe[Ie - 2 * Re] = os[255 + xe[Ie - 2 * Re] + rt], xe[Ie - Re] = os[255 + At + kt], xe[Ie + 0] = os[255 + vt - Gt], xe[Ie + Re] = os[255 + at - rt];
        }
        R += W;
      }
    }
    function Ya(S, R, D, W, se, de) {
      ai(S, R, D, 1, 16, W, se, de);
    }
    function Bo(S, R, D, W, se, de) {
      ai(S, R, 1, D, 16, W, se, de);
    }
    function Ri(S, R, D, W, se, de) {
      var ge;
      for (ge = 3; 0 < ge; --ge) Rs(S, R += 4 * D, D, 1, 16, W, se, de);
    }
    function Sa(S, R, D, W, se, de) {
      var ge;
      for (ge = 3; 0 < ge; --ge) Rs(S, R += 4, 1, D, 16, W, se, de);
    }
    function Al(S, R, D, W, se, de, ge, _e) {
      ai(S, R, se, 1, 8, de, ge, _e), ai(D, W, se, 1, 8, de, ge, _e);
    }
    function Ea(S, R, D, W, se, de, ge, _e) {
      ai(S, R, 1, se, 8, de, ge, _e), ai(D, W, 1, se, 8, de, ge, _e);
    }
    function Iu(S, R, D, W, se, de, ge, _e) {
      Rs(S, R + 4 * se, se, 1, 8, de, ge, _e), Rs(D, W + 4 * se, se, 1, 8, de, ge, _e);
    }
    function aa(S, R, D, W, se, de, ge, _e) {
      Rs(S, R + 4, 1, se, 8, de, ge, _e), Rs(D, W + 4, 1, se, 8, de, ge, _e);
    }
    function Ca() {
      this.ba = new Bt(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new st(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function Hl() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function Mu() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function is() {
      this.ua = 0, this.Wa = new We(), this.vb = new We(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new Pe(), this.yc = new me();
    }
    function Tl() {
      this.xb = this.a = 0, this.l = new Ha(), this.ca = new Bt(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new ce(), this.Pb = 0, this.wd = new ce(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new is(), this.ab = 0, this.gc = l(4, Mu), this.Oc = 0;
    }
    function ss() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new Ha(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function ji(S, R, D, W, se, de, ge) {
      for (S = S == null ? 0 : S[R + 0], R = 0; R < ge; ++R) se[de + R] = S + D[W + R] & 255, S = se[de + R];
    }
    function Wl(S, R, D, W, se, de, ge) {
      var _e;
      if (S == null) ji(null, null, D, W, se, de, ge);
      else for (_e = 0; _e < ge; ++_e) se[de + _e] = S[R + _e] + D[W + _e] & 255;
    }
    function Lo(S, R, D, W, se, de, ge) {
      if (S == null) ji(null, null, D, W, se, de, ge);
      else {
        var _e, xe = S[R + 0], Ie = xe, Re = xe;
        for (_e = 0; _e < ge; ++_e) Ie = Re + (xe = S[R + _e]) - Ie, Re = D[W + _e] + (-256 & Ie ? 0 > Ie ? 0 : 255 : Ie) & 255, Ie = xe, se[de + _e] = Re;
      }
    }
    function Ia(S, R, D, W) {
      var se = R.width, de = R.o;
      if (e(S != null && R != null), 0 > D || 0 >= W || D + W > de) return null;
      if (!S.Cc) {
        if (S.ga == null) {
          var ge;
          if (S.ga = new ss(), (ge = S.ga == null) || (ge = R.width * R.o, e(S.Gb.length == 0), S.Gb = s(ge), S.Uc = 0, S.Gb == null ? ge = 0 : (S.mb = S.Gb, S.nb = S.Uc, S.rc = null, ge = 1), ge = !ge), !ge) {
            ge = S.ga;
            var _e = S.Fa, xe = S.P, Ie = S.qc, Re = S.mb, At = S.nb, vt = xe + 1, at = Ie - 1, Gt = ge.l;
            if (e(_e != null && Re != null && R != null), Ki[0] = null, Ki[1] = ji, Ki[2] = Wl, Ki[3] = Lo, ge.ca = Re, ge.tb = At, ge.c = R.width, ge.i = R.height, e(0 < ge.c && 0 < ge.i), 1 >= Ie) R = 0;
            else if (ge.$a = _e[xe + 0] >> 0 & 3, ge.Z = _e[xe + 0] >> 2 & 3, ge.Lc = _e[xe + 0] >> 4 & 3, xe = _e[xe + 0] >> 6 & 3, 0 > ge.$a || 1 < ge.$a || 4 <= ge.Z || 1 < ge.Lc || xe) R = 0;
            else if (Gt.put = lr, Gt.ac = Sr, Gt.bc = Er, Gt.ma = ge, Gt.width = R.width, Gt.height = R.height, Gt.Da = R.Da, Gt.v = R.v, Gt.va = R.va, Gt.j = R.j, Gt.o = R.o, ge.$a) e: {
              e(ge.$a == 1), R = Vr();
              t: for (; ; ) {
                if (R == null) {
                  R = 0;
                  break e;
                }
                if (e(ge != null), ge.mc = R, R.c = ge.c, R.i = ge.i, R.l = ge.l, R.l.ma = ge, R.l.width = ge.c, R.l.height = ge.i, R.a = 0, xt(R.m, _e, vt, at), !Gr(ge.c, ge.i, 1, R, null) || (R.ab == 1 && R.gc[0].hc == 3 && oi(R.s) ? (ge.ic = 1, _e = R.c * R.i, R.Ta = null, R.Ua = 0, R.V = s(_e), R.Ba = 0, R.V == null ? (R.a = 1, R = 0) : R = 1) : (ge.ic = 0, R = Hi(R, ge.c)), !R)) break t;
                R = 1;
                break e;
              }
              ge.mc = null, R = 0;
            }
            else R = at >= ge.c * ge.i;
            ge = !R;
          }
          if (ge) return null;
          S.ga.Lc != 1 ? S.Ga = 0 : W = de - D;
        }
        e(S.ga != null), e(D + W <= de);
        e: {
          if (R = (_e = S.ga).c, de = _e.l.o, _e.$a == 0) {
            if (vt = S.rc, at = S.Vc, Gt = S.Fa, xe = S.P + 1 + D * R, Ie = S.mb, Re = S.nb + D * R, e(xe <= S.P + S.qc), _e.Z != 0) for (e(Ki[_e.Z] != null), ge = 0; ge < W; ++ge) Ki[_e.Z](vt, at, Gt, xe, Ie, Re, R), vt = Ie, at = Re, Re += R, xe += R;
            else for (ge = 0; ge < W; ++ge) n(Ie, Re, Gt, xe, R), vt = Ie, at = Re, Re += R, xe += R;
            S.rc = vt, S.Vc = at;
          } else {
            if (e(_e.mc != null), R = D + W, e((ge = _e.mc) != null), e(R <= ge.i), ge.C >= R) R = 1;
            else if (_e.ic || mt(), _e.ic) {
              _e = ge.V, vt = ge.Ba, at = ge.c;
              var kt = ge.i, rt = (Gt = 1, xe = ge.$ / at, Ie = ge.$ % at, Re = ge.m, At = ge.s, ge.$), Xe = at * kt, qt = at * R, Zt = At.wc, Ht = rt < qt ? zr(At, Ie, xe) : null;
              e(rt <= Xe), e(R <= kt), e(oi(At));
              t: for (; ; ) {
                for (; !Re.h && rt < qt; ) {
                  if (Ie & Zt || (Ht = zr(At, Ie, xe)), e(Ht != null), ot(Re), 256 > (kt = Jr(Ht.G[0], Ht.H[0], Re))) _e[vt + rt] = kt, ++rt, ++Ie >= at && (Ie = 0, ++xe <= R && !(xe % 16) && rs(ge, xe));
                  else {
                    if (!(280 > kt)) {
                      Gt = 0;
                      break t;
                    }
                    kt = xn(kt - 256, Re);
                    var Mr, yr = Jr(Ht.G[4], Ht.H[4], Re);
                    if (ot(Re), !(rt >= (yr = dn(at, yr = xn(yr, Re))) && Xe - rt >= kt)) {
                      Gt = 0;
                      break t;
                    }
                    for (Mr = 0; Mr < kt; ++Mr) _e[vt + rt + Mr] = _e[vt + rt + Mr - yr];
                    for (rt += kt, Ie += kt; Ie >= at; ) Ie -= at, ++xe <= R && !(xe % 16) && rs(ge, xe);
                    rt < qt && Ie & Zt && (Ht = zr(At, Ie, xe));
                  }
                  e(Re.h == $e(Re));
                }
                rs(ge, xe > R ? R : xe);
                break t;
              }
              !Gt || Re.h && rt < Xe ? (Gt = 0, ge.a = Re.h ? 5 : 3) : ge.$ = rt, R = Gt;
            } else R = _s(ge, ge.V, ge.Ba, ge.c, ge.i, R, Ga);
            if (!R) {
              W = 0;
              break e;
            }
          }
          D + W >= de && (S.Cc = 1), W = 1;
        }
        if (!W) return null;
        if (S.Cc && ((W = S.ga) != null && (W.mc = null), S.ga = null, 0 < S.Ga)) return alert("todo:WebPDequantizeLevels"), null;
      }
      return S.nb + D * se;
    }
    function O(S, R, D, W, se, de) {
      for (; 0 < se--; ) {
        var ge, _e = S, xe = R + (D ? 1 : 0), Ie = S, Re = R + (D ? 0 : 3);
        for (ge = 0; ge < W; ++ge) {
          var At = Ie[Re + 4 * ge];
          At != 255 && (At *= 32897, _e[xe + 4 * ge + 0] = _e[xe + 4 * ge + 0] * At >> 23, _e[xe + 4 * ge + 1] = _e[xe + 4 * ge + 1] * At >> 23, _e[xe + 4 * ge + 2] = _e[xe + 4 * ge + 2] * At >> 23);
        }
        R += de;
      }
    }
    function ae(S, R, D, W, se) {
      for (; 0 < W--; ) {
        var de;
        for (de = 0; de < D; ++de) {
          var ge = S[R + 2 * de + 0], _e = 15 & (Ie = S[R + 2 * de + 1]), xe = 4369 * _e, Ie = (240 & Ie | Ie >> 4) * xe >> 16;
          S[R + 2 * de + 0] = (240 & ge | ge >> 4) * xe >> 16 & 240 | (15 & ge | ge << 4) * xe >> 16 >> 4 & 15, S[R + 2 * de + 1] = 240 & Ie | _e;
        }
        R += se;
      }
    }
    function Ue(S, R, D, W, se, de, ge, _e) {
      var xe, Ie, Re = 255;
      for (Ie = 0; Ie < se; ++Ie) {
        for (xe = 0; xe < W; ++xe) {
          var At = S[R + xe];
          de[ge + 4 * xe] = At, Re &= At;
        }
        R += D, ge += _e;
      }
      return Re != 255;
    }
    function tt(S, R, D, W, se) {
      var de;
      for (de = 0; de < se; ++de) D[W + de] = S[R + de] >> 8;
    }
    function mt() {
      Ai = O, Yn = ae, Kn = Ue, Ti = tt;
    }
    function jt(S, R, D) {
      he[S] = function(W, se, de, ge, _e, xe, Ie, Re, At, vt, at, Gt, kt, rt, Xe, qt, Zt) {
        var Ht, Mr = Zt - 1 >> 1, yr = _e[xe + 0] | Ie[Re + 0] << 16, $r = At[vt + 0] | at[Gt + 0] << 16;
        e(W != null);
        var br = 3 * yr + $r + 131074 >> 2;
        for (R(W[se + 0], 255 & br, br >> 16, kt, rt), de != null && (br = 3 * $r + yr + 131074 >> 2, R(de[ge + 0], 255 & br, br >> 16, Xe, qt)), Ht = 1; Ht <= Mr; ++Ht) {
          var Pn = _e[xe + Ht] | Ie[Re + Ht] << 16, Fn = At[vt + Ht] | at[Gt + Ht] << 16, wn = yr + Pn + $r + Fn + 524296, Sn = wn + 2 * (Pn + $r) >> 3;
          br = Sn + yr >> 1, yr = (wn = wn + 2 * (yr + Fn) >> 3) + Pn >> 1, R(W[se + 2 * Ht - 1], 255 & br, br >> 16, kt, rt + (2 * Ht - 1) * D), R(W[se + 2 * Ht - 0], 255 & yr, yr >> 16, kt, rt + (2 * Ht - 0) * D), de != null && (br = wn + $r >> 1, yr = Sn + Fn >> 1, R(de[ge + 2 * Ht - 1], 255 & br, br >> 16, Xe, qt + (2 * Ht - 1) * D), R(de[ge + 2 * Ht + 0], 255 & yr, yr >> 16, Xe, qt + (2 * Ht + 0) * D)), yr = Pn, $r = Fn;
        }
        1 & Zt || (br = 3 * yr + $r + 131074 >> 2, R(W[se + Zt - 1], 255 & br, br >> 16, kt, rt + (Zt - 1) * D), de != null && (br = 3 * $r + yr + 131074 >> 2, R(de[ge + Zt - 1], 255 & br, br >> 16, Xe, qt + (Zt - 1) * D)));
      };
    }
    function Jt() {
      Xs[Gc] = zu, Xs[cn] = ic, Xs[Ml] = Yc, Xs[Lu] = ph, Xs[Ou] = Kc, Xs[rc] = gh, Xs[Jf] = rd, Xs[Qh] = ic, Xs[uh] = ph, Xs[ku] = Kc, Xs[Hc] = gh;
    }
    function wr(S) {
      return S & -16384 ? 0 > S ? 0 : 255 : S >> da;
    }
    function Fr(S, R) {
      return wr((19077 * S >> 8) + (26149 * R >> 8) - 14234);
    }
    function sn(S, R, D) {
      return wr((19077 * S >> 8) - (6419 * R >> 8) - (13320 * D >> 8) + 8708);
    }
    function Qr(S, R) {
      return wr((19077 * S >> 8) + (33050 * R >> 8) - 17685);
    }
    function ln(S, R, D, W, se) {
      W[se + 0] = Fr(S, D), W[se + 1] = sn(S, R, D), W[se + 2] = Qr(S, R);
    }
    function vi(S, R, D, W, se) {
      W[se + 0] = Qr(S, R), W[se + 1] = sn(S, R, D), W[se + 2] = Fr(S, D);
    }
    function xi(S, R, D, W, se) {
      var de = sn(S, R, D);
      R = de << 3 & 224 | Qr(S, R) >> 3, W[se + 0] = 248 & Fr(S, D) | de >> 5, W[se + 1] = R;
    }
    function fi(S, R, D, W, se) {
      var de = 240 & Qr(S, R) | 15;
      W[se + 0] = 240 & Fr(S, D) | sn(S, R, D) >> 4, W[se + 1] = de;
    }
    function Vi(S, R, D, W, se) {
      W[se + 0] = 255, ln(S, R, D, W, se + 1);
    }
    function Xi(S, R, D, W, se) {
      vi(S, R, D, W, se), W[se + 3] = 255;
    }
    function Gs(S, R, D, W, se) {
      ln(S, R, D, W, se), W[se + 3] = 255;
    }
    function Ao(S, R) {
      return 0 > S ? 0 : S > R ? R : S;
    }
    function Hs(S, R, D) {
      he[S] = function(W, se, de, ge, _e, xe, Ie, Re, At) {
        for (var vt = Re + (-2 & At) * D; Re != vt; ) R(W[se + 0], de[ge + 0], _e[xe + 0], Ie, Re), R(W[se + 1], de[ge + 0], _e[xe + 0], Ie, Re + D), se += 2, ++ge, ++xe, Re += 2 * D;
        1 & At && R(W[se + 0], de[ge + 0], _e[xe + 0], Ie, Re);
      };
    }
    function oh(S, R, D) {
      return D == 0 ? S == 0 ? R == 0 ? 6 : 5 : R == 0 ? 4 : 0 : D;
    }
    function jc(S, R, D, W, se) {
      switch (S >>> 30) {
        case 3:
          ua(R, D, W, se, 0);
          break;
        case 2:
          Zn(R, D, W, se);
          break;
        case 1:
          Ws(R, D, W, se);
      }
    }
    function Pu(S, R) {
      var D, W, se = R.M, de = R.Nb, ge = S.oc, _e = S.pc + 40, xe = S.oc, Ie = S.pc + 584, Re = S.oc, At = S.pc + 600;
      for (D = 0; 16 > D; ++D) ge[_e + 32 * D - 1] = 129;
      for (D = 0; 8 > D; ++D) xe[Ie + 32 * D - 1] = 129, Re[At + 32 * D - 1] = 129;
      for (0 < se ? ge[_e - 1 - 32] = xe[Ie - 1 - 32] = Re[At - 1 - 32] = 129 : (i(ge, _e - 32 - 1, 127, 21), i(xe, Ie - 32 - 1, 127, 9), i(Re, At - 32 - 1, 127, 9)), W = 0; W < S.za; ++W) {
        var vt = R.ya[R.aa + W];
        if (0 < W) {
          for (D = -1; 16 > D; ++D) n(ge, _e + 32 * D - 4, ge, _e + 32 * D + 12, 4);
          for (D = -1; 8 > D; ++D) n(xe, Ie + 32 * D - 4, xe, Ie + 32 * D + 4, 4), n(Re, At + 32 * D - 4, Re, At + 32 * D + 4, 4);
        }
        var at = S.Gd, Gt = S.Hd + W, kt = vt.ad, rt = vt.Hc;
        if (0 < se && (n(ge, _e - 32, at[Gt].y, 0, 16), n(xe, Ie - 32, at[Gt].f, 0, 8), n(Re, At - 32, at[Gt].ea, 0, 8)), vt.Za) {
          var Xe = ge, qt = _e - 32 + 16;
          for (0 < se && (W >= S.za - 1 ? i(Xe, qt, at[Gt].y[15], 4) : n(Xe, qt, at[Gt + 1].y, 0, 4)), D = 0; 4 > D; D++) Xe[qt + 128 + D] = Xe[qt + 256 + D] = Xe[qt + 384 + D] = Xe[qt + 0 + D];
          for (D = 0; 16 > D; ++D, rt <<= 2) Xe = ge, qt = _e + Vu[D], uo[vt.Ob[D]](Xe, qt), jc(rt, kt, 16 * +D, Xe, qt);
        } else if (Xe = oh(W, se, vt.Ob[0]), fa[Xe](ge, _e), rt != 0) for (D = 0; 16 > D; ++D, rt <<= 2) jc(rt, kt, 16 * +D, ge, _e + Vu[D]);
        for (D = vt.Gc, Xe = oh(W, se, vt.Dd), La[Xe](xe, Ie), La[Xe](Re, At), rt = kt, Xe = xe, qt = Ie, 255 & (vt = D >> 0) && (170 & vt ? ec(rt, 256, Xe, qt) : ko(rt, 256, Xe, qt)), vt = Re, rt = At, 255 & (D >>= 8) && (170 & D ? ec(kt, 320, vt, rt) : ko(kt, 320, vt, rt)), se < S.Ub - 1 && (n(at[Gt].y, 0, ge, _e + 480, 16), n(at[Gt].f, 0, xe, Ie + 224, 8), n(at[Gt].ea, 0, Re, At + 224, 8)), D = 8 * de * S.B, at = S.sa, Gt = S.ta + 16 * W + 16 * de * S.R, kt = S.qa, vt = S.ra + 8 * W + D, rt = S.Ha, Xe = S.Ia + 8 * W + D, D = 0; 16 > D; ++D) n(at, Gt + D * S.R, ge, _e + 32 * D, 16);
        for (D = 0; 8 > D; ++D) n(kt, vt + D * S.B, xe, Ie + 32 * D, 8), n(rt, Xe + D * S.B, Re, At + 32 * D, 8);
      }
    }
    function Ka(S, R, D, W, se, de, ge, _e, xe) {
      var Ie = [0], Re = [0], At = 0, vt = xe != null ? xe.kd : 0, at = xe ?? new Hl();
      if (S == null || 12 > D) return 7;
      at.data = S, at.w = R, at.ha = D, R = [R], D = [D], at.gb = [at.gb];
      e: {
        var Gt = R, kt = D, rt = at.gb;
        if (e(S != null), e(kt != null), e(rt != null), rt[0] = 0, 12 <= kt[0] && !t(S, Gt[0], "RIFF")) {
          if (t(S, Gt[0] + 8, "WEBP")) {
            rt = 3;
            break e;
          }
          var Xe = sr(S, Gt[0] + 4);
          if (12 > Xe || 4294967286 < Xe) {
            rt = 3;
            break e;
          }
          if (vt && Xe > kt[0] - 8) {
            rt = 7;
            break e;
          }
          rt[0] = Xe, Gt[0] += 12, kt[0] -= 12;
        }
        rt = 0;
      }
      if (rt != 0) return rt;
      for (Xe = 0 < at.gb[0], D = D[0]; ; ) {
        e: {
          var qt = S;
          kt = R, rt = D;
          var Zt = Ie, Ht = Re, Mr = Gt = [0];
          if ((br = At = [At])[0] = 0, 8 > rt[0]) rt = 7;
          else {
            if (!t(qt, kt[0], "VP8X")) {
              if (sr(qt, kt[0] + 4) != 10) {
                rt = 3;
                break e;
              }
              if (18 > rt[0]) {
                rt = 7;
                break e;
              }
              var yr = sr(qt, kt[0] + 8), $r = 1 + vr(qt, kt[0] + 12);
              if (2147483648 <= $r * (qt = 1 + vr(qt, kt[0] + 15))) {
                rt = 3;
                break e;
              }
              Mr != null && (Mr[0] = yr), Zt != null && (Zt[0] = $r), Ht != null && (Ht[0] = qt), kt[0] += 18, rt[0] -= 18, br[0] = 1;
            }
            rt = 0;
          }
        }
        if (At = At[0], Gt = Gt[0], rt != 0) return rt;
        if (kt = !!(2 & Gt), !Xe && At) return 3;
        if (de != null && (de[0] = !!(16 & Gt)), ge != null && (ge[0] = kt), _e != null && (_e[0] = 0), ge = Ie[0], Gt = Re[0], At && kt && xe == null) {
          rt = 0;
          break;
        }
        if (4 > D) {
          rt = 7;
          break;
        }
        if (Xe && At || !Xe && !At && !t(S, R[0], "ALPH")) {
          D = [D], at.na = [at.na], at.P = [at.P], at.Sa = [at.Sa];
          e: {
            yr = S, rt = R, Xe = D;
            var br = at.gb;
            Zt = at.na, Ht = at.P, Mr = at.Sa, $r = 22, e(yr != null), e(Xe != null), qt = rt[0];
            var Pn = Xe[0];
            for (e(Zt != null), e(Mr != null), Zt[0] = null, Ht[0] = null, Mr[0] = 0; ; ) {
              if (rt[0] = qt, Xe[0] = Pn, 8 > Pn) {
                rt = 7;
                break e;
              }
              var Fn = sr(yr, qt + 4);
              if (4294967286 < Fn) {
                rt = 3;
                break e;
              }
              var wn = 8 + Fn + 1 & -2;
              if ($r += wn, 0 < br && $r > br) {
                rt = 3;
                break e;
              }
              if (!t(yr, qt, "VP8 ") || !t(yr, qt, "VP8L")) {
                rt = 0;
                break e;
              }
              if (Pn[0] < wn) {
                rt = 7;
                break e;
              }
              t(yr, qt, "ALPH") || (Zt[0] = yr, Ht[0] = qt + 8, Mr[0] = Fn), qt += wn, Pn -= wn;
            }
          }
          if (D = D[0], at.na = at.na[0], at.P = at.P[0], at.Sa = at.Sa[0], rt != 0) break;
        }
        D = [D], at.Ja = [at.Ja], at.xa = [at.xa];
        e: if (br = S, rt = R, Xe = D, Zt = at.gb[0], Ht = at.Ja, Mr = at.xa, yr = rt[0], qt = !t(br, yr, "VP8 "), $r = !t(br, yr, "VP8L"), e(br != null), e(Xe != null), e(Ht != null), e(Mr != null), 8 > Xe[0]) rt = 7;
        else {
          if (qt || $r) {
            if (br = sr(br, yr + 4), 12 <= Zt && br > Zt - 12) {
              rt = 3;
              break e;
            }
            if (vt && br > Xe[0] - 8) {
              rt = 7;
              break e;
            }
            Ht[0] = br, rt[0] += 8, Xe[0] -= 8, Mr[0] = $r;
          } else Mr[0] = 5 <= Xe[0] && br[yr + 0] == 47 && !(br[yr + 4] >> 5), Ht[0] = Xe[0];
          rt = 0;
        }
        if (D = D[0], at.Ja = at.Ja[0], at.xa = at.xa[0], R = R[0], rt != 0) break;
        if (4294967286 < at.Ja) return 3;
        if (_e == null || kt || (_e[0] = at.xa ? 2 : 1), ge = [ge], Gt = [Gt], at.xa) {
          if (5 > D) {
            rt = 7;
            break;
          }
          _e = ge, vt = Gt, kt = de, S == null || 5 > D ? S = 0 : 5 <= D && S[R + 0] == 47 && !(S[R + 4] >> 5) ? (Xe = [0], br = [0], Zt = [0], xt(Ht = new ce(), S, R, D), tr(Ht, Xe, br, Zt) ? (_e != null && (_e[0] = Xe[0]), vt != null && (vt[0] = br[0]), kt != null && (kt[0] = Zt[0]), S = 1) : S = 0) : S = 0;
        } else {
          if (10 > D) {
            rt = 7;
            break;
          }
          _e = Gt, S == null || 10 > D || !xu(S, R + 3, D - 3) ? S = 0 : (vt = S[R + 0] | S[R + 1] << 8 | S[R + 2] << 16, kt = 16383 & (S[R + 7] << 8 | S[R + 6]), S = 16383 & (S[R + 9] << 8 | S[R + 8]), 1 & vt || 3 < (vt >> 1 & 7) || !(vt >> 4 & 1) || vt >> 5 >= at.Ja || !kt || !S ? S = 0 : (ge && (ge[0] = kt), _e && (_e[0] = S), S = 1));
        }
        if (!S || (ge = ge[0], Gt = Gt[0], At && (Ie[0] != ge || Re[0] != Gt))) return 3;
        xe != null && (xe[0] = at, xe.offset = R - xe.w, e(4294967286 > R - xe.w), e(xe.offset == xe.ha - D));
        break;
      }
      return rt == 0 || rt == 7 && At && xe == null ? (de != null && (de[0] |= at.na != null && 0 < at.na.length), W != null && (W[0] = ge), se != null && (se[0] = Gt), 0) : rt;
    }
    function Xl(S, R, D) {
      var W = R.width, se = R.height, de = 0, ge = 0, _e = W, xe = se;
      if (R.Da = S != null && 0 < S.Da, R.Da && (_e = S.cd, xe = S.bd, de = S.v, ge = S.j, 11 > D || (de &= -2, ge &= -2), 0 > de || 0 > ge || 0 >= _e || 0 >= xe || de + _e > W || ge + xe > se)) return 0;
      if (R.v = de, R.j = ge, R.va = de + _e, R.o = ge + xe, R.U = _e, R.T = xe, R.da = S != null && 0 < S.da, R.da) {
        if (!Dr(_e, xe, D = [S.ib], de = [S.hb])) return 0;
        R.ib = D[0], R.hb = de[0];
      }
      return R.ob = S != null && S.ob, R.Kb = S == null || !S.Sd, R.da && (R.ob = R.ib < 3 * W / 4 && R.hb < 3 * se / 4, R.Kb = 0), 1;
    }
    function Vc(S) {
      if (S == null) return 2;
      if (11 > S.S) {
        var R = S.f.RGBA;
        R.fb += (S.height - 1) * R.A, R.A = -R.A;
      } else R = S.f.kb, S = S.height, R.O += (S - 1) * R.fa, R.fa = -R.fa, R.N += (S - 1 >> 1) * R.Ab, R.Ab = -R.Ab, R.W += (S - 1 >> 1) * R.Db, R.Db = -R.Db, R.F != null && (R.J += (S - 1) * R.lb, R.lb = -R.lb);
      return 0;
    }
    function Zl(S, R, D, W) {
      if (W == null || 0 >= S || 0 >= R) return 2;
      if (D != null) {
        if (D.Da) {
          var se = D.cd, de = D.bd, ge = -2 & D.v, _e = -2 & D.j;
          if (0 > ge || 0 > _e || 0 >= se || 0 >= de || ge + se > S || _e + de > R) return 2;
          S = se, R = de;
        }
        if (D.da) {
          if (!Dr(S, R, se = [D.ib], de = [D.hb])) return 2;
          S = se[0], R = de[0];
        }
      }
      W.width = S, W.height = R;
      e: {
        var xe = W.width, Ie = W.height;
        if (S = W.S, 0 >= xe || 0 >= Ie || !(S >= Gc && 13 > S)) S = 2;
        else {
          if (0 >= W.Rd && W.sd == null) {
            ge = de = se = R = 0;
            var Re = (_e = xe * Uo[S]) * Ie;
            if (11 > S || (de = (Ie + 1) / 2 * (R = (xe + 1) / 2), S == 12 && (ge = (se = xe) * Ie)), (Ie = s(Re + 2 * de + ge)) == null) {
              S = 1;
              break e;
            }
            W.sd = Ie, 11 > S ? ((xe = W.f.RGBA).eb = Ie, xe.fb = 0, xe.A = _e, xe.size = Re) : ((xe = W.f.kb).y = Ie, xe.O = 0, xe.fa = _e, xe.Fd = Re, xe.f = Ie, xe.N = 0 + Re, xe.Ab = R, xe.Cd = de, xe.ea = Ie, xe.W = 0 + Re + de, xe.Db = R, xe.Ed = de, S == 12 && (xe.F = Ie, xe.J = 0 + Re + 2 * de), xe.Tc = ge, xe.lb = se);
          }
          if (R = 1, se = W.S, de = W.width, ge = W.height, se >= Gc && 13 > se)
            if (11 > se) S = W.f.RGBA, R &= (_e = Math.abs(S.A)) * (ge - 1) + de <= S.size, R &= _e >= de * Uo[se], R &= S.eb != null;
            else {
              S = W.f.kb, _e = (de + 1) / 2, Re = (ge + 1) / 2, xe = Math.abs(S.fa), Ie = Math.abs(S.Ab);
              var At = Math.abs(S.Db), vt = Math.abs(S.lb), at = vt * (ge - 1) + de;
              R &= xe * (ge - 1) + de <= S.Fd, R &= Ie * (Re - 1) + _e <= S.Cd, R = (R &= At * (Re - 1) + _e <= S.Ed) & xe >= de & Ie >= _e & At >= _e, R &= S.y != null, R &= S.f != null, R &= S.ea != null, se == 12 && (R &= vt >= de, R &= at <= S.Tc, R &= S.F != null);
            }
          else R = 0;
          S = R ? 0 : 2;
        }
      }
      return S != 0 || D != null && D.fd && (S = Vc(W)), S;
    }
    var Zi = 64, Sl = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], Oo = 24, Yl = 32, Kl = 8, Yi = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    pr("Predictor0", "PredictorAdd0"), he.Predictor0 = function() {
      return 4278190080;
    }, he.Predictor1 = function(S) {
      return S;
    }, he.Predictor2 = function(S, R, D) {
      return R[D + 0];
    }, he.Predictor3 = function(S, R, D) {
      return R[D + 1];
    }, he.Predictor4 = function(S, R, D) {
      return R[D - 1];
    }, he.Predictor5 = function(S, R, D) {
      return _r(_r(S, R[D + 1]), R[D + 0]);
    }, he.Predictor6 = function(S, R, D) {
      return _r(S, R[D - 1]);
    }, he.Predictor7 = function(S, R, D) {
      return _r(S, R[D + 0]);
    }, he.Predictor8 = function(S, R, D) {
      return _r(R[D - 1], R[D + 0]);
    }, he.Predictor9 = function(S, R, D) {
      return _r(R[D + 0], R[D + 1]);
    }, he.Predictor10 = function(S, R, D) {
      return _r(_r(S, R[D - 1]), _r(R[D + 0], R[D + 1]));
    }, he.Predictor11 = function(S, R, D) {
      var W = R[D + 0];
      return 0 >= Kr(W >> 24 & 255, S >> 24 & 255, (R = R[D - 1]) >> 24 & 255) + Kr(W >> 16 & 255, S >> 16 & 255, R >> 16 & 255) + Kr(W >> 8 & 255, S >> 8 & 255, R >> 8 & 255) + Kr(255 & W, 255 & S, 255 & R) ? W : S;
    }, he.Predictor12 = function(S, R, D) {
      var W = R[D + 0];
      return (Lr((S >> 24 & 255) + (W >> 24 & 255) - ((R = R[D - 1]) >> 24 & 255)) << 24 | Lr((S >> 16 & 255) + (W >> 16 & 255) - (R >> 16 & 255)) << 16 | Lr((S >> 8 & 255) + (W >> 8 & 255) - (R >> 8 & 255)) << 8 | Lr((255 & S) + (255 & W) - (255 & R))) >>> 0;
    }, he.Predictor13 = function(S, R, D) {
      var W = R[D - 1];
      return (qr((S = _r(S, R[D + 0])) >> 24 & 255, W >> 24 & 255) << 24 | qr(S >> 16 & 255, W >> 16 & 255) << 16 | qr(S >> 8 & 255, W >> 8 & 255) << 8 | qr(S >> 0 & 255, W >> 0 & 255)) >>> 0;
    };
    var Jh = he.PredictorAdd0;
    he.PredictorAdd1 = en, pr("Predictor2", "PredictorAdd2"), pr("Predictor3", "PredictorAdd3"), pr("Predictor4", "PredictorAdd4"), pr("Predictor5", "PredictorAdd5"), pr("Predictor6", "PredictorAdd6"), pr("Predictor7", "PredictorAdd7"), pr("Predictor8", "PredictorAdd8"), pr("Predictor9", "PredictorAdd9"), pr("Predictor10", "PredictorAdd10"), pr("Predictor11", "PredictorAdd11"), pr("Predictor12", "PredictorAdd12"), pr("Predictor13", "PredictorAdd13");
    var El = he.PredictorAdd2;
    fn("ColorIndexInverseTransform", "MapARGB", "32b", function(S) {
      return S >> 8 & 255;
    }, function(S) {
      return S;
    }), fn("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(S) {
      return S;
    }, function(S) {
      return S >> 8 & 255;
    });
    var ah, To = he.ColorIndexInverseTransform, Jl = he.MapARGB, Ru = he.VP8LColorIndexInverseTransformAlpha, Bu = he.MapAlpha, Ma = he.VP8LPredictorsAdd = [];
    Ma.length = 16, (he.VP8LPredictors = []).length = 16, (he.VP8LPredictorsAdd_C = []).length = 16, (he.VP8LPredictors_C = []).length = 16;
    var mn, vs, wi, Pa, la, ca, Ql, ua, Zn, ec, Ws, ko, $c, lh, qc, tc, Cl, ha, Ra, Ja, Qa, lo, el, xs, Ai, Yn, Kn, Ti, li = s(511), No = s(2041), Il = s(225), Ba = s(767), tl = 0, ch = No, rl = Il, os = Ba, co = li, Gc = 0, cn = 1, Ml = 2, Lu = 3, Ou = 4, rc = 5, Jf = 6, Qh = 7, uh = 8, ku = 9, Hc = 10, hh = [2, 3, 7], fh = [3, 3, 11], Wc = [280, 256, 256, 256, 40], dh = [0, 1, 1, 1, 0], ef = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], Nu = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], Xc = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], Zc = 8, nc = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], Du = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], Do = null, Ap = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], Qf = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], Fu = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], tf = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], ed = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], td = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], Uu = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], fa = [], uo = [], La = [], Si = 1, nl = 2, Ki = [], Xs = [];
    jt("UpsampleRgbLinePair", ln, 3), jt("UpsampleBgrLinePair", vi, 3), jt("UpsampleRgbaLinePair", Gs, 4), jt("UpsampleBgraLinePair", Xi, 4), jt("UpsampleArgbLinePair", Vi, 4), jt("UpsampleRgba4444LinePair", fi, 2), jt("UpsampleRgb565LinePair", xi, 2);
    var zu = he.UpsampleRgbLinePair, Yc = he.UpsampleBgrLinePair, ic = he.UpsampleRgbaLinePair, ph = he.UpsampleBgraLinePair, Kc = he.UpsampleArgbLinePair, gh = he.UpsampleRgba4444LinePair, rd = he.UpsampleRgb565LinePair, ju = 16, il = 1 << ju - 1, Oa = -227, Bs = 482, da = 6, mh = 0, nd = s(256), id = s(256), Jc = s(256), rf = s(256), _h = s(Bs - Oa), sd = s(Bs - Oa);
    Hs("YuvToRgbRow", ln, 3), Hs("YuvToBgrRow", vi, 3), Hs("YuvToRgbaRow", Gs, 4), Hs("YuvToBgraRow", Xi, 4), Hs("YuvToArgbRow", Vi, 4), Hs("YuvToRgba4444Row", fi, 2), Hs("YuvToRgb565Row", xi, 2);
    var Vu = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], sc = [0, 2, 8], Qc = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], Fo = 1;
    this.WebPDecodeRGBA = function(S, R, D, W, se) {
      var de = cn, ge = new Ca(), _e = new Bt();
      ge.ba = _e, _e.S = de, _e.width = [_e.width], _e.height = [_e.height];
      var xe = _e.width, Ie = _e.height, Re = new Pt();
      if (Re == null || S == null) var At = 2;
      else e(Re != null), At = Ka(S, R, D, Re.width, Re.height, Re.Pd, Re.Qd, Re.format, null);
      if (At != 0 ? xe = 0 : (xe != null && (xe[0] = Re.width[0]), Ie != null && (Ie[0] = Re.height[0]), xe = 1), xe) {
        _e.width = _e.width[0], _e.height = _e.height[0], W != null && (W[0] = _e.width), se != null && (se[0] = _e.height);
        e: {
          if (W = new Ha(), (se = new Hl()).data = S, se.w = R, se.ha = D, se.kd = 1, R = [0], e(se != null), ((S = Ka(se.data, se.w, se.ha, null, null, null, R, null, se)) == 0 || S == 7) && R[0] && (S = 4), (R = S) == 0) {
            if (e(ge != null), W.data = se.data, W.w = se.w + se.offset, W.ha = se.ha - se.offset, W.put = lr, W.ac = Sr, W.bc = Er, W.ma = ge, se.xa) {
              if ((S = Vr()) == null) {
                ge = 1;
                break e;
              }
              if (function(vt, at) {
                var Gt = [0], kt = [0], rt = [0];
                t: for (; ; ) {
                  if (vt == null) return 0;
                  if (at == null) return vt.a = 2, 0;
                  if (vt.l = at, vt.a = 0, xt(vt.m, at.data, at.w, at.ha), !tr(vt.m, Gt, kt, rt)) {
                    vt.a = 3;
                    break t;
                  }
                  if (vt.xb = nl, at.width = Gt[0], at.height = kt[0], !Gr(Gt[0], kt[0], 1, vt, null)) break t;
                  return 1;
                }
                return e(vt.a != 0), 0;
              }(S, W)) {
                if (W = (R = Zl(W.width, W.height, ge.Oa, ge.ba)) == 0) {
                  t: {
                    W = S;
                    r: for (; ; ) {
                      if (W == null) {
                        W = 0;
                        break t;
                      }
                      if (e(W.s.yc != null), e(W.s.Ya != null), e(0 < W.s.Wb), e((D = W.l) != null), e((se = D.ma) != null), W.xb != 0) {
                        if (W.ca = se.ba, W.tb = se.tb, e(W.ca != null), !Xl(se.Oa, D, Lu)) {
                          W.a = 2;
                          break r;
                        }
                        if (!Hi(W, D.width) || D.da) break r;
                        if ((D.da || Qe(W.ca.S)) && mt(), 11 > W.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), W.ca.f.kb.F != null && mt()), W.Pb && 0 < W.s.ua && W.s.vb.X == null && !Ur(W.s.vb, W.s.Wa.Xa)) {
                          W.a = 1;
                          break r;
                        }
                        W.xb = 0;
                      }
                      if (!_s(W, W.V, W.Ba, W.c, W.i, D.o, er)) break r;
                      se.Dc = W.Ma, W = 1;
                      break t;
                    }
                    e(W.a != 0), W = 0;
                  }
                  W = !W;
                }
                W && (R = S.a);
              } else R = S.a;
            } else {
              if ((S = new Wa()) == null) {
                ge = 1;
                break e;
              }
              if (S.Fa = se.na, S.P = se.P, S.qc = se.Sa, wu(S, W)) {
                if ((R = Zl(W.width, W.height, ge.Oa, ge.ba)) == 0) {
                  if (S.Aa = 0, D = ge.Oa, e((se = S) != null), D != null) {
                    if (0 < (xe = 0 > (xe = D.Md) ? 0 : 100 < xe ? 255 : 255 * xe / 100)) {
                      for (Ie = Re = 0; 4 > Ie; ++Ie) 12 > (At = se.pb[Ie]).lc && (At.ia = xe * Qc[0 > At.lc ? 0 : At.lc] >> 3), Re |= At.ia;
                      Re && (alert("todo:VP8InitRandom"), se.ia = 1);
                    }
                    se.Ga = D.Id, 100 < se.Ga ? se.Ga = 100 : 0 > se.Ga && (se.Ga = 0);
                  }
                  ih(S, W) || (R = S.a);
                }
              } else R = S.a;
            }
            R == 0 && ge.Oa != null && ge.Oa.fd && (R = Vc(ge.ba));
          }
          ge = R;
        }
        de = ge != 0 ? null : 11 > de ? _e.f.RGBA.eb : _e.f.kb.y;
      } else de = null;
      return de;
    };
    var Uo = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function m(he, Be) {
    for (var ke = "", pe = 0; pe < 4; pe++) ke += String.fromCharCode(he[Be++]);
    return ke;
  }
  function b(he, Be) {
    return (he[Be + 0] << 0 | he[Be + 1] << 8 | he[Be + 2] << 16) >>> 0;
  }
  function A(he, Be) {
    return (he[Be + 0] << 0 | he[Be + 1] << 8 | he[Be + 2] << 16 | he[Be + 3] << 24) >>> 0;
  }
  new d();
  var M = [0], E = [0], k = [], U = new d(), V = r, q = function(he, Be) {
    var ke = {}, pe = 0, me = !1, je = 0, Pe = 0;
    if (ke.frames = [], !/** @license
     * Copyright (c) 2017 Dominik Homberger
    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    https://webpjs.appspot.com
    WebPRiffParser dominikhlbg@gmail.com
    */
    function(Oe, $e, et, ot) {
      for (var ht = 0; ht < ot; ht++) if (Oe[$e + ht] != et.charCodeAt(ht)) return !0;
      return !1;
    }(he, Be, "RIFF", 4)) {
      var St, Mt;
      for (A(he, Be += 4), Be += 8; Be < he.length; ) {
        var Lt = m(he, Be), xt = A(he, Be += 4);
        Be += 4;
        var zt = xt + (1 & xt);
        switch (Lt) {
          case "VP8 ":
          case "VP8L":
            ke.frames[pe] === void 0 && (ke.frames[pe] = {}), (ce = ke.frames[pe]).src_off = me ? Pe : Be - 8, ce.src_size = je + xt + 8, pe++, me && (me = !1, je = 0, Pe = 0);
            break;
          case "VP8X":
            (ce = ke.header = {}).feature_flags = he[Be];
            var Dt = Be + 4;
            ce.canvas_width = 1 + b(he, Dt), Dt += 3, ce.canvas_height = 1 + b(he, Dt), Dt += 3;
            break;
          case "ALPH":
            me = !0, je = zt + 8, Pe = Be - 8;
            break;
          case "ANIM":
            (ce = ke.header).bgcolor = A(he, Be), Dt = Be + 4, ce.loop_count = (St = he)[(Mt = Dt) + 0] << 0 | St[Mt + 1] << 8, Dt += 2;
            break;
          case "ANMF":
            var hr, ce;
            (ce = ke.frames[pe] = {}).offset_x = 2 * b(he, Be), Be += 3, ce.offset_y = 2 * b(he, Be), Be += 3, ce.width = 1 + b(he, Be), Be += 3, ce.height = 1 + b(he, Be), Be += 3, ce.duration = b(he, Be), Be += 3, hr = he[Be++], ce.dispose = 1 & hr, ce.blend = hr >> 1 & 1;
        }
        Lt != "ANMF" && (Be += zt);
      }
      return ke;
    }
  }(V, 0);
  q.response = V, q.rgbaoutput = !0, q.dataurl = !1;
  var Y = q.header ? q.header : null, re = q.frames ? q.frames : null;
  if (Y) {
    Y.loop_counter = Y.loop_count, M = [Y.canvas_height], E = [Y.canvas_width];
    for (var Z = 0; Z < re.length && re[Z].blend != 0; Z++) ;
  }
  var K = re[0], ie = U.WebPDecodeRGBA(V, K.src_off, K.src_size, E, M);
  K.rgba = ie, K.imgwidth = E[0], K.imgheight = M[0];
  for (var be = 0; be < E[0] * M[0] * 4; be++) k[be] = ie[be];
  return this.width = E, this.height = M, this.data = k, this;
}
(function(r) {
  var e = function() {
    return typeof jv == "function";
  }, t = function(M, E, k, U) {
    var V = 4, q = l;
    switch (U) {
      case r.image_compression.FAST:
        V = 1, q = s;
        break;
      case r.image_compression.MEDIUM:
        V = 6, q = o;
        break;
      case r.image_compression.SLOW:
        V = 9, q = d;
    }
    M = n(M, E, k, q);
    var Y = jv(M, { level: V });
    return r.__addimage__.arrayBufferToBinaryString(Y);
  }, n = function(M, E, k, U) {
    for (var V, q, Y, re = M.length / E, Z = new Uint8Array(M.length + re), K = b(), ie = 0; ie < re; ie += 1) {
      if (Y = ie * E, V = M.subarray(Y, Y + E), U) Z.set(U(V, k, q), Y + ie);
      else {
        for (var be, he = K.length, Be = []; be < he; be += 1) Be[be] = K[be](V, k, q);
        var ke = A(Be.concat());
        Z.set(Be[ke], Y + ie);
      }
      q = V;
    }
    return Z;
  }, i = function(M) {
    var E = Array.apply([], M);
    return E.unshift(0), E;
  }, s = function(M, E) {
    var k, U = [], V = M.length;
    U[0] = 1;
    for (var q = 0; q < V; q += 1) k = M[q - E] || 0, U[q + 1] = M[q] - k + 256 & 255;
    return U;
  }, l = function(M, E, k) {
    var U, V = [], q = M.length;
    V[0] = 2;
    for (var Y = 0; Y < q; Y += 1) U = k && k[Y] || 0, V[Y + 1] = M[Y] - U + 256 & 255;
    return V;
  }, o = function(M, E, k) {
    var U, V, q = [], Y = M.length;
    q[0] = 3;
    for (var re = 0; re < Y; re += 1) U = M[re - E] || 0, V = k && k[re] || 0, q[re + 1] = M[re] + 256 - (U + V >>> 1) & 255;
    return q;
  }, d = function(M, E, k) {
    var U, V, q, Y, re = [], Z = M.length;
    re[0] = 4;
    for (var K = 0; K < Z; K += 1) U = M[K - E] || 0, V = k && k[K] || 0, q = k && k[K - E] || 0, Y = m(U, V, q), re[K + 1] = M[K] - Y + 256 & 255;
    return re;
  }, m = function(M, E, k) {
    if (M === E && E === k) return M;
    var U = Math.abs(E - k), V = Math.abs(M - k), q = Math.abs(M + E - k - k);
    return U <= V && U <= q ? M : V <= q ? E : k;
  }, b = function() {
    return [i, s, l, o, d];
  }, A = function(M) {
    var E = M.map(function(k) {
      return k.reduce(function(U, V) {
        return U + Math.abs(V);
      }, 0);
    });
    return E.indexOf(Math.min.apply(null, E));
  };
  r.processPNG = function(M, E, k, U) {
    var V, q, Y, re, Z, K, ie, be, he, Be, ke, pe, me, je, Pe, St = this.decode.FLATE_DECODE, Mt = "";
    if (this.__addimage__.isArrayBuffer(M) && (M = new Uint8Array(M)), this.__addimage__.isArrayBufferView(M)) {
      if (M = (Y = new TZ(M)).imgData, q = Y.bits, V = Y.colorSpace, Z = Y.colors, [4, 6].indexOf(Y.colorType) !== -1) {
        if (Y.bits === 8) {
          he = (be = Y.pixelBitlength == 32 ? new Uint32Array(Y.decodePixels().buffer) : Y.pixelBitlength == 16 ? new Uint16Array(Y.decodePixels().buffer) : new Uint8Array(Y.decodePixels().buffer)).length, ke = new Uint8Array(he * Y.colors), Be = new Uint8Array(he);
          var Lt, xt = Y.pixelBitlength - Y.bits;
          for (je = 0, Pe = 0; je < he; je++) {
            for (me = be[je], Lt = 0; Lt < xt; ) ke[Pe++] = me >>> Lt & 255, Lt += Y.bits;
            Be[je] = me >>> Lt & 255;
          }
        }
        if (Y.bits === 16) {
          he = (be = new Uint32Array(Y.decodePixels().buffer)).length, ke = new Uint8Array(he * (32 / Y.pixelBitlength) * Y.colors), Be = new Uint8Array(he * (32 / Y.pixelBitlength)), pe = Y.colors > 1, je = 0, Pe = 0;
          for (var zt = 0; je < he; ) me = be[je++], ke[Pe++] = me >>> 0 & 255, pe && (ke[Pe++] = me >>> 16 & 255, me = be[je++], ke[Pe++] = me >>> 0 & 255), Be[zt++] = me >>> 16 & 255;
          q = 8;
        }
        U !== r.image_compression.NONE && e() ? (M = t(ke, Y.width * Y.colors, Y.colors, U), ie = t(Be, Y.width, 1, U)) : (M = ke, ie = Be, St = void 0);
      }
      if (Y.colorType === 3 && (V = this.color_spaces.INDEXED, K = Y.palette, Y.transparency.indexed)) {
        var Dt = Y.transparency.indexed, hr = 0;
        for (je = 0, he = Dt.length; je < he; ++je) hr += Dt[je];
        if ((hr /= 255) === he - 1 && Dt.indexOf(0) !== -1) re = [Dt.indexOf(0)];
        else if (hr !== he) {
          for (be = Y.decodePixels(), Be = new Uint8Array(be.length), je = 0, he = be.length; je < he; je++) Be[je] = Dt[be[je]];
          ie = t(Be, Y.width, 1);
        }
      }
      var ce = function(Oe) {
        var $e;
        switch (Oe) {
          case r.image_compression.FAST:
            $e = 11;
            break;
          case r.image_compression.MEDIUM:
            $e = 13;
            break;
          case r.image_compression.SLOW:
            $e = 14;
            break;
          default:
            $e = 12;
        }
        return $e;
      }(U);
      return St === this.decode.FLATE_DECODE && (Mt = "/Predictor " + ce + " "), Mt += "/Colors " + Z + " /BitsPerComponent " + q + " /Columns " + Y.width, (this.__addimage__.isArrayBuffer(M) || this.__addimage__.isArrayBufferView(M)) && (M = this.__addimage__.arrayBufferToBinaryString(M)), (ie && this.__addimage__.isArrayBuffer(ie) || this.__addimage__.isArrayBufferView(ie)) && (ie = this.__addimage__.arrayBufferToBinaryString(ie)), { alias: k, data: M, index: E, filter: St, decodeParameters: Mt, transparency: re, palette: K, sMask: ie, predictor: ce, width: Y.width, height: Y.height, bitsPerComponent: q, colorSpace: V };
    }
  };
})(rn.API), function(r) {
  r.processGIF89A = function(e, t, n, i) {
    var s = new SZ(e), l = s.width, o = s.height, d = [];
    s.decodeAndBlitFrameRGBA(0, d);
    var m = { data: d, width: l, height: o }, b = new p1(100).encode(m, 100);
    return r.processJPEG.call(this, b, t, n, i);
  }, r.processGIF87A = r.processGIF89A;
}(rn.API), mc.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, !0), this.pos += 4, this.offset = this.datav.getUint32(this.pos, !0), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.width = this.datav.getUint32(this.pos, !0), this.pos += 4, this.height = this.datav.getInt32(this.pos, !0), this.pos += 4, this.planes = this.datav.getUint16(this.pos, !0), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, !0), this.pos += 2, this.compress = this.datav.getUint32(this.pos, !0), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.hr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.vr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.colors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var r = this.colors === 0 ? 1 << this.bitPP : this.colors;
    this.palette = new Array(r);
    for (var e = 0; e < r; e++) {
      var t = this.datav.getUint8(this.pos++, !0), n = this.datav.getUint8(this.pos++, !0), i = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0);
      this.palette[e] = { red: i, green: n, blue: t, quad: s };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = !1);
}, mc.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var r = "bit" + this.bitPP, e = this.width * this.height * 4;
    this.data = new Uint8Array(e), this[r]();
  } catch (t) {
    Ii.log("bit decode error:" + t);
  }
}, mc.prototype.bit1 = function() {
  var r, e = Math.ceil(this.width / 8), t = e % 4;
  for (r = this.height - 1; r >= 0; r--) {
    for (var n = this.bottom_up ? r : this.height - 1 - r, i = 0; i < e; i++) for (var s = this.datav.getUint8(this.pos++, !0), l = n * this.width * 4 + 8 * i * 4, o = 0; o < 8 && 8 * i + o < this.width; o++) {
      var d = this.palette[s >> 7 - o & 1];
      this.data[l + 4 * o] = d.blue, this.data[l + 4 * o + 1] = d.green, this.data[l + 4 * o + 2] = d.red, this.data[l + 4 * o + 3] = 255;
    }
    t !== 0 && (this.pos += 4 - t);
  }
}, mc.prototype.bit4 = function() {
  for (var r = Math.ceil(this.width / 2), e = r % 4, t = this.height - 1; t >= 0; t--) {
    for (var n = this.bottom_up ? t : this.height - 1 - t, i = 0; i < r; i++) {
      var s = this.datav.getUint8(this.pos++, !0), l = n * this.width * 4 + 2 * i * 4, o = s >> 4, d = 15 & s, m = this.palette[o];
      if (this.data[l] = m.blue, this.data[l + 1] = m.green, this.data[l + 2] = m.red, this.data[l + 3] = 255, 2 * i + 1 >= this.width) break;
      m = this.palette[d], this.data[l + 4] = m.blue, this.data[l + 4 + 1] = m.green, this.data[l + 4 + 2] = m.red, this.data[l + 4 + 3] = 255;
    }
    e !== 0 && (this.pos += 4 - e);
  }
}, mc.prototype.bit8 = function() {
  for (var r = this.width % 4, e = this.height - 1; e >= 0; e--) {
    for (var t = this.bottom_up ? e : this.height - 1 - e, n = 0; n < this.width; n++) {
      var i = this.datav.getUint8(this.pos++, !0), s = t * this.width * 4 + 4 * n;
      if (i < this.palette.length) {
        var l = this.palette[i];
        this.data[s] = l.red, this.data[s + 1] = l.green, this.data[s + 2] = l.blue, this.data[s + 3] = 255;
      } else this.data[s] = 255, this.data[s + 1] = 255, this.data[s + 2] = 255, this.data[s + 3] = 255;
    }
    r !== 0 && (this.pos += 4 - r);
  }
}, mc.prototype.bit15 = function() {
  for (var r = this.width % 3, e = parseInt("11111", 2), t = this.height - 1; t >= 0; t--) {
    for (var n = this.bottom_up ? t : this.height - 1 - t, i = 0; i < this.width; i++) {
      var s = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var l = (s & e) / e * 255 | 0, o = (s >> 5 & e) / e * 255 | 0, d = (s >> 10 & e) / e * 255 | 0, m = s >> 15 ? 255 : 0, b = n * this.width * 4 + 4 * i;
      this.data[b] = d, this.data[b + 1] = o, this.data[b + 2] = l, this.data[b + 3] = m;
    }
    this.pos += r;
  }
}, mc.prototype.bit16 = function() {
  for (var r = this.width % 3, e = parseInt("11111", 2), t = parseInt("111111", 2), n = this.height - 1; n >= 0; n--) {
    for (var i = this.bottom_up ? n : this.height - 1 - n, s = 0; s < this.width; s++) {
      var l = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var o = (l & e) / e * 255 | 0, d = (l >> 5 & t) / t * 255 | 0, m = (l >> 11) / e * 255 | 0, b = i * this.width * 4 + 4 * s;
      this.data[b] = m, this.data[b + 1] = d, this.data[b + 2] = o, this.data[b + 3] = 255;
    }
    this.pos += r;
  }
}, mc.prototype.bit24 = function() {
  for (var r = this.height - 1; r >= 0; r--) {
    for (var e = this.bottom_up ? r : this.height - 1 - r, t = 0; t < this.width; t++) {
      var n = this.datav.getUint8(this.pos++, !0), i = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0), l = e * this.width * 4 + 4 * t;
      this.data[l] = s, this.data[l + 1] = i, this.data[l + 2] = n, this.data[l + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, mc.prototype.bit32 = function() {
  for (var r = this.height - 1; r >= 0; r--) for (var e = this.bottom_up ? r : this.height - 1 - r, t = 0; t < this.width; t++) {
    var n = this.datav.getUint8(this.pos++, !0), i = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0), l = this.datav.getUint8(this.pos++, !0), o = e * this.width * 4 + 4 * t;
    this.data[o] = s, this.data[o + 1] = i, this.data[o + 2] = n, this.data[o + 3] = l;
  }
}, mc.prototype.getData = function() {
  return this.data;
}, /**
* @license
* Copyright (c) 2018 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  r.processBMP = function(e, t, n, i) {
    var s = new mc(e, !1), l = s.width, o = s.height, d = { data: s.getData(), width: l, height: o }, m = new p1(100).encode(d, 100);
    return r.processJPEG.call(this, m, t, n, i);
  };
}(rn.API), sE.prototype.getData = function() {
  return this.data;
}, /**
* @license
* Copyright (c) 2019 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  r.processWEBP = function(e, t, n, i) {
    var s = new sE(e), l = s.width, o = s.height, d = { data: s.getData(), width: l, height: o }, m = new p1(100).encode(d, 100);
    return r.processJPEG.call(this, m, t, n, i);
  };
}(rn.API), rn.API.processRGBA = function(r, e, t) {
  for (var n = r.data, i = n.length, s = new Uint8Array(i / 4 * 3), l = new Uint8Array(i / 4), o = 0, d = 0, m = 0; m < i; m += 4) {
    var b = n[m], A = n[m + 1], M = n[m + 2], E = n[m + 3];
    s[o++] = b, s[o++] = A, s[o++] = M, l[d++] = E;
  }
  var k = this.__addimage__.arrayBufferToBinaryString(s);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(l), data: k, index: e, alias: t, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: r.width, height: r.height };
}, rn.API.setLanguage = function(r) {
  return this.internal.languageSettings === void 0 && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = !1), { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[r] !== void 0 && (this.internal.languageSettings.languageCode = r, this.internal.languageSettings.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = !0)), this;
}, Pd = rn.API, r_ = Pd.getCharWidthsArray = function(r, e) {
  var t, n, i = (e = e || {}).font || this.internal.getFont(), s = e.fontSize || this.internal.getFontSize(), l = e.charSpace || this.internal.getCharSpace(), o = e.widths ? e.widths : i.metadata.Unicode.widths, d = o.fof ? o.fof : 1, m = e.kerning ? e.kerning : i.metadata.Unicode.kerning, b = m.fof ? m.fof : 1, A = e.doKerning !== !1, M = 0, E = r.length, k = 0, U = o[0] || d, V = [];
  for (t = 0; t < E; t++) n = r.charCodeAt(t), typeof i.metadata.widthOfString == "function" ? V.push((i.metadata.widthOfGlyph(i.metadata.characterToGlyph(n)) + l * (1e3 / s) || 0) / 1e3) : (M = A && ci(m[n]) === "object" && !isNaN(parseInt(m[n][k], 10)) ? m[n][k] / b : 0, V.push((o[n] || U) / d + M)), k = n;
  return V;
}, tE = Pd.getStringUnitWidth = function(r, e) {
  var t = (e = e || {}).fontSize || this.internal.getFontSize(), n = e.font || this.internal.getFont(), i = e.charSpace || this.internal.getCharSpace();
  return Pd.processArabic && (r = Pd.processArabic(r)), typeof n.metadata.widthOfString == "function" ? n.metadata.widthOfString(r, t, i) / t : r_.apply(this, arguments).reduce(function(s, l) {
    return s + l;
  }, 0);
}, rE = function(r, e, t, n) {
  for (var i = [], s = 0, l = r.length, o = 0; s !== l && o + e[s] < t; ) o += e[s], s++;
  i.push(r.slice(0, s));
  var d = s;
  for (o = 0; s !== l; ) o + e[s] > n && (i.push(r.slice(d, s)), o = 0, d = s), o += e[s], s++;
  return d !== s && i.push(r.slice(d, s)), i;
}, nE = function(r, e, t) {
  t || (t = {});
  var n, i, s, l, o, d, m, b = [], A = [b], M = t.textIndent || 0, E = 0, k = 0, U = r.split(" "), V = r_.apply(this, [" ", t])[0];
  if (d = t.lineIndent === -1 ? U[0].length + 2 : t.lineIndent || 0) {
    var q = Array(d).join(" "), Y = [];
    U.map(function(Z) {
      (Z = Z.split(/\s*\n/)).length > 1 ? Y = Y.concat(Z.map(function(K, ie) {
        return (ie && K.length ? `
` : "") + K;
      })) : Y.push(Z[0]);
    }), U = Y, d = tE.apply(this, [q, t]);
  }
  for (s = 0, l = U.length; s < l; s++) {
    var re = 0;
    if (n = U[s], d && n[0] == `
` && (n = n.substr(1), re = 1), M + E + (k = (i = r_.apply(this, [n, t])).reduce(function(Z, K) {
      return Z + K;
    }, 0)) > e || re) {
      if (k > e) {
        for (o = rE.apply(this, [n, i, e - (M + E), e]), b.push(o.shift()), b = [o.pop()]; o.length; ) A.push([o.shift()]);
        k = i.slice(n.length - (b[0] ? b[0].length : 0)).reduce(function(Z, K) {
          return Z + K;
        }, 0);
      } else b = [n];
      A.push(b), M = k + d, E = V;
    } else b.push(n), M += E + k, E = V;
  }
  return m = d ? function(Z, K) {
    return (K ? q : "") + Z.join(" ");
  } : function(Z) {
    return Z.join(" ");
  }, A.map(m);
}, Pd.splitTextToSize = function(r, e, t) {
  var n, i = (t = t || {}).fontSize || this.internal.getFontSize(), s = (function(b) {
    if (b.widths && b.kerning) return { widths: b.widths, kerning: b.kerning };
    var A = this.internal.getFont(b.fontName, b.fontStyle);
    return A.metadata.Unicode ? { widths: A.metadata.Unicode.widths || { 0: 1 }, kerning: A.metadata.Unicode.kerning || {} } : { font: A.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }).call(this, t);
  n = Array.isArray(r) ? r : String(r).split(/\r?\n/);
  var l = 1 * this.internal.scaleFactor * e / i;
  s.textIndent = t.textIndent ? 1 * t.textIndent * this.internal.scaleFactor / i : 0, s.lineIndent = t.lineIndent;
  var o, d, m = [];
  for (o = 0, d = n.length; o < d; o++) m = m.concat(nE.apply(this, [n[o], l, s]));
  return m;
}, function(r) {
  r.__fontmetrics__ = r.__fontmetrics__ || {};
  for (var e = "klmnopqrstuvwxyz", t = {}, n = {}, i = 0; i < e.length; i++) t[e[i]] = "0123456789abcdef"[i], n["0123456789abcdef"[i]] = e[i];
  var s = function(A) {
    return "0x" + parseInt(A, 10).toString(16);
  }, l = r.__fontmetrics__.compress = function(A) {
    var M, E, k, U, V = ["{"];
    for (var q in A) {
      if (M = A[q], isNaN(parseInt(q, 10)) ? E = "'" + q + "'" : (q = parseInt(q, 10), E = (E = s(q).slice(2)).slice(0, -1) + n[E.slice(-1)]), typeof M == "number") M < 0 ? (k = s(M).slice(3), U = "-") : (k = s(M).slice(2), U = ""), k = U + k.slice(0, -1) + n[k.slice(-1)];
      else {
        if (ci(M) !== "object") throw new Error("Don't know what to do with value type " + ci(M) + ".");
        k = l(M);
      }
      V.push(E + k);
    }
    return V.push("}"), V.join("");
  }, o = r.__fontmetrics__.uncompress = function(A) {
    if (typeof A != "string") throw new Error("Invalid argument passed to uncompress.");
    for (var M, E, k, U, V = {}, q = 1, Y = V, re = [], Z = "", K = "", ie = A.length - 1, be = 1; be < ie; be += 1) (U = A[be]) == "'" ? M ? (k = M.join(""), M = void 0) : M = [] : M ? M.push(U) : U == "{" ? (re.push([Y, k]), Y = {}, k = void 0) : U == "}" ? ((E = re.pop())[0][E[1]] = Y, k = void 0, Y = E[0]) : U == "-" ? q = -1 : k === void 0 ? t.hasOwnProperty(U) ? (Z += t[U], k = parseInt(Z, 16) * q, q = 1, Z = "") : Z += U : t.hasOwnProperty(U) ? (K += t[U], Y[k] = parseInt(K, 16) * q, q = 1, k = void 0, K = "") : K += U;
    return V;
  }, d = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: o("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, m = { Unicode: { Courier: d, "Courier-Bold": d, "Courier-BoldOblique": d, "Courier-Oblique": d, Helvetica: d, "Helvetica-Bold": d, "Helvetica-BoldOblique": d, "Helvetica-Oblique": d, "Times-Roman": d, "Times-Bold": d, "Times-BoldItalic": d, "Times-Italic": d } }, b = { Unicode: { "Courier-Oblique": o("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": o("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": o("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: o("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": o("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": o("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: o("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: o("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": o("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: o("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": o("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": o("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": o("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": o("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  r.events.push(["addFont", function(A) {
    var M = A.font, E = b.Unicode[M.postScriptName];
    E && (M.metadata.Unicode = {}, M.metadata.Unicode.widths = E.widths, M.metadata.Unicode.kerning = E.kerning);
    var k = m.Unicode[M.postScriptName];
    k && (M.metadata.Unicode.encoding = k, M.encoding = k.codePages[0]);
  }]);
}(rn.API), /**
* @license
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  var e = function(t) {
    for (var n = t.length, i = new Uint8Array(n), s = 0; s < n; s++) i[s] = t.charCodeAt(s);
    return i;
  };
  r.API.events.push(["addFont", function(t) {
    var n = void 0, i = t.font, s = t.instance;
    if (!i.isStandardFont) {
      if (s === void 0) throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + i.postScriptName + "').");
      if (typeof (n = s.existsFileInVFS(i.postScriptName) === !1 ? s.loadFile(i.postScriptName) : s.getFileFromVFS(i.postScriptName)) != "string") throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + i.postScriptName + "').");
      (function(l, o) {
        o = /^\x00\x01\x00\x00/.test(o) ? e(o) : e(Eg(o)), l.metadata = r.API.TTFFont.open(o), l.metadata.Unicode = l.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, l.metadata.glyIdsUsed = [0];
      })(i, n);
    }
  }]);
}(rn), /** @license
* Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
function(r) {
  function e() {
    return (on.canvg ? Promise.resolve(on.canvg) : import("./index.es-H945btOb-DbvF5zOC.mjs")).catch(function(t) {
      return Promise.reject(new Error("Could not load canvg: " + t));
    }).then(function(t) {
      return t.default ? t.default : t;
    });
  }
  rn.API.addSvgAsImage = function(t, n, i, s, l, o, d, m) {
    if (isNaN(n) || isNaN(i)) throw Ii.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(s) || isNaN(l)) throw Ii.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var b = document.createElement("canvas");
    b.width = s, b.height = l;
    var A = b.getContext("2d");
    A.fillStyle = "#fff", A.fillRect(0, 0, b.width, b.height);
    var M = { ignoreMouse: !0, ignoreAnimation: !0, ignoreDimensions: !0 }, E = this;
    return e().then(function(k) {
      return k.fromString(A, t, M);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(k) {
      return k.render(M);
    }).then(function() {
      E.addImage(b.toDataURL("image/jpeg", 1), n, i, s, l, d, m);
    });
  };
}(), rn.API.putTotalPages = function(r) {
  var e, t = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (e = new RegExp(r, "g"), t = this.internal.getNumberOfPages()) : (e = new RegExp(this.pdfEscape16(r, this.internal.getFont()), "g"), t = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var n = 1; n <= this.internal.getNumberOfPages(); n++) for (var i = 0; i < this.internal.pages[n].length; i++) this.internal.pages[n][i] = this.internal.pages[n][i].replace(e, t);
  return this;
}, rn.API.viewerPreferences = function(r, e) {
  var t;
  r = r || {}, e = e || !1;
  var n, i, s, l = { HideToolbar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideMenubar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, FitWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, CenterWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: !1, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: !1, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: !1, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: !1, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: !1, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: !1, valueSet: null, pdfVersion: 1.7 } }, o = Object.keys(l), d = [], m = 0, b = 0, A = 0;
  function M(k, U) {
    var V, q = !1;
    for (V = 0; V < k.length; V += 1) k[V] === U && (q = !0);
    return q;
  }
  if (this.internal.viewerpreferences === void 0 && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(l)), this.internal.viewerpreferences.isSubscribed = !1), t = this.internal.viewerpreferences.configuration, r === "reset" || e === !0) {
    var E = o.length;
    for (A = 0; A < E; A += 1) t[o[A]].value = t[o[A]].defaultValue, t[o[A]].explicitSet = !1;
  }
  if (ci(r) === "object") {
    for (i in r) if (s = r[i], M(o, i) && s !== void 0) {
      if (t[i].type === "boolean" && typeof s == "boolean") t[i].value = s;
      else if (t[i].type === "name" && M(t[i].valueSet, s)) t[i].value = s;
      else if (t[i].type === "integer" && Number.isInteger(s)) t[i].value = s;
      else if (t[i].type === "array") {
        for (m = 0; m < s.length; m += 1) if (n = !0, s[m].length === 1 && typeof s[m][0] == "number") d.push(String(s[m] - 1));
        else if (s[m].length > 1) {
          for (b = 0; b < s[m].length; b += 1) typeof s[m][b] != "number" && (n = !1);
          n === !0 && d.push([s[m][0] - 1, s[m][1] - 1].join(" "));
        }
        t[i].value = "[" + d.join(" ") + "]";
      } else t[i].value = t[i].defaultValue;
      t[i].explicitSet = !0;
    }
  }
  return this.internal.viewerpreferences.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    var k, U = [];
    for (k in t) t[k].explicitSet === !0 && (t[k].type === "name" ? U.push("/" + k + " /" + t[k].value) : U.push("/" + k + " " + t[k].value));
    U.length !== 0 && this.internal.write(`/ViewerPreferences
<<
` + U.join(`
`) + `
>>`);
  }), this.internal.viewerpreferences.isSubscribed = !0), this.internal.viewerpreferences.configuration = t, this;
}, /** ====================================================================
* @license
* jsPDF XMP metadata plugin
* Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
function(r) {
  var e = function() {
    var n = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', i = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), s = unescape(encodeURIComponent(n)), l = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), o = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), d = unescape(encodeURIComponent("</x:xmpmeta>")), m = s.length + l.length + o.length + i.length + d.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + m + " >>"), this.internal.write("stream"), this.internal.write(i + s + l + o + d), this.internal.write("endstream"), this.internal.write("endobj");
  }, t = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  r.addMetadata = function(n, i) {
    return this.internal.__metadata__ === void 0 && (this.internal.__metadata__ = { metadata: n, namespaceuri: i || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", t), this.internal.events.subscribe("postPutResources", e)), this;
  };
}(rn.API), function(r) {
  var e = r.API, t = e.pdfEscape16 = function(s, l) {
    for (var o, d = l.metadata.Unicode.widths, m = ["", "0", "00", "000", "0000"], b = [""], A = 0, M = s.length; A < M; ++A) {
      if (o = l.metadata.characterToGlyph(s.charCodeAt(A)), l.metadata.glyIdsUsed.push(o), l.metadata.toUnicode[o] = s.charCodeAt(A), d.indexOf(o) == -1 && (d.push(o), d.push([parseInt(l.metadata.widthOfGlyph(o), 10)])), o == "0") return b.join("");
      o = o.toString(16), b.push(m[4 - o.length], o);
    }
    return b.join("");
  }, n = function(s) {
    var l, o, d, m, b, A, M;
    for (b = `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo <<
  /Registry (Adobe)
  /Ordering (UCS)
  /Supplement 0
>> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000><ffff>
endcodespacerange`, d = [], A = 0, M = (o = Object.keys(s).sort(function(E, k) {
      return E - k;
    })).length; A < M; A++) l = o[A], d.length >= 100 && (b += `
` + d.length + ` beginbfchar
` + d.join(`
`) + `
endbfchar`, d = []), s[l] !== void 0 && s[l] !== null && typeof s[l].toString == "function" && (m = ("0000" + s[l].toString(16)).slice(-4), l = ("0000" + (+l).toString(16)).slice(-4), d.push("<" + l + "><" + m + ">"));
    return d.length && (b += `
` + d.length + ` beginbfchar
` + d.join(`
`) + `
endbfchar
`), b += `endcmap
CMapName currentdict /CMap defineresource pop
end
end`;
  };
  e.events.push(["putFont", function(s) {
    (function(l) {
      var o = l.font, d = l.out, m = l.newObject, b = l.putStream;
      if (o.metadata instanceof r.API.TTFFont && o.encoding === "Identity-H") {
        for (var A = o.metadata.Unicode.widths, M = o.metadata.subset.encode(o.metadata.glyIdsUsed, 1), E = "", k = 0; k < M.length; k++) E += String.fromCharCode(M[k]);
        var U = m();
        b({ data: E, addLength1: !0, objectId: U }), d("endobj");
        var V = m();
        b({ data: n(o.metadata.toUnicode), addLength1: !0, objectId: V }), d("endobj");
        var q = m();
        d("<<"), d("/Type /FontDescriptor"), d("/FontName /" + Od(o.fontName)), d("/FontFile2 " + U + " 0 R"), d("/FontBBox " + r.API.PDFObject.convert(o.metadata.bbox)), d("/Flags " + o.metadata.flags), d("/StemV " + o.metadata.stemV), d("/ItalicAngle " + o.metadata.italicAngle), d("/Ascent " + o.metadata.ascender), d("/Descent " + o.metadata.decender), d("/CapHeight " + o.metadata.capHeight), d(">>"), d("endobj");
        var Y = m();
        d("<<"), d("/Type /Font"), d("/BaseFont /" + Od(o.fontName)), d("/FontDescriptor " + q + " 0 R"), d("/W " + r.API.PDFObject.convert(A)), d("/CIDToGIDMap /Identity"), d("/DW 1000"), d("/Subtype /CIDFontType2"), d("/CIDSystemInfo"), d("<<"), d("/Supplement 0"), d("/Registry (Adobe)"), d("/Ordering (" + o.encoding + ")"), d(">>"), d(">>"), d("endobj"), o.objectNumber = m(), d("<<"), d("/Type /Font"), d("/Subtype /Type0"), d("/ToUnicode " + V + " 0 R"), d("/BaseFont /" + Od(o.fontName)), d("/Encoding /" + o.encoding), d("/DescendantFonts [" + Y + " 0 R]"), d(">>"), d("endobj"), o.isAlreadyPutted = !0;
      }
    })(s);
  }]), e.events.push(["putFont", function(s) {
    (function(l) {
      var o = l.font, d = l.out, m = l.newObject, b = l.putStream;
      if (o.metadata instanceof r.API.TTFFont && o.encoding === "WinAnsiEncoding") {
        for (var A = o.metadata.rawData, M = "", E = 0; E < A.length; E++) M += String.fromCharCode(A[E]);
        var k = m();
        b({ data: M, addLength1: !0, objectId: k }), d("endobj");
        var U = m();
        b({ data: n(o.metadata.toUnicode), addLength1: !0, objectId: U }), d("endobj");
        var V = m();
        d("<<"), d("/Descent " + o.metadata.decender), d("/CapHeight " + o.metadata.capHeight), d("/StemV " + o.metadata.stemV), d("/Type /FontDescriptor"), d("/FontFile2 " + k + " 0 R"), d("/Flags 96"), d("/FontBBox " + r.API.PDFObject.convert(o.metadata.bbox)), d("/FontName /" + Od(o.fontName)), d("/ItalicAngle " + o.metadata.italicAngle), d("/Ascent " + o.metadata.ascender), d(">>"), d("endobj"), o.objectNumber = m();
        for (var q = 0; q < o.metadata.hmtx.widths.length; q++) o.metadata.hmtx.widths[q] = parseInt(o.metadata.hmtx.widths[q] * (1e3 / o.metadata.head.unitsPerEm));
        d("<</Subtype/TrueType/Type/Font/ToUnicode " + U + " 0 R/BaseFont/" + Od(o.fontName) + "/FontDescriptor " + V + " 0 R/Encoding/" + o.encoding + " /FirstChar 29 /LastChar 255 /Widths " + r.API.PDFObject.convert(o.metadata.hmtx.widths) + ">>"), d("endobj"), o.isAlreadyPutted = !0;
      }
    })(s);
  }]);
  var i = function(s) {
    var l, o = s.text || "", d = s.x, m = s.y, b = s.options || {}, A = s.mutex || {}, M = A.pdfEscape, E = A.activeFontKey, k = A.fonts, U = E, V = "", q = 0, Y = "", re = k[U].encoding;
    if (k[U].encoding !== "Identity-H") return { text: o, x: d, y: m, options: b, mutex: A };
    for (Y = o, U = E, Array.isArray(o) && (Y = o[0]), q = 0; q < Y.length; q += 1) k[U].metadata.hasOwnProperty("cmap") && (l = k[U].metadata.cmap.unicode.codeMap[Y[q].charCodeAt(0)]), l || Y[q].charCodeAt(0) < 256 && k[U].metadata.hasOwnProperty("Unicode") ? V += Y[q] : V += "";
    var Z = "";
    return parseInt(U.slice(1)) < 14 || re === "WinAnsiEncoding" ? Z = M(V, U).split("").map(function(K) {
      return K.charCodeAt(0).toString(16);
    }).join("") : re === "Identity-H" && (Z = t(V, k[U])), A.isHex = !0, { text: Z, x: d, y: m, options: b, mutex: A };
  };
  e.events.push(["postProcessText", function(s) {
    var l = s.text || "", o = [], d = { text: l, x: s.x, y: s.y, options: s.options, mutex: s.mutex };
    if (Array.isArray(l)) {
      var m = 0;
      for (m = 0; m < l.length; m += 1) Array.isArray(l[m]) && l[m].length === 3 ? o.push([i(Object.assign({}, d, { text: l[m][0] })).text, l[m][1], l[m][2]]) : o.push(i(Object.assign({}, d, { text: l[m] })).text);
      s.text = o;
    } else s.text = i(Object.assign({}, d, { text: l })).text;
  }]);
}(rn), /**
* @license
* jsPDF virtual FileSystem functionality
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  var e = function() {
    return this.internal.vFS === void 0 && (this.internal.vFS = {}), !0;
  };
  r.existsFileInVFS = function(t) {
    return e.call(this), this.internal.vFS[t] !== void 0;
  }, r.addFileToVFS = function(t, n) {
    return e.call(this), this.internal.vFS[t] = n, this;
  }, r.getFileFromVFS = function(t) {
    return e.call(this), this.internal.vFS[t] !== void 0 ? this.internal.vFS[t] : null;
  };
}(rn.API), /**
* @license
* Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
* MIT License
*/
function(r) {
  r.__bidiEngine__ = r.prototype.__bidiEngine__ = function(n) {
    var i, s, l, o, d, m, b, A = e, M = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], E = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], k = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, U = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, V = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "«", "»", "«", "‹", "›", "‹", "⁅", "⁆", "⁅", "⁽", "⁾", "⁽", "₍", "₎", "₍", "≤", "≥", "≤", "〈", "〉", "〈", "﹙", "﹚", "﹙", "﹛", "﹜", "﹛", "﹝", "﹞", "﹝", "﹤", "﹥", "﹤"], q = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), Y = !1, re = 0;
    this.__bidiEngine__ = {};
    var Z = function(pe) {
      var me = pe.charCodeAt(), je = me >> 8, Pe = U[je];
      return Pe !== void 0 ? A[256 * Pe + (255 & me)] : je === 252 || je === 253 ? "AL" : q.test(je) ? "L" : je === 8 ? "R" : "N";
    }, K = function(pe) {
      for (var me, je = 0; je < pe.length; je++) {
        if ((me = Z(pe.charAt(je))) === "L") return !1;
        if (me === "R") return !0;
      }
      return !1;
    }, ie = function(pe, me, je, Pe) {
      var St, Mt, Lt, xt, zt = me[Pe];
      switch (zt) {
        case "L":
        case "R":
          Y = !1;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          Y && (zt = "AN");
          break;
        case "AL":
          Y = !0, zt = "R";
          break;
        case "WS":
          zt = "N";
          break;
        case "CS":
          Pe < 1 || Pe + 1 >= me.length || (St = je[Pe - 1]) !== "EN" && St !== "AN" || (Mt = me[Pe + 1]) !== "EN" && Mt !== "AN" ? zt = "N" : Y && (Mt = "AN"), zt = Mt === St ? Mt : "N";
          break;
        case "ES":
          zt = (St = Pe > 0 ? je[Pe - 1] : "B") === "EN" && Pe + 1 < me.length && me[Pe + 1] === "EN" ? "EN" : "N";
          break;
        case "ET":
          if (Pe > 0 && je[Pe - 1] === "EN") {
            zt = "EN";
            break;
          }
          if (Y) {
            zt = "N";
            break;
          }
          for (Lt = Pe + 1, xt = me.length; Lt < xt && me[Lt] === "ET"; ) Lt++;
          zt = Lt < xt && me[Lt] === "EN" ? "EN" : "N";
          break;
        case "NSM":
          if (l && !o) {
            for (xt = me.length, Lt = Pe + 1; Lt < xt && me[Lt] === "NSM"; ) Lt++;
            if (Lt < xt) {
              var Dt = pe[Pe], hr = Dt >= 1425 && Dt <= 2303 || Dt === 64286;
              if (St = me[Lt], hr && (St === "R" || St === "AL")) {
                zt = "R";
                break;
              }
            }
          }
          zt = Pe < 1 || (St = me[Pe - 1]) === "B" ? "N" : je[Pe - 1];
          break;
        case "B":
          Y = !1, i = !0, zt = re;
          break;
        case "S":
          s = !0, zt = "N";
          break;
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          Y = !1;
          break;
        case "BN":
          zt = "N";
      }
      return zt;
    }, be = function(pe, me, je) {
      var Pe = pe.split("");
      return je && he(Pe, je, { hiLevel: re }), Pe.reverse(), me && me.reverse(), Pe.join("");
    }, he = function(pe, me, je) {
      var Pe, St, Mt, Lt, xt, zt = -1, Dt = pe.length, hr = 0, ce = [], Oe = re ? E : M, $e = [];
      for (Y = !1, i = !1, s = !1, St = 0; St < Dt; St++) $e[St] = Z(pe[St]);
      for (Mt = 0; Mt < Dt; Mt++) {
        if (xt = hr, ce[Mt] = ie(pe, $e, ce, Mt), Pe = 240 & (hr = Oe[xt][k[ce[Mt]]]), hr &= 15, me[Mt] = Lt = Oe[hr][5], Pe > 0) if (Pe === 16) {
          for (St = zt; St < Mt; St++) me[St] = 1;
          zt = -1;
        } else zt = -1;
        if (Oe[hr][6]) zt === -1 && (zt = Mt);
        else if (zt > -1) {
          for (St = zt; St < Mt; St++) me[St] = Lt;
          zt = -1;
        }
        $e[Mt] === "B" && (me[Mt] = 0), je.hiLevel |= Lt;
      }
      s && function(et, ot, ht) {
        for (var It = 0; It < ht; It++) if (et[It] === "S") {
          ot[It] = re;
          for (var yt = It - 1; yt >= 0 && et[yt] === "WS"; yt--) ot[yt] = re;
        }
      }($e, me, Dt);
    }, Be = function(pe, me, je, Pe, St) {
      if (!(St.hiLevel < pe)) {
        if (pe === 1 && re === 1 && !i) return me.reverse(), void (je && je.reverse());
        for (var Mt, Lt, xt, zt, Dt = me.length, hr = 0; hr < Dt; ) {
          if (Pe[hr] >= pe) {
            for (xt = hr + 1; xt < Dt && Pe[xt] >= pe; ) xt++;
            for (zt = hr, Lt = xt - 1; zt < Lt; zt++, Lt--) Mt = me[zt], me[zt] = me[Lt], me[Lt] = Mt, je && (Mt = je[zt], je[zt] = je[Lt], je[Lt] = Mt);
            hr = xt;
          }
          hr++;
        }
      }
    }, ke = function(pe, me, je) {
      var Pe = pe.split(""), St = { hiLevel: re };
      return je || (je = []), he(Pe, je, St), function(Mt, Lt, xt) {
        if (xt.hiLevel !== 0 && b) for (var zt, Dt = 0; Dt < Mt.length; Dt++) Lt[Dt] === 1 && (zt = V.indexOf(Mt[Dt])) >= 0 && (Mt[Dt] = V[zt + 1]);
      }(Pe, je, St), Be(2, Pe, me, je, St), Be(1, Pe, me, je, St), Pe.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(pe, me, je) {
      if (function(St, Mt) {
        if (Mt) for (var Lt = 0; Lt < St.length; Lt++) Mt[Lt] = Lt;
        o === void 0 && (o = K(St)), m === void 0 && (m = K(St));
      }(pe, me), l || !d || m)
        if (l && d && o ^ m) re = o ? 1 : 0, pe = be(pe, me, je);
        else if (!l && d && m) re = o ? 1 : 0, pe = ke(pe, me, je), pe = be(pe, me);
        else if (!l || o || d || m) {
          if (l && !d && o ^ m) pe = be(pe, me), o ? (re = 0, pe = ke(pe, me, je)) : (re = 1, pe = ke(pe, me, je), pe = be(pe, me));
          else if (l && o && !d && m) re = 1, pe = ke(pe, me, je), pe = be(pe, me);
          else if (!l && !d && o ^ m) {
            var Pe = b;
            o ? (re = 1, pe = ke(pe, me, je), re = 0, b = !1, pe = ke(pe, me, je), b = Pe) : (re = 0, pe = ke(pe, me, je), pe = be(pe, me), re = 1, b = !1, pe = ke(pe, me, je), b = Pe, pe = be(pe, me));
          }
        } else re = 0, pe = ke(pe, me, je);
      else re = o ? 1 : 0, pe = ke(pe, me, je);
      return pe;
    }, this.__bidiEngine__.setOptions = function(pe) {
      pe && (l = pe.isInputVisual, d = pe.isOutputVisual, o = pe.isInputRtl, m = pe.isOutputRtl, b = pe.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(n), this.__bidiEngine__;
  };
  var e = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], t = new r.__bidiEngine__({ isInputVisual: !0 });
  r.API.events.push(["postProcessText", function(n) {
    var i = n.text, s = (n.x, n.y, n.options || {}), l = (n.mutex, s.lang, []);
    if (s.isInputVisual = typeof s.isInputVisual != "boolean" || s.isInputVisual, t.setOptions(s), Object.prototype.toString.call(i) === "[object Array]") {
      var o = 0;
      for (l = [], o = 0; o < i.length; o += 1) Object.prototype.toString.call(i[o]) === "[object Array]" ? l.push([t.doBidiReorder(i[o][0]), i[o][1], i[o][2]]) : l.push([t.doBidiReorder(i[o])]);
      n.text = l;
    } else n.text = t.doBidiReorder(i);
    t.setOptions({ isInputVisual: !0 });
  }]);
}(rn), rn.API.TTFFont = function() {
  function r(e) {
    var t;
    if (this.rawData = e, t = this.contents = new Kh(e), this.contents.pos = 4, t.readString(4) === "ttcf") throw new Error("TTCF not supported.");
    t.pos = 0, this.parse(), this.subset = new zZ(this), this.registerTTF();
  }
  return r.open = function(e) {
    return new r(e);
  }, r.prototype.parse = function() {
    return this.directory = new EZ(this.contents), this.head = new IZ(this), this.name = new LZ(this), this.cmap = new ZM(this), this.toUnicode = {}, this.hhea = new MZ(this), this.maxp = new OZ(this), this.hmtx = new kZ(this), this.post = new RZ(this), this.os2 = new PZ(this), this.loca = new UZ(this), this.glyf = new NZ(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, r.prototype.registerTTF = function() {
    var e, t, n, i, s;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = (function() {
      var l, o, d, m;
      for (m = [], l = 0, o = (d = this.bbox).length; l < o; l++) e = d[l], m.push(Math.round(e * this.scaleFactor));
      return m;
    }).call(this), this.stemV = 0, this.post.exists ? (n = 255 & (i = this.post.italic_angle), (32768 & (t = i >> 16)) != 0 && (t = -(1 + (65535 ^ t))), this.italicAngle = +(t + "." + n)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = (s = this.familyClass) === 1 || s === 2 || s === 3 || s === 4 || s === 5 || s === 7, this.isScript = this.familyClass === 10, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), this.italicAngle !== 0 && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode) throw new Error("No unicode cmap for font");
  }, r.prototype.characterToGlyph = function(e) {
    var t;
    return ((t = this.cmap.unicode) != null ? t.codeMap[e] : void 0) || 0;
  }, r.prototype.widthOfGlyph = function(e) {
    var t;
    return t = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(e).advance * t;
  }, r.prototype.widthOfString = function(e, t, n) {
    var i, s, l, o;
    for (l = 0, s = 0, o = (e = "" + e).length; 0 <= o ? s < o : s > o; s = 0 <= o ? ++s : --s) i = e.charCodeAt(s), l += this.widthOfGlyph(this.characterToGlyph(i)) + n * (1e3 / t) || 0;
    return l * (t / 1e3);
  }, r.prototype.lineHeight = function(e, t) {
    var n;
    return t == null && (t = !1), n = t ? this.lineGap : 0, (this.ascender + n - this.decender) / 1e3 * e;
  }, r;
}();
var kc, Kh = function() {
  function r(e) {
    this.data = e ?? [], this.pos = 0, this.length = this.data.length;
  }
  return r.prototype.readByte = function() {
    return this.data[this.pos++];
  }, r.prototype.writeByte = function(e) {
    return this.data[this.pos++] = e;
  }, r.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, r.prototype.writeUInt32 = function(e) {
    return this.writeByte(e >>> 24 & 255), this.writeByte(e >> 16 & 255), this.writeByte(e >> 8 & 255), this.writeByte(255 & e);
  }, r.prototype.readInt32 = function() {
    var e;
    return (e = this.readUInt32()) >= 2147483648 ? e - 4294967296 : e;
  }, r.prototype.writeInt32 = function(e) {
    return e < 0 && (e += 4294967296), this.writeUInt32(e);
  }, r.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, r.prototype.writeUInt16 = function(e) {
    return this.writeByte(e >> 8 & 255), this.writeByte(255 & e);
  }, r.prototype.readInt16 = function() {
    var e;
    return (e = this.readUInt16()) >= 32768 ? e - 65536 : e;
  }, r.prototype.writeInt16 = function(e) {
    return e < 0 && (e += 65536), this.writeUInt16(e);
  }, r.prototype.readString = function(e) {
    var t, n;
    for (n = [], t = 0; 0 <= e ? t < e : t > e; t = 0 <= e ? ++t : --t) n[t] = String.fromCharCode(this.readByte());
    return n.join("");
  }, r.prototype.writeString = function(e) {
    var t, n, i;
    for (i = [], t = 0, n = e.length; 0 <= n ? t < n : t > n; t = 0 <= n ? ++t : --t) i.push(this.writeByte(e.charCodeAt(t)));
    return i;
  }, r.prototype.readShort = function() {
    return this.readInt16();
  }, r.prototype.writeShort = function(e) {
    return this.writeInt16(e);
  }, r.prototype.readLongLong = function() {
    var e, t, n, i, s, l, o, d;
    return e = this.readByte(), t = this.readByte(), n = this.readByte(), i = this.readByte(), s = this.readByte(), l = this.readByte(), o = this.readByte(), d = this.readByte(), 128 & e ? -1 * (72057594037927940 * (255 ^ e) + 281474976710656 * (255 ^ t) + 1099511627776 * (255 ^ n) + 4294967296 * (255 ^ i) + 16777216 * (255 ^ s) + 65536 * (255 ^ l) + 256 * (255 ^ o) + (255 ^ d) + 1) : 72057594037927940 * e + 281474976710656 * t + 1099511627776 * n + 4294967296 * i + 16777216 * s + 65536 * l + 256 * o + d;
  }, r.prototype.writeLongLong = function(e) {
    var t, n;
    return t = Math.floor(e / 4294967296), n = 4294967295 & e, this.writeByte(t >> 24 & 255), this.writeByte(t >> 16 & 255), this.writeByte(t >> 8 & 255), this.writeByte(255 & t), this.writeByte(n >> 24 & 255), this.writeByte(n >> 16 & 255), this.writeByte(n >> 8 & 255), this.writeByte(255 & n);
  }, r.prototype.readInt = function() {
    return this.readInt32();
  }, r.prototype.writeInt = function(e) {
    return this.writeInt32(e);
  }, r.prototype.read = function(e) {
    var t, n;
    for (t = [], n = 0; 0 <= e ? n < e : n > e; n = 0 <= e ? ++n : --n) t.push(this.readByte());
    return t;
  }, r.prototype.write = function(e) {
    var t, n, i, s;
    for (s = [], n = 0, i = e.length; n < i; n++) t = e[n], s.push(this.writeByte(t));
    return s;
  }, r;
}(), EZ = function() {
  var r;
  function e(t) {
    var n, i, s;
    for (this.scalarType = t.readInt(), this.tableCount = t.readShort(), this.searchRange = t.readShort(), this.entrySelector = t.readShort(), this.rangeShift = t.readShort(), this.tables = {}, i = 0, s = this.tableCount; 0 <= s ? i < s : i > s; i = 0 <= s ? ++i : --i) n = { tag: t.readString(4), checksum: t.readInt(), offset: t.readInt(), length: t.readInt() }, this.tables[n.tag] = n;
  }
  return e.prototype.encode = function(t) {
    var n, i, s, l, o, d, m, b, A, M, E, k, U;
    for (U in E = Object.keys(t).length, d = Math.log(2), A = 16 * Math.floor(Math.log(E) / d), l = Math.floor(A / d), b = 16 * E - A, (i = new Kh()).writeInt(this.scalarType), i.writeShort(E), i.writeShort(A), i.writeShort(l), i.writeShort(b), s = 16 * E, m = i.pos + s, o = null, k = [], t) for (M = t[U], i.writeString(U), i.writeInt(r(M)), i.writeInt(m), i.writeInt(M.length), k = k.concat(M), U === "head" && (o = m), m += M.length; m % 4; ) k.push(0), m++;
    return i.write(k), n = 2981146554 - r(i.data), i.pos = o + 8, i.writeUInt32(n), i.data;
  }, r = function(t) {
    var n, i, s, l;
    for (t = YM.call(t); t.length % 4; ) t.push(0);
    for (s = new Kh(t), i = 0, n = 0, l = t.length; n < l; n = n += 4) i += s.readUInt32();
    return 4294967295 & i;
  }, e;
}(), CZ = {}.hasOwnProperty, bu = function(r, e) {
  for (var t in e) CZ.call(e, t) && (r[t] = e[t]);
  function n() {
    this.constructor = r;
  }
  return n.prototype = e.prototype, r.prototype = new n(), r.__super__ = e.prototype, r;
};
kc = function() {
  function r(e) {
    var t;
    this.file = e, t = this.file.directory.tables[this.tag], this.exists = !!t, t && (this.offset = t.offset, this.length = t.length, this.parse(this.file.contents));
  }
  return r.prototype.parse = function() {
  }, r.prototype.encode = function() {
  }, r.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, r;
}();
var IZ = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return bu(e, kc), e.prototype.tag = "head", e.prototype.parse = function(t) {
    return t.pos = this.offset, this.version = t.readInt(), this.revision = t.readInt(), this.checkSumAdjustment = t.readInt(), this.magicNumber = t.readInt(), this.flags = t.readShort(), this.unitsPerEm = t.readShort(), this.created = t.readLongLong(), this.modified = t.readLongLong(), this.xMin = t.readShort(), this.yMin = t.readShort(), this.xMax = t.readShort(), this.yMax = t.readShort(), this.macStyle = t.readShort(), this.lowestRecPPEM = t.readShort(), this.fontDirectionHint = t.readShort(), this.indexToLocFormat = t.readShort(), this.glyphDataFormat = t.readShort();
  }, e.prototype.encode = function(t) {
    var n;
    return (n = new Kh()).writeInt(this.version), n.writeInt(this.revision), n.writeInt(this.checkSumAdjustment), n.writeInt(this.magicNumber), n.writeShort(this.flags), n.writeShort(this.unitsPerEm), n.writeLongLong(this.created), n.writeLongLong(this.modified), n.writeShort(this.xMin), n.writeShort(this.yMin), n.writeShort(this.xMax), n.writeShort(this.yMax), n.writeShort(this.macStyle), n.writeShort(this.lowestRecPPEM), n.writeShort(this.fontDirectionHint), n.writeShort(t), n.writeShort(this.glyphDataFormat), n.data;
  }, e;
}(), oE = function() {
  function r(e, t) {
    var n, i, s, l, o, d, m, b, A, M, E, k, U, V, q, Y, re;
    switch (this.platformID = e.readUInt16(), this.encodingID = e.readShort(), this.offset = t + e.readInt(), A = e.pos, e.pos = this.offset, this.format = e.readUInt16(), this.length = e.readUInt16(), this.language = e.readUInt16(), this.isUnicode = this.platformID === 3 && this.encodingID === 1 && this.format === 4 || this.platformID === 0 && this.format === 4, this.codeMap = {}, this.format) {
      case 0:
        for (d = 0; d < 256; ++d) this.codeMap[d] = e.readByte();
        break;
      case 4:
        for (E = e.readUInt16(), M = E / 2, e.pos += 6, s = function() {
          var Z, K;
          for (K = [], d = Z = 0; 0 <= M ? Z < M : Z > M; d = 0 <= M ? ++Z : --Z) K.push(e.readUInt16());
          return K;
        }(), e.pos += 2, U = function() {
          var Z, K;
          for (K = [], d = Z = 0; 0 <= M ? Z < M : Z > M; d = 0 <= M ? ++Z : --Z) K.push(e.readUInt16());
          return K;
        }(), m = function() {
          var Z, K;
          for (K = [], d = Z = 0; 0 <= M ? Z < M : Z > M; d = 0 <= M ? ++Z : --Z) K.push(e.readUInt16());
          return K;
        }(), b = function() {
          var Z, K;
          for (K = [], d = Z = 0; 0 <= M ? Z < M : Z > M; d = 0 <= M ? ++Z : --Z) K.push(e.readUInt16());
          return K;
        }(), i = (this.length - e.pos + this.offset) / 2, o = function() {
          var Z, K;
          for (K = [], d = Z = 0; 0 <= i ? Z < i : Z > i; d = 0 <= i ? ++Z : --Z) K.push(e.readUInt16());
          return K;
        }(), d = q = 0, re = s.length; q < re; d = ++q) for (V = s[d], n = Y = k = U[d]; k <= V ? Y <= V : Y >= V; n = k <= V ? ++Y : --Y) b[d] === 0 ? l = n + m[d] : (l = o[b[d] / 2 + (n - k) - (M - d)] || 0) !== 0 && (l += m[d]), this.codeMap[n] = 65535 & l;
    }
    e.pos = A;
  }
  return r.encode = function(e, t) {
    var n, i, s, l, o, d, m, b, A, M, E, k, U, V, q, Y, re, Z, K, ie, be, he, Be, ke, pe, me, je, Pe, St, Mt, Lt, xt, zt, Dt, hr, ce, Oe, $e, et, ot, ht, It, yt, ar, Kt, vr;
    switch (Pe = new Kh(), l = Object.keys(e).sort(function(sr, Ur) {
      return sr - Ur;
    }), t) {
      case "macroman":
        for (U = 0, V = function() {
          var sr = [];
          for (k = 0; k < 256; ++k) sr.push(0);
          return sr;
        }(), Y = { 0: 0 }, s = {}, St = 0, zt = l.length; St < zt; St++) Y[yt = e[i = l[St]]] == null && (Y[yt] = ++U), s[i] = { old: e[i], new: Y[e[i]] }, V[i] = Y[e[i]];
        return Pe.writeUInt16(1), Pe.writeUInt16(0), Pe.writeUInt32(12), Pe.writeUInt16(0), Pe.writeUInt16(262), Pe.writeUInt16(0), Pe.write(V), { charMap: s, subtable: Pe.data, maxGlyphID: U + 1 };
      case "unicode":
        for (me = [], A = [], re = 0, Y = {}, n = {}, q = m = null, Mt = 0, Dt = l.length; Mt < Dt; Mt++) Y[K = e[i = l[Mt]]] == null && (Y[K] = ++re), n[i] = { old: K, new: Y[K] }, o = Y[K] - i, q != null && o === m || (q && A.push(q), me.push(i), m = o), q = i;
        for (q && A.push(q), A.push(65535), me.push(65535), ke = 2 * (Be = me.length), he = 2 * Math.pow(Math.log(Be) / Math.LN2, 2), M = Math.log(he / 2) / Math.LN2, be = 2 * Be - he, d = [], ie = [], E = [], k = Lt = 0, hr = me.length; Lt < hr; k = ++Lt) {
          if (pe = me[k], b = A[k], pe === 65535) {
            d.push(0), ie.push(0);
            break;
          }
          if (pe - (je = n[pe].new) >= 32768) for (d.push(0), ie.push(2 * (E.length + Be - k)), i = xt = pe; pe <= b ? xt <= b : xt >= b; i = pe <= b ? ++xt : --xt) E.push(n[i].new);
          else d.push(je - pe), ie.push(0);
        }
        for (Pe.writeUInt16(3), Pe.writeUInt16(1), Pe.writeUInt32(12), Pe.writeUInt16(4), Pe.writeUInt16(16 + 8 * Be + 2 * E.length), Pe.writeUInt16(0), Pe.writeUInt16(ke), Pe.writeUInt16(he), Pe.writeUInt16(M), Pe.writeUInt16(be), ht = 0, ce = A.length; ht < ce; ht++) i = A[ht], Pe.writeUInt16(i);
        for (Pe.writeUInt16(0), It = 0, Oe = me.length; It < Oe; It++) i = me[It], Pe.writeUInt16(i);
        for (ar = 0, $e = d.length; ar < $e; ar++) o = d[ar], Pe.writeUInt16(o);
        for (Kt = 0, et = ie.length; Kt < et; Kt++) Z = ie[Kt], Pe.writeUInt16(Z);
        for (vr = 0, ot = E.length; vr < ot; vr++) U = E[vr], Pe.writeUInt16(U);
        return { charMap: n, subtable: Pe.data, maxGlyphID: re + 1 };
    }
  }, r;
}(), ZM = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return bu(e, kc), e.prototype.tag = "cmap", e.prototype.parse = function(t) {
    var n, i, s;
    for (t.pos = this.offset, this.version = t.readUInt16(), s = t.readUInt16(), this.tables = [], this.unicode = null, i = 0; 0 <= s ? i < s : i > s; i = 0 <= s ? ++i : --i) n = new oE(t, this.offset), this.tables.push(n), n.isUnicode && this.unicode == null && (this.unicode = n);
    return !0;
  }, e.encode = function(t, n) {
    var i, s;
    return n == null && (n = "macroman"), i = oE.encode(t, n), (s = new Kh()).writeUInt16(0), s.writeUInt16(1), i.table = s.data.concat(i.subtable), i;
  }, e;
}(), MZ = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return bu(e, kc), e.prototype.tag = "hhea", e.prototype.parse = function(t) {
    return t.pos = this.offset, this.version = t.readInt(), this.ascender = t.readShort(), this.decender = t.readShort(), this.lineGap = t.readShort(), this.advanceWidthMax = t.readShort(), this.minLeftSideBearing = t.readShort(), this.minRightSideBearing = t.readShort(), this.xMaxExtent = t.readShort(), this.caretSlopeRise = t.readShort(), this.caretSlopeRun = t.readShort(), this.caretOffset = t.readShort(), t.pos += 8, this.metricDataFormat = t.readShort(), this.numberOfMetrics = t.readUInt16();
  }, e;
}(), PZ = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return bu(e, kc), e.prototype.tag = "OS/2", e.prototype.parse = function(t) {
    if (t.pos = this.offset, this.version = t.readUInt16(), this.averageCharWidth = t.readShort(), this.weightClass = t.readUInt16(), this.widthClass = t.readUInt16(), this.type = t.readShort(), this.ySubscriptXSize = t.readShort(), this.ySubscriptYSize = t.readShort(), this.ySubscriptXOffset = t.readShort(), this.ySubscriptYOffset = t.readShort(), this.ySuperscriptXSize = t.readShort(), this.ySuperscriptYSize = t.readShort(), this.ySuperscriptXOffset = t.readShort(), this.ySuperscriptYOffset = t.readShort(), this.yStrikeoutSize = t.readShort(), this.yStrikeoutPosition = t.readShort(), this.familyClass = t.readShort(), this.panose = function() {
      var n, i;
      for (i = [], n = 0; n < 10; ++n) i.push(t.readByte());
      return i;
    }(), this.charRange = function() {
      var n, i;
      for (i = [], n = 0; n < 4; ++n) i.push(t.readInt());
      return i;
    }(), this.vendorID = t.readString(4), this.selection = t.readShort(), this.firstCharIndex = t.readShort(), this.lastCharIndex = t.readShort(), this.version > 0 && (this.ascent = t.readShort(), this.descent = t.readShort(), this.lineGap = t.readShort(), this.winAscent = t.readShort(), this.winDescent = t.readShort(), this.codePageRange = function() {
      var n, i;
      for (i = [], n = 0; n < 2; n = ++n) i.push(t.readInt());
      return i;
    }(), this.version > 1)) return this.xHeight = t.readShort(), this.capHeight = t.readShort(), this.defaultChar = t.readShort(), this.breakChar = t.readShort(), this.maxContext = t.readShort();
  }, e;
}(), RZ = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return bu(e, kc), e.prototype.tag = "post", e.prototype.parse = function(t) {
    var n, i, s;
    switch (t.pos = this.offset, this.format = t.readInt(), this.italicAngle = t.readInt(), this.underlinePosition = t.readShort(), this.underlineThickness = t.readShort(), this.isFixedPitch = t.readInt(), this.minMemType42 = t.readInt(), this.maxMemType42 = t.readInt(), this.minMemType1 = t.readInt(), this.maxMemType1 = t.readInt(), this.format) {
      case 65536:
        break;
      case 131072:
        var l;
        for (i = t.readUInt16(), this.glyphNameIndex = [], l = 0; 0 <= i ? l < i : l > i; l = 0 <= i ? ++l : --l) this.glyphNameIndex.push(t.readUInt16());
        for (this.names = [], s = []; t.pos < this.offset + this.length; ) n = t.readByte(), s.push(this.names.push(t.readString(n)));
        return s;
      case 151552:
        return i = t.readUInt16(), this.offsets = t.read(i);
      case 196608:
        break;
      case 262144:
        return this.map = (function() {
          var o, d, m;
          for (m = [], l = o = 0, d = this.file.maxp.numGlyphs; 0 <= d ? o < d : o > d; l = 0 <= d ? ++o : --o) m.push(t.readUInt32());
          return m;
        }).call(this);
    }
  }, e;
}(), BZ = function(r, e) {
  this.raw = r, this.length = r.length, this.platformID = e.platformID, this.encodingID = e.encodingID, this.languageID = e.languageID;
}, LZ = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return bu(e, kc), e.prototype.tag = "name", e.prototype.parse = function(t) {
    var n, i, s, l, o, d, m, b, A, M, E;
    for (t.pos = this.offset, t.readShort(), n = t.readShort(), d = t.readShort(), i = [], l = 0; 0 <= n ? l < n : l > n; l = 0 <= n ? ++l : --l) i.push({ platformID: t.readShort(), encodingID: t.readShort(), languageID: t.readShort(), nameID: t.readShort(), length: t.readShort(), offset: this.offset + d + t.readShort() });
    for (m = {}, l = A = 0, M = i.length; A < M; l = ++A) s = i[l], t.pos = s.offset, b = t.readString(s.length), o = new BZ(b, s), m[E = s.nameID] == null && (m[E] = []), m[s.nameID].push(o);
    this.strings = m, this.copyright = m[0], this.fontFamily = m[1], this.fontSubfamily = m[2], this.uniqueSubfamily = m[3], this.fontName = m[4], this.version = m[5];
    try {
      this.postscriptName = m[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch {
      this.postscriptName = m[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = m[7], this.manufacturer = m[8], this.designer = m[9], this.description = m[10], this.vendorUrl = m[11], this.designerUrl = m[12], this.license = m[13], this.licenseUrl = m[14], this.preferredFamily = m[15], this.preferredSubfamily = m[17], this.compatibleFull = m[18], this.sampleText = m[19];
  }, e;
}(), OZ = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return bu(e, kc), e.prototype.tag = "maxp", e.prototype.parse = function(t) {
    return t.pos = this.offset, this.version = t.readInt(), this.numGlyphs = t.readUInt16(), this.maxPoints = t.readUInt16(), this.maxContours = t.readUInt16(), this.maxCompositePoints = t.readUInt16(), this.maxComponentContours = t.readUInt16(), this.maxZones = t.readUInt16(), this.maxTwilightPoints = t.readUInt16(), this.maxStorage = t.readUInt16(), this.maxFunctionDefs = t.readUInt16(), this.maxInstructionDefs = t.readUInt16(), this.maxStackElements = t.readUInt16(), this.maxSizeOfInstructions = t.readUInt16(), this.maxComponentElements = t.readUInt16(), this.maxComponentDepth = t.readUInt16();
  }, e;
}(), kZ = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return bu(e, kc), e.prototype.tag = "hmtx", e.prototype.parse = function(t) {
    var n, i, s, l, o, d, m;
    for (t.pos = this.offset, this.metrics = [], n = 0, d = this.file.hhea.numberOfMetrics; 0 <= d ? n < d : n > d; n = 0 <= d ? ++n : --n) this.metrics.push({ advance: t.readUInt16(), lsb: t.readInt16() });
    for (s = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
      var b, A;
      for (A = [], n = b = 0; 0 <= s ? b < s : b > s; n = 0 <= s ? ++b : --b) A.push(t.readInt16());
      return A;
    }(), this.widths = (function() {
      var b, A, M, E;
      for (E = [], b = 0, A = (M = this.metrics).length; b < A; b++) l = M[b], E.push(l.advance);
      return E;
    }).call(this), i = this.widths[this.widths.length - 1], m = [], n = o = 0; 0 <= s ? o < s : o > s; n = 0 <= s ? ++o : --o) m.push(this.widths.push(i));
    return m;
  }, e.prototype.forGlyph = function(t) {
    return t in this.metrics ? this.metrics[t] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[t - this.metrics.length] };
  }, e;
}(), YM = [].slice, NZ = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return bu(e, kc), e.prototype.tag = "glyf", e.prototype.parse = function() {
    return this.cache = {};
  }, e.prototype.glyphFor = function(t) {
    var n, i, s, l, o, d, m, b, A, M;
    return t in this.cache ? this.cache[t] : (l = this.file.loca, n = this.file.contents, i = l.indexOf(t), (s = l.lengthOf(t)) === 0 ? this.cache[t] = null : (n.pos = this.offset + i, o = (d = new Kh(n.read(s))).readShort(), b = d.readShort(), M = d.readShort(), m = d.readShort(), A = d.readShort(), this.cache[t] = o === -1 ? new FZ(d, b, M, m, A) : new DZ(d, o, b, M, m, A), this.cache[t]));
  }, e.prototype.encode = function(t, n, i) {
    var s, l, o, d, m;
    for (o = [], l = [], d = 0, m = n.length; d < m; d++) s = t[n[d]], l.push(o.length), s && (o = o.concat(s.encode(i)));
    return l.push(o.length), { table: o, offsets: l };
  }, e;
}(), DZ = function() {
  function r(e, t, n, i, s, l) {
    this.raw = e, this.numberOfContours = t, this.xMin = n, this.yMin = i, this.xMax = s, this.yMax = l, this.compound = !1;
  }
  return r.prototype.encode = function() {
    return this.raw.data;
  }, r;
}(), FZ = function() {
  function r(e, t, n, i, s) {
    var l, o;
    for (this.raw = e, this.xMin = t, this.yMin = n, this.xMax = i, this.yMax = s, this.compound = !0, this.glyphIDs = [], this.glyphOffsets = [], l = this.raw; o = l.readShort(), this.glyphOffsets.push(l.pos), this.glyphIDs.push(l.readUInt16()), 32 & o; ) l.pos += 1 & o ? 4 : 2, 128 & o ? l.pos += 8 : 64 & o ? l.pos += 4 : 8 & o && (l.pos += 2);
  }
  return r.prototype.encode = function() {
    var e, t, n;
    for (t = new Kh(YM.call(this.raw.data)), e = 0, n = this.glyphIDs.length; e < n; ++e) t.pos = this.glyphOffsets[e];
    return t.data;
  }, r;
}(), UZ = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return bu(e, kc), e.prototype.tag = "loca", e.prototype.parse = function(t) {
    var n, i;
    return t.pos = this.offset, n = this.file.head.indexToLocFormat, this.offsets = n === 0 ? (function() {
      var s, l;
      for (l = [], i = 0, s = this.length; i < s; i += 2) l.push(2 * t.readUInt16());
      return l;
    }).call(this) : (function() {
      var s, l;
      for (l = [], i = 0, s = this.length; i < s; i += 4) l.push(t.readUInt32());
      return l;
    }).call(this);
  }, e.prototype.indexOf = function(t) {
    return this.offsets[t];
  }, e.prototype.lengthOf = function(t) {
    return this.offsets[t + 1] - this.offsets[t];
  }, e.prototype.encode = function(t, n) {
    for (var i = new Uint32Array(this.offsets.length), s = 0, l = 0, o = 0; o < i.length; ++o) if (i[o] = s, l < n.length && n[l] == o) {
      ++l, i[o] = s;
      var d = this.offsets[o], m = this.offsets[o + 1] - d;
      m > 0 && (s += m);
    }
    for (var b = new Array(4 * i.length), A = 0; A < i.length; ++A) b[4 * A + 3] = 255 & i[A], b[4 * A + 2] = (65280 & i[A]) >> 8, b[4 * A + 1] = (16711680 & i[A]) >> 16, b[4 * A] = (4278190080 & i[A]) >> 24;
    return b;
  }, e;
}(), zZ = function() {
  function r(e) {
    this.font = e, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return r.prototype.generateCmap = function() {
    var e, t, n, i, s;
    for (t in i = this.font.cmap.tables[0].codeMap, e = {}, s = this.subset) n = s[t], e[t] = i[n];
    return e;
  }, r.prototype.glyphsFor = function(e) {
    var t, n, i, s, l, o, d;
    for (i = {}, l = 0, o = e.length; l < o; l++) i[s = e[l]] = this.font.glyf.glyphFor(s);
    for (s in t = [], i) (n = i[s]) != null && n.compound && t.push.apply(t, n.glyphIDs);
    if (t.length > 0) for (s in d = this.glyphsFor(t)) n = d[s], i[s] = n;
    return i;
  }, r.prototype.encode = function(e, t) {
    var n, i, s, l, o, d, m, b, A, M, E, k, U, V, q;
    for (i in n = ZM.encode(this.generateCmap(), "unicode"), l = this.glyphsFor(e), E = { 0: 0 }, q = n.charMap) E[(d = q[i]).old] = d.new;
    for (k in M = n.maxGlyphID, l) k in E || (E[k] = M++);
    return b = function(Y) {
      var re, Z;
      for (re in Z = {}, Y) Z[Y[re]] = re;
      return Z;
    }(E), A = Object.keys(b).sort(function(Y, re) {
      return Y - re;
    }), U = function() {
      var Y, re, Z;
      for (Z = [], Y = 0, re = A.length; Y < re; Y++) o = A[Y], Z.push(b[o]);
      return Z;
    }(), s = this.font.glyf.encode(l, U, E), m = this.font.loca.encode(s.offsets, U), V = { cmap: this.font.cmap.raw(), glyf: s.table, loca: m, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(t) }, this.font.os2.exists && (V["OS/2"] = this.font.os2.raw()), this.font.directory.encode(V);
  }, r;
}();
rn.API.PDFObject = function() {
  var r;
  function e() {
  }
  return r = function(t, n) {
    return (Array(n + 1).join("0") + t).slice(-n);
  }, e.convert = function(t) {
    var n, i, s, l;
    if (Array.isArray(t)) return "[" + function() {
      var o, d, m;
      for (m = [], o = 0, d = t.length; o < d; o++) n = t[o], m.push(e.convert(n));
      return m;
    }().join(" ") + "]";
    if (typeof t == "string") return "/" + t;
    if (t != null && t.isString) return "(" + t + ")";
    if (t instanceof Date) return "(D:" + r(t.getUTCFullYear(), 4) + r(t.getUTCMonth(), 2) + r(t.getUTCDate(), 2) + r(t.getUTCHours(), 2) + r(t.getUTCMinutes(), 2) + r(t.getUTCSeconds(), 2) + "Z)";
    if ({}.toString.call(t) === "[object Object]") {
      for (i in s = ["<<"], t) l = t[i], s.push("/" + i + " " + e.convert(l));
      return s.push(">>"), s.join(`
`);
    }
    return "" + t;
  }, e;
}();
const Tx = { "circle-radius": 8, "circle-color": "red", "circle-stroke-width": 1, "circle-stroke-color": "black" }, dy = { style: { textSize: 16, textHaloColor: "#FFFFFF", textHaloWidth: 0.8, textColor: "#000000", fallbackTextFont: ["Open Sans Regular"] }, visibility: "visible", position: "bottom-right" }, py = { image: '<svg width="800px" height="800px" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--gis" preserveAspectRatio="xMidYMid meet"><path d="M47.655 1.634l-35 95c-.828 2.24 1.659 4.255 3.68 2.98l33.667-21.228l33.666 21.228c2.02 1.271 4.503-.74 3.678-2.98l-35-95C51.907.514 51.163.006 50 .008c-1.163.001-1.99.65-2.345 1.626zm-.155 14.88v57.54L19.89 91.461z" fill="none" stroke="white" stroke-width="1.5"/><path d="M47.655 1.634l-35 95c-.828 2.24 1.659 4.255 3.68 2.98l33.667-21.228l33.666 21.228c2.02 1.271 4.503-.74 3.678-2.98l-35-95C51.907.514 51.163.006 50 .008c-1.163.001-1.99.65-2.345 1.626zm-.155 14.88v57.54L19.89 91.461z" fill="#000000" fill-rule="evenodd"></path></svg>', imageName: "gl-export-north-icon", imageSizeFraction: 0.05, visibility: "visible", position: "top-right" };
class jZ {
  /**
  * Constructor
  * @param map MaplibreMap object
  * @param size layout size. default is A4
  * @param dpi dpi value. default is 300
  * @param format image format. default is PNG
  * @param unit length unit. default is mm
  * @param fileName file name. default is 'map'
  */
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Rf.A4, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 300, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Ku.PNG, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : dp.mm, l = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "map", o = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : "maplibregl-marker", d = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : Tx, m = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : "maplibregl-ctrl-attrib-inner", b = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : dy, A = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : py;
    $n(this, "map"), $n(this, "width"), $n(this, "height"), $n(this, "dpi"), $n(this, "format"), $n(this, "unit"), $n(this, "fileName"), $n(this, "markerClassName"), $n(this, "markerCirclePaint"), $n(this, "attributionClassName"), $n(this, "attributionOptions"), $n(this, "northIconOptions"), this.map = e, this.width = t[0], this.height = t[1], this.dpi = n, this.format = i, this.unit = s, this.fileName = l, this.markerClassName = o, this.markerCirclePaint = d, this.attributionClassName = m, this.attributionOptions = b, this.northIconOptions = A;
  }
  renderMapPost(e) {
    return e;
  }
  getMarkers() {
    return this.map.getCanvasContainer().getElementsByClassName(this.markerClassName);
  }
  renderMarkers(e) {
    const t = this.getMarkers();
    for (let n = 0; n < t.length; n++) {
      const i = t.item(n);
      if (!i) continue;
      const s = i.getAttribute("style");
      if (!s) continue;
      const l = /translate\(([^,]+)px,\s*([^,]+)px\)/, o = s.match(l);
      if (!o) continue;
      const d = parseInt(o[1]), m = parseInt(o[2]), b = this.map.unproject([d, m]), A = `point${n}`;
      e.addSource(A, { type: "geojson", data: { type: "Point", coordinates: [b.lng, b.lat] } }), e.addLayer({ id: A, source: A, type: "circle", paint: this.markerCirclePaint });
    }
    return e;
  }
  /**
  * Generate and download Map image
  */
  generate() {
    const e = this;
    this.addLoader(), this.showLoader();
    const t = window.devicePixelRatio;
    Object.defineProperty(window, "devicePixelRatio", { get() {
      return e.dpi / 96;
    } });
    const n = document.createElement("div");
    n.className = "hidden-map", document.body.appendChild(n);
    const i = document.createElement("div");
    i.style.width = this.toPixels(this.width), i.style.height = this.toPixels(this.height), n.appendChild(i);
    const s = this.map.getStyle();
    if (s && s.sources) {
      const o = s.sources;
      Object.keys(o).forEach((d) => {
        const m = o[d];
        Object.keys(m).forEach((b) => {
          m[b] || delete m[b];
        });
      });
    }
    let l = this.getRenderedMap(i, s);
    l.on("load", () => {
      this.addNorthIconToMap(l).then(() => {
        l.once("idle", () => {
          this.addAttributions(l) ? l.once("idle", () => {
            l = this.renderMapPost(l), this.getMarkers().length === 0 ? this.exportImage(l, n, t) : (l = this.renderMarkers(l), l.once("idle", () => {
              this.exportImage(l, n, t);
            }));
          }) : (l = this.renderMapPost(l), this.getMarkers().length === 0 ? this.exportImage(l, n, t) : (l = this.renderMarkers(l), l.once("idle", () => {
            this.exportImage(l, n, t);
          })));
        });
      });
    });
  }
  stripHtml(e) {
    const t = document.createElement("div");
    return t.innerHTML = e, t.textContent || t.innerText || "";
  }
  /**
  * Get icon width against exported map size by using fraction rate
  * @param renderMap Map object
  * @param fraction adjust icon size by using this fraction rate. Default is 8%
  * @returns Icon width calculated
  */
  getIconWidth(e, t) {
    const n = e.getContainer(), i = parseInt(n.style.width.replace("px", ""));
    return parseInt(`${i * t}`);
  }
  /**
  * Get element position's pixel values based on selected position setting
  * @param renderMap Map object
  * @param position Position of element inserted
  * @param offset Offset value to adjust position
  * @returns Pixels [width, height]
  */
  getElementPosition(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    const i = e.getContainer();
    let s = 0, l = 0;
    switch (t) {
      case "top-left":
        s = 0 + n, l = 0 + n;
        break;
      case "top-right":
        s = parseInt(i.style.width.replace("px", "")) - n, l = 0 + n;
        break;
      case "bottom-left":
        s = 0 + n, l = parseInt(i.style.height.replace("px", "")) - n;
        break;
      case "bottom-right":
        s = parseInt(i.style.width.replace("px", "")) - n, l = parseInt(i.style.height.replace("px", "")) - n;
        break;
    }
    return [s, l];
  }
  /**
  * Add North Icon SVG to map object
  * @param renderMap Map object
  * @returns void
  */
  addNorthIconImage(e) {
    const t = this.getIconWidth(e, this.northIconOptions.imageSizeFraction ?? 0.08);
    return new Promise((n) => {
      const i = new Image(t, t);
      i.onload = () => {
        this.northIconOptions.imageName && e.addImage(this.northIconOptions.imageName, i), n();
      };
      function s(l) {
        return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(l);
      }
      this.northIconOptions.image && (i.src = s(this.northIconOptions.image));
    });
  }
  /**
  * Add North Icon Symbol layer to renderMap object
  * @param renderMap Map object
  * @returns
  */
  addNorthIconToMap(e) {
    let t = this.northIconOptions.visibility ?? "visible";
    return e.getZoom() < 2 && this.width > this.height && (t = "none"), new Promise((n) => {
      this.addNorthIconImage(e).then(() => {
        const i = this.getIconWidth(e, this.northIconOptions.imageSizeFraction ?? 0.08) * 0.8, s = this.getElementPosition(e, this.northIconOptions.position ?? "top-right", i), l = e.unproject(s), o = this.northIconOptions.imageName ?? "gl-export-north-icon";
        e.addSource(o, { type: "geojson", data: { type: "Feature", geometry: { type: "Point", coordinates: [l.lng, l.lat] }, properties: {} } }), e.addLayer({ id: o, source: o, type: "symbol", layout: { "icon-image": o, "icon-size": 1, "icon-rotate": e.getBearing() * -1, "icon-allow-overlap": !0, "icon-ignore-placement": !0, visibility: t }, paint: {} }), n();
      });
    });
  }
  addAttributions(e) {
    var t;
    if (!this.map.getStyle().glyphs) return !1;
    const n = e.getContainer(), i = this.attributionOptions.position ?? "bottom-right", s = this.getElementPosition(e, i, 5), l = s[0], o = e.unproject(s), d = n.getElementsByClassName(this.attributionClassName), m = [];
    if ((d == null ? void 0 : d.length) > 0) {
      const V = d.item(0);
      if (V) for (let q = 0; q < V.children.length; q++) {
        const Y = V.children.item(q);
        Y && m.push(this.stripHtml(Y.outerHTML));
      }
    } else {
      const V = this.map.getStyle().sources;
      Object.keys(V).forEach((q) => {
        const Y = V[q];
        if ("attribution" in Y) {
          const re = Y.attribution;
          m.push(this.stripHtml(re));
        }
      });
    }
    if (m.length === 0) return !1;
    const b = m.join(" | "), A = "attribution";
    e.addSource(A, { type: "geojson", data: { type: "Feature", geometry: { type: "Point", coordinates: [o.lng, o.lat] }, properties: { attribution: b } } });
    const M = this.map.getStyle().layers.filter((V) => V.type === "symbol" && V.layout && "text-font" in V.layout), E = M.length > 0 && M[0].layout ? M[0].layout["text-font"] : (t = this.attributionOptions.style) == null ? void 0 : t.fallbackTextFont;
    let k = this.attributionOptions.visibility ?? "visible";
    e.getZoom() < 2 && this.width > this.height && (k = "none");
    const U = this.attributionOptions.style;
    return e.addLayer({ id: A, source: A, type: "symbol", layout: { "text-field": ["get", "attribution"], "text-font": E, "text-max-width": parseInt(`${l / U.textSize}`), "text-anchor": i, "text-justify": ["top-right", "bottom-right"].includes(i) ? "right" : "left", "text-size": U.textSize, "text-allow-overlap": !0, visibility: k }, paint: { "text-halo-color": U.textHaloColor, "text-halo-width": U.textHaloWidth, "text-color": U.textColor } }), !0;
  }
  exportImage(e, t, n) {
    var i;
    const s = e.getCanvas(), l = `${this.fileName}.${this.format}`;
    switch (this.format) {
      case Ku.PNG:
        this.toPNG(s, l);
        break;
      case Ku.JPEG:
        this.toJPEG(s, l);
        break;
      case Ku.PDF:
        this.toPDF(e, l);
        break;
      case Ku.SVG:
        this.toSVG(s, l);
        break;
      default:
        console.error(`Invalid file format: ${this.format}`);
        break;
    }
    e.remove(), (i = t.parentNode) == null || i.removeChild(t), Object.defineProperty(window, "devicePixelRatio", { get() {
      return n;
    } }), t.remove(), this.hideLoader();
  }
  /**
  * Convert canvas to PNG
  * @param canvas Canvas element
  * @param fileName file name
  */
  toPNG(e, t) {
    const n = document.createElement("a");
    n.href = e.toDataURL(), n.download = t, n.click(), n.remove();
  }
  /**
  * Convert canvas to JPEG
  * @param canvas Canvas element
  * @param fileName file name
  */
  toJPEG(e, t) {
    const n = e.toDataURL("image/jpeg", 0.85), i = document.createElement("a");
    i.href = n, i.download = t, i.click(), i.remove();
  }
  /**
  * Convert Map object to PDF
  * @param map Map object
  * @param fileName file name
  */
  toPDF(e, t) {
    const n = e.getCanvas(), i = new rn({ orientation: this.width > this.height ? "l" : "p", unit: this.unit, compress: !0, format: [this.width, this.height] });
    i.addImage(n.toDataURL("image/png"), "png", 0, 0, this.width, this.height, void 0, "FAST");
    const { lng: s, lat: l } = e.getCenter();
    i.setProperties({ title: e.getStyle().name, subject: `center: [${s}, ${l}], zoom: ${e.getZoom()}`, creator: "Mapbox GL Export Plugin", author: "(c)Mapbox, (c)OpenStreetMap" }), i.save(t);
  }
  /**
  * Convert canvas to SVG
  * @param canvas Canvas element
  * @param fileName file name
  */
  toSVG(e, t) {
    const n = e.toDataURL("image/png"), i = Number(this.toPixels(this.width, this.dpi).replace("px", "")), s = Number(this.toPixels(this.height, this.dpi).replace("px", "")), l = `
    <svg xmlns="http://www.w3.org/2000/svg" 
      xmlns:xlink="http://www.w3.org/1999/xlink" 
      version="1.1" 
      width="${i}" 
      height="${s}" 
      viewBox="0 0 ${i} ${s}" 
      xml:space="preserve">
        <image style="stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: rgb(0,0,0); fill-rule: nonzero; opacity: 1;"  
      xlink:href="${n}" width="${i}" height="${s}"></image>
    </svg>`, o = document.createElement("a");
    o.href = `data:application/xml,${encodeURIComponent(l)}`, o.download = t, o.click(), o.remove();
  }
  /**
  * Convert mm/inch to pixel
  * @param length mm/inch length
  * @param conversionFactor DPI value. default is 96.
  */
  toPixels(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 96;
    return this.unit === dp.mm && (t /= 25.4), `${t * e}px`;
  }
  /**
  * Add loader in the parent element of maplibre map.
  */
  addLoader() {
    var e;
    const t = (e = this.map.getCanvas().parentElement) == null ? void 0 : e.parentElement;
    if (!t || t.getElementsByClassName("map-export-loader").length > 0) return;
    const n = document.createElement("span");
    n.classList.add("map-export-loader"), n.classList.add("loader-default"), t.appendChild(n);
  }
  /**
  * Show loader
  */
  showLoader() {
    var e, t;
    const n = (e = this.map.getCanvas().parentElement) == null ? void 0 : e.parentElement;
    if (!n) return;
    const i = n.getElementsByClassName("map-export-loader");
    i && i.length > 0 && ((t = i.item(0)) == null || t.classList.add("is-active"));
  }
  /**
  * Hide loader
  */
  hideLoader() {
    var e, t;
    const n = (e = this.map.getCanvas().parentElement) == null ? void 0 : e.parentElement;
    if (!n) return;
    const i = n.getElementsByClassName("map-export-loader");
    i && i.length > 0 && ((t = i.item(0)) == null || t.classList.remove("is-active"));
  }
}
class VZ extends jZ {
  /**
  * Constructor
  * @param map MaplibreMap object
  * @param size layout size. default is A4
  * @param dpi dpi value. default is 300
  * @param format image format. default is PNG
  * @param unit length unit. default is mm
  * @param fileName file name. default is 'map'
  */
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Rf.A4, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 300, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Ku.PNG, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : dp.mm, l = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "map", o = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : Tx, d = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : dy, m = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : py;
    super(e, t, n, i, s, l, "maplibregl-marker", o, "maplibregl-ctrl-attrib-inner", d, m);
  }
  getRenderedMap(e, t) {
    const n = new kE.Map({
      container: e,
      style: t,
      center: this.map.getCenter(),
      zoom: this.map.getZoom(),
      bearing: this.map.getBearing(),
      pitch: this.map.getPitch(),
      interactive: !1,
      canvasContextAttributes: { preserveDrawingBuffer: !0 },
      fadeDuration: 0,
      // attributionControl: false,
      // hack to read transform request callback function
      // eslint-disable-next-line
      // @ts-ignore
      transformRequest: this.map._requestManager._transformRequestFn
    });
    this.map.getTerrain() && (n.setMaxPitch(85), n.setPitch(this.map.getPitch()));
    const i = (this.map.style.imageManager || {}).images || [];
    return Object.keys(i).forEach((s) => {
      i[s].data && n.addImage(s, i[s].data);
    }), n;
  }
  renderMapPost(e) {
    const t = this.map.getTerrain();
    return t && e.setTerrain({ source: t.source, exaggeration: t.exaggeration }), e;
  }
}
class $Z {
  constructor(e) {
    $n(this, "controlContainer"), $n(this, "exportContainer"), $n(this, "crosshair"), $n(this, "printableArea"), $n(this, "map"), $n(this, "exportButton"), $n(this, "options", { PageSize: Rf.A4, PageOrientation: pg.Landscape, Format: Ku.PDF, DPI: Nv[300], Crosshair: !1, PrintableArea: !1, Local: "en", AllowedSizes: Object.keys(Rf), Filename: "map", markerCirclePaint: Tx, attributionOptions: dy, northIconOptions: py }), $n(this, "MAPLIB_CSS_PREFIX", "maplibregl"), e && (e.attributionOptions = Object.assign(dy, e.attributionOptions), e.northIconOptions = Object.assign(py, e.northIconOptions), this.options = Object.assign(this.options, e)), this.onDocumentClick = this.onDocumentClick.bind(this);
  }
  getDefaultPosition() {
    return "top-right";
  }
  getTranslation() {
    const e = this.options.Local ?? "en";
    return $X(e);
  }
  onAdd(e) {
    var t;
    this.map = e, this.controlContainer = document.createElement("div"), this.controlContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl`), this.controlContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl-group`), this.exportContainer = document.createElement("div"), this.exportContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-export-list`), this.exportButton = document.createElement("button"), this.exportButton.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl-icon`), this.exportButton.classList.add(`${this.MAPLIB_CSS_PREFIX}-export-control`), this.exportButton.type = "button", this.exportButton.addEventListener("click", () => {
      this.exportButton.style.display = "none", this.exportContainer.style.display = "block", this.toggleCrosshair(!0), this.togglePrintableArea(!0);
    }), document.addEventListener("click", this.onDocumentClick), this.controlContainer.appendChild(this.exportButton), this.controlContainer.appendChild(this.exportContainer);
    const n = document.createElement("TABLE");
    n.className = "print-table";
    const i = {};
    (t = this.options.AllowedSizes) == null || t.forEach((b) => {
      Rf[b] && (i[b] = Rf[b]);
    });
    const s = this.createSelection(i, this.getTranslation().PageSize, "page-size", this.options.PageSize, (b, A) => JSON.stringify(b[A]));
    n.appendChild(s);
    const l = this.createSelection(pg, this.getTranslation().PageOrientation, "page-orientation", this.options.PageOrientation, (b, A) => b[A]);
    n.appendChild(l);
    const o = this.createSelection(Ku, this.getTranslation().Format, "format-type", this.options.Format, (b, A) => b[A]);
    n.appendChild(o);
    const d = this.createSelection(Nv, this.getTranslation().DPI, "dpi-type", this.options.DPI, (b, A) => b[A]);
    n.appendChild(d), this.exportContainer.appendChild(n);
    const m = document.createElement("button");
    return m.type = "button", m.textContent = this.getTranslation().Generate, m.classList.add("generate-button"), m.addEventListener("click", () => {
      const b = document.getElementById("mapbox-gl-export-page-size"), A = document.getElementById("mapbox-gl-export-page-orientation"), M = document.getElementById("mapbox-gl-export-format-type"), E = document.getElementById("mapbox-gl-export-dpi-type"), k = A.value;
      let U = JSON.parse(b.value);
      k === pg.Portrait && (U = U.reverse()), this.generateMap(e, U, Number(E.value), M.value, dp.mm, this.options.Filename);
    }), this.exportContainer.appendChild(m), this.controlContainer;
  }
  generateMap(e, t, n, i, s, l) {
    new VZ(e, t, n, i, s, l, this.options.markerCirclePaint, this.options.attributionOptions, this.options.northIconOptions).generate();
  }
  createSelection(e, t, n, i, s) {
    const l = document.createElement("label");
    l.textContent = t;
    const o = document.createElement("select");
    o.setAttribute("id", `mapbox-gl-export-${n}`), o.style.width = "100%", Object.keys(e).forEach((A) => {
      const M = document.createElement("option");
      M.setAttribute("value", s(e, A)), M.appendChild(document.createTextNode(A)), M.setAttribute("name", n), i === e[A] && (M.selected = !0), o.appendChild(M);
    }), o.addEventListener("change", () => {
      this.updatePrintableArea();
    });
    const d = document.createElement("TR"), m = document.createElement("TD"), b = document.createElement("TD");
    return m.appendChild(l), b.appendChild(o), d.appendChild(m), d.appendChild(b), d;
  }
  onRemove() {
    !this.controlContainer || !this.controlContainer.parentNode || !this.map || !this.exportButton || (this.exportButton.removeEventListener("click", this.onDocumentClick), this.controlContainer.parentNode.removeChild(this.controlContainer), document.removeEventListener("click", this.onDocumentClick), this.crosshair !== void 0 && (this.crosshair.destroy(), this.crosshair = void 0), this.printableArea !== void 0 && (this.printableArea.destroy(), this.printableArea = void 0), this.map = void 0);
  }
  onDocumentClick(e) {
    this.controlContainer && !this.controlContainer.contains(e.target) && this.exportContainer && this.exportButton && (this.exportContainer.style.display = "none", this.exportButton.style.display = "block", this.toggleCrosshair(!1), this.togglePrintableArea(!1));
  }
  toggleCrosshair(e) {
    this.options.Crosshair === !0 && (e === !1 ? this.crosshair !== void 0 && (this.crosshair.destroy(), this.crosshair = void 0) : (this.crosshair = new IX(this.map), this.crosshair.create()));
  }
  togglePrintableArea(e) {
    this.options.PrintableArea === !0 && (e === !1 ? this.printableArea !== void 0 && (this.printableArea.destroy(), this.printableArea = void 0) : (this.printableArea = new MX(this.map), this.updatePrintableArea()));
  }
  updatePrintableArea() {
    if (this.printableArea === void 0) return;
    const e = document.getElementById("mapbox-gl-export-page-size"), t = document.getElementById("mapbox-gl-export-page-orientation").value;
    let n = JSON.parse(e.value);
    t === pg.Portrait && (n = n.reverse()), this.printableArea.updateArea(n[0], n[1]);
  }
}
function g1(r, e, t, n) {
  function i(s) {
    return s instanceof t ? s : new t(function(l) {
      l(s);
    });
  }
  return new (t || (t = Promise))(function(s, l) {
    function o(b) {
      try {
        m(n.next(b));
      } catch (A) {
        l(A);
      }
    }
    function d(b) {
      try {
        m(n.throw(b));
      } catch (A) {
        l(A);
      }
    }
    function m(b) {
      b.done ? s(b.value) : i(b.value).then(o, d);
    }
    m((n = n.apply(r, e || [])).next());
  });
}
var n_ = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Yy(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var m1, aE;
function KM() {
  if (aE) return m1;
  aE = 1, m1 = e;
  var r = Object.prototype.hasOwnProperty;
  function e() {
    for (var t = {}, n = 0; n < arguments.length; n++) {
      var i = arguments[n];
      for (var s in i)
        r.call(i, s) && (t[s] = i[s]);
    }
    return t;
  }
  return m1;
}
var _1 = {
  exports: {}
}, lE;
function qZ() {
  return lE || (lE = 1, function(r, e) {
    (function() {
      var t = {};
      r.exports = t, t.simpleFilter = function(n, i) {
        return i.filter(function(s) {
          return t.test(n, s);
        });
      }, t.test = function(n, i) {
        return t.match(n, i) !== null;
      }, t.match = function(n, i, s) {
        s = s || {};
        var l = 0, o = [], d = i.length, m = 0, b = 0, A = s.pre || "", M = s.post || "", E = s.caseSensitive && i || i.toLowerCase(), k;
        n = s.caseSensitive && n || n.toLowerCase();
        for (var U = 0; U < d; U++)
          k = i[U], E[U] === n[l] ? (k = A + k + M, l += 1, b += 1 + b) : b = 0, m += b, o[o.length] = k;
        return l === n.length ? (m = E === n ? 1 / 0 : m, {
          rendered: o.join(""),
          score: m
        }) : null;
      }, t.filter = function(n, i, s) {
        return !i || i.length === 0 ? [] : typeof n != "string" ? i : (s = s || {}, i.reduce(function(l, o, d, m) {
          var b = o;
          s.extract && (b = s.extract(o));
          var A = t.match(n, b, s);
          return A != null && (l[l.length] = {
            string: A.rendered,
            score: A.score,
            index: d,
            original: o
          }), l;
        }, []).sort(function(l, o) {
          var d = o.score - l.score;
          return d || l.index - o.index;
        }));
      };
    })();
  }(_1)), _1.exports;
}
var y1, cE;
function GZ() {
  if (cE) return y1;
  cE = 1;
  var r = function(e) {
    return this.component = e, this.items = [], this.active = e.options.noInitialSelection ? -1 : 0, this.wrapper = document.createElement("div"), this.wrapper.className = "suggestions-wrapper", this.element = document.createElement("ul"), this.element.className = "suggestions", this.wrapper.appendChild(this.element), this.selectingListItem = !1, e.el.parentNode.insertBefore(this.wrapper, e.el.nextSibling), this;
  };
  return r.prototype.show = function() {
    this.element.style.display = "block";
  }, r.prototype.hide = function() {
    this.element.style.display = "none";
  }, r.prototype.add = function(e) {
    this.items.push(e);
  }, r.prototype.clear = function() {
    this.items = [], this.active = this.component.options.noInitialSelection ? -1 : 0;
  }, r.prototype.isEmpty = function() {
    return !this.items.length;
  }, r.prototype.isVisible = function() {
    return this.element.style.display === "block";
  }, r.prototype.draw = function() {
    if (this.element.innerHTML = "", this.items.length === 0) {
      this.hide();
      return;
    }
    for (var e = 0; e < this.items.length; e++)
      this.drawItem(this.items[e], this.active === e);
    this.show();
  }, r.prototype.drawItem = function(e, t) {
    var n = document.createElement("li"), i = document.createElement("a");
    t && (n.className += " active"), i.innerHTML = e.string, n.appendChild(i), this.element.appendChild(n), n.addEventListener("mousedown", (function() {
      this.selectingListItem = !0;
    }).bind(this)), n.addEventListener("mouseup", (function() {
      this.handleMouseUp.call(this, e);
    }).bind(this));
  }, r.prototype.handleMouseUp = function(e) {
    this.selectingListItem = !1, this.component.value(e.original), this.clear(), this.draw();
  }, r.prototype.move = function(e) {
    this.active = e, this.draw();
  }, r.prototype.previous = function() {
    this.move(this.active <= 0 ? this.items.length - 1 : this.active - 1);
  }, r.prototype.next = function() {
    this.move(this.active >= this.items.length - 1 ? 0 : this.active + 1);
  }, r.prototype.drawError = function(e) {
    var t = document.createElement("li");
    t.innerHTML = e, this.element.appendChild(t), this.show();
  }, y1 = r, y1;
}
var b1, uE;
function HZ() {
  if (uE) return b1;
  uE = 1;
  var r = KM(), e = qZ(), t = GZ(), n = function(i, s, l) {
    return l = l || {}, this.options = r({
      minLength: 2,
      limit: 5,
      filter: !0,
      hideOnBlur: !0,
      noInitialSelection: !0
    }, l), this.el = i, this.data = s || [], this.list = new t(this), this.query = "", this.selected = null, this.list.draw(), this.el.addEventListener("keyup", (function(o) {
      this.handleKeyUp(o.keyCode, o);
    }).bind(this), !1), this.el.addEventListener("keydown", (function(o) {
      this.handleKeyDown(o);
    }).bind(this)), this.el.addEventListener("focus", (function() {
      this.handleFocus();
    }).bind(this)), this.el.addEventListener("blur", (function() {
      this.handleBlur();
    }).bind(this)), this.el.addEventListener("paste", (function(o) {
      this.handlePaste(o);
    }).bind(this)), this.render = this.options.render ? this.options.render.bind(this) : this.render.bind(this), this.getItemValue = this.options.getItemValue ? this.options.getItemValue.bind(this) : this.getItemValue.bind(this), this;
  };
  return n.prototype.handleKeyUp = function(i, s) {
    if (!(i === 40 || i === 38 || i === 27 || i === 9)) {
      if (i === 13) {
        this.list.items[this.list.active] && (this.list.handleMouseUp(this.list.items[this.list.active]), s.stopPropagation());
        return;
      }
      this.handleInputChange(this.el.value);
    }
  }, n.prototype.handleKeyDown = function(i) {
    switch (i.keyCode) {
      case 13:
        this.list.active >= 0 && (this.list.selectingListItem = !0);
        break;
      case 9:
        this.list.isEmpty() || (this.list.isVisible() && i.preventDefault(), this.value(this.list.active >= 0 ? this.list.items[this.list.active].original : null), this.list.hide());
        break;
      case 27:
        this.list.isEmpty() || this.list.hide();
        break;
      case 38:
        this.list.previous();
        break;
      case 40:
        this.list.next();
        break;
    }
  }, n.prototype.handleBlur = function() {
    !this.list.selectingListItem && this.options.hideOnBlur && this.list.hide();
  }, n.prototype.handlePaste = function(i) {
    if (i.clipboardData)
      this.handleInputChange(i.clipboardData.getData("Text"));
    else {
      var s = this;
      setTimeout(function() {
        s.handleInputChange(i.target.value);
      }, 100);
    }
  }, n.prototype.handleInputChange = function(i) {
    if (this.query = this.normalize(i), this.list.clear(), this.query.length < this.options.minLength) {
      this.list.draw();
      return;
    }
    this.getCandidates((function(s) {
      for (var l = 0; l < s.length && (this.list.add(s[l]), l !== this.options.limit - 1); l++)
        ;
      this.list.draw();
    }).bind(this));
  }, n.prototype.handleFocus = function() {
    this.list.isEmpty() || this.list.show(), this.list.selectingListItem = !1;
  }, n.prototype.update = function(i) {
    this.data = i, this.handleKeyUp();
  }, n.prototype.clear = function() {
    this.data = [], this.list.clear();
  }, n.prototype.normalize = function(i) {
    return i = i.toLowerCase(), i;
  }, n.prototype.match = function(i, s) {
    return i.indexOf(s) > -1;
  }, n.prototype.value = function(i) {
    if (this.selected = i, this.el.value = this.getItemValue(i || {
      place_name: this.query
    }), document.createEvent) {
      var s = document.createEvent("HTMLEvents");
      s.initEvent("change", !0, !1), this.el.dispatchEvent(s);
    } else
      this.el.fireEvent("onchange");
  }, n.prototype.getCandidates = function(i) {
    var s = {
      pre: "<strong>",
      post: "</strong>",
      extract: (function(o) {
        return this.getItemValue(o);
      }).bind(this)
    }, l;
    this.options.filter ? (l = e.filter(this.query, this.data, s), l = l.map((function(o) {
      return {
        original: o.original,
        string: this.render(o.original, o.string)
      };
    }).bind(this))) : l = this.data.map((function(o) {
      var d = this.render(o);
      return {
        original: o,
        string: d
      };
    }).bind(this)), i(l);
  }, n.prototype.getItemValue = function(i) {
    return i;
  }, n.prototype.render = function(i, s) {
    if (s)
      return s;
    for (var l = i.original ? this.getItemValue(i.original) : this.getItemValue(i), o = this.normalize(l), d = o.lastIndexOf(this.query); d > -1; ) {
      var m = d + this.query.length;
      l = l.slice(0, d) + "<strong>" + l.slice(d, m) + "</strong>" + l.slice(m), d = o.slice(0, d).lastIndexOf(this.query);
    }
    return l;
  }, n.prototype.renderError = function(i) {
    this.list.drawError(i);
  }, b1 = n, b1;
}
var v1, hE;
function WZ() {
  if (hE) return v1;
  hE = 1;
  var r = HZ();
  return v1 = r, typeof window < "u" && (window.Suggestions = r), v1;
}
var XZ = WZ(), ZZ = /* @__PURE__ */ Yy(XZ), S_ = {
  exports: {}
}, YZ = S_.exports, fE;
function KZ() {
  return fE || (fE = 1, function(r) {
    (function(e, t, n) {
      r.exports ? r.exports = n() : e[t] = n();
    })(YZ, "subtag", function() {
      var e = "", t = /^([a-zA-Z]{2,3})(?:[_-]+([a-zA-Z]{3})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{4})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{2}|[0-9]{3})(?=$|[_-]+))?/;
      function n(d) {
        return d.match(t) || [];
      }
      function i(d) {
        return n(d).filter(function(m, b) {
          return m && b;
        });
      }
      function s(d) {
        return d = n(d), {
          language: d[1] || e,
          extlang: d[2] || e,
          script: d[3] || e,
          region: d[4] || e
        };
      }
      function l(d, m, b) {
        Object.defineProperty(d, m, {
          value: b,
          enumerable: !0
        });
      }
      function o(d, m, b) {
        function A(M) {
          return n(M)[d] || e;
        }
        l(A, "pattern", m), l(s, b, A);
      }
      return o(1, /^[a-zA-Z]{2,3}$/, "language"), o(2, /^[a-zA-Z]{3}$/, "extlang"), o(3, /^[a-zA-Z]{4}$/, "script"), o(4, /^[a-zA-Z]{2}$|^[0-9]{3}$/, "region"), l(s, "split", i), s;
    });
  }(S_)), S_.exports;
}
var JZ = KZ(), QZ = /* @__PURE__ */ Yy(JZ), x1, dE;
function eY() {
  if (dE) return x1;
  dE = 1;
  var r = "Expected a function", e = NaN, t = "[object Symbol]", n = /^\s+|\s+$/g, i = /^[-+]0x[0-9a-f]+$/i, s = /^0b[01]+$/i, l = /^0o[0-7]+$/i, o = parseInt, d = typeof n_ == "object" && n_ && n_.Object === Object && n_, m = typeof self == "object" && self && self.Object === Object && self, b = d || m || Function("return this")(), A = Object.prototype, M = A.toString, E = Math.max, k = Math.min, U = function() {
    return b.Date.now();
  };
  function V(K, ie, be) {
    var he, Be, ke, pe, me, je, Pe = 0, St = !1, Mt = !1, Lt = !0;
    if (typeof K != "function")
      throw new TypeError(r);
    ie = Z(ie) || 0, q(be) && (St = !!be.leading, Mt = "maxWait" in be, ke = Mt ? E(Z(be.maxWait) || 0, ie) : ke, Lt = "trailing" in be ? !!be.trailing : Lt);
    function xt(ht) {
      var It = he, yt = Be;
      return he = Be = void 0, Pe = ht, pe = K.apply(yt, It), pe;
    }
    function zt(ht) {
      return Pe = ht, me = setTimeout(ce, ie), St ? xt(ht) : pe;
    }
    function Dt(ht) {
      var It = ht - je, yt = ht - Pe, ar = ie - It;
      return Mt ? k(ar, ke - yt) : ar;
    }
    function hr(ht) {
      var It = ht - je, yt = ht - Pe;
      return je === void 0 || It >= ie || It < 0 || Mt && yt >= ke;
    }
    function ce() {
      var ht = U();
      if (hr(ht))
        return Oe(ht);
      me = setTimeout(ce, Dt(ht));
    }
    function Oe(ht) {
      return me = void 0, Lt && he ? xt(ht) : (he = Be = void 0, pe);
    }
    function $e() {
      me !== void 0 && clearTimeout(me), Pe = 0, he = je = Be = me = void 0;
    }
    function et() {
      return me === void 0 ? pe : Oe(U());
    }
    function ot() {
      var ht = U(), It = hr(ht);
      if (he = arguments, Be = this, je = ht, It) {
        if (me === void 0)
          return zt(je);
        if (Mt)
          return me = setTimeout(ce, ie), xt(je);
      }
      return me === void 0 && (me = setTimeout(ce, ie)), pe;
    }
    return ot.cancel = $e, ot.flush = et, ot;
  }
  function q(K) {
    var ie = typeof K;
    return !!K && (ie == "object" || ie == "function");
  }
  function Y(K) {
    return !!K && typeof K == "object";
  }
  function re(K) {
    return typeof K == "symbol" || Y(K) && M.call(K) == t;
  }
  function Z(K) {
    if (typeof K == "number")
      return K;
    if (re(K))
      return e;
    if (q(K)) {
      var ie = typeof K.valueOf == "function" ? K.valueOf() : K;
      K = q(ie) ? ie + "" : ie;
    }
    if (typeof K != "string")
      return K === 0 ? K : +K;
    K = K.replace(n, "");
    var be = s.test(K);
    return be || l.test(K) ? o(K.slice(2), be ? 2 : 8) : i.test(K) ? e : +K;
  }
  return x1 = V, x1;
}
var tY = eY(), rY = /* @__PURE__ */ Yy(tY), nY = KM(), _c = /* @__PURE__ */ Yy(nY), i_ = {
  exports: {}
}, pE;
function iY() {
  if (pE) return i_.exports;
  pE = 1;
  var r = typeof Reflect == "object" ? Reflect : null, e = r && typeof r.apply == "function" ? r.apply : function(K, ie, be) {
    return Function.prototype.apply.call(K, ie, be);
  }, t;
  r && typeof r.ownKeys == "function" ? t = r.ownKeys : Object.getOwnPropertySymbols ? t = function(K) {
    return Object.getOwnPropertyNames(K).concat(Object.getOwnPropertySymbols(K));
  } : t = function(K) {
    return Object.getOwnPropertyNames(K);
  };
  function n(Z) {
    console && console.warn && console.warn(Z);
  }
  var i = Number.isNaN || function(K) {
    return K !== K;
  };
  function s() {
    s.init.call(this);
  }
  i_.exports = s, i_.exports.once = q, s.EventEmitter = s, s.prototype._events = void 0, s.prototype._eventsCount = 0, s.prototype._maxListeners = void 0;
  var l = 10;
  function o(Z) {
    if (typeof Z != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof Z);
  }
  Object.defineProperty(s, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return l;
    },
    set: function(Z) {
      if (typeof Z != "number" || Z < 0 || i(Z))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + Z + ".");
      l = Z;
    }
  }), s.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, s.prototype.setMaxListeners = function(K) {
    if (typeof K != "number" || K < 0 || i(K))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + K + ".");
    return this._maxListeners = K, this;
  };
  function d(Z) {
    return Z._maxListeners === void 0 ? s.defaultMaxListeners : Z._maxListeners;
  }
  s.prototype.getMaxListeners = function() {
    return d(this);
  }, s.prototype.emit = function(K) {
    for (var ie = [], be = 1; be < arguments.length; be++) ie.push(arguments[be]);
    var he = K === "error", Be = this._events;
    if (Be !== void 0) he = he && Be.error === void 0;
    else if (!he) return !1;
    if (he) {
      var ke;
      if (ie.length > 0 && (ke = ie[0]), ke instanceof Error)
        throw ke;
      var pe = new Error("Unhandled error." + (ke ? " (" + ke.message + ")" : ""));
      throw pe.context = ke, pe;
    }
    var me = Be[K];
    if (me === void 0) return !1;
    if (typeof me == "function")
      e(me, this, ie);
    else
      for (var je = me.length, Pe = k(me, je), be = 0; be < je; ++be) e(Pe[be], this, ie);
    return !0;
  };
  function m(Z, K, ie, be) {
    var he, Be, ke;
    if (o(ie), Be = Z._events, Be === void 0 ? (Be = Z._events = /* @__PURE__ */ Object.create(null), Z._eventsCount = 0) : (Be.newListener !== void 0 && (Z.emit("newListener", K, ie.listener ? ie.listener : ie), Be = Z._events), ke = Be[K]), ke === void 0)
      ke = Be[K] = ie, ++Z._eventsCount;
    else if (typeof ke == "function" ? ke = Be[K] = be ? [ie, ke] : [ke, ie] : be ? ke.unshift(ie) : ke.push(ie), he = d(Z), he > 0 && ke.length > he && !ke.warned) {
      ke.warned = !0;
      var pe = new Error("Possible EventEmitter memory leak detected. " + ke.length + " " + String(K) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      pe.name = "MaxListenersExceededWarning", pe.emitter = Z, pe.type = K, pe.count = ke.length, n(pe);
    }
    return Z;
  }
  s.prototype.addListener = function(K, ie) {
    return m(this, K, ie, !1);
  }, s.prototype.on = s.prototype.addListener, s.prototype.prependListener = function(K, ie) {
    return m(this, K, ie, !0);
  };
  function b() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function A(Z, K, ie) {
    var be = {
      fired: !1,
      wrapFn: void 0,
      target: Z,
      type: K,
      listener: ie
    }, he = b.bind(be);
    return he.listener = ie, be.wrapFn = he, he;
  }
  s.prototype.once = function(K, ie) {
    return o(ie), this.on(K, A(this, K, ie)), this;
  }, s.prototype.prependOnceListener = function(K, ie) {
    return o(ie), this.prependListener(K, A(this, K, ie)), this;
  }, s.prototype.removeListener = function(K, ie) {
    var be, he, Be, ke, pe;
    if (o(ie), he = this._events, he === void 0) return this;
    if (be = he[K], be === void 0) return this;
    if (be === ie || be.listener === ie)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete he[K], he.removeListener && this.emit("removeListener", K, be.listener || ie));
    else if (typeof be != "function") {
      for (Be = -1, ke = be.length - 1; ke >= 0; ke--)
        if (be[ke] === ie || be[ke].listener === ie) {
          pe = be[ke].listener, Be = ke;
          break;
        }
      if (Be < 0) return this;
      Be === 0 ? be.shift() : U(be, Be), be.length === 1 && (he[K] = be[0]), he.removeListener !== void 0 && this.emit("removeListener", K, pe || ie);
    }
    return this;
  }, s.prototype.off = s.prototype.removeListener, s.prototype.removeAllListeners = function(K) {
    var ie, be, he;
    if (be = this._events, be === void 0) return this;
    if (be.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : be[K] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete be[K]), this;
    if (arguments.length === 0) {
      var Be = Object.keys(be), ke;
      for (he = 0; he < Be.length; ++he)
        ke = Be[he], ke !== "removeListener" && this.removeAllListeners(ke);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (ie = be[K], typeof ie == "function")
      this.removeListener(K, ie);
    else if (ie !== void 0)
      for (he = ie.length - 1; he >= 0; he--)
        this.removeListener(K, ie[he]);
    return this;
  };
  function M(Z, K, ie) {
    var be = Z._events;
    if (be === void 0) return [];
    var he = be[K];
    return he === void 0 ? [] : typeof he == "function" ? ie ? [he.listener || he] : [he] : ie ? V(he) : k(he, he.length);
  }
  s.prototype.listeners = function(K) {
    return M(this, K, !0);
  }, s.prototype.rawListeners = function(K) {
    return M(this, K, !1);
  }, s.listenerCount = function(Z, K) {
    return typeof Z.listenerCount == "function" ? Z.listenerCount(K) : E.call(Z, K);
  }, s.prototype.listenerCount = E;
  function E(Z) {
    var K = this._events;
    if (K !== void 0) {
      var ie = K[Z];
      if (typeof ie == "function")
        return 1;
      if (ie !== void 0)
        return ie.length;
    }
    return 0;
  }
  s.prototype.eventNames = function() {
    return this._eventsCount > 0 ? t(this._events) : [];
  };
  function k(Z, K) {
    for (var ie = new Array(K), be = 0; be < K; ++be) ie[be] = Z[be];
    return ie;
  }
  function U(Z, K) {
    for (; K + 1 < Z.length; K++) Z[K] = Z[K + 1];
    Z.pop();
  }
  function V(Z) {
    for (var K = new Array(Z.length), ie = 0; ie < K.length; ++ie)
      K[ie] = Z[ie].listener || Z[ie];
    return K;
  }
  function q(Z, K) {
    return new Promise(function(ie, be) {
      function he(ke) {
        Z.removeListener(K, Be), be(ke);
      }
      function Be() {
        typeof Z.removeListener == "function" && Z.removeListener("error", he), ie([].slice.call(arguments));
      }
      re(Z, K, Be, {
        once: !0
      }), K !== "error" && Y(Z, he, {
        once: !0
      });
    });
  }
  function Y(Z, K, ie) {
    typeof Z.on == "function" && re(Z, "error", K, ie);
  }
  function re(Z, K, ie, be) {
    if (typeof Z.on == "function")
      be.once ? Z.once(K, ie) : Z.on(K, ie);
    else if (typeof Z.addEventListener == "function")
      Z.addEventListener(K, function he(Be) {
        be.once && Z.removeEventListener(K, he), ie(Be);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof Z);
  }
  return i_.exports;
}
var sY = iY();
const gE = {
  fr: {
    name: "France",
    bbox: [[-4.59235, 41.380007], [9.560016, 51.148506]]
  },
  us: {
    name: "United States",
    bbox: [[-171.791111, 18.91619], [-66.96466, 71.357764]]
  },
  ru: {
    name: "Russia",
    bbox: [[19.66064, 41.151416], [190.10042, 81.2504]]
  },
  ca: {
    name: "Canada",
    bbox: [[-140.99778, 41.675105], [-52.648099, 83.23324]]
  }
}, oY = {
  // list drawn from https://docs.mapbox.com/api/search/#language-coverage
  de: "Suche",
  // german
  it: "Ricerca",
  //italian
  en: "Search",
  // english
  nl: "Zoeken",
  //dutch
  fr: "Chercher",
  //french
  ca: "Cerca",
  //catalan
  he: "לחפש",
  //hebrew
  ja: "サーチ",
  //japanese
  lv: "Meklēt",
  //latvian
  pt: "Procurar",
  //portuguese 
  sr: "Претрага",
  //serbian
  zh: "搜索",
  //chinese-simplified
  cs: "Vyhledávání",
  //czech
  hu: "Keresés",
  //hungarian
  ka: "ძიება",
  // georgian
  nb: "Søke",
  //norwegian
  sk: "Vyhľadávanie",
  //slovak
  th: "ค้นหา",
  //thai
  fi: "Hae",
  //finnish
  is: "Leita",
  //icelandic
  ko: "수색",
  //korean
  pl: "Szukaj",
  //polish
  sl: "Iskanje",
  //slovenian
  fa: "جستجو",
  //persian(aka farsi)
  ru: "Поиск",
  //russian,
  es: "Buscar"
  //spanish
}, aY = {
  en: "No results found",
  de: "Keine Ergebnisse gefunden",
  es: "No hay resultados"
}, lY = {
  en: "There was an error reaching the server",
  de: "Verbindung fehlgeschlagen",
  es: "Error al conectarse al servidor"
};
var ng = {
  placeholder: oY,
  errorNoResults: aY,
  errorConnectionFailed: lY
};
const cY = /(-?\d+\.?\d*)[, ]+(-?\d+\.?\d*)[ ]*$/;
class uY {
  constructor(e, t) {
    this.options = {
      zoom: 16,
      flyTo: !0,
      trackProximity: !0,
      showResultsWhileTyping: !1,
      minLength: 2,
      reverseGeocode: !1,
      limit: 5,
      enableEventLogging: !0,
      marker: !0,
      popup: !1,
      maplibregl: void 0,
      collapsed: !1,
      clearAndBlurOnEsc: !1,
      clearOnBlur: !1,
      proximityMinZoom: 9,
      getItemValue: (n) => n.text !== void 0 ? n.text : n.place_name,
      render: function(n) {
        if (!n.geometry) {
          const s = n.text, l = s.toLowerCase().indexOf(this.query.toLowerCase()), o = this.query.length, d = s.substring(0, l), m = s.substring(l, l + o), b = s.substring(l + o);
          return '<div class="maplibregl-ctrl-geocoder--suggestion"><svg class="maplibregl-ctrl-geocoder--suggestion-icon" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M22.8702 20.1258H21.4248L20.9125 19.6318C22.7055 17.546 23.785 14.8382 23.785 11.8925C23.785 5.32419 18.4608 0 11.8925 0C5.32419 0 0 5.32419 0 11.8925C0 18.4608 5.32419 23.785 11.8925 23.785C14.8382 23.785 17.546 22.7055 19.6318 20.9125L20.1258 21.4248V22.8702L29.2739 32L32 29.2739L22.8702 20.1258ZM11.8925 20.1258C7.33676 20.1258 3.65923 16.4483 3.65923 11.8925C3.65923 7.33676 7.33676 3.65923 11.8925 3.65923C16.4483 3.65923 20.1258 7.33676 20.1258 11.8925C20.1258 16.4483 16.4483 20.1258 11.8925 20.1258Z" fill="#687078"/></svg><div class="maplibregl-ctrl-geocoder--suggestion-info"><div class="maplibregl-ctrl-geocoder--suggestion-title">' + d + '<span class="maplibregl-ctrl-geocoder--suggestion-match">' + m + "</span>" + b + "</div></div></div>";
        }
        const i = n.place_name.split(",");
        return '<div class="maplibregl-ctrl-geocoder--result"><svg class="maplibregl-ctrl-geocoder--result-icon" viewBox="0 0 24 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 0C5.36571 0 0 5.38676 0 12.0471C0 21.0824 12 32 12 32C12 32 24 21.0824 24 12.0471C24 5.38676 18.6343 0 12 0ZM12 16.3496C9.63428 16.3496 7.71429 14.4221 7.71429 12.0471C7.71429 9.67207 9.63428 7.74454 12 7.74454C14.3657 7.74454 16.2857 9.67207 16.2857 12.0471C16.2857 14.4221 14.3657 16.3496 12 16.3496Z" fill="#687078"/></svg><div><div class="maplibregl-ctrl-geocoder--result-title">' + i[0] + '</div><div class="maplibregl-ctrl-geocoder--result-address">' + i.splice(1, i.length).join(",") + "</div></div></div>";
      },
      popupRender: (n) => {
        const i = n.place_name.split(",");
        return '<div class="maplibregl-ctrl-geocoder--suggestion popup-suggestion"><div class="maplibregl-ctrl-geocoder--suggestion-title popup-suggestion-title">' + i[0] + '</div><div class="maplibregl-ctrl-geocoder--suggestion-address popup-suggestion-address">' + i.splice(1, i.length).join(",") + "</div></div>";
      },
      showResultMarkers: !0,
      debounceSearch: 200
    }, this._eventEmitter = new sY.EventEmitter(), this.options = _c({}, this.options, t), this.fresh = !0, this.lastSelected = null, this.geocoderApi = e;
  }
  /**
   * Add the geocoder to a container. The container can be either a `Map`, an `HTMLElement` or a CSS selector string.
   *
   * If the container is a [`Map`](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map), this function will behave identically to [`Map.addControl(geocoder)`](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map#addcontrol).
   * If the container is an instance of [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement), then the geocoder will be appended as a child of that [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement).
   * If the container is a [CSS selector string](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors), the geocoder will be appended to the element returned from the query.
   *
   * This function will throw an error if the container is none of the above.
   * It will also throw an error if the referenced HTML element cannot be found in the `document.body`.
   *
   * For example, if the HTML body contains the element `<div id='geocoder-container'></div>`, the following script will append the geocoder to `#geocoder-container`:
   * @example
   * ```js
   * const GeoApi = {
   *   forwardGeocode: (config) => { return { features: [] } },
   *   reverseGeocode: (config) => { return { features: [] } }
   * }
   * const geocoder = new MaplibreGeocoder(GeoAPI, {});
   * geocoder.addTo('#geocoder-container');
   * ```
   * @param container - A reference to the container to which to add the geocoder
   */
  addTo(e) {
    function t(n, i) {
      if (!document.body.contains(i))
        throw new Error("Element provided to #addTo() exists, but is not in the DOM");
      const s = n.onAdd();
      i.appendChild(s);
    }
    if (e instanceof HTMLElement)
      t(this, e);
    else if (typeof e == "string") {
      const n = document.querySelectorAll(e);
      if (n.length === 0)
        throw new Error("Element " + e + "not found.");
      if (n.length > 1)
        throw new Error("Geocoder can only be added to a single html element");
      t(this, n[0]);
    } else if ("addControl" in e)
      e.addControl(this);
    else
      throw new Error("Error: addTo must be a maplibre-gl-js map, an html element, or a CSS selector query for a single html element");
  }
  onAdd(e) {
    if (e && typeof e != "string" && (this._map = e), this.setLanguage(), this.options.localGeocoderOnly && !this.options.localGeocoder)
      throw new Error("A localGeocoder function must be specified to use localGeocoderOnly mode");
    this._onChange = this._onChange.bind(this), this._onKeyDown = this._onKeyDown.bind(this), this._onPaste = this._onPaste.bind(this), this._onBlur = this._onBlur.bind(this), this._showButton = this._showButton.bind(this), this._hideButton = this._hideButton.bind(this), this._onQueryResult = this._onQueryResult.bind(this), this.clear = this.clear.bind(this), this._updateProximity = this._updateProximity.bind(this), this._collapse = this._collapse.bind(this), this._unCollapse = this._unCollapse.bind(this), this._clear = this._clear.bind(this), this._clearOnBlur = this._clearOnBlur.bind(this);
    const t = this.container = document.createElement("div");
    t.className = "maplibregl-ctrl-geocoder maplibregl-ctrl maplibregl-ctrl-geocoder maplibregl-ctrl";
    const n = this.createIcon("search", '<path d="M7.4 2.5c-2.7 0-4.9 2.2-4.9 4.9s2.2 4.9 4.9 4.9c1 0 1.8-.2 2.5-.8l3.7 3.7c.2.2.4.3.8.3.7 0 1.1-.4 1.1-1.1 0-.3-.1-.5-.3-.8L11.4 10c.4-.8.8-1.6.8-2.5.1-2.8-2.1-5-4.8-5zm0 1.6c1.8 0 3.2 1.4 3.2 3.2s-1.4 3.2-3.2 3.2-3.3-1.3-3.3-3.1 1.4-3.3 3.3-3.3z"/>');
    this._inputEl = document.createElement("input"), this._inputEl.type = "text", this._inputEl.className = "maplibregl-ctrl-geocoder--input", this.setPlaceholder(), this.options.collapsed && (this._collapse(), this.container.addEventListener("mouseenter", this._unCollapse), this.container.addEventListener("mouseleave", this._collapse), this._inputEl.addEventListener("focus", this._unCollapse)), (this.options.collapsed || this.options.clearOnBlur) && this._inputEl.addEventListener("blur", this._onBlur), this._inputEl.addEventListener("keydown", rY(this._onKeyDown, this.options.debounceSearch)), this._inputEl.addEventListener("paste", this._onPaste), this._inputEl.addEventListener("change", this._onChange), this.container.addEventListener("mouseenter", this._showButton), this.container.addEventListener("mouseleave", this._hideButton);
    const i = document.createElement("div");
    i.classList.add("maplibregl-ctrl-geocoder--pin-right"), this._clearEl = document.createElement("button"), this._clearEl.setAttribute("type", "button"), this._clearEl.setAttribute("aria-label", "Clear"), this._clearEl.addEventListener("click", this.clear), this._clearEl.className = "maplibregl-ctrl-geocoder--button";
    const s = this.createIcon("close", '<path d="M3.8 2.5c-.6 0-1.3.7-1.3 1.3 0 .3.2.7.5.8L7.2 9 3 13.2c-.3.3-.5.7-.5 1 0 .6.7 1.3 1.3 1.3.3 0 .7-.2 1-.5L9 10.8l4.2 4.2c.2.3.7.3 1 .3.6 0 1.3-.7 1.3-1.3 0-.3-.2-.7-.3-1l-4.4-4L15 4.6c.3-.2.5-.5.5-.8 0-.7-.7-1.3-1.3-1.3-.3 0-.7.2-1 .3L9 7.1 4.8 2.8c-.3-.1-.7-.3-1-.3z"/>');
    return this._clearEl.appendChild(s), this._loadingEl = this.createIcon("loading", '<path fill="#333" d="M4.4 4.4l.8.8c2.1-2.1 5.5-2.1 7.6 0l.8-.8c-2.5-2.5-6.7-2.5-9.2 0z"/><path opacity=".1" d="M12.8 12.9c-2.1 2.1-5.5 2.1-7.6 0-2.1-2.1-2.1-5.5 0-7.7l-.8-.8c-2.5 2.5-2.5 6.7 0 9.2s6.6 2.5 9.2 0 2.5-6.6 0-9.2l-.8.8c2.2 2.1 2.2 5.6 0 7.7z"/>'), i.appendChild(this._clearEl), i.appendChild(this._loadingEl), t.appendChild(n), t.appendChild(this._inputEl), t.appendChild(i), this._typeahead = new ZZ(this._inputEl, [], {
      filter: !1,
      minLength: this.options.minLength,
      limit: this.options.limit,
      noInitialSelection: !0
    }), this.container.addEventListener("click", () => {
      this._typeahead.update(this._typeahead.data);
    }), this.setRenderFunction(this.options.render), this._typeahead.getItemValue = this.options.getItemValue, this.mapMarker = null, this.resultMarkers = [], this._handleMarker = this._handleMarker.bind(this), this._handleResultMarkers = this._handleResultMarkers.bind(this), this._map && (this.options.trackProximity && (this._updateProximity(), this._map.on("moveend", this._updateProximity)), this._maplibregl = this.options.maplibregl, !this._maplibregl && this.options.marker && (console.error("No maplibregl detected in options. Map markers are disabled. Please set options.maplibregl."), this.options.marker = !1)), t;
  }
  createIcon(e, t) {
    const n = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    if (n.setAttribute("class", "maplibregl-ctrl-geocoder--icon maplibregl-ctrl-geocoder--icon-" + e), n.setAttribute("viewBox", "0 0 18 18"), n.setAttribute("xml:space", "preserve"), n.setAttribute("width", "18"), n.setAttribute("height", "18"), "innerHTML" in n)
      n.innerHTML = t;
    else {
      const i = document.createElement("div");
      i.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>";
      const s = i.firstChild, l = s.firstChild;
      n.appendChild(l);
    }
    return n;
  }
  onRemove() {
    return this.container.remove(), this.options.trackProximity && this._map && this._map.off("moveend", this._updateProximity), this._removeMarker(), this._map = null, this;
  }
  _onPaste(e) {
    const t = (e.clipboardData || window.clipboardData).getData("text");
    t.length >= this.options.minLength && this.options.showResultsWhileTyping && this._geocode(t);
  }
  _onKeyDown(e) {
    if (e.keyCode === 27 && this.options.clearAndBlurOnEsc)
      return this._clear(e), this._inputEl.blur();
    const s = this._inputEl.value;
    if (!s)
      return this.fresh = !0, e.keyCode !== 9 && this.clear(e), this._clearEl.style.display = "none";
    if (!(e.metaKey || [9, 27, 37, 39, 38, 40].indexOf(e.keyCode) !== -1)) {
      if (e.keyCode === 13)
        if (!this.options.showResultsWhileTyping)
          this._typeahead.selected || this._geocode(s);
        else {
          this._typeahead.selected == null && this.geocoderApi.getSuggestions ? this._geocode(s, !0) : this._typeahead.selected == null && this.options.showResultMarkers && this._fitBoundsForMarkers();
          return;
        }
      s.length >= this.options.minLength && this.options.showResultsWhileTyping && this._geocode(s);
    }
  }
  _showButton() {
    this._inputEl.value.length > 0 && (this._clearEl.style.display = "block");
  }
  _hideButton() {
    this._typeahead.selected && (this._clearEl.style.display = "none");
  }
  _onBlur(e) {
    this.options.clearOnBlur && this._clearOnBlur(e), this.options.collapsed && this._collapse();
  }
  // Change events are fire by suggestions library whenever the enter key is pressed or input is blurred
  // This can sometimes cause strange behavior as this function is called before our own onKeyDown handler and thus
  //  we cannot depend on some internal values of the suggestion state like `selected` as those will change or before
  //  our onKeyDown handler.
  _onChange() {
    const e = this._typeahead.selected;
    if (e && !e.geometry)
      e.placeId ? this._geocode(e.placeId, !0, !0) : this._geocode(e.text, !0);
    else if (e && JSON.stringify(e) !== this.lastSelected) {
      if (this._clearEl.style.display = "none", this.options.flyTo) {
        let t;
        if (this._removeResultMarkers(), e.properties && gE[e.properties.short_code])
          t = _c({}, this.options.flyTo), this._map && this._map.fitBounds(gE[e.properties.short_code].bbox, t);
        else if (e.bbox) {
          const n = e.bbox;
          t = _c({}, this.options.flyTo), this._map && this._map.fitBounds([[n[0], n[1]], [n[2], n[3]]], t);
        } else {
          const n = {
            zoom: this.options.zoom
          };
          t = _c({}, n, this.options.flyTo), e.center ? t.center = e.center : e.geometry && e.geometry.type && e.geometry.type === "Point" && e.geometry.coordinates && (t.center = e.geometry.coordinates), this._map && this._map.flyTo(t);
        }
      }
      this.options.marker && this._maplibregl && this._handleMarker(e), this._inputEl.focus(), this._inputEl.scrollLeft = 0, this._inputEl.setSelectionRange(0, 0), this.lastSelected = JSON.stringify(e), this._typeahead.selected = null, this._eventEmitter.emit("result", {
        result: e
      });
    }
  }
  _getConfigForRequest() {
    return ["bbox", "limit", "proximity", "countries", "types", "language", "reverseMode"].reduce((n, i) => (this.options[i] && (["countries", "types", "language"].indexOf(i) > -1 ? n[i] = this.options[i].split(/[\s,]+/) : n[i] = this.options[i], i === "proximity" && this.options[i] && typeof this.options[i].longitude == "number" && typeof this.options[i].latitude == "number" && (n[i] = [this.options[i].longitude, this.options[i].latitude])), n), {});
  }
  _geocode(e) {
    return g1(this, arguments, void 0, function(t) {
      var n = this;
      let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
      return function* () {
        n._loadingEl.style.display = "block", n._eventEmitter.emit("loading", {
          query: t
        });
        const l = n._getConfigForRequest(), o = n._createGeocodeRequest(l, t, i, s), d = n.options.localGeocoder ? n.options.localGeocoder(t) || [] : [];
        try {
          const m = yield o;
          yield n._handleGeocodeResponse(m, l, t, i, d);
        } catch (m) {
          n._handleGeocodeErrorResponse(m, d);
        }
        return o;
      }();
    });
  }
  _createGeocodeRequest(e, t, n, i) {
    return this.options.localGeocoderOnly ? Promise.resolve({}) : this.options.reverseGeocode && cY.test(t) ? this._createReverseGeocodeRequest(t, e) : (e.query = t, this.geocoderApi.getSuggestions ? n ? this.geocoderApi.searchByPlaceId && i ? this.geocoderApi.searchByPlaceId(e) : this.geocoderApi.forwardGeocode(e) : this.geocoderApi.getSuggestions(e) : this.geocoderApi.forwardGeocode(e));
  }
  _createReverseGeocodeRequest(e, t) {
    const n = e.split(/[\s(,)?]+/).map((i) => parseFloat(i)).reverse();
    return t.query = n, t.limit = 1, "proximity" in t && delete t.proximity, this.geocoderApi.reverseGeocode(t);
  }
  _handleGeocodeResponse(e, t, n, i, s) {
    return g1(this, void 0, void 0, function* () {
      this._loadingEl.style.display = "none";
      let l = {};
      e ? l = e : l = {
        type: "FeatureCollection",
        features: []
      }, l.config = t, this.fresh && (this.fresh = !1), l.features = l.features ? s.concat(l.features) : s;
      const o = this.options.externalGeocoder ? this.options.externalGeocoder(n, l.features, t) || Promise.resolve([]) : Promise.resolve([]);
      try {
        const m = yield o;
        l.features = l.features ? m.concat(l.features) : m;
      } catch {
      }
      this.options.filter && l.features.length && (l.features = l.features.filter(this.options.filter));
      let d = [];
      "suggestions" in l ? d = l.suggestions : "place" in l ? d = [l.place] : d = l.features, d.length ? (this._clearEl.style.display = "block", this._typeahead.update(d), (!this.options.showResultsWhileTyping || i) && this.options.showResultMarkers && (l.features.length > 0 || "place" in l) && this._fitBoundsForMarkers(), this._eventEmitter.emit("results", l)) : (this._clearEl.style.display = "none", this._typeahead.selected = null, this._renderNoResults(), this._eventEmitter.emit("results", l));
    });
  }
  _handleGeocodeErrorResponse(e, t) {
    this._loadingEl.style.display = "none", t.length && this.options.localGeocoder ? (this._clearEl.style.display = "block", this._typeahead.update(t)) : (this._clearEl.style.display = "none", this._typeahead.selected = null, this._renderError()), this._eventEmitter.emit("results", {
      features: t
    }), this._eventEmitter.emit("error", {
      error: e
    });
  }
  /**
   * Shared logic for clearing input
   * @param ev - the event that triggered the clear, if available
   */
  _clear(e) {
    e && e.preventDefault(), this._inputEl.value = "", this._typeahead.selected = null, this._typeahead.clear(), this._onChange(), this._clearEl.style.display = "none", this._removeMarker(), this._removeResultMarkers(), this.lastSelected = null, this._eventEmitter.emit("clear"), this.fresh = !0;
  }
  /**
   * Clear and then focus the input.
   * @param ev - the event that triggered the clear, if available
   *
   */
  clear(e) {
    this._clear(e), this._inputEl.focus();
  }
  /**
   * Clear the input, without refocusing it. Used to implement clearOnBlur
   * constructor option.
   * @param ev - the blur event
   */
  _clearOnBlur(e) {
    e.relatedTarget && this._clear(e);
  }
  _onQueryResult(e) {
    if (!("features" in e) || !e.features.length) return;
    const t = e.features[0];
    this._typeahead.selected = t, this._inputEl.value = t.place_name, this._onChange();
  }
  _updateProximity() {
    if (this._map)
      if (this._map.getZoom() > this.options.proximityMinZoom) {
        const e = this._map.getCenter().wrap();
        this.setProximity({
          longitude: e.lng,
          latitude: e.lat
        });
      } else
        this.setProximity(null);
  }
  _collapse() {
    !this._inputEl.value && this._inputEl !== document.activeElement && this.container.classList.add("maplibregl-ctrl-geocoder--collapsed");
  }
  _unCollapse() {
    this.container.classList.remove("maplibregl-ctrl-geocoder--collapsed");
  }
  /**
   * Set & query the input
   * @param searchInput - location name or other search input
   */
  query(e) {
    return g1(this, void 0, void 0, function* () {
      const t = yield this._geocode(e);
      this._onQueryResult(t);
    });
  }
  _renderError() {
    const e = `<div class='maplibre-gl-geocoder--error'>${this._localize("errorConnectionFailed")}</div>`;
    this._renderMessage(e);
  }
  _renderNoResults() {
    const e = `<div class='maplibre-gl-geocoder--error maplibre-gl-geocoder--no-results'>
        ${this._localize("errorNoResults")}</div>`;
    this._renderMessage(e);
  }
  _renderMessage(e) {
    this._typeahead.update([]), this._typeahead.selected = null, this._typeahead.clear(), this._typeahead.renderError(e);
  }
  /**
   * Get a localised string for a given key
   *
   * If language is provided in options, attempt to return localized string (defaults to English)
   * @param key - key in the localization object
   * @returns localized string
   */
  _localize(e) {
    const t = QZ.language(this.options.language.split(",")[0]);
    return this.options.language && (ng != null && ng[e][t]) ? ng[e][t] : ng[e].en;
  }
  /**
   * Fits the map to the current bounds for the searched results
   */
  _fitBoundsForMarkers() {
    if (this._typeahead.data.length < 1) return;
    const e = this._typeahead.data.filter((t) => typeof t != "string").slice(0, this.options.limit);
    if (this._clearEl.style.display = "none", this.options.flyTo && this._maplibregl && this._map) {
      const n = _c({}, {
        padding: 100
      }, this.options.flyTo), i = new this._maplibregl.LngLatBounds();
      for (const s of e)
        i.extend(s.geometry.coordinates);
      this._map.fitBounds(i, n);
    }
    return e.length > 0 && this._maplibregl && this._handleResultMarkers(e), this;
  }
  /**
   * Set input
   * @param searchInput - location name or other search input
   */
  setInput(e) {
    return this._inputEl.value = e, this._typeahead.selected = null, this._typeahead.clear(), e.length >= this.options.minLength && this.options.showResultsWhileTyping && this._geocode(e), this;
  }
  /**
   * Set proximity
   * @param proximity - The new `options.proximity` value. This is a geographical point given as an object with `latitude` and `longitude` properties.
   */
  setProximity(e) {
    return this.options.proximity = e, this;
  }
  /**
   * Get proximity
   * @returns The geocoder proximity
   */
  getProximity() {
    return this.options.proximity;
  }
  /**
   * Set the render function used in the results dropdown
   * @param fn - The function to use as a render function. This function accepts a single {@link CarmenGeojsonFeature} object as input and returns a string.
   */
  setRenderFunction(e) {
    return e && typeof e == "function" && (this._typeahead.render = e), this;
  }
  /**
   * Get the function used to render the results dropdown
   *
   * @returns the render function
   */
  getRenderFunction() {
    return this._typeahead.render;
  }
  /**
   * Get the language to use in UI elements and when making search requests
   *
   * Look first at the explicitly set options otherwise use the browser's language settings
   * @param language - Specify the language to use for response text and query result weighting. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and optionally one or more IETF subtags for country or script. More than one value can also be specified, separated by commas.
   */
  setLanguage(e) {
    return this.options.language = e || this.options.language || navigator.language, this;
  }
  /**
   * Get the language to use in UI elements and when making search requests
   * @returns The language(s) used by the plugin, if any
   */
  getLanguage() {
    return this.options.language;
  }
  /**
   * Get the zoom level the map will move to when there is no bounding box on the selected result
   * @returns the map zoom
   */
  getZoom() {
    return this.options.zoom;
  }
  /**
   * Set the zoom level
   * @param zoom - The zoom level that the map should animate to when a `bbox` isn't found in the response. If a `bbox` is found the map will fit to the `bbox`.
   * @returns this
   */
  setZoom(e) {
    return this.options.zoom = e, this;
  }
  /**
   * Get the parameters used to fly to the selected response, if any
   * @returns The `flyTo` option
   */
  getFlyTo() {
    return this.options.flyTo;
  }
  /**
   * Set the flyTo options
   * @param flyTo - If false, animating the map to a selected result is disabled. If true, animating the map will use the default animation parameters. If an object, it will be passed as `options` to the map [`flyTo`](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map#flyto) or [`fitBounds`](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map#fitbounds) method providing control over the animation of the transition.
   */
  setFlyTo(e) {
    return this.options.flyTo = e, this;
  }
  /**
   * Get the value of the placeholder string
   * @returns The input element's placeholder value
   */
  getPlaceholder() {
    return this.options.placeholder;
  }
  /**
   * Set the value of the input element's placeholder
   * @param placeholder - the text to use as the input element's placeholder
   */
  setPlaceholder(e) {
    return this.placeholder = e || this.options.placeholder || this._localize("placeholder"), this._inputEl.placeholder = this.placeholder, this._inputEl.setAttribute("aria-label", this.placeholder), this;
  }
  /**
   * Get the bounding box used by the plugin
   * @returns the bounding box, if any
   */
  getBbox() {
    return this.options.bbox;
  }
  /**
   * Set the bounding box to limit search results to
   * @param bbox - a bounding box given as an array in the format [minX, minY, maxX, maxY].
   */
  setBbox(e) {
    return this.options.bbox = e, this;
  }
  /**
   * Get a list of the countries to limit search results to
   * @returns a comma separated list of countries to limit to, if any
   */
  getCountries() {
    return this.options.countries;
  }
  /**
   * Set the countries to limit search results to
   * @param countries - a comma separated list of countries to limit to
   */
  setCountries(e) {
    return this.options.countries = e, this;
  }
  /**
   * Get a list of the types to limit search results to
   * @returns a comma separated list of types to limit to
   */
  getTypes() {
    return this.options.types;
  }
  /**
   * Set the types to limit search results to
   * @param types - a comma separated list of types to limit to
   */
  setTypes(e) {
    return this.options.types = e, this;
  }
  /**
   * Get the minimum number of characters typed to trigger results used in the plugin
   * @returns The minimum length in characters before a search is triggered
   */
  getMinLength() {
    return this.options.minLength;
  }
  /**
   * Set the minimum number of characters typed to trigger results used by the plugin
   * @param minLength - the minimum length in characters
   */
  setMinLength(e) {
    return this.options.minLength = e, this._typeahead && (this._typeahead.options.minLength = e), this;
  }
  /**
   * Get the limit value for the number of results to display used by the plugin
   * @returns The limit value for the number of results to display used by the plugin
   */
  getLimit() {
    return this.options.limit;
  }
  /**
   * Set the limit value for the number of results to display used by the plugin
   * @param limit - the number of search results to return
   */
  setLimit(e) {
    return this.options.limit = e, this._typeahead && (this._typeahead.options.limit = e), this;
  }
  /**
   * Get the filter function used by the plugin
   * @returns the filter function
   */
  getFilter() {
    return this.options.filter;
  }
  /**
   * Set the filter function used by the plugin.
   * @param filter - A function which accepts a {@link CarmenGeojsonFeature} to filter out results from the Geocoding API response before they are included in the suggestions list. Return `true` to keep the item, `false` otherwise.
   */
  setFilter(e) {
    return this.options.filter = e, this;
  }
  /**
   * Set the geocoding api used by the plugin.
   */
  setGeocoderApi(e) {
    return this.geocoderApi = e, this;
  }
  /**
   * Get the geocoding endpoint the plugin is currently set to
   * @returns the geocoding API
   */
  getGeocoderApi() {
    return this.geocoderApi;
  }
  /**
   * Handle the placement of a result marking the selected result
   * @param selected - the selected geojson feature
   */
  _handleMarker(e) {
    if (!this._map)
      return;
    this._removeMarker();
    const n = _c({}, {
      color: "#4668F2"
    }, this.options.marker);
    this.mapMarker = new this._maplibregl.Marker(n);
    let i;
    if (this.options.popup) {
      const l = _c({}, {}, this.options.popup);
      i = new this._maplibregl.Popup(l).setHTML(this.options.popupRender(e));
    }
    return e.center ? (this.mapMarker.setLngLat(e.center).addTo(this._map), this.options.popup && this.mapMarker.setPopup(i)) : e.geometry && e.geometry.type && e.geometry.type === "Point" && e.geometry.coordinates && (this.mapMarker.setLngLat(e.geometry.coordinates).addTo(this._map), this.options.popup && this.mapMarker.setPopup(i)), this;
  }
  /**
   * Handle the removal of a result marker
   */
  _removeMarker() {
    this.mapMarker && (this.mapMarker.remove(), this.mapMarker = null);
  }
  /**
   * Handle the placement of a result marking the selected result
   * @param results - the top results to display on the map
   */
  _handleResultMarkers(e) {
    if (!this._map)
      return;
    this._removeResultMarkers();
    let n = _c({}, {
      color: "#4668F2"
    }, this.options.showResultMarkers);
    for (const i of e) {
      let s;
      if (this.options.showResultMarkers) {
        this.options.showResultMarkers && this.options.showResultMarkers.element && (s = this.options.showResultMarkers.element.cloneNode(!0), n = _c(n, {
          element: s
        }));
        const l = new this._maplibregl.Marker(_c({}, n, {
          element: s
        }));
        let o;
        if (this.options.popup) {
          const m = _c({}, {}, this.options.popup);
          o = new this._maplibregl.Popup(m).setHTML(this.options.popupRender(i));
        }
        i.center ? (l.setLngLat(i.center).addTo(this._map), this.options.popup && l.setPopup(o)) : i.geometry && i.geometry.type && i.geometry.type === "Point" && i.geometry.coordinates && (l.setLngLat(i.geometry.coordinates).addTo(this._map), this.options.popup && l.setPopup(o)), this.resultMarkers.push(l);
      }
    }
    return this;
  }
  /**
   * Handle the removal of a result marker
   */
  _removeResultMarkers() {
    this.resultMarkers && this.resultMarkers.length > 0 && (this.resultMarkers.forEach(function(e) {
      e.remove();
    }), this.resultMarkers = []);
  }
  /**
   * Subscribe to events that happen within the plugin.
   * @param type - name of event. Available events and the data passed into their respective event objects are:
   *
   * - __clear__ `Emitted when the input is cleared`
   * - __loading__ `{ query } Emitted when the geocoder is looking up a query`
   * - __results__ `{ results } Fired when the geocoder returns a response`
   * - __result__ `{ result } Fired when input is set`
   * - __error__ `{ error } Error as string`
   * @param fn - function that's called when the event is emitted.
   */
  on(e, t) {
    return this._eventEmitter.on(e, t), this;
  }
  /**
   * Subscribe to events that happen within the plugin only once.
   * @param type - Event name.
   * Available events and the data passed into their respective event objects are:
   *
   * - __clear__ `Emitted when the input is cleared`
   * - __loading__ `{ query } Emitted when the geocoder is looking up a query`
   * - __results__ `{ results } Fired when the geocoder returns a response`
   * - __result__ `{ result } Fired when input is set`
   * - __error__ `{ error } Error as string`
   * @returns a Promise that resolves when the event is emitted.
   */
  once(e) {
    return new Promise((t) => {
      this._eventEmitter.once(e, t);
    });
  }
  /**
   * Remove an event
   * @param type - Event name.
   * @param fn - Function that should unsubscribe to the event emitted.
   */
  off(e, t) {
    return this._eventEmitter.removeListener(e, t), this;
  }
}
const hY = /* @__PURE__ */ JSON.parse('{"limitsUrl":"https://tilemaps.icgc.cat/vt/limits-tilejsonV3.json","geocoder":{"peliasUrl1":"https://eines.icgc.cat/geocodificador/autocompletar?text=","peliasUrl2":"&layers=topo1%2Ctopo2%2Caddress&size=5"},"mapOptions":{"container":"map","center":{"0":1.537786,"1":41.837539},"zoom":7.5,"bearing":0,"pitch":0,"hash":false,"style":"https://geoserveis.icgc.cat/styles/icgc_mapa_base_gris.json.json","maxZoom":18,"maxPitch":85},"logoIcgcOptions":{"logoUrlColor":"https://eines.icgc.cat/recursos/logos/icgc_logo_color.png","logoUrlWhite":"https://eines.icgc.cat/recursos/logos/icgc_logo_blanc.svg","logoLink":"https://www.icgc.cat","logoTitle":"Institut Cartogràfic i Geològic de Catalunya","logoWidth":100,"logoOpacity":0.6},"logoGencatOptions":{"logoUrlColor":"https://eines.icgc.cat/recursos/logos/gencat_logo_color.png","logoUrlWhite":"https://eines.icgc.cat/recursos/logos/gencat_logo_blanc.png","logoLink":"https://web.gencat.cat/","logoTitle":"Generalitat de Catalunya","logoWidth":100,"logoOpacity":0.6},"map3dOptions":{"spaceErrorFactor":2,"exaggeration":1,"zfactor":48,"minZoomRange":15.5,"maxZoomRange":22,"urlTilesetCities":"https://geoserveis.icgc.cat/servei/catalunya/ciutats/3dtiles/v1/tilesetV1.0.json","layerIdOrder":"place-isolated","sourceLayerFilterId":"place","minZoomFilter":14,"layerId3d":"edificisMapboxLayer","terrainSource":"ICGC5M","style3dName":"orto3d","imageIcon":"https://eines.icgc.cat/recursos//images/stick.png"},"baseStyles":[{"key":"TOPO","url":"https://geoserveis.icgc.cat/styles/icgc_mapa_base_topografic.json","image":"https://visors.icgc.cat/contextmaps/imatges_estil/icgc_mapa_estandard.png"},{"key":"ORTO","url":"https://geoserveis.icgc.cat/styles/icgc_orto_estandard.json","image":"https://visors.icgc.cat/contextmaps/imatges_estil/icgc_orto_estandard.png"},{"key":"ORTO3D","url":"https://eines.icgc.cat/recursos//styles/icgc_orto_3d.json","image":"https://visors.icgc.cat/contextmaps/imatges_estil/icgc_orto_estandard.png"},{"key":"ORTOHYBRID","url":"https://geoserveis.icgc.cat/styles/icgc_orto_hibrida.json","image":"https://visors.icgc.cat/contextmaps/imatges_estil/icgc_orto_hibrida.png"},{"key":"ADMIN","url":"https://geoserveis.icgc.cat/styles/icgc_limits_administratius_gris.json","image":"https://visors.icgc.cat/contextmaps/imatges_estil/icgc_delimitacio_limits_administratius.png"},{"key":"DARK","url":"https://geoserveis.icgc.cat/styles/icgc_mapa_base_fosc.json","image":"https://visors.icgc.cat/contextmaps/imatges_estil/icgc_mapa_base_fosc.png"},{"key":"LIGHT","url":"https://geoserveis.icgc.cat/styles/icgc_mapa_base_gris.json","image":"https://visors.icgc.cat/contextmaps/imatges_estil/icgc_mapa_base_gris.png"},{"key":"GEOLOGY","url":"https://geoserveis.icgc.cat/styles/icgc_geologic_informacio.json","image":"https://visors.icgc.cat/contextmaps/imatges_estil/icgc_geologic_informacio.png"},{"key":"RASTER","substyles":{"TOPO":{"url":"https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/topografic/MON3857NW/{z}/{x}/{y}.png","image":"https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_topo.jpg"},"ADMIN":{"url":"https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/administratiu/MON3857NW/{z}/{x}/{y}.png","image":"https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_administratiu.jpg"},"LIGHT":{"url":"https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/topografic-gris/MON3857NW/{z}/{x}/{y}.png","image":"https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_topo_gris.jpg"},"STANDARD":{"url":"https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/estandard/MON3857NW/{z}/{x}/{y}.png","image":"https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_estandard_0.jpg"},"Simplified":{"url":"https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/simplificat/MON3857NW/{z}/{x}/{y}.png","image":"https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_simplificat.jpg"},"ORTO":{"url":"https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto/MON3857NW/{z}/{x}/{y}.png","image":"https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_orto.jpg"},"ORTOGREY":{"url":"https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto-gris/MON3857NW/{z}/{x}/{y}.png","image":"https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_orto_gris.jpg"},"ORTOHYBRID":{"url":"https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto-hibrida/MON3857NW/{z}/{x}/{y}.png","image":"https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_orto_hibida.jpg"}}}],"urlTerrainICGC":[{"name":"ICGC5M","url":"https://tilemaps.icgc.cat/tileserver/tileserver/terreny-5m-30m-rgb-extent/{z}/{x}/{y}.png"},{"name":"WORLD30M","url":"https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png","encoding":"terrarium"}],"ortoLayersICGC":[{"name":"ortofotoColorProvisional","key":"ortofoto_color_provisional","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_provisional"},{"name":"ortofotoColor2023","key":"ortofoto_color_2023","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2023"},{"name":"ortofotoColor2022","key":"ortofoto_color_2022","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2022"},{"name":"ortofotoColor2021","key":"ortofoto_color_2021","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2021"},{"name":"ortofotoColor2020","key":"ortofoto_color_2020","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2020"},{"name":"ortofotoColor2019","key":"ortofoto_color_2019","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2019"},{"name":"ortofotoColor2018","key":"ortofoto_color_2018","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2018"},{"name":"ortofotoColor2017","key":"ortofoto_color_2017","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2017"},{"name":"ortofotoColor2016","key":"ortofoto_color_2016","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2016"},{"name":"ortofotoColor2015","key":"ortofoto_color_2015","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2015"},{"name":"ortofotoColor2014","key":"ortofoto_color_2014","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2014"},{"name":"ortofotoColor2013","key":"ortofoto_color_2013","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2013"},{"name":"ortofotoColor2012","key":"ortofoto_color_2012","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2012"},{"name":"ortofotoColor2011","key":"ortofoto_color_2011","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2011"},{"name":"ortofotoColor2010","key":"ortofoto_color_2010","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2010"},{"name":"ortofotoColor2009","key":"ortofoto_color_2009","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2009"},{"name":"ortofotoColor2008","key":"ortofoto_color_2008","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2008"},{"name":"ortofotoColor20062007","key":"ortofoto_color_2006-2007","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2006-2007"},{"name":"ortofotoColor20042005","key":"ortofoto_color_2004-2005","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2004-2005"},{"name":"ortofotoColor20002003","key":"ortofoto_color_2000-2003","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2000-2003"},{"name":"ortofotoBlancINegre1998","key":"ortofoto_blanc_i_negre_1998","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1998"},{"name":"ortofotoBlancINegre19941997","key":"ortofoto_blanc_i_negre_1994-1997","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1994-1997"},{"name":"ortofotoColor1993","key":"ortofoto_color_1993","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_1993"},{"name":"ortofotoBlancINegre19831992","key":"ortofoto_blanc_i_negre_1983-1992","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1983-1992"},{"name":"ortofotoBlancINegre19701977","key":"ortofoto_blanc_i_negre_1970-1977","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1970-1977"},{"name":"ortofotoBlancINegre1956","key":"ortofoto_blanc_i_negre_1956","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1956"},{"name":"ortofotoBlancINegre1945","key":"ortofoto_blanc_i_negre_1945","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1945"},{"name":"ortofotoColorSerieAnual","key":"ortofoto_color_serie_anual","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_serie_anual"},{"name":"ortofotoInfraroigProvisional","key":"ortofoto_infraroig_provisional","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_provisional"},{"name":"ortofotoInfraroig2023","key":"ortofoto_infraroig_2023","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2023"},{"name":"ortofotoInfraroig2022","key":"ortofoto_infraroig_2022","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2022"},{"name":"ortofotoInfraroig2021","key":"ortofoto_infraroig_2021","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2021"},{"name":"ortofotoInfraroig2020","key":"ortofoto_infraroig_2020","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2020"},{"name":"ortofotoInfraroig2019","key":"ortofoto_infraroig_2019","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2019"},{"name":"ortofotoInfraroig2018","key":"ortofoto_infraroig_2018","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2018"},{"name":"ortofotoInfraroig2017","key":"ortofoto_infraroig_2017","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2017"},{"name":"ortofotoInfraroig2016","key":"ortofoto_infraroig_2016","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2016"},{"name":"ortofotoInfraroig2015","key":"ortofoto_infraroig_2015","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2015"},{"name":"ortofotoInfraroig2014","key":"ortofoto_infraroig_2014","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2014"},{"name":"ortofotoInfraroig2013","key":"ortofoto_infraroig_2013","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2013"},{"name":"ortofotoInfraroig2012","key":"ortofoto_infraroig_2012","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2012"},{"name":"ortofotoInfraroig2011","key":"ortofoto_infraroig_2011","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2011"},{"name":"ortofotoInfraroig2010","key":"ortofoto_infraroig_2010","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2010"},{"name":"ortofotoInfraroig2009","key":"ortofoto_infraroig_2009","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2009"},{"name":"ortofotoInfraroig2008","key":"ortofoto_infraroig_2008","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2008"},{"name":"ortofotoInfraroig20062007","key":"ortofoto_infraroig_2006-2007","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2006-2007"},{"name":"ortofotoInfraroig19961997","key":"ortofoto_infraroig_1996-1997","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_1996-1997"},{"name":"ortofotoInfraroigSerieAnual","key":"ortofoto_infraroig_serie_anual","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_serie_anual"}],"vectorLayersICGC":[{"name":"agrupacionsCensals2015","key":"agrupacions_censals_2015"},{"name":"agrupacionsCensals2016","key":"agrupacions_censals_2016"},{"name":"agrupacionsCensals2017","key":"agrupacions_censals_2017"},{"name":"agrupacionsCensals2018","key":"agrupacions_censals_2018"},{"name":"agrupacionsCensals2019","key":"agrupacions_censals_2019"},{"name":"agrupacionsCensals2020","key":"agrupacions_censals_2020"},{"name":"agrupacionsCensals2021","key":"agrupacions_censals_2021"},{"name":"agrupacionsCensalsVigent","key":"agrupacions_censals_vigent"},{"name":"agrupacionsCensalsVigentText","key":"agrupacions_censals_vigent_text"},{"name":"areesBasiquesPolicials2019","key":"arees_basiques_policials_2019"},{"name":"areesBasiquesPolicials2020","key":"arees_basiques_policials_2020"},{"name":"areesBasiquesPolicials2022","key":"arees_basiques_policials_2022"},{"name":"areesBasiquesPolicialsVigent","key":"arees_basiques_policials_vigent"},{"name":"areesBasiquesPolicialsVigentText","key":"arees_basiques_policials_vigent_text"},{"name":"areesBasiquesSalutVigent","key":"arees_basiques_salut_vigent"},{"name":"areesBasiquesServeisSocialsVigent","key":"arees_basiques_serveis_socials_vigent"},{"name":"areesBasiquesServeisSocialsVigentText","key":"arees_basiques_serveis_socials_vigent_text"},{"name":"areesGestioAssistencialVigent","key":"arees_gestio_assistencial_vigent"},{"name":"areesHidrogeologiquesAquifersVigent","key":"arees_hidrogeologiques_aquifers_vigent"},{"name":"catalunyaVigent","key":"catalunya_vigent"},{"name":"catalunyaVigentText","key":"catalunya_vigent_text"},{"name":"comarques2022","key":"comarques_2022"},{"name":"comarquesVigent","key":"comarques_vigent"},{"name":"comarquesVigentText","key":"comarques_vigent_text"},{"name":"districtesCensals2015","key":"districtes_censals_2015"},{"name":"districtesCensals2016","key":"districtes_censals_2016"},{"name":"districtesCensals2017","key":"districtes_censals_2017"},{"name":"districtesCensals2018","key":"districtes_censals_2018"},{"name":"districtesCensals2019","key":"districtes_censals_2019"},{"name":"districtesCensals2020","key":"districtes_censals_2020"},{"name":"districtesCensals2021","key":"districtes_censals_2021"},{"name":"districtesCensals2022","key":"districtes_censals_2022"},{"name":"districtesCensals2023","key":"districtes_censals_2023"},{"name":"districtesCensalsVigent","key":"districtes_censals_vigent"},{"name":"districtesCensalsVigentText","key":"districtes_censals_vigent_text"},{"name":"incendisForestalsVigent","key":"incendis_forestals_vigent"},{"name":"incendisForestalsVigentText","key":"incendis_forestals_vigent_text"},{"name":"municipis2022","key":"municipis_2022"},{"name":"municipis2022Text","key":"municipis_2022_text"},{"name":"municipisVigent","key":"municipis_vigent"},{"name":"municipisVigentText","key":"municipis_vigent_text"},{"name":"partitsJudicialsVigent","key":"partits_judicials_vigent"},{"name":"partitsJudicialsVigentText","key":"partits_judicials_vigent_text"},{"name":"plaTerritorial2015","key":"pla_territorial_2015"},{"name":"plaTerritorialVigent","key":"pla_territorial_vigent"},{"name":"plaTerritorialVigentText","key":"pla_territorial_vigent_text"},{"name":"provinciesVigent","key":"provincies_vigent"},{"name":"provinciesVigentText","key":"provincies_vigent_text"},{"name":"regionsPolicialsVigent","key":"regions_policials_vigent"},{"name":"regionsPolicialsVigentText","key":"regions_policials_vigent_text"},{"name":"regionsSanitariesVigent","key":"regions_sanitaries_vigent"},{"name":"regionsSanitariesVigentText","key":"regions_sanitaries_vigent_text"},{"name":"seccionsCensals2015","key":"seccions_censals_2015"},{"name":"seccionsCensals2016","key":"seccions_censals_2016"},{"name":"seccionsCensals2017","key":"seccions_censals_2017"},{"name":"seccionsCensals2018","key":"seccions_censals_2018"},{"name":"seccionsCensals2019","key":"seccions_censals_2019"},{"name":"seccionsCensals2020","key":"seccions_censals_2020"},{"name":"seccionsCensals2021","key":"seccions_censals_2021"},{"name":"seccionsCensals2022","key":"seccions_censals_2022"},{"name":"seccionsCensals2023","key":"seccions_censals_2023"},{"name":"seccionsCensalsVigent","key":"seccions_censals_vigent"},{"name":"seccionsCensalsVigentText","key":"seccions_censals_vigent_text"},{"name":"sectorsSanitarisVigent","key":"sectors_sanitaris_vigent"},{"name":"vegueriesVigent","key":"vegueries_vigent"},{"name":"vegueriesVigentText","key":"vegueries_vigent_text"}],"vectorLayers":[{"key":"cobertes2018","url":"https://tilemaps.icgc.cat/tileserver/cobertes_tilejson.json","legend":"https://eines.icgc.cat/recursos//images/llegendaCobertesSol2018.jpg"}],"wmsLayers":[{"key":"espaisInteresGeologic","layer":"","url":"https://geoserveis.icgc.cat/servei/catalunya/espais-interes-geologic/wms/service?&service=WMS&request=GetMap&layers=espais-interes-geologic&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}"},{"key":"gravimetriaBouguer500000","layer":"","url":"https://geoserveis.icgc.cat/servei/catalunya/gravimetria/wms/service?&service=WMS&request=GetMap&layers=anomalia_bouguer_500000&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}"},{"key":"cobertesSol2018","layer":"","url":"https://geoserveis.icgc.cat/servei/catalunya/cobertes-sol/wms/service?&service=WMS&request=GetMap&layers=cobertes_2018&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}"},{"key":"administratiu","layer":"","url":"http://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/administratiu/MON3857NW/{z}/{x}/{y}.png"},{"key":"simplificat","layer":"","url":"http://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/simplificat/MON3857NW/{z}/{x}/{y}.png"},{"key":"cims","layer":"","url":"https://geoserveis.icgc.cat/icc_100cims/wms/service?REQUEST=GetMap&SERVICE=WMS&VERSION=1.1.1&LAYERS=0&STYLES=&FORMAT=image/png&BGCOLOR=0xFFFFFF&TRANSPARENT=TRUE&SRS=EPSG:25831&BBOX=137118.923076923,4488408.75,650959.076923077,4749634.75&WIDTH=895&HEIGHT=455"},{"key":"cobertesSol","layer":"","url":"http://geoserveis.icgc.cat/servei/catalunya/cobertes-sol/wms?REQUEST=GetMap&SERVICE=WMS&VERSION=1.3.0&LAYERS=cobertes_2009&STYLES=&FORMAT=image/png&BGCOLOR=0xFFFFFF&TRANSPARENT=TRUE&CRS=EPSG:25831&BBOX=374110.828167253,4639230.79853085,452621.120632226,4703578.45000215&WIDTH=1020&HEIGHT=836"}],"fgbLayers":[{"name":"agrupacionsCensalsVigent","key":"agrupacions_censals_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/agrupacions_censals_vigent.fgb"},{"name":"agrupacionsCensalsVigentText","key":"agrupacions_censals_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/agrupacions_censals_vigent_text.fgb"},{"name":"areesBasiquesPolicialsVigent","key":"arees_basiques_policials_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_policials_vigent.fgb"},{"name":"areesBasiquesPolicialsVigentText","key":"arees_basiques_policials_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_policials_vigent_text.fgb"},{"name":"areesBasiquesSalutVigent","key":"arees_basiques_salut_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_salut_vigent.fgb"},{"name":"areesBasiquesServeisSocialsVigent","key":"arees_basiques_serveis_socials_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_serveis_socials_vigent.fgb"},{"name":"areesBasiquesServeisSocialsVigentText","key":"arees_basiques_serveis_socials_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_serveis_socials_vigent_text.fgb"},{"name":"areesGestioAssistencialVigent","key":"arees_gestio_assistencial_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/arees_gestio_assistencial_vigent.fgb"},{"name":"areesHidrogeologiquesAquifersVigent","key":"arees_hidrogeologiques_aquifers_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/arees_hidrogeologiques_aquifers_vigent.fgb"},{"name":"catalunyaVigent","key":"catalunya_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/catalunya_vigent.fgb"},{"name":"catalunyaVigentText","key":"catalunya_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/catalunya_vigent_text.fgb"},{"name":"comarquesVigent","key":"comarques_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/comarques_vigent.fgb"},{"name":"comarquesVigentText","key":"comarques_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/comarques_vigent_text.fgb"},{"name":"districtesCensalsVigent","key":"districtes_censals_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/districtes_censals_vigent.fgb"},{"name":"districtesCensalsVigentText","key":"districtes_censals_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/districtes_censals_vigent_text.fgb"},{"name":"incendisForestalsVigent","key":"incendis_forestals_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/incendis_forestals_vigent.fgb"},{"name":"incendisForestalsVigentText","key":"incendis_forestals_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/incendis_forestals_vigent_text.fgb"},{"name":"municipisVigent","key":"municipis_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/municipis_vigent.fgb"},{"name":"municipisVigentText","key":"municipis_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/municipis_vigent_text.fgb"},{"name":"partitsJudicialsVigent","key":"partits_judicials_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/partits_judicials_vigent.fgb"},{"name":"partitsJudicialsVigentText","key":"partits_judicials_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/partits_judicials_vigent_text.fgb"},{"name":"plaTerritorialVigent","key":"pla_territorial_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/pla_territorial_vigent.fgb"},{"name":"plaTerritorialVigentText","key":"pla_territorial_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/pla_territorial_vigent_text.fgb"},{"name":"provinciesVigent","key":"provincies_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/provincies_vigent.fgb"},{"name":"provinciesVigentText","key":"provincies_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/provincies_vigent_text.fgb"},{"name":"regionsPolicialsVigent","key":"regions_policials_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/regions_policials_vigent.fgb"},{"name":"regionsPolicialsVigentText","key":"regions_policials_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/regions_policials_vigent_text.fgb"},{"name":"regionsSanitariesVigent","key":"regions_sanitaries_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/regions_sanitaries_vigent.fgb"},{"name":"regionsSanitariesVigentText","key":"regions_sanitaries_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/regions_sanitaries_vigent_text.fgb"},{"name":"seccionsCensalsVigent","key":"seccions_censals_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/seccions_censals_vigent.fgb"},{"name":"seccionsCensalsVigentText","key":"seccions_censals_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/seccions_censals_vigent_text.fgb"},{"name":"sectorsSanitarisVigent","key":"sectors_sanitaris_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/sectors_sanitaris_vigent.fgb"},{"name":"vegueriesVigent","key":"vegueries_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/vegueries_vigent.fgb"},{"name":"vegueriesVigentText","key":"vegueries_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/vegueries_vigent_text.fgb"}]}'), fY = { TOPO: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_topografic.json", ORTO: "https://geoserveis.icgc.cat/styles/icgc_orto_estandard.json", ORTO3D: "https://eines.icgc.cat/recursos//styles/icgc_orto_3d.json", ORTOHYBRID: "https://geoserveis.icgc.cat/styles/icgc_orto_hibrida.json", ADMIN: "https://geoserveis.icgc.cat/styles/icgc_limits_administratius_gris.json", DARK: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_fosc.json", LIGHT: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_gris.json", GEOLOGY: "https://geoserveis.icgc.cat/styles/icgc_geologic_informacio.json", RASTER: { TOPO: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/topografic/MON3857NW/{z}/{x}/{y}.png", ADMIN: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/administratiu/MON3857NW/{z}/{x}/{y}.png", LIGHT: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/topografic-gris/MON3857NW/{z}/{x}/{y}.png", STANDARD: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/estandard/MON3857NW/{z}/{x}/{y}.png", SIMPLIFIED: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/simplificat/MON3857NW/{z}/{x}/{y}.png", ORTO: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto/MON3857NW/{z}/{x}/{y}.png", ORTOGREY: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto-gris/MON3857NW/{z}/{x}/{y}.png", ORTOHYBRID: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto-hibrida/MON3857NW/{z}/{x}/{y}.png" } }, dY = { ICGC5M: "https://tilemaps.icgc.cat/tileserver/tileserver/terreny-5m-30m-rgb-extent/{z}/{x}/{y}.png", WORLD30M: "https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png" }, pY = /* @__PURE__ */ JSON.parse('{"Orto":{"ortofotoColorProvisional":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_provisional","ortofotoColor2023":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2023","ortofotoColor2022":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2022","ortofotoColor2021":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2021","ortofotoColor2020":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2020","ortofotoColor2019":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2019","ortofotoColor2018":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2018","ortofotoColor2017":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2017","ortofotoColor2016":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2016","ortofotoColor2015":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2015","ortofotoColor2014":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2014","ortofotoColor2013":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2013","ortofotoColor2012":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2012","ortofotoColor2011":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2011","ortofotoColor2010":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2010","ortofotoColor2009":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2009","ortofotoColor2008":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2008","ortofotoColor20062007":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2006-2007","ortofotoColor20042005":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2004-2005","ortofotoColor20002003":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2000-2003","ortofotoBlancINegre1998":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1998","ortofotoBlancINegre19941997":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1994-1997","ortofotoColor1993":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_1993","ortofotoBlancINegre19831992":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1983-1992","ortofotoBlancINegre19701977":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1970-1977","ortofotoBlancINegre1956":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1956","ortofotoBlancINegre1945":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1945","ortofotoColorSerieAnual":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_serie_anual","ortofotoInfraroigProvisional":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_provisional","ortofotoInfraroig2023":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2023","ortofotoInfraroig2022":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2022","ortofotoInfraroig2021":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2021","ortofotoInfraroig2020":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2020","ortofotoInfraroig2019":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2019","ortofotoInfraroig2018":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2018","ortofotoInfraroig2017":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2017","ortofotoInfraroig2016":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2016","ortofotoInfraroig2015":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2015","ortofotoInfraroig2014":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2014","ortofotoInfraroig2013":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2013","ortofotoInfraroig2012":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2012","ortofotoInfraroig2011":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2011","ortofotoInfraroig2010":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2010","ortofotoInfraroig2009":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2009","ortofotoInfraroig2008":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2008","ortofotoInfraroig20062007":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2006-2007","ortofotoInfraroig19961997":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_1996-1997","ortofotoInfraroigSerieAnual":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_serie_anual"},"VectorAdmin":{"agrupacionsCensals2015":"agrupacions_censals_2015","agrupacionsCensals2016":"agrupacions_censals_2016","agrupacionsCensals2017":"agrupacions_censals_2017","agrupacionsCensals2018":"agrupacions_censals_2018","agrupacionsCensals2019":"agrupacions_censals_2019","agrupacionsCensals2020":"agrupacions_censals_2020","agrupacionsCensals2021":"agrupacions_censals_2021","agrupacionsCensalsVigent":"agrupacions_censals_vigent","agrupacionsCensalsVigentText":"agrupacions_censals_vigent_text","areesBasiquesPolicials2019":"arees_basiques_policials_2019","areesBasiquesPolicials2020":"arees_basiques_policials_2020","areesBasiquesPolicials2022":"arees_basiques_policials_2022","areesBasiquesPolicialsVigent":"arees_basiques_policials_vigent","areesBasiquesPolicialsVigentText":"arees_basiques_policials_vigent_text","areesBasiquesSalutVigent":"arees_basiques_salut_vigent","areesBasiquesServeisSocialsVigent":"arees_basiques_serveis_socials_vigent","areesBasiquesServeisSocialsVigentText":"arees_basiques_serveis_socials_vigent_text","areesGestioAssistencialVigent":"arees_gestio_assistencial_vigent","areesHidrogeologiquesAquifersVigent":"arees_hidrogeologiques_aquifers_vigent","catalunyaVigent":"catalunya_vigent","catalunyaVigentText":"catalunya_vigent_text","comarques2022":"comarques_2022","comarquesVigent":"comarques_vigent","comarquesVigentText":"comarques_vigent_text","districtesCensals2015":"districtes_censals_2015","districtesCensals2016":"districtes_censals_2016","districtesCensals2017":"districtes_censals_2017","districtesCensals2018":"districtes_censals_2018","districtesCensals2019":"districtes_censals_2019","districtesCensals2020":"districtes_censals_2020","districtesCensals2021":"districtes_censals_2021","districtesCensals2022":"districtes_censals_2022","districtesCensals2023":"districtes_censals_2023","districtesCensalsVigent":"districtes_censals_vigent","districtesCensalsVigentText":"districtes_censals_vigent_text","incendisForestalsVigent":"incendis_forestals_vigent","incendisForestalsVigentText":"incendis_forestals_vigent_text","municipis2022":"municipis_2022","municipis2022Text":"municipis_2022_text","municipisVigent":"municipis_vigent","municipisVigentText":"municipis_vigent_text","partitsJudicialsVigent":"partits_judicials_vigent","partitsJudicialsVigentText":"partits_judicials_vigent_text","plaTerritorial2015":"pla_territorial_2015","plaTerritorialVigent":"pla_territorial_vigent","plaTerritorialVigentText":"pla_territorial_vigent_text","provinciesVigent":"provincies_vigent","provinciesVigentText":"provincies_vigent_text","regionsPolicialsVigent":"regions_policials_vigent","regionsPolicialsVigentText":"regions_policials_vigent_text","regionsSanitariesVigent":"regions_sanitaries_vigent","regionsSanitariesVigentText":"regions_sanitaries_vigent_text","seccionsCensals2015":"seccions_censals_2015","seccionsCensals2016":"seccions_censals_2016","seccionsCensals2017":"seccions_censals_2017","seccionsCensals2018":"seccions_censals_2018","seccionsCensals2019":"seccions_censals_2019","seccionsCensals2020":"seccions_censals_2020","seccionsCensals2021":"seccions_censals_2021","seccionsCensals2022":"seccions_censals_2022","seccionsCensals2023":"seccions_censals_2023","seccionsCensalsVigent":"seccions_censals_vigent","seccionsCensalsVigentText":"seccions_censals_vigent_text","sectorsSanitarisVigent":"sectors_sanitaris_vigent","vegueriesVigent":"vegueries_vigent","vegueriesVigentText":"vegueries_vigent_text"},"FGBAdmin":{"agrupacionsCensalsVigent":"https://tilemaps.icgc.cat/vector/fgb/agrupacions_censals_vigent.fgb","agrupacionsCensalsVigentText":"https://tilemaps.icgc.cat/vector/fgb/agrupacions_censals_vigent_text.fgb","areesBasiquesPolicialsVigent":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_policials_vigent.fgb","areesBasiquesPolicialsVigentText":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_policials_vigent_text.fgb","areesBasiquesSalutVigent":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_salut_vigent.fgb","areesBasiquesServeisSocialsVigent":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_serveis_socials_vigent.fgb","areesBasiquesServeisSocialsVigentText":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_serveis_socials_vigent_text.fgb","areesGestioAssistencialVigent":"https://tilemaps.icgc.cat/vector/fgb/arees_gestio_assistencial_vigent.fgb","areesHidrogeologiquesAquifersVigent":"https://tilemaps.icgc.cat/vector/fgb/arees_hidrogeologiques_aquifers_vigent.fgb","catalunyaVigent":"https://tilemaps.icgc.cat/vector/fgb/catalunya_vigent.fgb","catalunyaVigentText":"https://tilemaps.icgc.cat/vector/fgb/catalunya_vigent_text.fgb","comarquesVigent":"https://tilemaps.icgc.cat/vector/fgb/comarques_vigent.fgb","comarquesVigentText":"https://tilemaps.icgc.cat/vector/fgb/comarques_vigent_text.fgb","districtesCensalsVigent":"https://tilemaps.icgc.cat/vector/fgb/districtes_censals_vigent.fgb","districtesCensalsVigentText":"https://tilemaps.icgc.cat/vector/fgb/districtes_censals_vigent_text.fgb","incendisForestalsVigent":"https://tilemaps.icgc.cat/vector/fgb/incendis_forestals_vigent.fgb","incendisForestalsVigentText":"https://tilemaps.icgc.cat/vector/fgb/incendis_forestals_vigent_text.fgb","municipisVigent":"https://tilemaps.icgc.cat/vector/fgb/municipis_vigent.fgb","municipisVigentText":"https://tilemaps.icgc.cat/vector/fgb/municipis_vigent_text.fgb","partitsJudicialsVigent":"https://tilemaps.icgc.cat/vector/fgb/partits_judicials_vigent.fgb","partitsJudicialsVigentText":"https://tilemaps.icgc.cat/vector/fgb/partits_judicials_vigent_text.fgb","plaTerritorialVigent":"https://tilemaps.icgc.cat/vector/fgb/pla_territorial_vigent.fgb","plaTerritorialVigentText":"https://tilemaps.icgc.cat/vector/fgb/pla_territorial_vigent_text.fgb","provinciesVigent":"https://tilemaps.icgc.cat/vector/fgb/provincies_vigent.fgb","provinciesVigentText":"https://tilemaps.icgc.cat/vector/fgb/provincies_vigent_text.fgb","regionsPolicialsVigent":"https://tilemaps.icgc.cat/vector/fgb/regions_policials_vigent.fgb","regionsPolicialsVigentText":"https://tilemaps.icgc.cat/vector/fgb/regions_policials_vigent_text.fgb","regionsSanitariesVigent":"https://tilemaps.icgc.cat/vector/fgb/regions_sanitaries_vigent.fgb","regionsSanitariesVigentText":"https://tilemaps.icgc.cat/vector/fgb/regions_sanitaries_vigent_text.fgb","seccionsCensalsVigent":"https://tilemaps.icgc.cat/vector/fgb/seccions_censals_vigent.fgb","seccionsCensalsVigentText":"https://tilemaps.icgc.cat/vector/fgb/seccions_censals_vigent_text.fgb","sectorsSanitarisVigent":"https://tilemaps.icgc.cat/vector/fgb/sectors_sanitaris_vigent.fgb","vegueriesVigent":"https://tilemaps.icgc.cat/vector/fgb/vegueries_vigent.fgb","vegueriesVigentText":"https://tilemaps.icgc.cat/vector/fgb/vegueries_vigent_text.fgb"},"Vector":{"cobertes2018":"https://tilemaps.icgc.cat/tileserver/cobertes_tilejson.json"},"WMS":{"espaisInteresGeologic":"https://geoserveis.icgc.cat/servei/catalunya/espais-interes-geologic/wms/service?&service=WMS&request=GetMap&layers=espais-interes-geologic&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}","gravimetriaBouguer500000":"https://geoserveis.icgc.cat/servei/catalunya/gravimetria/wms/service?&service=WMS&request=GetMap&layers=anomalia_bouguer_500000&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}","cobertesSol2018":"https://geoserveis.icgc.cat/servei/catalunya/cobertes-sol/wms/service?&service=WMS&request=GetMap&layers=cobertes_2018&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}","administratiu":"http://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/administratiu/MON3857NW/{z}/{x}/{y}.png","simplificat":"http://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/simplificat/MON3857NW/{z}/{x}/{y}.png","cims":"https://geoserveis.icgc.cat/icc_100cims/wms/service?REQUEST=GetMap&SERVICE=WMS&VERSION=1.1.1&LAYERS=0&STYLES=&FORMAT=image/png&BGCOLOR=0xFFFFFF&TRANSPARENT=TRUE&SRS=EPSG:25831&BBOX=137118.923076923,4488408.75,650959.076923077,4749634.75&WIDTH=895&HEIGHT=455","cobertesSol":"http://geoserveis.icgc.cat/servei/catalunya/cobertes-sol/wms?REQUEST=GetMap&SERVICE=WMS&VERSION=1.3.0&LAYERS=cobertes_2009&STYLES=&FORMAT=image/png&BGCOLOR=0xFFFFFF&TRANSPARENT=TRUE&CRS=EPSG:25831&BBOX=374110.828167253,4639230.79853085,452621.120632226,4703578.45000215&WIDTH=1020&HEIGHT=836"}}'), Bf = {
  defaultOptions: hY,
  Styles: fY,
  Terrains: dY,
  Layers: pY
};
class gY {
  constructor(e) {
    this.options = e || {};
  }
  onAdd(e) {
    let t = Bf.defaultOptions;
    return this._map = e, this._img1 = document.createElement("img"), this._img1.className = "maplibregl-ctrl", this._img1.src = this.options.color ? t.logoIcgcOptions.logoUrlColor : t.logoIcgcOptions.logoUrlWhite, this._img1.width = t.logoIcgcOptions.logoWidth, this._img1.title = t.logoIcgcOptions.logoTitle, this._img1.style.opacity = t.logoIcgcOptions.logoOpacity, this.link1 = document.createElement("a"), this.link1.href = t.logoIcgcOptions.logoLink, this.link1.target = "_blank", this.link1.appendChild(this._img1), this._container1 = document.createElement("div"), this._container1.className = "maplibregl-ctrl", this._container1.style.width = `${t.logoIcgcOptions.logoWidth}px`, this._container1.appendChild(this.link1), this._img2 = document.createElement("img"), this._img2.className = "maplibregl-ctrl", this._img2.src = this.options.color ? t.logoGencatOptions.logoUrlColor : t.logoGencatOptions.logoUrlWhite, this._img2.width = t.logoGencatOptions.logoWidth, this._img2.title = t.logoGencatOptions.logoTitle, this._img2.style.opacity = t.logoGencatOptions.logoOpacity, this.link2 = document.createElement("a"), this.link2.href = t.logoGencatOptions.logoLink, this.link2.target = "_blank", this.link2.appendChild(this._img2), this._container2 = document.createElement("div"), this._container2.className = "maplibregl-ctrl", this._container2.style.width = `${t.logoGencatOptions.logoWidth}px`, this._container2.appendChild(this.link2), this._mainContainer = document.createElement("div"), this._mainContainer.className = "divLogos", this._mainContainer.style = "display: flex", this._mainContainer.appendChild(this._container1), this._mainContainer.appendChild(this._container2), this._mainContainer;
  }
}
class mY {
  constructor(e) {
    this.options = e || {};
  }
  onAdd(e) {
    this._map = e, this._img1 = document.createElement("img"), this._img1.src = this.options.url, this._img1.width = 150, this._img1.title = 300, this.controlContainer = document.createElement("div"), this.controlContainer.classList.add("maplibregl-ctrl"), this.controlContainer.classList.add("maplibregl-ctrl-group"), this.legendContainer = document.createElement("div"), this.legendContainer.classList.add("maplibregl-legend-list"), this.legendButton = document.createElement("button"), this.legendButton.classList.add("maplibregl-ctrl-icon"), this.legendButton.classList.add("maplibregl-legend-switcher"), this.legendButton.addEventListener("click", () => {
      this.legendButton.style.display = "none", this.legendContainer.style.display = "block";
    }), document.addEventListener("click", this.onDocumentClick), this.controlContainer.appendChild(this.legendButton), this.controlContainer.appendChild(this.legendContainer), this.closeButton = document.createElement("button"), this.closeButton.textContent = "x", this.closeButton.classList.add("maplibregl-legend-close-button"), this.closeButton.addEventListener("click", () => {
      this.legendButton.style.display = "block", this.legendContainer.style.display = "none";
    }), this.legendContainer.appendChild(this.closeButton);
    const t = document.createElement("label");
    return t.classList.add("maplibregl-legend-title-label"), t.textContent = this.options.idLayer || "Llegenda", this.legendContainer.appendChild(t), this.legendContainer.appendChild(document.createElement("br")), this.legendContainer.appendChild(this._img1), this.controlContainer;
  }
}
var w1, mE;
function _Y() {
  if (mE) return w1;
  mE = 1;
  var r = t.prototype, e = "WGS 84";
  function t(i) {
    i !== void 0 && (e = i), this.setEllipsoid(e);
  }
  r.convertLatLngToUtm = function(i, s, l) {
    var o;
    if (this.status)
      return "No ecclipsoid data associated with unknown datum: " + e;
    if (!Number.isInteger(l))
      return "Precision is not integer number.";
    i = parseFloat(i), s = parseFloat(s);
    var d = s, m = this.toRadians(i), b = this.toRadians(d);
    d >= 8 && d <= 13 && i > 54.5 && i < 58 || i >= 56 && i < 64 && d >= 3 && d < 12 ? o = 32 : (o = (d + 180) / 6 + 1, i >= 72 && i < 84 && (d >= 0 && d < 9 ? o = 31 : d >= 9 && d < 21 ? o = 33 : d >= 21 && d < 33 ? o = 35 : d >= 33 && d < 42 && (o = 37))), o = parseInt(o);
    var A = (o - 1) * 6 - 180 + 3, M = this.toRadians(A), E = this.getUtmLetterDesignator(i), k = this.eccSquared / (1 - this.eccSquared), U = this.a / Math.sqrt(1 - this.eccSquared * Math.sin(m) * Math.sin(m)), V = Math.tan(m) * Math.tan(m), q = k * Math.cos(m) * Math.cos(m), Y = Math.cos(m) * (b - M), re = this.a * ((1 - this.eccSquared / 4 - 3 * this.eccSquared * this.eccSquared / 64 - 5 * this.eccSquared * this.eccSquared * this.eccSquared / 256) * m - (3 * this.eccSquared / 8 + 3 * this.eccSquared * this.eccSquared / 32 + 45 * this.eccSquared * this.eccSquared * this.eccSquared / 1024) * Math.sin(2 * m) + (15 * this.eccSquared * this.eccSquared / 256 + 45 * this.eccSquared * this.eccSquared * this.eccSquared / 1024) * Math.sin(4 * m) - 35 * this.eccSquared * this.eccSquared * this.eccSquared / 3072 * Math.sin(6 * m)), Z = parseFloat(0.9996 * U * (Y + (1 - V + q) * Y * Y * Y / 6 + (5 - 18 * V + V * V + 72 * q - 58 * k) * Y * Y * Y * Y * Y / 120) + 5e5), K = parseFloat(0.9996 * (re + U * Math.tan(m) * (Y * Y / 2 + (5 - V + 9 * q + 4 * q * q) * Y * Y * Y * Y / 24 + (61 - 58 * V + V * V + 600 * q - 330 * k) * Y * Y * Y * Y * Y * Y / 720)));
    return i < 0 && (K += 1e7), K = n(K, l), Z = n(Z, l), {
      Easting: Z,
      Northing: K,
      ZoneNumber: parseInt(o),
      ZoneLetter: E
    };
  }, r.convertUtmToLatLng = function(i, s, l, o) {
    var d = (1 - Math.sqrt(1 - this.eccSquared)) / (1 + Math.sqrt(1 - this.eccSquared)), m = i - 5e5, b = s, A = l, M = o;
    if (i === void 0)
      return "Please pass the UTMEasting!";
    if (s === void 0)
      return "Please pass the UTMNorthing!";
    if (l === void 0)
      return "Please pass the UTMZoneNumber!";
    if (o === void 0)
      return "Please pass the UTMZoneLetter!";
    ["N", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"].indexOf(M) !== -1 || (b -= 1e7);
    var E = (A - 1) * 6 - 180 + 3, k = this.eccSquared / (1 - this.eccSquared), U = b / 0.9996, V = U / (this.a * (1 - this.eccSquared / 4 - 3 * this.eccSquared * this.eccSquared / 64 - 5 * this.eccSquared * this.eccSquared * this.eccSquared / 256)), q = V + (3 * d / 2 - 27 * d * d * d / 32) * Math.sin(2 * V) + (21 * d * d / 16 - 55 * d * d * d * d / 32) * Math.sin(4 * V) + 151 * d * d * d / 96 * Math.sin(6 * V);
    this.toDegrees(q);
    var Y = this.a / Math.sqrt(1 - this.eccSquared * Math.sin(q) * Math.sin(q)), re = Math.tan(q) * Math.tan(q), Z = k * Math.cos(q) * Math.cos(q), K = this.a * (1 - this.eccSquared) / Math.pow(1 - this.eccSquared * Math.sin(q) * Math.sin(q), 1.5), ie = m / (Y * 0.9996), be = q - Y * Math.tan(q) / K * (ie * ie / 2 - (5 + 3 * re + 10 * Z - 4 * Z * Z - 9 * k) * ie * ie * ie * ie / 24 + (61 + 90 * re + 298 * Z + 45 * re * re - 252 * k - 3 * Z * Z) * ie * ie * ie * ie * ie * ie / 720);
    be = this.toDegrees(be);
    var he = (ie - (1 + 2 * re + Z) * ie * ie * ie / 6 + (5 - 2 * Z + 28 * re - 3 * Z * Z + 8 * k + 24 * re * re) * ie * ie * ie * ie * ie / 120) / Math.cos(q);
    return he = E + this.toDegrees(he), {
      lat: be,
      lng: he
    };
  }, r.getUtmLetterDesignator = function(i) {
    return i = parseFloat(i), 84 >= i && i >= 72 ? "X" : 72 > i && i >= 64 ? "W" : 64 > i && i >= 56 ? "V" : 56 > i && i >= 48 ? "U" : 48 > i && i >= 40 ? "T" : 40 > i && i >= 32 ? "S" : 32 > i && i >= 24 ? "R" : 24 > i && i >= 16 ? "Q" : 16 > i && i >= 8 ? "P" : 8 > i && i >= 0 ? "N" : 0 > i && i >= -8 ? "M" : -8 > i && i >= -16 ? "L" : -16 > i && i >= -24 ? "K" : -24 > i && i >= -32 ? "J" : -32 > i && i >= -40 ? "H" : -40 > i && i >= -48 ? "G" : -48 > i && i >= -56 ? "F" : -56 > i && i >= -64 ? "E" : -64 > i && i >= -72 ? "D" : -72 > i && i >= -80 ? "C" : "Z";
  }, r.setEllipsoid = function(i) {
    switch (i) {
      case "Airy":
        this.a = 6377563, this.eccSquared = 667054e-8;
        break;
      case "Australian National":
        this.a = 6378160, this.eccSquared = 6694542e-9;
        break;
      case "Bessel 1841":
        this.a = 6377397, this.eccSquared = 6674372e-9;
        break;
      case "Bessel 1841 Nambia":
        this.a = 6377484, this.eccSquared = 6674372e-9;
        break;
      case "Clarke 1866":
        this.a = 6378206, this.eccSquared = 6768658e-9;
        break;
      case "Clarke 1880":
        this.a = 6378249, this.eccSquared = 6803511e-9;
        break;
      case "Everest":
        this.a = 6377276, this.eccSquared = 6637847e-9;
        break;
      case "Fischer 1960 Mercury":
        this.a = 6378166, this.eccSquared = 6693422e-9;
        break;
      case "Fischer 1968":
        this.a = 6378150, this.eccSquared = 6693422e-9;
        break;
      case "GRS 1967":
        this.a = 6378160, this.eccSquared = 6694605e-9;
        break;
      case "GRS 1980":
        this.a = 6378137, this.eccSquared = 669438e-8;
        break;
      case "Helmert 1906":
        this.a = 6378200, this.eccSquared = 6693422e-9;
        break;
      case "Hough":
        this.a = 6378270, this.eccSquared = 672267e-8;
        break;
      case "International":
        this.a = 6378388, this.eccSquared = 672267e-8;
        break;
      case "Krassovsky":
        this.a = 6378245, this.eccSquared = 6693422e-9;
        break;
      case "Modified Airy":
        this.a = 6377340, this.eccSquared = 667054e-8;
        break;
      case "Modified Everest":
        this.a = 6377304, this.eccSquared = 6637847e-9;
        break;
      case "Modified Fischer 1960":
        this.a = 6378155, this.eccSquared = 6693422e-9;
        break;
      case "South American 1969":
        this.a = 6378160, this.eccSquared = 6694542e-9;
        break;
      case "WGS 60":
        this.a = 6378165, this.eccSquared = 6693422e-9;
        break;
      case "WGS 66":
        this.a = 6378145, this.eccSquared = 6694542e-9;
        break;
      case "WGS 72":
        this.a = 6378135, this.eccSquared = 6694318e-9;
        break;
      case "ED50":
        this.a = 6378388, this.eccSquared = 672267e-8;
        break;
      // International Ellipsoid
      case "WGS 84":
      case "EUREF89":
      // Max deviation from WGS 84 is 40 cm/km see http://ocq.dk/euref89 (in danish)
      case "ETRS89":
        this.a = 6378137, this.eccSquared = 669438e-8;
        break;
      default:
        this.status = !0;
    }
  }, r.toDegrees = function(i) {
    return i / Math.PI * 180;
  }, r.toRadians = function(i) {
    return i * Math.PI / 180;
  };
  function n(i, s) {
    var l = Math.pow(10, s);
    return Math.round(i * l) / l;
  }
  return w1 = t, w1;
}
var yY = _Y();
const bY = /* @__PURE__ */ e2(yY);
class vY {
  constructor(e) {
    this.options = e || {}, this.options.utm = this.options.hasOwnProperty("utm") ? this.options.utm : !0, this.options.lonlat = this.options.hasOwnProperty("lonlat") ? this.options.lonlat : !0;
  }
  onAdd(e) {
    const t = new bY();
    return this._map = e, this._container = document.createElement("div"), this._container.className = "maplibregl-ctrl coordControl", this._container.style.width = `${this.options.width || "225px"}`, this._map.on("mousemove", (n) => {
      const i = n.lngLat.lat, s = n.lngLat.lng;
      let l = "", o = "";
      const d = t.convertLatLngToUtm(i, s, 2), m = i > 0 ? "N" : "S";
      this.options.utm && (l = `ETRS89 UTM ${d.ZoneNumber}${m} X:<b> ${d.Easting}</b> Y:<b> ${d.Northing}</b> <br>`), this.options.lonlat && (o = `WGS 84 Lon:<b> ${s.toFixed(5)}</b>  Lat:<b> ${i.toFixed(5)}</b>`);
      const b = `${l}${o}`;
      this._container.innerHTML = b;
    }), this._container;
  }
  _lookUTM31(e, t) {
    var n = 0, i = 0, s = 6, l = 84;
    return e >= n && e <= s && t >= i && t <= l;
  }
  onRemove() {
    this._container.parentNode.removeChild(this._container), this._map = void 0;
  }
}
function JM(r, e) {
  return function() {
    return r.apply(e, arguments);
  };
}
const {
  toString: xY
} = Object.prototype, {
  getPrototypeOf: Sx
} = Object, {
  iterator: Ky,
  toStringTag: QM
} = Symbol, Jy = /* @__PURE__ */ ((r) => (e) => {
  const t = xY.call(e);
  return r[t] || (r[t] = t.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Nc = (r) => (r = r.toLowerCase(), (e) => Jy(e) === r), Qy = (r) => (e) => typeof e === r, {
  isArray: xp
} = Array, $g = Qy("undefined");
function wY(r) {
  return r !== null && !$g(r) && r.constructor !== null && !$g(r.constructor) && Va(r.constructor.isBuffer) && r.constructor.isBuffer(r);
}
const eP = Nc("ArrayBuffer");
function AY(r) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(r) : e = r && r.buffer && eP(r.buffer), e;
}
const TY = Qy("string"), Va = Qy("function"), tP = Qy("number"), e0 = (r) => r !== null && typeof r == "object", SY = (r) => r === !0 || r === !1, E_ = (r) => {
  if (Jy(r) !== "object")
    return !1;
  const e = Sx(r);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(QM in r) && !(Ky in r);
}, EY = Nc("Date"), CY = Nc("File"), IY = Nc("Blob"), MY = Nc("FileList"), PY = (r) => e0(r) && Va(r.pipe), RY = (r) => {
  let e;
  return r && (typeof FormData == "function" && r instanceof FormData || Va(r.append) && ((e = Jy(r)) === "formdata" || // detect form-data instance
  e === "object" && Va(r.toString) && r.toString() === "[object FormData]"));
}, BY = Nc("URLSearchParams"), [LY, OY, kY, NY] = ["ReadableStream", "Request", "Response", "Headers"].map(Nc), DY = (r) => r.trim ? r.trim() : r.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function em(r, e) {
  let {
    allOwnKeys: t = !1
  } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (r === null || typeof r > "u")
    return;
  let n, i;
  if (typeof r != "object" && (r = [r]), xp(r))
    for (n = 0, i = r.length; n < i; n++)
      e.call(null, r[n], n, r);
  else {
    const s = t ? Object.getOwnPropertyNames(r) : Object.keys(r), l = s.length;
    let o;
    for (n = 0; n < l; n++)
      o = s[n], e.call(null, r[o], o, r);
  }
}
function rP(r, e) {
  e = e.toLowerCase();
  const t = Object.keys(r);
  let n = t.length, i;
  for (; n-- > 0; )
    if (i = t[n], e === i.toLowerCase())
      return i;
  return null;
}
const Lf = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, nP = (r) => !$g(r) && r !== Lf;
function Xv() {
  const {
    caseless: r
  } = nP(this) && this || {}, e = {}, t = (n, i) => {
    const s = r && rP(e, i) || i;
    E_(e[s]) && E_(n) ? e[s] = Xv(e[s], n) : E_(n) ? e[s] = Xv({}, n) : xp(n) ? e[s] = n.slice() : e[s] = n;
  };
  for (let n = 0, i = arguments.length; n < i; n++)
    arguments[n] && em(arguments[n], t);
  return e;
}
const FY = function(r, e, t) {
  let {
    allOwnKeys: n
  } = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  return em(e, (i, s) => {
    t && Va(i) ? r[s] = JM(i, t) : r[s] = i;
  }, {
    allOwnKeys: n
  }), r;
}, UY = (r) => (r.charCodeAt(0) === 65279 && (r = r.slice(1)), r), zY = (r, e, t, n) => {
  r.prototype = Object.create(e.prototype, n), r.prototype.constructor = r, Object.defineProperty(r, "super", {
    value: e.prototype
  }), t && Object.assign(r.prototype, t);
}, jY = (r, e, t, n) => {
  let i, s, l;
  const o = {};
  if (e = e || {}, r == null) return e;
  do {
    for (i = Object.getOwnPropertyNames(r), s = i.length; s-- > 0; )
      l = i[s], (!n || n(l, r, e)) && !o[l] && (e[l] = r[l], o[l] = !0);
    r = t !== !1 && Sx(r);
  } while (r && (!t || t(r, e)) && r !== Object.prototype);
  return e;
}, VY = (r, e, t) => {
  r = String(r), (t === void 0 || t > r.length) && (t = r.length), t -= e.length;
  const n = r.indexOf(e, t);
  return n !== -1 && n === t;
}, $Y = (r) => {
  if (!r) return null;
  if (xp(r)) return r;
  let e = r.length;
  if (!tP(e)) return null;
  const t = new Array(e);
  for (; e-- > 0; )
    t[e] = r[e];
  return t;
}, qY = /* @__PURE__ */ ((r) => (e) => r && e instanceof r)(typeof Uint8Array < "u" && Sx(Uint8Array)), GY = (r, e) => {
  const n = (r && r[Ky]).call(r);
  let i;
  for (; (i = n.next()) && !i.done; ) {
    const s = i.value;
    e.call(r, s[0], s[1]);
  }
}, HY = (r, e) => {
  let t;
  const n = [];
  for (; (t = r.exec(e)) !== null; )
    n.push(t);
  return n;
}, WY = Nc("HTMLFormElement"), XY = (r) => r.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(t, n, i) {
  return n.toUpperCase() + i;
}), _E = ((r) => {
  let {
    hasOwnProperty: e
  } = r;
  return (t, n) => e.call(t, n);
})(Object.prototype), ZY = Nc("RegExp"), iP = (r, e) => {
  const t = Object.getOwnPropertyDescriptors(r), n = {};
  em(t, (i, s) => {
    let l;
    (l = e(i, s, r)) !== !1 && (n[s] = l || i);
  }), Object.defineProperties(r, n);
}, YY = (r) => {
  iP(r, (e, t) => {
    if (Va(r) && ["arguments", "caller", "callee"].indexOf(t) !== -1)
      return !1;
    const n = r[t];
    if (Va(n)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + t + "'");
      });
    }
  });
}, KY = (r, e) => {
  const t = {}, n = (i) => {
    i.forEach((s) => {
      t[s] = !0;
    });
  };
  return xp(r) ? n(r) : n(String(r).split(e)), t;
}, JY = () => {
}, QY = (r, e) => r != null && Number.isFinite(r = +r) ? r : e;
function eK(r) {
  return !!(r && Va(r.append) && r[QM] === "FormData" && r[Ky]);
}
const tK = (r) => {
  const e = new Array(10), t = (n, i) => {
    if (e0(n)) {
      if (e.indexOf(n) >= 0)
        return;
      if (!("toJSON" in n)) {
        e[i] = n;
        const s = xp(n) ? [] : {};
        return em(n, (l, o) => {
          const d = t(l, i + 1);
          !$g(d) && (s[o] = d);
        }), e[i] = void 0, s;
      }
    }
    return n;
  };
  return t(r, 0);
}, rK = Nc("AsyncFunction"), nK = (r) => r && (e0(r) || Va(r)) && Va(r.then) && Va(r.catch), sP = ((r, e) => r ? setImmediate : e ? ((t, n) => (Lf.addEventListener("message", (i) => {
  let {
    source: s,
    data: l
  } = i;
  s === Lf && l === t && n.length && n.shift()();
}, !1), (i) => {
  n.push(i), Lf.postMessage(t, "*");
}))(`axios@${Math.random()}`, []) : (t) => setTimeout(t))(typeof setImmediate == "function", Va(Lf.postMessage)), iK = typeof queueMicrotask < "u" ? queueMicrotask.bind(Lf) : typeof process < "u" && process.nextTick || sP, sK = (r) => r != null && Va(r[Ky]), Ut = {
  isArray: xp,
  isArrayBuffer: eP,
  isBuffer: wY,
  isFormData: RY,
  isArrayBufferView: AY,
  isString: TY,
  isNumber: tP,
  isBoolean: SY,
  isObject: e0,
  isPlainObject: E_,
  isReadableStream: LY,
  isRequest: OY,
  isResponse: kY,
  isHeaders: NY,
  isUndefined: $g,
  isDate: EY,
  isFile: CY,
  isBlob: IY,
  isRegExp: ZY,
  isFunction: Va,
  isStream: PY,
  isURLSearchParams: BY,
  isTypedArray: qY,
  isFileList: MY,
  forEach: em,
  merge: Xv,
  extend: FY,
  trim: DY,
  stripBOM: UY,
  inherits: zY,
  toFlatObject: jY,
  kindOf: Jy,
  kindOfTest: Nc,
  endsWith: VY,
  toArray: $Y,
  forEachEntry: GY,
  matchAll: HY,
  isHTMLForm: WY,
  hasOwnProperty: _E,
  hasOwnProp: _E,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: iP,
  freezeMethods: YY,
  toObjectSet: KY,
  toCamelCase: XY,
  noop: JY,
  toFiniteNumber: QY,
  findKey: rP,
  global: Lf,
  isContextDefined: nP,
  isSpecCompliantForm: eK,
  toJSONObject: tK,
  isAsyncFn: rK,
  isThenable: nK,
  setImmediate: sP,
  asap: iK,
  isIterable: sK
};
function bn(r, e, t, n, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = r, this.name = "AxiosError", e && (this.code = e), t && (this.config = t), n && (this.request = n), i && (this.response = i, this.status = i.status ? i.status : null);
}
Ut.inherits(bn, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: Ut.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const oP = bn.prototype, aP = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((r) => {
  aP[r] = {
    value: r
  };
});
Object.defineProperties(bn, aP);
Object.defineProperty(oP, "isAxiosError", {
  value: !0
});
bn.from = (r, e, t, n, i, s) => {
  const l = Object.create(oP);
  return Ut.toFlatObject(r, l, function(d) {
    return d !== Error.prototype;
  }, (o) => o !== "isAxiosError"), bn.call(l, r.message, e, t, n, i), l.cause = r, l.name = r.name, s && Object.assign(l, s), l;
};
const oK = null;
function Zv(r) {
  return Ut.isPlainObject(r) || Ut.isArray(r);
}
function lP(r) {
  return Ut.endsWith(r, "[]") ? r.slice(0, -2) : r;
}
function yE(r, e, t) {
  return r ? r.concat(e).map(function(i, s) {
    return i = lP(i), !t && s ? "[" + i + "]" : i;
  }).join(t ? "." : "") : e;
}
function aK(r) {
  return Ut.isArray(r) && !r.some(Zv);
}
const lK = Ut.toFlatObject(Ut, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function t0(r, e, t) {
  if (!Ut.isObject(r))
    throw new TypeError("target must be an object");
  e = e || new FormData(), t = Ut.toFlatObject(t, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(U, V) {
    return !Ut.isUndefined(V[U]);
  });
  const n = t.metaTokens, i = t.visitor || b, s = t.dots, l = t.indexes, d = (t.Blob || typeof Blob < "u" && Blob) && Ut.isSpecCompliantForm(e);
  if (!Ut.isFunction(i))
    throw new TypeError("visitor must be a function");
  function m(k) {
    if (k === null) return "";
    if (Ut.isDate(k))
      return k.toISOString();
    if (Ut.isBoolean(k))
      return k.toString();
    if (!d && Ut.isBlob(k))
      throw new bn("Blob is not supported. Use a Buffer instead.");
    return Ut.isArrayBuffer(k) || Ut.isTypedArray(k) ? d && typeof Blob == "function" ? new Blob([k]) : Buffer.from(k) : k;
  }
  function b(k, U, V) {
    let q = k;
    if (k && !V && typeof k == "object") {
      if (Ut.endsWith(U, "{}"))
        U = n ? U : U.slice(0, -2), k = JSON.stringify(k);
      else if (Ut.isArray(k) && aK(k) || (Ut.isFileList(k) || Ut.endsWith(U, "[]")) && (q = Ut.toArray(k)))
        return U = lP(U), q.forEach(function(re, Z) {
          !(Ut.isUndefined(re) || re === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            l === !0 ? yE([U], Z, s) : l === null ? U : U + "[]",
            m(re)
          );
        }), !1;
    }
    return Zv(k) ? !0 : (e.append(yE(V, U, s), m(k)), !1);
  }
  const A = [], M = Object.assign(lK, {
    defaultVisitor: b,
    convertValue: m,
    isVisitable: Zv
  });
  function E(k, U) {
    if (!Ut.isUndefined(k)) {
      if (A.indexOf(k) !== -1)
        throw Error("Circular reference detected in " + U.join("."));
      A.push(k), Ut.forEach(k, function(q, Y) {
        (!(Ut.isUndefined(q) || q === null) && i.call(e, q, Ut.isString(Y) ? Y.trim() : Y, U, M)) === !0 && E(q, U ? U.concat(Y) : [Y]);
      }), A.pop();
    }
  }
  if (!Ut.isObject(r))
    throw new TypeError("data must be an object");
  return E(r), e;
}
function bE(r) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(r).replace(/[!'()~]|%20|%00/g, function(n) {
    return e[n];
  });
}
function Ex(r, e) {
  this._pairs = [], r && t0(r, this, e);
}
const cP = Ex.prototype;
cP.append = function(e, t) {
  this._pairs.push([e, t]);
};
cP.toString = function(e) {
  const t = e ? function(n) {
    return e.call(this, n, bE);
  } : bE;
  return this._pairs.map(function(i) {
    return t(i[0]) + "=" + t(i[1]);
  }, "").join("&");
};
function cK(r) {
  return encodeURIComponent(r).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function uP(r, e, t) {
  if (!e)
    return r;
  const n = t && t.encode || cK;
  Ut.isFunction(t) && (t = {
    serialize: t
  });
  const i = t && t.serialize;
  let s;
  if (i ? s = i(e, t) : s = Ut.isURLSearchParams(e) ? e.toString() : new Ex(e, t).toString(n), s) {
    const l = r.indexOf("#");
    l !== -1 && (r = r.slice(0, l)), r += (r.indexOf("?") === -1 ? "?" : "&") + s;
  }
  return r;
}
class vE {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, t, n) {
    return this.handlers.push({
      fulfilled: e,
      rejected: t,
      synchronous: n ? n.synchronous : !1,
      runWhen: n ? n.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    Ut.forEach(this.handlers, function(n) {
      n !== null && e(n);
    });
  }
}
const hP = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, uK = typeof URLSearchParams < "u" ? URLSearchParams : Ex, hK = typeof FormData < "u" ? FormData : null, fK = typeof Blob < "u" ? Blob : null, dK = {
  isBrowser: !0,
  classes: {
    URLSearchParams: uK,
    FormData: hK,
    Blob: fK
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, Cx = typeof window < "u" && typeof document < "u", Yv = typeof navigator == "object" && navigator || void 0, pK = Cx && (!Yv || ["ReactNative", "NativeScript", "NS"].indexOf(Yv.product) < 0), gK = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", mK = Cx && window.location.href || "http://localhost", _K = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: Cx,
  hasStandardBrowserEnv: pK,
  hasStandardBrowserWebWorkerEnv: gK,
  navigator: Yv,
  origin: mK
}, Symbol.toStringTag, { value: "Module" })), na = {
  ..._K,
  ...dK
};
function yK(r, e) {
  return t0(r, new na.classes.URLSearchParams(), Object.assign({
    visitor: function(t, n, i, s) {
      return na.isNode && Ut.isBuffer(t) ? (this.append(n, t.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments);
    }
  }, e));
}
function bK(r) {
  return Ut.matchAll(/\w+|\[(\w*)]/g, r).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function vK(r) {
  const e = {}, t = Object.keys(r);
  let n;
  const i = t.length;
  let s;
  for (n = 0; n < i; n++)
    s = t[n], e[s] = r[s];
  return e;
}
function fP(r) {
  function e(t, n, i, s) {
    let l = t[s++];
    if (l === "__proto__") return !0;
    const o = Number.isFinite(+l), d = s >= t.length;
    return l = !l && Ut.isArray(i) ? i.length : l, d ? (Ut.hasOwnProp(i, l) ? i[l] = [i[l], n] : i[l] = n, !o) : ((!i[l] || !Ut.isObject(i[l])) && (i[l] = []), e(t, n, i[l], s) && Ut.isArray(i[l]) && (i[l] = vK(i[l])), !o);
  }
  if (Ut.isFormData(r) && Ut.isFunction(r.entries)) {
    const t = {};
    return Ut.forEachEntry(r, (n, i) => {
      e(bK(n), i, t, 0);
    }), t;
  }
  return null;
}
function xK(r, e, t) {
  if (Ut.isString(r))
    try {
      return (e || JSON.parse)(r), Ut.trim(r);
    } catch (n) {
      if (n.name !== "SyntaxError")
        throw n;
    }
  return (t || JSON.stringify)(r);
}
const tm = {
  transitional: hP,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, t) {
    const n = t.getContentType() || "", i = n.indexOf("application/json") > -1, s = Ut.isObject(e);
    if (s && Ut.isHTMLForm(e) && (e = new FormData(e)), Ut.isFormData(e))
      return i ? JSON.stringify(fP(e)) : e;
    if (Ut.isArrayBuffer(e) || Ut.isBuffer(e) || Ut.isStream(e) || Ut.isFile(e) || Ut.isBlob(e) || Ut.isReadableStream(e))
      return e;
    if (Ut.isArrayBufferView(e))
      return e.buffer;
    if (Ut.isURLSearchParams(e))
      return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let o;
    if (s) {
      if (n.indexOf("application/x-www-form-urlencoded") > -1)
        return yK(e, this.formSerializer).toString();
      if ((o = Ut.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
        const d = this.env && this.env.FormData;
        return t0(o ? {
          "files[]": e
        } : e, d && new d(), this.formSerializer);
      }
    }
    return s || i ? (t.setContentType("application/json", !1), xK(e)) : e;
  }],
  transformResponse: [function(e) {
    const t = this.transitional || tm.transitional, n = t && t.forcedJSONParsing, i = this.responseType === "json";
    if (Ut.isResponse(e) || Ut.isReadableStream(e))
      return e;
    if (e && Ut.isString(e) && (n && !this.responseType || i)) {
      const l = !(t && t.silentJSONParsing) && i;
      try {
        return JSON.parse(e);
      } catch (o) {
        if (l)
          throw o.name === "SyntaxError" ? bn.from(o, bn.ERR_BAD_RESPONSE, this, null, this.response) : o;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: na.classes.FormData,
    Blob: na.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
Ut.forEach(["delete", "get", "head", "post", "put", "patch"], (r) => {
  tm.headers[r] = {};
});
const wK = Ut.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), AK = (r) => {
  const e = {};
  let t, n, i;
  return r && r.split(`
`).forEach(function(l) {
    i = l.indexOf(":"), t = l.substring(0, i).trim().toLowerCase(), n = l.substring(i + 1).trim(), !(!t || e[t] && wK[t]) && (t === "set-cookie" ? e[t] ? e[t].push(n) : e[t] = [n] : e[t] = e[t] ? e[t] + ", " + n : n);
  }), e;
}, xE = Symbol("internals");
function ig(r) {
  return r && String(r).trim().toLowerCase();
}
function C_(r) {
  return r === !1 || r == null ? r : Ut.isArray(r) ? r.map(C_) : String(r);
}
function TK(r) {
  const e = /* @__PURE__ */ Object.create(null), t = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let n;
  for (; n = t.exec(r); )
    e[n[1]] = n[2];
  return e;
}
const SK = (r) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(r.trim());
function A1(r, e, t, n, i) {
  if (Ut.isFunction(n))
    return n.call(this, e, t);
  if (i && (e = t), !!Ut.isString(e)) {
    if (Ut.isString(n))
      return e.indexOf(n) !== -1;
    if (Ut.isRegExp(n))
      return n.test(e);
  }
}
function EK(r) {
  return r.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, t, n) => t.toUpperCase() + n);
}
function CK(r, e) {
  const t = Ut.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((n) => {
    Object.defineProperty(r, n + t, {
      value: function(i, s, l) {
        return this[n].call(this, e, i, s, l);
      },
      configurable: !0
    });
  });
}
let $a = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, t, n) {
    const i = this;
    function s(o, d, m) {
      const b = ig(d);
      if (!b)
        throw new Error("header name must be a non-empty string");
      const A = Ut.findKey(i, b);
      (!A || i[A] === void 0 || m === !0 || m === void 0 && i[A] !== !1) && (i[A || d] = C_(o));
    }
    const l = (o, d) => Ut.forEach(o, (m, b) => s(m, b, d));
    if (Ut.isPlainObject(e) || e instanceof this.constructor)
      l(e, t);
    else if (Ut.isString(e) && (e = e.trim()) && !SK(e))
      l(AK(e), t);
    else if (Ut.isObject(e) && Ut.isIterable(e)) {
      let o = {}, d, m;
      for (const b of e) {
        if (!Ut.isArray(b))
          throw TypeError("Object iterator must return a key-value pair");
        o[m = b[0]] = (d = o[m]) ? Ut.isArray(d) ? [...d, b[1]] : [d, b[1]] : b[1];
      }
      l(o, t);
    } else
      e != null && s(t, e, n);
    return this;
  }
  get(e, t) {
    if (e = ig(e), e) {
      const n = Ut.findKey(this, e);
      if (n) {
        const i = this[n];
        if (!t)
          return i;
        if (t === !0)
          return TK(i);
        if (Ut.isFunction(t))
          return t.call(this, i, n);
        if (Ut.isRegExp(t))
          return t.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, t) {
    if (e = ig(e), e) {
      const n = Ut.findKey(this, e);
      return !!(n && this[n] !== void 0 && (!t || A1(this, this[n], n, t)));
    }
    return !1;
  }
  delete(e, t) {
    const n = this;
    let i = !1;
    function s(l) {
      if (l = ig(l), l) {
        const o = Ut.findKey(n, l);
        o && (!t || A1(n, n[o], o, t)) && (delete n[o], i = !0);
      }
    }
    return Ut.isArray(e) ? e.forEach(s) : s(e), i;
  }
  clear(e) {
    const t = Object.keys(this);
    let n = t.length, i = !1;
    for (; n--; ) {
      const s = t[n];
      (!e || A1(this, this[s], s, e, !0)) && (delete this[s], i = !0);
    }
    return i;
  }
  normalize(e) {
    const t = this, n = {};
    return Ut.forEach(this, (i, s) => {
      const l = Ut.findKey(n, s);
      if (l) {
        t[l] = C_(i), delete t[s];
        return;
      }
      const o = e ? EK(s) : String(s).trim();
      o !== s && delete t[s], t[o] = C_(i), n[o] = !0;
    }), this;
  }
  concat() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.constructor.concat(this, ...t);
  }
  toJSON(e) {
    const t = /* @__PURE__ */ Object.create(null);
    return Ut.forEach(this, (n, i) => {
      n != null && n !== !1 && (t[i] = e && Ut.isArray(n) ? n.join(", ") : n);
    }), t;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map((e) => {
      let [t, n] = e;
      return t + ": " + n;
    }).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e) {
    const t = new this(e);
    for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++)
      i[s - 1] = arguments[s];
    return i.forEach((l) => t.set(l)), t;
  }
  static accessor(e) {
    const n = (this[xE] = this[xE] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function s(l) {
      const o = ig(l);
      n[o] || (CK(i, l), n[o] = !0);
    }
    return Ut.isArray(e) ? e.forEach(s) : s(e), this;
  }
};
$a.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
Ut.reduceDescriptors($a.prototype, (r, e) => {
  let {
    value: t
  } = r, n = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => t,
    set(i) {
      this[n] = i;
    }
  };
});
Ut.freezeMethods($a);
function T1(r, e) {
  const t = this || tm, n = e || t, i = $a.from(n.headers);
  let s = n.data;
  return Ut.forEach(r, function(o) {
    s = o.call(t, s, i.normalize(), e ? e.status : void 0);
  }), i.normalize(), s;
}
function dP(r) {
  return !!(r && r.__CANCEL__);
}
function wp(r, e, t) {
  bn.call(this, r ?? "canceled", bn.ERR_CANCELED, e, t), this.name = "CanceledError";
}
Ut.inherits(wp, bn, {
  __CANCEL__: !0
});
function pP(r, e, t) {
  const n = t.config.validateStatus;
  !t.status || !n || n(t.status) ? r(t) : e(new bn("Request failed with status code " + t.status, [bn.ERR_BAD_REQUEST, bn.ERR_BAD_RESPONSE][Math.floor(t.status / 100) - 4], t.config, t.request, t));
}
function IK(r) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(r);
  return e && e[1] || "";
}
function MK(r, e) {
  r = r || 10;
  const t = new Array(r), n = new Array(r);
  let i = 0, s = 0, l;
  return e = e !== void 0 ? e : 1e3, function(d) {
    const m = Date.now(), b = n[s];
    l || (l = m), t[i] = d, n[i] = m;
    let A = s, M = 0;
    for (; A !== i; )
      M += t[A++], A = A % r;
    if (i = (i + 1) % r, i === s && (s = (s + 1) % r), m - l < e)
      return;
    const E = b && m - b;
    return E ? Math.round(M * 1e3 / E) : void 0;
  };
}
function PK(r, e) {
  let t = 0, n = 1e3 / e, i, s;
  const l = function(m) {
    t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Date.now(), i = null, s && (clearTimeout(s), s = null), r.apply(null, m);
  };
  return [function() {
    const m = Date.now(), b = m - t;
    for (var A = arguments.length, M = new Array(A), E = 0; E < A; E++)
      M[E] = arguments[E];
    b >= n ? l(M, m) : (i = M, s || (s = setTimeout(() => {
      s = null, l(i);
    }, n - b)));
  }, () => i && l(i)];
}
const gy = function(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 3, n = 0;
  const i = MK(50, 250);
  return PK((s) => {
    const l = s.loaded, o = s.lengthComputable ? s.total : void 0, d = l - n, m = i(d), b = l <= o;
    n = l;
    const A = {
      loaded: l,
      total: o,
      progress: o ? l / o : void 0,
      bytes: d,
      rate: m || void 0,
      estimated: m && o && b ? (o - l) / m : void 0,
      event: s,
      lengthComputable: o != null,
      [e ? "download" : "upload"]: !0
    };
    r(A);
  }, t);
}, wE = (r, e) => {
  const t = r != null;
  return [(n) => e[0]({
    lengthComputable: t,
    total: r,
    loaded: n
  }), e[1]];
}, AE = (r) => function() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return Ut.asap(() => r(...t));
}, RK = na.hasStandardBrowserEnv ? /* @__PURE__ */ ((r, e) => (t) => (t = new URL(t, na.origin), r.protocol === t.protocol && r.host === t.host && (e || r.port === t.port)))(new URL(na.origin), na.navigator && /(msie|trident)/i.test(na.navigator.userAgent)) : () => !0, BK = na.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(r, e, t, n, i, s) {
      const l = [r + "=" + encodeURIComponent(e)];
      Ut.isNumber(t) && l.push("expires=" + new Date(t).toGMTString()), Ut.isString(n) && l.push("path=" + n), Ut.isString(i) && l.push("domain=" + i), s === !0 && l.push("secure"), document.cookie = l.join("; ");
    },
    read(r) {
      const e = document.cookie.match(new RegExp("(^|;\\s*)(" + r + ")=([^;]*)"));
      return e ? decodeURIComponent(e[3]) : null;
    },
    remove(r) {
      this.write(r, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function LK(r) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(r);
}
function OK(r, e) {
  return e ? r.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : r;
}
function gP(r, e, t) {
  let n = !LK(e);
  return r && (n || t == !1) ? OK(r, e) : e;
}
const TE = (r) => r instanceof $a ? {
  ...r
} : r;
function Hf(r, e) {
  e = e || {};
  const t = {};
  function n(m, b, A, M) {
    return Ut.isPlainObject(m) && Ut.isPlainObject(b) ? Ut.merge.call({
      caseless: M
    }, m, b) : Ut.isPlainObject(b) ? Ut.merge({}, b) : Ut.isArray(b) ? b.slice() : b;
  }
  function i(m, b, A, M) {
    if (Ut.isUndefined(b)) {
      if (!Ut.isUndefined(m))
        return n(void 0, m, A, M);
    } else return n(m, b, A, M);
  }
  function s(m, b) {
    if (!Ut.isUndefined(b))
      return n(void 0, b);
  }
  function l(m, b) {
    if (Ut.isUndefined(b)) {
      if (!Ut.isUndefined(m))
        return n(void 0, m);
    } else return n(void 0, b);
  }
  function o(m, b, A) {
    if (A in e)
      return n(m, b);
    if (A in r)
      return n(void 0, m);
  }
  const d = {
    url: s,
    method: s,
    data: s,
    baseURL: l,
    transformRequest: l,
    transformResponse: l,
    paramsSerializer: l,
    timeout: l,
    timeoutMessage: l,
    withCredentials: l,
    withXSRFToken: l,
    adapter: l,
    responseType: l,
    xsrfCookieName: l,
    xsrfHeaderName: l,
    onUploadProgress: l,
    onDownloadProgress: l,
    decompress: l,
    maxContentLength: l,
    maxBodyLength: l,
    beforeRedirect: l,
    transport: l,
    httpAgent: l,
    httpsAgent: l,
    cancelToken: l,
    socketPath: l,
    responseEncoding: l,
    validateStatus: o,
    headers: (m, b, A) => i(TE(m), TE(b), A, !0)
  };
  return Ut.forEach(Object.keys(Object.assign({}, r, e)), function(b) {
    const A = d[b] || i, M = A(r[b], e[b], b);
    Ut.isUndefined(M) && A !== o || (t[b] = M);
  }), t;
}
const mP = (r) => {
  const e = Hf({}, r);
  let {
    data: t,
    withXSRFToken: n,
    xsrfHeaderName: i,
    xsrfCookieName: s,
    headers: l,
    auth: o
  } = e;
  e.headers = l = $a.from(l), e.url = uP(gP(e.baseURL, e.url, e.allowAbsoluteUrls), r.params, r.paramsSerializer), o && l.set("Authorization", "Basic " + btoa((o.username || "") + ":" + (o.password ? unescape(encodeURIComponent(o.password)) : "")));
  let d;
  if (Ut.isFormData(t)) {
    if (na.hasStandardBrowserEnv || na.hasStandardBrowserWebWorkerEnv)
      l.setContentType(void 0);
    else if ((d = l.getContentType()) !== !1) {
      const [m, ...b] = d ? d.split(";").map((A) => A.trim()).filter(Boolean) : [];
      l.setContentType([m || "multipart/form-data", ...b].join("; "));
    }
  }
  if (na.hasStandardBrowserEnv && (n && Ut.isFunction(n) && (n = n(e)), n || n !== !1 && RK(e.url))) {
    const m = i && s && BK.read(s);
    m && l.set(i, m);
  }
  return e;
}, kK = typeof XMLHttpRequest < "u", NK = kK && function(r) {
  return new Promise(function(t, n) {
    const i = mP(r);
    let s = i.data;
    const l = $a.from(i.headers).normalize();
    let {
      responseType: o,
      onUploadProgress: d,
      onDownloadProgress: m
    } = i, b, A, M, E, k;
    function U() {
      E && E(), k && k(), i.cancelToken && i.cancelToken.unsubscribe(b), i.signal && i.signal.removeEventListener("abort", b);
    }
    let V = new XMLHttpRequest();
    V.open(i.method.toUpperCase(), i.url, !0), V.timeout = i.timeout;
    function q() {
      if (!V)
        return;
      const re = $a.from("getAllResponseHeaders" in V && V.getAllResponseHeaders()), K = {
        data: !o || o === "text" || o === "json" ? V.responseText : V.response,
        status: V.status,
        statusText: V.statusText,
        headers: re,
        config: r,
        request: V
      };
      pP(function(be) {
        t(be), U();
      }, function(be) {
        n(be), U();
      }, K), V = null;
    }
    "onloadend" in V ? V.onloadend = q : V.onreadystatechange = function() {
      !V || V.readyState !== 4 || V.status === 0 && !(V.responseURL && V.responseURL.indexOf("file:") === 0) || setTimeout(q);
    }, V.onabort = function() {
      V && (n(new bn("Request aborted", bn.ECONNABORTED, r, V)), V = null);
    }, V.onerror = function() {
      n(new bn("Network Error", bn.ERR_NETWORK, r, V)), V = null;
    }, V.ontimeout = function() {
      let Z = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
      const K = i.transitional || hP;
      i.timeoutErrorMessage && (Z = i.timeoutErrorMessage), n(new bn(Z, K.clarifyTimeoutError ? bn.ETIMEDOUT : bn.ECONNABORTED, r, V)), V = null;
    }, s === void 0 && l.setContentType(null), "setRequestHeader" in V && Ut.forEach(l.toJSON(), function(Z, K) {
      V.setRequestHeader(K, Z);
    }), Ut.isUndefined(i.withCredentials) || (V.withCredentials = !!i.withCredentials), o && o !== "json" && (V.responseType = i.responseType), m && ([M, k] = gy(m, !0), V.addEventListener("progress", M)), d && V.upload && ([A, E] = gy(d), V.upload.addEventListener("progress", A), V.upload.addEventListener("loadend", E)), (i.cancelToken || i.signal) && (b = (re) => {
      V && (n(!re || re.type ? new wp(null, r, V) : re), V.abort(), V = null);
    }, i.cancelToken && i.cancelToken.subscribe(b), i.signal && (i.signal.aborted ? b() : i.signal.addEventListener("abort", b)));
    const Y = IK(i.url);
    if (Y && na.protocols.indexOf(Y) === -1) {
      n(new bn("Unsupported protocol " + Y + ":", bn.ERR_BAD_REQUEST, r));
      return;
    }
    V.send(s || null);
  });
}, DK = (r, e) => {
  const {
    length: t
  } = r = r ? r.filter(Boolean) : [];
  if (e || t) {
    let n = new AbortController(), i;
    const s = function(m) {
      if (!i) {
        i = !0, o();
        const b = m instanceof Error ? m : this.reason;
        n.abort(b instanceof bn ? b : new wp(b instanceof Error ? b.message : b));
      }
    };
    let l = e && setTimeout(() => {
      l = null, s(new bn(`timeout ${e} of ms exceeded`, bn.ETIMEDOUT));
    }, e);
    const o = () => {
      r && (l && clearTimeout(l), l = null, r.forEach((m) => {
        m.unsubscribe ? m.unsubscribe(s) : m.removeEventListener("abort", s);
      }), r = null);
    };
    r.forEach((m) => m.addEventListener("abort", s));
    const {
      signal: d
    } = n;
    return d.unsubscribe = () => Ut.asap(o), d;
  }
}, FK = function* (r, e) {
  let t = r.byteLength;
  if (t < e) {
    yield r;
    return;
  }
  let n = 0, i;
  for (; n < t; )
    i = n + e, yield r.slice(n, i), n = i;
}, UK = async function* (r, e) {
  for await (const t of zK(r))
    yield* FK(t, e);
}, zK = async function* (r) {
  if (r[Symbol.asyncIterator]) {
    yield* r;
    return;
  }
  const e = r.getReader();
  try {
    for (; ; ) {
      const {
        done: t,
        value: n
      } = await e.read();
      if (t)
        break;
      yield n;
    }
  } finally {
    await e.cancel();
  }
}, SE = (r, e, t, n) => {
  const i = UK(r, e);
  let s = 0, l, o = (d) => {
    l || (l = !0, n && n(d));
  };
  return new ReadableStream({
    async pull(d) {
      try {
        const {
          done: m,
          value: b
        } = await i.next();
        if (m) {
          o(), d.close();
          return;
        }
        let A = b.byteLength;
        if (t) {
          let M = s += A;
          t(M);
        }
        d.enqueue(new Uint8Array(b));
      } catch (m) {
        throw o(m), m;
      }
    },
    cancel(d) {
      return o(d), i.return();
    }
  }, {
    highWaterMark: 2
  });
}, r0 = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", _P = r0 && typeof ReadableStream == "function", jK = r0 && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((r) => (e) => r.encode(e))(new TextEncoder()) : async (r) => new Uint8Array(await new Response(r).arrayBuffer())), yP = function(r) {
  try {
    for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
      t[n - 1] = arguments[n];
    return !!r(...t);
  } catch {
    return !1;
  }
}, VK = _P && yP(() => {
  let r = !1;
  const e = new Request(na.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return r = !0, "half";
    }
  }).headers.has("Content-Type");
  return r && !e;
}), EE = 64 * 1024, Kv = _P && yP(() => Ut.isReadableStream(new Response("").body)), my = {
  stream: Kv && ((r) => r.body)
};
r0 && ((r) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e) => {
    !my[e] && (my[e] = Ut.isFunction(r[e]) ? (t) => t[e]() : (t, n) => {
      throw new bn(`Response type '${e}' is not supported`, bn.ERR_NOT_SUPPORT, n);
    });
  });
})(new Response());
const $K = async (r) => {
  if (r == null)
    return 0;
  if (Ut.isBlob(r))
    return r.size;
  if (Ut.isSpecCompliantForm(r))
    return (await new Request(na.origin, {
      method: "POST",
      body: r
    }).arrayBuffer()).byteLength;
  if (Ut.isArrayBufferView(r) || Ut.isArrayBuffer(r))
    return r.byteLength;
  if (Ut.isURLSearchParams(r) && (r = r + ""), Ut.isString(r))
    return (await jK(r)).byteLength;
}, qK = async (r, e) => {
  const t = Ut.toFiniteNumber(r.getContentLength());
  return t ?? $K(e);
}, GK = r0 && (async (r) => {
  let {
    url: e,
    method: t,
    data: n,
    signal: i,
    cancelToken: s,
    timeout: l,
    onDownloadProgress: o,
    onUploadProgress: d,
    responseType: m,
    headers: b,
    withCredentials: A = "same-origin",
    fetchOptions: M
  } = mP(r);
  m = m ? (m + "").toLowerCase() : "text";
  let E = DK([i, s && s.toAbortSignal()], l), k;
  const U = E && E.unsubscribe && (() => {
    E.unsubscribe();
  });
  let V;
  try {
    if (d && VK && t !== "get" && t !== "head" && (V = await qK(b, n)) !== 0) {
      let K = new Request(e, {
        method: "POST",
        body: n,
        duplex: "half"
      }), ie;
      if (Ut.isFormData(n) && (ie = K.headers.get("content-type")) && b.setContentType(ie), K.body) {
        const [be, he] = wE(V, gy(AE(d)));
        n = SE(K.body, EE, be, he);
      }
    }
    Ut.isString(A) || (A = A ? "include" : "omit");
    const q = "credentials" in Request.prototype;
    k = new Request(e, {
      ...M,
      signal: E,
      method: t.toUpperCase(),
      headers: b.normalize().toJSON(),
      body: n,
      duplex: "half",
      credentials: q ? A : void 0
    });
    let Y = await fetch(k, M);
    const re = Kv && (m === "stream" || m === "response");
    if (Kv && (o || re && U)) {
      const K = {};
      ["status", "statusText", "headers"].forEach((Be) => {
        K[Be] = Y[Be];
      });
      const ie = Ut.toFiniteNumber(Y.headers.get("content-length")), [be, he] = o && wE(ie, gy(AE(o), !0)) || [];
      Y = new Response(SE(Y.body, EE, be, () => {
        he && he(), U && U();
      }), K);
    }
    m = m || "text";
    let Z = await my[Ut.findKey(my, m) || "text"](Y, r);
    return !re && U && U(), await new Promise((K, ie) => {
      pP(K, ie, {
        data: Z,
        headers: $a.from(Y.headers),
        status: Y.status,
        statusText: Y.statusText,
        config: r,
        request: k
      });
    });
  } catch (q) {
    throw U && U(), q && q.name === "TypeError" && /Load failed|fetch/i.test(q.message) ? Object.assign(new bn("Network Error", bn.ERR_NETWORK, r, k), {
      cause: q.cause || q
    }) : bn.from(q, q && q.code, r, k);
  }
}), Jv = {
  http: oK,
  xhr: NK,
  fetch: GK
};
Ut.forEach(Jv, (r, e) => {
  if (r) {
    try {
      Object.defineProperty(r, "name", {
        value: e
      });
    } catch {
    }
    Object.defineProperty(r, "adapterName", {
      value: e
    });
  }
});
const CE = (r) => `- ${r}`, HK = (r) => Ut.isFunction(r) || r === null || r === !1, bP = {
  getAdapter: (r) => {
    r = Ut.isArray(r) ? r : [r];
    const {
      length: e
    } = r;
    let t, n;
    const i = {};
    for (let s = 0; s < e; s++) {
      t = r[s];
      let l;
      if (n = t, !HK(t) && (n = Jv[(l = String(t)).toLowerCase()], n === void 0))
        throw new bn(`Unknown adapter '${l}'`);
      if (n)
        break;
      i[l || "#" + s] = n;
    }
    if (!n) {
      const s = Object.entries(i).map((o) => {
        let [d, m] = o;
        return `adapter ${d} ` + (m === !1 ? "is not supported by the environment" : "is not available in the build");
      });
      let l = e ? s.length > 1 ? `since :
` + s.map(CE).join(`
`) : " " + CE(s[0]) : "as no adapter specified";
      throw new bn("There is no suitable adapter to dispatch the request " + l, "ERR_NOT_SUPPORT");
    }
    return n;
  },
  adapters: Jv
};
function S1(r) {
  if (r.cancelToken && r.cancelToken.throwIfRequested(), r.signal && r.signal.aborted)
    throw new wp(null, r);
}
function IE(r) {
  return S1(r), r.headers = $a.from(r.headers), r.data = T1.call(r, r.transformRequest), ["post", "put", "patch"].indexOf(r.method) !== -1 && r.headers.setContentType("application/x-www-form-urlencoded", !1), bP.getAdapter(r.adapter || tm.adapter)(r).then(function(n) {
    return S1(r), n.data = T1.call(r, r.transformResponse, n), n.headers = $a.from(n.headers), n;
  }, function(n) {
    return dP(n) || (S1(r), n && n.response && (n.response.data = T1.call(r, r.transformResponse, n.response), n.response.headers = $a.from(n.response.headers))), Promise.reject(n);
  });
}
const vP = "1.10.0", n0 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((r, e) => {
  n0[r] = function(n) {
    return typeof n === r || "a" + (e < 1 ? "n " : " ") + r;
  };
});
const ME = {};
n0.transitional = function(e, t, n) {
  function i(s, l) {
    return "[Axios v" + vP + "] Transitional option '" + s + "'" + l + (n ? ". " + n : "");
  }
  return (s, l, o) => {
    if (e === !1)
      throw new bn(i(l, " has been removed" + (t ? " in " + t : "")), bn.ERR_DEPRECATED);
    return t && !ME[l] && (ME[l] = !0, console.warn(i(l, " has been deprecated since v" + t + " and will be removed in the near future"))), e ? e(s, l, o) : !0;
  };
};
n0.spelling = function(e) {
  return (t, n) => (console.warn(`${n} is likely a misspelling of ${e}`), !0);
};
function WK(r, e, t) {
  if (typeof r != "object")
    throw new bn("options must be an object", bn.ERR_BAD_OPTION_VALUE);
  const n = Object.keys(r);
  let i = n.length;
  for (; i-- > 0; ) {
    const s = n[i], l = e[s];
    if (l) {
      const o = r[s], d = o === void 0 || l(o, s, r);
      if (d !== !0)
        throw new bn("option " + s + " must be " + d, bn.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (t !== !0)
      throw new bn("Unknown option " + s, bn.ERR_BAD_OPTION);
  }
}
const I_ = {
  assertOptions: WK,
  validators: n0
}, lu = I_.validators;
let zf = class {
  constructor(e) {
    this.defaults = e || {}, this.interceptors = {
      request: new vE(),
      response: new vE()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, t) {
    try {
      return await this._request(e, t);
    } catch (n) {
      if (n instanceof Error) {
        let i = {};
        Error.captureStackTrace ? Error.captureStackTrace(i) : i = new Error();
        const s = i.stack ? i.stack.replace(/^.+\n/, "") : "";
        try {
          n.stack ? s && !String(n.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + s) : n.stack = s;
        } catch {
        }
      }
      throw n;
    }
  }
  _request(e, t) {
    typeof e == "string" ? (t = t || {}, t.url = e) : t = e || {}, t = Hf(this.defaults, t);
    const {
      transitional: n,
      paramsSerializer: i,
      headers: s
    } = t;
    n !== void 0 && I_.assertOptions(n, {
      silentJSONParsing: lu.transitional(lu.boolean),
      forcedJSONParsing: lu.transitional(lu.boolean),
      clarifyTimeoutError: lu.transitional(lu.boolean)
    }, !1), i != null && (Ut.isFunction(i) ? t.paramsSerializer = {
      serialize: i
    } : I_.assertOptions(i, {
      encode: lu.function,
      serialize: lu.function
    }, !0)), t.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : t.allowAbsoluteUrls = !0), I_.assertOptions(t, {
      baseUrl: lu.spelling("baseURL"),
      withXsrfToken: lu.spelling("withXSRFToken")
    }, !0), t.method = (t.method || this.defaults.method || "get").toLowerCase();
    let l = s && Ut.merge(s.common, s[t.method]);
    s && Ut.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (k) => {
      delete s[k];
    }), t.headers = $a.concat(l, s);
    const o = [];
    let d = !0;
    this.interceptors.request.forEach(function(U) {
      typeof U.runWhen == "function" && U.runWhen(t) === !1 || (d = d && U.synchronous, o.unshift(U.fulfilled, U.rejected));
    });
    const m = [];
    this.interceptors.response.forEach(function(U) {
      m.push(U.fulfilled, U.rejected);
    });
    let b, A = 0, M;
    if (!d) {
      const k = [IE.bind(this), void 0];
      for (k.unshift.apply(k, o), k.push.apply(k, m), M = k.length, b = Promise.resolve(t); A < M; )
        b = b.then(k[A++], k[A++]);
      return b;
    }
    M = o.length;
    let E = t;
    for (A = 0; A < M; ) {
      const k = o[A++], U = o[A++];
      try {
        E = k(E);
      } catch (V) {
        U.call(this, V);
        break;
      }
    }
    try {
      b = IE.call(this, E);
    } catch (k) {
      return Promise.reject(k);
    }
    for (A = 0, M = m.length; A < M; )
      b = b.then(m[A++], m[A++]);
    return b;
  }
  getUri(e) {
    e = Hf(this.defaults, e);
    const t = gP(e.baseURL, e.url, e.allowAbsoluteUrls);
    return uP(t, e.params, e.paramsSerializer);
  }
};
Ut.forEach(["delete", "get", "head", "options"], function(e) {
  zf.prototype[e] = function(t, n) {
    return this.request(Hf(n || {}, {
      method: e,
      url: t,
      data: (n || {}).data
    }));
  };
});
Ut.forEach(["post", "put", "patch"], function(e) {
  function t(n) {
    return function(s, l, o) {
      return this.request(Hf(o || {}, {
        method: e,
        headers: n ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: s,
        data: l
      }));
    };
  }
  zf.prototype[e] = t(), zf.prototype[e + "Form"] = t(!0);
});
let XK = class xP {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let t;
    this.promise = new Promise(function(s) {
      t = s;
    });
    const n = this;
    this.promise.then((i) => {
      if (!n._listeners) return;
      let s = n._listeners.length;
      for (; s-- > 0; )
        n._listeners[s](i);
      n._listeners = null;
    }), this.promise.then = (i) => {
      let s;
      const l = new Promise((o) => {
        n.subscribe(o), s = o;
      }).then(i);
      return l.cancel = function() {
        n.unsubscribe(s);
      }, l;
    }, e(function(s, l, o) {
      n.reason || (n.reason = new wp(s, l, o), t(n.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const t = this._listeners.indexOf(e);
    t !== -1 && this._listeners.splice(t, 1);
  }
  toAbortSignal() {
    const e = new AbortController(), t = (n) => {
      e.abort(n);
    };
    return this.subscribe(t), e.signal.unsubscribe = () => this.unsubscribe(t), e.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new xP(function(i) {
        e = i;
      }),
      cancel: e
    };
  }
};
function ZK(r) {
  return function(t) {
    return r.apply(null, t);
  };
}
function YK(r) {
  return Ut.isObject(r) && r.isAxiosError === !0;
}
const Qv = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(Qv).forEach((r) => {
  let [e, t] = r;
  Qv[t] = e;
});
function wP(r) {
  const e = new zf(r), t = JM(zf.prototype.request, e);
  return Ut.extend(t, zf.prototype, e, {
    allOwnKeys: !0
  }), Ut.extend(t, e, null, {
    allOwnKeys: !0
  }), t.create = function(i) {
    return wP(Hf(r, i));
  }, t;
}
const Ms = wP(tm);
Ms.Axios = zf;
Ms.CanceledError = wp;
Ms.CancelToken = XK;
Ms.isCancel = dP;
Ms.VERSION = vP;
Ms.toFormData = t0;
Ms.AxiosError = bn;
Ms.Cancel = Ms.CanceledError;
Ms.all = function(e) {
  return Promise.all(e);
};
Ms.spread = ZK;
Ms.isAxiosError = YK;
Ms.mergeConfig = Hf;
Ms.AxiosHeaders = $a;
Ms.formToJSON = (r) => fP(Ut.isHTMLForm(r) ? new FormData(r) : r);
Ms.getAdapter = bP.getAdapter;
Ms.HttpStatusCode = Qv;
Ms.default = Ms;
const {
  Axios: wJ,
  AxiosError: AJ,
  CanceledError: TJ,
  isCancel: SJ,
  CancelToken: EJ,
  VERSION: CJ,
  all: IJ,
  Cancel: MJ,
  isAxiosError: PJ,
  spread: RJ,
  toFormData: BJ,
  AxiosHeaders: LJ,
  HttpStatusCode: OJ,
  formToJSON: kJ,
  getAdapter: NJ,
  mergeConfig: DJ
} = Ms, KK = "https://eines.icgc.cat/recursos/mapicgc-gl-js/mapicgc-config.json", JK = 5e3;
class QK {
  static async getConfigICGC() {
    try {
      const e = await Ms.get(KK, {
        timeout: JK
      });
      return e.data ? e.data : (console.log("Resposta sense dades:", e), Bf);
    } catch (e) {
      return e.response ? (console.error("Error de resposta:", e.response.data), console.error("Codi d'estat:", e.response.status)) : e.request ? console.error("No s'ha rebut resposta del servidor:", e.request) : console.error("Error:", e.message), Bf;
    }
  }
}
const eJ = {
  "fill-opacity": ["interpolate", ["exponential", 0.5], ["zoom"], 13.5, 1, 18, 0.4],
  "fill-outline-color": "rgba(0,0, 0, 0)",
  "fill-color": ["interpolate", ["cubic-bezier", 0.5, 1, 1, 1], ["get", "nivell_2"], 0, "#ffffff", 111, "#ffff00", 112, "#ccff33", 113, "#af5b15", 114, "#808000", 115, "#cdcd00", 116, "#ffffcc", 221, "#33cc33", 222, "#66ff33", 223, "#689018", 224, "#967d5f", 225, "#19e61e", 226, "#b4ff9b", 227, "#aaa500", 228, "#c3c3a0", 229, "#00ff9b", 230, "#ff9632", 231, "#282828", 232, "#79797a", 233, "#f5df78", 234, "#3296ff", 341, "#ff007d", 342, "#ff53cd", 343, "#ffa4e2", 344, "#ffc8e2", 345, "#ffb4b4", 346, "#0f3700", 347, "#730055", 348, "#6200c4", 349, "#4a9595", 350, "#ff00f0", 351, "#adaaca", 352, "#ffe6e6", 353, "#67629a", 354, "#4a466e", 355, "#2f2d46", 461, "#6f6fff", 462, "#0000dc", 463, "#000064", 464, "#185f94", 465, "#12466d", 466, "#000080"]
}, tJ = {
  cobertesSol: eJ
}, rJ = "lines", s_ = "labels";
let dl, wf, sg, fs, si, FJ = class {
  /**
   * Constructor for the Map class.
   * @param {Object} options - Options to initialize the map.
   */
  constructor(e) {
    QK.getConfigICGC().then((t) => {
      wf = {
        ...t.Styles
      }, fs = {
        ...t.Layers
      }, sg = {
        ...t.Terrains
      }, si = {
        ...t.defaultOptions
      }, this.initTheMap(e);
    }).catch((t) => {
      console.info("Configuracio per defecte", t), wf = {
        ...Bf.Styles
      }, fs = {
        ...Bf.Layers
      }, sg = {
        ...Bf.Terrains
      }, si = {
        ...Bf.defaultOptions
      }, this.initTheMap(e);
    });
  }
  initTheMap(e) {
    if (!e)
      e = si.mapOptions;
    else
      for (const n in si.mapOptions) {
        let i = [si.mapOptions.center[0], si.mapOptions.center[1]];
        si.mapOptions.center = i, e.hasOwnProperty(n) || (e[n] = si.mapOptions[n]);
      }
    e.maxPitch = 85, e.maplibreLogo = !1, e.attributionControl = !1;
    const t = e.style.includes("https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/");
    t ? (this.map = new po.Map({
      container: e.container,
      center: e.center,
      zoom: e.zoom,
      pitch: e.pitch || 0,
      hash: e.hash || !1,
      style: {
        version: 8,
        sources: {},
        layers: []
      }
    }), this.map.on("load", () => {
      this.map.addSource("raster-source", {
        type: "raster",
        tiles: [e.style],
        // URL del raster
        tileSize: 256
      }), this.map.addLayer({
        id: "raster-layer",
        type: "raster",
        source: "raster-source"
      });
    })) : this.map = new po.Map(e), this.map.on("load", () => {
      if (!t) {
        const n = this.map.getStyle().name, i = e.style;
        this.map.addControl(new gY({
          color: i.indexOf("orto") === -1,
          defaultOptions: si
        }), "bottom-left"), this._dealOrto3dStyle(n);
      }
    });
  }
  /**
   * Add geocoder with customizable options.
   * @function addGeocoderICGC
   * @param {Object} [options={}] - Optional configuration options for the geocoder. Defaults to an empty object.
   * @param {string} [position='top-right'] - Position to add the geocoder control on the map. Defaults to 'top-right'.
   * @returns {Object} - The merged configuration options for the geocoder, including the position.
   *
   */
  addGeocoderICGC() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "top-right";
    try {
      e = {
        ...{
          collapsed: !0,
          marker: !0,
          zoom: 16,
          popup: !0,
          showResultMarkers: !0,
          maplibregl: po,
          showResultsWhileTyping: !0,
          minLength: 2
        },
        ...e
      };
      const i = {
        forwardGeocode: async (l) => {
          const o = [];
          try {
            const d = si.geocoder.peliasUrl1 + encodeURIComponent(l.query) + si.geocoder.peliasUrl2, b = await (await fetch(d)).json();
            for (const A of b.features) {
              const M = A.geometry.coordinates, E = {
                type: "Feature",
                geometry: {
                  type: "Point",
                  coordinates: M
                },
                place_name: A.properties.etiqueta,
                properties: A.properties,
                text: A.properties.etiqueta,
                place_type: ["place"],
                center: M
              };
              o.push(E);
            }
          } catch (d) {
            console.error(`Failed to forwardGeocode with error: ${d}`);
          }
          return {
            features: o
          };
        }
      };
      this.map.addControl(new uY(i, e), t);
      let s = document.getElementsByClassName("maplibregl-ctrl-geocoder--input");
      s[0].attributes[2].nodeValue = "Cerca...", s[0].addEventListener("input", function(l) {
        l.target.value.length > 3;
      });
    } catch (n) {
      console.error(`Error adding ICGC geocoder: ${n.message}`);
    }
  }
  //geocoder ends
  async loadImage(e) {
    try {
      return this.map.loadImage(e);
    } catch (t) {
      console.error(`Error getting loadImage: ${t.message}`);
    }
  }
  /**
   * Retrieves the available base styles from default options.
   * @function getConfigStyles
   * @returns {Array} - Array containing the names of available base styles.
   */
  getConfigStyles() {
    try {
      let e = [];
      for (const t of wf)
        e.push(t.name);
      return e;
    } catch (e) {
      console.error(`Error retrieving base styles: ${e.message}`);
    }
  }
  /**
   * Retrieves the available WMS image layers from default options.
   * @function getConfigWMSLayers
   * @returns {Array} - Array containing the keys of available WMS image layers.
   */
  getConfigWMSLayers() {
    try {
      let e = [];
      for (const t in fs.WMS)
        fs.WMS.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving WMS layers: ${e.message}`);
    }
  }
  /**
   * Retrieves the available orto image layers from default options.
   * @function getConfigOrtoLayers
   * @returns {Array} - Array containing the keys of available image layers.
   */
  getConfigOrtoLayers() {
    try {
      let e = [];
      for (const t in fs.Orto)
        fs.Orto.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving orto image layers: ${e.message}`);
    }
  }
  /**
   * Retrieves the available vector layers from default options.
   * @function getConfigVectorLayers
   * @returns {Array} - Array containing the keys of available vector layers.
   */
  getConfigVectorLayers() {
    try {
      let e = [];
      for (const t in fs.Vector)
        fs.Vector.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving vector layers: ${e.message}`);
    }
  }
  /**
   * Retrieves the available vector layers from default options.
   * @function getConfigVectorAdminLayers
   * @returns {Array} - Array containing the keys of available vectorAdmin layers.
   */
  getConfigVectorAdminLayers() {
    try {
      let e = [];
      for (const t in fs.VectorAdmin)
        fs.VectorAdmin.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving vectorAdmin layers: ${e.message}`);
    }
  }
  /**
   * Retrieves the available fgb layers from default options.
   * @function getConfigFGBAdminLayers
   * @returns {Array} - Array containing the keys of available fgbadmin layers.
   */
  getConfigFGBAdminLayers() {
    try {
      let e = [];
      for (const t in fs.FGBAdmin)
        fs.FGBAdmin.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving FGBAdmin layers: ${e.message}`);
    }
  }
  /**
   * Fetches GeoJSON data from a URL and adds a corresponding layer to the map based on the specified geometry type.
   * @param {string} url - The URL to fetch GeoJSON data from.
   * @param {string} idLayer - The id for the layer.
   * @param {Object} options - Additional options for configuring the layer.
   */
  async fetchData(e, t, n) {
    try {
      (!n || n === void 0) && (n = {
        type: "line",
        layout: {
          visibility: "visible"
        },
        paint: {
          "line-color": "grey",
          "line-width": 2
        },
        layerPosition: "top"
        // select: 'top', 'lines' or 'labels'
      });
      let i = n.layerPosition;
      if (e.includes(".fgb"))
        this.addFGBLayerICGC(e, t, n);
      else {
        const l = await (await fetch(e)).json();
        let o = t, d = this._dealOrderLayer(i), m = l.features[0].geometry.type;
        m.includes("ine") && (n !== void 0 ? this.map.addLayer({
          id: o,
          type: "line",
          source: {
            type: "geojson",
            data: l
          },
          layout: n.layout || {},
          paint: n.paint || {}
        }, d) : this.map.addLayer({
          id: o,
          type: "line",
          source: {
            type: "geojson",
            data: l
          },
          layout: {
            visibility: "visible"
          },
          paint: {
            "line-color": "black",
            "line-width": 2,
            "line-opacity": 1
          }
        }, d)), m.includes("olygon") && (n !== void 0 ? this.map.addLayer({
          id: o,
          type: "fill",
          source: {
            type: "geojson",
            data: l
          },
          layout: n.layout,
          paint: n.paint
        }, d) : this.map.addLayer({
          id: o,
          type: "fill",
          source: {
            type: "geojson",
            data: l
          },
          layout: {
            visibility: "visible"
          },
          paint: {
            "fill-color": "blue",
            "fill-opacity": 0.6
          }
        }, d)), m.includes("oint") && (n !== void 0 ? this.map.addLayer({
          id: o,
          type: "circle",
          source: {
            type: "geojson",
            data: l
          },
          layout: n.layout,
          paint: n.paint
        }, d) : this.map.addLayer({
          id: o,
          type: "circle",
          source: {
            type: "geojson",
            data: l
          },
          layout: {
            visibility: "visible"
          },
          paint: {
            "circle-color": "red",
            "circle-opacity": 0.85
          }
        }, d));
      }
    } catch (i) {
      console.error(`Error fetching data: ${i.message}`);
    }
  }
  /**
   * Fetches GeoJSON data from a URL and adds a corresponding layer to the map based on the specified geometry type and adds to the Menu as a checkbox item.
   * @param {string} url - The URL to fetch GeoJSON data from.
   * @param {string} idLayer - The geometry name (e.g., 'buildings').
   * @param {string} filterField - Import all features as unique or group based on a field ('all', 'field').
   * @param {Object} options - Additional options for configuring the layer.
   */
  async fetchDataAndMenu(e, t, n, i) {
    try {
      let s;
      i !== null ? s = i.layerPosition : s = s_;
      let l, o = document.getElementById("map");
      if (document.getElementById("menu-group") ? l = document.getElementById("menu-group") : (l = document.createElement("nav"), l.id = "menu-group", l.classList.add = "filter-group", o.appendChild(l)), l !== null) {
        let d = "visible", m = this._dealOrderLayer(s), b;
        if (e.includes(".fgb")) {
          let M = this._getKeyByUrlFGB(e);
          M === null && (M = "userFGB");
          const E = await fetch(e), k = {
            type: "FeatureCollection",
            features: []
          };
          for await (const V of wA(E.body)) k.features.push(V);
          b = k;
          let U = t;
          if (this.map.addSource(U, {
            type: "geojson",
            data: k
          }), e.includes("text"))
            i !== void 0 ? this.map.addLayer({
              id: t,
              type: "symbol",
              source: U,
              layout: i.layout,
              paint: i.paint
            }, m) : this.map.addLayer({
              id: t,
              type: "symbol",
              source: U,
              layout: {
                "text-letter-spacing": 0.1,
                "text-size": {
                  base: 1.2,
                  stops: [[8, 0], [12, 14], [15, 15]]
                },
                "text-font": ["FiraSans-Regular"],
                "text-field": ["get", "NOM_AC"],
                "text-transform": "none",
                "text-max-width": 25,
                visibility: d,
                "text-justify": "right",
                "text-anchor": "top",
                "text-allow-overlap": !1,
                "symbol-spacing": 2,
                "text-line-height": 1
              },
              paint: {
                "text-halo-blur": 0.5,
                "text-color": "rgba(90, 7, 7, 1)",
                "text-halo-width": 2,
                "text-halo-color": "rgba(255, 255, 255,0.8)"
              }
            }, m);
          else {
            let V = t + "Text";
            this.map.addLayer({
              id: V,
              type: "symbol",
              source: U,
              layout: {
                "text-letter-spacing": 0.1,
                "text-size": {
                  base: 1.2,
                  stops: [[8, 0], [12, 14], [15, 15]]
                },
                "text-font": ["FiraSans-Regular"],
                "text-field": ["get", "NOM_AC"],
                "text-transform": "none",
                "text-max-width": 25,
                visibility: d,
                "text-justify": "right",
                "text-anchor": "top",
                "text-allow-overlap": !1,
                "symbol-spacing": 2,
                "text-line-height": 1
              },
              paint: {
                "text-halo-blur": 0.5,
                "text-color": "rgba(90, 7, 7, 1)",
                "text-halo-width": 2,
                "text-halo-color": "rgba(255, 255, 255,0.8)"
              }
            }, m);
          }
        } else
          b = await (await fetch(e)).json();
        if (n !== "all") {
          const M = document.createElement("div");
          M.id = "titleDivMenu", M.textContent = t, l.appendChild(M);
          const E = document.createElement("div");
          E.id = "titleDivMenuSub", E.textContent = `📂 ${n}`, l.appendChild(E);
        }
        let A;
        if (i.type ? A = i.type : A = b.features[0].geometry.type, n === "all")
          A.includes("ine") && (i !== void 0 ? this.map.addLayer({
            id: t,
            type: "line",
            source: {
              type: "geojson",
              data: b
            },
            layout: i.layout,
            paint: i.paint
          }, m) : this.map.addLayer({
            id: t,
            type: "line",
            source: {
              type: "geojson",
              data: b
            },
            layout: {
              visibility: "visible"
            },
            paint: {
              "line-color": "black",
              "line-width": 2,
              "line-opacity": 1
            }
          }, m)), A.includes("olygon") && (i !== void 0 ? this.map.addLayer({
            id: t,
            type: "fill",
            source: {
              type: "geojson",
              data: b
            },
            layout: i.layout,
            paint: i.paint
          }, m) : this.map.addLayer({
            id: t,
            type: "fill",
            source: {
              type: "geojson",
              data: b
            },
            layout: {
              visibility: "visible"
            },
            paint: {
              "fill-color": "#0000FF",
              "fill-opacity": 0
            }
          }, m)), A.includes("oint") && (i !== void 0 ? this.map.addLayer({
            id: t,
            type: "circle",
            source: {
              type: "geojson",
              data: b
            },
            layout: i.layout,
            paint: i.paint
          }, m) : this.map.addLayer({
            id: t,
            type: "circle",
            source: {
              type: "geojson",
              data: b
            },
            layout: {
              visibility: "visible"
            },
            paint: {
              "circle-color": "red",
              "circle-opacity": 0.85
            }
          }, m)), A.includes("ymbol") && (i !== void 0 ? this.map.addLayer({
            id: t,
            type: "symbol",
            source: {
              type: "geojson",
              data: b
            },
            layout: i.layout,
            paint: i.paint
          }, m) : this.map.addLayer({
            id: t,
            type: "symbol",
            source: {
              type: "geojson",
              data: b
            },
            layout: {
              visibility: "visible"
            },
            paint: {
              "text-halo-blur": 0.5,
              "text-color": "rgba(90, 7, 7, 1)",
              "text-halo-width": 2,
              "text-halo-color": "rgba(255, 255, 255,0.8)"
            }
          }, m)), this.addMenuItem(t);
        else {
          let M = n;
          const E = {};
          b.features.forEach((k) => {
            const U = k.properties[M], V = U + "-userFieldFilter-" + t;
            U !== null && (E[V] || (A.includes("ine") && (i !== void 0 ? this.map.addLayer({
              id: V,
              type: "line",
              source: {
                type: "geojson",
                data: b
              },
              layout: i.layout,
              paint: i.paint,
              filter: ["==", `${M}`, U]
            }, m) : this.map.addLayer({
              id: V,
              type: "line",
              source: {
                type: "geojson",
                data: b
              },
              layout: {
                visibility: "visible"
              },
              filter: ["==", `${M}`, U],
              paint: {
                "line-color": "black",
                "line-width": 2,
                "line-opacity": 1
              }
            }, m)), A.includes("olygon") && (i !== void 0 ? this.map.addLayer({
              id: V,
              type: "fill",
              source: {
                type: "geojson",
                data: b
              },
              filter: ["==", `${M}`, U],
              layout: i.layout,
              paint: i.paint
            }, m) : this.map.addLayer({
              id: V,
              type: "fill",
              source: {
                type: "geojson",
                data: b
              },
              layout: {
                visibility: "visible"
              },
              filter: ["==", `${M}`, U],
              paint: {
                "fill-color": "blue",
                "fill-opacity": 0.6
              }
            }, m)), A.includes("oint") && (i !== void 0 ? this.map.addLayer({
              id: V,
              type: "circle",
              source: {
                type: "geojson",
                data: b
              },
              filter: ["==", `${M}`, U],
              layout: i.layout,
              paint: i.paint
            }, m) : this.map.addLayer({
              id: V,
              type: "circle",
              source: {
                type: "geojson",
                data: b
              },
              layout: {
                visibility: "visible"
              },
              filter: ["==", `${M}`, U],
              paint: {
                "circle-color": "red",
                "circle-opacity": 0.85
              }
            }, m)), E[V] = !0, this.addMenuItem(V)));
          });
        }
      }
    } catch (s) {
      console.error(`Error fetching data: ${s.message}`);
    }
  }
  /**
   * Adds an event listener to the map.
   * @function on
   * @param {string} type - The type of the event.
   * @param {Function} func - The callback function to be executed when the event occurs.
   */
  on(e, t) {
    setTimeout(() => {
      try {
        return this.map.on(e, t);
      } catch (n) {
        console.error(`Error adding event ON listener: ${n.message}`);
      }
    }, 100);
  }
  /**
   * Sets the style of the map.
   * @function setStyle
   * @param {string} style - Name of the map style.
   * @param {Object} [options] - Options for setting the style.
   */
  setStyle(e, t) {
    try {
      t !== void 0 ? this.map.setStyle(e, t) : this.map.setStyle(e), this.map.on("styledata", () => {
        if (window.document.querySelector(".maplibregl-compact-show")) {
          var n = window.document.querySelector(".maplibregl-compact-show");
          n.classList.remove("maplibregl-compact-show");
        }
        this._dealOrto3dStyle(this.map.getStyle().name);
      });
    } catch (n) {
      console.error(`Error setting style: ${n.message}`);
    }
  }
  /**
   * Adds a control to the map with the specified position.
   * @function addControl
   * @param {Object} control - The control to add.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), this.map.addControl(e, t);
    } catch (n) {
      console.error(`Error adding control: ${n.message}`);
    }
  }
  /**
   * Sets the sky properties of the map.
   * @function setSky
   * @param {Object} options - Options to set the sky properties.
   * @param {string} [options.skyType='gradient'] - Type of sky to set (e.g., 'gradient', 'atmosphere').
   * @param {string} [options.color='lightblue'] - Color of the sky.
   * @param {Number} [options.horizonBlend=0.03] - Blend horizon value.
   * @param {Number} [options.starIntensity=0.5] - Intensity of stars in the sky.
   * @param {Number} [options.sunIntensity=0.1] - Intensity of the sun in the sky.
   * @param {Array<Number>} [options.sunPosition=[0, 0]] - Position of the sun in the sky.
   */
  setSky(e) {
    try {
      e === void 0 && (this.map.style.stylesheet.id.includes("orto") ? e = {
        "sky-color": "#86bbd5",
        "sky-horizon-blend": 0.3,
        "horizon-color": "#ffffff33",
        "horizon-fog-blend": 0.1,
        "fog-ground-blend": 0.75,
        "fog-color": "#c5d6d6"
      } : this.map.style.stylesheet.id.includes("mapa_estandard_general") ? e = {
        "sky-color": "#a5f0f0",
        "sky-horizon-blend": 0.3,
        "horizon-color": "#e1e3e3",
        "horizon-fog-blend": 0.9,
        "fog-ground-blend": 0.85,
        "fog-color": "#c5d6d6"
      } : this.map.style.stylesheet.id.includes("icgc_mapa_vissir") ? e = {
        "sky-color": "#a5f0f0",
        "sky-horizon-blend": 0.3,
        "horizon-color": "#e1e3e3",
        "horizon-fog-blend": 0.9,
        "fog-ground-blend": 0.85,
        "fog-color": "#c5d6d6"
      } : this.map.style.stylesheet.id.includes("fosc") ? e = {
        "sky-color": "#232423",
        "sky-horizon-blend": 0.3,
        "horizon-color": "#969996",
        "horizon-fog-blend": 0.9,
        "fog-ground-blend": 0.85,
        "fog-color": "#383838"
      } : e = {
        "sky-color": "#86bbd5",
        "sky-horizon-blend": 0.3,
        "horizon-color": "#ffffff33",
        "horizon-fog-blend": 0.1,
        "fog-ground-blend": 0.75,
        "fog-color": "#c5d6d6"
      }), this.map.setSky(e);
    } catch (t) {
      console.error(`Error setting sky properties: ${t.message}`);
    }
  }
  /**
   * Adds a mouse coordinate control to the map.
   * @function addMouseCoordControl
   * @param {Number} options.width - Width control i.
   * @param {Boolean} options.utm - Boolean to show coordinates in UTM.
   * @param {Boolean} options.lonlat - Boolean to show coordinates in Lon Lat.
   * @param {string} [position='bottom-left'] - Position to add the control on the map.
   */
  addMouseCoordControl(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "bottom-left";
    try {
      this.map.addControl(new vY(e), t);
    } catch (n) {
      console.error(`Error adding mouse coordinate control: ${n.message}`);
    }
  }
  /**
   * Adds a geolocate control to the map.
   * @function addGeolocateControl
   * @param {Object} options - Options for the geolocate control.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addGeolocateControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), e === void 0 ? this.map.addControl(new po.GeolocateControl({
        positionOptions: {
          enableHighAccuracy: !0
        },
        trackUserLocation: !0
      }), t) : this.map.addControl(new po.GeolocateControl(e), t);
    } catch (n) {
      console.error(`Error adding geolocate control: ${n.message}`);
    }
  }
  /**
   * Adds a fullscreen control to the map.
   * @function addFullscreenControl
   * @param {Object} options - Options for the geolocate control.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addFullscreenControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), e === void 0 ? this.map.addControl(new po.FullscreenControl({
        container: HTMLElement
      }), t) : this.map.addControl(new po.FullscreenControl(e), t);
    } catch (n) {
      console.error(`Error adding fullscreen control: ${n.message}`);
    }
  }
  /**
   * Adds a layer to the map.
   * @function addLayer
   * @param {Object} layer - Options for the layer to add.
   * @param {string} layerIdOrder - Optional layer Id draw position.
   */
  addLayer(e, t) {
    try {
      this.map.addLayer(e, t);
    } catch (n) {
      console.error(`Error adding layer: ${n.message}`);
    }
  }
  //add maplibre methods
  /**
   * Adds an image to the map.
   * @function addImage
   * @param {string} id - The ID of the image.
   * @param {ImageBitmap | HTMLImageElement | ImageData | StyleImageInterface | object} image - The image object to add.
   * @param {Partial<StyleImageMetadata>} options - Optional metadata for the image.
   * @returns {this}
   */
  addImage(e, t, n) {
    try {
      this.map.addImage(e, t, n);
    } catch (i) {
      console.error(`Error adding image: ${i.message}`);
    }
    return this;
  }
  /**
   * Adds a source to the map.
   * @function addSource
   * @param {string} id - The ID of the source.
   * @param {SourceSpecification} source - The source object to add.
   * @returns {this}
   */
  addSource(e, t) {
    try {
      this.map.addSource(e, t);
    } catch (n) {
      console.error(`Error adding source: ${n.message}`);
    }
    return this;
  }
  /**
   * Adds a sprite to the map.
   * @function addSprite
   * @param {string} id - The ID of the sprite.
   * @param {string} url - The URL to load the sprite from.
   * @param {StyleSetterOptions} options - Options object.
   * @returns {this}
   */
  addSprite(e, t, n) {
    try {
      this.map.addSprite(e, t, n);
    } catch (i) {
      console.error(`Error adding sprite: ${i.message}`);
    }
    return this;
  }
  /**
   * Checks if all tiles in the viewport are loaded.
   * @function areTilesLoaded
   * @returns {boolean}
   */
  areTilesLoaded() {
    return this.map.areTilesLoaded();
  }
  /**
   * Calculates the camera position for given bounds.
   * @function cameraForBounds
   * @param {LngLatBoundsLike} bounds - The geographical bounds to fit.
   * @param {CameraForBoundsOptions} options - Options object.
   * @returns {CenterZoomBearing | undefined}
   */
  cameraForBounds(e, t) {
    return this.map.cameraForBounds(e, t);
  }
  /**
   * Eases the camera to a new position.
   * @function easeTo
   * @param {object} options - Options describing the animation.
   * @param {any} eventData - Additional properties for event objects.
   * @returns {this}
   */
  easeTo(e, t) {
    return this.map.easeTo(e, t), this;
  }
  /**
   * Fits the map to the given geographical bounds.
   * @function fitBounds
   * @param {LngLatBoundsLike} bounds - The geographical bounds to fit.
   * @param {FitBoundsOptions} options - Options object.
   * @param {any} eventData - Additional properties for event objects.
   * @returns {this}
   */
  fitBounds(e, t, n) {
    return this.map.fitBounds(e, t, n), this;
  }
  /**
   * Fits the map to the given screen coordinates.
   * @function fitScreenCoordinates
   * @param {PointLike} p0 - First point on screen, in pixel coordinates.
   * @param {PointLike} p1 - Second point on screen, in pixel coordinates.
   * @param {number} bearing - Desired map bearing at end of animation, in degrees.
   * @param {FitBoundsOptions} options - Options object.
   * @param {any} eventData - Additional properties for event objects.
   * @returns {this}
   */
  fitScreenCoordinates(e, t, n, i, s) {
    return this.map.fitScreenCoordinates(e, t, n, i, s), this;
  }
  /**
   * Flies the camera to a new position.
   * @function flyTo
   * @param {FlyToOptions} options - Options describing the flight.
   * @param {any} eventData - Additional properties for event objects.
   * @returns {this}
   */
  flyTo(e, t) {
    return this.map.flyTo(e, t), this;
  }
  /**
   * Gets the current bearing of the map.
   * @function getBearing
   * @returns {number}
   */
  getBearing() {
    return this.map.getBearing();
  }
  /**
   * Gets the current geographical bounds of the map.
   * @function getBounds
   * @returns {LngLatBounds}
   */
  getBounds() {
    return this.map.getBounds();
  }
  /**
   * Gets the elevation for the point where the camera is looking.
   * @function getCameraTargetElevation
   * @returns {number}
   */
  getCameraTargetElevation() {
    return this.map.getCameraTargetElevation();
  }
  /**
   * Gets the map's <canvas> element.
   * @function getCanvas
   * @returns {HTMLCanvasElement}
   */
  getCanvas() {
    return this.map.getCanvas();
  }
  /**
   * Gets the HTML element containing the map's <canvas> element.
   * @function getCanvasContainer
   * @returns {HTMLElement}
   */
  getCanvasContainer() {
    return this.map.getCanvasContainer();
  }
  /**
   * Returns the map's geographical centerpoint.
   * @function getCenter
   * @returns {LngLat} The map's geographical centerpoint.
   */
  getCenter() {
    return this.map.getCenter();
  }
  /**
   * Returns the map's containing HTML element.
   * @function getContainer
   * @returns {HTMLElement} The map's container.
   */
  getContainer() {
    return this.map.getContainer();
  }
  /**
   * Gets the state of a feature.
   * @function getFeatureState
   * @param {FeatureIdentifier} feature - Feature identifier.
   * @returns {any} The state of the feature.
   */
  getFeatureState(e) {
    return this.map.getFeatureState(e);
  }
  /**
   * Returns the filter applied to the specified style layer.
   * @function getFilter
   * @param {string} layerId - The ID of the style layer.
   * @returns {void | FilterSpecification} The layer's filter.
   */
  getFilter(e) {
    return this.map.getFilter(e);
  }
  /**
   * Returns the value of the style's glyphs URL.
   * @function getGlyphs
   * @returns {string} The glyphs Style's glyphs URL.
   */
  getGlyphs() {
    return this.map.getGlyphs();
  }
  /**
   * Returns an image currently available in the map.
   * @function getImage
   * @param {string} id - The ID of the image.
   * @returns {StyleImage} An image in the map with the specified ID.
   */
  getImage(e) {
    return this.map.getImage(e);
  }
  /**
   * Returns the layer with the specified ID in the map's style.
   * @function getLayer
   * @param {string} id - The ID of the layer to get.
   * @returns {StyleLayer} The layer with the specified ID.
   */
  getLayer(e) {
    return this.map.getLayer(e);
  }
  /**
   * Return the ids of all layers currently in the style, including custom layers, in order.
   * @function getLayersOrder
   * @returns {string[]} Ids of layers, in order.
   */
  getLayersOrder() {
    return this.map.getLayersOrder();
  }
  /**
   * Returns the value of a layout property in the specified style layer.
   * @function getLayoutProperty
   * @param {string} layerId - The ID of the layer.
   * @param {string} name - The name of the layout property.
   * @returns {any} The value of the specified layout property.
   */
  getLayoutProperty(e, t) {
    return this.map.getLayoutProperty(e, t);
  }
  /**
   * Returns the value of the light object.
   * @function getLight
   * @returns {LightSpecification} Light properties of the style.
   */
  getLight() {
    return this.map.getLight();
  }
  /**
   * Returns the maximum geographical bounds the map is constrained to.
   * @function getMaxBounds
   * @returns {LngLatBounds} The map's maximum geographical bounds.
   */
  getMaxBounds() {
    return this.map.getMaxBounds();
  }
  /**
   * Returns the map's maximum allowable pitch.
   * @function getMaxPitch
   * @returns {number} The maxPitch.
   */
  getMaxPitch() {
    return this.map.getMaxPitch();
  }
  /**
   * Returns the map's maximum allowable zoom level.
   * @function getMaxZoom
   * @returns {number} The maxZoom.
   */
  getMaxZoom() {
    return this.map.getMaxZoom();
  }
  /**
   * Returns the map's minimum allowable pitch.
   * @function getMinPitch
   * @returns {number} The minPitch.
   */
  getMinPitch() {
    return this.map.getMinPitch();
  }
  /**
   * Returns the map's minimum allowable zoom level.
   * @function getMinZoom
   * @returns {number} The minZoom.
   */
  getMinZoom() {
    return this.map.getMinZoom();
  }
  /**
   * Returns the current padding applied around the map viewport.
   * @function getPadding
   * @returns {PaddingOptions} The current padding around the map viewport.
   */
  getPadding() {
    return this.map.getPadding();
  }
  /**
   * Returns the value of a paint property in the specified style layer.
   * @function getPaintProperty
   * @param {string} layerId - The ID of the layer.
   * @param {string} name - The name of a paint property.
   * @returns {unknown} The value of the specified paint property.
   */
  getPaintProperty(e, t) {
    return this.map.getPaintProperty(e, t);
  }
  /**
   * Returns the map's current pitch (tilt).
   * @function getPitch
   * @returns {number} The map's current pitch, measured in degrees away from the plane of the screen.
   */
  getPitch() {
    return this.map.getPitch();
  }
  /**
   * Returns the map's pixel ratio.
   * @function getPixelRatio
   * @returns {number} The pixel ratio.
   */
  getPixelRatio() {
    return this.map.getPixelRatio();
  }
  /**
   * Returns the state of renderWorldCopies.
   * @function getRenderWorldCopies
   * @returns {boolean} The renderWorldCopies.
   */
  getRenderWorldCopies() {
    return this.map.getRenderWorldCopies();
  }
  /**
   * Returns the source with the specified ID in the map's style.
   * @function getSource
   * @param {string} id - The ID of the source to get.
   * @returns {Source} The style source with the specified ID.
   */
  getSource(e) {
    return this.map.getSource(e);
  }
  /**
   * Returns the as-is value of the style's sprite.
   * @function getSprite
   * @returns {object[]} Style's sprite list of id-url pairs.
   */
  getSprite() {
    return this.map.getSprite();
  }
  /**
   * Returns the map's MapLibre style object.
   * @function getStyle
   * @returns {StyleSpecification} The map's style JSON object.
   */
  getStyle() {
    return this.map.getStyle();
  }
  /**
   * Get the terrain-options if terrain is loaded.
   * @function getTerrain
   * @returns {TerrainSpecification} The TerrainSpecification passed to setTerrain.
   */
  getTerrain() {
    return this.map.getTerrain();
  }
  //  Function getZoom()
  /**
   * Returns the map's current zoom level.
   * @function getZoom
   * @returns {number} The map's current zoom level.
   */
  getZoom() {
    return this.map.getZoom();
  }
  //  Function hasControl()
  /**
   * Checks if a control exists on the map.
   * @function hasControl
   * @param {IControl} control - The IControl to check.
   * @returns {boolean} true if map contains control.
   */
  hasControl(e) {
    return this.map.hasControl(e);
  }
  //  Function hasImage()
  /**
   * Check whether or not an image with a specific ID exists in the style.
   * @function hasImage
   * @param {string} id - The ID of the image.
   * @returns {boolean} A Boolean indicating whether the image exists.
   */
  hasImage(e) {
    return this.map.hasImage(e);
  }
  //  Function isMoving()
  /**
   * Returns true if the map is panning, zooming, rotating, or pitching due to a camera animation or user gesture.
   * @function isMoving
   * @returns {boolean} true if the map is moving.
   */
  isMoving() {
    return this.map.isMoving();
  }
  //  Function isRotating()
  /**
   * Returns true if the map is rotating due to a camera animation or user gesture.
   * @function isRotating
   * @returns {boolean} true if the map is rotating.
   */
  isRotating() {
    return this.map.isRotating();
  }
  //  Function isSourceLoaded()
  /**
   * Returns a Boolean indicating whether the source is loaded.
   * @function isSourceLoaded
   * @param {string} id - The ID of the source to be checked.
   * @returns {boolean} A Boolean indicating whether the source is loaded.
   */
  isSourceLoaded(e) {
    return this.map.isSourceLoaded(e);
  }
  //  Function isStyleLoaded()
  /**
   * Returns a Boolean indicating whether the map's style is fully loaded.
   * @function isStyleLoaded
   * @returns {boolean | void} A Boolean indicating whether the style is fully loaded.
   */
  isStyleLoaded() {
    return this.map.isStyleLoaded();
  }
  //  Function isZooming()
  /**
   * Returns true if the map is zooming due to a camera animation or user gesture.
   * @function isZooming
   * @returns {boolean} true if the map is zooming.
   */
  isZooming() {
    return this.map.isZooming();
  }
  //  Function jumpTo()
  /**
   * Changes any combination of center, zoom, bearing, and pitch, without an animated transition.
   * @function jumpTo
   * @param {JumpToOptions} options - Options object
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  jumpTo(e, t) {
    return this.map.jumpTo(e, t);
  }
  //  Function listImages()
  /**
   * Returns an Array of strings containing the IDs of all images currently available in the map.
   * @function listImages
   * @returns {string[]} An Array of strings containing the names of all sprites/images currently available in the map.
   */
  listImages() {
    return this.map.listImages();
  }
  //  Function listens()
  /**
   * Returns a true if this instance of Evented or any forwardeed instances of Evented have a listener for the specified type.
   * @function listens
   * @param {string} type - The event type.
   * @returns {boolean} true if there is at least one registered listener for specified event type, false otherwise.
   */
  listens(e) {
    return this.map.listens(e);
  }
  //  Function loadImage()
  /**
   * Load an image from an external URL to be used with Map#addImage.
   * @function loadImage
   * @param {string} url - The URL of the image file. Image file must be in png, webp, or jpg format.
   * @returns {Promise<GetResourceResponse<ImageBitmap | HTMLImageElement>>} A promise that is resolved when the image is loaded.
   */
  loadImage(e) {
    return this.map.loadImage(e);
  }
  //  Function loaded()
  /**
   * Returns a Boolean indicating whether the map is fully loaded.
   * @function loaded
   * @returns {boolean} A Boolean indicating whether the map is fully loaded.
   */
  loaded() {
    return this.map.loaded();
  }
  //  Function new LngLatBounds()
  /**
   * Constructs a new LngLatBounds object representing a geographical bounding box.
   * @class LngLatBounds
   * @constructor
   * @param {LngLatLike} [sw] - The southwest corner of the bounding box. Can be specified as an array of 4 numbers in the order of west, south, east, north, or an array of 2 LngLatLike representing [sw,ne].
   * @param {LngLatLike} [ne] - The northeast corner of the bounding box.
   */
  LngLatBounds(e, t) {
    return new po.LngLatBounds(e, t);
  }
  //  Function addProtocol()
  /**
   * Adds a custom load resource function that will be called when using a URL that starts with a custom URL schema.
   * @function addProtocol
   * @param {string} customProtocol - The protocol to hook, for example 'custom'.
   * @param {AddProtocolAction} loadFn - The function to use when trying to fetch a resource specified by the customProtocol.
   * @returns {void}
   */
  addProtocol(e, t) {
    return this.map.addProtocol(e, t);
  }
  //  Function moveLayer()
  /**
   * Moves a layer to a different z-position.
   * @function moveLayer
   * @param {string} id - The ID of the layer to move.
   * @param {string} [beforeId] - The ID of an existing layer to insert the new layer before.
   * @returns {this}
   */
  moveLayer(e, t) {
    return this.map.moveLayer(e, t);
  }
  //  Function panBy()
  /**
   * Pans the map by the specified offset.
   * @function panBy
   * @param {PointLike} offset - x and y coordinates by which to pan the map.
   * @param {AnimationOptions} [options] - Options object.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  panBy(e, t, n) {
    return this.map.panBy(e, t, n);
  }
  //  Function panTo()
  /**
   * Pans the map to the specified location with an animated transition.
   * @function panTo
   * @param {LngLatLike} lnglat - The location to pan the map to.
   * @param {AnimationOptions} [options] - Options describing the destination and animation of the transition.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  panTo(e, t, n) {
    return this.map.panTo(e, t, n);
  }
  //  Function project()
  /**
   * Returns a Point representing pixel coordinates, relative to the map's container, that correspond to the specified geographical location.
   * @function project
   * @param {LngLatLike} lnglat - The geographical location to project.
   * @returns {Point} The Point corresponding to lnglat, relative to the map's container.
   */
  project(e) {
    return this.map.project(e);
  }
  //  Function queryRenderedFeatures()
  /**
   * Queries rendered features within a specified geometry or bounding box.
   * @function queryRenderedFeatures
   * @param {GeometryLike | Array | Object} [geometryOrOptions] - The geometry or options for the query.
   * @param {Object} [options] - Options for the query.
   * @returns {Array} An array of GeoJSON Feature objects representing the features that intersect the query geometry.
   */
  queryRenderedFeatures(e, t) {
    return this.map.queryRenderedFeatures(e, t);
  }
  //  Function querySourceFeatures()
  /**
   * Queries source features within a specified source.
   * @function querySourceFeatures
   * @param {string} sourceId - The ID of the source to query.
   * @param {Object} parameters - Parameters for the query.
   * @returns {Array} An array of GeoJSON Feature objects representing the features in the source that satisfy the query parameters.
   */
  querySourceFeatures(e, t) {
    return this.map.querySourceFeatures(e, t);
  }
  //  Function queryTerrainElevation()
  /**
   * Queries the terrain elevation at a specified geographical location.
   * @function queryTerrainElevation
   * @param {LngLatLike} lngLatLike - The geographical location to query.
   * @returns {number} The elevation (in meters) at the specified location.
   */
  queryTerrainElevation(e) {
    return this.map.queryTerrainElevation(e);
  }
  //  Function redraw()
  /**
   * Redraws the map.
   * @function redraw
   * @returns {this}
   */
  redraw() {
    return this.map.redraw();
  }
  //  Function remove()
  /**
   * Removes the map from the DOM.
   * @function remove
   * @returns {this}
   */
  remove() {
    return this.map.remove();
  }
  //  Function removeControl()
  /**
   * Removes a control from the map.
   * @function removeControl
   * @param {Object} control - The control to remove.
   * @returns {this}
   */
  removeControl(e) {
    return this.map.removeControl(e);
  }
  //  Function removeFeatureState()
  /**
   * Removes the state of a feature.
   * @function removeFeatureState
   * @param {Object} target - The target feature.
   * @param {string} [key] - The key of the state to remove.
   * @returns {this}
   */
  removeFeatureState(e, t) {
    return this.map.removeFeatureState(e, t);
  }
  //  Function removeImage()
  /**
   * Removes an image from the style's sprite.
   * @function removeImage
   * @param {string} id - The ID of the image to remove.
   * @returns {this}
   */
  removeImage(e) {
    return this.map.removeImage(e);
  }
  /**
   * Removes a layer from the map.
   * @function removeLayer
   * @param {string} idLayer - Identifier of the layer to remove.
   */
  removeLayer(e) {
    try {
      this.map.removeLayer(e);
    } catch (t) {
      console.error(`Error removing layer: ${t.message}`);
    }
  }
  /**
   * Removes a source from the map.
   * @function removeSource
   * @param {string} idLayer - Identifier of the source to remove.
   */
  removeSource(e) {
    try {
      this.map.removeSource(e);
    } catch (t) {
      console.error(`Error removing source: ${t.message}`);
    }
  }
  //  Function removeSprite()
  /**
   * Removes a sprite from the style.
   * @function removeSprite
   * @param {string} id - The ID of the sprite to remove.
   * @returns {this}
   */
  removeSprite(e) {
    return this.map.removeSprite(e);
  }
  //  Function resetNorth()
  /**
   * Resets the map orientation so that north is up.
   * @function resetNorth
   * @param {Object} [options] - Options for the reset.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  resetNorth(e, t) {
    return this.map.resetNorth(e, t);
  }
  //  Function resetNorthPitch()
  /**
   * Resets the map orientation so that north is up and pitch is set to 0°.
   * @function resetNorthPitch
   * @param {Object} [options] - Options for the reset.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  resetNorthPitch(e, t) {
    return this.map.resetNorthPitch(e, t);
  }
  //  Function resize()
  /**
   * Resizes the map to fit its container.
   * @function resize
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  resize(e) {
    return this.map.resize(e);
  }
  //  Function rotateTo()
  /**
   * Rotates the map to the specified bearing with an animated transition.
   * @function rotateTo
   * @param {number} bearing - The desired bearing (in degrees) to rotate the map to.
   * @param {Object} [options] - Options for the rotation.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  rotateTo(e, t, n) {
    return this.map.rotateTo(e, t, n);
  }
  //  Function setBearing()
  /**
   * Sets the map's bearing with an optional animated transition.
   * @function setBearing
   * @param {number} bearing - The desired bearing (in degrees) to set for the map.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setBearing(e, t) {
    return this.map.setBearing(e, t);
  }
  //  Function setCenter()
  /**
   * Sets the map's center coordinates with an optional animated transition.
   * @function setCenter
   * @param {LngLatLike} center - The desired center coordinates to set for the map.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setCenter(e, t) {
    return this.map.setCenter(e, t);
  }
  //  Function setEventedParent()
  /**
   * Sets the parent of the map's event emitter.
   * @function setEventedParent
   * @param {any} [parent] - The parent object to set for the event emitter.
   * @param {any} [data] - Additional data to pass to the parent.
   * @returns {this}
   */
  setEventedParent(e, t) {
    return this.map.setEventedParent(e, t);
  }
  //  Function setFeatureState()
  /**
   * Sets the state of a feature.
   * @function setFeatureState
   * @param {Object} feature - The feature to set the state for.
   * @param {Object} state - The state object to set for the feature.
   * @returns {this}
   */
  setFeatureState(e, t) {
    return this.map.setFeatureState(e, t);
  }
  //  Function setFilter()
  /**
   * Sets the filter for a specified layer.
   * @function setFilter
   * @param {string} layerId - The ID of the layer to set the filter for.
   * @param {Array} [filter] - The filter array to apply to the layer.
   * @param {Object} [options] - Options for the filter.
   * @returns {this}
   */
  setFilter(e, t, n) {
    return this.map.setFilter(e, t, n);
  }
  //  Function setGlyphs()
  /**
   * Sets the glyphs for the map's style.
   * @function setGlyphs
   * @param {string} glyphsUrl - The URL to the glyphs.
   * @param {Object} [options] - Options for setting the glyphs.
   * @returns {this}
   */
  setGlyphs(e, t) {
    return this.map.setGlyphs(e, t);
  }
  //  Function setLayerZoomRange()
  /**
   * Sets the zoom range for a specified layer.
   * @function setLayerZoomRange
   * @param {string} layerId - The ID of the layer to set the zoom range for.
   * @param {number} minzoom - The minimum zoom level for the layer.
   * @param {number} maxzoom - The maximum zoom level for the layer.
   * @returns {this}
   */
  setLayerZoomRange(e, t, n) {
    return this.map.setLayerZoomRange(e, t, n);
  }
  //  Function setLayoutProperty()
  /**
   * Sets a layout property for a specified layer.
   * @function setLayoutProperty
   * @param {string} layerId - The ID of the layer to set the layout property for.
   * @param {string} name - The name of the layout property to set.
   * @param {any} value - The value to set for the layout property.
   * @param {Object} [options] - Options for setting the layout property.
   * @returns {this}
   */
  setLayoutProperty(e, t, n, i) {
    return this.map.setLayoutProperty(e, t, n, i);
  }
  //  Function setLight()
  /**
   * Sets the light for the map's style.
   * @function setLight
   * @param {Object} light - The light object to set for the map.
   * @param {Object} [options] - Options for setting the light.
   * @returns {this}
   */
  setLight(e, t) {
    return this.map.setLight(e, t);
  }
  //  Function setMaxBounds()
  /**
   * Sets the maximum bounds for the map.
   * @function setMaxBounds
   * @param {Array} bounds - The maximum bounds for the map.
   * @returns {this}
   */
  setMaxBounds(e) {
    return this.map.setMaxBounds(e);
  }
  //  Function setMaxPitch()
  /**
   * Sets the maximum pitch for the map.
   * @function setMaxPitch
   * @param {number} maxPitch - The maximum pitch (in degrees) for the map.
   * @returns {this}
   */
  setMaxPitch(e) {
    return this.map.setMaxPitch(e);
  }
  //  Function setMaxZoom()
  /**
   * Sets the maximum zoom level for the map.
   * @function setMaxZoom
   * @param {number} maxZoom - The maximum zoom level for the map.
   * @returns {this}
   */
  setMaxZoom(e) {
    return this.map.setMaxZoom(e);
  }
  //  Function setMinPitch()
  /**
   * Sets the minimum pitch for the map.
   * @function setMinPitch
   * @param {number} minPitch - The minimum pitch (in degrees) for the map.
   * @returns {this}
   */
  setMinPitch(e) {
    return this.map.setMinPitch(e);
  }
  //  Function setMinZoom()
  /**
   * Sets the minimum zoom level for the map.
   * @function setMinZoom
   * @param {number} minZoom - The minimum zoom level for the map.
   * @returns {this}
   */
  setMinZoom(e) {
    return this.map.setMinZoom(e);
  }
  //  Function setPadding()
  /**
   * Sets padding for the map's container.
   * @function setPadding
   * @param {Object} padding - The padding object to set for the map's container.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setPadding(e, t) {
    return this.map.setPadding(e, t);
  }
  //  Function setPaintProperty()
  /**
   * Sets a paint property for a specified layer.
   * @function setPaintProperty
   * @param {string} layerId - The ID of the layer to set the paint property for.
   * @param {string} name - The name of the paint property to set.
   * @param {any} value - The value to set for the paint property.
   * @param {Object} [options] - Options for setting the paint property.
   * @returns {this}
   */
  setPaintProperty(e, t, n, i) {
    return this.map.setPaintProperty(e, t, n, i);
  }
  //  Function setPitch()
  /**
   * Sets the map's pitch angle with an optional animated transition.
   * @function setPitch
   * @param {number} pitch - The desired pitch angle (in degrees) to set for the map.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setPitch(e, t) {
    return this.map.setPitch(e, t);
  }
  //  Function setPixelRatio()
  /**
   * Sets the pixel ratio for the map.
   * @function setPixelRatio
   * @param {number} pixelRatio - The desired pixel ratio for the map.
   * @returns {this}
   */
  setPixelRatio(e) {
    return this.map.setPixelRatio(e);
  }
  //  Function setRenderWorldCopies()
  /**
   * Sets whether the map should render world copies when the center longitude is greater than or less than ±180 degrees.
   * @function setRenderWorldCopies
   * @param {boolean} renderWorldCopies - A boolean indicating whether to render world copies.
   * @returns {this}
   */
  setRenderWorldCopies(e) {
    return this.map.setRenderWorldCopies(e);
  }
  //  Function setSprite()
  /**
   * Sets the sprite for the map's style.
   * @function setSprite
   * @param {string} spriteUrl - The URL to the sprite.
   * @param {Object} [options] - Options for setting the sprite.
   * @returns {this}
   */
  setSprite(e, t) {
    return this.map.setSprite(e, t);
  }
  //  Function setTerrain()
  /**
   * Loads a 3D terrain mesh based on a "raster-dem" source.
   * @function setTerrain
   * @param {TerrainSpecification} options - Options object specifying the terrain source.
   * @returns {this}
   */
  setTerrain(e) {
    return this.map.setTerrain(e);
  }
  //  Function setTransformRequest()
  /**
   * Updates the requestManager's transform request with a new function.
   * @function setTransformRequest
   * @param {RequestTransformFunction} transformRequest - The callback function to update the transform request.
   * @returns {this}
   */
  setTransformRequest(e) {
    return this.map.setTransformRequest(e);
  }
  //  Function setZoom()
  /**
   * Sets the map's zoom level.
   * @function setZoom
   * @param {number} zoom - The zoom level to set (0-20).
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setZoom(e, t) {
    return this.map.setZoom(e, t);
  }
  //  Function snapToNorth()
  /**
   * Snaps the map so that north is up (0° bearing), if the current bearing is close enough to it.
   * @function snapToNorth
   * @param {Object} [options] - Options for snapping to north.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  snapToNorth(e, t) {
    return this.map.snapToNorth(e, t);
  }
  //  Function stop()
  /**
   * Stops any animated transition underway.
   * @function stop
   * @returns {this}
   */
  stop() {
    return this.map.stop();
  }
  //  Function triggerRepaint()
  /**
   * Triggers the rendering of a single frame.
   * @function triggerRepaint
   * @returns {void}
   */
  triggerRepaint() {
    return this.map.triggerRepaint();
  }
  //  Function unproject()
  /**
   * Returns geographical coordinates corresponding to the specified pixel coordinates.
   * @function unproject
   * @param {PointLike} point - The pixel coordinates to unproject.
   * @returns {LngLat} The geographical coordinates corresponding to the specified pixel coordinates.
   */
  unproject(e) {
    return this.map.unproject(e);
  }
  //  Function updateImage()
  /**
   * Updates an existing image in the style's sprite.
   * @function updateImage
   * @param {string} id - The ID of the image to update.
   * @param {ImageBitmap | HTMLImageElement | ImageData | StyleImageInterface | object} image - The new image data.
   * @returns {this}
   */
  updateImage(e, t) {
    return this.map.updateImage(e, t);
  }
  //  Function zoomIn()
  /**
   * Increases the map's zoom level by 1.
   * @function zoomIn
   * @param {Object} [options] - Options for zooming in.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  zoomIn(e, t) {
    return this.map.zoomIn(e, t);
  }
  //  Function zoomOut()
  /**
   * Decreases the map's zoom level by 1.
   * @function zoomOut
   * @param {Object} [options] - Options for zooming out.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  zoomOut(e, t) {
    return this.map.zoomOut(e, t);
  }
  //  Function zoomTo()
  /**
   * Zooms the map to the specified zoom level with an animated transition.
   * @function zoomTo
   * @param {number} zoom - The zoom level to transition to.
   * @param {Object} [options] - Options for zooming to.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  zoomTo(e, t, n) {
    return this.map.zoomTo(e, t, n);
  }
  // end maplibre methods
  /**
   * Adds a GeoJSON layer to the map.
   * @function addLayerGeoJSON
   * @param {Object} layer - Options for the GeoJSON layer to add.
   * @param {string} layer.id - Unique identifier for the layer.
   * @param {Object} layer.data - GeoJSON data for the layer.
   * @param {string} layer.type - Map layer type (e.g., 'symbol', 'circle', 'fill').   *
   * @param {Object} layer.layout - Layer layout configuration.
   * @param {Object} layer.paint - Layer paint configuration.
   * @param {string} layerPosition - Position of the layer: 'top', below 'labels' or below 'lines'.
   */
  addLayerGeoJSON(e, t) {
    try {
      let n = this._dealOrderLayer(t);
      this.map.addSource(`${e.id}`, {
        type: "geojson",
        data: e.data
      }), this.map.addLayer({
        id: `${e.id}-layerIcgcMap`,
        type: e.type,
        source: `${e.id}`,
        layout: e.layout,
        paint: e.paint
      }, n);
    } catch (n) {
      console.error(`Error adding GeoJSON layer: ${n.message}`);
    }
  }
  /**
   * Adds a WMS layer to the map.
   * @function addLayerWMS
   
   * @param {string[]} tiles - Tiles for the raster layer.
   * @param {string} idLayer - Unique identifier for the layer.
   * @param {Object} options - Options of the layer: layout, paint and layerPosition.
   */
  addLayerWMS(e, t, n) {
    try {
      let i = this._dealOrderLayer(n.layerPosition);
      n ? (this.map.addSource(`${t}`, {
        type: "raster",
        tiles: [e],
        tileSize: 256
      }, i), this.map.addLayer({
        id: t,
        type: "raster",
        source: t,
        layout: n.layout,
        paint: n.paint
      }, i)) : (this.map.addSource(`${t}`, {
        type: "raster",
        tiles: [e],
        tileSize: 256
      }, i), this.map.addLayer({
        id: t,
        type: "raster",
        source: t,
        paint: {}
      }, i));
    } catch (i) {
      console.error(`Error adding WMS layer: ${i.message}`);
    }
  }
  /**
   * Adds a logo to the map.
   * @function addLogo
   * @param {Object} options - Options for the logo to add.
   * @param {string} options.id - Unique identifier for the logo.
   * @param {string} options.url - URL of the logo image.
   * @param {string} options.href - URL to navigate to when the logo is clicked.
   * @param {string} options.height - Height of the logo.
   */
  addLogo(e) {
    try {
      let t = document.getElementById("map"), n;
      n = document.createElement("div"), n.id = "logos", t.appendChild(n);
      const i = document.createElement("img");
      i.src = e.url, i.style.height = e.height;
      const s = document.getElementById("logos"), l = document.createElement("a");
      l.id = e.id, l.href = e.href, l.target = "_blank", l.style.position = "relative", l.style.bottom = "1px", l.appendChild(i), s.appendChild(l);
    } catch (t) {
      console.error(`Error adding logo: ${t.message}`);
    }
  }
  /**
   * Adds base layers to the map.
   * @function addBasemapsICGC
   * @param {Object[]} basesArray - Array of base layer objects.
   */
  addBasemapsICGC(e) {
    try {
      const t = (l) => {
        this.map.setStyle(l);
      };
      let n = document.getElementById("map"), i;
      i = document.createElement("div"), i.id = "basemap-group", i.classList.add = "filter-group", n.appendChild(i);
      const s = document.getElementById("basemap-group");
      for (const l of e)
        for (const o of Object.keys(si.baseStyles)) {
          const d = si.baseStyles[o];
          if (l === d.url) {
            const m = document.createElement("div");
            m.className = "basemap-item", m.title = d.key, m.style.backgroundImage = `url('${d.image}')`, s.appendChild(m), m.addEventListener("click", () => t(d.url));
          }
        }
    } catch (t) {
      console.error(`Error adding basemaps: ${t.message}`);
    }
  }
  /**
   * Adds base layers to the map.
   * @function addBasemaps
   * @param {Object[]} baseLayers - Array of base layer objects.
   * @param {string} baseLayers.label - Label for the base layer.
   * @param {string} baseLayers.image - URL of the image representing the base layer.
   * @param {string} baseLayers.url - URL of the base layer style.
   */
  addBasemaps(e) {
    try {
      const t = (l) => {
        map.setStyle(l.url);
      };
      let n = document.getElementById("map"), i;
      i = document.createElement("div"), i.id = "basemap-group", i.classList.add = "basemap-group", n.appendChild(i);
      const s = document.getElementById("basemap-group");
      e.forEach((l) => {
        const o = document.createElement("div");
        o.className = "basemap-item", o.title = l.label, o.style.backgroundImage = `url('${l.image}')`, s.appendChild(o), o.addEventListener("click", () => t(l));
      });
    } catch (t) {
      console.error(`Error adding basemaps: ${t.message}`);
    }
  }
  /**
   * Adds feature query function to a layer.
   * @function addFeatureQuery
   * @param {string} idLayer - name of the layer
   * @param {objetc} queryFields - optional indications for the popup
   * @param {objetc} popupStyle - optional indications for the popup style
   */
  addFeatureQuery(e, t, n) {
    try {
      let i;
      this.map.on("mouseenter", e, () => {
        this.map.getCanvas().style.cursor = "pointer";
      }), this.map.on("mouseleave", e, () => {
        this.map.getCanvas().style.cursor = "";
      }), this.map.on("click", (s) => {
        let l = this.map.queryRenderedFeatures(s.point);
        if (l && l[0].source.includes(e)) {
          let o = [s.lngLat.lng, s.lngLat.lat];
          if (t !== void 0 && t.length > 0 && t !== "all") {
            if (t !== null) {
              let d = "";
              t.forEach((m) => {
                let b = l[0].properties[m];
                d = d + `<h4>${b}</h4>`;
              }), i = d, this.addPopup(o, i, n);
            }
          } else {
            let d = "";
            for (const m in l[0].properties)
              d += "<b>" + m + "</b>:" + l[0].properties[m] + "<br>";
            i = d, this.addPopup(o, i, n);
          }
        }
      });
    } catch (i) {
      console.error(`Error adding feature query: ${i.message}`);
    }
  }
  /**
   * Adds a scale control to the map.
   *  * @function addScaleControl
   * @param {Object} options - Options for configuring the scale control.
   * @param {string} position - The position on the map to place the scale control (e.g., 'top-left', 'bottom-right').
   */
  addScaleControl(e, t) {
    try {
      var n = new po.ScaleControl(e);
      this.map.addControl(n, t);
    } catch (i) {
      console.error(`Error adding scale: ${i.message}`);
    }
  }
  /**
   * Adds an export control to the map with the provided options and position.
   * @function addExportControl
   * @param {Object|string} options - Options for the export control or position if provided as a string.
   * @param {string} [position] - Position to place the export control (e.g., 'top-right').
   */
  addExportControl(e, t) {
    try {
      typeof e == "string" && (t = e, e = void 0), e === void 0 && (e = {
        PageSize: Rf.A4,
        PageOrientation: pg.Landscape,
        Format: Ku.PNG,
        DPI: Nv[300],
        Crosshair: !0,
        PrintableArea: !0,
        Local: "ca"
      }, t = "top-right"), this.map.addControl(new $Z(e), t);
    } catch (n) {
      console.error(`Error adding export control: ${n.message}`);
    }
  }
  /**
   * Adds a marker to the map.
   * @function addMarker
   * @param {Object} options - Options for the marker to add.
   * @param {string} options.text - Text content for the marker popup.
   * @param {Object} options.options - Marker options.
   * @param {LngLatLike} options.coord - Coordinates for placing the marker.
   * @param {Object} options.textOffset - Text offset for the marker popup.
   * @returns {Object} - Instance of the added marker.
   */
  addMarker(e) {
    try {
      let t, n;
      return e.text === void 0 ? t = new po.Marker(e.options).setLngLat(e.coord).addTo(this.map) : (n = new po.Popup({
        offset: e.textOffset
      }).setHTML(e.text), t = new po.Marker(e.options).setLngLat(e.coord).setPopup(n).addTo(this.map)), t;
    } catch (t) {
      return console.error(`Error adding marker: ${t.message}`), null;
    }
  }
  /**
   * Adds a popup to the map.
   * @function addPopup
   * @param {Object} options - Options for the popup to add.
   * @param {LngLatLike} coord - Coordinates for placing the popup.
   * @param {string} text - HTML content for the popup.
   * @param {string} popupStyle - css content for the popup style.
   * @returns {Object} - Instance of the added popup.
   */
  addPopup(e, t, n) {
    try {
      return n.image === void 0 ? new po.Popup().setLngLat(e).setHTML(`
        <div class="popupBody">
          <div class="popupTop">
          ${n.title}
          </div>
          <div class="popupBottom">
          <div class="popupBottomUp">
 ${t}
          </div>
          <div class="popupBottomDown">
          </div>
          </div>
        </div>
      `).addTo(this.map) : new po.Popup().setLngLat(e).setHTML(`
        <div class="popupBody">
          <div class="popupTop">
          ${n.title}
          </div>
          <div class="popupBottom">
          <div class="popupBottomUp">
          ${t}
          </div>
          <div class="popupBottomDown">
             <img style="  padding: 8px;  width: 50%;" src=${n.image} />
          </div>
          </div>
        </div>
      `).addTo(this.map);
    } catch (i) {
      return console.error(`Error adding popup: ${i.message}`), null;
    }
  }
  /**
   * Adds a fullscreen control to the map.
   * @function addFullScreen
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addFullScreen(e) {
    try {
      e === void 0 && (e = "top-right"), this.map.addControl(new po.FullscreenControl(), e);
    } catch (t) {
      console.error(`Error adding fullscreen control: ${t.message}`);
    }
  }
  /**
   * Adds a menu item with a checkbox for controlling the visibility of a layer on the map.
   * @function addMenuItem
   * @param {string} name - The name of the layer corresponding to the menu item.
   */
  addMenuItem(e) {
    try {
      let t;
      if (e.includes("-userFieldFilter-") ? t = e.split("-userFieldFilter-")[0] : t = e, e.length > 0) {
        const n = document.getElementById("menu-group"), i = document.createElement("input");
        i.type = "checkbox", i.id = e, i.checked = !0, n.appendChild(i);
        const s = document.createElement("label");
        s.setAttribute("for", e), s.textContent = t, n.appendChild(s), i.addEventListener("change", (l) => {
          this.map.setLayoutProperty(e, "visibility", l.target.checked ? "visible" : "none");
        });
      }
    } catch (t) {
      console.error(`Error adding menu item: ${t.message}`);
    }
  }
  /**
   * Adds a layer tree to the map.
   * @function addLayerTree
   * @param {Object} options - Options for the layer tree to add.
   * @param {Object} options.features - Features for the layer tree.
   * @param {string} options.id - Unique identifier for the layer tree.
   * @param {string} options.type - Type of layer tree ('geojson', 'raster', etc.).
   */
  addLayerTree(e) {
    try {
      let t = e.features, n = document.getElementById("map"), i = document.createElement("nav");
      i.id = "filter-group", n.appendChild(i);
      const s = document.getElementById("filter-group");
      this.map.addSource(`${e.id}`, {
        type: e.type,
        data: t
      }), t.features.forEach((l) => {
        const o = l.properties.icon, d = `poi-${o}`;
        if (!this.map.getLayer(d)) {
          this.map.addLayer({
            id: d,
            type: "circle",
            source: `${e.id}`,
            paint: {
              "circle-radius": 6,
              "circle-color": "#B42222"
            },
            filter: ["==", "icon", o]
          }, this._firstSymbolLayer());
          const m = document.createElement("input");
          m.type = "checkbox", m.id = d, m.checked = !0, s.appendChild(m);
          const b = document.createElement("label");
          b.setAttribute("for", d), b.textContent = o, s.appendChild(b), m.addEventListener("change", (A) => {
            this.map.setLayoutProperty(d, "visibility", A.target.checked ? "visible" : "none");
          });
        }
      });
    } catch (t) {
      console.error(`Error adding layer tree: ${t.message}`);
    }
  }
  /**
   * Creates a navigation control with the provided options.
   * @function createNavigationControl
   * @param {Object} options - Options for the navigation control.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   * @returns {Object} - Instance of the created navigation control.
   */
  createNavigationControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), this.map.addControl(new po.NavigationControl(e), t);
    } catch (n) {
      return console.error(`Error creating navigation control: ${n.message}`), null;
    }
  }
  /**
   * Adds a navigation control to the map with the provided options.
   * @function addNavigationControl
   * @param {Object} options - Options for the navigation control.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addNavigationControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), this.map.addControl(new po.NavigationControl(e), t);
    } catch (n) {
      console.error(`Error adding navigation control: ${n.message}`);
    }
  }
  /**
   * Adds an attribution control to the map with the provided options.
   * @function addAttributionControl
   * @param {Object} options - Options for the attribution control.
   * @param {string} [position='bottom-right'] - Position to add the control on the map.
   */
  addAttributionControl(e, t) {
    try {
      this.map.addControl(new po.AttributionControl(e), t);
    } catch (n) {
      console.error(`Error adding attribution control: ${n.message}`);
    }
  }
  /**
   * Adds an ICGC image layer to the map based on the specified name and year.
   * @function addImageLayerICGC
   * @param {string} url - The url of the  layer.
   * @param {string} idLayer - The user id for the  layer.
   * @param {object} options - Type, position,layout and paint options for the layer
   */
  addImageLayerICGC(e, t, n) {
    try {
      let i = null, s, l;
      n ? (l = n, s = n.layerPosition) : l = {
        type: "raster",
        layout: {
          visibility: "visible"
        },
        paint: {
          "raster-opacity": 1
        },
        layerPosition: s_
      }, i = this._findImageType(e, fs.Orto, fs.VectorAdmin, fs.WMS, fs.Vector), i || console.log("❌ %c The layer: %c%s%c does not exist in the ICGC DB. Consult the documentation.", "font-weight: bold; font-style: italic;", "font-weight: normal; font-style: normal; color: red;", e, "font-weight: bold; font-style: italic;");
      let o = {
        id: t,
        tiles: e
      };
      this.addLayerWMS(e, t, l);
    } catch (i) {
      console.error(`Error adding ICGC image layer: ${i.message}`);
    }
  }
  /**
   * Adds an ICGC vector layer to the map based on the specified name and year.
   * @function addVectorLayerICGC
   * @param {string} url - The url of the vector layer.
   * @param {string} idLayer - The user id for the vector layer.
   * @param {object} options - Type, position,layout and paint options for the layer
   *
   */
  async addVectorLayerICGC(e, t, n) {
    try {
      let {
        type: i = "line",
        layerPosition: s = s_,
        layoutOptions: l = {
          visibility: "visible"
        },
        paintOption: o
      } = n || {}, d = this._dealOrderLayer(s);
      if (!e) {
        console.log("❌ %c The layer: %c%s%c does not exist in the ICGC DB. Consult the documentation.", "font-weight: bold; font-style: italic;", "font-weight: normal; font-style: normal; color: red;", e, "font-weight: bold; font-style: italic;");
        return;
      }
      if (e.includes("https")) {
        let m = this._getKeyByUrlVector(e);
        this.map.addSource(m, {
          type: "vector",
          url: e
        });
        let b = {
          id: m,
          type: "fill",
          source: m,
          "source-layer": "cobertes",
          maxzoom: 18,
          layout: n.layout,
          paint: tJ.cobertesSol
        };
        if (m === "cobertes2018" && this.map.addLayer(b, d), l.visibility === "visible") {
          let A = this._getLegendByName(m);
          this.addLegend(A, m);
        }
      } else {
        let m = t;
        this.map.addSource(m, {
          type: "vector",
          url: si.limitsUrl
        });
        let b = {
          id: t,
          type: i,
          source: m,
          "source-layer": e,
          layout: n.layout,
          paint: n.paint || {}
        };
        i === "fill" || i === "polygon" ? b.paint = o || {
          "fill-color": "#0000FF",
          "fill-opacity": 0
        } : i === "line" && (b.paint = o || {
          "line-color": "#4832a8",
          "line-opacity": 1,
          "line-width": 1
        }), this.map.addLayer(b, d);
      }
    } catch (i) {
      console.error(`Error adding ICGC vector layer: ${i.message}`);
    }
  }
  /**
   * Adds an ICGC FGB layer to the map based on the specified name and year.
   * @function addFGBLayerICGC
   * @param {string} url - The url of the FGB layer.
   * @param {string} idLayer - Id for the layer.
   * @param {object} options - Paint option for the layer
   *
   */
  async addFGBLayerICGC(e, t, n) {
    try {
      n || (n.layout = {
        visibility: !0
      }, n.paint = {
        "line-color": "#4832a8",
        "line-opacity": 1,
        "line-width": 1
      }, n.type = "lines", n.layerPosition = "labels");
      let i = this._dealOrderLayer(n.layerPosition);
      const s = await fetch(e), l = {
        type: "FeatureCollection",
        features: []
      };
      for await (const d of wA(s.body)) l.features.push(d);
      let o = t;
      this.map.addSource(o, {
        type: "geojson",
        data: l
      }), e.includes("text") ? this.map.addLayer({
        id: t,
        type: "symbol",
        source: o,
        layout: {
          "text-letter-spacing": 0.1,
          "text-size": {
            base: 1.2,
            stops: [[8, 0], [12, 14], [15, 15]]
          },
          "text-font": ["FiraSans-Regular"],
          "text-field": ["get", "NOM_AC"],
          "text-transform": "none",
          "text-max-width": 25,
          visibility: n.layout.visibility,
          "text-justify": "right",
          "text-anchor": "top",
          "text-allow-overlap": !1,
          "symbol-spacing": 2,
          "text-line-height": 1
        },
        paint: {
          "text-halo-blur": 0.5,
          "text-color": "rgba(90, 7, 7, 1)",
          "text-halo-width": 2,
          "text-halo-color": "rgba(255, 255, 255,0.8)"
        }
      }, i) : this.map.addLayer({
        id: t,
        type: n.type,
        source: o,
        layout: n.layout,
        paint: n.paint
      }, i);
    } catch (i) {
      console.error(`Error adding ICGC FGB layer: ${i.message}`);
    }
  }
  /**
   * Adds 3D terrain to the map using hillshade.
   * @function addTerrainICGC
   * @param {string} url - dataset url of the terrain
   * @param {string} controlPosition - Position to add the control on the map.
   */
  addTerrainICGC(e, t) {
    try {
      let n;
      for (const s in sg)
        if (sg.hasOwnProperty(s)) {
          const l = sg[s];
          l === e && (n = l);
        }
      let i = n;
      this.getSource("terrainICGC") !== void 0 && (this.getStyle().layers.forEach((l) => {
        l.source === "terrainICGC" && this.removeLayer(l.id);
      }), this.removeSource("terrainICGC")), this.getSource("terrainICGC") === void 0 && (e.includes("terrarium") ? this.map.addSource("terrainICGC", {
        type: "raster-dem",
        tiles: [i],
        tileSize: 512,
        encoding: "terrarium",
        maxzoom: 16
      }) : this.map.addSource("terrainICGC", {
        type: "raster-dem",
        tiles: [i],
        tileSize: 256,
        maxzoom: 14,
        minzoom: 7
      })), this.map.setTerrain({
        source: "terrainICGC",
        exaggeration: 1.5
      }), t == null || this.map.addControl(new U4({
        pitch: 90,
        bearing: null,
        minpitchzoom: null
      }), t);
    } catch (n) {
      console.error(`Error adding 3D terrain: ${n.message}`);
    }
  }
  /**
   * Add image legend.
   * @function addLegend
   * @param {string} url - image legend url.
   * @param {string} idLayer - layer's name.
   */
  addLegend(e, t) {
    try {
      this.map.addControl(new mY({
        url: e,
        idLayer: t
      }));
    } catch (n) {
      console.error(`Error adding legend: ${n.message}`);
    }
  }
  //Internal methods
  /**
   * Finds the type of image based on the provided URL and specified vectors.
   * @function _findImageType
   * @param {string} url - The URL of the image to find the type for.
   * @param {Object} var1 - The first vector object containing key-value pairs.
   * @param {Object} var2 - The second vector object containing key-value pairs.
   * @param {Object} var3 - The third vector object containing key-value pairs.
   * @param {Object} var4 - The fourth vector object containing key-value pairs.
   * @returns {string|null} - The type of image if found, otherwise null.
   */
  _findImageType(e, t, n, i, s) {
    const l = [t, n, i, s];
    for (const o of l)
      for (const [d, m] of Object.entries(o))
        if (m === e)
          return d;
    return null;
  }
  /**
   * Gets the key by URL from the FGBAdmin layers.
   * @function _getKeyByUrlFGB
   * @param {string} url - The URL to find the key for in the FGBAdmin layers.
   * @returns {string|null} - The key if found, otherwise null.
   */
  _getKeyByUrlFGB(e) {
    for (const t in fs.FGBAdmin)
      if (fs.FGBAdmin.hasOwnProperty(t) && fs.FGBAdmin[t] === e)
        return t;
    return null;
  }
  /**
   * Gets the legend by name from the default vector layers.
   * @function _getLegendByName
   * @param {string} name - The name of the vector layer to get the legend for.
   * @returns {string|null} - The legend if found, otherwise null.
   */
  _getLegendByName(e) {
    for (const t in si.vectorLayers) {
      const n = si.vectorLayers[t];
      if (n.key === e)
        return n.legend;
    }
    return null;
  }
  /**
   * Gets the key by URL from the Vector layers.
   * @function _getKeyByUrlVector
   * @param {string} url - The URL to find the key for in the Vector layers.
   * @returns {string|null} - The key if found, otherwise null.
   */
  _getKeyByUrlVector(e) {
    for (const t in fs.Vector)
      if (fs.Vector.hasOwnProperty(t) && fs.Vector[t] === e)
        return t;
    return null;
  }
  /**
   * Raises text 3D style on the map.
   * @function _raiseText3DStyle
   * @async
   * @returns {Promise<void>} - A promise that resolves after updating the text 3D style on the map.
   */
  async _raiseText3DStyle() {
    try {
      const e = await this.map.loadImage(si.map3dOptions.imageIcon);
      this.map.hasImage("stick") || this.map.addImage("stick", e.data), this.map.getStyle().layers.forEach((t) => {
        if (t["source-layer"] === si.map3dOptions.sourceLayerFilterId && t.minzoom >= si.map3dOptions.minZoomFilter && e) {
          const n = t.id;
          this.map.setLayoutProperty(n, "icon-image", "stick"), this.map.setLayoutProperty(n, "text-offset", [0, -9]), this.map.setLayoutProperty(n, "symbol-placement", "point"), this.map.setLayoutProperty(n, "symbol-avoid-edges", !1), this.map.setLayoutProperty(n, "text-allow-overlap", !0), this.map.setLayoutProperty(n, "text-ignore-placement", !1), this.map.setLayoutProperty(n, "text-pitch-alignment", "auto"), this.map.setLayoutProperty(n, "text-rotation-alignment", "auto"), this.map.setLayoutProperty(n, "text-justify", "center"), this.map.setLayoutProperty(n, "text-anchor", "bottom"), this.map.setLayoutProperty(n, "icon-anchor", "bottom"), this.map.setPaintProperty(n, "text-color", "#ffffff"), this.map.setPaintProperty(n, "text-halo-color", "#000000"), this.map.setPaintProperty(n, "text-halo-width", 2);
        }
      });
    } catch (e) {
      return console.error(`Error dealing orto 3D: ${e.message}`), null;
    }
  }
  /**
   * Deals with map styles based on the name.
   * @function _dealStyleMaps
   * @param {string} name - The name of the map style.
   * @returns {Object|string|null} - The map style object if found, or the input name if not found, or null if an error occurs.
   */
  _dealStyleMaps(e) {
    try {
      if (e && e.indexOf("icgc.cat") != -1) {
        for (const t in wf)
          if (wf.hasOwnProperty(t)) {
            const n = wf[t];
            if (t === e)
              return n;
          }
        return wf[0];
      } else
        return e;
    } catch (t) {
      return console.error(`Error dealing with map styles: ${t.message}`), null;
    }
  }
  /**
   * Deals with the 3D ortho style based on the name.
   * @function _dealOrto3dStyle
   * @param {string} name - The name of the orto3D style.
   * @returns {void|null} - Returns null if an error occurs.
   */
  _dealOrto3dStyle(e) {
    try {
      if (e == "orto3d") {
        this.map.setMaxZoom(18.8), this.map.easeTo({
          pitch: 45
        });
        const t = new F5({
          intensity: 4
        }), n = new H2({
          ambientLight: t
        });
        this.map.setTerrain({
          source: si.map3dOptions.terrainSource,
          exaggeration: si.map3dOptions.exaggeration
        }), dl = new Ij({
          interleaved: !0,
          layers: [this._createCitiesMapboxLayer(!1)],
          // Inicialment invisible
          effects: [n],
          onAfterRender: () => {
            try {
              const s = this.map.getZoom() >= si.map3dOptions.minZoomRange;
              dl.setProps({
                layers: [this._createCitiesMapboxLayer(s)]
              });
            } catch {
              console.log("No render 3D Mesh");
            }
          }
        }), this.map.hasControl(dl) || (this.map.addControl(dl), this._raiseText3DStyle()), this.map.setSky({
          "sky-color": "#86bbd5",
          "sky-horizon-blend": 0.3,
          "horizon-color": "#ffffff33",
          "horizon-fog-blend": 0.1,
          "fog-ground-blend": 0.75,
          "fog-color": "#c5d6d6"
        }), this.map.on("zoomend", () => {
          !this.map.getStyle().name == "orto3d" && this.map.hasControl(dl) && (this.map.removeControl(dl), dl.setProps({
            layers: []
          }), this.map.setTerrain(null));
        });
      } else
        dl == null || dl.setProps({
          layers: []
        }), this.map.hasControl(dl) && (this.map.removeControl(dl), dl.setProps({
          layers: []
        }), this.map.setTerrain(null));
    } catch (t) {
      return console.error(`Error dealing orto 3D: ${t.message}`), null;
    }
  }
  /**
   * Deals with the order of the layer.
   * @function _dealOrderLayer
   * @param {string} order - The order of the layer.
   * @returns {string} - The id of the first symbol layer if the order is 'symbol', the id of the first line layer if the order is 'line', otherwise an empty string.
   */
  _dealOrderLayer(e) {
    return e === s_ ? this._firstSymbolLayer() : e === rJ ? this._firstLineLayer() : "";
  }
  /**
   * Retrieves the id of the first symbol layer.
   * @function _firstSymbolLayer
   * @returns {string|undefined} - The id of the first symbol layer if found, otherwise undefined.
   */
  _firstSymbolLayer() {
    try {
      const e = this.map.getStyle().layers;
      let t;
      for (let n = 0; n < e.length; n++)
        if (e[n].type === "symbol" && e[n].id.indexOf("contour") === -1 && e[n].id.indexOf("water") === -1) {
          t = e[n].id;
          break;
        }
      return t;
    } catch (e) {
      console.error(`Error getting first symbol layer: ${e.message}`);
    }
  }
  /**
   * Retrieves the id of the first line layer.
   * @function _firstLineLayer
   * @returns {string|undefined} - The id of the first line layer if found, otherwise undefined.
   */
  _firstLineLayer() {
    try {
      const e = this.map.getStyle().layers;
      let t;
      for (let n = 0; n < e.length; n++)
        if (e[n].type === "line") {
          t = e[n].id;
          break;
        }
      return t;
    } catch (e) {
      console.error(`Error getting first symbol layer: ${e.message}`);
    }
  }
  /**
   * Creates a Mapbox layer for displaying cities in 3D.
   * @function _createCitiesMapboxLayer
   * @returns {MapboxLayer|null} - The Mapbox layer for displaying cities in 3D if created successfully, otherwise null.
   */
  _createCitiesMapboxLayer() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    try {
      return new vx({
        id: si.map3dOptions.layerId3d,
        data: si.map3dOptions.urlTilesetCities,
        loader: bx,
        beforeId: si.map3dOptions.layerIdOrder,
        visible: e,
        loadOptions: {
          tileset: {
            viewDistanceScale: 1,
            memoryAdjustedScreenSpaceError: si.map3dOptions.spaceErrorFactor,
            updateTransforms: !0,
            adjustScreenSpaceError: si.map3dOptions.spaceErrorFactor
            // Aplicació inicial
          }
        },
        onTilesetLoad: (t) => {
          t.adjustScreenSpaceError = si.map3dOptions.spaceErrorFactor, t.memoryAdjustedScreenSpaceError = si.map3dOptions.spaceErrorFactor;
        },
        onTileLoad: (t) => {
          t.content.cartographicOrigin.z -= si.map3dOptions.zfactor;
        },
        operation: "terrain+draw",
        pickable: !1
      });
    } catch (t) {
      return console.error(`Error adding MapboxOverlay: ${t.message}`), null;
    }
  }
};
var E1 = { exports: {} }, C1, PE;
function nJ() {
  if (PE) return C1;
  PE = 1;
  function r(t, n) {
    var i = t.getCenter(), s = t.getZoom(), l = t.getBearing(), o = t.getPitch();
    n.forEach(function(d) {
      d.jumpTo({
        center: i,
        zoom: s,
        bearing: l,
        pitch: o
      });
    });
  }
  function e() {
    var t, n = arguments.length;
    if (n === 1)
      t = arguments[0];
    else {
      t = [];
      for (var i = 0; i < n; i++)
        t.push(arguments[i]);
    }
    var s = [];
    t.forEach(function(m, b) {
      s[b] = d.bind(null, m, t.filter(function(A, M) {
        return M !== b;
      }));
    });
    function l() {
      t.forEach(function(m, b) {
        m.on("move", s[b]);
      });
    }
    function o() {
      t.forEach(function(m, b) {
        m.off("move", s[b]);
      });
    }
    function d(m, b) {
      o(), r(m, b), l();
    }
    return l(), function() {
      o(), s = [], t = [];
    };
  }
  return C1 = e, C1;
}
var o_ = { exports: {} }, RE;
function iJ() {
  if (RE) return o_.exports;
  RE = 1;
  var r = typeof Reflect == "object" ? Reflect : null, e = r && typeof r.apply == "function" ? r.apply : function(K, ie, be) {
    return Function.prototype.apply.call(K, ie, be);
  }, t;
  r && typeof r.ownKeys == "function" ? t = r.ownKeys : Object.getOwnPropertySymbols ? t = function(K) {
    return Object.getOwnPropertyNames(K).concat(Object.getOwnPropertySymbols(K));
  } : t = function(K) {
    return Object.getOwnPropertyNames(K);
  };
  function n(Z) {
    console && console.warn && console.warn(Z);
  }
  var i = Number.isNaN || function(K) {
    return K !== K;
  };
  function s() {
    s.init.call(this);
  }
  o_.exports = s, o_.exports.once = q, s.EventEmitter = s, s.prototype._events = void 0, s.prototype._eventsCount = 0, s.prototype._maxListeners = void 0;
  var l = 10;
  function o(Z) {
    if (typeof Z != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof Z);
  }
  Object.defineProperty(s, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return l;
    },
    set: function(Z) {
      if (typeof Z != "number" || Z < 0 || i(Z))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + Z + ".");
      l = Z;
    }
  }), s.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, s.prototype.setMaxListeners = function(K) {
    if (typeof K != "number" || K < 0 || i(K))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + K + ".");
    return this._maxListeners = K, this;
  };
  function d(Z) {
    return Z._maxListeners === void 0 ? s.defaultMaxListeners : Z._maxListeners;
  }
  s.prototype.getMaxListeners = function() {
    return d(this);
  }, s.prototype.emit = function(K) {
    for (var ie = [], be = 1; be < arguments.length; be++) ie.push(arguments[be]);
    var he = K === "error", Be = this._events;
    if (Be !== void 0) he = he && Be.error === void 0;
    else if (!he) return !1;
    if (he) {
      var ke;
      if (ie.length > 0 && (ke = ie[0]), ke instanceof Error)
        throw ke;
      var pe = new Error("Unhandled error." + (ke ? " (" + ke.message + ")" : ""));
      throw pe.context = ke, pe;
    }
    var me = Be[K];
    if (me === void 0) return !1;
    if (typeof me == "function")
      e(me, this, ie);
    else
      for (var je = me.length, Pe = k(me, je), be = 0; be < je; ++be) e(Pe[be], this, ie);
    return !0;
  };
  function m(Z, K, ie, be) {
    var he, Be, ke;
    if (o(ie), Be = Z._events, Be === void 0 ? (Be = Z._events = /* @__PURE__ */ Object.create(null), Z._eventsCount = 0) : (Be.newListener !== void 0 && (Z.emit("newListener", K, ie.listener ? ie.listener : ie), Be = Z._events), ke = Be[K]), ke === void 0)
      ke = Be[K] = ie, ++Z._eventsCount;
    else if (typeof ke == "function" ? ke = Be[K] = be ? [ie, ke] : [ke, ie] : be ? ke.unshift(ie) : ke.push(ie), he = d(Z), he > 0 && ke.length > he && !ke.warned) {
      ke.warned = !0;
      var pe = new Error("Possible EventEmitter memory leak detected. " + ke.length + " " + String(K) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      pe.name = "MaxListenersExceededWarning", pe.emitter = Z, pe.type = K, pe.count = ke.length, n(pe);
    }
    return Z;
  }
  s.prototype.addListener = function(K, ie) {
    return m(this, K, ie, !1);
  }, s.prototype.on = s.prototype.addListener, s.prototype.prependListener = function(K, ie) {
    return m(this, K, ie, !0);
  };
  function b() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function A(Z, K, ie) {
    var be = {
      fired: !1,
      wrapFn: void 0,
      target: Z,
      type: K,
      listener: ie
    }, he = b.bind(be);
    return he.listener = ie, be.wrapFn = he, he;
  }
  s.prototype.once = function(K, ie) {
    return o(ie), this.on(K, A(this, K, ie)), this;
  }, s.prototype.prependOnceListener = function(K, ie) {
    return o(ie), this.prependListener(K, A(this, K, ie)), this;
  }, s.prototype.removeListener = function(K, ie) {
    var be, he, Be, ke, pe;
    if (o(ie), he = this._events, he === void 0) return this;
    if (be = he[K], be === void 0) return this;
    if (be === ie || be.listener === ie)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete he[K], he.removeListener && this.emit("removeListener", K, be.listener || ie));
    else if (typeof be != "function") {
      for (Be = -1, ke = be.length - 1; ke >= 0; ke--)
        if (be[ke] === ie || be[ke].listener === ie) {
          pe = be[ke].listener, Be = ke;
          break;
        }
      if (Be < 0) return this;
      Be === 0 ? be.shift() : U(be, Be), be.length === 1 && (he[K] = be[0]), he.removeListener !== void 0 && this.emit("removeListener", K, pe || ie);
    }
    return this;
  }, s.prototype.off = s.prototype.removeListener, s.prototype.removeAllListeners = function(K) {
    var ie, be, he;
    if (be = this._events, be === void 0) return this;
    if (be.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : be[K] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete be[K]), this;
    if (arguments.length === 0) {
      var Be = Object.keys(be), ke;
      for (he = 0; he < Be.length; ++he)
        ke = Be[he], ke !== "removeListener" && this.removeAllListeners(ke);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (ie = be[K], typeof ie == "function")
      this.removeListener(K, ie);
    else if (ie !== void 0)
      for (he = ie.length - 1; he >= 0; he--)
        this.removeListener(K, ie[he]);
    return this;
  };
  function M(Z, K, ie) {
    var be = Z._events;
    if (be === void 0) return [];
    var he = be[K];
    return he === void 0 ? [] : typeof he == "function" ? ie ? [he.listener || he] : [he] : ie ? V(he) : k(he, he.length);
  }
  s.prototype.listeners = function(K) {
    return M(this, K, !0);
  }, s.prototype.rawListeners = function(K) {
    return M(this, K, !1);
  }, s.listenerCount = function(Z, K) {
    return typeof Z.listenerCount == "function" ? Z.listenerCount(K) : E.call(Z, K);
  }, s.prototype.listenerCount = E;
  function E(Z) {
    var K = this._events;
    if (K !== void 0) {
      var ie = K[Z];
      if (typeof ie == "function")
        return 1;
      if (ie !== void 0)
        return ie.length;
    }
    return 0;
  }
  s.prototype.eventNames = function() {
    return this._eventsCount > 0 ? t(this._events) : [];
  };
  function k(Z, K) {
    for (var ie = new Array(K), be = 0; be < K; ++be) ie[be] = Z[be];
    return ie;
  }
  function U(Z, K) {
    for (; K + 1 < Z.length; K++) Z[K] = Z[K + 1];
    Z.pop();
  }
  function V(Z) {
    for (var K = new Array(Z.length), ie = 0; ie < K.length; ++ie)
      K[ie] = Z[ie].listener || Z[ie];
    return K;
  }
  function q(Z, K) {
    return new Promise(function(ie, be) {
      function he(ke) {
        Z.removeListener(K, Be), be(ke);
      }
      function Be() {
        typeof Z.removeListener == "function" && Z.removeListener("error", he), ie([].slice.call(arguments));
      }
      re(Z, K, Be, {
        once: !0
      }), K !== "error" && Y(Z, he, {
        once: !0
      });
    });
  }
  function Y(Z, K, ie) {
    typeof Z.on == "function" && re(Z, "error", K, ie);
  }
  function re(Z, K, ie, be) {
    if (typeof Z.on == "function")
      be.once ? Z.once(K, ie) : Z.on(K, ie);
    else if (typeof Z.addEventListener == "function")
      Z.addEventListener(K, function he(Be) {
        be.once && Z.removeEventListener(K, he), ie(Be);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof Z);
  }
  return o_.exports;
}
var BE;
function sJ() {
  return BE || (BE = 1, function(r) {
    var e = nJ(), t = iJ().EventEmitter;
    function n(i, s, l, o) {
      if (this.options = o || {}, this._mapA = i, this._mapB = s, this._horizontal = this.options.orientation === "horizontal", this._onDown = this._onDown.bind(this), this._onMove = this._onMove.bind(this), this._onMouseUp = this._onMouseUp.bind(this), this._onTouchEnd = this._onTouchEnd.bind(this), this._ev = new t(), this._swiper = document.createElement("div"), this._swiper.className = this._horizontal ? "compare-swiper-horizontal" : "compare-swiper-vertical", this._controlContainer = document.createElement("div"), this._controlContainer.className = this._horizontal ? "maplibregl-compare maplibregl-compare-horizontal" : "maplibregl-compare", this._controlContainer.className = this._controlContainer.className, this._controlContainer.appendChild(this._swiper), typeof l == "string" && document.body.querySelectorAll) {
        var d = document.body.querySelectorAll(l)[0];
        if (!d)
          throw new Error("Cannot find element with specified container selector.");
        d.appendChild(this._controlContainer);
      } else if (l instanceof Element && l.appendChild)
        l.appendChild(this._controlContainer);
      else
        throw new Error("Invalid container specified. Must be CSS selector or HTML element.");
      this._bounds = s.getContainer().getBoundingClientRect();
      var m = (this._horizontal ? this._bounds.height : this._bounds.width) / 2;
      this._setPosition(m), this._clearSync = e(i, s), this._onResize = (function() {
        this._bounds = s.getContainer().getBoundingClientRect(), this.currentPosition && this._setPosition(this.currentPosition);
      }).bind(this), s.on("resize", this._onResize), this.options && this.options.mousemove && (i.getContainer().addEventListener("mousemove", this._onMove), s.getContainer().addEventListener("mousemove", this._onMove)), this._swiper.addEventListener("mousedown", this._onDown), this._swiper.addEventListener("touchstart", this._onDown);
    }
    n.prototype = {
      _setPointerEvents: function(i) {
        this._controlContainer.style.pointerEvents = i, this._swiper.style.pointerEvents = i;
      },
      _onDown: function(i) {
        i.touches ? (document.addEventListener("touchmove", this._onMove), document.addEventListener("touchend", this._onTouchEnd)) : (document.addEventListener("mousemove", this._onMove), document.addEventListener("mouseup", this._onMouseUp));
      },
      _setPosition: function(i) {
        i = Math.min(i, this._horizontal ? this._bounds.height : this._bounds.width);
        var s = this._horizontal ? "translate(0, " + i + "px)" : "translate(" + i + "px, 0)";
        this._controlContainer.style.transform = s, this._controlContainer.style.WebkitTransform = s;
        var l = this._horizontal ? "rect(0, 999em, " + i + "px, 0)" : "rect(0, " + i + "px, " + this._bounds.height + "px, 0)", o = this._horizontal ? "rect(" + i + "px, 999em, " + this._bounds.height + "px,0)" : "rect(0, 999em, " + this._bounds.height + "px," + i + "px)";
        this._mapA.getContainer().style.clip = l, this._mapB.getContainer().style.clip = o, this.currentPosition = i;
      },
      _onMove: function(i) {
        this.options && this.options.mousemove && this._setPointerEvents(i.touches ? "auto" : "none"), this._horizontal ? this._setPosition(this._getY(i)) : this._setPosition(this._getX(i));
      },
      _onMouseUp: function() {
        document.removeEventListener("mousemove", this._onMove), document.removeEventListener("mouseup", this._onMouseUp), this.fire("slideend", {
          currentPosition: this.currentPosition
        });
      },
      _onTouchEnd: function() {
        document.removeEventListener("touchmove", this._onMove), document.removeEventListener("touchend", this._onTouchEnd), this.fire("slideend", {
          currentPosition: this.currentPosition
        });
      },
      _getX: function(i) {
        i = i.touches ? i.touches[0] : i;
        var s = i.clientX - this._bounds.left;
        return s < 0 && (s = 0), s > this._bounds.width && (s = this._bounds.width), s;
      },
      _getY: function(i) {
        i = i.touches ? i.touches[0] : i;
        var s = i.clientY - this._bounds.top;
        return s < 0 && (s = 0), s > this._bounds.height && (s = this._bounds.height), s;
      },
      /**
       * Set the position of the slider.
       *
       * @param {number} x Slider position in pixels from left/top.
       */
      setSlider: function(i) {
        this._setPosition(i);
      },
      /**
       * Adds a listener for events of a specified type.
       *
       * @param {string} type The event type to listen for; one of `slideend`.
       * @param {Function} listener The function to be called when the event is fired.
       * @returns {Compare} `this`
       */
      on: function(i, s) {
        return this._ev.on(i, s), this;
      },
      /**
       * Fire an event of a specified type.
       *
       * @param {string} type The event type to fire; one of `slideend`.
       * @param {Object} data Data passed to the event listener.
       * @returns {Compare} `this`
       */
      fire: function(i, s) {
        return this._ev.emit(i, s), this;
      },
      /**
       * Removes an event listener previously added with `Compare#on`.
       *
       * @param {string} type The event type previously used to install the listener.
       * @param {Function} listener The function previously installed as a listener.
       * @returns {Compare} `this`
       */
      off: function(i, s) {
        return this._ev.removeListener(i, s), this;
      },
      remove: function() {
        this._clearSync(), this._mapB.off("resize", this._onResize);
        var i = this._mapA.getContainer();
        i && (i.style.clip = null, i.removeEventListener("mousemove", this._onMove));
        var s = this._mapB.getContainer();
        s && (s.style.clip = null, s.removeEventListener("mousemove", this._onMove)), this._swiper.removeEventListener("mousedown", this._onDown), this._swiper.removeEventListener("touchstart", this._onDown), this._controlContainer.remove();
      }
    }, window.maplibregl ? maplibregl.Compare = n : r.exports = n;
  }(E1)), E1.exports;
}
var oJ = sJ();
const aJ = /* @__PURE__ */ e2(oJ);
class zJ {
  /**
   * Constructor for the map comparison class.
   * @class MapComparison
   * @param {Object} map1 - The first map object to compare.
   * @param {Object} map2 - The second map object to compare.
   * @param {string} container - The HTML container element ID for displaying the comparison.
   * @param {Object} options - Additional options for map comparison (if needed).
   */
  constructor(e, t, n, i) {
    const s = this;
    setTimeout(function() {
      s.mapCompare = new aJ(e.map, t.map, n, {});
    }, 1e3);
  }
}
export {
  zJ as C,
  FJ as M,
  QK as a,
  ci as d
};
