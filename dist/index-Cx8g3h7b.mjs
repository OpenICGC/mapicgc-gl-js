function YC(n, e) {
  for (var t = 0; t < e.length; t++) {
    const i = e[t];
    if (typeof i != "string" && !Array.isArray(i)) {
      for (const r in i)
        if (r !== "default" && !(r in n)) {
          const s = Object.getOwnPropertyDescriptor(i, r);
          s && Object.defineProperty(n, r, s.get ? s : {
            enumerable: !0,
            get: () => i[r]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
var Ed = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ap(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var h5 = { exports: {} };
(function(n, e) {
  (function(t, i) {
    n.exports = i();
  })(Ed, function() {
    var t = {}, i = {};
    function r(c, l, m) {
      if (i[c] = m, c === "index") {
        var y = "var sharedModule = {}; (" + i.shared + ")(sharedModule); (" + i.worker + ")(sharedModule);", A = {};
        return i.shared(A), i.index(t, A), typeof window < "u" && t.setWorkerUrl(window.URL.createObjectURL(new Blob([y], { type: "text/javascript" }))), t;
      }
    }
    r("shared", ["exports"], function(c) {
      function l(u, o, d, g) {
        return new (d || (d = Promise))(function(v, w) {
          function S(k) {
            try {
              B(g.next(k));
            } catch (j) {
              w(j);
            }
          }
          function P(k) {
            try {
              B(g.throw(k));
            } catch (j) {
              w(j);
            }
          }
          function B(k) {
            var j;
            k.done ? v(k.value) : (j = k.value, j instanceof d ? j : new d(function(q) {
              q(j);
            })).then(S, P);
          }
          B((g = g.apply(u, o || [])).next());
        });
      }
      function m(u) {
        return u && u.__esModule && Object.prototype.hasOwnProperty.call(u, "default") ? u.default : u;
      }
      typeof SuppressedError == "function" && SuppressedError;
      var y = A;
      function A(u, o) {
        this.x = u, this.y = o;
      }
      A.prototype = { clone: function() {
        return new A(this.x, this.y);
      }, add: function(u) {
        return this.clone()._add(u);
      }, sub: function(u) {
        return this.clone()._sub(u);
      }, multByPoint: function(u) {
        return this.clone()._multByPoint(u);
      }, divByPoint: function(u) {
        return this.clone()._divByPoint(u);
      }, mult: function(u) {
        return this.clone()._mult(u);
      }, div: function(u) {
        return this.clone()._div(u);
      }, rotate: function(u) {
        return this.clone()._rotate(u);
      }, rotateAround: function(u, o) {
        return this.clone()._rotateAround(u, o);
      }, matMult: function(u) {
        return this.clone()._matMult(u);
      }, unit: function() {
        return this.clone()._unit();
      }, perp: function() {
        return this.clone()._perp();
      }, round: function() {
        return this.clone()._round();
      }, mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, equals: function(u) {
        return this.x === u.x && this.y === u.y;
      }, dist: function(u) {
        return Math.sqrt(this.distSqr(u));
      }, distSqr: function(u) {
        var o = u.x - this.x, d = u.y - this.y;
        return o * o + d * d;
      }, angle: function() {
        return Math.atan2(this.y, this.x);
      }, angleTo: function(u) {
        return Math.atan2(this.y - u.y, this.x - u.x);
      }, angleWith: function(u) {
        return this.angleWithSep(u.x, u.y);
      }, angleWithSep: function(u, o) {
        return Math.atan2(this.x * o - this.y * u, this.x * u + this.y * o);
      }, _matMult: function(u) {
        var o = u[2] * this.x + u[3] * this.y;
        return this.x = u[0] * this.x + u[1] * this.y, this.y = o, this;
      }, _add: function(u) {
        return this.x += u.x, this.y += u.y, this;
      }, _sub: function(u) {
        return this.x -= u.x, this.y -= u.y, this;
      }, _mult: function(u) {
        return this.x *= u, this.y *= u, this;
      }, _div: function(u) {
        return this.x /= u, this.y /= u, this;
      }, _multByPoint: function(u) {
        return this.x *= u.x, this.y *= u.y, this;
      }, _divByPoint: function(u) {
        return this.x /= u.x, this.y /= u.y, this;
      }, _unit: function() {
        return this._div(this.mag()), this;
      }, _perp: function() {
        var u = this.y;
        return this.y = this.x, this.x = -u, this;
      }, _rotate: function(u) {
        var o = Math.cos(u), d = Math.sin(u), g = d * this.x + o * this.y;
        return this.x = o * this.x - d * this.y, this.y = g, this;
      }, _rotateAround: function(u, o) {
        var d = Math.cos(u), g = Math.sin(u), v = o.y + g * (this.x - o.x) + d * (this.y - o.y);
        return this.x = o.x + d * (this.x - o.x) - g * (this.y - o.y), this.y = v, this;
      }, _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      } }, A.convert = function(u) {
        return u instanceof A ? u : Array.isArray(u) ? new A(u[0], u[1]) : u;
      };
      var T = m(y), I = L;
      function L(u, o, d, g) {
        this.cx = 3 * u, this.bx = 3 * (d - u) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * o, this.by = 3 * (g - o) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = u, this.p1y = o, this.p2x = d, this.p2y = g;
      }
      L.prototype = { sampleCurveX: function(u) {
        return ((this.ax * u + this.bx) * u + this.cx) * u;
      }, sampleCurveY: function(u) {
        return ((this.ay * u + this.by) * u + this.cy) * u;
      }, sampleCurveDerivativeX: function(u) {
        return (3 * this.ax * u + 2 * this.bx) * u + this.cx;
      }, solveCurveX: function(u, o) {
        if (o === void 0 && (o = 1e-6), u < 0)
          return 0;
        if (u > 1)
          return 1;
        for (var d = u, g = 0; g < 8; g++) {
          var v = this.sampleCurveX(d) - u;
          if (Math.abs(v) < o)
            return d;
          var w = this.sampleCurveDerivativeX(d);
          if (Math.abs(w) < 1e-6)
            break;
          d -= v / w;
        }
        var S = 0, P = 1;
        for (d = u, g = 0; g < 20 && (v = this.sampleCurveX(d), !(Math.abs(v - u) < o)); g++)
          u > v ? S = d : P = d, d = 0.5 * (P - S) + S;
        return d;
      }, solve: function(u, o) {
        return this.sampleCurveY(this.solveCurveX(u, o));
      } };
      var N = m(I);
      let z, V;
      function H() {
        return z == null && (z = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), z;
      }
      function J() {
        if (V == null && (V = !1, H())) {
          const o = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: !0 });
          if (o) {
            for (let g = 0; g < 5 * 5; g++) {
              const v = 4 * g;
              o.fillStyle = `rgb(${v},${v + 1},${v + 2})`, o.fillRect(g % 5, Math.floor(g / 5), 1, 1);
            }
            const d = o.getImageData(0, 0, 5, 5).data;
            for (let g = 0; g < 5 * 5 * 4; g++)
              if (g % 4 != 3 && d[g] !== g) {
                V = !0;
                break;
              }
          }
        }
        return V || !1;
      }
      function ce(u, o, d, g) {
        const v = new N(u, o, d, g);
        return (w) => v.solve(w);
      }
      const me = ce(0.25, 0.1, 0.25, 1);
      function Se(u, o, d) {
        return Math.min(d, Math.max(o, u));
      }
      function De(u, o, d) {
        const g = d - o, v = ((u - o) % g + g) % g + o;
        return v === o ? d : v;
      }
      function Le(u) {
        for (var o = arguments.length, d = new Array(o > 1 ? o - 1 : 0), g = 1; g < o; g++)
          d[g - 1] = arguments[g];
        for (const v of d)
          for (const w in v)
            u[w] = v[w];
        return u;
      }
      let ye = 1;
      function Ve(u, o, d) {
        const g = {};
        for (const v in u)
          g[v] = o.call(this, u[v], v, u);
        return g;
      }
      function Fe(u, o, d) {
        const g = {};
        for (const v in u)
          o.call(this, u[v], v, u) && (g[v] = u[v]);
        return g;
      }
      function ae(u) {
        return Array.isArray(u) ? u.map(ae) : typeof u == "object" && u ? Ve(u, ae) : u;
      }
      const de = {};
      function Te(u) {
        de[u] || (typeof console < "u" && console.warn(u), de[u] = !0);
      }
      function be(u, o, d) {
        return (d.y - u.y) * (o.x - u.x) > (o.y - u.y) * (d.x - u.x);
      }
      function tt(u) {
        return typeof WorkerGlobalScope < "u" && u !== void 0 && u instanceof WorkerGlobalScope;
      }
      let st = null;
      function lt(u) {
        return typeof ImageBitmap < "u" && u instanceof ImageBitmap;
      }
      const Ye = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      function ht(u, o, d, g, v) {
        return l(this, void 0, void 0, function* () {
          if (typeof VideoFrame > "u")
            throw new Error("VideoFrame not supported");
          const w = new VideoFrame(u, { timestamp: 0 });
          try {
            const S = w == null ? void 0 : w.format;
            if (!S || !S.startsWith("BGR") && !S.startsWith("RGB"))
              throw new Error(`Unrecognized format ${S}`);
            const P = S.startsWith("BGR"), B = new Uint8ClampedArray(g * v * 4);
            if (yield w.copyTo(B, function(k, j, q, Z, ee) {
              const oe = 4 * Math.max(-j, 0), pe = (Math.max(0, q) - q) * Z * 4 + oe, we = 4 * Z, Pe = Math.max(0, j), He = Math.max(0, q);
              return { rect: { x: Pe, y: He, width: Math.min(k.width, j + Z) - Pe, height: Math.min(k.height, q + ee) - He }, layout: [{ offset: pe, stride: we }] };
            }(u, o, d, g, v)), P)
              for (let k = 0; k < B.length; k += 4) {
                const j = B[k];
                B[k] = B[k + 2], B[k + 2] = j;
              }
            return B;
          } finally {
            w.close();
          }
        });
      }
      let ct, Pt;
      const se = "AbortError";
      function Ae() {
        return new Error(se);
      }
      const Ce = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
      function Ue(u) {
        return Ce.REGISTERED_PROTOCOLS[u.substring(0, u.indexOf("://"))];
      }
      const qe = "global-dispatcher";
      class We extends Error {
        constructor(o, d, g, v) {
          super(`AJAXError: ${d} (${o}): ${g}`), this.status = o, this.statusText = d, this.url = g, this.body = v;
        }
      }
      const Ke = () => tt(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, Ze = function(u, o) {
        if (/:\/\//.test(u.url) && !/^https?:|^file:/.test(u.url)) {
          const g = Ue(u.url);
          if (g)
            return g(u, o);
          if (tt(self) && self.worker && self.worker.actor)
            return self.worker.actor.sendAsync({ type: "GR", data: u, targetMapId: qe }, o);
        }
        if (!(/^file:/.test(d = u.url) || /^file:/.test(Ke()) && !/^\w+:/.test(d))) {
          if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal"))
            return function(g, v) {
              return l(this, void 0, void 0, function* () {
                const w = new Request(g.url, { method: g.method || "GET", body: g.body, credentials: g.credentials, headers: g.headers, cache: g.cache, referrer: Ke(), signal: v.signal });
                g.type !== "json" || w.headers.has("Accept") || w.headers.set("Accept", "application/json");
                const S = yield fetch(w);
                if (!S.ok) {
                  const k = yield S.blob();
                  throw new We(S.status, S.statusText, g.url, k);
                }
                let P;
                P = g.type === "arrayBuffer" || g.type === "image" ? S.arrayBuffer() : g.type === "json" ? S.json() : S.text();
                const B = yield P;
                if (v.signal.aborted)
                  throw Ae();
                return { data: B, cacheControl: S.headers.get("Cache-Control"), expires: S.headers.get("Expires") };
              });
            }(u, o);
          if (tt(self) && self.worker && self.worker.actor)
            return self.worker.actor.sendAsync({ type: "GR", data: u, mustQueue: !0, targetMapId: qe }, o);
        }
        var d;
        return function(g, v) {
          return new Promise((w, S) => {
            var P;
            const B = new XMLHttpRequest();
            B.open(g.method || "GET", g.url, !0), g.type !== "arrayBuffer" && g.type !== "image" || (B.responseType = "arraybuffer");
            for (const k in g.headers)
              B.setRequestHeader(k, g.headers[k]);
            g.type === "json" && (B.responseType = "text", !((P = g.headers) === null || P === void 0) && P.Accept || B.setRequestHeader("Accept", "application/json")), B.withCredentials = g.credentials === "include", B.onerror = () => {
              S(new Error(B.statusText));
            }, B.onload = () => {
              if (!v.signal.aborted)
                if ((B.status >= 200 && B.status < 300 || B.status === 0) && B.response !== null) {
                  let k = B.response;
                  if (g.type === "json")
                    try {
                      k = JSON.parse(B.response);
                    } catch (j) {
                      return void S(j);
                    }
                  w({ data: k, cacheControl: B.getResponseHeader("Cache-Control"), expires: B.getResponseHeader("Expires") });
                } else {
                  const k = new Blob([B.response], { type: B.getResponseHeader("Content-Type") });
                  S(new We(B.status, B.statusText, g.url, k));
                }
            }, v.signal.addEventListener("abort", () => {
              B.abort(), S(Ae());
            }), B.send(g.body);
          });
        }(u, o);
      };
      function At(u) {
        if (!u || u.indexOf("://") <= 0 || u.indexOf("data:image/") === 0 || u.indexOf("blob:") === 0)
          return !0;
        const o = new URL(u), d = window.location;
        return o.protocol === d.protocol && o.host === d.host;
      }
      function It(u, o, d) {
        d[u] && d[u].indexOf(o) !== -1 || (d[u] = d[u] || [], d[u].push(o));
      }
      function Rt(u, o, d) {
        if (d && d[u]) {
          const g = d[u].indexOf(o);
          g !== -1 && d[u].splice(g, 1);
        }
      }
      class kt {
        constructor(o) {
          let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          Le(this, d), this.type = o;
        }
      }
      class on extends kt {
        constructor(o) {
          let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          super("error", Le({ error: o }, d));
        }
      }
      class ut {
        on(o, d) {
          return this._listeners = this._listeners || {}, It(o, d, this._listeners), this;
        }
        off(o, d) {
          return Rt(o, d, this._listeners), Rt(o, d, this._oneTimeListeners), this;
        }
        once(o, d) {
          return d ? (this._oneTimeListeners = this._oneTimeListeners || {}, It(o, d, this._oneTimeListeners), this) : new Promise((g) => this.once(o, g));
        }
        fire(o, d) {
          typeof o == "string" && (o = new kt(o, d || {}));
          const g = o.type;
          if (this.listens(g)) {
            o.target = this;
            const v = this._listeners && this._listeners[g] ? this._listeners[g].slice() : [];
            for (const P of v)
              P.call(this, o);
            const w = this._oneTimeListeners && this._oneTimeListeners[g] ? this._oneTimeListeners[g].slice() : [];
            for (const P of w)
              Rt(g, P, this._oneTimeListeners), P.call(this, o);
            const S = this._eventedParent;
            S && (Le(o, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), S.fire(o));
          } else
            o instanceof on && console.error(o.error);
          return this;
        }
        listens(o) {
          return this._listeners && this._listeners[o] && this._listeners[o].length > 0 || this._oneTimeListeners && this._oneTimeListeners[o] && this._oneTimeListeners[o].length > 0 || this._eventedParent && this._eventedParent.listens(o);
        }
        setEventedParent(o, d) {
          return this._eventedParent = o, this._eventedParentData = d, this;
        }
      }
      var re = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: !0, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { required: !0, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, terrain: { source: { type: "string", required: !0 }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "enum", default: "mercator", values: { mercator: {}, globe: {} } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
      const mn = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
      function Qt(u, o) {
        const d = {};
        for (const g in u)
          g !== "ref" && (d[g] = u[g]);
        return mn.forEach((g) => {
          g in o && (d[g] = o[g]);
        }), d;
      }
      function pt(u, o) {
        if (Array.isArray(u)) {
          if (!Array.isArray(o) || u.length !== o.length)
            return !1;
          for (let d = 0; d < u.length; d++)
            if (!pt(u[d], o[d]))
              return !1;
          return !0;
        }
        if (typeof u == "object" && u !== null && o !== null) {
          if (typeof o != "object" || Object.keys(u).length !== Object.keys(o).length)
            return !1;
          for (const d in u)
            if (!pt(u[d], o[d]))
              return !1;
          return !0;
        }
        return u === o;
      }
      function Et(u, o) {
        u.push(o);
      }
      function Lt(u, o, d) {
        Et(d, { command: "addSource", args: [u, o[u]] });
      }
      function Ft(u, o, d) {
        Et(o, { command: "removeSource", args: [u] }), d[u] = !0;
      }
      function nn(u, o, d, g) {
        Ft(u, d, g), Lt(u, o, d);
      }
      function Tn(u, o, d) {
        let g;
        for (g in u[d])
          if (Object.prototype.hasOwnProperty.call(u[d], g) && g !== "data" && !pt(u[d][g], o[d][g]))
            return !1;
        for (g in o[d])
          if (Object.prototype.hasOwnProperty.call(o[d], g) && g !== "data" && !pt(u[d][g], o[d][g]))
            return !1;
        return !0;
      }
      function xn(u, o, d, g, v, w) {
        u = u || {}, o = o || {};
        for (const S in u)
          Object.prototype.hasOwnProperty.call(u, S) && (pt(u[S], o[S]) || d.push({ command: w, args: [g, S, o[S], v] }));
        for (const S in o)
          Object.prototype.hasOwnProperty.call(o, S) && !Object.prototype.hasOwnProperty.call(u, S) && (pt(u[S], o[S]) || d.push({ command: w, args: [g, S, o[S], v] }));
      }
      function On(u) {
        return u.id;
      }
      function Un(u, o) {
        return u[o.id] = o, u;
      }
      class mt {
        constructor(o, d, g, v) {
          this.message = (o ? `${o}: ` : "") + g, v && (this.identifier = v), d != null && d.__line__ && (this.line = d.__line__);
        }
      }
      function hn(u) {
        for (var o = arguments.length, d = new Array(o > 1 ? o - 1 : 0), g = 1; g < o; g++)
          d[g - 1] = arguments[g];
        for (const v of d)
          for (const w in v)
            u[w] = v[w];
        return u;
      }
      class wn extends Error {
        constructor(o, d) {
          super(d), this.message = d, this.key = o;
        }
      }
      class Bt {
        constructor(o) {
          let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
          this.parent = o, this.bindings = {};
          for (const [g, v] of d)
            this.bindings[g] = v;
        }
        concat(o) {
          return new Bt(this, o);
        }
        get(o) {
          if (this.bindings[o])
            return this.bindings[o];
          if (this.parent)
            return this.parent.get(o);
          throw new Error(`${o} not found in scope.`);
        }
        has(o) {
          return !!this.bindings[o] || !!this.parent && this.parent.has(o);
        }
      }
      const bi = { kind: "null" }, _t = { kind: "number" }, bn = { kind: "string" }, Gt = { kind: "boolean" }, qn = { kind: "color" }, er = { kind: "object" }, Nt = { kind: "value" }, vr = { kind: "collator" }, ii = { kind: "formatted" }, sr = { kind: "padding" }, or = { kind: "resolvedImage" }, ve = { kind: "variableAnchorOffsetCollection" };
      function X(u, o) {
        return { kind: "array", itemType: u, N: o };
      }
      function $(u) {
        if (u.kind === "array") {
          const o = $(u.itemType);
          return typeof u.N == "number" ? `array<${o}, ${u.N}>` : u.itemType.kind === "value" ? "array" : `array<${o}>`;
        }
        return u.kind;
      }
      const he = [bi, _t, bn, Gt, qn, ii, er, X(Nt), sr, or, ve];
      function _e(u, o) {
        if (o.kind === "error")
          return null;
        if (u.kind === "array") {
          if (o.kind === "array" && (o.N === 0 && o.itemType.kind === "value" || !_e(u.itemType, o.itemType)) && (typeof u.N != "number" || u.N === o.N))
            return null;
        } else {
          if (u.kind === o.kind)
            return null;
          if (u.kind === "value") {
            for (const d of he)
              if (!_e(d, o))
                return null;
          }
        }
        return `Expected ${$(u)} but found ${$(o)} instead.`;
      }
      function Oe(u, o) {
        return o.some((d) => d.kind === u.kind);
      }
      function je(u, o) {
        return o.some((d) => d === "null" ? u === null : d === "array" ? Array.isArray(u) : d === "object" ? u && !Array.isArray(u) && typeof u == "object" : d === typeof u);
      }
      function Be(u, o) {
        return u.kind === "array" && o.kind === "array" ? u.itemType.kind === o.itemType.kind && typeof u.N == "number" : u.kind === o.kind;
      }
      const Ie = 0.96422, nt = 0.82521, ft = 4 / 29, Xe = 6 / 29, xt = 3 * Xe * Xe, $t = Xe * Xe * Xe, Kt = Math.PI / 180, _n = 180 / Math.PI;
      function An(u) {
        return (u %= 360) < 0 && (u += 360), u;
      }
      function an(u) {
        let [o, d, g, v] = u, w, S;
        const P = Yn((0.2225045 * (o = Fn(o)) + 0.7168786 * (d = Fn(d)) + 0.0606169 * (g = Fn(g))) / 1);
        o === d && d === g ? w = S = P : (w = Yn((0.4360747 * o + 0.3850649 * d + 0.1430804 * g) / Ie), S = Yn((0.0139322 * o + 0.0971045 * d + 0.7141733 * g) / nt));
        const B = 116 * P - 16;
        return [B < 0 ? 0 : B, 500 * (w - P), 200 * (P - S), v];
      }
      function Fn(u) {
        return u <= 0.04045 ? u / 12.92 : Math.pow((u + 0.055) / 1.055, 2.4);
      }
      function Yn(u) {
        return u > $t ? Math.pow(u, 1 / 3) : u / xt + ft;
      }
      function Kn(u) {
        let [o, d, g, v] = u, w = (o + 16) / 116, S = isNaN(d) ? w : w + d / 500, P = isNaN(g) ? w : w - g / 200;
        return w = 1 * Dn(w), S = Ie * Dn(S), P = nt * Dn(P), [dn(3.1338561 * S - 1.6168667 * w - 0.4906146 * P), dn(-0.9787684 * S + 1.9161415 * w + 0.033454 * P), dn(0.0719453 * S - 0.2289914 * w + 1.4052427 * P), v];
      }
      function dn(u) {
        return (u = u <= 304e-5 ? 12.92 * u : 1.055 * Math.pow(u, 1 / 2.4) - 0.055) < 0 ? 0 : u > 1 ? 1 : u;
      }
      function Dn(u) {
        return u > Xe ? u * u * u : xt * (u - ft);
      }
      function Jn(u) {
        return parseInt(u.padEnd(2, u), 16) / 255;
      }
      function di(u, o) {
        return Bi(o ? u / 100 : u, 0, 1);
      }
      function Bi(u, o, d) {
        return Math.min(Math.max(o, u), d);
      }
      function Xi(u) {
        return !u.some(Number.isNaN);
      }
      const yo = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
      class Xn {
        constructor(o, d, g) {
          let v = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1, w = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0;
          this.r = o, this.g = d, this.b = g, this.a = v, w || (this.r *= v, this.g *= v, this.b *= v, v || this.overwriteGetter("rgb", [o, d, g, v]));
        }
        static parse(o) {
          if (o instanceof Xn)
            return o;
          if (typeof o != "string")
            return;
          const d = function(g) {
            if ((g = g.toLowerCase().trim()) === "transparent")
              return [0, 0, 0, 0];
            const v = yo[g];
            if (v) {
              const [S, P, B] = v;
              return [S / 255, P / 255, B / 255, 1];
            }
            if (g.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(g)) {
              const S = g.length < 6 ? 1 : 2;
              let P = 1;
              return [Jn(g.slice(P, P += S)), Jn(g.slice(P, P += S)), Jn(g.slice(P, P += S)), Jn(g.slice(P, P + S) || "ff")];
            }
            if (g.startsWith("rgb")) {
              const S = g.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (S) {
                const [P, B, k, j, q, Z, ee, oe, pe, we, Pe, He] = S, ke = [j || " ", ee || " ", we].join("");
                if (ke === "  " || ke === "  /" || ke === ",," || ke === ",,,") {
                  const Ge = [k, Z, pe].join(""), at = Ge === "%%%" ? 100 : Ge === "" ? 255 : 0;
                  if (at) {
                    const bt = [Bi(+B / at, 0, 1), Bi(+q / at, 0, 1), Bi(+oe / at, 0, 1), Pe ? di(+Pe, He) : 1];
                    if (Xi(bt))
                      return bt;
                  }
                }
                return;
              }
            }
            const w = g.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
            if (w) {
              const [S, P, B, k, j, q, Z, ee, oe] = w, pe = [B || " ", j || " ", Z].join("");
              if (pe === "  " || pe === "  /" || pe === ",," || pe === ",,,") {
                const we = [+P, Bi(+k, 0, 100), Bi(+q, 0, 100), ee ? di(+ee, oe) : 1];
                if (Xi(we))
                  return function(Pe) {
                    let [He, ke, Ge, at] = Pe;
                    function bt(Ut) {
                      const ln = (Ut + He / 30) % 12, jt = ke * Math.min(Ge, 1 - Ge);
                      return Ge - jt * Math.max(-1, Math.min(ln - 3, 9 - ln, 1));
                    }
                    return He = An(He), ke /= 100, Ge /= 100, [bt(0), bt(8), bt(4), at];
                  }(we);
              }
            }
          }(o);
          return d ? new Xn(...d, !1) : void 0;
        }
        get rgb() {
          const { r: o, g: d, b: g, a: v } = this, w = v || 1 / 0;
          return this.overwriteGetter("rgb", [o / w, d / w, g / w, v]);
        }
        get hcl() {
          return this.overwriteGetter("hcl", function(o) {
            const [d, g, v, w] = an(o), S = Math.sqrt(g * g + v * v);
            return [Math.round(1e4 * S) ? An(Math.atan2(v, g) * _n) : NaN, S, d, w];
          }(this.rgb));
        }
        get lab() {
          return this.overwriteGetter("lab", an(this.rgb));
        }
        overwriteGetter(o, d) {
          return Object.defineProperty(this, o, { value: d }), d;
        }
        toString() {
          const [o, d, g, v] = this.rgb;
          return `rgba(${[o, d, g].map((w) => Math.round(255 * w)).join(",")},${v})`;
        }
      }
      Xn.black = new Xn(0, 0, 0, 1), Xn.white = new Xn(1, 1, 1, 1), Xn.transparent = new Xn(0, 0, 0, 0), Xn.red = new Xn(1, 0, 0, 1);
      class br {
        constructor(o, d, g) {
          this.sensitivity = o ? d ? "variant" : "case" : d ? "accent" : "base", this.locale = g, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        }
        compare(o, d) {
          return this.collator.compare(o, d);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      }
      class Hr {
        constructor(o, d, g, v, w) {
          this.text = o, this.image = d, this.scale = g, this.fontStack = v, this.textColor = w;
        }
      }
      class Ri {
        constructor(o) {
          this.sections = o;
        }
        static fromString(o) {
          return new Ri([new Hr(o, null, null, null, null)]);
        }
        isEmpty() {
          return this.sections.length === 0 || !this.sections.some((o) => o.text.length !== 0 || o.image && o.image.name.length !== 0);
        }
        static factory(o) {
          return o instanceof Ri ? o : Ri.fromString(o);
        }
        toString() {
          return this.sections.length === 0 ? "" : this.sections.map((o) => o.text).join("");
        }
      }
      class Oi {
        constructor(o) {
          this.values = o.slice();
        }
        static parse(o) {
          if (o instanceof Oi)
            return o;
          if (typeof o == "number")
            return new Oi([o, o, o, o]);
          if (Array.isArray(o) && !(o.length < 1 || o.length > 4)) {
            for (const d of o)
              if (typeof d != "number")
                return;
            switch (o.length) {
              case 1:
                o = [o[0], o[0], o[0], o[0]];
                break;
              case 2:
                o = [o[0], o[1], o[0], o[1]];
                break;
              case 3:
                o = [o[0], o[1], o[2], o[1]];
            }
            return new Oi(o);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
      }
      const Ys = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
      class Ii {
        constructor(o) {
          this.values = o.slice();
        }
        static parse(o) {
          if (o instanceof Ii)
            return o;
          if (Array.isArray(o) && !(o.length < 1) && o.length % 2 == 0) {
            for (let d = 0; d < o.length; d += 2) {
              const g = o[d], v = o[d + 1];
              if (typeof g != "string" || !Ys.has(g) || !Array.isArray(v) || v.length !== 2 || typeof v[0] != "number" || typeof v[1] != "number")
                return;
            }
            return new Ii(o);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
      }
      class fi {
        constructor(o) {
          this.name = o.name, this.available = o.available;
        }
        toString() {
          return this.name;
        }
        static fromString(o) {
          return o ? new fi({ name: o, available: !1 }) : null;
        }
      }
      function zo(u, o, d, g) {
        return typeof u == "number" && u >= 0 && u <= 255 && typeof o == "number" && o >= 0 && o <= 255 && typeof d == "number" && d >= 0 && d <= 255 ? g === void 0 || typeof g == "number" && g >= 0 && g <= 1 ? null : `Invalid rgba value [${[u, o, d, g].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof g == "number" ? [u, o, d, g] : [u, o, d]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function _s(u) {
        if (u === null || typeof u == "string" || typeof u == "boolean" || typeof u == "number" || u instanceof Xn || u instanceof br || u instanceof Ri || u instanceof Oi || u instanceof Ii || u instanceof fi)
          return !0;
        if (Array.isArray(u)) {
          for (const o of u)
            if (!_s(o))
              return !1;
          return !0;
        }
        if (typeof u == "object") {
          for (const o in u)
            if (!_s(u[o]))
              return !1;
          return !0;
        }
        return !1;
      }
      function xi(u) {
        if (u === null)
          return bi;
        if (typeof u == "string")
          return bn;
        if (typeof u == "boolean")
          return Gt;
        if (typeof u == "number")
          return _t;
        if (u instanceof Xn)
          return qn;
        if (u instanceof br)
          return vr;
        if (u instanceof Ri)
          return ii;
        if (u instanceof Oi)
          return sr;
        if (u instanceof Ii)
          return ve;
        if (u instanceof fi)
          return or;
        if (Array.isArray(u)) {
          const o = u.length;
          let d;
          for (const g of u) {
            const v = xi(g);
            if (d) {
              if (d === v)
                continue;
              d = Nt;
              break;
            }
            d = v;
          }
          return X(d || Nt, o);
        }
        return er;
      }
      function Nn(u) {
        const o = typeof u;
        return u === null ? "" : o === "string" || o === "number" || o === "boolean" ? String(u) : u instanceof Xn || u instanceof Ri || u instanceof Oi || u instanceof Ii || u instanceof fi ? u.toString() : JSON.stringify(u);
      }
      class Wr {
        constructor(o, d) {
          this.type = o, this.value = d;
        }
        static parse(o, d) {
          if (o.length !== 2)
            return d.error(`'literal' expression requires exactly one argument, but found ${o.length - 1} instead.`);
          if (!_s(o[1]))
            return d.error("invalid value");
          const g = o[1];
          let v = xi(g);
          const w = d.expectedType;
          return v.kind !== "array" || v.N !== 0 || !w || w.kind !== "array" || typeof w.N == "number" && w.N !== 0 || (v = w), new Wr(v, g);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      class _i {
        constructor(o) {
          this.name = "ExpressionEvaluationError", this.message = o;
        }
        toJSON() {
          return this.message;
        }
      }
      const Ks = { string: bn, number: _t, boolean: Gt, object: er };
      class hr {
        constructor(o, d) {
          this.type = o, this.args = d;
        }
        static parse(o, d) {
          if (o.length < 2)
            return d.error("Expected at least one argument.");
          let g, v = 1;
          const w = o[0];
          if (w === "array") {
            let P, B;
            if (o.length > 2) {
              const k = o[1];
              if (typeof k != "string" || !(k in Ks) || k === "object")
                return d.error('The item type argument of "array" must be one of string, number, boolean', 1);
              P = Ks[k], v++;
            } else
              P = Nt;
            if (o.length > 3) {
              if (o[2] !== null && (typeof o[2] != "number" || o[2] < 0 || o[2] !== Math.floor(o[2])))
                return d.error('The length argument to "array" must be a positive integer literal', 2);
              B = o[2], v++;
            }
            g = X(P, B);
          } else {
            if (!Ks[w])
              throw new Error(`Types doesn't contain name = ${w}`);
            g = Ks[w];
          }
          const S = [];
          for (; v < o.length; v++) {
            const P = d.parse(o[v], v, Nt);
            if (!P)
              return null;
            S.push(P);
          }
          return new hr(g, S);
        }
        evaluate(o) {
          for (let d = 0; d < this.args.length; d++) {
            const g = this.args[d].evaluate(o);
            if (!_e(this.type, xi(g)))
              return g;
            if (d === this.args.length - 1)
              throw new _i(`Expected value to be of type ${$(this.type)}, but found ${$(xi(g))} instead.`);
          }
          throw new Error();
        }
        eachChild(o) {
          this.args.forEach(o);
        }
        outputDefined() {
          return this.args.every((o) => o.outputDefined());
        }
      }
      const Qs = { "to-boolean": Gt, "to-color": qn, "to-number": _t, "to-string": bn };
      class Ji {
        constructor(o, d) {
          this.type = o, this.args = d;
        }
        static parse(o, d) {
          if (o.length < 2)
            return d.error("Expected at least one argument.");
          const g = o[0];
          if (!Qs[g])
            throw new Error(`Can't parse ${g} as it is not part of the known types`);
          if ((g === "to-boolean" || g === "to-string") && o.length !== 2)
            return d.error("Expected one argument.");
          const v = Qs[g], w = [];
          for (let S = 1; S < o.length; S++) {
            const P = d.parse(o[S], S, Nt);
            if (!P)
              return null;
            w.push(P);
          }
          return new Ji(v, w);
        }
        evaluate(o) {
          switch (this.type.kind) {
            case "boolean":
              return !!this.args[0].evaluate(o);
            case "color": {
              let d, g;
              for (const v of this.args) {
                if (d = v.evaluate(o), g = null, d instanceof Xn)
                  return d;
                if (typeof d == "string") {
                  const w = o.parseColor(d);
                  if (w)
                    return w;
                } else if (Array.isArray(d) && (g = d.length < 3 || d.length > 4 ? `Invalid rbga value ${JSON.stringify(d)}: expected an array containing either three or four numeric values.` : zo(d[0], d[1], d[2], d[3]), !g))
                  return new Xn(d[0] / 255, d[1] / 255, d[2] / 255, d[3]);
              }
              throw new _i(g || `Could not parse color from value '${typeof d == "string" ? d : JSON.stringify(d)}'`);
            }
            case "padding": {
              let d;
              for (const g of this.args) {
                d = g.evaluate(o);
                const v = Oi.parse(d);
                if (v)
                  return v;
              }
              throw new _i(`Could not parse padding from value '${typeof d == "string" ? d : JSON.stringify(d)}'`);
            }
            case "variableAnchorOffsetCollection": {
              let d;
              for (const g of this.args) {
                d = g.evaluate(o);
                const v = Ii.parse(d);
                if (v)
                  return v;
              }
              throw new _i(`Could not parse variableAnchorOffsetCollection from value '${typeof d == "string" ? d : JSON.stringify(d)}'`);
            }
            case "number": {
              let d = null;
              for (const g of this.args) {
                if (d = g.evaluate(o), d === null)
                  return 0;
                const v = Number(d);
                if (!isNaN(v))
                  return v;
              }
              throw new _i(`Could not convert ${JSON.stringify(d)} to number.`);
            }
            case "formatted":
              return Ri.fromString(Nn(this.args[0].evaluate(o)));
            case "resolvedImage":
              return fi.fromString(Nn(this.args[0].evaluate(o)));
            default:
              return Nn(this.args[0].evaluate(o));
          }
        }
        eachChild(o) {
          this.args.forEach(o);
        }
        outputDefined() {
          return this.args.every((o) => o.outputDefined());
        }
      }
      const Pr = ["Unknown", "Point", "LineString", "Polygon"];
      class dr {
        constructor() {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
        }
        id() {
          return this.feature && "id" in this.feature ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? typeof this.feature.type == "number" ? Pr[this.feature.type] : this.feature.type : null;
        }
        geometry() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return this.feature && this.feature.properties || {};
        }
        parseColor(o) {
          let d = this._parseColorCache[o];
          return d || (d = this._parseColorCache[o] = Xn.parse(o)), d;
        }
      }
      class Xr {
        constructor(o, d) {
          let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], v = arguments.length > 3 ? arguments[3] : void 0, w = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : new Bt(), S = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : [];
          this.registry = o, this.path = g, this.key = g.map((P) => `[${P}]`).join(""), this.scope = w, this.errors = S, this.expectedType = v, this._isConstant = d;
        }
        parse(o, d, g, v) {
          let w = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
          return d ? this.concat(d, g, v)._parse(o, w) : this._parse(o, w);
        }
        _parse(o, d) {
          function g(v, w, S) {
            return S === "assert" ? new hr(w, [v]) : S === "coerce" ? new Ji(w, [v]) : v;
          }
          if (o !== null && typeof o != "string" && typeof o != "boolean" && typeof o != "number" || (o = ["literal", o]), Array.isArray(o)) {
            if (o.length === 0)
              return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            const v = o[0];
            if (typeof v != "string")
              return this.error(`Expression name must be a string, but found ${typeof v} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
            const w = this.registry[v];
            if (w) {
              let S = w.parse(o, this);
              if (!S)
                return null;
              if (this.expectedType) {
                const P = this.expectedType, B = S.type;
                if (P.kind !== "string" && P.kind !== "number" && P.kind !== "boolean" && P.kind !== "object" && P.kind !== "array" || B.kind !== "value")
                  if (P.kind !== "color" && P.kind !== "formatted" && P.kind !== "resolvedImage" || B.kind !== "value" && B.kind !== "string")
                    if (P.kind !== "padding" || B.kind !== "value" && B.kind !== "number" && B.kind !== "array")
                      if (P.kind !== "variableAnchorOffsetCollection" || B.kind !== "value" && B.kind !== "array") {
                        if (this.checkSubtype(P, B))
                          return null;
                      } else
                        S = g(S, P, d.typeAnnotation || "coerce");
                    else
                      S = g(S, P, d.typeAnnotation || "coerce");
                  else
                    S = g(S, P, d.typeAnnotation || "coerce");
                else
                  S = g(S, P, d.typeAnnotation || "assert");
              }
              if (!(S instanceof Wr) && S.type.kind !== "resolvedImage" && this._isConstant(S)) {
                const P = new dr();
                try {
                  S = new Wr(S.type, S.evaluate(P));
                } catch (B) {
                  return this.error(B.message), null;
                }
              }
              return S;
            }
            return this.error(`Unknown expression "${v}". If you wanted a literal array, use ["literal", [...]].`, 0);
          }
          return this.error(o === void 0 ? "'undefined' value invalid. Use null instead." : typeof o == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof o} instead.`);
        }
        concat(o, d, g) {
          const v = typeof o == "number" ? this.path.concat(o) : this.path, w = g ? this.scope.concat(g) : this.scope;
          return new Xr(this.registry, this._isConstant, v, d || null, w, this.errors);
        }
        error(o) {
          for (var d = arguments.length, g = new Array(d > 1 ? d - 1 : 0), v = 1; v < d; v++)
            g[v - 1] = arguments[v];
          const w = `${this.key}${g.map((S) => `[${S}]`).join("")}`;
          this.errors.push(new wn(w, o));
        }
        checkSubtype(o, d) {
          const g = _e(o, d);
          return g && this.error(g), g;
        }
      }
      class jn {
        constructor(o, d) {
          this.type = d.type, this.bindings = [].concat(o), this.result = d;
        }
        evaluate(o) {
          return this.result.evaluate(o);
        }
        eachChild(o) {
          for (const d of this.bindings)
            o(d[1]);
          o(this.result);
        }
        static parse(o, d) {
          if (o.length < 4)
            return d.error(`Expected at least 3 arguments, but found ${o.length - 1} instead.`);
          const g = [];
          for (let w = 1; w < o.length - 1; w += 2) {
            const S = o[w];
            if (typeof S != "string")
              return d.error(`Expected string, but found ${typeof S} instead.`, w);
            if (/[^a-zA-Z0-9_]/.test(S))
              return d.error("Variable names must contain only alphanumeric characters or '_'.", w);
            const P = d.parse(o[w + 1], w + 1);
            if (!P)
              return null;
            g.push([S, P]);
          }
          const v = d.parse(o[o.length - 1], o.length - 1, d.expectedType, g);
          return v ? new jn(g, v) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
      }
      class Uo {
        constructor(o, d) {
          this.type = d.type, this.name = o, this.boundExpression = d;
        }
        static parse(o, d) {
          if (o.length !== 2 || typeof o[1] != "string")
            return d.error("'var' expression requires exactly one string literal argument.");
          const g = o[1];
          return d.scope.has(g) ? new Uo(g, d.scope.get(g)) : d.error(`Unknown variable "${g}". Make sure "${g}" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        evaluate(o) {
          return this.boundExpression.evaluate(o);
        }
        eachChild() {
        }
        outputDefined() {
          return !1;
        }
      }
      class ma {
        constructor(o, d, g) {
          this.type = o, this.index = d, this.input = g;
        }
        static parse(o, d) {
          if (o.length !== 3)
            return d.error(`Expected 2 arguments, but found ${o.length - 1} instead.`);
          const g = d.parse(o[1], 1, _t), v = d.parse(o[2], 2, X(d.expectedType || Nt));
          return g && v ? new ma(v.type.itemType, g, v) : null;
        }
        evaluate(o) {
          const d = this.index.evaluate(o), g = this.input.evaluate(o);
          if (d < 0)
            throw new _i(`Array index out of bounds: ${d} < 0.`);
          if (d >= g.length)
            throw new _i(`Array index out of bounds: ${d} > ${g.length - 1}.`);
          if (d !== Math.floor(d))
            throw new _i(`Array index must be an integer, but found ${d} instead.`);
          return g[d];
        }
        eachChild(o) {
          o(this.index), o(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      class jo {
        constructor(o, d) {
          this.type = Gt, this.needle = o, this.haystack = d;
        }
        static parse(o, d) {
          if (o.length !== 3)
            return d.error(`Expected 2 arguments, but found ${o.length - 1} instead.`);
          const g = d.parse(o[1], 1, Nt), v = d.parse(o[2], 2, Nt);
          return g && v ? Oe(g.type, [Gt, bn, _t, bi, Nt]) ? new jo(g, v) : d.error(`Expected first argument to be of type boolean, string, number or null, but found ${$(g.type)} instead`) : null;
        }
        evaluate(o) {
          const d = this.needle.evaluate(o), g = this.haystack.evaluate(o);
          if (!g)
            return !1;
          if (!je(d, ["boolean", "string", "number", "null"]))
            throw new _i(`Expected first argument to be of type boolean, string, number or null, but found ${$(xi(d))} instead.`);
          if (!je(g, ["string", "array"]))
            throw new _i(`Expected second argument to be of type array or string, but found ${$(xi(g))} instead.`);
          return g.indexOf(d) >= 0;
        }
        eachChild(o) {
          o(this.needle), o(this.haystack);
        }
        outputDefined() {
          return !0;
        }
      }
      class ue {
        constructor(o, d, g) {
          this.type = _t, this.needle = o, this.haystack = d, this.fromIndex = g;
        }
        static parse(o, d) {
          if (o.length <= 2 || o.length >= 5)
            return d.error(`Expected 3 or 4 arguments, but found ${o.length - 1} instead.`);
          const g = d.parse(o[1], 1, Nt), v = d.parse(o[2], 2, Nt);
          if (!g || !v)
            return null;
          if (!Oe(g.type, [Gt, bn, _t, bi, Nt]))
            return d.error(`Expected first argument to be of type boolean, string, number or null, but found ${$(g.type)} instead`);
          if (o.length === 4) {
            const w = d.parse(o[3], 3, _t);
            return w ? new ue(g, v, w) : null;
          }
          return new ue(g, v);
        }
        evaluate(o) {
          const d = this.needle.evaluate(o), g = this.haystack.evaluate(o);
          if (!je(d, ["boolean", "string", "number", "null"]))
            throw new _i(`Expected first argument to be of type boolean, string, number or null, but found ${$(xi(d))} instead.`);
          if (!je(g, ["string", "array"]))
            throw new _i(`Expected second argument to be of type array or string, but found ${$(xi(g))} instead.`);
          if (this.fromIndex) {
            const v = this.fromIndex.evaluate(o);
            return g.indexOf(d, v);
          }
          return g.indexOf(d);
        }
        eachChild(o) {
          o(this.needle), o(this.haystack), this.fromIndex && o(this.fromIndex);
        }
        outputDefined() {
          return !1;
        }
      }
      class ge {
        constructor(o, d, g, v, w, S) {
          this.inputType = o, this.type = d, this.input = g, this.cases = v, this.outputs = w, this.otherwise = S;
        }
        static parse(o, d) {
          if (o.length < 5)
            return d.error(`Expected at least 4 arguments, but found only ${o.length - 1}.`);
          if (o.length % 2 != 1)
            return d.error("Expected an even number of arguments.");
          let g, v;
          d.expectedType && d.expectedType.kind !== "value" && (v = d.expectedType);
          const w = {}, S = [];
          for (let k = 2; k < o.length - 1; k += 2) {
            let j = o[k];
            const q = o[k + 1];
            Array.isArray(j) || (j = [j]);
            const Z = d.concat(k);
            if (j.length === 0)
              return Z.error("Expected at least one branch label.");
            for (const oe of j) {
              if (typeof oe != "number" && typeof oe != "string")
                return Z.error("Branch labels must be numbers or strings.");
              if (typeof oe == "number" && Math.abs(oe) > Number.MAX_SAFE_INTEGER)
                return Z.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
              if (typeof oe == "number" && Math.floor(oe) !== oe)
                return Z.error("Numeric branch labels must be integer values.");
              if (g) {
                if (Z.checkSubtype(g, xi(oe)))
                  return null;
              } else
                g = xi(oe);
              if (w[String(oe)] !== void 0)
                return Z.error("Branch labels must be unique.");
              w[String(oe)] = S.length;
            }
            const ee = d.parse(q, k, v);
            if (!ee)
              return null;
            v = v || ee.type, S.push(ee);
          }
          const P = d.parse(o[1], 1, Nt);
          if (!P)
            return null;
          const B = d.parse(o[o.length - 1], o.length - 1, v);
          return B ? P.type.kind !== "value" && d.concat(1).checkSubtype(g, P.type) ? null : new ge(g, v, P, w, S, B) : null;
        }
        evaluate(o) {
          const d = this.input.evaluate(o);
          return (xi(d) === this.inputType && this.outputs[this.cases[d]] || this.otherwise).evaluate(o);
        }
        eachChild(o) {
          o(this.input), this.outputs.forEach(o), o(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every((o) => o.outputDefined()) && this.otherwise.outputDefined();
        }
      }
      class Re {
        constructor(o, d, g) {
          this.type = o, this.branches = d, this.otherwise = g;
        }
        static parse(o, d) {
          if (o.length < 4)
            return d.error(`Expected at least 3 arguments, but found only ${o.length - 1}.`);
          if (o.length % 2 != 0)
            return d.error("Expected an odd number of arguments.");
          let g;
          d.expectedType && d.expectedType.kind !== "value" && (g = d.expectedType);
          const v = [];
          for (let S = 1; S < o.length - 1; S += 2) {
            const P = d.parse(o[S], S, Gt);
            if (!P)
              return null;
            const B = d.parse(o[S + 1], S + 1, g);
            if (!B)
              return null;
            v.push([P, B]), g = g || B.type;
          }
          const w = d.parse(o[o.length - 1], o.length - 1, g);
          if (!w)
            return null;
          if (!g)
            throw new Error("Can't infer output type");
          return new Re(g, v, w);
        }
        evaluate(o) {
          for (const [d, g] of this.branches)
            if (d.evaluate(o))
              return g.evaluate(o);
          return this.otherwise.evaluate(o);
        }
        eachChild(o) {
          for (const [d, g] of this.branches)
            o(d), o(g);
          o(this.otherwise);
        }
        outputDefined() {
          return this.branches.every((o) => {
            let [d, g] = o;
            return g.outputDefined();
          }) && this.otherwise.outputDefined();
        }
      }
      class it {
        constructor(o, d, g, v) {
          this.type = o, this.input = d, this.beginIndex = g, this.endIndex = v;
        }
        static parse(o, d) {
          if (o.length <= 2 || o.length >= 5)
            return d.error(`Expected 3 or 4 arguments, but found ${o.length - 1} instead.`);
          const g = d.parse(o[1], 1, Nt), v = d.parse(o[2], 2, _t);
          if (!g || !v)
            return null;
          if (!Oe(g.type, [X(Nt), bn, Nt]))
            return d.error(`Expected first argument to be of type array or string, but found ${$(g.type)} instead`);
          if (o.length === 4) {
            const w = d.parse(o[3], 3, _t);
            return w ? new it(g.type, g, v, w) : null;
          }
          return new it(g.type, g, v);
        }
        evaluate(o) {
          const d = this.input.evaluate(o), g = this.beginIndex.evaluate(o);
          if (!je(d, ["string", "array"]))
            throw new _i(`Expected first argument to be of type array or string, but found ${$(xi(d))} instead.`);
          if (this.endIndex) {
            const v = this.endIndex.evaluate(o);
            return d.slice(g, v);
          }
          return d.slice(g);
        }
        eachChild(o) {
          o(this.input), o(this.beginIndex), this.endIndex && o(this.endIndex);
        }
        outputDefined() {
          return !1;
        }
      }
      function St(u, o) {
        const d = u.length - 1;
        let g, v, w = 0, S = d, P = 0;
        for (; w <= S; )
          if (P = Math.floor((w + S) / 2), g = u[P], v = u[P + 1], g <= o) {
            if (P === d || o < v)
              return P;
            w = P + 1;
          } else {
            if (!(g > o))
              throw new _i("Input is not a number.");
            S = P - 1;
          }
        return 0;
      }
      class Wt {
        constructor(o, d, g) {
          this.type = o, this.input = d, this.labels = [], this.outputs = [];
          for (const [v, w] of g)
            this.labels.push(v), this.outputs.push(w);
        }
        static parse(o, d) {
          if (o.length - 1 < 4)
            return d.error(`Expected at least 4 arguments, but found only ${o.length - 1}.`);
          if ((o.length - 1) % 2 != 0)
            return d.error("Expected an even number of arguments.");
          const g = d.parse(o[1], 1, _t);
          if (!g)
            return null;
          const v = [];
          let w = null;
          d.expectedType && d.expectedType.kind !== "value" && (w = d.expectedType);
          for (let S = 1; S < o.length; S += 2) {
            const P = S === 1 ? -1 / 0 : o[S], B = o[S + 1], k = S, j = S + 1;
            if (typeof P != "number")
              return d.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', k);
            if (v.length && v[v.length - 1][0] >= P)
              return d.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', k);
            const q = d.parse(B, j, w);
            if (!q)
              return null;
            w = w || q.type, v.push([P, q]);
          }
          return new Wt(w, g, v);
        }
        evaluate(o) {
          const d = this.labels, g = this.outputs;
          if (d.length === 1)
            return g[0].evaluate(o);
          const v = this.input.evaluate(o);
          if (v <= d[0])
            return g[0].evaluate(o);
          const w = d.length;
          return v >= d[w - 1] ? g[w - 1].evaluate(o) : g[St(d, v)].evaluate(o);
        }
        eachChild(o) {
          o(this.input);
          for (const d of this.outputs)
            o(d);
        }
        outputDefined() {
          return this.outputs.every((o) => o.outputDefined());
        }
      }
      function Pn(u) {
        return u && u.__esModule && Object.prototype.hasOwnProperty.call(u, "default") ? u.default : u;
      }
      var Fi = Di;
      function Di(u, o, d, g) {
        this.cx = 3 * u, this.bx = 3 * (d - u) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * o, this.by = 3 * (g - o) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = u, this.p1y = o, this.p2x = d, this.p2y = g;
      }
      Di.prototype = { sampleCurveX: function(u) {
        return ((this.ax * u + this.bx) * u + this.cx) * u;
      }, sampleCurveY: function(u) {
        return ((this.ay * u + this.by) * u + this.cy) * u;
      }, sampleCurveDerivativeX: function(u) {
        return (3 * this.ax * u + 2 * this.bx) * u + this.cx;
      }, solveCurveX: function(u, o) {
        if (o === void 0 && (o = 1e-6), u < 0)
          return 0;
        if (u > 1)
          return 1;
        for (var d = u, g = 0; g < 8; g++) {
          var v = this.sampleCurveX(d) - u;
          if (Math.abs(v) < o)
            return d;
          var w = this.sampleCurveDerivativeX(d);
          if (Math.abs(w) < 1e-6)
            break;
          d -= v / w;
        }
        var S = 0, P = 1;
        for (d = u, g = 0; g < 20 && (v = this.sampleCurveX(d), !(Math.abs(v - u) < o)); g++)
          u > v ? S = d : P = d, d = 0.5 * (P - S) + S;
        return d;
      }, solve: function(u, o) {
        return this.sampleCurveY(this.solveCurveX(u, o));
      } };
      var fr = Pn(Fi);
      function ti(u, o, d) {
        return u + d * (o - u);
      }
      function Qa(u, o, d) {
        return u.map((g, v) => ti(g, o[v], d));
      }
      const Nr = { number: ti, color: function(u, o, d) {
        switch (arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "rgb") {
          case "rgb": {
            const [v, w, S, P] = Qa(u.rgb, o.rgb, d);
            return new Xn(v, w, S, P, !1);
          }
          case "hcl": {
            const [v, w, S, P] = u.hcl, [B, k, j, q] = o.hcl;
            let Z, ee;
            if (isNaN(v) || isNaN(B))
              isNaN(v) ? isNaN(B) ? Z = NaN : (Z = B, S !== 1 && S !== 0 || (ee = k)) : (Z = v, j !== 1 && j !== 0 || (ee = w));
            else {
              let He = B - v;
              B > v && He > 180 ? He -= 360 : B < v && v - B > 180 && (He += 360), Z = v + d * He;
            }
            const [oe, pe, we, Pe] = function(He) {
              let [ke, Ge, at, bt] = He;
              return ke = isNaN(ke) ? 0 : ke * Kt, Kn([at, Math.cos(ke) * Ge, Math.sin(ke) * Ge, bt]);
            }([Z, ee ?? ti(w, k, d), ti(S, j, d), ti(P, q, d)]);
            return new Xn(oe, pe, we, Pe, !1);
          }
          case "lab": {
            const [v, w, S, P] = Kn(Qa(u.lab, o.lab, d));
            return new Xn(v, w, S, P, !1);
          }
        }
      }, array: Qa, padding: function(u, o, d) {
        return new Oi(Qa(u.values, o.values, d));
      }, variableAnchorOffsetCollection: function(u, o, d) {
        const g = u.values, v = o.values;
        if (g.length !== v.length)
          throw new _i(`Cannot interpolate values of different length. from: ${u.toString()}, to: ${o.toString()}`);
        const w = [];
        for (let S = 0; S < g.length; S += 2) {
          if (g[S] !== v[S])
            throw new _i(`Cannot interpolate values containing mismatched anchors. from[${S}]: ${g[S]}, to[${S}]: ${v[S]}`);
          w.push(g[S]);
          const [P, B] = g[S + 1], [k, j] = v[S + 1];
          w.push([ti(P, k, d), ti(B, j, d)]);
        }
        return new Ii(w);
      } };
      class yn {
        constructor(o, d, g, v, w) {
          this.type = o, this.operator = d, this.interpolation = g, this.input = v, this.labels = [], this.outputs = [];
          for (const [S, P] of w)
            this.labels.push(S), this.outputs.push(P);
        }
        static interpolationFactor(o, d, g, v) {
          let w = 0;
          if (o.name === "exponential")
            w = el(d, o.base, g, v);
          else if (o.name === "linear")
            w = el(d, 1, g, v);
          else if (o.name === "cubic-bezier") {
            const S = o.controlPoints;
            w = new fr(S[0], S[1], S[2], S[3]).solve(el(d, 1, g, v));
          }
          return w;
        }
        static parse(o, d) {
          let [g, v, w, ...S] = o;
          if (!Array.isArray(v) || v.length === 0)
            return d.error("Expected an interpolation type expression.", 1);
          if (v[0] === "linear")
            v = { name: "linear" };
          else if (v[0] === "exponential") {
            const k = v[1];
            if (typeof k != "number")
              return d.error("Exponential interpolation requires a numeric base.", 1, 1);
            v = { name: "exponential", base: k };
          } else {
            if (v[0] !== "cubic-bezier")
              return d.error(`Unknown interpolation type ${String(v[0])}`, 1, 0);
            {
              const k = v.slice(1);
              if (k.length !== 4 || k.some((j) => typeof j != "number" || j < 0 || j > 1))
                return d.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
              v = { name: "cubic-bezier", controlPoints: k };
            }
          }
          if (o.length - 1 < 4)
            return d.error(`Expected at least 4 arguments, but found only ${o.length - 1}.`);
          if ((o.length - 1) % 2 != 0)
            return d.error("Expected an even number of arguments.");
          if (w = d.parse(w, 2, _t), !w)
            return null;
          const P = [];
          let B = null;
          g === "interpolate-hcl" || g === "interpolate-lab" ? B = qn : d.expectedType && d.expectedType.kind !== "value" && (B = d.expectedType);
          for (let k = 0; k < S.length; k += 2) {
            const j = S[k], q = S[k + 1], Z = k + 3, ee = k + 4;
            if (typeof j != "number")
              return d.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', Z);
            if (P.length && P[P.length - 1][0] >= j)
              return d.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', Z);
            const oe = d.parse(q, ee, B);
            if (!oe)
              return null;
            B = B || oe.type, P.push([j, oe]);
          }
          return Be(B, _t) || Be(B, qn) || Be(B, sr) || Be(B, ve) || Be(B, X(_t)) ? new yn(B, g, v, w, P) : d.error(`Type ${$(B)} is not interpolatable.`);
        }
        evaluate(o) {
          const d = this.labels, g = this.outputs;
          if (d.length === 1)
            return g[0].evaluate(o);
          const v = this.input.evaluate(o);
          if (v <= d[0])
            return g[0].evaluate(o);
          const w = d.length;
          if (v >= d[w - 1])
            return g[w - 1].evaluate(o);
          const S = St(d, v), P = yn.interpolationFactor(this.interpolation, v, d[S], d[S + 1]), B = g[S].evaluate(o), k = g[S + 1].evaluate(o);
          switch (this.operator) {
            case "interpolate":
              return Nr[this.type.kind](B, k, P);
            case "interpolate-hcl":
              return Nr.color(B, k, P, "hcl");
            case "interpolate-lab":
              return Nr.color(B, k, P, "lab");
          }
        }
        eachChild(o) {
          o(this.input);
          for (const d of this.outputs)
            o(d);
        }
        outputDefined() {
          return this.outputs.every((o) => o.outputDefined());
        }
      }
      function el(u, o, d, g) {
        const v = g - d, w = u - d;
        return v === 0 ? 0 : o === 1 ? w / v : (Math.pow(o, w) - 1) / (Math.pow(o, v) - 1);
      }
      class Rl {
        constructor(o, d) {
          this.type = o, this.args = d;
        }
        static parse(o, d) {
          if (o.length < 2)
            return d.error("Expectected at least one argument.");
          let g = null;
          const v = d.expectedType;
          v && v.kind !== "value" && (g = v);
          const w = [];
          for (const P of o.slice(1)) {
            const B = d.parse(P, 1 + w.length, g, void 0, { typeAnnotation: "omit" });
            if (!B)
              return null;
            g = g || B.type, w.push(B);
          }
          if (!g)
            throw new Error("No output type");
          const S = v && w.some((P) => _e(v, P.type));
          return new Rl(S ? Nt : g, w);
        }
        evaluate(o) {
          let d, g = null, v = 0;
          for (const w of this.args)
            if (v++, g = w.evaluate(o), g && g instanceof fi && !g.available && (d || (d = g.name), g = null, v === this.args.length && (g = d)), g !== null)
              break;
          return g;
        }
        eachChild(o) {
          this.args.forEach(o);
        }
        outputDefined() {
          return this.args.every((o) => o.outputDefined());
        }
      }
      function eo(u, o) {
        return u === "==" || u === "!=" ? o.kind === "boolean" || o.kind === "string" || o.kind === "number" || o.kind === "null" || o.kind === "value" : o.kind === "string" || o.kind === "number" || o.kind === "value";
      }
      function vc(u, o, d, g) {
        return g.compare(o, d) === 0;
      }
      function vo(u, o, d) {
        const g = u !== "==" && u !== "!=";
        return class d5 {
          constructor(w, S, P) {
            this.type = Gt, this.lhs = w, this.rhs = S, this.collator = P, this.hasUntypedArgument = w.type.kind === "value" || S.type.kind === "value";
          }
          static parse(w, S) {
            if (w.length !== 3 && w.length !== 4)
              return S.error("Expected two or three arguments.");
            const P = w[0];
            let B = S.parse(w[1], 1, Nt);
            if (!B)
              return null;
            if (!eo(P, B.type))
              return S.concat(1).error(`"${P}" comparisons are not supported for type '${$(B.type)}'.`);
            let k = S.parse(w[2], 2, Nt);
            if (!k)
              return null;
            if (!eo(P, k.type))
              return S.concat(2).error(`"${P}" comparisons are not supported for type '${$(k.type)}'.`);
            if (B.type.kind !== k.type.kind && B.type.kind !== "value" && k.type.kind !== "value")
              return S.error(`Cannot compare types '${$(B.type)}' and '${$(k.type)}'.`);
            g && (B.type.kind === "value" && k.type.kind !== "value" ? B = new hr(k.type, [B]) : B.type.kind !== "value" && k.type.kind === "value" && (k = new hr(B.type, [k])));
            let j = null;
            if (w.length === 4) {
              if (B.type.kind !== "string" && k.type.kind !== "string" && B.type.kind !== "value" && k.type.kind !== "value")
                return S.error("Cannot use collator to compare non-string types.");
              if (j = S.parse(w[3], 3, vr), !j)
                return null;
            }
            return new d5(B, k, j);
          }
          evaluate(w) {
            const S = this.lhs.evaluate(w), P = this.rhs.evaluate(w);
            if (g && this.hasUntypedArgument) {
              const B = xi(S), k = xi(P);
              if (B.kind !== k.kind || B.kind !== "string" && B.kind !== "number")
                throw new _i(`Expected arguments for "${u}" to be (string, string) or (number, number), but found (${B.kind}, ${k.kind}) instead.`);
            }
            if (this.collator && !g && this.hasUntypedArgument) {
              const B = xi(S), k = xi(P);
              if (B.kind !== "string" || k.kind !== "string")
                return o(w, S, P);
            }
            return this.collator ? d(w, S, P, this.collator.evaluate(w)) : o(w, S, P);
          }
          eachChild(w) {
            w(this.lhs), w(this.rhs), this.collator && w(this.collator);
          }
          outputDefined() {
            return !0;
          }
        };
      }
      const tl = vo("==", function(u, o, d) {
        return o === d;
      }, vc), bc = vo("!=", function(u, o, d) {
        return o !== d;
      }, function(u, o, d, g) {
        return !vc(0, o, d, g);
      }), Ku = vo("<", function(u, o, d) {
        return o < d;
      }, function(u, o, d, g) {
        return g.compare(o, d) < 0;
      }), su = vo(">", function(u, o, d) {
        return o > d;
      }, function(u, o, d, g) {
        return g.compare(o, d) > 0;
      }), ou = vo("<=", function(u, o, d) {
        return o <= d;
      }, function(u, o, d, g) {
        return g.compare(o, d) <= 0;
      }), xc = vo(">=", function(u, o, d) {
        return o >= d;
      }, function(u, o, d, g) {
        return g.compare(o, d) >= 0;
      });
      class bo {
        constructor(o, d, g) {
          this.type = vr, this.locale = g, this.caseSensitive = o, this.diacriticSensitive = d;
        }
        static parse(o, d) {
          if (o.length !== 2)
            return d.error("Expected one argument.");
          const g = o[1];
          if (typeof g != "object" || Array.isArray(g))
            return d.error("Collator options argument must be an object.");
          const v = d.parse(g["case-sensitive"] !== void 0 && g["case-sensitive"], 1, Gt);
          if (!v)
            return null;
          const w = d.parse(g["diacritic-sensitive"] !== void 0 && g["diacritic-sensitive"], 1, Gt);
          if (!w)
            return null;
          let S = null;
          return g.locale && (S = d.parse(g.locale, 1, bn), !S) ? null : new bo(v, w, S);
        }
        evaluate(o) {
          return new br(this.caseSensitive.evaluate(o), this.diacriticSensitive.evaluate(o), this.locale ? this.locale.evaluate(o) : null);
        }
        eachChild(o) {
          o(this.caseSensitive), o(this.diacriticSensitive), this.locale && o(this.locale);
        }
        outputDefined() {
          return !1;
        }
      }
      class xo {
        constructor(o, d, g, v, w) {
          this.type = bn, this.number = o, this.locale = d, this.currency = g, this.minFractionDigits = v, this.maxFractionDigits = w;
        }
        static parse(o, d) {
          if (o.length !== 3)
            return d.error("Expected two arguments.");
          const g = d.parse(o[1], 1, _t);
          if (!g)
            return null;
          const v = o[2];
          if (typeof v != "object" || Array.isArray(v))
            return d.error("NumberFormat options argument must be an object.");
          let w = null;
          if (v.locale && (w = d.parse(v.locale, 1, bn), !w))
            return null;
          let S = null;
          if (v.currency && (S = d.parse(v.currency, 1, bn), !S))
            return null;
          let P = null;
          if (v["min-fraction-digits"] && (P = d.parse(v["min-fraction-digits"], 1, _t), !P))
            return null;
          let B = null;
          return v["max-fraction-digits"] && (B = d.parse(v["max-fraction-digits"], 1, _t), !B) ? null : new xo(g, w, S, P, B);
        }
        evaluate(o) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(o) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(o) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(o) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(o) : void 0 }).format(this.number.evaluate(o));
        }
        eachChild(o) {
          o(this.number), this.locale && o(this.locale), this.currency && o(this.currency), this.minFractionDigits && o(this.minFractionDigits), this.maxFractionDigits && o(this.maxFractionDigits);
        }
        outputDefined() {
          return !1;
        }
      }
      class Ol {
        constructor(o) {
          this.type = ii, this.sections = o;
        }
        static parse(o, d) {
          if (o.length < 2)
            return d.error("Expected at least one argument.");
          const g = o[1];
          if (!Array.isArray(g) && typeof g == "object")
            return d.error("First argument must be an image or text section.");
          const v = [];
          let w = !1;
          for (let S = 1; S <= o.length - 1; ++S) {
            const P = o[S];
            if (w && typeof P == "object" && !Array.isArray(P)) {
              w = !1;
              let B = null;
              if (P["font-scale"] && (B = d.parse(P["font-scale"], 1, _t), !B))
                return null;
              let k = null;
              if (P["text-font"] && (k = d.parse(P["text-font"], 1, X(bn)), !k))
                return null;
              let j = null;
              if (P["text-color"] && (j = d.parse(P["text-color"], 1, qn), !j))
                return null;
              const q = v[v.length - 1];
              q.scale = B, q.font = k, q.textColor = j;
            } else {
              const B = d.parse(o[S], 1, Nt);
              if (!B)
                return null;
              const k = B.type.kind;
              if (k !== "string" && k !== "value" && k !== "null" && k !== "resolvedImage")
                return d.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              w = !0, v.push({ content: B, scale: null, font: null, textColor: null });
            }
          }
          return new Ol(v);
        }
        evaluate(o) {
          return new Ri(this.sections.map((d) => {
            const g = d.content.evaluate(o);
            return xi(g) === or ? new Hr("", g, null, null, null) : new Hr(Nn(g), null, d.scale ? d.scale.evaluate(o) : null, d.font ? d.font.evaluate(o).join(",") : null, d.textColor ? d.textColor.evaluate(o) : null);
          }));
        }
        eachChild(o) {
          for (const d of this.sections)
            o(d.content), d.scale && o(d.scale), d.font && o(d.font), d.textColor && o(d.textColor);
        }
        outputDefined() {
          return !1;
        }
      }
      class Go {
        constructor(o) {
          this.type = or, this.input = o;
        }
        static parse(o, d) {
          if (o.length !== 2)
            return d.error("Expected two arguments.");
          const g = d.parse(o[1], 1, bn);
          return g ? new Go(g) : d.error("No image name provided.");
        }
        evaluate(o) {
          const d = this.input.evaluate(o), g = fi.fromString(d);
          return g && o.availableImages && (g.available = o.availableImages.indexOf(d) > -1), g;
        }
        eachChild(o) {
          o(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      class nl {
        constructor(o) {
          this.type = _t, this.input = o;
        }
        static parse(o, d) {
          if (o.length !== 2)
            return d.error(`Expected 1 argument, but found ${o.length - 1} instead.`);
          const g = d.parse(o[1], 1);
          return g ? g.type.kind !== "array" && g.type.kind !== "string" && g.type.kind !== "value" ? d.error(`Expected argument of type string or array, but found ${$(g.type)} instead.`) : new nl(g) : null;
        }
        evaluate(o) {
          const d = this.input.evaluate(o);
          if (typeof d == "string" || Array.isArray(d))
            return d.length;
          throw new _i(`Expected value to be of type string or array, but found ${$(xi(d))} instead.`);
        }
        eachChild(o) {
          o(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      const Jr = 8192;
      function Fl(u, o) {
        const d = (180 + u[0]) / 360, g = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + u[1] * Math.PI / 360))) / 360, v = Math.pow(2, o.z);
        return [Math.round(d * v * Jr), Math.round(g * v * Jr)];
      }
      function Vo(u, o) {
        const d = Math.pow(2, o.z);
        return [(v = (u[0] / Jr + o.x) / d, 360 * v - 180), (g = (u[1] / Jr + o.y) / d, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * g) * Math.PI / 180)) - 90)];
        var g, v;
      }
      function Hn(u, o) {
        u[0] = Math.min(u[0], o[0]), u[1] = Math.min(u[1], o[1]), u[2] = Math.max(u[2], o[0]), u[3] = Math.max(u[3], o[1]);
      }
      function _a(u, o) {
        return !(u[0] <= o[0] || u[2] >= o[2] || u[1] <= o[1] || u[3] >= o[3]);
      }
      function qo(u, o, d) {
        const g = u[0] - o[0], v = u[1] - o[1], w = u[0] - d[0], S = u[1] - d[1];
        return g * S - w * v == 0 && g * w <= 0 && v * S <= 0;
      }
      function to(u, o, d, g) {
        return (v = [g[0] - d[0], g[1] - d[1]])[0] * (w = [o[0] - u[0], o[1] - u[1]])[1] - v[1] * w[0] != 0 && !(!au(u, o, d, g) || !au(d, g, u, o));
        var v, w;
      }
      function Qu(u, o, d) {
        for (const g of d)
          for (let v = 0; v < g.length - 1; ++v)
            if (to(u, o, g[v], g[v + 1]))
              return !0;
        return !1;
      }
      function ys(u, o) {
        let d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, g = !1;
        for (const P of o)
          for (let B = 0; B < P.length - 1; B++) {
            if (qo(u, P[B], P[B + 1]))
              return d;
            (w = P[B])[1] > (v = u)[1] != (S = P[B + 1])[1] > v[1] && v[0] < (S[0] - w[0]) * (v[1] - w[1]) / (S[1] - w[1]) + w[0] && (g = !g);
          }
        var v, w, S;
        return g;
      }
      function no(u, o) {
        for (const d of o)
          if (ys(u, d))
            return !0;
        return !1;
      }
      function Dl(u, o) {
        for (const d of u)
          if (!ys(d, o))
            return !1;
        for (let d = 0; d < u.length - 1; ++d)
          if (Qu(u[d], u[d + 1], o))
            return !1;
        return !0;
      }
      function il(u, o) {
        for (const d of o)
          if (Dl(u, d))
            return !0;
        return !1;
      }
      function au(u, o, d, g) {
        const v = g[0] - d[0], w = g[1] - d[1], S = (u[0] - d[0]) * w - v * (u[1] - d[1]), P = (o[0] - d[0]) * w - v * (o[1] - d[1]);
        return S > 0 && P < 0 || S < 0 && P > 0;
      }
      function ya(u, o, d) {
        const g = [];
        for (let v = 0; v < u.length; v++) {
          const w = [];
          for (let S = 0; S < u[v].length; S++) {
            const P = Fl(u[v][S], d);
            Hn(o, P), w.push(P);
          }
          g.push(w);
        }
        return g;
      }
      function lu(u, o, d) {
        const g = [];
        for (let v = 0; v < u.length; v++) {
          const w = ya(u[v], o, d);
          g.push(w);
        }
        return g;
      }
      function kl(u, o, d, g) {
        if (u[0] < d[0] || u[0] > d[2]) {
          const v = 0.5 * g;
          let w = u[0] - d[0] > v ? -g : d[0] - u[0] > v ? g : 0;
          w === 0 && (w = u[0] - d[2] > v ? -g : d[2] - u[0] > v ? g : 0), u[0] += w;
        }
        Hn(o, u);
      }
      function Nl(u, o, d, g) {
        const v = Math.pow(2, g.z) * Jr, w = [g.x * Jr, g.y * Jr], S = [];
        for (const P of u)
          for (const B of P) {
            const k = [B.x + w[0], B.y + w[1]];
            kl(k, o, d, v), S.push(k);
          }
        return S;
      }
      function wc(u, o, d, g) {
        const v = Math.pow(2, g.z) * Jr, w = [g.x * Jr, g.y * Jr], S = [];
        for (const B of u) {
          const k = [];
          for (const j of B) {
            const q = [j.x + w[0], j.y + w[1]];
            Hn(o, q), k.push(q);
          }
          S.push(k);
        }
        if (o[2] - o[0] <= v / 2) {
          (P = o)[0] = P[1] = 1 / 0, P[2] = P[3] = -1 / 0;
          for (const B of S)
            for (const k of B)
              kl(k, o, d, v);
        }
        var P;
        return S;
      }
      class Ps {
        constructor(o, d) {
          this.type = Gt, this.geojson = o, this.geometries = d;
        }
        static parse(o, d) {
          if (o.length !== 2)
            return d.error(`'within' expression requires exactly one argument, but found ${o.length - 1} instead.`);
          if (_s(o[1])) {
            const g = o[1];
            if (g.type === "FeatureCollection") {
              const v = [];
              for (const w of g.features) {
                const { type: S, coordinates: P } = w.geometry;
                S === "Polygon" && v.push(P), S === "MultiPolygon" && v.push(...P);
              }
              if (v.length)
                return new Ps(g, { type: "MultiPolygon", coordinates: v });
            } else if (g.type === "Feature") {
              const v = g.geometry.type;
              if (v === "Polygon" || v === "MultiPolygon")
                return new Ps(g, g.geometry);
            } else if (g.type === "Polygon" || g.type === "MultiPolygon")
              return new Ps(g, g);
          }
          return d.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(o) {
          if (o.geometry() != null && o.canonicalID() != null) {
            if (o.geometryType() === "Point")
              return function(d, g) {
                const v = [1 / 0, 1 / 0, -1 / 0, -1 / 0], w = [1 / 0, 1 / 0, -1 / 0, -1 / 0], S = d.canonicalID();
                if (g.type === "Polygon") {
                  const P = ya(g.coordinates, w, S), B = Nl(d.geometry(), v, w, S);
                  if (!_a(v, w))
                    return !1;
                  for (const k of B)
                    if (!ys(k, P))
                      return !1;
                }
                if (g.type === "MultiPolygon") {
                  const P = lu(g.coordinates, w, S), B = Nl(d.geometry(), v, w, S);
                  if (!_a(v, w))
                    return !1;
                  for (const k of B)
                    if (!no(k, P))
                      return !1;
                }
                return !0;
              }(o, this.geometries);
            if (o.geometryType() === "LineString")
              return function(d, g) {
                const v = [1 / 0, 1 / 0, -1 / 0, -1 / 0], w = [1 / 0, 1 / 0, -1 / 0, -1 / 0], S = d.canonicalID();
                if (g.type === "Polygon") {
                  const P = ya(g.coordinates, w, S), B = wc(d.geometry(), v, w, S);
                  if (!_a(v, w))
                    return !1;
                  for (const k of B)
                    if (!Dl(k, P))
                      return !1;
                }
                if (g.type === "MultiPolygon") {
                  const P = lu(g.coordinates, w, S), B = wc(d.geometry(), v, w, S);
                  if (!_a(v, w))
                    return !1;
                  for (const k of B)
                    if (!il(k, P))
                      return !1;
                }
                return !0;
              }(o, this.geometries);
          }
          return !1;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      let zl = class {
        constructor() {
          let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ac;
          if (this.data = u, this.length = this.data.length, this.compare = o, this.length > 0)
            for (let d = (this.length >> 1) - 1; d >= 0; d--)
              this._down(d);
        }
        push(u) {
          this.data.push(u), this.length++, this._up(this.length - 1);
        }
        pop() {
          if (this.length === 0)
            return;
          const u = this.data[0], o = this.data.pop();
          return this.length--, this.length > 0 && (this.data[0] = o, this._down(0)), u;
        }
        peek() {
          return this.data[0];
        }
        _up(u) {
          const { data: o, compare: d } = this, g = o[u];
          for (; u > 0; ) {
            const v = u - 1 >> 1, w = o[v];
            if (d(g, w) >= 0)
              break;
            o[u] = w, u = v;
          }
          o[u] = g;
        }
        _down(u) {
          const { data: o, compare: d } = this, g = this.length >> 1, v = o[u];
          for (; u < g; ) {
            let w = 1 + (u << 1), S = o[w];
            const P = w + 1;
            if (P < this.length && d(o[P], S) < 0 && (w = P, S = o[P]), d(S, v) >= 0)
              break;
            o[u] = S, u = w;
          }
          o[u] = v;
        }
      };
      function Ac(u, o) {
        return u < o ? -1 : u > o ? 1 : 0;
      }
      function cu(u, o, d, g, v) {
        uu(u, o, d, g || u.length - 1, v || rl);
      }
      function uu(u, o, d, g, v) {
        for (; g > d; ) {
          if (g - d > 600) {
            var w = g - d + 1, S = o - d + 1, P = Math.log(w), B = 0.5 * Math.exp(2 * P / 3), k = 0.5 * Math.sqrt(P * B * (w - B) / w) * (S - w / 2 < 0 ? -1 : 1);
            uu(u, o, Math.max(d, Math.floor(o - S * B / w + k)), Math.min(g, Math.floor(o + (w - S) * B / w + k)), v);
          }
          var j = u[o], q = d, Z = g;
          for (wo(u, d, o), v(u[g], j) > 0 && wo(u, d, g); q < Z; ) {
            for (wo(u, q, Z), q++, Z--; v(u[q], j) < 0; )
              q++;
            for (; v(u[Z], j) > 0; )
              Z--;
          }
          v(u[d], j) === 0 ? wo(u, d, Z) : wo(u, ++Z, g), Z <= o && (d = Z + 1), o <= Z && (g = Z - 1);
        }
      }
      function wo(u, o, d) {
        var g = u[o];
        u[o] = u[d], u[d] = g;
      }
      function rl(u, o) {
        return u < o ? -1 : u > o ? 1 : 0;
      }
      function va(u, o) {
        if (u.length <= 1)
          return [u];
        const d = [];
        let g, v;
        for (const w of u) {
          const S = Ec(w);
          S !== 0 && (w.area = Math.abs(S), v === void 0 && (v = S < 0), v === S < 0 ? (g && d.push(g), g = [w]) : g.push(w));
        }
        if (g && d.push(g), o > 1)
          for (let w = 0; w < d.length; w++)
            d[w].length <= o || (cu(d[w], o, 1, d[w].length - 1, ba), d[w] = d[w].slice(0, o));
        return d;
      }
      function ba(u, o) {
        return o.area - u.area;
      }
      function Ec(u) {
        let o = 0;
        for (let d, g, v = 0, w = u.length, S = w - 1; v < w; S = v++)
          d = u[v], g = u[S], o += (g.x - d.x) * (d.y + g.y);
        return o;
      }
      const F = 1 / 298.257223563, te = F * (2 - F), Ee = Math.PI / 180;
      class ze {
        constructor(o) {
          const d = 6378.137 * Ee * 1e3, g = Math.cos(o * Ee), v = 1 / (1 - te * (1 - g * g)), w = Math.sqrt(v);
          this.kx = d * w * g, this.ky = d * w * v * (1 - te);
        }
        distance(o, d) {
          const g = this.wrap(o[0] - d[0]) * this.kx, v = (o[1] - d[1]) * this.ky;
          return Math.sqrt(g * g + v * v);
        }
        pointOnLine(o, d) {
          let g, v, w, S, P = 1 / 0;
          for (let B = 0; B < o.length - 1; B++) {
            let k = o[B][0], j = o[B][1], q = this.wrap(o[B + 1][0] - k) * this.kx, Z = (o[B + 1][1] - j) * this.ky, ee = 0;
            q === 0 && Z === 0 || (ee = (this.wrap(d[0] - k) * this.kx * q + (d[1] - j) * this.ky * Z) / (q * q + Z * Z), ee > 1 ? (k = o[B + 1][0], j = o[B + 1][1]) : ee > 0 && (k += q / this.kx * ee, j += Z / this.ky * ee)), q = this.wrap(d[0] - k) * this.kx, Z = (d[1] - j) * this.ky;
            const oe = q * q + Z * Z;
            oe < P && (P = oe, g = k, v = j, w = B, S = ee);
          }
          return { point: [g, v], index: w, t: Math.max(0, Math.min(1, S)) };
        }
        wrap(o) {
          for (; o < -180; )
            o += 360;
          for (; o > 180; )
            o -= 360;
          return o;
        }
      }
      function Je(u, o) {
        return o[0] - u[0];
      }
      function dt(u) {
        return u[1] - u[0] + 1;
      }
      function Tt(u, o) {
        return u[1] >= u[0] && u[1] < o;
      }
      function Xt(u, o) {
        if (u[0] > u[1])
          return [null, null];
        const d = dt(u);
        if (o) {
          if (d === 2)
            return [u, null];
          const v = Math.floor(d / 2);
          return [[u[0], u[0] + v], [u[0] + v, u[1]]];
        }
        if (d === 1)
          return [u, null];
        const g = Math.floor(d / 2) - 1;
        return [[u[0], u[0] + g], [u[0] + g + 1, u[1]]];
      }
      function vn(u, o) {
        if (!Tt(o, u.length))
          return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        const d = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (let g = o[0]; g <= o[1]; ++g)
          Hn(d, u[g]);
        return d;
      }
      function Ln(u) {
        const o = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (const d of u)
          for (const g of d)
            Hn(o, g);
        return o;
      }
      function zn(u) {
        return u[0] !== -1 / 0 && u[1] !== -1 / 0 && u[2] !== 1 / 0 && u[3] !== 1 / 0;
      }
      function $n(u, o, d) {
        if (!zn(u) || !zn(o))
          return NaN;
        let g = 0, v = 0;
        return u[2] < o[0] && (g = o[0] - u[2]), u[0] > o[2] && (g = u[0] - o[2]), u[1] > o[3] && (v = u[1] - o[3]), u[3] < o[1] && (v = o[1] - u[3]), d.distance([0, 0], [g, v]);
      }
      function In(u, o, d) {
        const g = d.pointOnLine(o, u);
        return d.distance(u, g.point);
      }
      function $i(u, o, d, g, v) {
        const w = Math.min(In(u, [d, g], v), In(o, [d, g], v)), S = Math.min(In(d, [u, o], v), In(g, [u, o], v));
        return Math.min(w, S);
      }
      function fn(u, o, d, g, v) {
        if (!Tt(o, u.length) || !Tt(g, d.length))
          return 1 / 0;
        let w = 1 / 0;
        for (let S = o[0]; S < o[1]; ++S) {
          const P = u[S], B = u[S + 1];
          for (let k = g[0]; k < g[1]; ++k) {
            const j = d[k], q = d[k + 1];
            if (to(P, B, j, q))
              return 0;
            w = Math.min(w, $i(P, B, j, q, v));
          }
        }
        return w;
      }
      function xr(u, o, d, g, v) {
        if (!Tt(o, u.length) || !Tt(g, d.length))
          return NaN;
        let w = 1 / 0;
        for (let S = o[0]; S <= o[1]; ++S)
          for (let P = g[0]; P <= g[1]; ++P)
            if (w = Math.min(w, v.distance(u[S], d[P])), w === 0)
              return w;
        return w;
      }
      function kn(u, o, d) {
        if (ys(u, o, !0))
          return 0;
        let g = 1 / 0;
        for (const v of o) {
          const w = v[0], S = v[v.length - 1];
          if (w !== S && (g = Math.min(g, In(u, [S, w], d)), g === 0))
            return g;
          const P = d.pointOnLine(v, u);
          if (g = Math.min(g, d.distance(u, P.point)), g === 0)
            return g;
        }
        return g;
      }
      function Zn(u, o, d, g) {
        if (!Tt(o, u.length))
          return NaN;
        for (let w = o[0]; w <= o[1]; ++w)
          if (ys(u[w], d, !0))
            return 0;
        let v = 1 / 0;
        for (let w = o[0]; w < o[1]; ++w) {
          const S = u[w], P = u[w + 1];
          for (const B of d)
            for (let k = 0, j = B.length, q = j - 1; k < j; q = k++) {
              const Z = B[q], ee = B[k];
              if (to(S, P, Z, ee))
                return 0;
              v = Math.min(v, $i(S, P, Z, ee, g));
            }
        }
        return v;
      }
      function zr(u, o) {
        for (const d of u)
          for (const g of d)
            if (ys(g, o, !0))
              return !0;
        return !1;
      }
      function Ao(u, o, d) {
        let g = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1 / 0;
        const v = Ln(u), w = Ln(o);
        if (g !== 1 / 0 && $n(v, w, d) >= g)
          return g;
        if (_a(v, w)) {
          if (zr(u, o))
            return 0;
        } else if (zr(o, u))
          return 0;
        let S = 1 / 0;
        for (const P of u)
          for (let B = 0, k = P.length, j = k - 1; B < k; j = B++) {
            const q = P[j], Z = P[B];
            for (const ee of o)
              for (let oe = 0, pe = ee.length, we = pe - 1; oe < pe; we = oe++) {
                const Pe = ee[we], He = ee[oe];
                if (to(q, Z, Pe, He))
                  return 0;
                S = Math.min(S, $i(q, Z, Pe, He, d));
              }
          }
        return S;
      }
      function Ul(u, o, d, g, v, w) {
        if (!w)
          return;
        const S = $n(vn(g, w), v, d);
        S < o && u.push([S, w, [0, 0]]);
      }
      function xa(u, o, d, g, v, w, S) {
        if (!w || !S)
          return;
        const P = $n(vn(g, w), vn(v, S), d);
        P < o && u.push([P, w, S]);
      }
      function wa(u, o, d, g) {
        let v = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1 / 0, w = Math.min(g.distance(u[0], d[0][0]), v);
        if (w === 0)
          return w;
        const S = new zl([[0, [0, u.length - 1], [0, 0]]], Je), P = Ln(d);
        for (; S.length > 0; ) {
          const B = S.pop();
          if (B[0] >= w)
            continue;
          const k = B[1], j = o ? 50 : 100;
          if (dt(k) <= j) {
            if (!Tt(k, u.length))
              return NaN;
            if (o) {
              const q = Zn(u, k, d, g);
              if (isNaN(q) || q === 0)
                return q;
              w = Math.min(w, q);
            } else
              for (let q = k[0]; q <= k[1]; ++q) {
                const Z = kn(u[q], d, g);
                if (w = Math.min(w, Z), w === 0)
                  return 0;
              }
          } else {
            const q = Xt(k, o);
            Ul(S, w, g, u, P, q[0]), Ul(S, w, g, u, P, q[1]);
          }
        }
        return w;
      }
      function Ho(u, o, d, g, v) {
        let w = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1 / 0, S = Math.min(w, v.distance(u[0], d[0]));
        if (S === 0)
          return S;
        const P = new zl([[0, [0, u.length - 1], [0, d.length - 1]]], Je);
        for (; P.length > 0; ) {
          const B = P.pop();
          if (B[0] >= S)
            continue;
          const k = B[1], j = B[2], q = o ? 50 : 100, Z = g ? 50 : 100;
          if (dt(k) <= q && dt(j) <= Z) {
            if (!Tt(k, u.length) && Tt(j, d.length))
              return NaN;
            let ee;
            if (o && g)
              ee = fn(u, k, d, j, v), S = Math.min(S, ee);
            else if (o && !g) {
              const oe = u.slice(k[0], k[1] + 1);
              for (let pe = j[0]; pe <= j[1]; ++pe)
                if (ee = In(d[pe], oe, v), S = Math.min(S, ee), S === 0)
                  return S;
            } else if (!o && g) {
              const oe = d.slice(j[0], j[1] + 1);
              for (let pe = k[0]; pe <= k[1]; ++pe)
                if (ee = In(u[pe], oe, v), S = Math.min(S, ee), S === 0)
                  return S;
            } else
              ee = xr(u, k, d, j, v), S = Math.min(S, ee);
          } else {
            const ee = Xt(k, o), oe = Xt(j, g);
            xa(P, S, v, u, d, ee[0], oe[0]), xa(P, S, v, u, d, ee[0], oe[1]), xa(P, S, v, u, d, ee[1], oe[0]), xa(P, S, v, u, d, ee[1], oe[1]);
          }
        }
        return S;
      }
      function sl(u) {
        return u.type === "MultiPolygon" ? u.coordinates.map((o) => ({ type: "Polygon", coordinates: o })) : u.type === "MultiLineString" ? u.coordinates.map((o) => ({ type: "LineString", coordinates: o })) : u.type === "MultiPoint" ? u.coordinates.map((o) => ({ type: "Point", coordinates: o })) : [u];
      }
      class Ls {
        constructor(o, d) {
          this.type = _t, this.geojson = o, this.geometries = d;
        }
        static parse(o, d) {
          if (o.length !== 2)
            return d.error(`'distance' expression requires exactly one argument, but found ${o.length - 1} instead.`);
          if (_s(o[1])) {
            const g = o[1];
            if (g.type === "FeatureCollection")
              return new Ls(g, g.features.map((v) => sl(v.geometry)).flat());
            if (g.type === "Feature")
              return new Ls(g, sl(g.geometry));
            if ("type" in g && "coordinates" in g)
              return new Ls(g, sl(g));
          }
          return d.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(o) {
          if (o.geometry() != null && o.canonicalID() != null) {
            if (o.geometryType() === "Point")
              return function(d, g) {
                const v = d.geometry(), w = v.flat().map((B) => Vo([B.x, B.y], d.canonical));
                if (v.length === 0)
                  return NaN;
                const S = new ze(w[0][1]);
                let P = 1 / 0;
                for (const B of g) {
                  switch (B.type) {
                    case "Point":
                      P = Math.min(P, Ho(w, !1, [B.coordinates], !1, S, P));
                      break;
                    case "LineString":
                      P = Math.min(P, Ho(w, !1, B.coordinates, !0, S, P));
                      break;
                    case "Polygon":
                      P = Math.min(P, wa(w, !1, B.coordinates, S, P));
                  }
                  if (P === 0)
                    return P;
                }
                return P;
              }(o, this.geometries);
            if (o.geometryType() === "LineString")
              return function(d, g) {
                const v = d.geometry(), w = v.flat().map((B) => Vo([B.x, B.y], d.canonical));
                if (v.length === 0)
                  return NaN;
                const S = new ze(w[0][1]);
                let P = 1 / 0;
                for (const B of g) {
                  switch (B.type) {
                    case "Point":
                      P = Math.min(P, Ho(w, !0, [B.coordinates], !1, S, P));
                      break;
                    case "LineString":
                      P = Math.min(P, Ho(w, !0, B.coordinates, !0, S, P));
                      break;
                    case "Polygon":
                      P = Math.min(P, wa(w, !0, B.coordinates, S, P));
                  }
                  if (P === 0)
                    return P;
                }
                return P;
              }(o, this.geometries);
            if (o.geometryType() === "Polygon")
              return function(d, g) {
                const v = d.geometry();
                if (v.length === 0 || v[0].length === 0)
                  return NaN;
                const w = va(v, 0).map((B) => B.map((k) => k.map((j) => Vo([j.x, j.y], d.canonical)))), S = new ze(w[0][0][0][1]);
                let P = 1 / 0;
                for (const B of g)
                  for (const k of w) {
                    switch (B.type) {
                      case "Point":
                        P = Math.min(P, wa([B.coordinates], !1, k, S, P));
                        break;
                      case "LineString":
                        P = Math.min(P, wa(B.coordinates, !0, k, S, P));
                        break;
                      case "Polygon":
                        P = Math.min(P, Ao(k, B.coordinates, S, P));
                    }
                    if (P === 0)
                      return P;
                  }
                return P;
              }(o, this.geometries);
          }
          return NaN;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      const Ms = { "==": tl, "!=": bc, ">": su, "<": Ku, ">=": xc, "<=": ou, array: hr, at: ma, boolean: hr, case: Re, coalesce: Rl, collator: bo, format: Ol, image: Go, in: jo, "index-of": ue, interpolate: yn, "interpolate-hcl": yn, "interpolate-lab": yn, length: nl, let: jn, literal: Wr, match: ge, number: hr, "number-format": xo, object: hr, slice: it, step: Wt, string: hr, "to-boolean": Ji, "to-color": Ji, "to-number": Ji, "to-string": Ji, var: Uo, within: Ps, distance: Ls };
      class Pi {
        constructor(o, d, g, v) {
          this.name = o, this.type = d, this._evaluate = g, this.args = v;
        }
        evaluate(o) {
          return this._evaluate(o, this.args);
        }
        eachChild(o) {
          this.args.forEach(o);
        }
        outputDefined() {
          return !1;
        }
        static parse(o, d) {
          const g = o[0], v = Pi.definitions[g];
          if (!v)
            return d.error(`Unknown expression "${g}". If you wanted a literal array, use ["literal", [...]].`, 0);
          const w = Array.isArray(v) ? v[0] : v.type, S = Array.isArray(v) ? [[v[1], v[2]]] : v.overloads, P = S.filter((k) => {
            let [j] = k;
            return !Array.isArray(j) || j.length === o.length - 1;
          });
          let B = null;
          for (const [k, j] of P) {
            B = new Xr(d.registry, Lr, d.path, null, d.scope);
            const q = [];
            let Z = !1;
            for (let ee = 1; ee < o.length; ee++) {
              const oe = o[ee], pe = Array.isArray(k) ? k[ee - 1] : k.type, we = B.parse(oe, 1 + q.length, pe);
              if (!we) {
                Z = !0;
                break;
              }
              q.push(we);
            }
            if (!Z)
              if (Array.isArray(k) && k.length !== q.length)
                B.error(`Expected ${k.length} arguments, but found ${q.length} instead.`);
              else {
                for (let ee = 0; ee < q.length; ee++) {
                  const oe = Array.isArray(k) ? k[ee] : k.type, pe = q[ee];
                  B.concat(ee + 1).checkSubtype(oe, pe.type);
                }
                if (B.errors.length === 0)
                  return new Pi(g, w, j, q);
              }
          }
          if (P.length === 1)
            d.errors.push(...B.errors);
          else {
            const k = (P.length ? P : S).map((q) => {
              let [Z] = q;
              return ee = Z, Array.isArray(ee) ? `(${ee.map($).join(", ")})` : `(${$(ee.type)}...)`;
              var ee;
            }).join(" | "), j = [];
            for (let q = 1; q < o.length; q++) {
              const Z = d.parse(o[q], 1 + j.length);
              if (!Z)
                return null;
              j.push($(Z.type));
            }
            d.error(`Expected arguments of type ${k}, but found (${j.join(", ")}) instead.`);
          }
          return null;
        }
        static register(o, d) {
          Pi.definitions = d;
          for (const g in d)
            o[g] = Pi;
        }
      }
      function Aa(u, o) {
        let [d, g, v, w] = o;
        d = d.evaluate(u), g = g.evaluate(u), v = v.evaluate(u);
        const S = w ? w.evaluate(u) : 1, P = zo(d, g, v, S);
        if (P)
          throw new _i(P);
        return new Xn(d / 255, g / 255, v / 255, S, !1);
      }
      function Wo(u, o) {
        return u in o;
      }
      function Ea(u, o) {
        const d = o[u];
        return d === void 0 ? null : d;
      }
      function io(u) {
        return { type: u };
      }
      function Lr(u) {
        if (u instanceof Uo)
          return Lr(u.boundExpression);
        if (u instanceof Pi && u.name === "error" || u instanceof bo || u instanceof Ps || u instanceof Ls)
          return !1;
        const o = u instanceof Ji || u instanceof hr;
        let d = !0;
        return u.eachChild((g) => {
          d = o ? d && Lr(g) : d && g instanceof Wr;
        }), !!d && jl(u) && ol(u, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
      }
      function jl(u) {
        if (u instanceof Pi && (u.name === "get" && u.args.length === 1 || u.name === "feature-state" || u.name === "has" && u.args.length === 1 || u.name === "properties" || u.name === "geometry-type" || u.name === "id" || /^filter-/.test(u.name)) || u instanceof Ps || u instanceof Ls)
          return !1;
        let o = !0;
        return u.eachChild((d) => {
          o && !jl(d) && (o = !1);
        }), o;
      }
      function Xo(u) {
        if (u instanceof Pi && u.name === "feature-state")
          return !1;
        let o = !0;
        return u.eachChild((d) => {
          o && !Xo(d) && (o = !1);
        }), o;
      }
      function ol(u, o) {
        if (u instanceof Pi && o.indexOf(u.name) >= 0)
          return !1;
        let d = !0;
        return u.eachChild((g) => {
          d && !ol(g, o) && (d = !1);
        }), d;
      }
      function Bs(u) {
        return { result: "success", value: u };
      }
      function Eo(u) {
        return { result: "error", value: u };
      }
      function Jo(u) {
        return u["property-type"] === "data-driven" || u["property-type"] === "cross-faded-data-driven";
      }
      function Sc(u) {
        return !!u.expression && u.expression.parameters.indexOf("zoom") > -1;
      }
      function vs(u) {
        return !!u.expression && u.expression.interpolated;
      }
      function Mn(u) {
        return u instanceof Number ? "number" : u instanceof String ? "string" : u instanceof Boolean ? "boolean" : Array.isArray(u) ? "array" : u === null ? "null" : typeof u;
      }
      function $r(u) {
        return typeof u == "object" && u !== null && !Array.isArray(u);
      }
      function $o(u) {
        return u;
      }
      function ro(u, o) {
        const d = o.type === "color", g = u.stops && typeof u.stops[0][0] == "object", v = g || !(g || u.property !== void 0), w = u.type || (vs(o) ? "exponential" : "interval");
        if (d || o.type === "padding") {
          const j = d ? Xn.parse : Oi.parse;
          (u = hn({}, u)).stops && (u.stops = u.stops.map((q) => [q[0], j(q[1])])), u.default = j(u.default ? u.default : o.default);
        }
        if (u.colorSpace && (S = u.colorSpace) !== "rgb" && S !== "hcl" && S !== "lab")
          throw new Error(`Unknown color space: "${u.colorSpace}"`);
        var S;
        let P, B, k;
        if (w === "exponential")
          P = Sa;
        else if (w === "interval")
          P = os;
        else if (w === "categorical") {
          P = Zo, B = /* @__PURE__ */ Object.create(null);
          for (const j of u.stops)
            B[j[0]] = j[1];
          k = typeof u.stops[0][0];
        } else {
          if (w !== "identity")
            throw new Error(`Unknown function type "${w}"`);
          P = al;
        }
        if (g) {
          const j = {}, q = [];
          for (let oe = 0; oe < u.stops.length; oe++) {
            const pe = u.stops[oe], we = pe[0].zoom;
            j[we] === void 0 && (j[we] = { zoom: we, type: u.type, property: u.property, default: u.default, stops: [] }, q.push(we)), j[we].stops.push([pe[0].value, pe[1]]);
          }
          const Z = [];
          for (const oe of q)
            Z.push([j[oe].zoom, ro(j[oe], o)]);
          const ee = { name: "linear" };
          return { kind: "composite", interpolationType: ee, interpolationFactor: yn.interpolationFactor.bind(void 0, ee), zoomStops: Z.map((oe) => oe[0]), evaluate: (oe, pe) => {
            let { zoom: we } = oe;
            return Sa({ stops: Z, base: u.base }, o, we).evaluate(we, pe);
          } };
        }
        if (v) {
          const j = w === "exponential" ? { name: "exponential", base: u.base !== void 0 ? u.base : 1 } : null;
          return { kind: "camera", interpolationType: j, interpolationFactor: yn.interpolationFactor.bind(void 0, j), zoomStops: u.stops.map((q) => q[0]), evaluate: (q) => {
            let { zoom: Z } = q;
            return P(u, o, Z, B, k);
          } };
        }
        return { kind: "source", evaluate(j, q) {
          const Z = q && q.properties ? q.properties[u.property] : void 0;
          return Z === void 0 ? Zr(u.default, o.default) : P(u, o, Z, B, k);
        } };
      }
      function Zr(u, o, d) {
        return u !== void 0 ? u : o !== void 0 ? o : d !== void 0 ? d : void 0;
      }
      function Zo(u, o, d, g, v) {
        return Zr(typeof d === v ? g[d] : void 0, u.default, o.default);
      }
      function os(u, o, d) {
        if (Mn(d) !== "number")
          return Zr(u.default, o.default);
        const g = u.stops.length;
        if (g === 1 || d <= u.stops[0][0])
          return u.stops[0][1];
        if (d >= u.stops[g - 1][0])
          return u.stops[g - 1][1];
        const v = St(u.stops.map((w) => w[0]), d);
        return u.stops[v][1];
      }
      function Sa(u, o, d) {
        const g = u.base !== void 0 ? u.base : 1;
        if (Mn(d) !== "number")
          return Zr(u.default, o.default);
        const v = u.stops.length;
        if (v === 1 || d <= u.stops[0][0])
          return u.stops[0][1];
        if (d >= u.stops[v - 1][0])
          return u.stops[v - 1][1];
        const w = St(u.stops.map((j) => j[0]), d), S = function(j, q, Z, ee) {
          const oe = ee - Z, pe = j - Z;
          return oe === 0 ? 0 : q === 1 ? pe / oe : (Math.pow(q, pe) - 1) / (Math.pow(q, oe) - 1);
        }(d, g, u.stops[w][0], u.stops[w + 1][0]), P = u.stops[w][1], B = u.stops[w + 1][1], k = Nr[o.type] || $o;
        return typeof P.evaluate == "function" ? { evaluate() {
          for (var j = arguments.length, q = new Array(j), Z = 0; Z < j; Z++)
            q[Z] = arguments[Z];
          const ee = P.evaluate.apply(void 0, q), oe = B.evaluate.apply(void 0, q);
          if (ee !== void 0 && oe !== void 0)
            return k(ee, oe, S, u.colorSpace);
        } } : k(P, B, S, u.colorSpace);
      }
      function al(u, o, d) {
        switch (o.type) {
          case "color":
            d = Xn.parse(d);
            break;
          case "formatted":
            d = Ri.fromString(d.toString());
            break;
          case "resolvedImage":
            d = fi.fromString(d.toString());
            break;
          case "padding":
            d = Oi.parse(d);
            break;
          default:
            Mn(d) === o.type || o.type === "enum" && o.values[d] || (d = void 0);
        }
        return Zr(d, u.default, o.default);
      }
      Pi.register(Ms, { error: [{ kind: "error" }, [bn], (u, o) => {
        let [d] = o;
        throw new _i(d.evaluate(u));
      }], typeof: [bn, [Nt], (u, o) => {
        let [d] = o;
        return $(xi(d.evaluate(u)));
      }], "to-rgba": [X(_t, 4), [qn], (u, o) => {
        let [d] = o;
        const [g, v, w, S] = d.evaluate(u).rgb;
        return [255 * g, 255 * v, 255 * w, S];
      }], rgb: [qn, [_t, _t, _t], Aa], rgba: [qn, [_t, _t, _t, _t], Aa], has: { type: Gt, overloads: [[[bn], (u, o) => {
        let [d] = o;
        return Wo(d.evaluate(u), u.properties());
      }], [[bn, er], (u, o) => {
        let [d, g] = o;
        return Wo(d.evaluate(u), g.evaluate(u));
      }]] }, get: { type: Nt, overloads: [[[bn], (u, o) => {
        let [d] = o;
        return Ea(d.evaluate(u), u.properties());
      }], [[bn, er], (u, o) => {
        let [d, g] = o;
        return Ea(d.evaluate(u), g.evaluate(u));
      }]] }, "feature-state": [Nt, [bn], (u, o) => {
        let [d] = o;
        return Ea(d.evaluate(u), u.featureState || {});
      }], properties: [er, [], (u) => u.properties()], "geometry-type": [bn, [], (u) => u.geometryType()], id: [Nt, [], (u) => u.id()], zoom: [_t, [], (u) => u.globals.zoom], "heatmap-density": [_t, [], (u) => u.globals.heatmapDensity || 0], "line-progress": [_t, [], (u) => u.globals.lineProgress || 0], accumulated: [Nt, [], (u) => u.globals.accumulated === void 0 ? null : u.globals.accumulated], "+": [_t, io(_t), (u, o) => {
        let d = 0;
        for (const g of o)
          d += g.evaluate(u);
        return d;
      }], "*": [_t, io(_t), (u, o) => {
        let d = 1;
        for (const g of o)
          d *= g.evaluate(u);
        return d;
      }], "-": { type: _t, overloads: [[[_t, _t], (u, o) => {
        let [d, g] = o;
        return d.evaluate(u) - g.evaluate(u);
      }], [[_t], (u, o) => {
        let [d] = o;
        return -d.evaluate(u);
      }]] }, "/": [_t, [_t, _t], (u, o) => {
        let [d, g] = o;
        return d.evaluate(u) / g.evaluate(u);
      }], "%": [_t, [_t, _t], (u, o) => {
        let [d, g] = o;
        return d.evaluate(u) % g.evaluate(u);
      }], ln2: [_t, [], () => Math.LN2], pi: [_t, [], () => Math.PI], e: [_t, [], () => Math.E], "^": [_t, [_t, _t], (u, o) => {
        let [d, g] = o;
        return Math.pow(d.evaluate(u), g.evaluate(u));
      }], sqrt: [_t, [_t], (u, o) => {
        let [d] = o;
        return Math.sqrt(d.evaluate(u));
      }], log10: [_t, [_t], (u, o) => {
        let [d] = o;
        return Math.log(d.evaluate(u)) / Math.LN10;
      }], ln: [_t, [_t], (u, o) => {
        let [d] = o;
        return Math.log(d.evaluate(u));
      }], log2: [_t, [_t], (u, o) => {
        let [d] = o;
        return Math.log(d.evaluate(u)) / Math.LN2;
      }], sin: [_t, [_t], (u, o) => {
        let [d] = o;
        return Math.sin(d.evaluate(u));
      }], cos: [_t, [_t], (u, o) => {
        let [d] = o;
        return Math.cos(d.evaluate(u));
      }], tan: [_t, [_t], (u, o) => {
        let [d] = o;
        return Math.tan(d.evaluate(u));
      }], asin: [_t, [_t], (u, o) => {
        let [d] = o;
        return Math.asin(d.evaluate(u));
      }], acos: [_t, [_t], (u, o) => {
        let [d] = o;
        return Math.acos(d.evaluate(u));
      }], atan: [_t, [_t], (u, o) => {
        let [d] = o;
        return Math.atan(d.evaluate(u));
      }], min: [_t, io(_t), (u, o) => Math.min(...o.map((d) => d.evaluate(u)))], max: [_t, io(_t), (u, o) => Math.max(...o.map((d) => d.evaluate(u)))], abs: [_t, [_t], (u, o) => {
        let [d] = o;
        return Math.abs(d.evaluate(u));
      }], round: [_t, [_t], (u, o) => {
        let [d] = o;
        const g = d.evaluate(u);
        return g < 0 ? -Math.round(-g) : Math.round(g);
      }], floor: [_t, [_t], (u, o) => {
        let [d] = o;
        return Math.floor(d.evaluate(u));
      }], ceil: [_t, [_t], (u, o) => {
        let [d] = o;
        return Math.ceil(d.evaluate(u));
      }], "filter-==": [Gt, [bn, Nt], (u, o) => {
        let [d, g] = o;
        return u.properties()[d.value] === g.value;
      }], "filter-id-==": [Gt, [Nt], (u, o) => {
        let [d] = o;
        return u.id() === d.value;
      }], "filter-type-==": [Gt, [bn], (u, o) => {
        let [d] = o;
        return u.geometryType() === d.value;
      }], "filter-<": [Gt, [bn, Nt], (u, o) => {
        let [d, g] = o;
        const v = u.properties()[d.value], w = g.value;
        return typeof v == typeof w && v < w;
      }], "filter-id-<": [Gt, [Nt], (u, o) => {
        let [d] = o;
        const g = u.id(), v = d.value;
        return typeof g == typeof v && g < v;
      }], "filter->": [Gt, [bn, Nt], (u, o) => {
        let [d, g] = o;
        const v = u.properties()[d.value], w = g.value;
        return typeof v == typeof w && v > w;
      }], "filter-id->": [Gt, [Nt], (u, o) => {
        let [d] = o;
        const g = u.id(), v = d.value;
        return typeof g == typeof v && g > v;
      }], "filter-<=": [Gt, [bn, Nt], (u, o) => {
        let [d, g] = o;
        const v = u.properties()[d.value], w = g.value;
        return typeof v == typeof w && v <= w;
      }], "filter-id-<=": [Gt, [Nt], (u, o) => {
        let [d] = o;
        const g = u.id(), v = d.value;
        return typeof g == typeof v && g <= v;
      }], "filter->=": [Gt, [bn, Nt], (u, o) => {
        let [d, g] = o;
        const v = u.properties()[d.value], w = g.value;
        return typeof v == typeof w && v >= w;
      }], "filter-id->=": [Gt, [Nt], (u, o) => {
        let [d] = o;
        const g = u.id(), v = d.value;
        return typeof g == typeof v && g >= v;
      }], "filter-has": [Gt, [Nt], (u, o) => {
        let [d] = o;
        return d.value in u.properties();
      }], "filter-has-id": [Gt, [], (u) => u.id() !== null && u.id() !== void 0], "filter-type-in": [Gt, [X(bn)], (u, o) => {
        let [d] = o;
        return d.value.indexOf(u.geometryType()) >= 0;
      }], "filter-id-in": [Gt, [X(Nt)], (u, o) => {
        let [d] = o;
        return d.value.indexOf(u.id()) >= 0;
      }], "filter-in-small": [Gt, [bn, X(Nt)], (u, o) => {
        let [d, g] = o;
        return g.value.indexOf(u.properties()[d.value]) >= 0;
      }], "filter-in-large": [Gt, [bn, X(Nt)], (u, o) => {
        let [d, g] = o;
        return function(v, w, S, P) {
          for (; S <= P; ) {
            const B = S + P >> 1;
            if (w[B] === v)
              return !0;
            w[B] > v ? P = B - 1 : S = B + 1;
          }
          return !1;
        }(u.properties()[d.value], g.value, 0, g.value.length - 1);
      }], all: { type: Gt, overloads: [[[Gt, Gt], (u, o) => {
        let [d, g] = o;
        return d.evaluate(u) && g.evaluate(u);
      }], [io(Gt), (u, o) => {
        for (const d of o)
          if (!d.evaluate(u))
            return !1;
        return !0;
      }]] }, any: { type: Gt, overloads: [[[Gt, Gt], (u, o) => {
        let [d, g] = o;
        return d.evaluate(u) || g.evaluate(u);
      }], [io(Gt), (u, o) => {
        for (const d of o)
          if (d.evaluate(u))
            return !0;
        return !1;
      }]] }, "!": [Gt, [Gt], (u, o) => {
        let [d] = o;
        return !d.evaluate(u);
      }], "is-supported-script": [Gt, [bn], (u, o) => {
        let [d] = o;
        const g = u.globals && u.globals.isSupportedScript;
        return !g || g(d.evaluate(u));
      }], upcase: [bn, [bn], (u, o) => {
        let [d] = o;
        return d.evaluate(u).toUpperCase();
      }], downcase: [bn, [bn], (u, o) => {
        let [d] = o;
        return d.evaluate(u).toLowerCase();
      }], concat: [bn, io(Nt), (u, o) => o.map((d) => Nn(d.evaluate(u))).join("")], "resolved-locale": [bn, [vr], (u, o) => {
        let [d] = o;
        return d.evaluate(u).resolvedLocale();
      }] });
      class so {
        constructor(o, d) {
          var g;
          this.expression = o, this._warningHistory = {}, this._evaluator = new dr(), this._defaultValue = d ? (g = d).type === "color" && $r(g.default) ? new Xn(0, 0, 0, 0) : g.type === "color" ? Xn.parse(g.default) || null : g.type === "padding" ? Oi.parse(g.default) || null : g.type === "variableAnchorOffsetCollection" ? Ii.parse(g.default) || null : g.default === void 0 ? null : g.default : null, this._enumValues = d && d.type === "enum" ? d.values : null;
        }
        evaluateWithoutErrorHandling(o, d, g, v, w, S) {
          return this._evaluator.globals = o, this._evaluator.feature = d, this._evaluator.featureState = g, this._evaluator.canonical = v, this._evaluator.availableImages = w || null, this._evaluator.formattedSection = S, this.expression.evaluate(this._evaluator);
        }
        evaluate(o, d, g, v, w, S) {
          this._evaluator.globals = o, this._evaluator.feature = d || null, this._evaluator.featureState = g || null, this._evaluator.canonical = v, this._evaluator.availableImages = w || null, this._evaluator.formattedSection = S || null;
          try {
            const P = this.expression.evaluate(this._evaluator);
            if (P == null || typeof P == "number" && P != P)
              return this._defaultValue;
            if (this._enumValues && !(P in this._enumValues))
              throw new _i(`Expected value to be one of ${Object.keys(this._enumValues).map((B) => JSON.stringify(B)).join(", ")}, but found ${JSON.stringify(P)} instead.`);
            return P;
          } catch (P) {
            return this._warningHistory[P.message] || (this._warningHistory[P.message] = !0, typeof console < "u" && console.warn(P.message)), this._defaultValue;
          }
        }
      }
      function Yr(u) {
        return Array.isArray(u) && u.length > 0 && typeof u[0] == "string" && u[0] in Ms;
      }
      function Kr(u, o) {
        const d = new Xr(Ms, Lr, [], o ? function(v) {
          const w = { color: qn, string: bn, number: _t, enum: bn, boolean: Gt, formatted: ii, padding: sr, resolvedImage: or, variableAnchorOffsetCollection: ve };
          return v.type === "array" ? X(w[v.value] || Nt, v.length) : w[v.type];
        }(o) : void 0), g = d.parse(u, void 0, void 0, void 0, o && o.type === "string" ? { typeAnnotation: "coerce" } : void 0);
        return g ? Bs(new so(g, o)) : Eo(d.errors);
      }
      class Yo {
        constructor(o, d) {
          this.kind = o, this._styleExpression = d, this.isStateDependent = o !== "constant" && !Xo(d.expression);
        }
        evaluateWithoutErrorHandling(o, d, g, v, w, S) {
          return this._styleExpression.evaluateWithoutErrorHandling(o, d, g, v, w, S);
        }
        evaluate(o, d, g, v, w, S) {
          return this._styleExpression.evaluate(o, d, g, v, w, S);
        }
      }
      class Ta {
        constructor(o, d, g, v) {
          this.kind = o, this.zoomStops = g, this._styleExpression = d, this.isStateDependent = o !== "camera" && !Xo(d.expression), this.interpolationType = v;
        }
        evaluateWithoutErrorHandling(o, d, g, v, w, S) {
          return this._styleExpression.evaluateWithoutErrorHandling(o, d, g, v, w, S);
        }
        evaluate(o, d, g, v, w, S) {
          return this._styleExpression.evaluate(o, d, g, v, w, S);
        }
        interpolationFactor(o, d, g) {
          return this.interpolationType ? yn.interpolationFactor(this.interpolationType, o, d, g) : 0;
        }
      }
      function Ca(u, o) {
        const d = Kr(u, o);
        if (d.result === "error")
          return d;
        const g = d.value.expression, v = jl(g);
        if (!v && !Jo(o))
          return Eo([new wn("", "data expressions not supported")]);
        const w = ol(g, ["zoom"]);
        if (!w && !Sc(o))
          return Eo([new wn("", "zoom expressions not supported")]);
        const S = Ia(g);
        return S || w ? S instanceof wn ? Eo([S]) : S instanceof yn && !vs(o) ? Eo([new wn("", '"interpolate" expressions cannot be used with this property')]) : Bs(S ? new Ta(v ? "camera" : "composite", d.value, S.labels, S instanceof yn ? S.interpolation : void 0) : new Yo(v ? "constant" : "source", d.value)) : Eo([new wn("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
      }
      class oo {
        constructor(o, d) {
          this._parameters = o, this._specification = d, hn(this, ro(this._parameters, this._specification));
        }
        static deserialize(o) {
          return new oo(o._parameters, o._specification);
        }
        static serialize(o) {
          return { _parameters: o._parameters, _specification: o._specification };
        }
      }
      function Ia(u) {
        let o = null;
        if (u instanceof jn)
          o = Ia(u.result);
        else if (u instanceof Rl) {
          for (const d of u.args)
            if (o = Ia(d), o)
              break;
        } else
          (u instanceof Wt || u instanceof yn) && u.input instanceof Pi && u.input.name === "zoom" && (o = u);
        return o instanceof wn || u.eachChild((d) => {
          const g = Ia(d);
          g instanceof wn ? o = g : !o && g ? o = new wn("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : o && g && o !== g && (o = new wn("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
        }), o;
      }
      function Mr(u) {
        if (u === !0 || u === !1)
          return !0;
        if (!Array.isArray(u) || u.length === 0)
          return !1;
        switch (u[0]) {
          case "has":
            return u.length >= 2 && u[1] !== "$id" && u[1] !== "$type";
          case "in":
            return u.length >= 3 && (typeof u[1] != "string" || Array.isArray(u[2]));
          case "!in":
          case "!has":
          case "none":
            return !1;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return u.length !== 3 || Array.isArray(u[1]) || Array.isArray(u[2]);
          case "any":
          case "all":
            for (const o of u.slice(1))
              if (!Mr(o) && typeof o != "boolean")
                return !1;
            return !0;
          default:
            return !0;
        }
      }
      const Rs = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } };
      function Gn(u) {
        if (u == null)
          return { filter: () => !0, needGeometry: !1 };
        Mr(u) || (u = tr(u));
        const o = Kr(u, Rs);
        if (o.result === "error")
          throw new Error(o.value.map((d) => `${d.key}: ${d.message}`).join(", "));
        return { filter: (d, g, v) => o.value.evaluate(d, g, {}, v), needGeometry: Zi(u) };
      }
      function ci(u, o) {
        return u < o ? -1 : u > o ? 1 : 0;
      }
      function Zi(u) {
        if (!Array.isArray(u))
          return !1;
        if (u[0] === "within" || u[0] === "distance")
          return !0;
        for (let o = 1; o < u.length; o++)
          if (Zi(u[o]))
            return !0;
        return !1;
      }
      function tr(u) {
        if (!u)
          return !0;
        const o = u[0];
        return u.length <= 1 ? o !== "any" : o === "==" ? ao(u[1], u[2], "==") : o === "!=" ? Ko(ao(u[1], u[2], "==")) : o === "<" || o === ">" || o === "<=" || o === ">=" ? ao(u[1], u[2], o) : o === "any" ? (d = u.slice(1), ["any"].concat(d.map(tr))) : o === "all" ? ["all"].concat(u.slice(1).map(tr)) : o === "none" ? ["all"].concat(u.slice(1).map(tr).map(Ko)) : o === "in" ? bs(u[1], u.slice(2)) : o === "!in" ? Ko(bs(u[1], u.slice(2))) : o === "has" ? Pa(u[1]) : o !== "!has" || Ko(Pa(u[1]));
        var d;
      }
      function ao(u, o, d) {
        switch (u) {
          case "$type":
            return [`filter-type-${d}`, o];
          case "$id":
            return [`filter-id-${d}`, o];
          default:
            return [`filter-${d}`, u, o];
        }
      }
      function bs(u, o) {
        if (o.length === 0)
          return !1;
        switch (u) {
          case "$type":
            return ["filter-type-in", ["literal", o]];
          case "$id":
            return ["filter-id-in", ["literal", o]];
          default:
            return o.length > 200 && !o.some((d) => typeof d != typeof o[0]) ? ["filter-in-large", u, ["literal", o.sort(ci)]] : ["filter-in-small", u, ["literal", o]];
        }
      }
      function Pa(u) {
        switch (u) {
          case "$type":
            return !0;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", u];
        }
      }
      function Ko(u) {
        return ["!", u];
      }
      function hu(u) {
        const o = typeof u;
        if (o === "number" || o === "boolean" || o === "string" || u == null)
          return JSON.stringify(u);
        if (Array.isArray(u)) {
          let v = "[";
          for (const w of u)
            v += `${hu(w)},`;
          return `${v}]`;
        }
        const d = Object.keys(u).sort();
        let g = "{";
        for (let v = 0; v < d.length; v++)
          g += `${JSON.stringify(d[v])}:${hu(u[d[v]])},`;
        return `${g}}`;
      }
      function du(u) {
        let o = "";
        for (const d of mn)
          o += `/${hu(u[d])}`;
        return o;
      }
      function eh(u) {
        const o = u.value;
        return o ? [new mt(u.key, o, "constants have been deprecated as of v8")] : [];
      }
      function wi(u) {
        return u instanceof Number || u instanceof String || u instanceof Boolean ? u.valueOf() : u;
      }
      function La(u) {
        if (Array.isArray(u))
          return u.map(La);
        if (u instanceof Object && !(u instanceof Number || u instanceof String || u instanceof Boolean)) {
          const o = {};
          for (const d in u)
            o[d] = La(u[d]);
          return o;
        }
        return wi(u);
      }
      function Qr(u) {
        const o = u.key, d = u.value, g = u.valueSpec || {}, v = u.objectElementValidators || {}, w = u.style, S = u.styleSpec, P = u.validateSpec;
        let B = [];
        const k = Mn(d);
        if (k !== "object")
          return [new mt(o, d, `object expected, ${k} found`)];
        for (const j in d) {
          const q = j.split(".")[0], Z = g[q] || g["*"];
          let ee;
          if (v[q])
            ee = v[q];
          else if (g[q])
            ee = P;
          else if (v["*"])
            ee = v["*"];
          else {
            if (!g["*"]) {
              B.push(new mt(o, d[j], `unknown property "${j}"`));
              continue;
            }
            ee = P;
          }
          B = B.concat(ee({ key: (o && `${o}.`) + j, value: d[j], valueSpec: Z, style: w, styleSpec: S, object: d, objectKey: j, validateSpec: P }, d));
        }
        for (const j in g)
          v[j] || g[j].required && g[j].default === void 0 && d[j] === void 0 && B.push(new mt(o, d, `missing required property "${j}"`));
        return B;
      }
      function Gl(u) {
        const o = u.value, d = u.valueSpec, g = u.style, v = u.styleSpec, w = u.key, S = u.arrayElementValidator || u.validateSpec;
        if (Mn(o) !== "array")
          return [new mt(w, o, `array expected, ${Mn(o)} found`)];
        if (d.length && o.length !== d.length)
          return [new mt(w, o, `array length ${d.length} expected, length ${o.length} found`)];
        if (d["min-length"] && o.length < d["min-length"])
          return [new mt(w, o, `array length at least ${d["min-length"]} expected, length ${o.length} found`)];
        let P = { type: d.value, values: d.values };
        v.$version < 7 && (P.function = d.function), Mn(d.value) === "object" && (P = d.value);
        let B = [];
        for (let k = 0; k < o.length; k++)
          B = B.concat(S({ array: o, arrayIndex: k, value: o[k], valueSpec: P, validateSpec: u.validateSpec, style: g, styleSpec: v, key: `${w}[${k}]` }));
        return B;
      }
      function Ma(u) {
        const o = u.key, d = u.value, g = u.valueSpec;
        let v = Mn(d);
        return v === "number" && d != d && (v = "NaN"), v !== "number" ? [new mt(o, d, `number expected, ${v} found`)] : "minimum" in g && d < g.minimum ? [new mt(o, d, `${d} is less than the minimum value ${g.minimum}`)] : "maximum" in g && d > g.maximum ? [new mt(o, d, `${d} is greater than the maximum value ${g.maximum}`)] : [];
      }
      function es(u) {
        const o = u.valueSpec, d = wi(u.value.type);
        let g, v, w, S = {};
        const P = d !== "categorical" && u.value.property === void 0, B = !P, k = Mn(u.value.stops) === "array" && Mn(u.value.stops[0]) === "array" && Mn(u.value.stops[0][0]) === "object", j = Qr({ key: u.key, value: u.value, valueSpec: u.styleSpec.function, validateSpec: u.validateSpec, style: u.style, styleSpec: u.styleSpec, objectElementValidators: { stops: function(ee) {
          if (d === "identity")
            return [new mt(ee.key, ee.value, 'identity function may not have a "stops" property')];
          let oe = [];
          const pe = ee.value;
          return oe = oe.concat(Gl({ key: ee.key, value: pe, valueSpec: ee.valueSpec, validateSpec: ee.validateSpec, style: ee.style, styleSpec: ee.styleSpec, arrayElementValidator: q })), Mn(pe) === "array" && pe.length === 0 && oe.push(new mt(ee.key, pe, "array must have at least one stop")), oe;
        }, default: function(ee) {
          return ee.validateSpec({ key: ee.key, value: ee.value, valueSpec: o, validateSpec: ee.validateSpec, style: ee.style, styleSpec: ee.styleSpec });
        } } });
        return d === "identity" && P && j.push(new mt(u.key, u.value, 'missing required property "property"')), d === "identity" || u.value.stops || j.push(new mt(u.key, u.value, 'missing required property "stops"')), d === "exponential" && u.valueSpec.expression && !vs(u.valueSpec) && j.push(new mt(u.key, u.value, "exponential functions not supported")), u.styleSpec.$version >= 8 && (B && !Jo(u.valueSpec) ? j.push(new mt(u.key, u.value, "property functions not supported")) : P && !Sc(u.valueSpec) && j.push(new mt(u.key, u.value, "zoom functions not supported"))), d !== "categorical" && !k || u.value.property !== void 0 || j.push(new mt(u.key, u.value, '"property" property is required')), j;
        function q(ee) {
          let oe = [];
          const pe = ee.value, we = ee.key;
          if (Mn(pe) !== "array")
            return [new mt(we, pe, `array expected, ${Mn(pe)} found`)];
          if (pe.length !== 2)
            return [new mt(we, pe, `array length 2 expected, length ${pe.length} found`)];
          if (k) {
            if (Mn(pe[0]) !== "object")
              return [new mt(we, pe, `object expected, ${Mn(pe[0])} found`)];
            if (pe[0].zoom === void 0)
              return [new mt(we, pe, "object stop key must have zoom")];
            if (pe[0].value === void 0)
              return [new mt(we, pe, "object stop key must have value")];
            if (w && w > wi(pe[0].zoom))
              return [new mt(we, pe[0].zoom, "stop zoom values must appear in ascending order")];
            wi(pe[0].zoom) !== w && (w = wi(pe[0].zoom), v = void 0, S = {}), oe = oe.concat(Qr({ key: `${we}[0]`, value: pe[0], valueSpec: { zoom: {} }, validateSpec: ee.validateSpec, style: ee.style, styleSpec: ee.styleSpec, objectElementValidators: { zoom: Ma, value: Z } }));
          } else
            oe = oe.concat(Z({ key: `${we}[0]`, value: pe[0], valueSpec: {}, validateSpec: ee.validateSpec, style: ee.style, styleSpec: ee.styleSpec }, pe));
          return Yr(La(pe[1])) ? oe.concat([new mt(`${we}[1]`, pe[1], "expressions are not allowed in function stops.")]) : oe.concat(ee.validateSpec({ key: `${we}[1]`, value: pe[1], valueSpec: o, validateSpec: ee.validateSpec, style: ee.style, styleSpec: ee.styleSpec }));
        }
        function Z(ee, oe) {
          const pe = Mn(ee.value), we = wi(ee.value), Pe = ee.value !== null ? ee.value : oe;
          if (g) {
            if (pe !== g)
              return [new mt(ee.key, Pe, `${pe} stop domain type must match previous stop domain type ${g}`)];
          } else
            g = pe;
          if (pe !== "number" && pe !== "string" && pe !== "boolean")
            return [new mt(ee.key, Pe, "stop domain value must be a number, string, or boolean")];
          if (pe !== "number" && d !== "categorical") {
            let He = `number expected, ${pe} found`;
            return Jo(o) && d === void 0 && (He += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new mt(ee.key, Pe, He)];
          }
          return d !== "categorical" || pe !== "number" || isFinite(we) && Math.floor(we) === we ? d !== "categorical" && pe === "number" && v !== void 0 && we < v ? [new mt(ee.key, Pe, "stop domain values must appear in ascending order")] : (v = we, d === "categorical" && we in S ? [new mt(ee.key, Pe, "stop domain values must be unique")] : (S[we] = !0, [])) : [new mt(ee.key, Pe, `integer expected, found ${we}`)];
        }
      }
      function wr(u) {
        const o = (u.expressionContext === "property" ? Ca : Kr)(La(u.value), u.valueSpec);
        if (o.result === "error")
          return o.value.map((g) => new mt(`${u.key}${g.key}`, u.value, g.message));
        const d = o.value.expression || o.value._styleExpression.expression;
        if (u.expressionContext === "property" && u.propertyKey === "text-font" && !d.outputDefined())
          return [new mt(u.key, u.value, `Invalid data expression for "${u.propertyKey}". Output values must be contained as literals within the expression.`)];
        if (u.expressionContext === "property" && u.propertyType === "layout" && !Xo(d))
          return [new mt(u.key, u.value, '"feature-state" data expressions are not supported with layout properties.')];
        if (u.expressionContext === "filter" && !Xo(d))
          return [new mt(u.key, u.value, '"feature-state" data expressions are not supported with filters.')];
        if (u.expressionContext && u.expressionContext.indexOf("cluster") === 0) {
          if (!ol(d, ["zoom", "feature-state"]))
            return [new mt(u.key, u.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if (u.expressionContext === "cluster-initial" && !jl(d))
            return [new mt(u.key, u.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function Ba(u) {
        const o = u.key, d = u.value, g = u.valueSpec, v = [];
        return Array.isArray(g.values) ? g.values.indexOf(wi(d)) === -1 && v.push(new mt(o, d, `expected one of [${g.values.join(", ")}], ${JSON.stringify(d)} found`)) : Object.keys(g.values).indexOf(wi(d)) === -1 && v.push(new mt(o, d, `expected one of [${Object.keys(g.values).join(", ")}], ${JSON.stringify(d)} found`)), v;
      }
      function Ra(u) {
        return Mr(La(u.value)) ? wr(hn({}, u, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : Vl(u);
      }
      function Vl(u) {
        const o = u.value, d = u.key;
        if (Mn(o) !== "array")
          return [new mt(d, o, `array expected, ${Mn(o)} found`)];
        const g = u.styleSpec;
        let v, w = [];
        if (o.length < 1)
          return [new mt(d, o, "filter array must have at least 1 element")];
        switch (w = w.concat(Ba({ key: `${d}[0]`, value: o[0], valueSpec: g.filter_operator, style: u.style, styleSpec: u.styleSpec })), wi(o[0])) {
          case "<":
          case "<=":
          case ">":
          case ">=":
            o.length >= 2 && wi(o[1]) === "$type" && w.push(new mt(d, o, `"$type" cannot be use with operator "${o[0]}"`));
          case "==":
          case "!=":
            o.length !== 3 && w.push(new mt(d, o, `filter array for operator "${o[0]}" must have 3 elements`));
          case "in":
          case "!in":
            o.length >= 2 && (v = Mn(o[1]), v !== "string" && w.push(new mt(`${d}[1]`, o[1], `string expected, ${v} found`)));
            for (let S = 2; S < o.length; S++)
              v = Mn(o[S]), wi(o[1]) === "$type" ? w = w.concat(Ba({ key: `${d}[${S}]`, value: o[S], valueSpec: g.geometry_type, style: u.style, styleSpec: u.styleSpec })) : v !== "string" && v !== "number" && v !== "boolean" && w.push(new mt(`${d}[${S}]`, o[S], `string, number, or boolean expected, ${v} found`));
            break;
          case "any":
          case "all":
          case "none":
            for (let S = 1; S < o.length; S++)
              w = w.concat(Vl({ key: `${d}[${S}]`, value: o[S], style: u.style, styleSpec: u.styleSpec }));
            break;
          case "has":
          case "!has":
            v = Mn(o[1]), o.length !== 2 ? w.push(new mt(d, o, `filter array for "${o[0]}" operator must have 2 elements`)) : v !== "string" && w.push(new mt(`${d}[1]`, o[1], `string expected, ${v} found`));
        }
        return w;
      }
      function ql(u, o) {
        const d = u.key, g = u.validateSpec, v = u.style, w = u.styleSpec, S = u.value, P = u.objectKey, B = w[`${o}_${u.layerType}`];
        if (!B)
          return [];
        const k = P.match(/^(.*)-transition$/);
        if (o === "paint" && k && B[k[1]] && B[k[1]].transition)
          return g({ key: d, value: S, valueSpec: w.transition, style: v, styleSpec: w });
        const j = u.valueSpec || B[P];
        if (!j)
          return [new mt(d, S, `unknown property "${P}"`)];
        let q;
        if (Mn(S) === "string" && Jo(j) && !j.tokens && (q = /^{([^}]+)}$/.exec(S)))
          return [new mt(d, S, `"${P}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(q[1])} }\`.`)];
        const Z = [];
        return u.layerType === "symbol" && (P === "text-field" && v && !v.glyphs && Z.push(new mt(d, S, 'use of "text-field" requires a style "glyphs" property')), P === "text-font" && $r(La(S)) && wi(S.type) === "identity" && Z.push(new mt(d, S, '"text-font" does not support identity functions'))), Z.concat(g({ key: u.key, value: S, valueSpec: j, style: v, styleSpec: w, expressionContext: "property", propertyType: o, propertyKey: P }));
      }
      function Hl(u) {
        return ql(u, "paint");
      }
      function Tc(u) {
        return ql(u, "layout");
      }
      function fu(u) {
        let o = [];
        const d = u.value, g = u.key, v = u.style, w = u.styleSpec;
        d.type || d.ref || o.push(new mt(g, d, 'either "type" or "ref" is required'));
        let S = wi(d.type);
        const P = wi(d.ref);
        if (d.id) {
          const B = wi(d.id);
          for (let k = 0; k < u.arrayIndex; k++) {
            const j = v.layers[k];
            wi(j.id) === B && o.push(new mt(g, d.id, `duplicate layer id "${d.id}", previously used at line ${j.id.__line__}`));
          }
        }
        if ("ref" in d) {
          let B;
          ["type", "source", "source-layer", "filter", "layout"].forEach((k) => {
            k in d && o.push(new mt(g, d[k], `"${k}" is prohibited for ref layers`));
          }), v.layers.forEach((k) => {
            wi(k.id) === P && (B = k);
          }), B ? B.ref ? o.push(new mt(g, d.ref, "ref cannot reference another ref layer")) : S = wi(B.type) : o.push(new mt(g, d.ref, `ref layer "${P}" not found`));
        } else if (S !== "background")
          if (d.source) {
            const B = v.sources && v.sources[d.source], k = B && wi(B.type);
            B ? k === "vector" && S === "raster" ? o.push(new mt(g, d.source, `layer "${d.id}" requires a raster source`)) : k !== "raster-dem" && S === "hillshade" ? o.push(new mt(g, d.source, `layer "${d.id}" requires a raster-dem source`)) : k === "raster" && S !== "raster" ? o.push(new mt(g, d.source, `layer "${d.id}" requires a vector source`)) : k !== "vector" || d["source-layer"] ? k === "raster-dem" && S !== "hillshade" ? o.push(new mt(g, d.source, "raster-dem source can only be used with layer type 'hillshade'.")) : S !== "line" || !d.paint || !d.paint["line-gradient"] || k === "geojson" && B.lineMetrics || o.push(new mt(g, d, `layer "${d.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : o.push(new mt(g, d, `layer "${d.id}" must specify a "source-layer"`)) : o.push(new mt(g, d.source, `source "${d.source}" not found`));
          } else
            o.push(new mt(g, d, 'missing required property "source"'));
        return o = o.concat(Qr({ key: g, value: d, valueSpec: w.layer, style: u.style, styleSpec: u.styleSpec, validateSpec: u.validateSpec, objectElementValidators: { "*": () => [], type: () => u.validateSpec({ key: `${g}.type`, value: d.type, valueSpec: w.layer.type, style: u.style, styleSpec: u.styleSpec, validateSpec: u.validateSpec, object: d, objectKey: "type" }), filter: Ra, layout: (B) => Qr({ layer: d, key: B.key, value: B.value, style: B.style, styleSpec: B.styleSpec, validateSpec: B.validateSpec, objectElementValidators: { "*": (k) => Tc(hn({ layerType: S }, k)) } }), paint: (B) => Qr({ layer: d, key: B.key, value: B.value, style: B.style, styleSpec: B.styleSpec, validateSpec: B.validateSpec, objectElementValidators: { "*": (k) => Hl(hn({ layerType: S }, k)) } }) } })), o;
      }
      function lo(u) {
        const o = u.value, d = u.key, g = Mn(o);
        return g !== "string" ? [new mt(d, o, `string expected, ${g} found`)] : [];
      }
      const Cc = { promoteId: function(u) {
        let { key: o, value: d } = u;
        if (Mn(d) === "string")
          return lo({ key: o, value: d });
        {
          const g = [];
          for (const v in d)
            g.push(...lo({ key: `${o}.${v}`, value: d[v] }));
          return g;
        }
      } };
      function Ic(u) {
        const o = u.value, d = u.key, g = u.styleSpec, v = u.style, w = u.validateSpec;
        if (!o.type)
          return [new mt(d, o, '"type" is required')];
        const S = wi(o.type);
        let P;
        switch (S) {
          case "vector":
          case "raster":
            return P = Qr({ key: d, value: o, valueSpec: g[`source_${S.replace("-", "_")}`], style: u.style, styleSpec: g, objectElementValidators: Cc, validateSpec: w }), P;
          case "raster-dem":
            return P = function(B) {
              var k;
              const j = (k = B.sourceName) !== null && k !== void 0 ? k : "", q = B.value, Z = B.styleSpec, ee = Z.source_raster_dem, oe = B.style;
              let pe = [];
              const we = Mn(q);
              if (q === void 0)
                return pe;
              if (we !== "object")
                return pe.push(new mt("source_raster_dem", q, `object expected, ${we} found`)), pe;
              const Pe = wi(q.encoding) === "custom", He = ["redFactor", "greenFactor", "blueFactor", "baseShift"], ke = B.value.encoding ? `"${B.value.encoding}"` : "Default";
              for (const Ge in q)
                !Pe && He.includes(Ge) ? pe.push(new mt(Ge, q[Ge], `In "${j}": "${Ge}" is only valid when "encoding" is set to "custom". ${ke} encoding found`)) : ee[Ge] ? pe = pe.concat(B.validateSpec({ key: Ge, value: q[Ge], valueSpec: ee[Ge], validateSpec: B.validateSpec, style: oe, styleSpec: Z })) : pe.push(new mt(Ge, q[Ge], `unknown property "${Ge}"`));
              return pe;
            }({ sourceName: d, value: o, style: u.style, styleSpec: g, validateSpec: w }), P;
          case "geojson":
            if (P = Qr({ key: d, value: o, valueSpec: g.source_geojson, style: v, styleSpec: g, validateSpec: w, objectElementValidators: Cc }), o.cluster)
              for (const B in o.clusterProperties) {
                const [k, j] = o.clusterProperties[B], q = typeof k == "string" ? [k, ["accumulated"], ["get", B]] : k;
                P.push(...wr({ key: `${d}.${B}.map`, value: j, validateSpec: w, expressionContext: "cluster-map" })), P.push(...wr({ key: `${d}.${B}.reduce`, value: q, validateSpec: w, expressionContext: "cluster-reduce" }));
              }
            return P;
          case "video":
            return Qr({ key: d, value: o, valueSpec: g.source_video, style: v, validateSpec: w, styleSpec: g });
          case "image":
            return Qr({ key: d, value: o, valueSpec: g.source_image, style: v, validateSpec: w, styleSpec: g });
          case "canvas":
            return [new mt(d, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return Ba({ key: `${d}.type`, value: o.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: v, validateSpec: w, styleSpec: g });
        }
      }
      function Pc(u) {
        const o = u.value, d = u.styleSpec, g = d.light, v = u.style;
        let w = [];
        const S = Mn(o);
        if (o === void 0)
          return w;
        if (S !== "object")
          return w = w.concat([new mt("light", o, `object expected, ${S} found`)]), w;
        for (const P in o) {
          const B = P.match(/^(.*)-transition$/);
          w = w.concat(B && g[B[1]] && g[B[1]].transition ? u.validateSpec({ key: P, value: o[P], valueSpec: d.transition, validateSpec: u.validateSpec, style: v, styleSpec: d }) : g[P] ? u.validateSpec({ key: P, value: o[P], valueSpec: g[P], validateSpec: u.validateSpec, style: v, styleSpec: d }) : [new mt(P, o[P], `unknown property "${P}"`)]);
        }
        return w;
      }
      function Wh(u) {
        const o = u.value, d = u.styleSpec, g = d.sky, v = u.style, w = Mn(o);
        if (o === void 0)
          return [];
        if (w !== "object")
          return [new mt("sky", o, `object expected, ${w} found`)];
        let S = [];
        for (const P in o)
          S = S.concat(g[P] ? u.validateSpec({ key: P, value: o[P], valueSpec: g[P], style: v, styleSpec: d }) : [new mt(P, o[P], `unknown property "${P}"`)]);
        return S;
      }
      function th(u) {
        const o = u.value, d = u.styleSpec, g = d.terrain, v = u.style;
        let w = [];
        const S = Mn(o);
        if (o === void 0)
          return w;
        if (S !== "object")
          return w = w.concat([new mt("terrain", o, `object expected, ${S} found`)]), w;
        for (const P in o)
          w = w.concat(g[P] ? u.validateSpec({ key: P, value: o[P], valueSpec: g[P], validateSpec: u.validateSpec, style: v, styleSpec: d }) : [new mt(P, o[P], `unknown property "${P}"`)]);
        return w;
      }
      function pu(u) {
        let o = [];
        const d = u.value, g = u.key;
        if (Array.isArray(d)) {
          const v = [], w = [];
          for (const S in d)
            d[S].id && v.includes(d[S].id) && o.push(new mt(g, d, `all the sprites' ids must be unique, but ${d[S].id} is duplicated`)), v.push(d[S].id), d[S].url && w.includes(d[S].url) && o.push(new mt(g, d, `all the sprites' URLs must be unique, but ${d[S].url} is duplicated`)), w.push(d[S].url), o = o.concat(Qr({ key: `${g}[${S}]`, value: d[S], valueSpec: { id: { type: "string", required: !0 }, url: { type: "string", required: !0 } }, validateSpec: u.validateSpec }));
          return o;
        }
        return lo({ key: g, value: d });
      }
      const nh = { "*": () => [], array: Gl, boolean: function(u) {
        const o = u.value, d = u.key, g = Mn(o);
        return g !== "boolean" ? [new mt(d, o, `boolean expected, ${g} found`)] : [];
      }, number: Ma, color: function(u) {
        const o = u.key, d = u.value, g = Mn(d);
        return g !== "string" ? [new mt(o, d, `color expected, ${g} found`)] : Xn.parse(String(d)) ? [] : [new mt(o, d, `color expected, "${d}" found`)];
      }, constants: eh, enum: Ba, filter: Ra, function: es, layer: fu, object: Qr, source: Ic, light: Pc, sky: Wh, terrain: th, projection: function(u) {
        const o = u.value, d = u.styleSpec, g = d.projection, v = u.style, w = Mn(o);
        if (o === void 0)
          return [];
        if (w !== "object")
          return [new mt("projection", o, `object expected, ${w} found`)];
        let S = [];
        for (const P in o)
          S = S.concat(g[P] ? u.validateSpec({ key: P, value: o[P], valueSpec: g[P], style: v, styleSpec: d }) : [new mt(P, o[P], `unknown property "${P}"`)]);
        return S;
      }, string: lo, formatted: function(u) {
        return lo(u).length === 0 ? [] : wr(u);
      }, resolvedImage: function(u) {
        return lo(u).length === 0 ? [] : wr(u);
      }, padding: function(u) {
        const o = u.key, d = u.value;
        if (Mn(d) === "array") {
          if (d.length < 1 || d.length > 4)
            return [new mt(o, d, `padding requires 1 to 4 values; ${d.length} values found`)];
          const g = { type: "number" };
          let v = [];
          for (let w = 0; w < d.length; w++)
            v = v.concat(u.validateSpec({ key: `${o}[${w}]`, value: d[w], validateSpec: u.validateSpec, valueSpec: g }));
          return v;
        }
        return Ma({ key: o, value: d, valueSpec: {} });
      }, variableAnchorOffsetCollection: function(u) {
        const o = u.key, d = u.value, g = Mn(d), v = u.styleSpec;
        if (g !== "array" || d.length < 1 || d.length % 2 != 0)
          return [new mt(o, d, "variableAnchorOffsetCollection requires a non-empty array of even length")];
        let w = [];
        for (let S = 0; S < d.length; S += 2)
          w = w.concat(Ba({ key: `${o}[${S}]`, value: d[S], valueSpec: v.layout_symbol["text-anchor"] })), w = w.concat(Gl({ key: `${o}[${S + 1}]`, value: d[S + 1], valueSpec: { length: 2, value: "number" }, validateSpec: u.validateSpec, style: u.style, styleSpec: v }));
        return w;
      }, sprite: pu };
      function Lc(u) {
        const o = u.value, d = u.valueSpec, g = u.styleSpec;
        return u.validateSpec = Lc, d.expression && $r(wi(o)) ? es(u) : d.expression && Yr(La(o)) ? wr(u) : d.type && nh[d.type] ? nh[d.type](u) : Qr(hn({}, u, { valueSpec: d.type ? g[d.type] : d }));
      }
      function Xh(u) {
        const o = u.value, d = u.key, g = lo(u);
        return g.length || (o.indexOf("{fontstack}") === -1 && g.push(new mt(d, o, '"glyphs" url must include a "{fontstack}" token')), o.indexOf("{range}") === -1 && g.push(new mt(d, o, '"glyphs" url must include a "{range}" token'))), g;
      }
      function Os(u) {
        let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : re, d = [];
        return d = d.concat(Lc({ key: "", value: u, valueSpec: o.$root, styleSpec: o, style: u, validateSpec: Lc, objectElementValidators: { glyphs: Xh, "*": () => [] } })), u.constants && (d = d.concat(eh({ key: "constants", value: u.constants, style: u, styleSpec: o, validateSpec: Lc }))), Mc(d);
      }
      function co(u) {
        return function(o) {
          return u({ ...o, validateSpec: Lc });
        };
      }
      function Mc(u) {
        return [].concat(u).sort((o, d) => o.line - d.line);
      }
      function xs(u) {
        return function() {
          for (var o = arguments.length, d = new Array(o), g = 0; g < o; g++)
            d[g] = arguments[g];
          return Mc(u.apply(this, d));
        };
      }
      Os.source = xs(co(Ic)), Os.sprite = xs(co(pu)), Os.glyphs = xs(co(Xh)), Os.light = xs(co(Pc)), Os.sky = xs(co(Wh)), Os.terrain = xs(co(th)), Os.layer = xs(co(fu)), Os.filter = xs(co(Ra)), Os.paintProperty = xs(co(Hl)), Os.layoutProperty = xs(co(Tc));
      const ws = Os, sf = ws.light, ih = ws.sky, Jh = ws.paintProperty, of = ws.layoutProperty;
      function rh(u, o) {
        let d = !1;
        if (o && o.length)
          for (const g of o)
            u.fire(new on(new Error(g.message))), d = !0;
        return d;
      }
      class Wl {
        constructor(o, d, g) {
          const v = this.cells = [];
          if (o instanceof ArrayBuffer) {
            this.arrayBuffer = o;
            const S = new Int32Array(this.arrayBuffer);
            o = S[0], this.d = (d = S[1]) + 2 * (g = S[2]);
            for (let B = 0; B < this.d * this.d; B++) {
              const k = S[3 + B], j = S[3 + B + 1];
              v.push(k === j ? null : S.subarray(k, j));
            }
            const P = S[3 + v.length + 1];
            this.keys = S.subarray(S[3 + v.length], P), this.bboxes = S.subarray(P), this.insert = this._insertReadonly;
          } else {
            this.d = d + 2 * g;
            for (let S = 0; S < this.d * this.d; S++)
              v.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = d, this.extent = o, this.padding = g, this.scale = d / o, this.uid = 0;
          const w = g / d * o;
          this.min = -w, this.max = o + w;
        }
        insert(o, d, g, v, w) {
          this._forEachCell(d, g, v, w, this._insertCell, this.uid++, void 0, void 0), this.keys.push(o), this.bboxes.push(d), this.bboxes.push(g), this.bboxes.push(v), this.bboxes.push(w);
        }
        _insertReadonly() {
          throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
        }
        _insertCell(o, d, g, v, w, S) {
          this.cells[w].push(S);
        }
        query(o, d, g, v, w) {
          const S = this.min, P = this.max;
          if (o <= S && d <= S && P <= g && P <= v && !w)
            return Array.prototype.slice.call(this.keys);
          {
            const B = [];
            return this._forEachCell(o, d, g, v, this._queryCell, B, {}, w), B;
          }
        }
        _queryCell(o, d, g, v, w, S, P, B) {
          const k = this.cells[w];
          if (k !== null) {
            const j = this.keys, q = this.bboxes;
            for (let Z = 0; Z < k.length; Z++) {
              const ee = k[Z];
              if (P[ee] === void 0) {
                const oe = 4 * ee;
                (B ? B(q[oe + 0], q[oe + 1], q[oe + 2], q[oe + 3]) : o <= q[oe + 2] && d <= q[oe + 3] && g >= q[oe + 0] && v >= q[oe + 1]) ? (P[ee] = !0, S.push(j[ee])) : P[ee] = !1;
              }
            }
          }
        }
        _forEachCell(o, d, g, v, w, S, P, B) {
          const k = this._convertToCellCoord(o), j = this._convertToCellCoord(d), q = this._convertToCellCoord(g), Z = this._convertToCellCoord(v);
          for (let ee = k; ee <= q; ee++)
            for (let oe = j; oe <= Z; oe++) {
              const pe = this.d * oe + ee;
              if ((!B || B(this._convertFromCellCoord(ee), this._convertFromCellCoord(oe), this._convertFromCellCoord(ee + 1), this._convertFromCellCoord(oe + 1))) && w.call(this, o, d, g, v, pe, S, P, B))
                return;
            }
        }
        _convertFromCellCoord(o) {
          return (o - this.padding) / this.scale;
        }
        _convertToCellCoord(o) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(o * this.scale) + this.padding));
        }
        toArrayBuffer() {
          if (this.arrayBuffer)
            return this.arrayBuffer;
          const o = this.cells, d = 3 + this.cells.length + 1 + 1;
          let g = 0;
          for (let S = 0; S < this.cells.length; S++)
            g += this.cells[S].length;
          const v = new Int32Array(d + g + this.keys.length + this.bboxes.length);
          v[0] = this.extent, v[1] = this.n, v[2] = this.padding;
          let w = d;
          for (let S = 0; S < o.length; S++) {
            const P = o[S];
            v[3 + S] = w, v.set(P, w), w += P.length;
          }
          return v[3 + o.length] = w, v.set(this.keys, w), w += this.keys.length, v[3 + o.length + 1] = w, v.set(this.bboxes, w), w += this.bboxes.length, v.buffer;
        }
        static serialize(o, d) {
          const g = o.toArrayBuffer();
          return d && d.push(g), { buffer: g };
        }
        static deserialize(o) {
          return new Wl(o.buffer);
        }
      }
      const So = {};
      function zt(u, o) {
        let d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (So[u])
          throw new Error(`${u} is already registered.`);
        Object.defineProperty(o, "_classRegistryKey", { value: u, writeable: !1 }), So[u] = { klass: o, omit: d.omit || [], shallow: d.shallow || [] };
      }
      zt("Object", Object), zt("TransferableGridIndex", Wl), zt("Color", Xn), zt("Error", Error), zt("AJAXError", We), zt("ResolvedImage", fi), zt("StylePropertyFunction", oo), zt("StyleExpression", so, { omit: ["_evaluator"] }), zt("ZoomDependentExpression", Ta), zt("ZoomConstantExpression", Yo), zt("CompoundExpression", Pi, { omit: ["_evaluate"] });
      for (const u in Ms)
        Ms[u]._classRegistryKey || zt(`Expression_${u}`, Ms[u]);
      function Fs(u) {
        return u && typeof ArrayBuffer < "u" && (u instanceof ArrayBuffer || u.constructor && u.constructor.name === "ArrayBuffer");
      }
      function uo(u) {
        return u.$name || u.constructor._classRegistryKey;
      }
      function $h(u) {
        return !function(o) {
          if (o === null || typeof o != "object")
            return !1;
          const d = uo(o);
          return !(!d || d === "Object");
        }(u) && (u == null || typeof u == "boolean" || typeof u == "number" || typeof u == "string" || u instanceof Boolean || u instanceof Number || u instanceof String || u instanceof Date || u instanceof RegExp || u instanceof Blob || u instanceof Error || Fs(u) || lt(u) || ArrayBuffer.isView(u) || u instanceof ImageData);
      }
      function Xl(u, o) {
        if ($h(u))
          return (Fs(u) || lt(u)) && o && o.push(u), ArrayBuffer.isView(u) && o && o.push(u.buffer), u instanceof ImageData && o && o.push(u.data.buffer), u;
        if (Array.isArray(u)) {
          const w = [];
          for (const S of u)
            w.push(Xl(S, o));
          return w;
        }
        if (typeof u != "object")
          throw new Error("can't serialize object of type " + typeof u);
        const d = uo(u);
        if (!d)
          throw new Error(`can't serialize object of unregistered class ${u.constructor.name}`);
        if (!So[d])
          throw new Error(`${d} is not registered.`);
        const { klass: g } = So[d], v = g.serialize ? g.serialize(u, o) : {};
        if (g.serialize) {
          if (o && v === o[o.length - 1])
            throw new Error("statically serialized object won't survive transfer of $name property");
        } else {
          for (const w in u) {
            if (!u.hasOwnProperty(w) || So[d].omit.indexOf(w) >= 0)
              continue;
            const S = u[w];
            v[w] = So[d].shallow.indexOf(w) >= 0 ? S : Xl(S, o);
          }
          u instanceof Error && (v.message = u.message);
        }
        if (v.$name)
          throw new Error("$name property is reserved for worker serialization logic.");
        return d !== "Object" && (v.$name = d), v;
      }
      function Br(u) {
        if ($h(u))
          return u;
        if (Array.isArray(u))
          return u.map(Br);
        if (typeof u != "object")
          throw new Error("can't deserialize object of type " + typeof u);
        const o = uo(u) || "Object";
        if (!So[o])
          throw new Error(`can't deserialize unregistered class ${o}`);
        const { klass: d } = So[o];
        if (!d)
          throw new Error(`can't deserialize unregistered class ${o}`);
        if (d.deserialize)
          return d.deserialize(u);
        const g = Object.create(d.prototype);
        for (const v of Object.keys(u)) {
          if (v === "$name")
            continue;
          const w = u[v];
          g[v] = So[o].shallow.indexOf(v) >= 0 ? w : Br(w);
        }
        return g;
      }
      class As {
        constructor() {
          this.first = !0;
        }
        update(o, d) {
          const g = Math.floor(o);
          return this.first ? (this.first = !1, this.lastIntegerZoom = g, this.lastIntegerZoomTime = 0, this.lastZoom = o, this.lastFloorZoom = g, !0) : (this.lastFloorZoom > g ? (this.lastIntegerZoom = g + 1, this.lastIntegerZoomTime = d) : this.lastFloorZoom < g && (this.lastIntegerZoom = g, this.lastIntegerZoomTime = d), o !== this.lastZoom && (this.lastZoom = o, this.lastFloorZoom = g, !0));
        }
      }
      const Vt = { "Latin-1 Supplement": (u) => u >= 128 && u <= 255, Arabic: (u) => u >= 1536 && u <= 1791, "Arabic Supplement": (u) => u >= 1872 && u <= 1919, "Arabic Extended-A": (u) => u >= 2208 && u <= 2303, "Hangul Jamo": (u) => u >= 4352 && u <= 4607, "Unified Canadian Aboriginal Syllabics": (u) => u >= 5120 && u <= 5759, Khmer: (u) => u >= 6016 && u <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (u) => u >= 6320 && u <= 6399, "General Punctuation": (u) => u >= 8192 && u <= 8303, "Letterlike Symbols": (u) => u >= 8448 && u <= 8527, "Number Forms": (u) => u >= 8528 && u <= 8591, "Miscellaneous Technical": (u) => u >= 8960 && u <= 9215, "Control Pictures": (u) => u >= 9216 && u <= 9279, "Optical Character Recognition": (u) => u >= 9280 && u <= 9311, "Enclosed Alphanumerics": (u) => u >= 9312 && u <= 9471, "Geometric Shapes": (u) => u >= 9632 && u <= 9727, "Miscellaneous Symbols": (u) => u >= 9728 && u <= 9983, "Miscellaneous Symbols and Arrows": (u) => u >= 11008 && u <= 11263, "CJK Radicals Supplement": (u) => u >= 11904 && u <= 12031, "Kangxi Radicals": (u) => u >= 12032 && u <= 12255, "Ideographic Description Characters": (u) => u >= 12272 && u <= 12287, "CJK Symbols and Punctuation": (u) => u >= 12288 && u <= 12351, Hiragana: (u) => u >= 12352 && u <= 12447, Katakana: (u) => u >= 12448 && u <= 12543, Bopomofo: (u) => u >= 12544 && u <= 12591, "Hangul Compatibility Jamo": (u) => u >= 12592 && u <= 12687, Kanbun: (u) => u >= 12688 && u <= 12703, "Bopomofo Extended": (u) => u >= 12704 && u <= 12735, "CJK Strokes": (u) => u >= 12736 && u <= 12783, "Katakana Phonetic Extensions": (u) => u >= 12784 && u <= 12799, "Enclosed CJK Letters and Months": (u) => u >= 12800 && u <= 13055, "CJK Compatibility": (u) => u >= 13056 && u <= 13311, "CJK Unified Ideographs Extension A": (u) => u >= 13312 && u <= 19903, "Yijing Hexagram Symbols": (u) => u >= 19904 && u <= 19967, "CJK Unified Ideographs": (u) => u >= 19968 && u <= 40959, "Yi Syllables": (u) => u >= 40960 && u <= 42127, "Yi Radicals": (u) => u >= 42128 && u <= 42191, "Hangul Jamo Extended-A": (u) => u >= 43360 && u <= 43391, "Hangul Syllables": (u) => u >= 44032 && u <= 55215, "Hangul Jamo Extended-B": (u) => u >= 55216 && u <= 55295, "Private Use Area": (u) => u >= 57344 && u <= 63743, "CJK Compatibility Ideographs": (u) => u >= 63744 && u <= 64255, "Arabic Presentation Forms-A": (u) => u >= 64336 && u <= 65023, "Vertical Forms": (u) => u >= 65040 && u <= 65055, "CJK Compatibility Forms": (u) => u >= 65072 && u <= 65103, "Small Form Variants": (u) => u >= 65104 && u <= 65135, "Arabic Presentation Forms-B": (u) => u >= 65136 && u <= 65279, "Halfwidth and Fullwidth Forms": (u) => u >= 65280 && u <= 65519 };
      function sh(u) {
        for (const o of u)
          if (gu(o.charCodeAt(0)))
            return !0;
        return !1;
      }
      function Zh(u) {
        for (const o of u)
          if (!oh(o.charCodeAt(0)))
            return !1;
        return !0;
      }
      function oh(u) {
        return !(Vt.Arabic(u) || Vt["Arabic Supplement"](u) || Vt["Arabic Extended-A"](u) || Vt["Arabic Presentation Forms-A"](u) || Vt["Arabic Presentation Forms-B"](u));
      }
      function gu(u) {
        return !(u !== 746 && u !== 747 && (u < 4352 || !(Vt["Bopomofo Extended"](u) || Vt.Bopomofo(u) || Vt["CJK Compatibility Forms"](u) && !(u >= 65097 && u <= 65103) || Vt["CJK Compatibility Ideographs"](u) || Vt["CJK Compatibility"](u) || Vt["CJK Radicals Supplement"](u) || Vt["CJK Strokes"](u) || !(!Vt["CJK Symbols and Punctuation"](u) || u >= 12296 && u <= 12305 || u >= 12308 && u <= 12319 || u === 12336) || Vt["CJK Unified Ideographs Extension A"](u) || Vt["CJK Unified Ideographs"](u) || Vt["Enclosed CJK Letters and Months"](u) || Vt["Hangul Compatibility Jamo"](u) || Vt["Hangul Jamo Extended-A"](u) || Vt["Hangul Jamo Extended-B"](u) || Vt["Hangul Jamo"](u) || Vt["Hangul Syllables"](u) || Vt.Hiragana(u) || Vt["Ideographic Description Characters"](u) || Vt.Kanbun(u) || Vt["Kangxi Radicals"](u) || Vt["Katakana Phonetic Extensions"](u) || Vt.Katakana(u) && u !== 12540 || !(!Vt["Halfwidth and Fullwidth Forms"](u) || u === 65288 || u === 65289 || u === 65293 || u >= 65306 && u <= 65310 || u === 65339 || u === 65341 || u === 65343 || u >= 65371 && u <= 65503 || u === 65507 || u >= 65512 && u <= 65519) || !(!Vt["Small Form Variants"](u) || u >= 65112 && u <= 65118 || u >= 65123 && u <= 65126) || Vt["Unified Canadian Aboriginal Syllabics"](u) || Vt["Unified Canadian Aboriginal Syllabics Extended"](u) || Vt["Vertical Forms"](u) || Vt["Yijing Hexagram Symbols"](u) || Vt["Yi Syllables"](u) || Vt["Yi Radicals"](u))));
      }
      function ah(u) {
        return !(gu(u) || function(o) {
          return !!(Vt["Latin-1 Supplement"](o) && (o === 167 || o === 169 || o === 174 || o === 177 || o === 188 || o === 189 || o === 190 || o === 215 || o === 247) || Vt["General Punctuation"](o) && (o === 8214 || o === 8224 || o === 8225 || o === 8240 || o === 8241 || o === 8251 || o === 8252 || o === 8258 || o === 8263 || o === 8264 || o === 8265 || o === 8273) || Vt["Letterlike Symbols"](o) || Vt["Number Forms"](o) || Vt["Miscellaneous Technical"](o) && (o >= 8960 && o <= 8967 || o >= 8972 && o <= 8991 || o >= 8996 && o <= 9e3 || o === 9003 || o >= 9085 && o <= 9114 || o >= 9150 && o <= 9165 || o === 9167 || o >= 9169 && o <= 9179 || o >= 9186 && o <= 9215) || Vt["Control Pictures"](o) && o !== 9251 || Vt["Optical Character Recognition"](o) || Vt["Enclosed Alphanumerics"](o) || Vt["Geometric Shapes"](o) || Vt["Miscellaneous Symbols"](o) && !(o >= 9754 && o <= 9759) || Vt["Miscellaneous Symbols and Arrows"](o) && (o >= 11026 && o <= 11055 || o >= 11088 && o <= 11097 || o >= 11192 && o <= 11243) || Vt["CJK Symbols and Punctuation"](o) || Vt.Katakana(o) || Vt["Private Use Area"](o) || Vt["CJK Compatibility Forms"](o) || Vt["Small Form Variants"](o) || Vt["Halfwidth and Fullwidth Forms"](o) || o === 8734 || o === 8756 || o === 8757 || o >= 9984 && o <= 10087 || o >= 10102 && o <= 10131 || o === 65532 || o === 65533);
        }(u));
      }
      function Oa(u) {
        return u >= 1424 && u <= 2303 || Vt["Arabic Presentation Forms-A"](u) || Vt["Arabic Presentation Forms-B"](u);
      }
      function Bc(u, o) {
        return !(!o && Oa(u) || u >= 2304 && u <= 3583 || u >= 3840 && u <= 4255 || Vt.Khmer(u));
      }
      function Jl(u) {
        for (const o of u)
          if (Oa(o.charCodeAt(0)))
            return !0;
        return !1;
      }
      const Ds = new class {
        constructor() {
          this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null;
        }
        setState(u) {
          this.pluginStatus = u.pluginStatus, this.pluginURL = u.pluginURL;
        }
        getState() {
          return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
        }
        setMethods(u) {
          this.applyArabicShaping = u.applyArabicShaping, this.processBidirectionalText = u.processBidirectionalText, this.processStyledBidirectionalText = u.processStyledBidirectionalText;
        }
        isParsed() {
          return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
        }
        getPluginURL() {
          return this.pluginURL;
        }
        getRTLTextPluginStatus() {
          return this.pluginStatus;
        }
      }();
      class pi {
        constructor(o, d) {
          this.zoom = o, d ? (this.now = d.now, this.fadeDuration = d.fadeDuration, this.zoomHistory = d.zoomHistory, this.transition = d.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new As(), this.transition = {});
        }
        isSupportedScript(o) {
          return function(d, g) {
            for (const v of d)
              if (!Bc(v.charCodeAt(0), g))
                return !1;
            return !0;
          }(o, Ds.getRTLTextPluginStatus() === "loaded");
        }
        crossFadingFactor() {
          return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
        }
        getCrossfadeParameters() {
          const o = this.zoom, d = o - Math.floor(o), g = this.crossFadingFactor();
          return o > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: d + (1 - d) * g } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - g) * d };
        }
      }
      class Rc {
        constructor(o, d) {
          this.property = o, this.value = d, this.expression = function(g, v) {
            if ($r(g))
              return new oo(g, v);
            if (Yr(g)) {
              const w = Ca(g, v);
              if (w.result === "error")
                throw new Error(w.value.map((S) => `${S.key}: ${S.message}`).join(", "));
              return w.value;
            }
            {
              let w = g;
              return v.type === "color" && typeof g == "string" ? w = Xn.parse(g) : v.type !== "padding" || typeof g != "number" && !Array.isArray(g) ? v.type === "variableAnchorOffsetCollection" && Array.isArray(g) && (w = Ii.parse(g)) : w = Oi.parse(g), { kind: "constant", evaluate: () => w };
            }
          }(d === void 0 ? o.specification.default : d, o.specification);
        }
        isDataDriven() {
          return this.expression.kind === "source" || this.expression.kind === "composite";
        }
        possiblyEvaluate(o, d, g) {
          return this.property.possiblyEvaluate(this, o, d, g);
        }
      }
      class $l {
        constructor(o) {
          this.property = o, this.value = new Rc(o, void 0);
        }
        transitioned(o, d) {
          return new Yh(this.property, this.value, d, Le({}, o.transition, this.transition), o.now);
        }
        untransitioned() {
          return new Yh(this.property, this.value, null, {}, 0);
        }
      }
      class ll {
        constructor(o) {
          this._properties = o, this._values = Object.create(o.defaultTransitionablePropertyValues);
        }
        getValue(o) {
          return ae(this._values[o].value.value);
        }
        setValue(o, d) {
          Object.prototype.hasOwnProperty.call(this._values, o) || (this._values[o] = new $l(this._values[o].property)), this._values[o].value = new Rc(this._values[o].property, d === null ? void 0 : ae(d));
        }
        getTransition(o) {
          return ae(this._values[o].transition);
        }
        setTransition(o, d) {
          Object.prototype.hasOwnProperty.call(this._values, o) || (this._values[o] = new $l(this._values[o].property)), this._values[o].transition = ae(d) || void 0;
        }
        serialize() {
          const o = {};
          for (const d of Object.keys(this._values)) {
            const g = this.getValue(d);
            g !== void 0 && (o[d] = g);
            const v = this.getTransition(d);
            v !== void 0 && (o[`${d}-transition`] = v);
          }
          return o;
        }
        transitioned(o, d) {
          const g = new lh(this._properties);
          for (const v of Object.keys(this._values))
            g._values[v] = this._values[v].transitioned(o, d._values[v]);
          return g;
        }
        untransitioned() {
          const o = new lh(this._properties);
          for (const d of Object.keys(this._values))
            o._values[d] = this._values[d].untransitioned();
          return o;
        }
      }
      class Yh {
        constructor(o, d, g, v, w) {
          this.property = o, this.value = d, this.begin = w + v.delay || 0, this.end = this.begin + v.duration || 0, o.specification.transition && (v.delay || v.duration) && (this.prior = g);
        }
        possiblyEvaluate(o, d, g) {
          const v = o.now || 0, w = this.value.possiblyEvaluate(o, d, g), S = this.prior;
          if (S) {
            if (v > this.end)
              return this.prior = null, w;
            if (this.value.isDataDriven())
              return this.prior = null, w;
            if (v < this.begin)
              return S.possiblyEvaluate(o, d, g);
            {
              const P = (v - this.begin) / (this.end - this.begin);
              return this.property.interpolate(S.possiblyEvaluate(o, d, g), w, function(B) {
                if (B <= 0)
                  return 0;
                if (B >= 1)
                  return 1;
                const k = B * B, j = k * B;
                return 4 * (B < 0.5 ? j : 3 * (B - k) + j - 0.75);
              }(P));
            }
          }
          return w;
        }
      }
      class lh {
        constructor(o) {
          this._properties = o, this._values = Object.create(o.defaultTransitioningPropertyValues);
        }
        possiblyEvaluate(o, d, g) {
          const v = new mu(this._properties);
          for (const w of Object.keys(this._values))
            v._values[w] = this._values[w].possiblyEvaluate(o, d, g);
          return v;
        }
        hasTransition() {
          for (const o of Object.keys(this._values))
            if (this._values[o].prior)
              return !0;
          return !1;
        }
      }
      class Oc {
        constructor(o) {
          this._properties = o, this._values = Object.create(o.defaultPropertyValues);
        }
        hasValue(o) {
          return this._values[o].value !== void 0;
        }
        getValue(o) {
          return ae(this._values[o].value);
        }
        setValue(o, d) {
          this._values[o] = new Rc(this._values[o].property, d === null ? void 0 : ae(d));
        }
        serialize() {
          const o = {};
          for (const d of Object.keys(this._values)) {
            const g = this.getValue(d);
            g !== void 0 && (o[d] = g);
          }
          return o;
        }
        possiblyEvaluate(o, d, g) {
          const v = new mu(this._properties);
          for (const w of Object.keys(this._values))
            v._values[w] = this._values[w].possiblyEvaluate(o, d, g);
          return v;
        }
      }
      class To {
        constructor(o, d, g) {
          this.property = o, this.value = d, this.parameters = g;
        }
        isConstant() {
          return this.value.kind === "constant";
        }
        constantOr(o) {
          return this.value.kind === "constant" ? this.value.value : o;
        }
        evaluate(o, d, g, v) {
          return this.property.evaluate(this.value, this.parameters, o, d, g, v);
        }
      }
      class mu {
        constructor(o) {
          this._properties = o, this._values = Object.create(o.defaultPossiblyEvaluatedValues);
        }
        get(o) {
          return this._values[o];
        }
      }
      class en {
        constructor(o) {
          this.specification = o;
        }
        possiblyEvaluate(o, d) {
          if (o.isDataDriven())
            throw new Error("Value should not be data driven");
          return o.expression.evaluate(d);
        }
        interpolate(o, d, g) {
          const v = Nr[this.specification.type];
          return v ? v(o, d, g) : o;
        }
      }
      class pn {
        constructor(o, d) {
          this.specification = o, this.overrides = d;
        }
        possiblyEvaluate(o, d, g, v) {
          return new To(this, o.expression.kind === "constant" || o.expression.kind === "camera" ? { kind: "constant", value: o.expression.evaluate(d, null, {}, g, v) } : o.expression, d);
        }
        interpolate(o, d, g) {
          if (o.value.kind !== "constant" || d.value.kind !== "constant")
            return o;
          if (o.value.value === void 0 || d.value.value === void 0)
            return new To(this, { kind: "constant", value: void 0 }, o.parameters);
          const v = Nr[this.specification.type];
          if (v) {
            const w = v(o.value.value, d.value.value, g);
            return new To(this, { kind: "constant", value: w }, o.parameters);
          }
          return o;
        }
        evaluate(o, d, g, v, w, S) {
          return o.kind === "constant" ? o.value : o.evaluate(d, g, v, w, S);
        }
      }
      class E extends pn {
        possiblyEvaluate(o, d, g, v) {
          if (o.value === void 0)
            return new To(this, { kind: "constant", value: void 0 }, d);
          if (o.expression.kind === "constant") {
            const w = o.expression.evaluate(d, null, {}, g, v), S = o.property.specification.type === "resolvedImage" && typeof w != "string" ? w.name : w, P = this._calculate(S, S, S, d);
            return new To(this, { kind: "constant", value: P }, d);
          }
          if (o.expression.kind === "camera") {
            const w = this._calculate(o.expression.evaluate({ zoom: d.zoom - 1 }), o.expression.evaluate({ zoom: d.zoom }), o.expression.evaluate({ zoom: d.zoom + 1 }), d);
            return new To(this, { kind: "constant", value: w }, d);
          }
          return new To(this, o.expression, d);
        }
        evaluate(o, d, g, v, w, S) {
          if (o.kind === "source") {
            const P = o.evaluate(d, g, v, w, S);
            return this._calculate(P, P, P, d);
          }
          return o.kind === "composite" ? this._calculate(o.evaluate({ zoom: Math.floor(d.zoom) - 1 }, g, v), o.evaluate({ zoom: Math.floor(d.zoom) }, g, v), o.evaluate({ zoom: Math.floor(d.zoom) + 1 }, g, v), d) : o.value;
        }
        _calculate(o, d, g, v) {
          return v.zoom > v.zoomHistory.lastIntegerZoom ? { from: o, to: d } : { from: g, to: d };
        }
        interpolate(o) {
          return o;
        }
      }
      class a {
        constructor(o) {
          this.specification = o;
        }
        possiblyEvaluate(o, d, g, v) {
          if (o.value !== void 0) {
            if (o.expression.kind === "constant") {
              const w = o.expression.evaluate(d, null, {}, g, v);
              return this._calculate(w, w, w, d);
            }
            return this._calculate(o.expression.evaluate(new pi(Math.floor(d.zoom - 1), d)), o.expression.evaluate(new pi(Math.floor(d.zoom), d)), o.expression.evaluate(new pi(Math.floor(d.zoom + 1), d)), d);
          }
        }
        _calculate(o, d, g, v) {
          return v.zoom > v.zoomHistory.lastIntegerZoom ? { from: o, to: d } : { from: g, to: d };
        }
        interpolate(o) {
          return o;
        }
      }
      class f {
        constructor(o) {
          this.specification = o;
        }
        possiblyEvaluate(o, d, g, v) {
          return !!o.expression.evaluate(d, null, {}, g, v);
        }
        interpolate() {
          return !1;
        }
      }
      class _ {
        constructor(o) {
          this.properties = o, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
          for (const d in o) {
            const g = o[d];
            g.specification.overridable && this.overridableProperties.push(d);
            const v = this.defaultPropertyValues[d] = new Rc(g, void 0), w = this.defaultTransitionablePropertyValues[d] = new $l(g);
            this.defaultTransitioningPropertyValues[d] = w.untransitioned(), this.defaultPossiblyEvaluatedValues[d] = v.possiblyEvaluate({});
          }
        }
      }
      zt("DataDrivenProperty", pn), zt("DataConstantProperty", en), zt("CrossFadedDataDrivenProperty", E), zt("CrossFadedProperty", a), zt("ColorRampProperty", f);
      const h = "-transition";
      class p extends ut {
        constructor(o, d) {
          if (super(), this.id = o.id, this.type = o.type, this._featureFilter = { filter: () => !0, needGeometry: !1 }, o.type !== "custom" && (this.metadata = o.metadata, this.minzoom = o.minzoom, this.maxzoom = o.maxzoom, o.type !== "background" && (this.source = o.source, this.sourceLayer = o["source-layer"], this.filter = o.filter), d.layout && (this._unevaluatedLayout = new Oc(d.layout)), d.paint)) {
            this._transitionablePaint = new ll(d.paint);
            for (const g in o.paint)
              this.setPaintProperty(g, o.paint[g], { validate: !1 });
            for (const g in o.layout)
              this.setLayoutProperty(g, o.layout[g], { validate: !1 });
            this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new mu(d.paint);
          }
        }
        getCrossfadeParameters() {
          return this._crossfadeParameters;
        }
        getLayoutProperty(o) {
          return o === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(o);
        }
        setLayoutProperty(o, d) {
          let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          d != null && this._validate(of, `layers.${this.id}.layout.${o}`, o, d, g) || (o !== "visibility" ? this._unevaluatedLayout.setValue(o, d) : this.visibility = d);
        }
        getPaintProperty(o) {
          return o.endsWith(h) ? this._transitionablePaint.getTransition(o.slice(0, -11)) : this._transitionablePaint.getValue(o);
        }
        setPaintProperty(o, d) {
          let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          if (d != null && this._validate(Jh, `layers.${this.id}.paint.${o}`, o, d, g))
            return !1;
          if (o.endsWith(h))
            return this._transitionablePaint.setTransition(o.slice(0, -11), d || void 0), !1;
          {
            const v = this._transitionablePaint._values[o], w = v.property.specification["property-type"] === "cross-faded-data-driven", S = v.value.isDataDriven(), P = v.value;
            this._transitionablePaint.setValue(o, d), this._handleSpecialPaintPropertyUpdate(o);
            const B = this._transitionablePaint._values[o].value;
            return B.isDataDriven() || S || w || this._handleOverridablePaintPropertyUpdate(o, P, B);
          }
        }
        _handleSpecialPaintPropertyUpdate(o) {
        }
        _handleOverridablePaintPropertyUpdate(o, d, g) {
          return !1;
        }
        isHidden(o) {
          return !!(this.minzoom && o < this.minzoom) || !!(this.maxzoom && o >= this.maxzoom) || this.visibility === "none";
        }
        updateTransitions(o) {
          this._transitioningPaint = this._transitionablePaint.transitioned(o, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(o, d) {
          o.getCrossfadeParameters && (this._crossfadeParameters = o.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(o, void 0, d)), this.paint = this._transitioningPaint.possiblyEvaluate(o, void 0, d);
        }
        serialize() {
          const o = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
          return this.visibility && (o.layout = o.layout || {}, o.layout.visibility = this.visibility), Fe(o, (d, g) => !(d === void 0 || g === "layout" && !Object.keys(d).length || g === "paint" && !Object.keys(d).length));
        }
        _validate(o, d, g, v) {
          let w = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
          return (!w || w.validate !== !1) && rh(this, o.call(ws, { key: d, layerType: this.type, objectKey: g, value: v, styleSpec: re, style: { glyphs: !0, sprite: !0 } }));
        }
        is3D() {
          return !1;
        }
        isTileClipped() {
          return !1;
        }
        hasOffscreenPass() {
          return !1;
        }
        resize() {
        }
        isStateDependent() {
          for (const o in this.paint._values) {
            const d = this.paint.get(o);
            if (d instanceof To && Jo(d.property.specification) && (d.value.kind === "source" || d.value.kind === "composite") && d.value.isStateDependent)
              return !0;
          }
          return !1;
        }
      }
      const b = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
      class x {
        constructor(o, d) {
          this._structArray = o, this._pos1 = d * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }
      }
      class C {
        constructor() {
          this.isTransferred = !1, this.capacity = -1, this.resize(0);
        }
        static serialize(o, d) {
          return o._trim(), d && (o.isTransferred = !0, d.push(o.arrayBuffer)), { length: o.length, arrayBuffer: o.arrayBuffer };
        }
        static deserialize(o) {
          const d = Object.create(this.prototype);
          return d.arrayBuffer = o.arrayBuffer, d.length = o.length, d.capacity = o.arrayBuffer.byteLength / d.bytesPerElement, d._refreshViews(), d;
        }
        _trim() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(o) {
          this.reserve(o), this.length = o;
        }
        reserve(o) {
          if (o > this.capacity) {
            this.capacity = Math.max(o, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            const d = this.uint8;
            this._refreshViews(), d && this.uint8.set(d);
          }
        }
        _refreshViews() {
          throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
        }
      }
      function M(u) {
        let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, d = 0, g = 0;
        return { members: u.map((v) => {
          const w = b[v.type].BYTES_PER_ELEMENT, S = d = R(d, Math.max(o, w)), P = v.components || 1;
          return g = Math.max(g, w), d += w * P, { name: v.name, type: v.type, components: P, offset: S };
        }), size: R(d, Math.max(g, o)), alignment: o };
      }
      function R(u, o) {
        return Math.ceil(u / o) * o;
      }
      class O extends C {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(o, d) {
          const g = this.length;
          return this.resize(g + 1), this.emplace(g, o, d);
        }
        emplace(o, d, g) {
          const v = 2 * o;
          return this.int16[v + 0] = d, this.int16[v + 1] = g, o;
        }
      }
      O.prototype.bytesPerElement = 4, zt("StructArrayLayout2i4", O);
      class D extends C {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(o, d, g) {
          const v = this.length;
          return this.resize(v + 1), this.emplace(v, o, d, g);
        }
        emplace(o, d, g, v) {
          const w = 3 * o;
          return this.int16[w + 0] = d, this.int16[w + 1] = g, this.int16[w + 2] = v, o;
        }
      }
      D.prototype.bytesPerElement = 6, zt("StructArrayLayout3i6", D);
      class U extends C {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(o, d, g, v) {
          const w = this.length;
          return this.resize(w + 1), this.emplace(w, o, d, g, v);
        }
        emplace(o, d, g, v, w) {
          const S = 4 * o;
          return this.int16[S + 0] = d, this.int16[S + 1] = g, this.int16[S + 2] = v, this.int16[S + 3] = w, o;
        }
      }
      U.prototype.bytesPerElement = 8, zt("StructArrayLayout4i8", U);
      class W extends C {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(o, d, g, v, w, S) {
          const P = this.length;
          return this.resize(P + 1), this.emplace(P, o, d, g, v, w, S);
        }
        emplace(o, d, g, v, w, S, P) {
          const B = 6 * o;
          return this.int16[B + 0] = d, this.int16[B + 1] = g, this.int16[B + 2] = v, this.int16[B + 3] = w, this.int16[B + 4] = S, this.int16[B + 5] = P, o;
        }
      }
      W.prototype.bytesPerElement = 12, zt("StructArrayLayout2i4i12", W);
      class Q extends C {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(o, d, g, v, w, S) {
          const P = this.length;
          return this.resize(P + 1), this.emplace(P, o, d, g, v, w, S);
        }
        emplace(o, d, g, v, w, S, P) {
          const B = 4 * o, k = 8 * o;
          return this.int16[B + 0] = d, this.int16[B + 1] = g, this.uint8[k + 4] = v, this.uint8[k + 5] = w, this.uint8[k + 6] = S, this.uint8[k + 7] = P, o;
        }
      }
      Q.prototype.bytesPerElement = 8, zt("StructArrayLayout2i4ub8", Q);
      class Y extends C {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(o, d) {
          const g = this.length;
          return this.resize(g + 1), this.emplace(g, o, d);
        }
        emplace(o, d, g) {
          const v = 2 * o;
          return this.float32[v + 0] = d, this.float32[v + 1] = g, o;
        }
      }
      Y.prototype.bytesPerElement = 8, zt("StructArrayLayout2f8", Y);
      class K extends C {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(o, d, g, v, w, S, P, B, k, j) {
          const q = this.length;
          return this.resize(q + 1), this.emplace(q, o, d, g, v, w, S, P, B, k, j);
        }
        emplace(o, d, g, v, w, S, P, B, k, j, q) {
          const Z = 10 * o;
          return this.uint16[Z + 0] = d, this.uint16[Z + 1] = g, this.uint16[Z + 2] = v, this.uint16[Z + 3] = w, this.uint16[Z + 4] = S, this.uint16[Z + 5] = P, this.uint16[Z + 6] = B, this.uint16[Z + 7] = k, this.uint16[Z + 8] = j, this.uint16[Z + 9] = q, o;
        }
      }
      K.prototype.bytesPerElement = 20, zt("StructArrayLayout10ui20", K);
      class fe extends C {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(o, d, g, v, w, S, P, B, k, j, q, Z) {
          const ee = this.length;
          return this.resize(ee + 1), this.emplace(ee, o, d, g, v, w, S, P, B, k, j, q, Z);
        }
        emplace(o, d, g, v, w, S, P, B, k, j, q, Z, ee) {
          const oe = 12 * o;
          return this.int16[oe + 0] = d, this.int16[oe + 1] = g, this.int16[oe + 2] = v, this.int16[oe + 3] = w, this.uint16[oe + 4] = S, this.uint16[oe + 5] = P, this.uint16[oe + 6] = B, this.uint16[oe + 7] = k, this.int16[oe + 8] = j, this.int16[oe + 9] = q, this.int16[oe + 10] = Z, this.int16[oe + 11] = ee, o;
        }
      }
      fe.prototype.bytesPerElement = 24, zt("StructArrayLayout4i4ui4i24", fe);
      class ne extends C {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(o, d, g) {
          const v = this.length;
          return this.resize(v + 1), this.emplace(v, o, d, g);
        }
        emplace(o, d, g, v) {
          const w = 3 * o;
          return this.float32[w + 0] = d, this.float32[w + 1] = g, this.float32[w + 2] = v, o;
        }
      }
      ne.prototype.bytesPerElement = 12, zt("StructArrayLayout3f12", ne);
      class ie extends C {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(o) {
          const d = this.length;
          return this.resize(d + 1), this.emplace(d, o);
        }
        emplace(o, d) {
          return this.uint32[1 * o + 0] = d, o;
        }
      }
      ie.prototype.bytesPerElement = 4, zt("StructArrayLayout1ul4", ie);
      class le extends C {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(o, d, g, v, w, S, P, B, k) {
          const j = this.length;
          return this.resize(j + 1), this.emplace(j, o, d, g, v, w, S, P, B, k);
        }
        emplace(o, d, g, v, w, S, P, B, k, j) {
          const q = 10 * o, Z = 5 * o;
          return this.int16[q + 0] = d, this.int16[q + 1] = g, this.int16[q + 2] = v, this.int16[q + 3] = w, this.int16[q + 4] = S, this.int16[q + 5] = P, this.uint32[Z + 3] = B, this.uint16[q + 8] = k, this.uint16[q + 9] = j, o;
        }
      }
      le.prototype.bytesPerElement = 20, zt("StructArrayLayout6i1ul2ui20", le);
      class xe extends C {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(o, d, g, v, w, S) {
          const P = this.length;
          return this.resize(P + 1), this.emplace(P, o, d, g, v, w, S);
        }
        emplace(o, d, g, v, w, S, P) {
          const B = 6 * o;
          return this.int16[B + 0] = d, this.int16[B + 1] = g, this.int16[B + 2] = v, this.int16[B + 3] = w, this.int16[B + 4] = S, this.int16[B + 5] = P, o;
        }
      }
      xe.prototype.bytesPerElement = 12, zt("StructArrayLayout2i2i2i12", xe);
      class Me extends C {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(o, d, g, v, w) {
          const S = this.length;
          return this.resize(S + 1), this.emplace(S, o, d, g, v, w);
        }
        emplace(o, d, g, v, w, S) {
          const P = 4 * o, B = 8 * o;
          return this.float32[P + 0] = d, this.float32[P + 1] = g, this.float32[P + 2] = v, this.int16[B + 6] = w, this.int16[B + 7] = S, o;
        }
      }
      Me.prototype.bytesPerElement = 16, zt("StructArrayLayout2f1f2i16", Me);
      class Ne extends C {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(o, d, g, v, w, S) {
          const P = this.length;
          return this.resize(P + 1), this.emplace(P, o, d, g, v, w, S);
        }
        emplace(o, d, g, v, w, S, P) {
          const B = 16 * o, k = 4 * o, j = 8 * o;
          return this.uint8[B + 0] = d, this.uint8[B + 1] = g, this.float32[k + 1] = v, this.float32[k + 2] = w, this.int16[j + 6] = S, this.int16[j + 7] = P, o;
        }
      }
      Ne.prototype.bytesPerElement = 16, zt("StructArrayLayout2ub2f2i16", Ne);
      class ot extends C {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(o, d, g) {
          const v = this.length;
          return this.resize(v + 1), this.emplace(v, o, d, g);
        }
        emplace(o, d, g, v) {
          const w = 3 * o;
          return this.uint16[w + 0] = d, this.uint16[w + 1] = g, this.uint16[w + 2] = v, o;
        }
      }
      ot.prototype.bytesPerElement = 6, zt("StructArrayLayout3ui6", ot);
      class et extends C {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(o, d, g, v, w, S, P, B, k, j, q, Z, ee, oe, pe, we, Pe) {
          const He = this.length;
          return this.resize(He + 1), this.emplace(He, o, d, g, v, w, S, P, B, k, j, q, Z, ee, oe, pe, we, Pe);
        }
        emplace(o, d, g, v, w, S, P, B, k, j, q, Z, ee, oe, pe, we, Pe, He) {
          const ke = 24 * o, Ge = 12 * o, at = 48 * o;
          return this.int16[ke + 0] = d, this.int16[ke + 1] = g, this.uint16[ke + 2] = v, this.uint16[ke + 3] = w, this.uint32[Ge + 2] = S, this.uint32[Ge + 3] = P, this.uint32[Ge + 4] = B, this.uint16[ke + 10] = k, this.uint16[ke + 11] = j, this.uint16[ke + 12] = q, this.float32[Ge + 7] = Z, this.float32[Ge + 8] = ee, this.uint8[at + 36] = oe, this.uint8[at + 37] = pe, this.uint8[at + 38] = we, this.uint32[Ge + 10] = Pe, this.int16[ke + 22] = He, o;
        }
      }
      et.prototype.bytesPerElement = 48, zt("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", et);
      class rt extends C {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(o, d, g, v, w, S, P, B, k, j, q, Z, ee, oe, pe, we, Pe, He, ke, Ge, at, bt, Ut, ln, jt, Dt, rn, Zt) {
          const Jt = this.length;
          return this.resize(Jt + 1), this.emplace(Jt, o, d, g, v, w, S, P, B, k, j, q, Z, ee, oe, pe, we, Pe, He, ke, Ge, at, bt, Ut, ln, jt, Dt, rn, Zt);
        }
        emplace(o, d, g, v, w, S, P, B, k, j, q, Z, ee, oe, pe, we, Pe, He, ke, Ge, at, bt, Ut, ln, jt, Dt, rn, Zt, Jt) {
          const gt = 32 * o, sn = 16 * o;
          return this.int16[gt + 0] = d, this.int16[gt + 1] = g, this.int16[gt + 2] = v, this.int16[gt + 3] = w, this.int16[gt + 4] = S, this.int16[gt + 5] = P, this.int16[gt + 6] = B, this.int16[gt + 7] = k, this.uint16[gt + 8] = j, this.uint16[gt + 9] = q, this.uint16[gt + 10] = Z, this.uint16[gt + 11] = ee, this.uint16[gt + 12] = oe, this.uint16[gt + 13] = pe, this.uint16[gt + 14] = we, this.uint16[gt + 15] = Pe, this.uint16[gt + 16] = He, this.uint16[gt + 17] = ke, this.uint16[gt + 18] = Ge, this.uint16[gt + 19] = at, this.uint16[gt + 20] = bt, this.uint16[gt + 21] = Ut, this.uint16[gt + 22] = ln, this.uint32[sn + 12] = jt, this.float32[sn + 13] = Dt, this.float32[sn + 14] = rn, this.uint16[gt + 30] = Zt, this.uint16[gt + 31] = Jt, o;
        }
      }
      rt.prototype.bytesPerElement = 64, zt("StructArrayLayout8i15ui1ul2f2ui64", rt);
      class $e extends C {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(o) {
          const d = this.length;
          return this.resize(d + 1), this.emplace(d, o);
        }
        emplace(o, d) {
          return this.float32[1 * o + 0] = d, o;
        }
      }
      $e.prototype.bytesPerElement = 4, zt("StructArrayLayout1f4", $e);
      class Ct extends C {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(o, d, g) {
          const v = this.length;
          return this.resize(v + 1), this.emplace(v, o, d, g);
        }
        emplace(o, d, g, v) {
          const w = 3 * o;
          return this.uint16[6 * o + 0] = d, this.float32[w + 1] = g, this.float32[w + 2] = v, o;
        }
      }
      Ct.prototype.bytesPerElement = 12, zt("StructArrayLayout1ui2f12", Ct);
      class qt extends C {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(o, d, g) {
          const v = this.length;
          return this.resize(v + 1), this.emplace(v, o, d, g);
        }
        emplace(o, d, g, v) {
          const w = 4 * o;
          return this.uint32[2 * o + 0] = d, this.uint16[w + 2] = g, this.uint16[w + 3] = v, o;
        }
      }
      qt.prototype.bytesPerElement = 8, zt("StructArrayLayout1ul2ui8", qt);
      class yt extends C {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(o, d) {
          const g = this.length;
          return this.resize(g + 1), this.emplace(g, o, d);
        }
        emplace(o, d, g) {
          const v = 2 * o;
          return this.uint16[v + 0] = d, this.uint16[v + 1] = g, o;
        }
      }
      yt.prototype.bytesPerElement = 4, zt("StructArrayLayout2ui4", yt);
      class vt extends C {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(o) {
          const d = this.length;
          return this.resize(d + 1), this.emplace(d, o);
        }
        emplace(o, d) {
          return this.uint16[1 * o + 0] = d, o;
        }
      }
      vt.prototype.bytesPerElement = 2, zt("StructArrayLayout1ui2", vt);
      class Ht extends C {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(o, d, g, v) {
          const w = this.length;
          return this.resize(w + 1), this.emplace(w, o, d, g, v);
        }
        emplace(o, d, g, v, w) {
          const S = 4 * o;
          return this.float32[S + 0] = d, this.float32[S + 1] = g, this.float32[S + 2] = v, this.float32[S + 3] = w, o;
        }
      }
      Ht.prototype.bytesPerElement = 16, zt("StructArrayLayout4f16", Ht);
      class Sn extends x {
        get anchorPointX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorPointY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get x1() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get y1() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get x2() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get y2() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get anchorPoint() {
          return new T(this.anchorPointX, this.anchorPointY);
        }
      }
      Sn.prototype.size = 20;
      class Ot extends le {
        get(o) {
          return new Sn(this, o);
        }
      }
      zt("CollisionBoxArray", Ot);
      class gn extends x {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 2];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 4];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 7];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 8];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 36];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 37];
        }
        set placedOrientation(o) {
          this._structArray.uint8[this._pos1 + 37] = o;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 38];
        }
        set hidden(o) {
          this._structArray.uint8[this._pos1 + 38] = o;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 10];
        }
        set crossTileID(o) {
          this._structArray.uint32[this._pos4 + 10] = o;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 22];
        }
      }
      gn.prototype.size = 48;
      class Wn extends et {
        get(o) {
          return new gn(this, o);
        }
      }
      zt("PlacedSymbolArray", Wn);
      class Qn extends x {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 6];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 7];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 13];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 12];
        }
        set crossTileID(o) {
          this._structArray.uint32[this._pos4 + 12] = o;
        }
        get textBoxScale() {
          return this._structArray.float32[this._pos4 + 13];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 14];
        }
        get textAnchorOffsetStartIndex() {
          return this._structArray.uint16[this._pos2 + 30];
        }
        get textAnchorOffsetEndIndex() {
          return this._structArray.uint16[this._pos2 + 31];
        }
      }
      Qn.prototype.size = 64;
      class ji extends rt {
        get(o) {
          return new Qn(this, o);
        }
      }
      zt("SymbolInstanceArray", ji);
      class En extends $e {
        getoffsetX(o) {
          return this.float32[1 * o + 0];
        }
      }
      zt("GlyphOffsetArray", En);
      class Li extends D {
        getx(o) {
          return this.int16[3 * o + 0];
        }
        gety(o) {
          return this.int16[3 * o + 1];
        }
        gettileUnitDistanceFromAnchor(o) {
          return this.int16[3 * o + 2];
        }
      }
      zt("SymbolLineVertexArray", Li);
      class Ai extends x {
        get textAnchor() {
          return this._structArray.uint16[this._pos2 + 0];
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 1];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 2];
        }
      }
      Ai.prototype.size = 12;
      class ni extends Ct {
        get(o) {
          return new Ai(this, o);
        }
      }
      zt("TextAnchorOffsetArray", ni);
      class ri extends x {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
      }
      ri.prototype.size = 8;
      class ki extends qt {
        get(o) {
          return new ri(this, o);
        }
      }
      zt("FeatureIndexArray", ki);
      class Ar extends O {
      }
      class Es extends O {
      }
      class Yi extends O {
      }
      class ts extends W {
      }
      class Co extends Q {
      }
      class Fa extends Y {
      }
      class Gi extends K {
      }
      class si extends fe {
      }
      class Io extends ne {
      }
      class cl extends ie {
      }
      class Rr extends xe {
      }
      class mr extends Ne {
      }
      class nr extends ot {
      }
      class Ei extends yt {
      }
      const Ur = M([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Da } = Ur;
      class Vi {
        constructor() {
          let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          this.segments = o;
        }
        prepareSegment(o, d, g, v) {
          let w = this.segments[this.segments.length - 1];
          return o > Vi.MAX_VERTEX_ARRAY_LENGTH && Te(`Max vertices per segment is ${Vi.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${o}`), (!w || w.vertexLength + o > Vi.MAX_VERTEX_ARRAY_LENGTH || w.sortKey !== v) && (w = { vertexOffset: d.length, primitiveOffset: g.length, vertexLength: 0, primitiveLength: 0 }, v !== void 0 && (w.sortKey = v), this.segments.push(w)), w;
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const o of this.segments)
            for (const d in o.vaos)
              o.vaos[d].destroy();
        }
        static simpleSegment(o, d, g, v) {
          return new Vi([{ vertexOffset: o, primitiveOffset: d, vertexLength: g, primitiveLength: v, vaos: {}, sortKey: 0 }]);
        }
      }
      function ch(u, o) {
        return 256 * (u = Se(Math.floor(u), 0, 255)) + Se(Math.floor(o), 0, 255);
      }
      Vi.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, zt("SegmentVector", Vi);
      const ul = M([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
      var Fc = { exports: {} }, ho = { exports: {} };
      ho.exports = function(u, o) {
        var d, g, v, w, S, P, B, k;
        for (g = u.length - (d = 3 & u.length), v = o, S = 3432918353, P = 461845907, k = 0; k < g; )
          B = 255 & u.charCodeAt(k) | (255 & u.charCodeAt(++k)) << 8 | (255 & u.charCodeAt(++k)) << 16 | (255 & u.charCodeAt(++k)) << 24, ++k, v = 27492 + (65535 & (w = 5 * (65535 & (v = (v ^= B = (65535 & (B = (B = (65535 & B) * S + (((B >>> 16) * S & 65535) << 16) & 4294967295) << 15 | B >>> 17)) * P + (((B >>> 16) * P & 65535) << 16) & 4294967295) << 13 | v >>> 19)) + ((5 * (v >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (w >>> 16) & 65535) << 16);
        switch (B = 0, d) {
          case 3:
            B ^= (255 & u.charCodeAt(k + 2)) << 16;
          case 2:
            B ^= (255 & u.charCodeAt(k + 1)) << 8;
          case 1:
            v ^= B = (65535 & (B = (B = (65535 & (B ^= 255 & u.charCodeAt(k))) * S + (((B >>> 16) * S & 65535) << 16) & 4294967295) << 15 | B >>> 17)) * P + (((B >>> 16) * P & 65535) << 16) & 4294967295;
        }
        return v ^= u.length, v = 2246822507 * (65535 & (v ^= v >>> 16)) + ((2246822507 * (v >>> 16) & 65535) << 16) & 4294967295, v = 3266489909 * (65535 & (v ^= v >>> 13)) + ((3266489909 * (v >>> 16) & 65535) << 16) & 4294967295, (v ^= v >>> 16) >>> 0;
      };
      var _u = ho.exports, Zl = { exports: {} };
      Zl.exports = function(u, o) {
        for (var d, g = u.length, v = o ^ g, w = 0; g >= 4; )
          d = 1540483477 * (65535 & (d = 255 & u.charCodeAt(w) | (255 & u.charCodeAt(++w)) << 8 | (255 & u.charCodeAt(++w)) << 16 | (255 & u.charCodeAt(++w)) << 24)) + ((1540483477 * (d >>> 16) & 65535) << 16), v = 1540483477 * (65535 & v) + ((1540483477 * (v >>> 16) & 65535) << 16) ^ (d = 1540483477 * (65535 & (d ^= d >>> 24)) + ((1540483477 * (d >>> 16) & 65535) << 16)), g -= 4, ++w;
        switch (g) {
          case 3:
            v ^= (255 & u.charCodeAt(w + 2)) << 16;
          case 2:
            v ^= (255 & u.charCodeAt(w + 1)) << 8;
          case 1:
            v = 1540483477 * (65535 & (v ^= 255 & u.charCodeAt(w))) + ((1540483477 * (v >>> 16) & 65535) << 16);
        }
        return v = 1540483477 * (65535 & (v ^= v >>> 13)) + ((1540483477 * (v >>> 16) & 65535) << 16), (v ^= v >>> 15) >>> 0;
      };
      var hl = _u, uh = Zl.exports;
      Fc.exports = hl, Fc.exports.murmur3 = hl, Fc.exports.murmur2 = uh;
      var yu = m(Fc.exports);
      class ka {
        constructor() {
          this.ids = [], this.positions = [], this.indexed = !1;
        }
        add(o, d, g, v) {
          this.ids.push(dl(o)), this.positions.push(d, g, v);
        }
        getPositions(o) {
          if (!this.indexed)
            throw new Error("Trying to get index, but feature positions are not indexed");
          const d = dl(o);
          let g = 0, v = this.ids.length - 1;
          for (; g < v; ) {
            const S = g + v >> 1;
            this.ids[S] >= d ? v = S : g = S + 1;
          }
          const w = [];
          for (; this.ids[g] === d; )
            w.push({ index: this.positions[3 * g], start: this.positions[3 * g + 1], end: this.positions[3 * g + 2] }), g++;
          return w;
        }
        static serialize(o, d) {
          const g = new Float64Array(o.ids), v = new Uint32Array(o.positions);
          return af(g, v, 0, g.length - 1), d && d.push(g.buffer, v.buffer), { ids: g, positions: v };
        }
        static deserialize(o) {
          const d = new ka();
          return d.ids = o.ids, d.positions = o.positions, d.indexed = !0, d;
        }
      }
      function dl(u) {
        const o = +u;
        return !isNaN(o) && o <= Number.MAX_SAFE_INTEGER ? o : yu(String(u));
      }
      function af(u, o, d, g) {
        for (; d < g; ) {
          const v = u[d + g >> 1];
          let w = d - 1, S = g + 1;
          for (; ; ) {
            do
              w++;
            while (u[w] < v);
            do
              S--;
            while (u[S] > v);
            if (w >= S)
              break;
            Kh(u, w, S), Kh(o, 3 * w, 3 * S), Kh(o, 3 * w + 1, 3 * S + 1), Kh(o, 3 * w + 2, 3 * S + 2);
          }
          S - d < g - S ? (af(u, o, d, S), d = S + 1) : (af(u, o, S + 1, g), g = S);
        }
      }
      function Kh(u, o, d) {
        const g = u[o];
        u[o] = u[d], u[d] = g;
      }
      zt("FeaturePositionMap", ka);
      class Dc {
        constructor(o, d) {
          this.gl = o.gl, this.location = d;
        }
      }
      class hh extends Dc {
        constructor(o, d) {
          super(o, d), this.current = 0;
        }
        set(o) {
          this.current !== o && (this.current = o, this.gl.uniform1f(this.location, o));
        }
      }
      class dh extends Dc {
        constructor(o, d) {
          super(o, d), this.current = [0, 0, 0, 0];
        }
        set(o) {
          o[0] === this.current[0] && o[1] === this.current[1] && o[2] === this.current[2] && o[3] === this.current[3] || (this.current = o, this.gl.uniform4f(this.location, o[0], o[1], o[2], o[3]));
        }
      }
      class lf extends Dc {
        constructor(o, d) {
          super(o, d), this.current = Xn.transparent;
        }
        set(o) {
          o.r === this.current.r && o.g === this.current.g && o.b === this.current.b && o.a === this.current.a || (this.current = o, this.gl.uniform4f(this.location, o.r, o.g, o.b, o.a));
        }
      }
      const Vp = new Float32Array(16);
      function vu(u) {
        return [ch(255 * u.r, 255 * u.g), ch(255 * u.b, 255 * u.a)];
      }
      class kc {
        constructor(o, d, g) {
          this.value = o, this.uniformNames = d.map((v) => `u_${v}`), this.type = g;
        }
        setUniform(o, d, g) {
          o.set(g.constantOr(this.value));
        }
        getBinding(o, d, g) {
          return this.type === "color" ? new lf(o, d) : new hh(o, d);
        }
      }
      class Na {
        constructor(o, d) {
          this.uniformNames = d.map((g) => `u_${g}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
        }
        setConstantPatternPositions(o, d) {
          this.pixelRatioFrom = d.pixelRatio, this.pixelRatioTo = o.pixelRatio, this.patternFrom = d.tlbr, this.patternTo = o.tlbr;
        }
        setUniform(o, d, g, v) {
          const w = v === "u_pattern_to" ? this.patternTo : v === "u_pattern_from" ? this.patternFrom : v === "u_pixel_ratio_to" ? this.pixelRatioTo : v === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
          w && o.set(w);
        }
        getBinding(o, d, g) {
          return g.substr(0, 9) === "u_pattern" ? new dh(o, d) : new hh(o, d);
        }
      }
      class za {
        constructor(o, d, g, v) {
          this.expression = o, this.type = g, this.maxValue = 0, this.paintVertexAttributes = d.map((w) => ({ name: `a_${w}`, type: "Float32", components: g === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new v();
        }
        populatePaintArray(o, d, g, v, w) {
          const S = this.paintVertexArray.length, P = this.expression.evaluate(new pi(0), d, {}, v, [], w);
          this.paintVertexArray.resize(o), this._setPaintValue(S, o, P);
        }
        updatePaintArray(o, d, g, v) {
          const w = this.expression.evaluate({ zoom: 0 }, g, v);
          this._setPaintValue(o, d, w);
        }
        _setPaintValue(o, d, g) {
          if (this.type === "color") {
            const v = vu(g);
            for (let w = o; w < d; w++)
              this.paintVertexArray.emplace(w, v[0], v[1]);
          } else {
            for (let v = o; v < d; v++)
              this.paintVertexArray.emplace(v, g);
            this.maxValue = Math.max(this.maxValue, Math.abs(g));
          }
        }
        upload(o) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = o.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class Qo {
        constructor(o, d, g, v, w, S) {
          this.expression = o, this.uniformNames = d.map((P) => `u_${P}_t`), this.type = g, this.useIntegerZoom = v, this.zoom = w, this.maxValue = 0, this.paintVertexAttributes = d.map((P) => ({ name: `a_${P}`, type: "Float32", components: g === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new S();
        }
        populatePaintArray(o, d, g, v, w) {
          const S = this.expression.evaluate(new pi(this.zoom), d, {}, v, [], w), P = this.expression.evaluate(new pi(this.zoom + 1), d, {}, v, [], w), B = this.paintVertexArray.length;
          this.paintVertexArray.resize(o), this._setPaintValue(B, o, S, P);
        }
        updatePaintArray(o, d, g, v) {
          const w = this.expression.evaluate({ zoom: this.zoom }, g, v), S = this.expression.evaluate({ zoom: this.zoom + 1 }, g, v);
          this._setPaintValue(o, d, w, S);
        }
        _setPaintValue(o, d, g, v) {
          if (this.type === "color") {
            const w = vu(g), S = vu(v);
            for (let P = o; P < d; P++)
              this.paintVertexArray.emplace(P, w[0], w[1], S[0], S[1]);
          } else {
            for (let w = o; w < d; w++)
              this.paintVertexArray.emplace(w, g, v);
            this.maxValue = Math.max(this.maxValue, Math.abs(g), Math.abs(v));
          }
        }
        upload(o) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = o.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(o, d) {
          const g = this.useIntegerZoom ? Math.floor(d.zoom) : d.zoom, v = Se(this.expression.interpolationFactor(g, this.zoom, this.zoom + 1), 0, 1);
          o.set(v);
        }
        getBinding(o, d, g) {
          return new hh(o, d);
        }
      }
      class ea {
        constructor(o, d, g, v, w, S) {
          this.expression = o, this.type = d, this.useIntegerZoom = g, this.zoom = v, this.layerId = S, this.zoomInPaintVertexArray = new w(), this.zoomOutPaintVertexArray = new w();
        }
        populatePaintArray(o, d, g) {
          const v = this.zoomInPaintVertexArray.length;
          this.zoomInPaintVertexArray.resize(o), this.zoomOutPaintVertexArray.resize(o), this._setPaintValues(v, o, d.patterns && d.patterns[this.layerId], g);
        }
        updatePaintArray(o, d, g, v, w) {
          this._setPaintValues(o, d, g.patterns && g.patterns[this.layerId], w);
        }
        _setPaintValues(o, d, g, v) {
          if (!v || !g)
            return;
          const { min: w, mid: S, max: P } = g, B = v[w], k = v[S], j = v[P];
          if (B && k && j)
            for (let q = o; q < d; q++)
              this.zoomInPaintVertexArray.emplace(q, k.tl[0], k.tl[1], k.br[0], k.br[1], B.tl[0], B.tl[1], B.br[0], B.br[1], k.pixelRatio, B.pixelRatio), this.zoomOutPaintVertexArray.emplace(q, k.tl[0], k.tl[1], k.br[0], k.br[1], j.tl[0], j.tl[1], j.br[0], j.br[1], k.pixelRatio, j.pixelRatio);
        }
        upload(o) {
          this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = o.createVertexBuffer(this.zoomInPaintVertexArray, ul.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = o.createVertexBuffer(this.zoomOutPaintVertexArray, ul.members, this.expression.isStateDependent));
        }
        destroy() {
          this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
        }
      }
      class cf {
        constructor(o, d, g) {
          this.binders = {}, this._buffers = [];
          const v = [];
          for (const w in o.paint._values) {
            if (!g(w))
              continue;
            const S = o.paint.get(w);
            if (!(S instanceof To && Jo(S.property.specification)))
              continue;
            const P = Yl(w, o.type), B = S.value, k = S.property.specification.type, j = S.property.useIntegerZoom, q = S.property.specification["property-type"], Z = q === "cross-faded" || q === "cross-faded-data-driven";
            if (B.kind === "constant")
              this.binders[w] = Z ? new Na(B.value, P) : new kc(B.value, P, k), v.push(`/u_${w}`);
            else if (B.kind === "source" || Z) {
              const ee = uf(w, k, "source");
              this.binders[w] = Z ? new ea(B, k, j, d, ee, o.id) : new za(B, P, k, ee), v.push(`/a_${w}`);
            } else {
              const ee = uf(w, k, "composite");
              this.binders[w] = new Qo(B, P, k, j, d, ee), v.push(`/z_${w}`);
            }
          }
          this.cacheKey = v.sort().join("");
        }
        getMaxValue(o) {
          const d = this.binders[o];
          return d instanceof za || d instanceof Qo ? d.maxValue : 0;
        }
        populatePaintArrays(o, d, g, v, w) {
          for (const S in this.binders) {
            const P = this.binders[S];
            (P instanceof za || P instanceof Qo || P instanceof ea) && P.populatePaintArray(o, d, g, v, w);
          }
        }
        setConstantPatternPositions(o, d) {
          for (const g in this.binders) {
            const v = this.binders[g];
            v instanceof Na && v.setConstantPatternPositions(o, d);
          }
        }
        updatePaintArrays(o, d, g, v, w) {
          let S = !1;
          for (const P in o) {
            const B = d.getPositions(P);
            for (const k of B) {
              const j = g.feature(k.index);
              for (const q in this.binders) {
                const Z = this.binders[q];
                if ((Z instanceof za || Z instanceof Qo || Z instanceof ea) && Z.expression.isStateDependent === !0) {
                  const ee = v.paint.get(q);
                  Z.expression = ee.value, Z.updatePaintArray(k.start, k.end, j, o[P], w), S = !0;
                }
              }
            }
          }
          return S;
        }
        defines() {
          const o = [];
          for (const d in this.binders) {
            const g = this.binders[d];
            (g instanceof kc || g instanceof Na) && o.push(...g.uniformNames.map((v) => `#define HAS_UNIFORM_${v}`));
          }
          return o;
        }
        getBinderAttributes() {
          const o = [];
          for (const d in this.binders) {
            const g = this.binders[d];
            if (g instanceof za || g instanceof Qo)
              for (let v = 0; v < g.paintVertexAttributes.length; v++)
                o.push(g.paintVertexAttributes[v].name);
            else if (g instanceof ea)
              for (let v = 0; v < ul.members.length; v++)
                o.push(ul.members[v].name);
          }
          return o;
        }
        getBinderUniforms() {
          const o = [];
          for (const d in this.binders) {
            const g = this.binders[d];
            if (g instanceof kc || g instanceof Na || g instanceof Qo)
              for (const v of g.uniformNames)
                o.push(v);
          }
          return o;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(o, d) {
          const g = [];
          for (const v in this.binders) {
            const w = this.binders[v];
            if (w instanceof kc || w instanceof Na || w instanceof Qo) {
              for (const S of w.uniformNames)
                if (d[S]) {
                  const P = w.getBinding(o, d[S], S);
                  g.push({ name: S, property: v, binding: P });
                }
            }
          }
          return g;
        }
        setUniforms(o, d, g, v) {
          for (const { name: w, property: S, binding: P } of d)
            this.binders[S].setUniform(P, v, g.get(S), w);
        }
        updatePaintBuffers(o) {
          this._buffers = [];
          for (const d in this.binders) {
            const g = this.binders[d];
            if (o && g instanceof ea) {
              const v = o.fromScale === 2 ? g.zoomInPaintVertexBuffer : g.zoomOutPaintVertexBuffer;
              v && this._buffers.push(v);
            } else
              (g instanceof za || g instanceof Qo) && g.paintVertexBuffer && this._buffers.push(g.paintVertexBuffer);
          }
        }
        upload(o) {
          for (const d in this.binders) {
            const g = this.binders[d];
            (g instanceof za || g instanceof Qo || g instanceof ea) && g.upload(o);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const o in this.binders) {
            const d = this.binders[o];
            (d instanceof za || d instanceof Qo || d instanceof ea) && d.destroy();
          }
        }
      }
      class fl {
        constructor(o, d) {
          let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : () => !0;
          this.programConfigurations = {};
          for (const v of o)
            this.programConfigurations[v.id] = new cf(v, d, g);
          this.needsUpload = !1, this._featureMap = new ka(), this._bufferOffset = 0;
        }
        populatePaintArrays(o, d, g, v, w, S) {
          for (const P in this.programConfigurations)
            this.programConfigurations[P].populatePaintArrays(o, d, v, w, S);
          d.id !== void 0 && this._featureMap.add(d.id, g, this._bufferOffset, o), this._bufferOffset = o, this.needsUpload = !0;
        }
        updatePaintArrays(o, d, g, v) {
          for (const w of g)
            this.needsUpload = this.programConfigurations[w.id].updatePaintArrays(o, this._featureMap, d, w, v) || this.needsUpload;
        }
        get(o) {
          return this.programConfigurations[o];
        }
        upload(o) {
          if (this.needsUpload) {
            for (const d in this.programConfigurations)
              this.programConfigurations[d].upload(o);
            this.needsUpload = !1;
          }
        }
        destroy() {
          for (const o in this.programConfigurations)
            this.programConfigurations[o].destroy();
        }
      }
      function Yl(u, o) {
        return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[u] || [u.replace(`${o}-`, "").replace(/-/g, "_")];
      }
      function uf(u, o, d) {
        const g = { color: { source: Y, composite: Ht }, number: { source: $e, composite: Y } }, v = function(w) {
          return { "line-pattern": { source: Gi, composite: Gi }, "fill-pattern": { source: Gi, composite: Gi }, "fill-extrusion-pattern": { source: Gi, composite: Gi } }[w];
        }(u);
        return v && v[d] || g[o][d];
      }
      zt("ConstantBinder", kc), zt("CrossFadedConstantBinder", Na), zt("SourceExpressionBinder", za), zt("CrossFadedCompositeBinder", ea), zt("CompositeExpressionBinder", Qo), zt("ProgramConfiguration", cf, { omit: ["_buffers"] }), zt("ProgramConfigurationSet", fl);
      const ar = 8192, hf = Math.pow(2, 14) - 1, df = -hf - 1;
      function Po(u) {
        const o = ar / u.extent, d = u.loadGeometry();
        for (let g = 0; g < d.length; g++) {
          const v = d[g];
          for (let w = 0; w < v.length; w++) {
            const S = v[w], P = Math.round(S.x * o), B = Math.round(S.y * o);
            S.x = Se(P, df, hf), S.y = Se(B, df, hf), (P < S.x || P > S.x + 1 || B < S.y || B > S.y + 1) && Te("Geometry exceeds allowed extent, reduce your vector tile buffer size");
          }
        }
        return d;
      }
      function Nc(u, o) {
        return { type: u.type, id: u.id, properties: u.properties, geometry: o ? Po(u) : [] };
      }
      function fh(u, o, d, g, v) {
        u.emplaceBack(2 * o + (g + 1) / 2, 2 * d + (v + 1) / 2);
      }
      class ff {
        constructor(o) {
          this.zoom = o.zoom, this.overscaling = o.overscaling, this.layers = o.layers, this.layerIds = this.layers.map((d) => d.id), this.index = o.index, this.hasPattern = !1, this.layoutVertexArray = new Es(), this.indexArray = new nr(), this.segments = new Vi(), this.programConfigurations = new fl(o.layers, o.zoom), this.stateDependentLayerIds = this.layers.filter((d) => d.isStateDependent()).map((d) => d.id);
        }
        populate(o, d, g) {
          const v = this.layers[0], w = [];
          let S = null, P = !1;
          v.type === "circle" && (S = v.layout.get("circle-sort-key"), P = !S.isConstant());
          for (const { feature: B, id: k, index: j, sourceLayerIndex: q } of o) {
            const Z = this.layers[0]._featureFilter.needGeometry, ee = Nc(B, Z);
            if (!this.layers[0]._featureFilter.filter(new pi(this.zoom), ee, g))
              continue;
            const oe = P ? S.evaluate(ee, {}, g) : void 0, pe = { id: k, properties: B.properties, type: B.type, sourceLayerIndex: q, index: j, geometry: Z ? ee.geometry : Po(B), patterns: {}, sortKey: oe };
            w.push(pe);
          }
          P && w.sort((B, k) => B.sortKey - k.sortKey);
          for (const B of w) {
            const { geometry: k, index: j, sourceLayerIndex: q } = B, Z = o[j].feature;
            this.addFeature(B, k, j, g), d.featureIndex.insert(Z, k, j, q, this.index);
          }
        }
        update(o, d, g) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(o, d, this.stateDependentLayers, g);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(o) {
          this.uploaded || (this.layoutVertexBuffer = o.createVertexBuffer(this.layoutVertexArray, Da), this.indexBuffer = o.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(o), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(o, d, g, v) {
          for (const w of d)
            for (const S of w) {
              const P = S.x, B = S.y;
              if (P < 0 || P >= ar || B < 0 || B >= ar)
                continue;
              const k = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, o.sortKey), j = k.vertexLength;
              fh(this.layoutVertexArray, P, B, -1, -1), fh(this.layoutVertexArray, P, B, 1, -1), fh(this.layoutVertexArray, P, B, 1, 1), fh(this.layoutVertexArray, P, B, -1, 1), this.indexArray.emplaceBack(j, j + 1, j + 2), this.indexArray.emplaceBack(j, j + 3, j + 2), k.vertexLength += 4, k.primitiveLength += 2;
            }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, o, g, {}, v);
        }
      }
      function pf(u, o) {
        for (let d = 0; d < u.length; d++)
          if (Kl(o, u[d]))
            return !0;
        for (let d = 0; d < o.length; d++)
          if (Kl(u, o[d]))
            return !0;
        return !!xu(u, o);
      }
      function $m(u, o, d) {
        return !!Kl(u, o) || !!Ua(o, u, d);
      }
      function bu(u, o) {
        if (u.length === 1)
          return ph(o, u[0]);
        for (let d = 0; d < o.length; d++) {
          const g = o[d];
          for (let v = 0; v < g.length; v++)
            if (Kl(u, g[v]))
              return !0;
        }
        for (let d = 0; d < u.length; d++)
          if (ph(o, u[d]))
            return !0;
        for (let d = 0; d < o.length; d++)
          if (xu(u, o[d]))
            return !0;
        return !1;
      }
      function gf(u, o, d) {
        if (u.length > 1) {
          if (xu(u, o))
            return !0;
          for (let g = 0; g < o.length; g++)
            if (Ua(o[g], u, d))
              return !0;
        }
        for (let g = 0; g < u.length; g++)
          if (Ua(u[g], o, d))
            return !0;
        return !1;
      }
      function xu(u, o) {
        if (u.length === 0 || o.length === 0)
          return !1;
        for (let d = 0; d < u.length - 1; d++) {
          const g = u[d], v = u[d + 1];
          for (let w = 0; w < o.length - 1; w++)
            if (pl(g, v, o[w], o[w + 1]))
              return !0;
        }
        return !1;
      }
      function pl(u, o, d, g) {
        return be(u, d, g) !== be(o, d, g) && be(u, o, d) !== be(u, o, g);
      }
      function Ua(u, o, d) {
        const g = d * d;
        if (o.length === 1)
          return u.distSqr(o[0]) < g;
        for (let v = 1; v < o.length; v++)
          if (gl(u, o[v - 1], o[v]) < g)
            return !0;
        return !1;
      }
      function gl(u, o, d) {
        const g = o.distSqr(d);
        if (g === 0)
          return u.distSqr(o);
        const v = ((u.x - o.x) * (d.x - o.x) + (u.y - o.y) * (d.y - o.y)) / g;
        return u.distSqr(v < 0 ? o : v > 1 ? d : d.sub(o)._mult(v)._add(o));
      }
      function ph(u, o) {
        let d, g, v, w = !1;
        for (let S = 0; S < u.length; S++) {
          d = u[S];
          for (let P = 0, B = d.length - 1; P < d.length; B = P++)
            g = d[P], v = d[B], g.y > o.y != v.y > o.y && o.x < (v.x - g.x) * (o.y - g.y) / (v.y - g.y) + g.x && (w = !w);
        }
        return w;
      }
      function Kl(u, o) {
        let d = !1;
        for (let g = 0, v = u.length - 1; g < u.length; v = g++) {
          const w = u[g], S = u[v];
          w.y > o.y != S.y > o.y && o.x < (S.x - w.x) * (o.y - w.y) / (S.y - w.y) + w.x && (d = !d);
        }
        return d;
      }
      function qp(u, o, d) {
        const g = d[0], v = d[2];
        if (u.x < g.x && o.x < g.x || u.x > v.x && o.x > v.x || u.y < g.y && o.y < g.y || u.y > v.y && o.y > v.y)
          return !1;
        const w = be(u, o, d[0]);
        return w !== be(u, o, d[1]) || w !== be(u, o, d[2]) || w !== be(u, o, d[3]);
      }
      function gh(u, o, d) {
        const g = o.paint.get(u).value;
        return g.kind === "constant" ? g.value : d.programConfigurations.get(o.id).getMaxValue(u);
      }
      function wu(u) {
        return Math.sqrt(u[0] * u[0] + u[1] * u[1]);
      }
      function Au(u, o, d, g, v) {
        if (!o[0] && !o[1])
          return u;
        const w = T.convert(o)._mult(v);
        d === "viewport" && w._rotate(-g);
        const S = [];
        for (let P = 0; P < u.length; P++)
          S.push(u[P].sub(w));
        return S;
      }
      let Rv, Ov;
      zt("CircleBucket", ff, { omit: ["layers"] });
      var u3 = { get paint() {
        return Ov = Ov || new _({ "circle-radius": new pn(re.paint_circle["circle-radius"]), "circle-color": new pn(re.paint_circle["circle-color"]), "circle-blur": new pn(re.paint_circle["circle-blur"]), "circle-opacity": new pn(re.paint_circle["circle-opacity"]), "circle-translate": new en(re.paint_circle["circle-translate"]), "circle-translate-anchor": new en(re.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new en(re.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new en(re.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new pn(re.paint_circle["circle-stroke-width"]), "circle-stroke-color": new pn(re.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new pn(re.paint_circle["circle-stroke-opacity"]) });
      }, get layout() {
        return Rv = Rv || new _({ "circle-sort-key": new pn(re.layout_circle["circle-sort-key"]) });
      } }, ks = 1e-6, Qh = typeof Float32Array < "u" ? Float32Array : Array;
      function Zm(u) {
        return u[0] = 1, u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = 1, u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[10] = 1, u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, u;
      }
      function Fv(u, o, d) {
        var g = o[0], v = o[1], w = o[2], S = o[3], P = o[4], B = o[5], k = o[6], j = o[7], q = o[8], Z = o[9], ee = o[10], oe = o[11], pe = o[12], we = o[13], Pe = o[14], He = o[15], ke = d[0], Ge = d[1], at = d[2], bt = d[3];
        return u[0] = ke * g + Ge * P + at * q + bt * pe, u[1] = ke * v + Ge * B + at * Z + bt * we, u[2] = ke * w + Ge * k + at * ee + bt * Pe, u[3] = ke * S + Ge * j + at * oe + bt * He, u[4] = (ke = d[4]) * g + (Ge = d[5]) * P + (at = d[6]) * q + (bt = d[7]) * pe, u[5] = ke * v + Ge * B + at * Z + bt * we, u[6] = ke * w + Ge * k + at * ee + bt * Pe, u[7] = ke * S + Ge * j + at * oe + bt * He, u[8] = (ke = d[8]) * g + (Ge = d[9]) * P + (at = d[10]) * q + (bt = d[11]) * pe, u[9] = ke * v + Ge * B + at * Z + bt * we, u[10] = ke * w + Ge * k + at * ee + bt * Pe, u[11] = ke * S + Ge * j + at * oe + bt * He, u[12] = (ke = d[12]) * g + (Ge = d[13]) * P + (at = d[14]) * q + (bt = d[15]) * pe, u[13] = ke * v + Ge * B + at * Z + bt * we, u[14] = ke * w + Ge * k + at * ee + bt * Pe, u[15] = ke * S + Ge * j + at * oe + bt * He, u;
      }
      Math.hypot || (Math.hypot = function() {
        for (var u = 0, o = arguments.length; o--; )
          u += arguments[o] * arguments[o];
        return Math.sqrt(u);
      });
      var mf, h3 = Fv;
      function Hp(u, o, d) {
        var g = o[0], v = o[1], w = o[2], S = o[3];
        return u[0] = d[0] * g + d[4] * v + d[8] * w + d[12] * S, u[1] = d[1] * g + d[5] * v + d[9] * w + d[13] * S, u[2] = d[2] * g + d[6] * v + d[10] * w + d[14] * S, u[3] = d[3] * g + d[7] * v + d[11] * w + d[15] * S, u;
      }
      mf = new Qh(4), Qh != Float32Array && (mf[0] = 0, mf[1] = 0, mf[2] = 0, mf[3] = 0);
      class d3 extends p {
        constructor(o) {
          super(o, u3);
        }
        createBucket(o) {
          return new ff(o);
        }
        queryRadius(o) {
          const d = o;
          return gh("circle-radius", this, d) + gh("circle-stroke-width", this, d) + wu(this.paint.get("circle-translate"));
        }
        queryIntersectsFeature(o, d, g, v, w, S, P, B) {
          const k = Au(o, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), S.angle, P), j = this.paint.get("circle-radius").evaluate(d, g) + this.paint.get("circle-stroke-width").evaluate(d, g), q = this.paint.get("circle-pitch-alignment") === "map", Z = q ? k : function(oe, pe) {
            return oe.map((we) => Dv(we, pe));
          }(k, B), ee = q ? j * P : j;
          for (const oe of v)
            for (const pe of oe) {
              const we = q ? pe : Dv(pe, B);
              let Pe = ee;
              const He = Hp([], [pe.x, pe.y, 0, 1], B);
              if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? Pe *= He[3] / S.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (Pe *= S.cameraToCenterDistance / He[3]), $m(Z, we, Pe))
                return !0;
            }
          return !1;
        }
      }
      function Dv(u, o) {
        const d = Hp([], [u.x, u.y, 0, 1], o);
        return new T(d[0] / d[3], d[1] / d[3]);
      }
      class kv extends ff {
      }
      let Nv;
      zt("HeatmapBucket", kv, { omit: ["layers"] });
      var f3 = { get paint() {
        return Nv = Nv || new _({ "heatmap-radius": new pn(re.paint_heatmap["heatmap-radius"]), "heatmap-weight": new pn(re.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new en(re.paint_heatmap["heatmap-intensity"]), "heatmap-color": new f(re.paint_heatmap["heatmap-color"]), "heatmap-opacity": new en(re.paint_heatmap["heatmap-opacity"]) });
      } };
      function Ym(u, o, d, g) {
        let { width: v, height: w } = o;
        if (g) {
          if (g instanceof Uint8ClampedArray)
            g = new Uint8Array(g.buffer);
          else if (g.length !== v * w * d)
            throw new RangeError(`mismatched image size. expected: ${g.length} but got: ${v * w * d}`);
        } else
          g = new Uint8Array(v * w * d);
        return u.width = v, u.height = w, u.data = g, u;
      }
      function zv(u, o, d) {
        let { width: g, height: v } = o;
        if (g === u.width && v === u.height)
          return;
        const w = Ym({}, { width: g, height: v }, d);
        Km(u, w, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(u.width, g), height: Math.min(u.height, v) }, d), u.width = g, u.height = v, u.data = w.data;
      }
      function Km(u, o, d, g, v, w) {
        if (v.width === 0 || v.height === 0)
          return o;
        if (v.width > u.width || v.height > u.height || d.x > u.width - v.width || d.y > u.height - v.height)
          throw new RangeError("out of range source coordinates for image copy");
        if (v.width > o.width || v.height > o.height || g.x > o.width - v.width || g.y > o.height - v.height)
          throw new RangeError("out of range destination coordinates for image copy");
        const S = u.data, P = o.data;
        if (S === P)
          throw new Error("srcData equals dstData, so image is already copied");
        for (let B = 0; B < v.height; B++) {
          const k = ((d.y + B) * u.width + d.x) * w, j = ((g.y + B) * o.width + g.x) * w;
          for (let q = 0; q < v.width * w; q++)
            P[j + q] = S[k + q];
        }
        return o;
      }
      class _f {
        constructor(o, d) {
          Ym(this, o, 1, d);
        }
        resize(o) {
          zv(this, o, 1);
        }
        clone() {
          return new _f({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(o, d, g, v, w) {
          Km(o, d, g, v, w, 1);
        }
      }
      class ta {
        constructor(o, d) {
          Ym(this, o, 4, d);
        }
        resize(o) {
          zv(this, o, 4);
        }
        replace(o, d) {
          d ? this.data.set(o) : this.data = o instanceof Uint8ClampedArray ? new Uint8Array(o.buffer) : o;
        }
        clone() {
          return new ta({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(o, d, g, v, w) {
          Km(o, d, g, v, w, 4);
        }
      }
      function Uv(u) {
        const o = {}, d = u.resolution || 256, g = u.clips ? u.clips.length : 1, v = u.image || new ta({ width: d, height: g });
        if (Math.log(d) / Math.LN2 % 1 != 0)
          throw new Error(`width is not a power of 2 - ${d}`);
        const w = (S, P, B) => {
          o[u.evaluationKey] = B;
          const k = u.expression.evaluate(o);
          v.data[S + P + 0] = Math.floor(255 * k.r / k.a), v.data[S + P + 1] = Math.floor(255 * k.g / k.a), v.data[S + P + 2] = Math.floor(255 * k.b / k.a), v.data[S + P + 3] = Math.floor(255 * k.a);
        };
        if (u.clips)
          for (let S = 0, P = 0; S < g; ++S, P += 4 * d)
            for (let B = 0, k = 0; B < d; B++, k += 4) {
              const j = B / (d - 1), { start: q, end: Z } = u.clips[S];
              w(P, k, q * (1 - j) + Z * j);
            }
        else
          for (let S = 0, P = 0; S < d; S++, P += 4)
            w(0, P, S / (d - 1));
        return v;
      }
      zt("AlphaImage", _f), zt("RGBAImage", ta);
      class p3 extends p {
        createBucket(o) {
          return new kv(o);
        }
        constructor(o) {
          super(o, f3), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(o) {
          o === "heatmap-color" && this._updateColorRamp();
        }
        _updateColorRamp() {
          this.colorRamp = Uv({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }
        resize() {
          this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return !1;
        }
        hasOffscreenPass() {
          return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
        }
      }
      let jv;
      var g3 = { get paint() {
        return jv = jv || new _({ "hillshade-illumination-direction": new en(re.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new en(re.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new en(re.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new en(re.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new en(re.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new en(re.paint_hillshade["hillshade-accent-color"]) });
      } };
      class m3 extends p {
        constructor(o) {
          super(o, g3);
        }
        hasOffscreenPass() {
          return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
        }
      }
      const _3 = M([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: y3 } = _3;
      var Qm = { exports: {} };
      function Wp(u, o, d) {
        d = d || 2;
        var g, v, w, S, P, B, k, j = o && o.length, q = j ? o[0] * d : u.length, Z = Gv(u, 0, q, d, !0), ee = [];
        if (!Z || Z.next === Z.prev)
          return ee;
        if (j && (Z = function(pe, we, Pe, He) {
          var ke, Ge, at, bt = [];
          for (ke = 0, Ge = we.length; ke < Ge; ke++)
            (at = Gv(pe, we[ke] * He, ke < Ge - 1 ? we[ke + 1] * He : pe.length, He, !1)) === at.next && (at.steiner = !0), bt.push(T3(at));
          for (bt.sort(A3), ke = 0; ke < bt.length; ke++)
            Pe = E3(bt[ke], Pe);
          return Pe;
        }(u, o, Z, d)), u.length > 80 * d) {
          g = w = u[0], v = S = u[1];
          for (var oe = d; oe < q; oe += d)
            (P = u[oe]) < g && (g = P), (B = u[oe + 1]) < v && (v = B), P > w && (w = P), B > S && (S = B);
          k = (k = Math.max(w - g, S - v)) !== 0 ? 32767 / k : 0;
        }
        return yf(Z, ee, d, g, v, k, 0), ee;
      }
      function Gv(u, o, d, g, v) {
        var w, S;
        if (v === n0(u, o, d, g) > 0)
          for (w = o; w < d; w += g)
            S = Hv(w, u[w], u[w + 1], S);
        else
          for (w = d - g; w >= o; w -= g)
            S = Hv(w, u[w], u[w + 1], S);
        return S && Xp(S, S.next) && (bf(S), S = S.next), S;
      }
      function mh(u, o) {
        if (!u)
          return u;
        o || (o = u);
        var d, g = u;
        do
          if (d = !1, g.steiner || !Xp(g, g.next) && _r(g.prev, g, g.next) !== 0)
            g = g.next;
          else {
            if (bf(g), (g = o = g.prev) === g.next)
              break;
            d = !0;
          }
        while (d || g !== o);
        return o;
      }
      function yf(u, o, d, g, v, w, S) {
        if (u) {
          !S && w && function(j, q, Z, ee) {
            var oe = j;
            do
              oe.z === 0 && (oe.z = e0(oe.x, oe.y, q, Z, ee)), oe.prevZ = oe.prev, oe.nextZ = oe.next, oe = oe.next;
            while (oe !== j);
            oe.prevZ.nextZ = null, oe.prevZ = null, function(pe) {
              var we, Pe, He, ke, Ge, at, bt, Ut, ln = 1;
              do {
                for (Pe = pe, pe = null, Ge = null, at = 0; Pe; ) {
                  for (at++, He = Pe, bt = 0, we = 0; we < ln && (bt++, He = He.nextZ); we++)
                    ;
                  for (Ut = ln; bt > 0 || Ut > 0 && He; )
                    bt !== 0 && (Ut === 0 || !He || Pe.z <= He.z) ? (ke = Pe, Pe = Pe.nextZ, bt--) : (ke = He, He = He.nextZ, Ut--), Ge ? Ge.nextZ = ke : pe = ke, ke.prevZ = Ge, Ge = ke;
                  Pe = He;
                }
                Ge.nextZ = null, ln *= 2;
              } while (at > 1);
            }(oe);
          }(u, g, v, w);
          for (var P, B, k = u; u.prev !== u.next; )
            if (P = u.prev, B = u.next, w ? b3(u, g, v, w) : v3(u))
              o.push(P.i / d | 0), o.push(u.i / d | 0), o.push(B.i / d | 0), bf(u), u = B.next, k = B.next;
            else if ((u = B) === k) {
              S ? S === 1 ? yf(u = x3(mh(u), o, d), o, d, g, v, w, 2) : S === 2 && w3(u, o, d, g, v, w) : yf(mh(u), o, d, g, v, w, 1);
              break;
            }
        }
      }
      function v3(u) {
        var o = u.prev, d = u, g = u.next;
        if (_r(o, d, g) >= 0)
          return !1;
        for (var v = o.x, w = d.x, S = g.x, P = o.y, B = d.y, k = g.y, j = v < w ? v < S ? v : S : w < S ? w : S, q = P < B ? P < k ? P : k : B < k ? B : k, Z = v > w ? v > S ? v : S : w > S ? w : S, ee = P > B ? P > k ? P : k : B > k ? B : k, oe = g.next; oe !== o; ) {
          if (oe.x >= j && oe.x <= Z && oe.y >= q && oe.y <= ee && ed(v, P, w, B, S, k, oe.x, oe.y) && _r(oe.prev, oe, oe.next) >= 0)
            return !1;
          oe = oe.next;
        }
        return !0;
      }
      function b3(u, o, d, g) {
        var v = u.prev, w = u, S = u.next;
        if (_r(v, w, S) >= 0)
          return !1;
        for (var P = v.x, B = w.x, k = S.x, j = v.y, q = w.y, Z = S.y, ee = P < B ? P < k ? P : k : B < k ? B : k, oe = j < q ? j < Z ? j : Z : q < Z ? q : Z, pe = P > B ? P > k ? P : k : B > k ? B : k, we = j > q ? j > Z ? j : Z : q > Z ? q : Z, Pe = e0(ee, oe, o, d, g), He = e0(pe, we, o, d, g), ke = u.prevZ, Ge = u.nextZ; ke && ke.z >= Pe && Ge && Ge.z <= He; ) {
          if (ke.x >= ee && ke.x <= pe && ke.y >= oe && ke.y <= we && ke !== v && ke !== S && ed(P, j, B, q, k, Z, ke.x, ke.y) && _r(ke.prev, ke, ke.next) >= 0 || (ke = ke.prevZ, Ge.x >= ee && Ge.x <= pe && Ge.y >= oe && Ge.y <= we && Ge !== v && Ge !== S && ed(P, j, B, q, k, Z, Ge.x, Ge.y) && _r(Ge.prev, Ge, Ge.next) >= 0))
            return !1;
          Ge = Ge.nextZ;
        }
        for (; ke && ke.z >= Pe; ) {
          if (ke.x >= ee && ke.x <= pe && ke.y >= oe && ke.y <= we && ke !== v && ke !== S && ed(P, j, B, q, k, Z, ke.x, ke.y) && _r(ke.prev, ke, ke.next) >= 0)
            return !1;
          ke = ke.prevZ;
        }
        for (; Ge && Ge.z <= He; ) {
          if (Ge.x >= ee && Ge.x <= pe && Ge.y >= oe && Ge.y <= we && Ge !== v && Ge !== S && ed(P, j, B, q, k, Z, Ge.x, Ge.y) && _r(Ge.prev, Ge, Ge.next) >= 0)
            return !1;
          Ge = Ge.nextZ;
        }
        return !0;
      }
      function x3(u, o, d) {
        var g = u;
        do {
          var v = g.prev, w = g.next.next;
          !Xp(v, w) && Vv(v, g, g.next, w) && vf(v, w) && vf(w, v) && (o.push(v.i / d | 0), o.push(g.i / d | 0), o.push(w.i / d | 0), bf(g), bf(g.next), g = u = w), g = g.next;
        } while (g !== u);
        return mh(g);
      }
      function w3(u, o, d, g, v, w) {
        var S = u;
        do {
          for (var P = S.next.next; P !== S.prev; ) {
            if (S.i !== P.i && C3(S, P)) {
              var B = qv(S, P);
              return S = mh(S, S.next), B = mh(B, B.next), yf(S, o, d, g, v, w, 0), void yf(B, o, d, g, v, w, 0);
            }
            P = P.next;
          }
          S = S.next;
        } while (S !== u);
      }
      function A3(u, o) {
        return u.x - o.x;
      }
      function E3(u, o) {
        var d = function(v, w) {
          var S, P = w, B = v.x, k = v.y, j = -1 / 0;
          do {
            if (k <= P.y && k >= P.next.y && P.next.y !== P.y) {
              var q = P.x + (k - P.y) * (P.next.x - P.x) / (P.next.y - P.y);
              if (q <= B && q > j && (j = q, S = P.x < P.next.x ? P : P.next, q === B))
                return S;
            }
            P = P.next;
          } while (P !== w);
          if (!S)
            return null;
          var Z, ee = S, oe = S.x, pe = S.y, we = 1 / 0;
          P = S;
          do
            B >= P.x && P.x >= oe && B !== P.x && ed(k < pe ? B : j, k, oe, pe, k < pe ? j : B, k, P.x, P.y) && (Z = Math.abs(k - P.y) / (B - P.x), vf(P, v) && (Z < we || Z === we && (P.x > S.x || P.x === S.x && S3(S, P))) && (S = P, we = Z)), P = P.next;
          while (P !== ee);
          return S;
        }(u, o);
        if (!d)
          return o;
        var g = qv(d, u);
        return mh(g, g.next), mh(d, d.next);
      }
      function S3(u, o) {
        return _r(u.prev, u, o.prev) < 0 && _r(o.next, u, u.next) < 0;
      }
      function e0(u, o, d, g, v) {
        return (u = 1431655765 & ((u = 858993459 & ((u = 252645135 & ((u = 16711935 & ((u = (u - d) * v | 0) | u << 8)) | u << 4)) | u << 2)) | u << 1)) | (o = 1431655765 & ((o = 858993459 & ((o = 252645135 & ((o = 16711935 & ((o = (o - g) * v | 0) | o << 8)) | o << 4)) | o << 2)) | o << 1)) << 1;
      }
      function T3(u) {
        var o = u, d = u;
        do
          (o.x < d.x || o.x === d.x && o.y < d.y) && (d = o), o = o.next;
        while (o !== u);
        return d;
      }
      function ed(u, o, d, g, v, w, S, P) {
        return (v - S) * (o - P) >= (u - S) * (w - P) && (u - S) * (g - P) >= (d - S) * (o - P) && (d - S) * (w - P) >= (v - S) * (g - P);
      }
      function C3(u, o) {
        return u.next.i !== o.i && u.prev.i !== o.i && !function(d, g) {
          var v = d;
          do {
            if (v.i !== d.i && v.next.i !== d.i && v.i !== g.i && v.next.i !== g.i && Vv(v, v.next, d, g))
              return !0;
            v = v.next;
          } while (v !== d);
          return !1;
        }(u, o) && (vf(u, o) && vf(o, u) && function(d, g) {
          var v = d, w = !1, S = (d.x + g.x) / 2, P = (d.y + g.y) / 2;
          do
            v.y > P != v.next.y > P && v.next.y !== v.y && S < (v.next.x - v.x) * (P - v.y) / (v.next.y - v.y) + v.x && (w = !w), v = v.next;
          while (v !== d);
          return w;
        }(u, o) && (_r(u.prev, u, o.prev) || _r(u, o.prev, o)) || Xp(u, o) && _r(u.prev, u, u.next) > 0 && _r(o.prev, o, o.next) > 0);
      }
      function _r(u, o, d) {
        return (o.y - u.y) * (d.x - o.x) - (o.x - u.x) * (d.y - o.y);
      }
      function Xp(u, o) {
        return u.x === o.x && u.y === o.y;
      }
      function Vv(u, o, d, g) {
        var v = $p(_r(u, o, d)), w = $p(_r(u, o, g)), S = $p(_r(d, g, u)), P = $p(_r(d, g, o));
        return v !== w && S !== P || !(v !== 0 || !Jp(u, d, o)) || !(w !== 0 || !Jp(u, g, o)) || !(S !== 0 || !Jp(d, u, g)) || !(P !== 0 || !Jp(d, o, g));
      }
      function Jp(u, o, d) {
        return o.x <= Math.max(u.x, d.x) && o.x >= Math.min(u.x, d.x) && o.y <= Math.max(u.y, d.y) && o.y >= Math.min(u.y, d.y);
      }
      function $p(u) {
        return u > 0 ? 1 : u < 0 ? -1 : 0;
      }
      function vf(u, o) {
        return _r(u.prev, u, u.next) < 0 ? _r(u, o, u.next) >= 0 && _r(u, u.prev, o) >= 0 : _r(u, o, u.prev) < 0 || _r(u, u.next, o) < 0;
      }
      function qv(u, o) {
        var d = new t0(u.i, u.x, u.y), g = new t0(o.i, o.x, o.y), v = u.next, w = o.prev;
        return u.next = o, o.prev = u, d.next = v, v.prev = d, g.next = d, d.prev = g, w.next = g, g.prev = w, g;
      }
      function Hv(u, o, d, g) {
        var v = new t0(u, o, d);
        return g ? (v.next = g.next, v.prev = g, g.next.prev = v, g.next = v) : (v.prev = v, v.next = v), v;
      }
      function bf(u) {
        u.next.prev = u.prev, u.prev.next = u.next, u.prevZ && (u.prevZ.nextZ = u.nextZ), u.nextZ && (u.nextZ.prevZ = u.prevZ);
      }
      function t0(u, o, d) {
        this.i = u, this.x = o, this.y = d, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
      }
      function n0(u, o, d, g) {
        for (var v = 0, w = o, S = d - g; w < d; w += g)
          v += (u[S] - u[w]) * (u[w + 1] + u[S + 1]), S = w;
        return v;
      }
      Qm.exports = Wp, Qm.exports.default = Wp, Wp.deviation = function(u, o, d, g) {
        var v = o && o.length, w = Math.abs(n0(u, 0, v ? o[0] * d : u.length, d));
        if (v)
          for (var S = 0, P = o.length; S < P; S++)
            w -= Math.abs(n0(u, o[S] * d, S < P - 1 ? o[S + 1] * d : u.length, d));
        var B = 0;
        for (S = 0; S < g.length; S += 3) {
          var k = g[S] * d, j = g[S + 1] * d, q = g[S + 2] * d;
          B += Math.abs((u[k] - u[q]) * (u[j + 1] - u[k + 1]) - (u[k] - u[j]) * (u[q + 1] - u[k + 1]));
        }
        return w === 0 && B === 0 ? 0 : Math.abs((B - w) / w);
      }, Wp.flatten = function(u) {
        for (var o = u[0][0].length, d = { vertices: [], holes: [], dimensions: o }, g = 0, v = 0; v < u.length; v++) {
          for (var w = 0; w < u[v].length; w++)
            for (var S = 0; S < o; S++)
              d.vertices.push(u[v][w][S]);
          v > 0 && d.holes.push(g += u[v - 1].length);
        }
        return d;
      };
      var Wv = m(Qm.exports);
      function i0(u, o, d) {
        const g = d.patternDependencies;
        let v = !1;
        for (const w of o) {
          const S = w.paint.get(`${u}-pattern`);
          S.isConstant() || (v = !0);
          const P = S.constantOr(null);
          P && (v = !0, g[P.to] = !0, g[P.from] = !0);
        }
        return v;
      }
      function r0(u, o, d, g, v) {
        const w = v.patternDependencies;
        for (const S of o) {
          const P = S.paint.get(`${u}-pattern`).value;
          if (P.kind !== "constant") {
            let B = P.evaluate({ zoom: g - 1 }, d, {}, v.availableImages), k = P.evaluate({ zoom: g }, d, {}, v.availableImages), j = P.evaluate({ zoom: g + 1 }, d, {}, v.availableImages);
            B = B && B.name ? B.name : B, k = k && k.name ? k.name : k, j = j && j.name ? j.name : j, w[B] = !0, w[k] = !0, w[j] = !0, d.patterns[S.id] = { min: B, mid: k, max: j };
          }
        }
        return d;
      }
      class s0 {
        constructor(o) {
          this.zoom = o.zoom, this.overscaling = o.overscaling, this.layers = o.layers, this.layerIds = this.layers.map((d) => d.id), this.index = o.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new Yi(), this.indexArray = new nr(), this.indexArray2 = new Ei(), this.programConfigurations = new fl(o.layers, o.zoom), this.segments = new Vi(), this.segments2 = new Vi(), this.stateDependentLayerIds = this.layers.filter((d) => d.isStateDependent()).map((d) => d.id);
        }
        populate(o, d, g) {
          this.hasPattern = i0("fill", this.layers, d);
          const v = this.layers[0].layout.get("fill-sort-key"), w = !v.isConstant(), S = [];
          for (const { feature: P, id: B, index: k, sourceLayerIndex: j } of o) {
            const q = this.layers[0]._featureFilter.needGeometry, Z = Nc(P, q);
            if (!this.layers[0]._featureFilter.filter(new pi(this.zoom), Z, g))
              continue;
            const ee = w ? v.evaluate(Z, {}, g, d.availableImages) : void 0, oe = { id: B, properties: P.properties, type: P.type, sourceLayerIndex: j, index: k, geometry: q ? Z.geometry : Po(P), patterns: {}, sortKey: ee };
            S.push(oe);
          }
          w && S.sort((P, B) => P.sortKey - B.sortKey);
          for (const P of S) {
            const { geometry: B, index: k, sourceLayerIndex: j } = P;
            if (this.hasPattern) {
              const q = r0("fill", this.layers, P, this.zoom, d);
              this.patternFeatures.push(q);
            } else
              this.addFeature(P, B, k, g, {});
            d.featureIndex.insert(o[k].feature, B, k, j, this.index);
          }
        }
        update(o, d, g) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(o, d, this.stateDependentLayers, g);
        }
        addFeatures(o, d, g) {
          for (const v of this.patternFeatures)
            this.addFeature(v, v.geometry, v.index, d, g);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(o) {
          this.uploaded || (this.layoutVertexBuffer = o.createVertexBuffer(this.layoutVertexArray, y3), this.indexBuffer = o.createIndexBuffer(this.indexArray), this.indexBuffer2 = o.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(o), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }
        addFeature(o, d, g, v, w) {
          for (const S of va(d, 500)) {
            let P = 0;
            for (const ee of S)
              P += ee.length;
            const B = this.segments.prepareSegment(P, this.layoutVertexArray, this.indexArray), k = B.vertexLength, j = [], q = [];
            for (const ee of S) {
              if (ee.length === 0)
                continue;
              ee !== S[0] && q.push(j.length / 2);
              const oe = this.segments2.prepareSegment(ee.length, this.layoutVertexArray, this.indexArray2), pe = oe.vertexLength;
              this.layoutVertexArray.emplaceBack(ee[0].x, ee[0].y), this.indexArray2.emplaceBack(pe + ee.length - 1, pe), j.push(ee[0].x), j.push(ee[0].y);
              for (let we = 1; we < ee.length; we++)
                this.layoutVertexArray.emplaceBack(ee[we].x, ee[we].y), this.indexArray2.emplaceBack(pe + we - 1, pe + we), j.push(ee[we].x), j.push(ee[we].y);
              oe.vertexLength += ee.length, oe.primitiveLength += ee.length;
            }
            const Z = Wv(j, q);
            for (let ee = 0; ee < Z.length; ee += 3)
              this.indexArray.emplaceBack(k + Z[ee], k + Z[ee + 1], k + Z[ee + 2]);
            B.vertexLength += P, B.primitiveLength += Z.length / 3;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, o, g, w, v);
        }
      }
      let Xv, Jv;
      zt("FillBucket", s0, { omit: ["layers", "patternFeatures"] });
      var I3 = { get paint() {
        return Jv = Jv || new _({ "fill-antialias": new en(re.paint_fill["fill-antialias"]), "fill-opacity": new pn(re.paint_fill["fill-opacity"]), "fill-color": new pn(re.paint_fill["fill-color"]), "fill-outline-color": new pn(re.paint_fill["fill-outline-color"]), "fill-translate": new en(re.paint_fill["fill-translate"]), "fill-translate-anchor": new en(re.paint_fill["fill-translate-anchor"]), "fill-pattern": new E(re.paint_fill["fill-pattern"]) });
      }, get layout() {
        return Xv = Xv || new _({ "fill-sort-key": new pn(re.layout_fill["fill-sort-key"]) });
      } };
      class P3 extends p {
        constructor(o) {
          super(o, I3);
        }
        recalculate(o, d) {
          super.recalculate(o, d);
          const g = this.paint._values["fill-outline-color"];
          g.value.kind === "constant" && g.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }
        createBucket(o) {
          return new s0(o);
        }
        queryRadius() {
          return wu(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature(o, d, g, v, w, S, P) {
          return bu(Au(o, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), S.angle, P), v);
        }
        isTileClipped() {
          return !0;
        }
      }
      const L3 = M([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), M3 = M([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: B3 } = L3;
      var Eu = {}, R3 = y, $v = td;
      function td(u, o, d, g, v) {
        this.properties = {}, this.extent = d, this.type = 0, this._pbf = u, this._geometry = -1, this._keys = g, this._values = v, u.readFields(O3, this, o);
      }
      function O3(u, o, d) {
        u == 1 ? o.id = d.readVarint() : u == 2 ? function(g, v) {
          for (var w = g.readVarint() + g.pos; g.pos < w; ) {
            var S = v._keys[g.readVarint()], P = v._values[g.readVarint()];
            v.properties[S] = P;
          }
        }(d, o) : u == 3 ? o.type = d.readVarint() : u == 4 && (o._geometry = d.pos);
      }
      function F3(u) {
        for (var o, d, g = 0, v = 0, w = u.length, S = w - 1; v < w; S = v++)
          g += ((d = u[S]).x - (o = u[v]).x) * (o.y + d.y);
        return g;
      }
      td.types = ["Unknown", "Point", "LineString", "Polygon"], td.prototype.loadGeometry = function() {
        var u = this._pbf;
        u.pos = this._geometry;
        for (var o, d = u.readVarint() + u.pos, g = 1, v = 0, w = 0, S = 0, P = []; u.pos < d; ) {
          if (v <= 0) {
            var B = u.readVarint();
            g = 7 & B, v = B >> 3;
          }
          if (v--, g === 1 || g === 2)
            w += u.readSVarint(), S += u.readSVarint(), g === 1 && (o && P.push(o), o = []), o.push(new R3(w, S));
          else {
            if (g !== 7)
              throw new Error("unknown command " + g);
            o && o.push(o[0].clone());
          }
        }
        return o && P.push(o), P;
      }, td.prototype.bbox = function() {
        var u = this._pbf;
        u.pos = this._geometry;
        for (var o = u.readVarint() + u.pos, d = 1, g = 0, v = 0, w = 0, S = 1 / 0, P = -1 / 0, B = 1 / 0, k = -1 / 0; u.pos < o; ) {
          if (g <= 0) {
            var j = u.readVarint();
            d = 7 & j, g = j >> 3;
          }
          if (g--, d === 1 || d === 2)
            (v += u.readSVarint()) < S && (S = v), v > P && (P = v), (w += u.readSVarint()) < B && (B = w), w > k && (k = w);
          else if (d !== 7)
            throw new Error("unknown command " + d);
        }
        return [S, B, P, k];
      }, td.prototype.toGeoJSON = function(u, o, d) {
        var g, v, w = this.extent * Math.pow(2, d), S = this.extent * u, P = this.extent * o, B = this.loadGeometry(), k = td.types[this.type];
        function j(ee) {
          for (var oe = 0; oe < ee.length; oe++) {
            var pe = ee[oe];
            ee[oe] = [360 * (pe.x + S) / w - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (pe.y + P) / w) * Math.PI / 180)) - 90];
          }
        }
        switch (this.type) {
          case 1:
            var q = [];
            for (g = 0; g < B.length; g++)
              q[g] = B[g][0];
            j(B = q);
            break;
          case 2:
            for (g = 0; g < B.length; g++)
              j(B[g]);
            break;
          case 3:
            for (B = function(ee) {
              var oe = ee.length;
              if (oe <= 1)
                return [ee];
              for (var pe, we, Pe = [], He = 0; He < oe; He++) {
                var ke = F3(ee[He]);
                ke !== 0 && (we === void 0 && (we = ke < 0), we === ke < 0 ? (pe && Pe.push(pe), pe = [ee[He]]) : pe.push(ee[He]));
              }
              return pe && Pe.push(pe), Pe;
            }(B), g = 0; g < B.length; g++)
              for (v = 0; v < B[g].length; v++)
                j(B[g][v]);
        }
        B.length === 1 ? B = B[0] : k = "Multi" + k;
        var Z = { type: "Feature", geometry: { type: k, coordinates: B }, properties: this.properties };
        return "id" in this && (Z.id = this.id), Z;
      };
      var D3 = $v, Zv = Yv;
      function Yv(u, o) {
        this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = u, this._keys = [], this._values = [], this._features = [], u.readFields(k3, this, o), this.length = this._features.length;
      }
      function k3(u, o, d) {
        u === 15 ? o.version = d.readVarint() : u === 1 ? o.name = d.readString() : u === 5 ? o.extent = d.readVarint() : u === 2 ? o._features.push(d.pos) : u === 3 ? o._keys.push(d.readString()) : u === 4 && o._values.push(function(g) {
          for (var v = null, w = g.readVarint() + g.pos; g.pos < w; ) {
            var S = g.readVarint() >> 3;
            v = S === 1 ? g.readString() : S === 2 ? g.readFloat() : S === 3 ? g.readDouble() : S === 4 ? g.readVarint64() : S === 5 ? g.readVarint() : S === 6 ? g.readSVarint() : S === 7 ? g.readBoolean() : null;
          }
          return v;
        }(d));
      }
      Yv.prototype.feature = function(u) {
        if (u < 0 || u >= this._features.length)
          throw new Error("feature index out of bounds");
        this._pbf.pos = this._features[u];
        var o = this._pbf.readVarint() + this._pbf.pos;
        return new D3(this._pbf, o, this.extent, this._keys, this._values);
      };
      var N3 = Zv;
      function z3(u, o, d) {
        if (u === 3) {
          var g = new N3(d, d.readVarint() + d.pos);
          g.length && (o[g.name] = g);
        }
      }
      Eu.VectorTile = function(u, o) {
        this.layers = u.readFields(z3, {}, o);
      }, Eu.VectorTileFeature = $v, Eu.VectorTileLayer = Zv;
      const U3 = Eu.VectorTileFeature.types, o0 = Math.pow(2, 13);
      function xf(u, o, d, g, v, w, S, P) {
        u.emplaceBack(o, d, 2 * Math.floor(g * o0) + S, v * o0 * 2, w * o0 * 2, Math.round(P));
      }
      class a0 {
        constructor(o) {
          this.zoom = o.zoom, this.overscaling = o.overscaling, this.layers = o.layers, this.layerIds = this.layers.map((d) => d.id), this.index = o.index, this.hasPattern = !1, this.layoutVertexArray = new ts(), this.centroidVertexArray = new Ar(), this.indexArray = new nr(), this.programConfigurations = new fl(o.layers, o.zoom), this.segments = new Vi(), this.stateDependentLayerIds = this.layers.filter((d) => d.isStateDependent()).map((d) => d.id);
        }
        populate(o, d, g) {
          this.features = [], this.hasPattern = i0("fill-extrusion", this.layers, d);
          for (const { feature: v, id: w, index: S, sourceLayerIndex: P } of o) {
            const B = this.layers[0]._featureFilter.needGeometry, k = Nc(v, B);
            if (!this.layers[0]._featureFilter.filter(new pi(this.zoom), k, g))
              continue;
            const j = { id: w, sourceLayerIndex: P, index: S, geometry: B ? k.geometry : Po(v), properties: v.properties, type: v.type, patterns: {} };
            this.hasPattern ? this.features.push(r0("fill-extrusion", this.layers, j, this.zoom, d)) : this.addFeature(j, j.geometry, S, g, {}), d.featureIndex.insert(v, j.geometry, S, P, this.index, !0);
          }
        }
        addFeatures(o, d, g) {
          for (const v of this.features) {
            const { geometry: w } = v;
            this.addFeature(v, w, v.index, d, g);
          }
        }
        update(o, d, g) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(o, d, this.stateDependentLayers, g);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(o) {
          this.uploaded || (this.layoutVertexBuffer = o.createVertexBuffer(this.layoutVertexArray, B3), this.centroidVertexBuffer = o.createVertexBuffer(this.centroidVertexArray, M3.members, !0), this.indexBuffer = o.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(o), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
        }
        addFeature(o, d, g, v, w) {
          for (const S of va(d, 500)) {
            const P = { x: 0, y: 0, vertexCount: 0 };
            let B = 0;
            for (const oe of S)
              B += oe.length;
            let k = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
            for (const oe of S) {
              if (oe.length === 0 || G3(oe))
                continue;
              let pe = 0;
              for (let we = 0; we < oe.length; we++) {
                const Pe = oe[we];
                if (we >= 1) {
                  const He = oe[we - 1];
                  if (!j3(Pe, He)) {
                    k.vertexLength + 4 > Vi.MAX_VERTEX_ARRAY_LENGTH && (k = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                    const ke = Pe.sub(He)._perp()._unit(), Ge = He.dist(Pe);
                    pe + Ge > 32768 && (pe = 0), xf(this.layoutVertexArray, Pe.x, Pe.y, ke.x, ke.y, 0, 0, pe), xf(this.layoutVertexArray, Pe.x, Pe.y, ke.x, ke.y, 0, 1, pe), P.x += 2 * Pe.x, P.y += 2 * Pe.y, P.vertexCount += 2, pe += Ge, xf(this.layoutVertexArray, He.x, He.y, ke.x, ke.y, 0, 0, pe), xf(this.layoutVertexArray, He.x, He.y, ke.x, ke.y, 0, 1, pe), P.x += 2 * He.x, P.y += 2 * He.y, P.vertexCount += 2;
                    const at = k.vertexLength;
                    this.indexArray.emplaceBack(at, at + 2, at + 1), this.indexArray.emplaceBack(at + 1, at + 2, at + 3), k.vertexLength += 4, k.primitiveLength += 2;
                  }
                }
              }
            }
            if (k.vertexLength + B > Vi.MAX_VERTEX_ARRAY_LENGTH && (k = this.segments.prepareSegment(B, this.layoutVertexArray, this.indexArray)), U3[o.type] !== "Polygon")
              continue;
            const j = [], q = [], Z = k.vertexLength;
            for (const oe of S)
              if (oe.length !== 0) {
                oe !== S[0] && q.push(j.length / 2);
                for (let pe = 0; pe < oe.length; pe++) {
                  const we = oe[pe];
                  xf(this.layoutVertexArray, we.x, we.y, 0, 0, 1, 1, 0), P.x += we.x, P.y += we.y, P.vertexCount += 1, j.push(we.x), j.push(we.y);
                }
              }
            const ee = Wv(j, q);
            for (let oe = 0; oe < ee.length; oe += 3)
              this.indexArray.emplaceBack(Z + ee[oe], Z + ee[oe + 2], Z + ee[oe + 1]);
            k.primitiveLength += ee.length / 3, k.vertexLength += B;
            for (let oe = 0; oe < P.vertexCount; oe++) {
              const pe = Math.floor(P.x / P.vertexCount), we = Math.floor(P.y / P.vertexCount);
              this.centroidVertexArray.emplaceBack(pe, we);
            }
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, o, g, w, v);
        }
      }
      function j3(u, o) {
        return u.x === o.x && (u.x < 0 || u.x > ar) || u.y === o.y && (u.y < 0 || u.y > ar);
      }
      function G3(u) {
        return u.every((o) => o.x < 0) || u.every((o) => o.x > ar) || u.every((o) => o.y < 0) || u.every((o) => o.y > ar);
      }
      let Kv;
      zt("FillExtrusionBucket", a0, { omit: ["layers", "features"] });
      var V3 = { get paint() {
        return Kv = Kv || new _({ "fill-extrusion-opacity": new en(re["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new pn(re["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new en(re["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new en(re["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new E(re["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new pn(re["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new pn(re["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new en(re["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
      } };
      class q3 extends p {
        constructor(o) {
          super(o, V3);
        }
        createBucket(o) {
          return new a0(o);
        }
        queryRadius() {
          return wu(this.paint.get("fill-extrusion-translate"));
        }
        is3D() {
          return !0;
        }
        queryIntersectsFeature(o, d, g, v, w, S, P, B) {
          const k = Au(o, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), S.angle, P), j = this.paint.get("fill-extrusion-height").evaluate(d, g), q = this.paint.get("fill-extrusion-base").evaluate(d, g), Z = function(oe, pe, we, Pe) {
            const He = [];
            for (const ke of oe) {
              const Ge = [ke.x, ke.y, 0, 1];
              Hp(Ge, Ge, pe), He.push(new T(Ge[0] / Ge[3], Ge[1] / Ge[3]));
            }
            return He;
          }(k, B), ee = function(oe, pe, we, Pe) {
            const He = [], ke = [], Ge = Pe[8] * pe, at = Pe[9] * pe, bt = Pe[10] * pe, Ut = Pe[11] * pe, ln = Pe[8] * we, jt = Pe[9] * we, Dt = Pe[10] * we, rn = Pe[11] * we;
            for (const Zt of oe) {
              const Jt = [], gt = [];
              for (const sn of Zt) {
                const tn = sn.x, Cn = sn.y, Mi = Pe[0] * tn + Pe[4] * Cn + Pe[12], Ti = Pe[1] * tn + Pe[5] * Cn + Pe[13], jr = Pe[2] * tn + Pe[6] * Cn + Pe[14], ja = Pe[3] * tn + Pe[7] * Cn + Pe[15], ls = jr + bt, pr = ja + Ut, Ns = Mi + ln, zs = Ti + jt, Us = jr + Dt, gr = ja + rn, Gr = new T((Mi + Ge) / pr, (Ti + at) / pr);
                Gr.z = ls / pr, Jt.push(Gr);
                const Ss = new T(Ns / gr, zs / gr);
                Ss.z = Us / gr, gt.push(Ss);
              }
              He.push(Jt), ke.push(gt);
            }
            return [He, ke];
          }(v, q, j, B);
          return function(oe, pe, we) {
            let Pe = 1 / 0;
            bu(we, pe) && (Pe = Qv(we, pe[0]));
            for (let He = 0; He < pe.length; He++) {
              const ke = pe[He], Ge = oe[He];
              for (let at = 0; at < ke.length - 1; at++) {
                const bt = ke[at], Ut = [bt, ke[at + 1], Ge[at + 1], Ge[at], bt];
                pf(we, Ut) && (Pe = Math.min(Pe, Qv(we, Ut)));
              }
            }
            return Pe !== 1 / 0 && Pe;
          }(ee[0], ee[1], Z);
        }
      }
      function wf(u, o) {
        return u.x * o.x + u.y * o.y;
      }
      function Qv(u, o) {
        if (u.length === 1) {
          let d = 0;
          const g = o[d++];
          let v;
          for (; !v || g.equals(v); )
            if (v = o[d++], !v)
              return 1 / 0;
          for (; d < o.length; d++) {
            const w = o[d], S = u[0], P = v.sub(g), B = w.sub(g), k = S.sub(g), j = wf(P, P), q = wf(P, B), Z = wf(B, B), ee = wf(k, P), oe = wf(k, B), pe = j * Z - q * q, we = (Z * ee - q * oe) / pe, Pe = (j * oe - q * ee) / pe, He = g.z * (1 - we - Pe) + v.z * we + w.z * Pe;
            if (isFinite(He))
              return He;
          }
          return 1 / 0;
        }
        {
          let d = 1 / 0;
          for (const g of o)
            d = Math.min(d, g.z);
          return d;
        }
      }
      const H3 = M([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: W3 } = H3, X3 = M([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: J3 } = X3, $3 = Eu.VectorTileFeature.types, Z3 = Math.cos(Math.PI / 180 * 37.5), eb = Math.pow(2, 14) / 0.5;
      class l0 {
        constructor(o) {
          this.zoom = o.zoom, this.overscaling = o.overscaling, this.layers = o.layers, this.layerIds = this.layers.map((d) => d.id), this.index = o.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((d) => {
            this.gradients[d.id] = {};
          }), this.layoutVertexArray = new Co(), this.layoutVertexArray2 = new Fa(), this.indexArray = new nr(), this.programConfigurations = new fl(o.layers, o.zoom), this.segments = new Vi(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((d) => d.isStateDependent()).map((d) => d.id);
        }
        populate(o, d, g) {
          this.hasPattern = i0("line", this.layers, d);
          const v = this.layers[0].layout.get("line-sort-key"), w = !v.isConstant(), S = [];
          for (const { feature: P, id: B, index: k, sourceLayerIndex: j } of o) {
            const q = this.layers[0]._featureFilter.needGeometry, Z = Nc(P, q);
            if (!this.layers[0]._featureFilter.filter(new pi(this.zoom), Z, g))
              continue;
            const ee = w ? v.evaluate(Z, {}, g) : void 0, oe = { id: B, properties: P.properties, type: P.type, sourceLayerIndex: j, index: k, geometry: q ? Z.geometry : Po(P), patterns: {}, sortKey: ee };
            S.push(oe);
          }
          w && S.sort((P, B) => P.sortKey - B.sortKey);
          for (const P of S) {
            const { geometry: B, index: k, sourceLayerIndex: j } = P;
            if (this.hasPattern) {
              const q = r0("line", this.layers, P, this.zoom, d);
              this.patternFeatures.push(q);
            } else
              this.addFeature(P, B, k, g, {});
            d.featureIndex.insert(o[k].feature, B, k, j, this.index);
          }
        }
        update(o, d, g) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(o, d, this.stateDependentLayers, g);
        }
        addFeatures(o, d, g) {
          for (const v of this.patternFeatures)
            this.addFeature(v, v.geometry, v.index, d, g);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(o) {
          this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = o.createVertexBuffer(this.layoutVertexArray2, J3)), this.layoutVertexBuffer = o.createVertexBuffer(this.layoutVertexArray, W3), this.indexBuffer = o.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(o), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        lineFeatureClips(o) {
          if (o.properties && Object.prototype.hasOwnProperty.call(o.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(o.properties, "mapbox_clip_end"))
            return { start: +o.properties.mapbox_clip_start, end: +o.properties.mapbox_clip_end };
        }
        addFeature(o, d, g, v, w) {
          const S = this.layers[0].layout, P = S.get("line-join").evaluate(o, {}), B = S.get("line-cap"), k = S.get("line-miter-limit"), j = S.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(o);
          for (const q of d)
            this.addLine(q, o, P, B, k, j);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, o, g, w, v);
        }
        addLine(o, d, g, v, w, S) {
          if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
            this.lineClipsArray.push(this.lineClips);
            for (let Pe = 0; Pe < o.length - 1; Pe++)
              this.totalDistance += o[Pe].dist(o[Pe + 1]);
            this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
          }
          const P = $3[d.type] === "Polygon";
          let B = o.length;
          for (; B >= 2 && o[B - 1].equals(o[B - 2]); )
            B--;
          let k = 0;
          for (; k < B - 1 && o[k].equals(o[k + 1]); )
            k++;
          if (B < (P ? 3 : 2))
            return;
          g === "bevel" && (w = 1.05);
          const j = this.overscaling <= 16 ? 15 * ar / (512 * this.overscaling) : 0, q = this.segments.prepareSegment(10 * B, this.layoutVertexArray, this.indexArray);
          let Z, ee, oe, pe, we;
          this.e1 = this.e2 = -1, P && (Z = o[B - 2], we = o[k].sub(Z)._unit()._perp());
          for (let Pe = k; Pe < B; Pe++) {
            if (oe = Pe === B - 1 ? P ? o[k + 1] : void 0 : o[Pe + 1], oe && o[Pe].equals(oe))
              continue;
            we && (pe = we), Z && (ee = Z), Z = o[Pe], we = oe ? oe.sub(Z)._unit()._perp() : pe, pe = pe || we;
            let He = pe.add(we);
            He.x === 0 && He.y === 0 || He._unit();
            const ke = pe.x * we.x + pe.y * we.y, Ge = He.x * we.x + He.y * we.y, at = Ge !== 0 ? 1 / Ge : 1 / 0, bt = 2 * Math.sqrt(2 - 2 * Ge), Ut = Ge < Z3 && ee && oe, ln = pe.x * we.y - pe.y * we.x > 0;
            if (Ut && Pe > k) {
              const rn = Z.dist(ee);
              if (rn > 2 * j) {
                const Zt = Z.sub(Z.sub(ee)._mult(j / rn)._round());
                this.updateDistance(ee, Zt), this.addCurrentVertex(Zt, pe, 0, 0, q), ee = Zt;
              }
            }
            const jt = ee && oe;
            let Dt = jt ? g : P ? "butt" : v;
            if (jt && Dt === "round" && (at < S ? Dt = "miter" : at <= 2 && (Dt = "fakeround")), Dt === "miter" && at > w && (Dt = "bevel"), Dt === "bevel" && (at > 2 && (Dt = "flipbevel"), at < w && (Dt = "miter")), ee && this.updateDistance(ee, Z), Dt === "miter")
              He._mult(at), this.addCurrentVertex(Z, He, 0, 0, q);
            else if (Dt === "flipbevel") {
              if (at > 100)
                He = we.mult(-1);
              else {
                const rn = at * pe.add(we).mag() / pe.sub(we).mag();
                He._perp()._mult(rn * (ln ? -1 : 1));
              }
              this.addCurrentVertex(Z, He, 0, 0, q), this.addCurrentVertex(Z, He.mult(-1), 0, 0, q);
            } else if (Dt === "bevel" || Dt === "fakeround") {
              const rn = -Math.sqrt(at * at - 1), Zt = ln ? rn : 0, Jt = ln ? 0 : rn;
              if (ee && this.addCurrentVertex(Z, pe, Zt, Jt, q), Dt === "fakeround") {
                const gt = Math.round(180 * bt / Math.PI / 20);
                for (let sn = 1; sn < gt; sn++) {
                  let tn = sn / gt;
                  if (tn !== 0.5) {
                    const Mi = tn - 0.5;
                    tn += tn * Mi * (tn - 1) * ((1.0904 + ke * (ke * (3.55645 - 1.43519 * ke) - 3.2452)) * Mi * Mi + (0.848013 + ke * (0.215638 * ke - 1.06021)));
                  }
                  const Cn = we.sub(pe)._mult(tn)._add(pe)._unit()._mult(ln ? -1 : 1);
                  this.addHalfVertex(Z, Cn.x, Cn.y, !1, ln, 0, q);
                }
              }
              oe && this.addCurrentVertex(Z, we, -Zt, -Jt, q);
            } else if (Dt === "butt")
              this.addCurrentVertex(Z, He, 0, 0, q);
            else if (Dt === "square") {
              const rn = ee ? 1 : -1;
              this.addCurrentVertex(Z, He, rn, rn, q);
            } else
              Dt === "round" && (ee && (this.addCurrentVertex(Z, pe, 0, 0, q), this.addCurrentVertex(Z, pe, 1, 1, q, !0)), oe && (this.addCurrentVertex(Z, we, -1, -1, q, !0), this.addCurrentVertex(Z, we, 0, 0, q)));
            if (Ut && Pe < B - 1) {
              const rn = Z.dist(oe);
              if (rn > 2 * j) {
                const Zt = Z.add(oe.sub(Z)._mult(j / rn)._round());
                this.updateDistance(Z, Zt), this.addCurrentVertex(Zt, we, 0, 0, q), Z = Zt;
              }
            }
          }
        }
        addCurrentVertex(o, d, g, v, w) {
          let S = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !1;
          const P = d.y * v - d.x, B = -d.y - d.x * v;
          this.addHalfVertex(o, d.x + d.y * g, d.y - d.x * g, S, !1, g, w), this.addHalfVertex(o, P, B, S, !0, -v, w), this.distance > eb / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(o, d, g, v, w, S));
        }
        addHalfVertex(o, d, g, v, w, S, P) {
          let { x: B, y: k } = o;
          const j = 0.5 * (this.lineClips ? this.scaledDistance * (eb - 1) : this.scaledDistance);
          this.layoutVertexArray.emplaceBack((B << 1) + (v ? 1 : 0), (k << 1) + (w ? 1 : 0), Math.round(63 * d) + 128, Math.round(63 * g) + 128, 1 + (S === 0 ? 0 : S < 0 ? -1 : 1) | (63 & j) << 2, j >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
          const q = P.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, q), P.primitiveLength++), w ? this.e2 = q : this.e1 = q;
        }
        updateScaledDistance() {
          this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
        }
        updateDistance(o, d) {
          this.distance += o.dist(d), this.updateScaledDistance();
        }
      }
      let tb, nb;
      zt("LineBucket", l0, { omit: ["layers", "patternFeatures"] });
      var ib = { get paint() {
        return nb = nb || new _({ "line-opacity": new pn(re.paint_line["line-opacity"]), "line-color": new pn(re.paint_line["line-color"]), "line-translate": new en(re.paint_line["line-translate"]), "line-translate-anchor": new en(re.paint_line["line-translate-anchor"]), "line-width": new pn(re.paint_line["line-width"]), "line-gap-width": new pn(re.paint_line["line-gap-width"]), "line-offset": new pn(re.paint_line["line-offset"]), "line-blur": new pn(re.paint_line["line-blur"]), "line-dasharray": new a(re.paint_line["line-dasharray"]), "line-pattern": new E(re.paint_line["line-pattern"]), "line-gradient": new f(re.paint_line["line-gradient"]) });
      }, get layout() {
        return tb = tb || new _({ "line-cap": new en(re.layout_line["line-cap"]), "line-join": new pn(re.layout_line["line-join"]), "line-miter-limit": new en(re.layout_line["line-miter-limit"]), "line-round-limit": new en(re.layout_line["line-round-limit"]), "line-sort-key": new pn(re.layout_line["line-sort-key"]) });
      } };
      class Y3 extends pn {
        possiblyEvaluate(o, d) {
          return d = new pi(Math.floor(d.zoom), { now: d.now, fadeDuration: d.fadeDuration, zoomHistory: d.zoomHistory, transition: d.transition }), super.possiblyEvaluate(o, d);
        }
        evaluate(o, d, g, v) {
          return d = Le({}, d, { zoom: Math.floor(d.zoom) }), super.evaluate(o, d, g, v);
        }
      }
      let Zp;
      class K3 extends p {
        constructor(o) {
          super(o, ib), this.gradientVersion = 0, Zp || (Zp = new Y3(ib.paint.properties["line-width"].specification), Zp.useIntegerZoom = !0);
        }
        _handleSpecialPaintPropertyUpdate(o) {
          if (o === "line-gradient") {
            const d = this.gradientExpression();
            this.stepInterpolant = !!function(g) {
              return g._styleExpression !== void 0;
            }(d) && d._styleExpression.expression instanceof Wt, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
          }
        }
        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }
        recalculate(o, d) {
          super.recalculate(o, d), this.paint._values["line-floorwidth"] = Zp.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, o);
        }
        createBucket(o) {
          return new l0(o);
        }
        queryRadius(o) {
          const d = o, g = rb(gh("line-width", this, d), gh("line-gap-width", this, d)), v = gh("line-offset", this, d);
          return g / 2 + Math.abs(v) + wu(this.paint.get("line-translate"));
        }
        queryIntersectsFeature(o, d, g, v, w, S, P) {
          const B = Au(o, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), S.angle, P), k = P / 2 * rb(this.paint.get("line-width").evaluate(d, g), this.paint.get("line-gap-width").evaluate(d, g)), j = this.paint.get("line-offset").evaluate(d, g);
          return j && (v = function(q, Z) {
            const ee = [];
            for (let oe = 0; oe < q.length; oe++) {
              const pe = q[oe], we = [];
              for (let Pe = 0; Pe < pe.length; Pe++) {
                const He = pe[Pe - 1], ke = pe[Pe], Ge = pe[Pe + 1], at = Pe === 0 ? new T(0, 0) : ke.sub(He)._unit()._perp(), bt = Pe === pe.length - 1 ? new T(0, 0) : Ge.sub(ke)._unit()._perp(), Ut = at._add(bt)._unit(), ln = Ut.x * bt.x + Ut.y * bt.y;
                ln !== 0 && Ut._mult(1 / ln), we.push(Ut._mult(Z)._add(ke));
              }
              ee.push(we);
            }
            return ee;
          }(v, j * P)), function(q, Z, ee) {
            for (let oe = 0; oe < Z.length; oe++) {
              const pe = Z[oe];
              if (q.length >= 3) {
                for (let we = 0; we < pe.length; we++)
                  if (Kl(q, pe[we]))
                    return !0;
              }
              if (gf(q, pe, ee))
                return !0;
            }
            return !1;
          }(B, v, k);
        }
        isTileClipped() {
          return !0;
        }
      }
      function rb(u, o) {
        return o > 0 ? o + 2 * u : u;
      }
      const Q3 = M([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), eC = M([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
      M([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
      const tC = M([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
      M([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
      const sb = M([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), nC = M([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      function iC(u, o, d) {
        return u.sections.forEach((g) => {
          g.text = function(v, w, S) {
            const P = w.layout.get("text-transform").evaluate(S, {});
            return P === "uppercase" ? v = v.toLocaleUpperCase() : P === "lowercase" && (v = v.toLocaleLowerCase()), Ds.applyArabicShaping && (v = Ds.applyArabicShaping(v)), v;
          }(g.text, o, d);
        }), u;
      }
      M([{ name: "triangle", components: 3, type: "Uint16" }]), M([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), M([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), M([{ type: "Float32", name: "offsetX" }]), M([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), M([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
      const Af = { "!": "", "#": "", $: "", "%": "", "&": "", "(": "", ")": "", "*": "", "+": "", ",": "", "-": "", ".": "", "/": "", ":": "", ";": "", "<": "", "=": "", ">": "", "?": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" };
      var Or = 24, ob = Si, ab = function(u, o, d, g, v) {
        var w, S, P = 8 * v - g - 1, B = (1 << P) - 1, k = B >> 1, j = -7, q = v - 1, Z = -1, ee = u[o + q];
        for (q += Z, w = ee & (1 << -j) - 1, ee >>= -j, j += P; j > 0; w = 256 * w + u[o + q], q += Z, j -= 8)
          ;
        for (S = w & (1 << -j) - 1, w >>= -j, j += g; j > 0; S = 256 * S + u[o + q], q += Z, j -= 8)
          ;
        if (w === 0)
          w = 1 - k;
        else {
          if (w === B)
            return S ? NaN : 1 / 0 * (ee ? -1 : 1);
          S += Math.pow(2, g), w -= k;
        }
        return (ee ? -1 : 1) * S * Math.pow(2, w - g);
      }, lb = function(u, o, d, g, v, w) {
        var S, P, B, k = 8 * w - v - 1, j = (1 << k) - 1, q = j >> 1, Z = v === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, ee = 0, oe = 1, pe = o < 0 || o === 0 && 1 / o < 0 ? 1 : 0;
        for (o = Math.abs(o), isNaN(o) || o === 1 / 0 ? (P = isNaN(o) ? 1 : 0, S = j) : (S = Math.floor(Math.log(o) / Math.LN2), o * (B = Math.pow(2, -S)) < 1 && (S--, B *= 2), (o += S + q >= 1 ? Z / B : Z * Math.pow(2, 1 - q)) * B >= 2 && (S++, B /= 2), S + q >= j ? (P = 0, S = j) : S + q >= 1 ? (P = (o * B - 1) * Math.pow(2, v), S += q) : (P = o * Math.pow(2, q - 1) * Math.pow(2, v), S = 0)); v >= 8; u[d + ee] = 255 & P, ee += oe, P /= 256, v -= 8)
          ;
        for (S = S << v | P, k += v; k > 0; u[d + ee] = 255 & S, ee += oe, S /= 256, k -= 8)
          ;
        u[d + ee - oe] |= 128 * pe;
      };
      function Si(u) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(u) ? u : new Uint8Array(u || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
      }
      Si.Varint = 0, Si.Fixed64 = 1, Si.Bytes = 2, Si.Fixed32 = 5;
      var c0 = 4294967296, cb = 1 / c0, ub = typeof TextDecoder > "u" ? null : new TextDecoder("utf8");
      function zc(u) {
        return u.type === Si.Bytes ? u.readVarint() + u.pos : u.pos + 1;
      }
      function nd(u, o, d) {
        return d ? 4294967296 * o + (u >>> 0) : 4294967296 * (o >>> 0) + (u >>> 0);
      }
      function hb(u, o, d) {
        var g = o <= 16383 ? 1 : o <= 2097151 ? 2 : o <= 268435455 ? 3 : Math.floor(Math.log(o) / (7 * Math.LN2));
        d.realloc(g);
        for (var v = d.pos - 1; v >= u; v--)
          d.buf[v + g] = d.buf[v];
      }
      function rC(u, o) {
        for (var d = 0; d < u.length; d++)
          o.writeVarint(u[d]);
      }
      function sC(u, o) {
        for (var d = 0; d < u.length; d++)
          o.writeSVarint(u[d]);
      }
      function oC(u, o) {
        for (var d = 0; d < u.length; d++)
          o.writeFloat(u[d]);
      }
      function aC(u, o) {
        for (var d = 0; d < u.length; d++)
          o.writeDouble(u[d]);
      }
      function lC(u, o) {
        for (var d = 0; d < u.length; d++)
          o.writeBoolean(u[d]);
      }
      function cC(u, o) {
        for (var d = 0; d < u.length; d++)
          o.writeFixed32(u[d]);
      }
      function uC(u, o) {
        for (var d = 0; d < u.length; d++)
          o.writeSFixed32(u[d]);
      }
      function hC(u, o) {
        for (var d = 0; d < u.length; d++)
          o.writeFixed64(u[d]);
      }
      function dC(u, o) {
        for (var d = 0; d < u.length; d++)
          o.writeSFixed64(u[d]);
      }
      function Yp(u, o) {
        return (u[o] | u[o + 1] << 8 | u[o + 2] << 16) + 16777216 * u[o + 3];
      }
      function id(u, o, d) {
        u[d] = o, u[d + 1] = o >>> 8, u[d + 2] = o >>> 16, u[d + 3] = o >>> 24;
      }
      function db(u, o) {
        return (u[o] | u[o + 1] << 8 | u[o + 2] << 16) + (u[o + 3] << 24);
      }
      Si.prototype = { destroy: function() {
        this.buf = null;
      }, readFields: function(u, o, d) {
        for (d = d || this.length; this.pos < d; ) {
          var g = this.readVarint(), v = g >> 3, w = this.pos;
          this.type = 7 & g, u(v, o, this), this.pos === w && this.skip(g);
        }
        return o;
      }, readMessage: function(u, o) {
        return this.readFields(u, o, this.readVarint() + this.pos);
      }, readFixed32: function() {
        var u = Yp(this.buf, this.pos);
        return this.pos += 4, u;
      }, readSFixed32: function() {
        var u = db(this.buf, this.pos);
        return this.pos += 4, u;
      }, readFixed64: function() {
        var u = Yp(this.buf, this.pos) + Yp(this.buf, this.pos + 4) * c0;
        return this.pos += 8, u;
      }, readSFixed64: function() {
        var u = Yp(this.buf, this.pos) + db(this.buf, this.pos + 4) * c0;
        return this.pos += 8, u;
      }, readFloat: function() {
        var u = ab(this.buf, this.pos, !0, 23, 4);
        return this.pos += 4, u;
      }, readDouble: function() {
        var u = ab(this.buf, this.pos, !0, 52, 8);
        return this.pos += 8, u;
      }, readVarint: function(u) {
        var o, d, g = this.buf;
        return o = 127 & (d = g[this.pos++]), d < 128 ? o : (o |= (127 & (d = g[this.pos++])) << 7, d < 128 ? o : (o |= (127 & (d = g[this.pos++])) << 14, d < 128 ? o : (o |= (127 & (d = g[this.pos++])) << 21, d < 128 ? o : function(v, w, S) {
          var P, B, k = S.buf;
          if (P = (112 & (B = k[S.pos++])) >> 4, B < 128 || (P |= (127 & (B = k[S.pos++])) << 3, B < 128) || (P |= (127 & (B = k[S.pos++])) << 10, B < 128) || (P |= (127 & (B = k[S.pos++])) << 17, B < 128) || (P |= (127 & (B = k[S.pos++])) << 24, B < 128) || (P |= (1 & (B = k[S.pos++])) << 31, B < 128))
            return nd(v, P, w);
          throw new Error("Expected varint not more than 10 bytes");
        }(o |= (15 & (d = g[this.pos])) << 28, u, this))));
      }, readVarint64: function() {
        return this.readVarint(!0);
      }, readSVarint: function() {
        var u = this.readVarint();
        return u % 2 == 1 ? (u + 1) / -2 : u / 2;
      }, readBoolean: function() {
        return !!this.readVarint();
      }, readString: function() {
        var u = this.readVarint() + this.pos, o = this.pos;
        return this.pos = u, u - o >= 12 && ub ? function(d, g, v) {
          return ub.decode(d.subarray(g, v));
        }(this.buf, o, u) : function(d, g, v) {
          for (var w = "", S = g; S < v; ) {
            var P, B, k, j = d[S], q = null, Z = j > 239 ? 4 : j > 223 ? 3 : j > 191 ? 2 : 1;
            if (S + Z > v)
              break;
            Z === 1 ? j < 128 && (q = j) : Z === 2 ? (192 & (P = d[S + 1])) == 128 && (q = (31 & j) << 6 | 63 & P) <= 127 && (q = null) : Z === 3 ? (B = d[S + 2], (192 & (P = d[S + 1])) == 128 && (192 & B) == 128 && ((q = (15 & j) << 12 | (63 & P) << 6 | 63 & B) <= 2047 || q >= 55296 && q <= 57343) && (q = null)) : Z === 4 && (B = d[S + 2], k = d[S + 3], (192 & (P = d[S + 1])) == 128 && (192 & B) == 128 && (192 & k) == 128 && ((q = (15 & j) << 18 | (63 & P) << 12 | (63 & B) << 6 | 63 & k) <= 65535 || q >= 1114112) && (q = null)), q === null ? (q = 65533, Z = 1) : q > 65535 && (q -= 65536, w += String.fromCharCode(q >>> 10 & 1023 | 55296), q = 56320 | 1023 & q), w += String.fromCharCode(q), S += Z;
          }
          return w;
        }(this.buf, o, u);
      }, readBytes: function() {
        var u = this.readVarint() + this.pos, o = this.buf.subarray(this.pos, u);
        return this.pos = u, o;
      }, readPackedVarint: function(u, o) {
        if (this.type !== Si.Bytes)
          return u.push(this.readVarint(o));
        var d = zc(this);
        for (u = u || []; this.pos < d; )
          u.push(this.readVarint(o));
        return u;
      }, readPackedSVarint: function(u) {
        if (this.type !== Si.Bytes)
          return u.push(this.readSVarint());
        var o = zc(this);
        for (u = u || []; this.pos < o; )
          u.push(this.readSVarint());
        return u;
      }, readPackedBoolean: function(u) {
        if (this.type !== Si.Bytes)
          return u.push(this.readBoolean());
        var o = zc(this);
        for (u = u || []; this.pos < o; )
          u.push(this.readBoolean());
        return u;
      }, readPackedFloat: function(u) {
        if (this.type !== Si.Bytes)
          return u.push(this.readFloat());
        var o = zc(this);
        for (u = u || []; this.pos < o; )
          u.push(this.readFloat());
        return u;
      }, readPackedDouble: function(u) {
        if (this.type !== Si.Bytes)
          return u.push(this.readDouble());
        var o = zc(this);
        for (u = u || []; this.pos < o; )
          u.push(this.readDouble());
        return u;
      }, readPackedFixed32: function(u) {
        if (this.type !== Si.Bytes)
          return u.push(this.readFixed32());
        var o = zc(this);
        for (u = u || []; this.pos < o; )
          u.push(this.readFixed32());
        return u;
      }, readPackedSFixed32: function(u) {
        if (this.type !== Si.Bytes)
          return u.push(this.readSFixed32());
        var o = zc(this);
        for (u = u || []; this.pos < o; )
          u.push(this.readSFixed32());
        return u;
      }, readPackedFixed64: function(u) {
        if (this.type !== Si.Bytes)
          return u.push(this.readFixed64());
        var o = zc(this);
        for (u = u || []; this.pos < o; )
          u.push(this.readFixed64());
        return u;
      }, readPackedSFixed64: function(u) {
        if (this.type !== Si.Bytes)
          return u.push(this.readSFixed64());
        var o = zc(this);
        for (u = u || []; this.pos < o; )
          u.push(this.readSFixed64());
        return u;
      }, skip: function(u) {
        var o = 7 & u;
        if (o === Si.Varint)
          for (; this.buf[this.pos++] > 127; )
            ;
        else if (o === Si.Bytes)
          this.pos = this.readVarint() + this.pos;
        else if (o === Si.Fixed32)
          this.pos += 4;
        else {
          if (o !== Si.Fixed64)
            throw new Error("Unimplemented type: " + o);
          this.pos += 8;
        }
      }, writeTag: function(u, o) {
        this.writeVarint(u << 3 | o);
      }, realloc: function(u) {
        for (var o = this.length || 16; o < this.pos + u; )
          o *= 2;
        if (o !== this.length) {
          var d = new Uint8Array(o);
          d.set(this.buf), this.buf = d, this.length = o;
        }
      }, finish: function() {
        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
      }, writeFixed32: function(u) {
        this.realloc(4), id(this.buf, u, this.pos), this.pos += 4;
      }, writeSFixed32: function(u) {
        this.realloc(4), id(this.buf, u, this.pos), this.pos += 4;
      }, writeFixed64: function(u) {
        this.realloc(8), id(this.buf, -1 & u, this.pos), id(this.buf, Math.floor(u * cb), this.pos + 4), this.pos += 8;
      }, writeSFixed64: function(u) {
        this.realloc(8), id(this.buf, -1 & u, this.pos), id(this.buf, Math.floor(u * cb), this.pos + 4), this.pos += 8;
      }, writeVarint: function(u) {
        (u = +u || 0) > 268435455 || u < 0 ? function(o, d) {
          var g, v;
          if (o >= 0 ? (g = o % 4294967296 | 0, v = o / 4294967296 | 0) : (v = ~(-o / 4294967296), 4294967295 ^ (g = ~(-o % 4294967296)) ? g = g + 1 | 0 : (g = 0, v = v + 1 | 0)), o >= 18446744073709552e3 || o < -18446744073709552e3)
            throw new Error("Given varint doesn't fit into 10 bytes");
          d.realloc(10), function(w, S, P) {
            P.buf[P.pos++] = 127 & w | 128, w >>>= 7, P.buf[P.pos++] = 127 & w | 128, w >>>= 7, P.buf[P.pos++] = 127 & w | 128, w >>>= 7, P.buf[P.pos++] = 127 & w | 128, P.buf[P.pos] = 127 & (w >>>= 7);
          }(g, 0, d), function(w, S) {
            var P = (7 & w) << 4;
            S.buf[S.pos++] |= P | ((w >>>= 3) ? 128 : 0), w && (S.buf[S.pos++] = 127 & w | ((w >>>= 7) ? 128 : 0), w && (S.buf[S.pos++] = 127 & w | ((w >>>= 7) ? 128 : 0), w && (S.buf[S.pos++] = 127 & w | ((w >>>= 7) ? 128 : 0), w && (S.buf[S.pos++] = 127 & w | ((w >>>= 7) ? 128 : 0), w && (S.buf[S.pos++] = 127 & w)))));
          }(v, d);
        }(u, this) : (this.realloc(4), this.buf[this.pos++] = 127 & u | (u > 127 ? 128 : 0), u <= 127 || (this.buf[this.pos++] = 127 & (u >>>= 7) | (u > 127 ? 128 : 0), u <= 127 || (this.buf[this.pos++] = 127 & (u >>>= 7) | (u > 127 ? 128 : 0), u <= 127 || (this.buf[this.pos++] = u >>> 7 & 127))));
      }, writeSVarint: function(u) {
        this.writeVarint(u < 0 ? 2 * -u - 1 : 2 * u);
      }, writeBoolean: function(u) {
        this.writeVarint(!!u);
      }, writeString: function(u) {
        u = String(u), this.realloc(4 * u.length), this.pos++;
        var o = this.pos;
        this.pos = function(g, v, w) {
          for (var S, P, B = 0; B < v.length; B++) {
            if ((S = v.charCodeAt(B)) > 55295 && S < 57344) {
              if (!P) {
                S > 56319 || B + 1 === v.length ? (g[w++] = 239, g[w++] = 191, g[w++] = 189) : P = S;
                continue;
              }
              if (S < 56320) {
                g[w++] = 239, g[w++] = 191, g[w++] = 189, P = S;
                continue;
              }
              S = P - 55296 << 10 | S - 56320 | 65536, P = null;
            } else
              P && (g[w++] = 239, g[w++] = 191, g[w++] = 189, P = null);
            S < 128 ? g[w++] = S : (S < 2048 ? g[w++] = S >> 6 | 192 : (S < 65536 ? g[w++] = S >> 12 | 224 : (g[w++] = S >> 18 | 240, g[w++] = S >> 12 & 63 | 128), g[w++] = S >> 6 & 63 | 128), g[w++] = 63 & S | 128);
          }
          return w;
        }(this.buf, u, this.pos);
        var d = this.pos - o;
        d >= 128 && hb(o, d, this), this.pos = o - 1, this.writeVarint(d), this.pos += d;
      }, writeFloat: function(u) {
        this.realloc(4), lb(this.buf, u, this.pos, !0, 23, 4), this.pos += 4;
      }, writeDouble: function(u) {
        this.realloc(8), lb(this.buf, u, this.pos, !0, 52, 8), this.pos += 8;
      }, writeBytes: function(u) {
        var o = u.length;
        this.writeVarint(o), this.realloc(o);
        for (var d = 0; d < o; d++)
          this.buf[this.pos++] = u[d];
      }, writeRawMessage: function(u, o) {
        this.pos++;
        var d = this.pos;
        u(o, this);
        var g = this.pos - d;
        g >= 128 && hb(d, g, this), this.pos = d - 1, this.writeVarint(g), this.pos += g;
      }, writeMessage: function(u, o, d) {
        this.writeTag(u, Si.Bytes), this.writeRawMessage(o, d);
      }, writePackedVarint: function(u, o) {
        o.length && this.writeMessage(u, rC, o);
      }, writePackedSVarint: function(u, o) {
        o.length && this.writeMessage(u, sC, o);
      }, writePackedBoolean: function(u, o) {
        o.length && this.writeMessage(u, lC, o);
      }, writePackedFloat: function(u, o) {
        o.length && this.writeMessage(u, oC, o);
      }, writePackedDouble: function(u, o) {
        o.length && this.writeMessage(u, aC, o);
      }, writePackedFixed32: function(u, o) {
        o.length && this.writeMessage(u, cC, o);
      }, writePackedSFixed32: function(u, o) {
        o.length && this.writeMessage(u, uC, o);
      }, writePackedFixed64: function(u, o) {
        o.length && this.writeMessage(u, hC, o);
      }, writePackedSFixed64: function(u, o) {
        o.length && this.writeMessage(u, dC, o);
      }, writeBytesField: function(u, o) {
        this.writeTag(u, Si.Bytes), this.writeBytes(o);
      }, writeFixed32Field: function(u, o) {
        this.writeTag(u, Si.Fixed32), this.writeFixed32(o);
      }, writeSFixed32Field: function(u, o) {
        this.writeTag(u, Si.Fixed32), this.writeSFixed32(o);
      }, writeFixed64Field: function(u, o) {
        this.writeTag(u, Si.Fixed64), this.writeFixed64(o);
      }, writeSFixed64Field: function(u, o) {
        this.writeTag(u, Si.Fixed64), this.writeSFixed64(o);
      }, writeVarintField: function(u, o) {
        this.writeTag(u, Si.Varint), this.writeVarint(o);
      }, writeSVarintField: function(u, o) {
        this.writeTag(u, Si.Varint), this.writeSVarint(o);
      }, writeStringField: function(u, o) {
        this.writeTag(u, Si.Bytes), this.writeString(o);
      }, writeFloatField: function(u, o) {
        this.writeTag(u, Si.Fixed32), this.writeFloat(o);
      }, writeDoubleField: function(u, o) {
        this.writeTag(u, Si.Fixed64), this.writeDouble(o);
      }, writeBooleanField: function(u, o) {
        this.writeVarintField(u, !!o);
      } };
      var u0 = m(ob);
      const h0 = 3;
      function fC(u, o, d) {
        u === 1 && d.readMessage(pC, o);
      }
      function pC(u, o, d) {
        if (u === 3) {
          const { id: g, bitmap: v, width: w, height: S, left: P, top: B, advance: k } = d.readMessage(gC, {});
          o.push({ id: g, bitmap: new _f({ width: w + 2 * h0, height: S + 2 * h0 }, v), metrics: { width: w, height: S, left: P, top: B, advance: k } });
        }
      }
      function gC(u, o, d) {
        u === 1 ? o.id = d.readVarint() : u === 2 ? o.bitmap = d.readBytes() : u === 3 ? o.width = d.readVarint() : u === 4 ? o.height = d.readVarint() : u === 5 ? o.left = d.readSVarint() : u === 6 ? o.top = d.readSVarint() : u === 7 && (o.advance = d.readVarint());
      }
      const fb = h0;
      function pb(u) {
        let o = 0, d = 0;
        for (const S of u)
          o += S.w * S.h, d = Math.max(d, S.w);
        u.sort((S, P) => P.h - S.h);
        const g = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(o / 0.95)), d), h: 1 / 0 }];
        let v = 0, w = 0;
        for (const S of u)
          for (let P = g.length - 1; P >= 0; P--) {
            const B = g[P];
            if (!(S.w > B.w || S.h > B.h)) {
              if (S.x = B.x, S.y = B.y, w = Math.max(w, S.y + S.h), v = Math.max(v, S.x + S.w), S.w === B.w && S.h === B.h) {
                const k = g.pop();
                P < g.length && (g[P] = k);
              } else
                S.h === B.h ? (B.x += S.w, B.w -= S.w) : S.w === B.w ? (B.y += S.h, B.h -= S.h) : (g.push({ x: B.x + S.w, y: B.y, w: B.w - S.w, h: S.h }), B.y += S.h, B.h -= S.h);
              break;
            }
          }
        return { w: v, h: w, fill: o / (v * w) || 0 };
      }
      const fo = 1;
      class d0 {
        constructor(o, d) {
          let { pixelRatio: g, version: v, stretchX: w, stretchY: S, content: P, textFitWidth: B, textFitHeight: k } = d;
          this.paddedRect = o, this.pixelRatio = g, this.stretchX = w, this.stretchY = S, this.content = P, this.version = v, this.textFitWidth = B, this.textFitHeight = k;
        }
        get tl() {
          return [this.paddedRect.x + fo, this.paddedRect.y + fo];
        }
        get br() {
          return [this.paddedRect.x + this.paddedRect.w - fo, this.paddedRect.y + this.paddedRect.h - fo];
        }
        get tlbr() {
          return this.tl.concat(this.br);
        }
        get displaySize() {
          return [(this.paddedRect.w - 2 * fo) / this.pixelRatio, (this.paddedRect.h - 2 * fo) / this.pixelRatio];
        }
      }
      class gb {
        constructor(o, d) {
          const g = {}, v = {};
          this.haveRenderCallbacks = [];
          const w = [];
          this.addImages(o, g, w), this.addImages(d, v, w);
          const { w: S, h: P } = pb(w), B = new ta({ width: S || 1, height: P || 1 });
          for (const k in o) {
            const j = o[k], q = g[k].paddedRect;
            ta.copy(j.data, B, { x: 0, y: 0 }, { x: q.x + fo, y: q.y + fo }, j.data);
          }
          for (const k in d) {
            const j = d[k], q = v[k].paddedRect, Z = q.x + fo, ee = q.y + fo, oe = j.data.width, pe = j.data.height;
            ta.copy(j.data, B, { x: 0, y: 0 }, { x: Z, y: ee }, j.data), ta.copy(j.data, B, { x: 0, y: pe - 1 }, { x: Z, y: ee - 1 }, { width: oe, height: 1 }), ta.copy(j.data, B, { x: 0, y: 0 }, { x: Z, y: ee + pe }, { width: oe, height: 1 }), ta.copy(j.data, B, { x: oe - 1, y: 0 }, { x: Z - 1, y: ee }, { width: 1, height: pe }), ta.copy(j.data, B, { x: 0, y: 0 }, { x: Z + oe, y: ee }, { width: 1, height: pe });
          }
          this.image = B, this.iconPositions = g, this.patternPositions = v;
        }
        addImages(o, d, g) {
          for (const v in o) {
            const w = o[v], S = { x: 0, y: 0, w: w.data.width + 2 * fo, h: w.data.height + 2 * fo };
            g.push(S), d[v] = new d0(S, w), w.hasRenderCallback && this.haveRenderCallbacks.push(v);
          }
        }
        patchUpdatedImages(o, d) {
          o.dispatchRenderCallbacks(this.haveRenderCallbacks);
          for (const g in o.updatedImages)
            this.patchUpdatedImage(this.iconPositions[g], o.getImage(g), d), this.patchUpdatedImage(this.patternPositions[g], o.getImage(g), d);
        }
        patchUpdatedImage(o, d, g) {
          if (!o || !d || o.version === d.version)
            return;
          o.version = d.version;
          const [v, w] = o.tl;
          g.update(d.data, void 0, { x: v, y: w });
        }
      }
      var Su;
      zt("ImagePosition", d0), zt("ImageAtlas", gb), c.ai = void 0, (Su = c.ai || (c.ai = {}))[Su.none = 0] = "none", Su[Su.horizontal = 1] = "horizontal", Su[Su.vertical = 2] = "vertical", Su[Su.horizontalOnly = 3] = "horizontalOnly";
      const Ef = -17;
      class Sf {
        constructor() {
          this.scale = 1, this.fontStack = "", this.imageName = null;
        }
        static forText(o, d) {
          const g = new Sf();
          return g.scale = o || 1, g.fontStack = d, g;
        }
        static forImage(o) {
          const d = new Sf();
          return d.imageName = o, d;
        }
      }
      class rd {
        constructor() {
          this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        }
        static fromFeature(o, d) {
          const g = new rd();
          for (let v = 0; v < o.sections.length; v++) {
            const w = o.sections[v];
            w.image ? g.addImageSection(w) : g.addTextSection(w, d);
          }
          return g;
        }
        length() {
          return this.text.length;
        }
        getSection(o) {
          return this.sections[this.sectionIndex[o]];
        }
        getSectionIndex(o) {
          return this.sectionIndex[o];
        }
        getCharCode(o) {
          return this.text.charCodeAt(o);
        }
        verticalizePunctuation() {
          this.text = function(o) {
            let d = "";
            for (let g = 0; g < o.length; g++) {
              const v = o.charCodeAt(g + 1) || null, w = o.charCodeAt(g - 1) || null;
              d += v && ah(v) && !Af[o[g + 1]] || w && ah(w) && !Af[o[g - 1]] || !Af[o[g]] ? o[g] : Af[o[g]];
            }
            return d;
          }(this.text);
        }
        trim() {
          let o = 0;
          for (let g = 0; g < this.text.length && Qp[this.text.charCodeAt(g)]; g++)
            o++;
          let d = this.text.length;
          for (let g = this.text.length - 1; g >= 0 && g >= o && Qp[this.text.charCodeAt(g)]; g--)
            d--;
          this.text = this.text.substring(o, d), this.sectionIndex = this.sectionIndex.slice(o, d);
        }
        substring(o, d) {
          const g = new rd();
          return g.text = this.text.substring(o, d), g.sectionIndex = this.sectionIndex.slice(o, d), g.sections = this.sections, g;
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce((o, d) => Math.max(o, this.sections[d].scale), 0);
        }
        addTextSection(o, d) {
          this.text += o.text, this.sections.push(Sf.forText(o.scale, o.fontStack || d));
          const g = this.sections.length - 1;
          for (let v = 0; v < o.text.length; ++v)
            this.sectionIndex.push(g);
        }
        addImageSection(o) {
          const d = o.image ? o.image.name : "";
          if (d.length === 0)
            return void Te("Can't add FormattedSection with an empty image.");
          const g = this.getNextImageSectionCharCode();
          g ? (this.text += String.fromCharCode(g), this.sections.push(Sf.forImage(d)), this.sectionIndex.push(this.sections.length - 1)) : Te("Reached maximum number of images 6401");
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        }
      }
      function Kp(u, o, d, g, v, w, S, P, B, k, j, q, Z, ee, oe) {
        const pe = rd.fromFeature(u, v);
        let we;
        q === c.ai.vertical && pe.verticalizePunctuation();
        const { processBidirectionalText: Pe, processStyledBidirectionalText: He } = Ds;
        if (Pe && pe.sections.length === 1) {
          we = [];
          const at = Pe(pe.toString(), f0(pe, k, w, o, g, ee));
          for (const bt of at) {
            const Ut = new rd();
            Ut.text = bt, Ut.sections = pe.sections;
            for (let ln = 0; ln < bt.length; ln++)
              Ut.sectionIndex.push(0);
            we.push(Ut);
          }
        } else if (He) {
          we = [];
          const at = He(pe.text, pe.sectionIndex, f0(pe, k, w, o, g, ee));
          for (const bt of at) {
            const Ut = new rd();
            Ut.text = bt[0], Ut.sectionIndex = bt[1], Ut.sections = pe.sections, we.push(Ut);
          }
        } else
          we = function(at, bt) {
            const Ut = [], ln = at.text;
            let jt = 0;
            for (const Dt of bt)
              Ut.push(at.substring(jt, Dt)), jt = Dt;
            return jt < ln.length && Ut.push(at.substring(jt, ln.length)), Ut;
          }(pe, f0(pe, k, w, o, g, ee));
        const ke = [], Ge = { positionedLines: ke, text: pe.toString(), top: j[1], bottom: j[1], left: j[0], right: j[0], writingMode: q, iconsInText: !1, verticalizable: !1 };
        return function(at, bt, Ut, ln, jt, Dt, rn, Zt, Jt, gt, sn, tn) {
          let Cn = 0, Mi = Ef, Ti = 0, jr = 0;
          const ja = Zt === "right" ? 1 : Zt === "left" ? 0 : 0.5;
          let ls = 0;
          for (const gr of jt) {
            gr.trim();
            const Gr = gr.getMaxScale(), Ss = (Gr - 1) * Or, cs = { positionedGlyphs: [], lineOffset: 0 };
            at.positionedLines[ls] = cs;
            const js = cs.positionedGlyphs;
            let us = 0;
            if (!gr.length()) {
              Mi += Dt, ++ls;
              continue;
            }
            for (let po = 0; po < gr.length(); po++) {
              const oi = gr.getSection(po), Ni = gr.getSectionIndex(po), qi = gr.getCharCode(po);
              let Lo = 0, lr = null, ld = null, ec = null, tc = Or;
              const Ga = !(Jt === c.ai.horizontal || !sn && !gu(qi) || sn && (Qp[qi] || (pr = qi, Vt.Arabic(pr) || Vt["Arabic Supplement"](pr) || Vt["Arabic Extended-A"](pr) || Vt["Arabic Presentation Forms-A"](pr) || Vt["Arabic Presentation Forms-B"](pr))));
              if (oi.imageName) {
                const ra = ln[oi.imageName];
                if (!ra)
                  continue;
                ec = oi.imageName, at.iconsInText = at.iconsInText || !0, ld = ra.paddedRect;
                const ns = ra.displaySize;
                oi.scale = oi.scale * Or / tn, lr = { width: ns[0], height: ns[1], left: fo, top: -fb, advance: Ga ? ns[1] : ns[0] }, Lo = Ss + (Or - ns[1] * oi.scale), tc = lr.advance;
                const Uc = Ga ? ns[0] * oi.scale - Or * Gr : ns[1] * oi.scale - Or * Gr;
                Uc > 0 && Uc > us && (us = Uc);
              } else {
                const ra = Ut[oi.fontStack], ns = ra && ra[qi];
                if (ns && ns.rect)
                  ld = ns.rect, lr = ns.metrics;
                else {
                  const Uc = bt[oi.fontStack], Lf = Uc && Uc[qi];
                  if (!Lf)
                    continue;
                  lr = Lf.metrics;
                }
                Lo = (Gr - oi.scale) * Or;
              }
              Ga ? (at.verticalizable = !0, js.push({ glyph: qi, imageName: ec, x: Cn, y: Mi + Lo, vertical: Ga, scale: oi.scale, fontStack: oi.fontStack, sectionIndex: Ni, metrics: lr, rect: ld }), Cn += tc * oi.scale + gt) : (js.push({ glyph: qi, imageName: ec, x: Cn, y: Mi + Lo, vertical: Ga, scale: oi.scale, fontStack: oi.fontStack, sectionIndex: Ni, metrics: lr, rect: ld }), Cn += lr.advance * oi.scale + gt);
            }
            js.length !== 0 && (Ti = Math.max(Cn - gt, Ti), vC(js, 0, js.length - 1, ja, us)), Cn = 0;
            const ia = Dt * Gr + us;
            cs.lineOffset = Math.max(us, Ss), Mi += ia, jr = Math.max(ia, jr), ++ls;
          }
          var pr;
          const Ns = Mi - Ef, { horizontalAlign: zs, verticalAlign: Us } = p0(rn);
          (function(gr, Gr, Ss, cs, js, us, ia, po, oi) {
            const Ni = (Gr - Ss) * js;
            let qi = 0;
            qi = us !== ia ? -po * cs - Ef : (-cs * oi + 0.5) * ia;
            for (const Lo of gr)
              for (const lr of Lo.positionedGlyphs)
                lr.x += Ni, lr.y += qi;
          })(at.positionedLines, ja, zs, Us, Ti, jr, Dt, Ns, jt.length), at.top += -Us * Ns, at.bottom = at.top + Ns, at.left += -zs * Ti, at.right = at.left + Ti;
        }(Ge, o, d, g, we, S, P, B, q, k, Z, oe), !function(at) {
          for (const bt of at)
            if (bt.positionedGlyphs.length !== 0)
              return !1;
          return !0;
        }(ke) && Ge;
      }
      const Qp = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, mC = { 10: !0, 32: !0, 38: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 }, _C = { 40: !0 };
      function mb(u, o, d, g, v, w) {
        if (o.imageName) {
          const S = g[o.imageName];
          return S ? S.displaySize[0] * o.scale * Or / w + v : 0;
        }
        {
          const S = d[o.fontStack], P = S && S[u];
          return P ? P.metrics.advance * o.scale + v : 0;
        }
      }
      function _b(u, o, d, g) {
        const v = Math.pow(u - o, 2);
        return g ? u < o ? v / 2 : 2 * v : v + Math.abs(d) * d;
      }
      function yC(u, o, d) {
        let g = 0;
        return u === 10 && (g -= 1e4), d && (g += 150), u !== 40 && u !== 65288 || (g += 50), o !== 41 && o !== 65289 || (g += 50), g;
      }
      function yb(u, o, d, g, v, w) {
        let S = null, P = _b(o, d, v, w);
        for (const B of g) {
          const k = _b(o - B.x, d, v, w) + B.badness;
          k <= P && (S = B, P = k);
        }
        return { index: u, x: o, priorBreak: S, badness: P };
      }
      function vb(u) {
        return u ? vb(u.priorBreak).concat(u.index) : [];
      }
      function f0(u, o, d, g, v, w) {
        if (!u)
          return [];
        const S = [], P = function(q, Z, ee, oe, pe, we) {
          let Pe = 0;
          for (let He = 0; He < q.length(); He++) {
            const ke = q.getSection(He);
            Pe += mb(q.getCharCode(He), ke, oe, pe, Z, we);
          }
          return Pe / Math.max(1, Math.ceil(Pe / ee));
        }(u, o, d, g, v, w), B = u.text.indexOf("") >= 0;
        let k = 0;
        for (let q = 0; q < u.length(); q++) {
          const Z = u.getSection(q), ee = u.getCharCode(q);
          if (Qp[ee] || (k += mb(ee, Z, g, v, o, w)), q < u.length() - 1) {
            const oe = !((j = ee) < 11904 || !(Vt["Bopomofo Extended"](j) || Vt.Bopomofo(j) || Vt["CJK Compatibility Forms"](j) || Vt["CJK Compatibility Ideographs"](j) || Vt["CJK Compatibility"](j) || Vt["CJK Radicals Supplement"](j) || Vt["CJK Strokes"](j) || Vt["CJK Symbols and Punctuation"](j) || Vt["CJK Unified Ideographs Extension A"](j) || Vt["CJK Unified Ideographs"](j) || Vt["Enclosed CJK Letters and Months"](j) || Vt["Halfwidth and Fullwidth Forms"](j) || Vt.Hiragana(j) || Vt["Ideographic Description Characters"](j) || Vt["Kangxi Radicals"](j) || Vt["Katakana Phonetic Extensions"](j) || Vt.Katakana(j) || Vt["Vertical Forms"](j) || Vt["Yi Radicals"](j) || Vt["Yi Syllables"](j)));
            (mC[ee] || oe || Z.imageName || q !== u.length() - 2 && _C[u.getCharCode(q + 1)]) && S.push(yb(q + 1, k, P, S, yC(ee, u.getCharCode(q + 1), oe && B), !1));
          }
        }
        var j;
        return vb(yb(u.length(), k, P, S, 0, !0));
      }
      function p0(u) {
        let o = 0.5, d = 0.5;
        switch (u) {
          case "right":
          case "top-right":
          case "bottom-right":
            o = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            o = 0;
        }
        switch (u) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            d = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            d = 0;
        }
        return { horizontalAlign: o, verticalAlign: d };
      }
      function vC(u, o, d, g, v) {
        if (!g && !v)
          return;
        const w = u[d], S = (u[d].x + w.metrics.advance * w.scale) * g;
        for (let P = o; P <= d; P++)
          u[P].x -= S, u[P].y += v;
      }
      function bC(u, o, d) {
        const { horizontalAlign: g, verticalAlign: v } = p0(d), w = o[0] - u.displaySize[0] * g, S = o[1] - u.displaySize[1] * v;
        return { image: u, top: S, bottom: S + u.displaySize[1], left: w, right: w + u.displaySize[0] };
      }
      function bb(u) {
        var o, d;
        let g = u.left, v = u.top, w = u.right - g, S = u.bottom - v;
        const P = (o = u.image.textFitWidth) !== null && o !== void 0 ? o : "stretchOrShrink", B = (d = u.image.textFitHeight) !== null && d !== void 0 ? d : "stretchOrShrink", k = (u.image.content[2] - u.image.content[0]) / (u.image.content[3] - u.image.content[1]);
        if (B === "proportional") {
          if (P === "stretchOnly" && w / S < k || P === "proportional") {
            const j = Math.ceil(S * k);
            g *= j / w, w = j;
          }
        } else if (P === "proportional" && B === "stretchOnly" && k !== 0 && w / S > k) {
          const j = Math.ceil(w / k);
          v *= j / S, S = j;
        }
        return { x1: g, y1: v, x2: g + w, y2: v + S };
      }
      function xb(u, o, d, g, v, w) {
        const S = u.image;
        let P;
        if (S.content) {
          const we = S.content, Pe = S.pixelRatio || 1;
          P = [we[0] / Pe, we[1] / Pe, S.displaySize[0] - we[2] / Pe, S.displaySize[1] - we[3] / Pe];
        }
        const B = o.left * w, k = o.right * w;
        let j, q, Z, ee;
        d === "width" || d === "both" ? (ee = v[0] + B - g[3], q = v[0] + k + g[1]) : (ee = v[0] + (B + k - S.displaySize[0]) / 2, q = ee + S.displaySize[0]);
        const oe = o.top * w, pe = o.bottom * w;
        return d === "height" || d === "both" ? (j = v[1] + oe - g[0], Z = v[1] + pe + g[2]) : (j = v[1] + (oe + pe - S.displaySize[1]) / 2, Z = j + S.displaySize[1]), { image: S, top: j, right: q, bottom: Z, left: ee, collisionPadding: P };
      }
      const Tf = 255, Ql = 128, Tu = Tf * Ql;
      function wb(u, o) {
        const { expression: d } = o;
        if (d.kind === "constant")
          return { kind: "constant", layoutSize: d.evaluate(new pi(u + 1)) };
        if (d.kind === "source")
          return { kind: "source" };
        {
          const { zoomStops: g, interpolationType: v } = d;
          let w = 0;
          for (; w < g.length && g[w] <= u; )
            w++;
          w = Math.max(0, w - 1);
          let S = w;
          for (; S < g.length && g[S] < u + 1; )
            S++;
          S = Math.min(g.length - 1, S);
          const P = g[w], B = g[S];
          return d.kind === "composite" ? { kind: "composite", minZoom: P, maxZoom: B, interpolationType: v } : { kind: "camera", minZoom: P, maxZoom: B, minSize: d.evaluate(new pi(P)), maxSize: d.evaluate(new pi(B)), interpolationType: v };
        }
      }
      function g0(u, o, d) {
        let g = "never";
        const v = u.get(o);
        return v ? g = v : u.get(d) && (g = "always"), g;
      }
      const xC = Eu.VectorTileFeature.types, wC = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function eg(u, o, d, g, v, w, S, P, B, k, j, q, Z) {
        const ee = P ? Math.min(Tu, Math.round(P[0])) : 0, oe = P ? Math.min(Tu, Math.round(P[1])) : 0;
        u.emplaceBack(o, d, Math.round(32 * g), Math.round(32 * v), w, S, (ee << 1) + (B ? 1 : 0), oe, 16 * k, 16 * j, 256 * q, 256 * Z);
      }
      function m0(u, o, d) {
        u.emplaceBack(o.x, o.y, d), u.emplaceBack(o.x, o.y, d), u.emplaceBack(o.x, o.y, d), u.emplaceBack(o.x, o.y, d);
      }
      function AC(u) {
        for (const o of u.sections)
          if (Jl(o.text))
            return !0;
        return !1;
      }
      class _0 {
        constructor(o) {
          this.layoutVertexArray = new si(), this.indexArray = new nr(), this.programConfigurations = o, this.segments = new Vi(), this.dynamicLayoutVertexArray = new Io(), this.opacityVertexArray = new cl(), this.hasVisibleVertices = !1, this.placedSymbolArray = new Wn();
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
        }
        upload(o, d, g, v) {
          this.isEmpty() || (g && (this.layoutVertexBuffer = o.createVertexBuffer(this.layoutVertexArray, Q3.members), this.indexBuffer = o.createIndexBuffer(this.indexArray, d), this.dynamicLayoutVertexBuffer = o.createVertexBuffer(this.dynamicLayoutVertexArray, eC.members, !0), this.opacityVertexBuffer = o.createVertexBuffer(this.opacityVertexArray, wC, !0), this.opacityVertexBuffer.itemSize = 1), (g || v) && this.programConfigurations.upload(o));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
        }
      }
      zt("SymbolBuffers", _0);
      class y0 {
        constructor(o, d, g) {
          this.layoutVertexArray = new o(), this.layoutAttributes = d, this.indexArray = new g(), this.segments = new Vi(), this.collisionVertexArray = new mr();
        }
        upload(o) {
          this.layoutVertexBuffer = o.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = o.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = o.createVertexBuffer(this.collisionVertexArray, tC.members, !0);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
        }
      }
      zt("CollisionBuffers", y0);
      class sd {
        constructor(o) {
          this.collisionBoxArray = o.collisionBoxArray, this.zoom = o.zoom, this.overscaling = o.overscaling, this.layers = o.layers, this.layerIds = this.layers.map((S) => S.id), this.index = o.index, this.pixelRatio = o.pixelRatio, this.sourceLayerIndex = o.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = Zm([]), this.placementViewportMatrix = Zm([]);
          const d = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = wb(this.zoom, d["text-size"]), this.iconSizeData = wb(this.zoom, d["icon-size"]);
          const g = this.layers[0].layout, v = g.get("symbol-sort-key"), w = g.get("symbol-z-order");
          this.canOverlap = g0(g, "text-overlap", "text-allow-overlap") !== "never" || g0(g, "icon-overlap", "icon-allow-overlap") !== "never" || g.get("text-ignore-placement") || g.get("icon-ignore-placement"), this.sortFeaturesByKey = w !== "viewport-y" && !v.isConstant(), this.sortFeaturesByY = (w === "viewport-y" || w === "auto" && !this.sortFeaturesByKey) && this.canOverlap, g.get("symbol-placement") === "point" && (this.writingModes = g.get("text-writing-mode").map((S) => c.ai[S])), this.stateDependentLayerIds = this.layers.filter((S) => S.isStateDependent()).map((S) => S.id), this.sourceID = o.sourceID;
        }
        createArrays() {
          this.text = new _0(new fl(this.layers, this.zoom, (o) => /^text/.test(o))), this.icon = new _0(new fl(this.layers, this.zoom, (o) => /^icon/.test(o))), this.glyphOffsetArray = new En(), this.lineVertexArray = new Li(), this.symbolInstances = new ji(), this.textAnchorOffsets = new ni();
        }
        calculateGlyphDependencies(o, d, g, v, w) {
          for (let S = 0; S < o.length; S++)
            if (d[o.charCodeAt(S)] = !0, (g || v) && w) {
              const P = Af[o.charAt(S)];
              P && (d[P.charCodeAt(0)] = !0);
            }
        }
        populate(o, d, g) {
          const v = this.layers[0], w = v.layout, S = w.get("text-font"), P = w.get("text-field"), B = w.get("icon-image"), k = (P.value.kind !== "constant" || P.value.value instanceof Ri && !P.value.value.isEmpty() || P.value.value.toString().length > 0) && (S.value.kind !== "constant" || S.value.value.length > 0), j = B.value.kind !== "constant" || !!B.value.value || Object.keys(B.parameters).length > 0, q = w.get("symbol-sort-key");
          if (this.features = [], !k && !j)
            return;
          const Z = d.iconDependencies, ee = d.glyphDependencies, oe = d.availableImages, pe = new pi(this.zoom);
          for (const { feature: we, id: Pe, index: He, sourceLayerIndex: ke } of o) {
            const Ge = v._featureFilter.needGeometry, at = Nc(we, Ge);
            if (!v._featureFilter.filter(pe, at, g))
              continue;
            let bt, Ut;
            if (Ge || (at.geometry = Po(we)), k) {
              const jt = v.getValueAndResolveTokens("text-field", at, g, oe), Dt = Ri.factory(jt), rn = this.hasRTLText = this.hasRTLText || AC(Dt);
              (!rn || Ds.getRTLTextPluginStatus() === "unavailable" || rn && Ds.isParsed()) && (bt = iC(Dt, v, at));
            }
            if (j) {
              const jt = v.getValueAndResolveTokens("icon-image", at, g, oe);
              Ut = jt instanceof fi ? jt : fi.fromString(jt);
            }
            if (!bt && !Ut)
              continue;
            const ln = this.sortFeaturesByKey ? q.evaluate(at, {}, g) : void 0;
            if (this.features.push({ id: Pe, text: bt, icon: Ut, index: He, sourceLayerIndex: ke, geometry: at.geometry, properties: we.properties, type: xC[we.type], sortKey: ln }), Ut && (Z[Ut.name] = !0), bt) {
              const jt = S.evaluate(at, {}, g).join(","), Dt = w.get("text-rotation-alignment") !== "viewport" && w.get("symbol-placement") !== "point";
              this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(c.ai.vertical) >= 0;
              for (const rn of bt.sections)
                if (rn.image)
                  Z[rn.image.name] = !0;
                else {
                  const Zt = sh(bt.toString()), Jt = rn.fontStack || jt, gt = ee[Jt] = ee[Jt] || {};
                  this.calculateGlyphDependencies(rn.text, gt, Dt, this.allowVerticalPlacement, Zt);
                }
            }
          }
          w.get("symbol-placement") === "line" && (this.features = function(we) {
            const Pe = {}, He = {}, ke = [];
            let Ge = 0;
            function at(jt) {
              ke.push(we[jt]), Ge++;
            }
            function bt(jt, Dt, rn) {
              const Zt = He[jt];
              return delete He[jt], He[Dt] = Zt, ke[Zt].geometry[0].pop(), ke[Zt].geometry[0] = ke[Zt].geometry[0].concat(rn[0]), Zt;
            }
            function Ut(jt, Dt, rn) {
              const Zt = Pe[Dt];
              return delete Pe[Dt], Pe[jt] = Zt, ke[Zt].geometry[0].shift(), ke[Zt].geometry[0] = rn[0].concat(ke[Zt].geometry[0]), Zt;
            }
            function ln(jt, Dt, rn) {
              const Zt = rn ? Dt[0][Dt[0].length - 1] : Dt[0][0];
              return `${jt}:${Zt.x}:${Zt.y}`;
            }
            for (let jt = 0; jt < we.length; jt++) {
              const Dt = we[jt], rn = Dt.geometry, Zt = Dt.text ? Dt.text.toString() : null;
              if (!Zt) {
                at(jt);
                continue;
              }
              const Jt = ln(Zt, rn), gt = ln(Zt, rn, !0);
              if (Jt in He && gt in Pe && He[Jt] !== Pe[gt]) {
                const sn = Ut(Jt, gt, rn), tn = bt(Jt, gt, ke[sn].geometry);
                delete Pe[Jt], delete He[gt], He[ln(Zt, ke[tn].geometry, !0)] = tn, ke[sn].geometry = null;
              } else
                Jt in He ? bt(Jt, gt, rn) : gt in Pe ? Ut(Jt, gt, rn) : (at(jt), Pe[Jt] = Ge - 1, He[gt] = Ge - 1);
            }
            return ke.filter((jt) => jt.geometry);
          }(this.features)), this.sortFeaturesByKey && this.features.sort((we, Pe) => we.sortKey - Pe.sortKey);
        }
        update(o, d, g) {
          this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(o, d, this.layers, g), this.icon.programConfigurations.updatePaintArrays(o, d, this.layers, g));
        }
        isEmpty() {
          return this.symbolInstances.length === 0 && !this.hasRTLText;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(o) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(o), this.iconCollisionBox.upload(o)), this.text.upload(o, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(o, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        destroy() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(o, d) {
          const g = this.lineVertexArray.length;
          if (o.segment !== void 0) {
            let v = o.dist(d[o.segment + 1]), w = o.dist(d[o.segment]);
            const S = {};
            for (let P = o.segment + 1; P < d.length; P++)
              S[P] = { x: d[P].x, y: d[P].y, tileUnitDistanceFromAnchor: v }, P < d.length - 1 && (v += d[P + 1].dist(d[P]));
            for (let P = o.segment || 0; P >= 0; P--)
              S[P] = { x: d[P].x, y: d[P].y, tileUnitDistanceFromAnchor: w }, P > 0 && (w += d[P - 1].dist(d[P]));
            for (let P = 0; P < d.length; P++) {
              const B = S[P];
              this.lineVertexArray.emplaceBack(B.x, B.y, B.tileUnitDistanceFromAnchor);
            }
          }
          return { lineStartIndex: g, lineLength: this.lineVertexArray.length - g };
        }
        addSymbols(o, d, g, v, w, S, P, B, k, j, q, Z) {
          const ee = o.indexArray, oe = o.layoutVertexArray, pe = o.segments.prepareSegment(4 * d.length, oe, ee, this.canOverlap ? S.sortKey : void 0), we = this.glyphOffsetArray.length, Pe = pe.vertexLength, He = this.allowVerticalPlacement && P === c.ai.vertical ? Math.PI / 2 : 0, ke = S.text && S.text.sections;
          for (let Ge = 0; Ge < d.length; Ge++) {
            const { tl: at, tr: bt, bl: Ut, br: ln, tex: jt, pixelOffsetTL: Dt, pixelOffsetBR: rn, minFontScaleX: Zt, minFontScaleY: Jt, glyphOffset: gt, isSDF: sn, sectionIndex: tn } = d[Ge], Cn = pe.vertexLength, Mi = gt[1];
            eg(oe, B.x, B.y, at.x, Mi + at.y, jt.x, jt.y, g, sn, Dt.x, Dt.y, Zt, Jt), eg(oe, B.x, B.y, bt.x, Mi + bt.y, jt.x + jt.w, jt.y, g, sn, rn.x, Dt.y, Zt, Jt), eg(oe, B.x, B.y, Ut.x, Mi + Ut.y, jt.x, jt.y + jt.h, g, sn, Dt.x, rn.y, Zt, Jt), eg(oe, B.x, B.y, ln.x, Mi + ln.y, jt.x + jt.w, jt.y + jt.h, g, sn, rn.x, rn.y, Zt, Jt), m0(o.dynamicLayoutVertexArray, B, He), ee.emplaceBack(Cn, Cn + 1, Cn + 2), ee.emplaceBack(Cn + 1, Cn + 2, Cn + 3), pe.vertexLength += 4, pe.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(gt[0]), Ge !== d.length - 1 && tn === d[Ge + 1].sectionIndex || o.programConfigurations.populatePaintArrays(oe.length, S, S.index, {}, Z, ke && ke[tn]);
          }
          o.placedSymbolArray.emplaceBack(B.x, B.y, we, this.glyphOffsetArray.length - we, Pe, k, j, B.segment, g ? g[0] : 0, g ? g[1] : 0, v[0], v[1], P, 0, !1, 0, q);
        }
        _addCollisionDebugVertex(o, d, g, v, w, S) {
          return d.emplaceBack(0, 0), o.emplaceBack(g.x, g.y, v, w, Math.round(S.x), Math.round(S.y));
        }
        addCollisionDebugVertices(o, d, g, v, w, S, P) {
          const B = w.segments.prepareSegment(4, w.layoutVertexArray, w.indexArray), k = B.vertexLength, j = w.layoutVertexArray, q = w.collisionVertexArray, Z = P.anchorX, ee = P.anchorY;
          this._addCollisionDebugVertex(j, q, S, Z, ee, new T(o, d)), this._addCollisionDebugVertex(j, q, S, Z, ee, new T(g, d)), this._addCollisionDebugVertex(j, q, S, Z, ee, new T(g, v)), this._addCollisionDebugVertex(j, q, S, Z, ee, new T(o, v)), B.vertexLength += 4;
          const oe = w.indexArray;
          oe.emplaceBack(k, k + 1), oe.emplaceBack(k + 1, k + 2), oe.emplaceBack(k + 2, k + 3), oe.emplaceBack(k + 3, k), B.primitiveLength += 4;
        }
        addDebugCollisionBoxes(o, d, g, v) {
          for (let w = o; w < d; w++) {
            const S = this.collisionBoxArray.get(w);
            this.addCollisionDebugVertices(S.x1, S.y1, S.x2, S.y2, v ? this.textCollisionBox : this.iconCollisionBox, S.anchorPoint, g);
          }
        }
        generateCollisionDebugBuffers() {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new y0(Rr, sb.members, Ei), this.iconCollisionBox = new y0(Rr, sb.members, Ei);
          for (let o = 0; o < this.symbolInstances.length; o++) {
            const d = this.symbolInstances.get(o);
            this.addDebugCollisionBoxes(d.textBoxStartIndex, d.textBoxEndIndex, d, !0), this.addDebugCollisionBoxes(d.verticalTextBoxStartIndex, d.verticalTextBoxEndIndex, d, !0), this.addDebugCollisionBoxes(d.iconBoxStartIndex, d.iconBoxEndIndex, d, !1), this.addDebugCollisionBoxes(d.verticalIconBoxStartIndex, d.verticalIconBoxEndIndex, d, !1);
          }
        }
        _deserializeCollisionBoxesForSymbol(o, d, g, v, w, S, P, B, k) {
          const j = {};
          for (let q = d; q < g; q++) {
            const Z = o.get(q);
            j.textBox = { x1: Z.x1, y1: Z.y1, x2: Z.x2, y2: Z.y2, anchorPointX: Z.anchorPointX, anchorPointY: Z.anchorPointY }, j.textFeatureIndex = Z.featureIndex;
            break;
          }
          for (let q = v; q < w; q++) {
            const Z = o.get(q);
            j.verticalTextBox = { x1: Z.x1, y1: Z.y1, x2: Z.x2, y2: Z.y2, anchorPointX: Z.anchorPointX, anchorPointY: Z.anchorPointY }, j.verticalTextFeatureIndex = Z.featureIndex;
            break;
          }
          for (let q = S; q < P; q++) {
            const Z = o.get(q);
            j.iconBox = { x1: Z.x1, y1: Z.y1, x2: Z.x2, y2: Z.y2, anchorPointX: Z.anchorPointX, anchorPointY: Z.anchorPointY }, j.iconFeatureIndex = Z.featureIndex;
            break;
          }
          for (let q = B; q < k; q++) {
            const Z = o.get(q);
            j.verticalIconBox = { x1: Z.x1, y1: Z.y1, x2: Z.x2, y2: Z.y2, anchorPointX: Z.anchorPointX, anchorPointY: Z.anchorPointY }, j.verticalIconFeatureIndex = Z.featureIndex;
            break;
          }
          return j;
        }
        deserializeCollisionBoxes(o) {
          this.collisionArrays = [];
          for (let d = 0; d < this.symbolInstances.length; d++) {
            const g = this.symbolInstances.get(d);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(o, g.textBoxStartIndex, g.textBoxEndIndex, g.verticalTextBoxStartIndex, g.verticalTextBoxEndIndex, g.iconBoxStartIndex, g.iconBoxEndIndex, g.verticalIconBoxStartIndex, g.verticalIconBoxEndIndex));
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }
        hasIconCollisionBoxData() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }
        addIndicesForPlacedSymbol(o, d) {
          const g = o.placedSymbolArray.get(d), v = g.vertexStartIndex + 4 * g.numGlyphs;
          for (let w = g.vertexStartIndex; w < v; w += 4)
            o.indexArray.emplaceBack(w, w + 1, w + 2), o.indexArray.emplaceBack(w + 1, w + 2, w + 3);
        }
        getSortedSymbolIndexes(o) {
          if (this.sortedAngle === o && this.symbolInstanceIndexes !== void 0)
            return this.symbolInstanceIndexes;
          const d = Math.sin(o), g = Math.cos(o), v = [], w = [], S = [];
          for (let P = 0; P < this.symbolInstances.length; ++P) {
            S.push(P);
            const B = this.symbolInstances.get(P);
            v.push(0 | Math.round(d * B.anchorX + g * B.anchorY)), w.push(B.featureIndex);
          }
          return S.sort((P, B) => v[P] - v[B] || w[B] - w[P]), S;
        }
        addToSortKeyRanges(o, d) {
          const g = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          g && g.sortKey === d ? g.symbolInstanceEnd = o + 1 : this.sortKeyRanges.push({ sortKey: d, symbolInstanceStart: o, symbolInstanceEnd: o + 1 });
        }
        sortFeatures(o) {
          if (this.sortFeaturesByY && this.sortedAngle !== o && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(o), this.sortedAngle = o, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (const d of this.symbolInstanceIndexes) {
              const g = this.symbolInstances.get(d);
              this.featureSortOrder.push(g.featureIndex), [g.rightJustifiedTextSymbolIndex, g.centerJustifiedTextSymbolIndex, g.leftJustifiedTextSymbolIndex].forEach((v, w, S) => {
                v >= 0 && S.indexOf(v) === w && this.addIndicesForPlacedSymbol(this.text, v);
              }), g.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, g.verticalPlacedTextSymbolIndex), g.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, g.placedIconSymbolIndex), g.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, g.verticalPlacedIconSymbolIndex);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      let Ab, Eb;
      zt("SymbolBucket", sd, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), sd.MAX_GLYPHS = 65535, sd.addDynamicAttributes = m0;
      var v0 = { get paint() {
        return Eb = Eb || new _({ "icon-opacity": new pn(re.paint_symbol["icon-opacity"]), "icon-color": new pn(re.paint_symbol["icon-color"]), "icon-halo-color": new pn(re.paint_symbol["icon-halo-color"]), "icon-halo-width": new pn(re.paint_symbol["icon-halo-width"]), "icon-halo-blur": new pn(re.paint_symbol["icon-halo-blur"]), "icon-translate": new en(re.paint_symbol["icon-translate"]), "icon-translate-anchor": new en(re.paint_symbol["icon-translate-anchor"]), "text-opacity": new pn(re.paint_symbol["text-opacity"]), "text-color": new pn(re.paint_symbol["text-color"], { runtimeType: qn, getOverride: (u) => u.textColor, hasOverride: (u) => !!u.textColor }), "text-halo-color": new pn(re.paint_symbol["text-halo-color"]), "text-halo-width": new pn(re.paint_symbol["text-halo-width"]), "text-halo-blur": new pn(re.paint_symbol["text-halo-blur"]), "text-translate": new en(re.paint_symbol["text-translate"]), "text-translate-anchor": new en(re.paint_symbol["text-translate-anchor"]) });
      }, get layout() {
        return Ab = Ab || new _({ "symbol-placement": new en(re.layout_symbol["symbol-placement"]), "symbol-spacing": new en(re.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new en(re.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new pn(re.layout_symbol["symbol-sort-key"]), "symbol-z-order": new en(re.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new en(re.layout_symbol["icon-allow-overlap"]), "icon-overlap": new en(re.layout_symbol["icon-overlap"]), "icon-ignore-placement": new en(re.layout_symbol["icon-ignore-placement"]), "icon-optional": new en(re.layout_symbol["icon-optional"]), "icon-rotation-alignment": new en(re.layout_symbol["icon-rotation-alignment"]), "icon-size": new pn(re.layout_symbol["icon-size"]), "icon-text-fit": new en(re.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new en(re.layout_symbol["icon-text-fit-padding"]), "icon-image": new pn(re.layout_symbol["icon-image"]), "icon-rotate": new pn(re.layout_symbol["icon-rotate"]), "icon-padding": new pn(re.layout_symbol["icon-padding"]), "icon-keep-upright": new en(re.layout_symbol["icon-keep-upright"]), "icon-offset": new pn(re.layout_symbol["icon-offset"]), "icon-anchor": new pn(re.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new en(re.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new en(re.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new en(re.layout_symbol["text-rotation-alignment"]), "text-field": new pn(re.layout_symbol["text-field"]), "text-font": new pn(re.layout_symbol["text-font"]), "text-size": new pn(re.layout_symbol["text-size"]), "text-max-width": new pn(re.layout_symbol["text-max-width"]), "text-line-height": new en(re.layout_symbol["text-line-height"]), "text-letter-spacing": new pn(re.layout_symbol["text-letter-spacing"]), "text-justify": new pn(re.layout_symbol["text-justify"]), "text-radial-offset": new pn(re.layout_symbol["text-radial-offset"]), "text-variable-anchor": new en(re.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new pn(re.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new pn(re.layout_symbol["text-anchor"]), "text-max-angle": new en(re.layout_symbol["text-max-angle"]), "text-writing-mode": new en(re.layout_symbol["text-writing-mode"]), "text-rotate": new pn(re.layout_symbol["text-rotate"]), "text-padding": new en(re.layout_symbol["text-padding"]), "text-keep-upright": new en(re.layout_symbol["text-keep-upright"]), "text-transform": new pn(re.layout_symbol["text-transform"]), "text-offset": new pn(re.layout_symbol["text-offset"]), "text-allow-overlap": new en(re.layout_symbol["text-allow-overlap"]), "text-overlap": new en(re.layout_symbol["text-overlap"]), "text-ignore-placement": new en(re.layout_symbol["text-ignore-placement"]), "text-optional": new en(re.layout_symbol["text-optional"]) });
      } };
      class Sb {
        constructor(o) {
          if (o.property.overrides === void 0)
            throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
          this.type = o.property.overrides ? o.property.overrides.runtimeType : bi, this.defaultValue = o;
        }
        evaluate(o) {
          if (o.formattedSection) {
            const d = this.defaultValue.property.overrides;
            if (d && d.hasOverride(o.formattedSection))
              return d.getOverride(o.formattedSection);
          }
          return o.feature && o.featureState ? this.defaultValue.evaluate(o.feature, o.featureState) : this.defaultValue.property.specification.default;
        }
        eachChild(o) {
          this.defaultValue.isConstant() || o(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return null;
        }
      }
      zt("FormatSectionOverride", Sb, { omit: ["defaultValue"] });
      class tg extends p {
        constructor(o) {
          super(o, v0);
        }
        recalculate(o, d) {
          if (super.recalculate(o, d), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
            const g = this.layout.get("text-writing-mode");
            if (g) {
              const v = [];
              for (const w of g)
                v.indexOf(w) < 0 && v.push(w);
              this.layout._values["text-writing-mode"] = v;
            } else
              this.layout._values["text-writing-mode"] = ["horizontal"];
          }
          this._setPaintOverrides();
        }
        getValueAndResolveTokens(o, d, g, v) {
          const w = this.layout.get(o).evaluate(d, {}, g, v), S = this._unevaluatedLayout._values[o];
          return S.isDataDriven() || Yr(S.value) || !w ? w : function(P, B) {
            return B.replace(/{([^{}]+)}/g, (k, j) => P && j in P ? String(P[j]) : "");
          }(d.properties, w);
        }
        createBucket(o) {
          return new sd(o);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          throw new Error("Should take a different path in FeatureIndex");
        }
        _setPaintOverrides() {
          for (const o of v0.paint.overridableProperties) {
            if (!tg.hasPaintOverride(this.layout, o))
              continue;
            const d = this.paint.get(o), g = new Sb(d), v = new so(g, d.property.specification);
            let w = null;
            w = d.value.kind === "constant" || d.value.kind === "source" ? new Yo("source", v) : new Ta("composite", v, d.value.zoomStops), this.paint._values[o] = new To(d.property, w, d.parameters);
          }
        }
        _handleOverridablePaintPropertyUpdate(o, d, g) {
          return !(!this.layout || d.isDataDriven() || g.isDataDriven()) && tg.hasPaintOverride(this.layout, o);
        }
        static hasPaintOverride(o, d) {
          const g = o.get("text-field"), v = v0.paint.properties[d];
          let w = !1;
          const S = (P) => {
            for (const B of P)
              if (v.overrides && v.overrides.hasOverride(B))
                return void (w = !0);
          };
          if (g.value.kind === "constant" && g.value.value instanceof Ri)
            S(g.value.value.sections);
          else if (g.value.kind === "source") {
            const P = (k) => {
              w || (k instanceof Wr && xi(k.value) === ii ? S(k.value.sections) : k instanceof Ol ? S(k.sections) : k.eachChild(P));
            }, B = g.value;
            B._styleExpression && P(B._styleExpression.expression);
          }
          return w;
        }
      }
      let Tb;
      var EC = { get paint() {
        return Tb = Tb || new _({ "background-color": new en(re.paint_background["background-color"]), "background-pattern": new a(re.paint_background["background-pattern"]), "background-opacity": new en(re.paint_background["background-opacity"]) });
      } };
      class SC extends p {
        constructor(o) {
          super(o, EC);
        }
      }
      let Cb;
      var TC = { get paint() {
        return Cb = Cb || new _({ "raster-opacity": new en(re.paint_raster["raster-opacity"]), "raster-hue-rotate": new en(re.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new en(re.paint_raster["raster-brightness-min"]), "raster-brightness-max": new en(re.paint_raster["raster-brightness-max"]), "raster-saturation": new en(re.paint_raster["raster-saturation"]), "raster-contrast": new en(re.paint_raster["raster-contrast"]), "raster-resampling": new en(re.paint_raster["raster-resampling"]), "raster-fade-duration": new en(re.paint_raster["raster-fade-duration"]) });
      } };
      class CC extends p {
        constructor(o) {
          super(o, TC);
        }
      }
      class IC extends p {
        constructor(o) {
          super(o, {}), this.onAdd = (d) => {
            this.implementation.onAdd && this.implementation.onAdd(d, d.painter.context.gl);
          }, this.onRemove = (d) => {
            this.implementation.onRemove && this.implementation.onRemove(d, d.painter.context.gl);
          }, this.implementation = o;
        }
        is3D() {
          return this.implementation.renderingMode === "3d";
        }
        hasOffscreenPass() {
          return this.implementation.prerender !== void 0;
        }
        recalculate() {
        }
        updateTransitions() {
        }
        hasTransition() {
          return !1;
        }
        serialize() {
          throw new Error("Custom layers cannot be serialized");
        }
      }
      class PC {
        constructor(o) {
          this._methodToThrottle = o, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
            this._triggered = !1, this._methodToThrottle();
          });
        }
        trigger() {
          this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
            this._triggered = !1, this._methodToThrottle();
          }, 0));
        }
        remove() {
          delete this._channel, this._methodToThrottle = () => {
          };
        }
      }
      const b0 = 63710088e-1;
      class Cu {
        constructor(o, d) {
          if (isNaN(o) || isNaN(d))
            throw new Error(`Invalid LngLat object: (${o}, ${d})`);
          if (this.lng = +o, this.lat = +d, this.lat > 90 || this.lat < -90)
            throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        }
        wrap() {
          return new Cu(De(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(o) {
          const d = Math.PI / 180, g = this.lat * d, v = o.lat * d, w = Math.sin(g) * Math.sin(v) + Math.cos(g) * Math.cos(v) * Math.cos((o.lng - this.lng) * d);
          return b0 * Math.acos(Math.min(w, 1));
        }
        static convert(o) {
          if (o instanceof Cu)
            return o;
          if (Array.isArray(o) && (o.length === 2 || o.length === 3))
            return new Cu(Number(o[0]), Number(o[1]));
          if (!Array.isArray(o) && typeof o == "object" && o !== null)
            return new Cu(Number("lng" in o ? o.lng : o.lon), Number(o.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        }
      }
      const Ib = 2 * Math.PI * b0;
      function Pb(u) {
        return Ib * Math.cos(u * Math.PI / 180);
      }
      function Lb(u) {
        return (180 + u) / 360;
      }
      function Mb(u) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + u * Math.PI / 360))) / 360;
      }
      function Bb(u, o) {
        return u / Pb(o);
      }
      function x0(u) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * u) * Math.PI / 180)) - 90;
      }
      class ng {
        constructor(o, d) {
          let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
          this.x = +o, this.y = +d, this.z = +g;
        }
        static fromLngLat(o) {
          let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          const g = Cu.convert(o);
          return new ng(Lb(g.lng), Mb(g.lat), Bb(d, g.lat));
        }
        toLngLat() {
          return new Cu(360 * this.x - 180, x0(this.y));
        }
        toAltitude() {
          return this.z * Pb(x0(this.y));
        }
        meterInMercatorCoordinateUnits() {
          return 1 / Ib * (o = x0(this.y), 1 / Math.cos(o * Math.PI / 180));
          var o;
        }
      }
      function Rb(u, o, d) {
        var g = 2 * Math.PI * 6378137 / 256 / Math.pow(2, d);
        return [u * g - 2 * Math.PI * 6378137 / 2, o * g - 2 * Math.PI * 6378137 / 2];
      }
      class w0 {
        constructor(o, d, g) {
          if (o < 0 || o > 25 || g < 0 || g >= Math.pow(2, o) || d < 0 || d >= Math.pow(2, o))
            throw new Error(`x=${d}, y=${g}, z=${o} outside of bounds. 0<=x<${Math.pow(2, o)}, 0<=y<${Math.pow(2, o)} 0<=z<=25 `);
          this.z = o, this.x = d, this.y = g, this.key = Cf(0, o, o, d, g);
        }
        equals(o) {
          return this.z === o.z && this.x === o.x && this.y === o.y;
        }
        url(o, d, g) {
          const v = (S = this.y, P = this.z, B = Rb(256 * (w = this.x), 256 * (S = Math.pow(2, P) - S - 1), P), k = Rb(256 * (w + 1), 256 * (S + 1), P), B[0] + "," + B[1] + "," + k[0] + "," + k[1]);
          var w, S, P, B, k;
          const j = function(q, Z, ee) {
            let oe, pe = "";
            for (let we = q; we > 0; we--)
              oe = 1 << we - 1, pe += (Z & oe ? 1 : 0) + (ee & oe ? 2 : 0);
            return pe;
          }(this.z, this.x, this.y);
          return o[(this.x + this.y) % o.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(g === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, d > 1 ? "@2x" : "").replace(/{quadkey}/g, j).replace(/{bbox-epsg-3857}/g, v);
        }
        isChildOf(o) {
          const d = this.z - o.z;
          return d > 0 && o.x === this.x >> d && o.y === this.y >> d;
        }
        getTilePoint(o) {
          const d = Math.pow(2, this.z);
          return new T((o.x * d - this.x) * ar, (o.y * d - this.y) * ar);
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }
      class Ob {
        constructor(o, d) {
          this.wrap = o, this.canonical = d, this.key = Cf(o, d.z, d.z, d.x, d.y);
        }
      }
      class na {
        constructor(o, d, g, v, w) {
          if (o < g)
            throw new Error(`overscaledZ should be >= z; overscaledZ = ${o}; z = ${g}`);
          this.overscaledZ = o, this.wrap = d, this.canonical = new w0(g, +v, +w), this.key = Cf(d, o, g, v, w);
        }
        clone() {
          return new na(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        equals(o) {
          return this.overscaledZ === o.overscaledZ && this.wrap === o.wrap && this.canonical.equals(o.canonical);
        }
        scaledTo(o) {
          if (o > this.overscaledZ)
            throw new Error(`targetZ > this.overscaledZ; targetZ = ${o}; overscaledZ = ${this.overscaledZ}`);
          const d = this.canonical.z - o;
          return o > this.canonical.z ? new na(o, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new na(o, this.wrap, o, this.canonical.x >> d, this.canonical.y >> d);
        }
        calculateScaledKey(o, d) {
          if (o > this.overscaledZ)
            throw new Error(`targetZ > this.overscaledZ; targetZ = ${o}; overscaledZ = ${this.overscaledZ}`);
          const g = this.canonical.z - o;
          return o > this.canonical.z ? Cf(this.wrap * +d, o, this.canonical.z, this.canonical.x, this.canonical.y) : Cf(this.wrap * +d, o, o, this.canonical.x >> g, this.canonical.y >> g);
        }
        isChildOf(o) {
          if (o.wrap !== this.wrap)
            return !1;
          const d = this.canonical.z - o.canonical.z;
          return o.overscaledZ === 0 || o.overscaledZ < this.overscaledZ && o.canonical.x === this.canonical.x >> d && o.canonical.y === this.canonical.y >> d;
        }
        children(o) {
          if (this.overscaledZ >= o)
            return [new na(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          const d = this.canonical.z + 1, g = 2 * this.canonical.x, v = 2 * this.canonical.y;
          return [new na(d, this.wrap, d, g, v), new na(d, this.wrap, d, g + 1, v), new na(d, this.wrap, d, g, v + 1), new na(d, this.wrap, d, g + 1, v + 1)];
        }
        isLessThan(o) {
          return this.wrap < o.wrap || !(this.wrap > o.wrap) && (this.overscaledZ < o.overscaledZ || !(this.overscaledZ > o.overscaledZ) && (this.canonical.x < o.canonical.x || !(this.canonical.x > o.canonical.x) && this.canonical.y < o.canonical.y));
        }
        wrapped() {
          return new na(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(o) {
          return new na(this.overscaledZ, o, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new Ob(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
        getTilePoint(o) {
          return this.canonical.getTilePoint(new ng(o.x - this.wrap, o.y));
        }
      }
      function Cf(u, o, d, g, v) {
        (u *= 2) < 0 && (u = -1 * u - 1);
        const w = 1 << d;
        return (w * w * u + w * v + g).toString(36) + d.toString(36) + o.toString(36);
      }
      zt("CanonicalTileID", w0), zt("OverscaledTileID", na, { omit: ["posMatrix"] });
      class Fb {
        constructor(o, d, g) {
          let v = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1, w = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1, S = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1, P = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 0;
          if (this.uid = o, d.height !== d.width)
            throw new RangeError("DEM tiles must be square");
          if (g && !["mapbox", "terrarium", "custom"].includes(g))
            return void Te(`"${g}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
          this.stride = d.height;
          const B = this.dim = d.height - 2;
          switch (this.data = new Uint32Array(d.data.buffer), g) {
            case "terrarium":
              this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
              break;
            case "custom":
              this.redFactor = v, this.greenFactor = w, this.blueFactor = S, this.baseShift = P;
              break;
            default:
              this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
          }
          for (let k = 0; k < B; k++)
            this.data[this._idx(-1, k)] = this.data[this._idx(0, k)], this.data[this._idx(B, k)] = this.data[this._idx(B - 1, k)], this.data[this._idx(k, -1)] = this.data[this._idx(k, 0)], this.data[this._idx(k, B)] = this.data[this._idx(k, B - 1)];
          this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(B, -1)] = this.data[this._idx(B - 1, 0)], this.data[this._idx(-1, B)] = this.data[this._idx(0, B - 1)], this.data[this._idx(B, B)] = this.data[this._idx(B - 1, B - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
          for (let k = 0; k < B; k++)
            for (let j = 0; j < B; j++) {
              const q = this.get(k, j);
              q > this.max && (this.max = q), q < this.min && (this.min = q);
            }
        }
        get(o, d) {
          const g = new Uint8Array(this.data.buffer), v = 4 * this._idx(o, d);
          return this.unpack(g[v], g[v + 1], g[v + 2]);
        }
        getUnpackVector() {
          return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
        }
        _idx(o, d) {
          if (o < -1 || o >= this.dim + 1 || d < -1 || d >= this.dim + 1)
            throw new RangeError("out of range source coordinates for DEM data");
          return (d + 1) * this.stride + (o + 1);
        }
        unpack(o, d, g) {
          return o * this.redFactor + d * this.greenFactor + g * this.blueFactor - this.baseShift;
        }
        getPixels() {
          return new ta({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
        }
        backfillBorder(o, d, g) {
          if (this.dim !== o.dim)
            throw new Error("dem dimension mismatch");
          let v = d * this.dim, w = d * this.dim + this.dim, S = g * this.dim, P = g * this.dim + this.dim;
          switch (d) {
            case -1:
              v = w - 1;
              break;
            case 1:
              w = v + 1;
          }
          switch (g) {
            case -1:
              S = P - 1;
              break;
            case 1:
              P = S + 1;
          }
          const B = -d * this.dim, k = -g * this.dim;
          for (let j = S; j < P; j++)
            for (let q = v; q < w; q++)
              this.data[this._idx(q, j)] = o.data[this._idx(q + B, j + k)];
        }
      }
      zt("DEMData", Fb);
      class Db {
        constructor(o) {
          this._stringToNumber = {}, this._numberToString = [];
          for (let d = 0; d < o.length; d++) {
            const g = o[d];
            this._stringToNumber[g] = d, this._numberToString[d] = g;
          }
        }
        encode(o) {
          return this._stringToNumber[o];
        }
        decode(o) {
          if (o >= this._numberToString.length)
            throw new Error(`Out of bounds. Index requested n=${o} can't be >= this._numberToString.length ${this._numberToString.length}`);
          return this._numberToString[o];
        }
      }
      class kb {
        constructor(o, d, g, v, w) {
          this.type = "Feature", this._vectorTileFeature = o, o._z = d, o._x = g, o._y = v, this.properties = o.properties, this.id = w;
        }
        get geometry() {
          return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
        }
        set geometry(o) {
          this._geometry = o;
        }
        toJSON() {
          const o = { geometry: this.geometry };
          for (const d in this)
            d !== "_geometry" && d !== "_vectorTileFeature" && (o[d] = this[d]);
          return o;
        }
      }
      class Nb {
        constructor(o, d) {
          this.tileID = o, this.x = o.canonical.x, this.y = o.canonical.y, this.z = o.canonical.z, this.grid = new Wl(ar, 16, 0), this.grid3D = new Wl(ar, 16, 0), this.featureIndexArray = new ki(), this.promoteId = d;
        }
        insert(o, d, g, v, w, S) {
          const P = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(g, v, w);
          const B = S ? this.grid3D : this.grid;
          for (let k = 0; k < d.length; k++) {
            const j = d[k], q = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let Z = 0; Z < j.length; Z++) {
              const ee = j[Z];
              q[0] = Math.min(q[0], ee.x), q[1] = Math.min(q[1], ee.y), q[2] = Math.max(q[2], ee.x), q[3] = Math.max(q[3], ee.y);
            }
            q[0] < ar && q[1] < ar && q[2] >= 0 && q[3] >= 0 && B.insert(P, q[0], q[1], q[2], q[3]);
          }
        }
        loadVTLayers() {
          return this.vtLayers || (this.vtLayers = new Eu.VectorTile(new u0(this.rawTileData)).layers, this.sourceLayerCoder = new Db(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
        }
        query(o, d, g, v) {
          this.loadVTLayers();
          const w = o.params || {}, S = ar / o.tileSize / o.scale, P = Gn(w.filter), B = o.queryGeometry, k = o.queryPadding * S, j = Ub(B), q = this.grid.query(j.minX - k, j.minY - k, j.maxX + k, j.maxY + k), Z = Ub(o.cameraQueryGeometry), ee = this.grid3D.query(Z.minX - k, Z.minY - k, Z.maxX + k, Z.maxY + k, (we, Pe, He, ke) => function(Ge, at, bt, Ut, ln) {
            for (const Dt of Ge)
              if (at <= Dt.x && bt <= Dt.y && Ut >= Dt.x && ln >= Dt.y)
                return !0;
            const jt = [new T(at, bt), new T(at, ln), new T(Ut, ln), new T(Ut, bt)];
            if (Ge.length > 2) {
              for (const Dt of jt)
                if (Kl(Ge, Dt))
                  return !0;
            }
            for (let Dt = 0; Dt < Ge.length - 1; Dt++)
              if (qp(Ge[Dt], Ge[Dt + 1], jt))
                return !0;
            return !1;
          }(o.cameraQueryGeometry, we - k, Pe - k, He + k, ke + k));
          for (const we of ee)
            q.push(we);
          q.sort(LC);
          const oe = {};
          let pe;
          for (let we = 0; we < q.length; we++) {
            const Pe = q[we];
            if (Pe === pe)
              continue;
            pe = Pe;
            const He = this.featureIndexArray.get(Pe);
            let ke = null;
            this.loadMatchingFeature(oe, He.bucketIndex, He.sourceLayerIndex, He.featureIndex, P, w.layers, w.availableImages, d, g, v, (Ge, at, bt) => (ke || (ke = Po(Ge)), at.queryIntersectsFeature(B, Ge, bt, ke, this.z, o.transform, S, o.pixelPosMatrix)));
          }
          return oe;
        }
        loadMatchingFeature(o, d, g, v, w, S, P, B, k, j, q) {
          const Z = this.bucketLayerIDs[d];
          if (S && !function(we, Pe) {
            for (let He = 0; He < we.length; He++)
              if (Pe.indexOf(we[He]) >= 0)
                return !0;
            return !1;
          }(S, Z))
            return;
          const ee = this.sourceLayerCoder.decode(g), oe = this.vtLayers[ee].feature(v);
          if (w.needGeometry) {
            const we = Nc(oe, !0);
            if (!w.filter(new pi(this.tileID.overscaledZ), we, this.tileID.canonical))
              return;
          } else if (!w.filter(new pi(this.tileID.overscaledZ), oe))
            return;
          const pe = this.getId(oe, ee);
          for (let we = 0; we < Z.length; we++) {
            const Pe = Z[we];
            if (S && S.indexOf(Pe) < 0)
              continue;
            const He = B[Pe];
            if (!He)
              continue;
            let ke = {};
            pe && j && (ke = j.getState(He.sourceLayer || "_geojsonTileLayer", pe));
            const Ge = Le({}, k[Pe]);
            Ge.paint = zb(Ge.paint, He.paint, oe, ke, P), Ge.layout = zb(Ge.layout, He.layout, oe, ke, P);
            const at = !q || q(oe, He, ke);
            if (!at)
              continue;
            const bt = new kb(oe, this.z, this.x, this.y, pe);
            bt.layer = Ge;
            let Ut = o[Pe];
            Ut === void 0 && (Ut = o[Pe] = []), Ut.push({ featureIndex: v, feature: bt, intersectionZ: at });
          }
        }
        lookupSymbolFeatures(o, d, g, v, w, S, P, B) {
          const k = {};
          this.loadVTLayers();
          const j = Gn(w);
          for (const q of o)
            this.loadMatchingFeature(k, g, v, q, j, S, P, B, d);
          return k;
        }
        hasLayer(o) {
          for (const d of this.bucketLayerIDs)
            for (const g of d)
              if (o === g)
                return !0;
          return !1;
        }
        getId(o, d) {
          let g = o.id;
          return this.promoteId && (g = o.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[d]], typeof g == "boolean" && (g = Number(g))), g;
        }
      }
      function zb(u, o, d, g, v) {
        return Ve(u, (w, S) => {
          const P = o instanceof mu ? o.get(S) : null;
          return P && P.evaluate ? P.evaluate(d, g, v) : P;
        });
      }
      function Ub(u) {
        let o = 1 / 0, d = 1 / 0, g = -1 / 0, v = -1 / 0;
        for (const w of u)
          o = Math.min(o, w.x), d = Math.min(d, w.y), g = Math.max(g, w.x), v = Math.max(v, w.y);
        return { minX: o, minY: d, maxX: g, maxY: v };
      }
      function LC(u, o) {
        return o - u;
      }
      function jb(u, o, d, g, v) {
        const w = [];
        for (let S = 0; S < u.length; S++) {
          const P = u[S];
          let B;
          for (let k = 0; k < P.length - 1; k++) {
            let j = P[k], q = P[k + 1];
            j.x < o && q.x < o || (j.x < o ? j = new T(o, j.y + (o - j.x) / (q.x - j.x) * (q.y - j.y))._round() : q.x < o && (q = new T(o, j.y + (o - j.x) / (q.x - j.x) * (q.y - j.y))._round()), j.y < d && q.y < d || (j.y < d ? j = new T(j.x + (d - j.y) / (q.y - j.y) * (q.x - j.x), d)._round() : q.y < d && (q = new T(j.x + (d - j.y) / (q.y - j.y) * (q.x - j.x), d)._round()), j.x >= g && q.x >= g || (j.x >= g ? j = new T(g, j.y + (g - j.x) / (q.x - j.x) * (q.y - j.y))._round() : q.x >= g && (q = new T(g, j.y + (g - j.x) / (q.x - j.x) * (q.y - j.y))._round()), j.y >= v && q.y >= v || (j.y >= v ? j = new T(j.x + (v - j.y) / (q.y - j.y) * (q.x - j.x), v)._round() : q.y >= v && (q = new T(j.x + (v - j.y) / (q.y - j.y) * (q.x - j.x), v)._round()), B && j.equals(B[B.length - 1]) || (B = [j], w.push(B)), B.push(q)))));
          }
        }
        return w;
      }
      zt("FeatureIndex", Nb, { omit: ["rawTileData", "sourceLayerCoder"] });
      class Iu extends T {
        constructor(o, d, g, v) {
          super(o, d), this.angle = g, v !== void 0 && (this.segment = v);
        }
        clone() {
          return new Iu(this.x, this.y, this.angle, this.segment);
        }
      }
      function Gb(u, o, d, g, v) {
        if (o.segment === void 0 || d === 0)
          return !0;
        let w = o, S = o.segment + 1, P = 0;
        for (; P > -d / 2; ) {
          if (S--, S < 0)
            return !1;
          P -= u[S].dist(w), w = u[S];
        }
        P += u[S].dist(u[S + 1]), S++;
        const B = [];
        let k = 0;
        for (; P < d / 2; ) {
          const j = u[S], q = u[S + 1];
          if (!q)
            return !1;
          let Z = u[S - 1].angleTo(j) - j.angleTo(q);
          for (Z = Math.abs((Z + 3 * Math.PI) % (2 * Math.PI) - Math.PI), B.push({ distance: P, angleDelta: Z }), k += Z; P - B[0].distance > g; )
            k -= B.shift().angleDelta;
          if (k > v)
            return !1;
          S++, P += j.dist(q);
        }
        return !0;
      }
      function Vb(u) {
        let o = 0;
        for (let d = 0; d < u.length - 1; d++)
          o += u[d].dist(u[d + 1]);
        return o;
      }
      function qb(u, o, d) {
        return u ? 0.6 * o * d : 0;
      }
      function Hb(u, o) {
        return Math.max(u ? u.right - u.left : 0, o ? o.right - o.left : 0);
      }
      function MC(u, o, d, g, v, w) {
        const S = qb(d, v, w), P = Hb(d, g) * w;
        let B = 0;
        const k = Vb(u) / 2;
        for (let j = 0; j < u.length - 1; j++) {
          const q = u[j], Z = u[j + 1], ee = q.dist(Z);
          if (B + ee > k) {
            const oe = (k - B) / ee, pe = Nr.number(q.x, Z.x, oe), we = Nr.number(q.y, Z.y, oe), Pe = new Iu(pe, we, Z.angleTo(q), j);
            return Pe._round(), !S || Gb(u, Pe, P, S, o) ? Pe : void 0;
          }
          B += ee;
        }
      }
      function BC(u, o, d, g, v, w, S, P, B) {
        const k = qb(g, w, S), j = Hb(g, v), q = j * S, Z = u[0].x === 0 || u[0].x === B || u[0].y === 0 || u[0].y === B;
        return o - q < o / 4 && (o = q + o / 4), Wb(u, Z ? o / 2 * P % o : (j / 2 + 2 * w) * S * P % o, o, k, d, q, Z, !1, B);
      }
      function Wb(u, o, d, g, v, w, S, P, B) {
        const k = w / 2, j = Vb(u);
        let q = 0, Z = o - d, ee = [];
        for (let oe = 0; oe < u.length - 1; oe++) {
          const pe = u[oe], we = u[oe + 1], Pe = pe.dist(we), He = we.angleTo(pe);
          for (; Z + d < q + Pe; ) {
            Z += d;
            const ke = (Z - q) / Pe, Ge = Nr.number(pe.x, we.x, ke), at = Nr.number(pe.y, we.y, ke);
            if (Ge >= 0 && Ge < B && at >= 0 && at < B && Z - k >= 0 && Z + k <= j) {
              const bt = new Iu(Ge, at, He, oe);
              bt._round(), g && !Gb(u, bt, w, g, v) || ee.push(bt);
            }
          }
          q += Pe;
        }
        return P || ee.length || S || (ee = Wb(u, q / 2, d, g, v, w, S, !0, B)), ee;
      }
      zt("Anchor", Iu);
      const od = fo;
      function Xb(u, o, d, g) {
        const v = [], w = u.image, S = w.pixelRatio, P = w.paddedRect.w - 2 * od, B = w.paddedRect.h - 2 * od;
        let k = { x1: u.left, y1: u.top, x2: u.right, y2: u.bottom };
        const j = w.stretchX || [[0, P]], q = w.stretchY || [[0, B]], Z = (gt, sn) => gt + sn[1] - sn[0], ee = j.reduce(Z, 0), oe = q.reduce(Z, 0), pe = P - ee, we = B - oe;
        let Pe = 0, He = ee, ke = 0, Ge = oe, at = 0, bt = pe, Ut = 0, ln = we;
        if (w.content && g) {
          const gt = w.content, sn = gt[2] - gt[0], tn = gt[3] - gt[1];
          (w.textFitWidth || w.textFitHeight) && (k = bb(u)), Pe = ig(j, 0, gt[0]), ke = ig(q, 0, gt[1]), He = ig(j, gt[0], gt[2]), Ge = ig(q, gt[1], gt[3]), at = gt[0] - Pe, Ut = gt[1] - ke, bt = sn - He, ln = tn - Ge;
        }
        const jt = k.x1, Dt = k.y1, rn = k.x2 - jt, Zt = k.y2 - Dt, Jt = (gt, sn, tn, Cn) => {
          const Mi = rg(gt.stretch - Pe, He, rn, jt), Ti = sg(gt.fixed - at, bt, gt.stretch, ee), jr = rg(sn.stretch - ke, Ge, Zt, Dt), ja = sg(sn.fixed - Ut, ln, sn.stretch, oe), ls = rg(tn.stretch - Pe, He, rn, jt), pr = sg(tn.fixed - at, bt, tn.stretch, ee), Ns = rg(Cn.stretch - ke, Ge, Zt, Dt), zs = sg(Cn.fixed - Ut, ln, Cn.stretch, oe), Us = new T(Mi, jr), gr = new T(ls, jr), Gr = new T(ls, Ns), Ss = new T(Mi, Ns), cs = new T(Ti / S, ja / S), js = new T(pr / S, zs / S), us = o * Math.PI / 180;
          if (us) {
            const oi = Math.sin(us), Ni = Math.cos(us), qi = [Ni, -oi, oi, Ni];
            Us._matMult(qi), gr._matMult(qi), Ss._matMult(qi), Gr._matMult(qi);
          }
          const ia = gt.stretch + gt.fixed, po = sn.stretch + sn.fixed;
          return { tl: Us, tr: gr, bl: Ss, br: Gr, tex: { x: w.paddedRect.x + od + ia, y: w.paddedRect.y + od + po, w: tn.stretch + tn.fixed - ia, h: Cn.stretch + Cn.fixed - po }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: cs, pixelOffsetBR: js, minFontScaleX: bt / S / rn, minFontScaleY: ln / S / Zt, isSDF: d };
        };
        if (g && (w.stretchX || w.stretchY)) {
          const gt = Jb(j, pe, ee), sn = Jb(q, we, oe);
          for (let tn = 0; tn < gt.length - 1; tn++) {
            const Cn = gt[tn], Mi = gt[tn + 1];
            for (let Ti = 0; Ti < sn.length - 1; Ti++)
              v.push(Jt(Cn, sn[Ti], Mi, sn[Ti + 1]));
          }
        } else
          v.push(Jt({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: P + 1 }, { fixed: 0, stretch: B + 1 }));
        return v;
      }
      function ig(u, o, d) {
        let g = 0;
        for (const v of u)
          g += Math.max(o, Math.min(d, v[1])) - Math.max(o, Math.min(d, v[0]));
        return g;
      }
      function Jb(u, o, d) {
        const g = [{ fixed: -od, stretch: 0 }];
        for (const [v, w] of u) {
          const S = g[g.length - 1];
          g.push({ fixed: v - S.stretch, stretch: S.stretch }), g.push({ fixed: v - S.stretch, stretch: S.stretch + (w - v) });
        }
        return g.push({ fixed: o + od, stretch: d }), g;
      }
      function rg(u, o, d, g) {
        return u / o * d + g;
      }
      function sg(u, o, d, g) {
        return u - o * d / g;
      }
      class og {
        constructor(o, d, g, v, w, S, P, B, k, j) {
          var q;
          if (this.boxStartIndex = o.length, k) {
            let Z = S.top, ee = S.bottom;
            const oe = S.collisionPadding;
            oe && (Z -= oe[1], ee += oe[3]);
            let pe = ee - Z;
            pe > 0 && (pe = Math.max(10, pe), this.circleDiameter = pe);
          } else {
            const Z = !((q = S.image) === null || q === void 0) && q.content && (S.image.textFitWidth || S.image.textFitHeight) ? bb(S) : { x1: S.left, y1: S.top, x2: S.right, y2: S.bottom };
            Z.y1 = Z.y1 * P - B[0], Z.y2 = Z.y2 * P + B[2], Z.x1 = Z.x1 * P - B[3], Z.x2 = Z.x2 * P + B[1];
            const ee = S.collisionPadding;
            if (ee && (Z.x1 -= ee[0] * P, Z.y1 -= ee[1] * P, Z.x2 += ee[2] * P, Z.y2 += ee[3] * P), j) {
              const oe = new T(Z.x1, Z.y1), pe = new T(Z.x2, Z.y1), we = new T(Z.x1, Z.y2), Pe = new T(Z.x2, Z.y2), He = j * Math.PI / 180;
              oe._rotate(He), pe._rotate(He), we._rotate(He), Pe._rotate(He), Z.x1 = Math.min(oe.x, pe.x, we.x, Pe.x), Z.x2 = Math.max(oe.x, pe.x, we.x, Pe.x), Z.y1 = Math.min(oe.y, pe.y, we.y, Pe.y), Z.y2 = Math.max(oe.y, pe.y, we.y, Pe.y);
            }
            o.emplaceBack(d.x, d.y, Z.x1, Z.y1, Z.x2, Z.y2, g, v, w);
          }
          this.boxEndIndex = o.length;
        }
      }
      class RC {
        constructor() {
          let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : OC;
          if (this.data = o, this.length = this.data.length, this.compare = d, this.length > 0)
            for (let g = (this.length >> 1) - 1; g >= 0; g--)
              this._down(g);
        }
        push(o) {
          this.data.push(o), this.length++, this._up(this.length - 1);
        }
        pop() {
          if (this.length === 0)
            return;
          const o = this.data[0], d = this.data.pop();
          return this.length--, this.length > 0 && (this.data[0] = d, this._down(0)), o;
        }
        peek() {
          return this.data[0];
        }
        _up(o) {
          const { data: d, compare: g } = this, v = d[o];
          for (; o > 0; ) {
            const w = o - 1 >> 1, S = d[w];
            if (g(v, S) >= 0)
              break;
            d[o] = S, o = w;
          }
          d[o] = v;
        }
        _down(o) {
          const { data: d, compare: g } = this, v = this.length >> 1, w = d[o];
          for (; o < v; ) {
            let S = 1 + (o << 1), P = d[S];
            const B = S + 1;
            if (B < this.length && g(d[B], P) < 0 && (S = B, P = d[B]), g(P, w) >= 0)
              break;
            d[o] = P, o = S;
          }
          d[o] = w;
        }
      }
      function OC(u, o) {
        return u < o ? -1 : u > o ? 1 : 0;
      }
      function FC(u) {
        let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, g = 1 / 0, v = 1 / 0, w = -1 / 0, S = -1 / 0;
        const P = u[0];
        for (let ee = 0; ee < P.length; ee++) {
          const oe = P[ee];
          (!ee || oe.x < g) && (g = oe.x), (!ee || oe.y < v) && (v = oe.y), (!ee || oe.x > w) && (w = oe.x), (!ee || oe.y > S) && (S = oe.y);
        }
        const B = Math.min(w - g, S - v);
        let k = B / 2;
        const j = new RC([], DC);
        if (B === 0)
          return new T(g, v);
        for (let ee = g; ee < w; ee += B)
          for (let oe = v; oe < S; oe += B)
            j.push(new ad(ee + k, oe + k, k, u));
        let q = function(ee) {
          let oe = 0, pe = 0, we = 0;
          const Pe = ee[0];
          for (let He = 0, ke = Pe.length, Ge = ke - 1; He < ke; Ge = He++) {
            const at = Pe[He], bt = Pe[Ge], Ut = at.x * bt.y - bt.x * at.y;
            pe += (at.x + bt.x) * Ut, we += (at.y + bt.y) * Ut, oe += 3 * Ut;
          }
          return new ad(pe / oe, we / oe, 0, ee);
        }(u), Z = j.length;
        for (; j.length; ) {
          const ee = j.pop();
          (ee.d > q.d || !q.d) && (q = ee, d && console.log("found best %d after %d probes", Math.round(1e4 * ee.d) / 1e4, Z)), ee.max - q.d <= o || (k = ee.h / 2, j.push(new ad(ee.p.x - k, ee.p.y - k, k, u)), j.push(new ad(ee.p.x + k, ee.p.y - k, k, u)), j.push(new ad(ee.p.x - k, ee.p.y + k, k, u)), j.push(new ad(ee.p.x + k, ee.p.y + k, k, u)), Z += 4);
        }
        return d && (console.log(`num probes: ${Z}`), console.log(`best distance: ${q.d}`)), q.p;
      }
      function DC(u, o) {
        return o.max - u.max;
      }
      function ad(u, o, d, g) {
        this.p = new T(u, o), this.h = d, this.d = function(v, w) {
          let S = !1, P = 1 / 0;
          for (let B = 0; B < w.length; B++) {
            const k = w[B];
            for (let j = 0, q = k.length, Z = q - 1; j < q; Z = j++) {
              const ee = k[j], oe = k[Z];
              ee.y > v.y != oe.y > v.y && v.x < (oe.x - ee.x) * (v.y - ee.y) / (oe.y - ee.y) + ee.x && (S = !S), P = Math.min(P, gl(v, ee, oe));
            }
          }
          return (S ? 1 : -1) * Math.sqrt(P);
        }(this.p, g), this.max = this.d + this.h * Math.SQRT2;
      }
      var as;
      c.ar = void 0, (as = c.ar || (c.ar = {}))[as.center = 1] = "center", as[as.left = 2] = "left", as[as.right = 3] = "right", as[as.top = 4] = "top", as[as.bottom = 5] = "bottom", as[as["top-left"] = 6] = "top-left", as[as["top-right"] = 7] = "top-right", as[as["bottom-left"] = 8] = "bottom-left", as[as["bottom-right"] = 9] = "bottom-right";
      const Pu = 7, A0 = Number.POSITIVE_INFINITY;
      function $b(u, o) {
        return o[1] !== A0 ? function(d, g, v) {
          let w = 0, S = 0;
          switch (g = Math.abs(g), v = Math.abs(v), d) {
            case "top-right":
            case "top-left":
            case "top":
              S = v - Pu;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              S = -v + Pu;
          }
          switch (d) {
            case "top-right":
            case "bottom-right":
            case "right":
              w = -g;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              w = g;
          }
          return [w, S];
        }(u, o[0], o[1]) : function(d, g) {
          let v = 0, w = 0;
          g < 0 && (g = 0);
          const S = g / Math.SQRT2;
          switch (d) {
            case "top-right":
            case "top-left":
              w = S - Pu;
              break;
            case "bottom-right":
            case "bottom-left":
              w = -S + Pu;
              break;
            case "bottom":
              w = -g + Pu;
              break;
            case "top":
              w = g - Pu;
          }
          switch (d) {
            case "top-right":
            case "bottom-right":
              v = -S;
              break;
            case "top-left":
            case "bottom-left":
              v = S;
              break;
            case "left":
              v = g;
              break;
            case "right":
              v = -g;
          }
          return [v, w];
        }(u, o[0]);
      }
      function Zb(u, o, d) {
        var g;
        const v = u.layout, w = (g = v.get("text-variable-anchor-offset")) === null || g === void 0 ? void 0 : g.evaluate(o, {}, d);
        if (w) {
          const P = w.values, B = [];
          for (let k = 0; k < P.length; k += 2) {
            const j = B[k] = P[k], q = P[k + 1].map((Z) => Z * Or);
            j.startsWith("top") ? q[1] -= Pu : j.startsWith("bottom") && (q[1] += Pu), B[k + 1] = q;
          }
          return new Ii(B);
        }
        const S = v.get("text-variable-anchor");
        if (S) {
          let P;
          P = u._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [v.get("text-radial-offset").evaluate(o, {}, d) * Or, A0] : v.get("text-offset").evaluate(o, {}, d).map((k) => k * Or);
          const B = [];
          for (const k of S)
            B.push(k, $b(k, P));
          return new Ii(B);
        }
        return null;
      }
      function E0(u) {
        switch (u) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function kC(u, o, d, g, v, w, S, P, B, k, j) {
        let q = w.textMaxSize.evaluate(o, {});
        q === void 0 && (q = S);
        const Z = u.layers[0].layout, ee = Z.get("icon-offset").evaluate(o, {}, j), oe = Kb(d.horizontal), pe = S / 24, we = u.tilePixelRatio * pe, Pe = u.tilePixelRatio * q / 24, He = u.tilePixelRatio * P, ke = u.tilePixelRatio * Z.get("symbol-spacing"), Ge = Z.get("text-padding") * u.tilePixelRatio, at = function(gt, sn, tn) {
          let Cn = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
          const Mi = gt.get("icon-padding").evaluate(sn, {}, tn), Ti = Mi && Mi.values;
          return [Ti[0] * Cn, Ti[1] * Cn, Ti[2] * Cn, Ti[3] * Cn];
        }(Z, o, j, u.tilePixelRatio), bt = Z.get("text-max-angle") / 180 * Math.PI, Ut = Z.get("text-rotation-alignment") !== "viewport" && Z.get("symbol-placement") !== "point", ln = Z.get("icon-rotation-alignment") === "map" && Z.get("symbol-placement") !== "point", jt = Z.get("symbol-placement"), Dt = ke / 2, rn = Z.get("icon-text-fit");
        let Zt;
        g && rn !== "none" && (u.allowVerticalPlacement && d.vertical && (Zt = xb(g, d.vertical, rn, Z.get("icon-text-fit-padding"), ee, pe)), oe && (g = xb(g, oe, rn, Z.get("icon-text-fit-padding"), ee, pe)));
        const Jt = (gt, sn) => {
          sn.x < 0 || sn.x >= ar || sn.y < 0 || sn.y >= ar || function(tn, Cn, Mi, Ti, jr, ja, ls, pr, Ns, zs, Us, gr, Gr, Ss, cs, js, us, ia, po, oi, Ni, qi, Lo, lr, ld) {
            const ec = tn.addToLineVertexArray(Cn, Mi);
            let tc, Ga, ra, ns, Uc = 0, Lf = 0, n2 = 0, i2 = 0, B0 = -1, R0 = -1;
            const jc = {};
            let r2 = yu("");
            if (tn.allowVerticalPlacement && Ti.vertical) {
              const Ts = pr.layout.get("text-rotate").evaluate(Ni, {}, lr) + 90;
              ra = new og(Ns, Cn, zs, Us, gr, Ti.vertical, Gr, Ss, cs, Ts), ls && (ns = new og(Ns, Cn, zs, Us, gr, ls, us, ia, cs, Ts));
            }
            if (jr) {
              const Ts = pr.layout.get("icon-rotate").evaluate(Ni, {}), sa = pr.layout.get("icon-text-fit") !== "none", _h = Xb(jr, Ts, Lo, sa), _l = ls ? Xb(ls, Ts, Lo, sa) : void 0;
              Ga = new og(Ns, Cn, zs, Us, gr, jr, us, ia, !1, Ts), Uc = 4 * _h.length;
              const yh = tn.iconSizeData;
              let nc = null;
              yh.kind === "source" ? (nc = [Ql * pr.layout.get("icon-size").evaluate(Ni, {})], nc[0] > Tu && Te(`${tn.layerIds[0]}: Value for "icon-size" is >= ${Tf}. Reduce your "icon-size".`)) : yh.kind === "composite" && (nc = [Ql * qi.compositeIconSizes[0].evaluate(Ni, {}, lr), Ql * qi.compositeIconSizes[1].evaluate(Ni, {}, lr)], (nc[0] > Tu || nc[1] > Tu) && Te(`${tn.layerIds[0]}: Value for "icon-size" is >= ${Tf}. Reduce your "icon-size".`)), tn.addSymbols(tn.icon, _h, nc, oi, po, Ni, c.ai.none, Cn, ec.lineStartIndex, ec.lineLength, -1, lr), B0 = tn.icon.placedSymbolArray.length - 1, _l && (Lf = 4 * _l.length, tn.addSymbols(tn.icon, _l, nc, oi, po, Ni, c.ai.vertical, Cn, ec.lineStartIndex, ec.lineLength, -1, lr), R0 = tn.icon.placedSymbolArray.length - 1);
            }
            const s2 = Object.keys(Ti.horizontal);
            for (const Ts of s2) {
              const sa = Ti.horizontal[Ts];
              if (!tc) {
                r2 = yu(sa.text);
                const _l = pr.layout.get("text-rotate").evaluate(Ni, {}, lr);
                tc = new og(Ns, Cn, zs, Us, gr, sa, Gr, Ss, cs, _l);
              }
              const _h = sa.positionedLines.length === 1;
              if (n2 += Yb(tn, Cn, sa, ja, pr, cs, Ni, js, ec, Ti.vertical ? c.ai.horizontal : c.ai.horizontalOnly, _h ? s2 : [Ts], jc, B0, qi, lr), _h)
                break;
            }
            Ti.vertical && (i2 += Yb(tn, Cn, Ti.vertical, ja, pr, cs, Ni, js, ec, c.ai.vertical, ["vertical"], jc, R0, qi, lr));
            const UC = tc ? tc.boxStartIndex : tn.collisionBoxArray.length, jC = tc ? tc.boxEndIndex : tn.collisionBoxArray.length, GC = ra ? ra.boxStartIndex : tn.collisionBoxArray.length, VC = ra ? ra.boxEndIndex : tn.collisionBoxArray.length, qC = Ga ? Ga.boxStartIndex : tn.collisionBoxArray.length, HC = Ga ? Ga.boxEndIndex : tn.collisionBoxArray.length, WC = ns ? ns.boxStartIndex : tn.collisionBoxArray.length, XC = ns ? ns.boxEndIndex : tn.collisionBoxArray.length;
            let ml = -1;
            const lg = (Ts, sa) => Ts && Ts.circleDiameter ? Math.max(Ts.circleDiameter, sa) : sa;
            ml = lg(tc, ml), ml = lg(ra, ml), ml = lg(Ga, ml), ml = lg(ns, ml);
            const o2 = ml > -1 ? 1 : 0;
            o2 && (ml *= ld / Or), tn.glyphOffsetArray.length >= sd.MAX_GLYPHS && Te("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), Ni.sortKey !== void 0 && tn.addToSortKeyRanges(tn.symbolInstances.length, Ni.sortKey);
            const JC = Zb(pr, Ni, lr), [$C, ZC] = function(Ts, sa) {
              const _h = Ts.length, _l = sa == null ? void 0 : sa.values;
              if ((_l == null ? void 0 : _l.length) > 0)
                for (let yh = 0; yh < _l.length; yh += 2) {
                  const nc = _l[yh + 1];
                  Ts.emplaceBack(c.ar[_l[yh]], nc[0], nc[1]);
                }
              return [_h, Ts.length];
            }(tn.textAnchorOffsets, JC);
            tn.symbolInstances.emplaceBack(Cn.x, Cn.y, jc.right >= 0 ? jc.right : -1, jc.center >= 0 ? jc.center : -1, jc.left >= 0 ? jc.left : -1, jc.vertical || -1, B0, R0, r2, UC, jC, GC, VC, qC, HC, WC, XC, zs, n2, i2, Uc, Lf, o2, 0, Gr, ml, $C, ZC);
          }(u, sn, gt, d, g, v, Zt, u.layers[0], u.collisionBoxArray, o.index, o.sourceLayerIndex, u.index, we, [Ge, Ge, Ge, Ge], Ut, B, He, at, ln, ee, o, w, k, j, S);
        };
        if (jt === "line")
          for (const gt of jb(o.geometry, 0, 0, ar, ar)) {
            const sn = BC(gt, ke, bt, d.vertical || oe, g, 24, Pe, u.overscaling, ar);
            for (const tn of sn)
              oe && NC(u, oe.text, Dt, tn) || Jt(gt, tn);
          }
        else if (jt === "line-center") {
          for (const gt of o.geometry)
            if (gt.length > 1) {
              const sn = MC(gt, bt, d.vertical || oe, g, 24, Pe);
              sn && Jt(gt, sn);
            }
        } else if (o.type === "Polygon")
          for (const gt of va(o.geometry, 0)) {
            const sn = FC(gt, 16);
            Jt(gt[0], new Iu(sn.x, sn.y, 0));
          }
        else if (o.type === "LineString")
          for (const gt of o.geometry)
            Jt(gt, new Iu(gt[0].x, gt[0].y, 0));
        else if (o.type === "Point")
          for (const gt of o.geometry)
            for (const sn of gt)
              Jt([sn], new Iu(sn.x, sn.y, 0));
      }
      function Yb(u, o, d, g, v, w, S, P, B, k, j, q, Z, ee, oe) {
        const pe = function(He, ke, Ge, at, bt, Ut, ln, jt) {
          const Dt = at.layout.get("text-rotate").evaluate(Ut, {}) * Math.PI / 180, rn = [];
          for (const Zt of ke.positionedLines)
            for (const Jt of Zt.positionedGlyphs) {
              if (!Jt.rect)
                continue;
              const gt = Jt.rect || {};
              let sn = fb + 1, tn = !0, Cn = 1, Mi = 0;
              const Ti = (bt || jt) && Jt.vertical, jr = Jt.metrics.advance * Jt.scale / 2;
              if (jt && ke.verticalizable && (Mi = Zt.lineOffset / 2 - (Jt.imageName ? -(Or - Jt.metrics.width * Jt.scale) / 2 : (Jt.scale - 1) * Or)), Jt.imageName) {
                const oi = ln[Jt.imageName];
                tn = oi.sdf, Cn = oi.pixelRatio, sn = fo / Cn;
              }
              const ja = bt ? [Jt.x + jr, Jt.y] : [0, 0];
              let ls = bt ? [0, 0] : [Jt.x + jr + Ge[0], Jt.y + Ge[1] - Mi], pr = [0, 0];
              Ti && (pr = ls, ls = [0, 0]);
              const Ns = Jt.metrics.isDoubleResolution ? 2 : 1, zs = (Jt.metrics.left - sn) * Jt.scale - jr + ls[0], Us = (-Jt.metrics.top - sn) * Jt.scale + ls[1], gr = zs + gt.w / Ns * Jt.scale / Cn, Gr = Us + gt.h / Ns * Jt.scale / Cn, Ss = new T(zs, Us), cs = new T(gr, Us), js = new T(zs, Gr), us = new T(gr, Gr);
              if (Ti) {
                const oi = new T(-jr, jr - Ef), Ni = -Math.PI / 2, qi = Or / 2 - jr, Lo = new T(5 - Ef - qi, -(Jt.imageName ? qi : 0)), lr = new T(...pr);
                Ss._rotateAround(Ni, oi)._add(Lo)._add(lr), cs._rotateAround(Ni, oi)._add(Lo)._add(lr), js._rotateAround(Ni, oi)._add(Lo)._add(lr), us._rotateAround(Ni, oi)._add(Lo)._add(lr);
              }
              if (Dt) {
                const oi = Math.sin(Dt), Ni = Math.cos(Dt), qi = [Ni, -oi, oi, Ni];
                Ss._matMult(qi), cs._matMult(qi), js._matMult(qi), us._matMult(qi);
              }
              const ia = new T(0, 0), po = new T(0, 0);
              rn.push({ tl: Ss, tr: cs, bl: js, br: us, tex: gt, writingMode: ke.writingMode, glyphOffset: ja, sectionIndex: Jt.sectionIndex, isSDF: tn, pixelOffsetTL: ia, pixelOffsetBR: po, minFontScaleX: 0, minFontScaleY: 0 });
            }
          return rn;
        }(0, d, P, v, w, S, g, u.allowVerticalPlacement), we = u.textSizeData;
        let Pe = null;
        we.kind === "source" ? (Pe = [Ql * v.layout.get("text-size").evaluate(S, {})], Pe[0] > Tu && Te(`${u.layerIds[0]}: Value for "text-size" is >= ${Tf}. Reduce your "text-size".`)) : we.kind === "composite" && (Pe = [Ql * ee.compositeTextSizes[0].evaluate(S, {}, oe), Ql * ee.compositeTextSizes[1].evaluate(S, {}, oe)], (Pe[0] > Tu || Pe[1] > Tu) && Te(`${u.layerIds[0]}: Value for "text-size" is >= ${Tf}. Reduce your "text-size".`)), u.addSymbols(u.text, pe, Pe, P, w, S, k, o, B.lineStartIndex, B.lineLength, Z, oe);
        for (const He of j)
          q[He] = u.text.placedSymbolArray.length - 1;
        return 4 * pe.length;
      }
      function Kb(u) {
        for (const o in u)
          return u[o];
        return null;
      }
      function NC(u, o, d, g) {
        const v = u.compareText;
        if (o in v) {
          const w = v[o];
          for (let S = w.length - 1; S >= 0; S--)
            if (g.dist(w[S]) < d)
              return !0;
        } else
          v[o] = [];
        return v[o].push(g), !1;
      }
      const Qb = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
      class S0 {
        static from(o) {
          if (!(o instanceof ArrayBuffer))
            throw new Error("Data must be an instance of ArrayBuffer.");
          const [d, g] = new Uint8Array(o, 0, 2);
          if (d !== 219)
            throw new Error("Data does not appear to be in a KDBush format.");
          const v = g >> 4;
          if (v !== 1)
            throw new Error(`Got v${v} data when expected v1.`);
          const w = Qb[15 & g];
          if (!w)
            throw new Error("Unrecognized array type.");
          const [S] = new Uint16Array(o, 2, 1), [P] = new Uint32Array(o, 4, 1);
          return new S0(P, S, w, o);
        }
        constructor(o) {
          let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, v = arguments.length > 3 ? arguments[3] : void 0;
          if (isNaN(o) || o < 0)
            throw new Error(`Unpexpected numItems value: ${o}.`);
          this.numItems = +o, this.nodeSize = Math.min(Math.max(+d, 2), 65535), this.ArrayType = g, this.IndexArrayType = o < 65536 ? Uint16Array : Uint32Array;
          const w = Qb.indexOf(this.ArrayType), S = 2 * o * this.ArrayType.BYTES_PER_ELEMENT, P = o * this.IndexArrayType.BYTES_PER_ELEMENT, B = (8 - P % 8) % 8;
          if (w < 0)
            throw new Error(`Unexpected typed array class: ${g}.`);
          v && v instanceof ArrayBuffer ? (this.data = v, this.ids = new this.IndexArrayType(this.data, 8, o), this.coords = new this.ArrayType(this.data, 8 + P + B, 2 * o), this._pos = 2 * o, this._finished = !0) : (this.data = new ArrayBuffer(8 + S + P + B), this.ids = new this.IndexArrayType(this.data, 8, o), this.coords = new this.ArrayType(this.data, 8 + P + B, 2 * o), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + w]), new Uint16Array(this.data, 2, 1)[0] = d, new Uint32Array(this.data, 4, 1)[0] = o);
        }
        add(o, d) {
          const g = this._pos >> 1;
          return this.ids[g] = g, this.coords[this._pos++] = o, this.coords[this._pos++] = d, g;
        }
        finish() {
          const o = this._pos >> 1;
          if (o !== this.numItems)
            throw new Error(`Added ${o} items when expected ${this.numItems}.`);
          return T0(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
        }
        range(o, d, g, v) {
          if (!this._finished)
            throw new Error("Data not yet indexed - call index.finish().");
          const { ids: w, coords: S, nodeSize: P } = this, B = [0, w.length - 1, 0], k = [];
          for (; B.length; ) {
            const j = B.pop() || 0, q = B.pop() || 0, Z = B.pop() || 0;
            if (q - Z <= P) {
              for (let we = Z; we <= q; we++) {
                const Pe = S[2 * we], He = S[2 * we + 1];
                Pe >= o && Pe <= g && He >= d && He <= v && k.push(w[we]);
              }
              continue;
            }
            const ee = Z + q >> 1, oe = S[2 * ee], pe = S[2 * ee + 1];
            oe >= o && oe <= g && pe >= d && pe <= v && k.push(w[ee]), (j === 0 ? o <= oe : d <= pe) && (B.push(Z), B.push(ee - 1), B.push(1 - j)), (j === 0 ? g >= oe : v >= pe) && (B.push(ee + 1), B.push(q), B.push(1 - j));
          }
          return k;
        }
        within(o, d, g) {
          if (!this._finished)
            throw new Error("Data not yet indexed - call index.finish().");
          const { ids: v, coords: w, nodeSize: S } = this, P = [0, v.length - 1, 0], B = [], k = g * g;
          for (; P.length; ) {
            const j = P.pop() || 0, q = P.pop() || 0, Z = P.pop() || 0;
            if (q - Z <= S) {
              for (let we = Z; we <= q; we++)
                t2(w[2 * we], w[2 * we + 1], o, d) <= k && B.push(v[we]);
              continue;
            }
            const ee = Z + q >> 1, oe = w[2 * ee], pe = w[2 * ee + 1];
            t2(oe, pe, o, d) <= k && B.push(v[ee]), (j === 0 ? o - g <= oe : d - g <= pe) && (P.push(Z), P.push(ee - 1), P.push(1 - j)), (j === 0 ? o + g >= oe : d + g >= pe) && (P.push(ee + 1), P.push(q), P.push(1 - j));
          }
          return B;
        }
      }
      function T0(u, o, d, g, v, w) {
        if (v - g <= d)
          return;
        const S = g + v >> 1;
        e2(u, o, S, g, v, w), T0(u, o, d, g, S - 1, 1 - w), T0(u, o, d, S + 1, v, 1 - w);
      }
      function e2(u, o, d, g, v, w) {
        for (; v > g; ) {
          if (v - g > 600) {
            const k = v - g + 1, j = d - g + 1, q = Math.log(k), Z = 0.5 * Math.exp(2 * q / 3), ee = 0.5 * Math.sqrt(q * Z * (k - Z) / k) * (j - k / 2 < 0 ? -1 : 1);
            e2(u, o, d, Math.max(g, Math.floor(d - j * Z / k + ee)), Math.min(v, Math.floor(d + (k - j) * Z / k + ee)), w);
          }
          const S = o[2 * d + w];
          let P = g, B = v;
          for (If(u, o, g, d), o[2 * v + w] > S && If(u, o, g, v); P < B; ) {
            for (If(u, o, P, B), P++, B--; o[2 * P + w] < S; )
              P++;
            for (; o[2 * B + w] > S; )
              B--;
          }
          o[2 * g + w] === S ? If(u, o, g, B) : (B++, If(u, o, B, v)), B <= d && (g = B + 1), d <= B && (v = B - 1);
        }
      }
      function If(u, o, d, g) {
        C0(u, d, g), C0(o, 2 * d, 2 * g), C0(o, 2 * d + 1, 2 * g + 1);
      }
      function C0(u, o, d) {
        const g = u[o];
        u[o] = u[d], u[d] = g;
      }
      function t2(u, o, d, g) {
        const v = u - d, w = o - g;
        return v * v + w * w;
      }
      var I0;
      c.bf = void 0, (I0 = c.bf || (c.bf = {})).create = "create", I0.load = "load", I0.fullLoad = "fullLoad";
      let ag = null, Pf = [];
      const P0 = 1e3 / 60, L0 = "loadTime", M0 = "fullLoadTime", zC = { mark(u) {
        performance.mark(u);
      }, frame(u) {
        const o = u;
        ag != null && Pf.push(o - ag), ag = o;
      }, clearMetrics() {
        ag = null, Pf = [], performance.clearMeasures(L0), performance.clearMeasures(M0);
        for (const u in c.bf)
          performance.clearMarks(c.bf[u]);
      }, getPerformanceMetrics() {
        performance.measure(L0, c.bf.create, c.bf.load), performance.measure(M0, c.bf.create, c.bf.fullLoad);
        const u = performance.getEntriesByName(L0)[0].duration, o = performance.getEntriesByName(M0)[0].duration, d = Pf.length, g = 1 / (Pf.reduce((w, S) => w + S, 0) / d / 1e3), v = Pf.filter((w) => w > P0).reduce((w, S) => w + (S - P0) / P0, 0);
        return { loadTime: u, fullLoadTime: o, fps: g, percentDroppedFrames: v / (d + v) * 100, totalFrames: d };
      } };
      c.$ = class extends U {
      }, c.A = Qh, c.B = ih, c.C = function(u) {
        if (st == null) {
          const o = u.navigator ? u.navigator.userAgent : null;
          st = !!u.safari || !(!o || !(/\b(iPad|iPhone|iPod)\b/.test(o) || o.match("Safari") && !o.match("Chrome")));
        }
        return st;
      }, c.D = en, c.E = ut, c.F = class {
        constructor(u, o) {
          this.target = u, this.mapId = o, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new PC(() => this.process()), this.subscription = function(d, g, v, w) {
            return d.addEventListener(g, v, !1), { unsubscribe: () => {
              d.removeEventListener(g, v, !1);
            } };
          }(this.target, "message", (d) => this.receive(d)), this.globalScope = tt(self) ? u : window;
        }
        registerMessageHandler(u, o) {
          this.messageHandlers[u] = o;
        }
        sendAsync(u, o) {
          return new Promise((d, g) => {
            const v = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
            this.resolveRejects[v] = { resolve: d, reject: g }, o && o.signal.addEventListener("abort", () => {
              delete this.resolveRejects[v];
              const P = { id: v, type: "<cancel>", origin: location.origin, targetMapId: u.targetMapId, sourceMapId: this.mapId };
              this.target.postMessage(P);
            }, { once: !0 });
            const w = [], S = Object.assign(Object.assign({}, u), { id: v, sourceMapId: this.mapId, origin: location.origin, data: Xl(u.data, w) });
            this.target.postMessage(S, { transfer: w });
          });
        }
        receive(u) {
          const o = u.data, d = o.id;
          if (!(o.origin !== "file://" && location.origin !== "file://" && o.origin !== location.origin || o.targetMapId && this.mapId !== o.targetMapId)) {
            if (o.type === "<cancel>") {
              delete this.tasks[d];
              const g = this.abortControllers[d];
              return delete this.abortControllers[d], void (g && g.abort());
            }
            if (tt(self) || o.mustQueue)
              return this.tasks[d] = o, this.taskQueue.push(d), void this.invoker.trigger();
            this.processTask(d, o);
          }
        }
        process() {
          if (this.taskQueue.length === 0)
            return;
          const u = this.taskQueue.shift(), o = this.tasks[u];
          delete this.tasks[u], this.taskQueue.length > 0 && this.invoker.trigger(), o && this.processTask(u, o);
        }
        processTask(u, o) {
          return l(this, void 0, void 0, function* () {
            if (o.type === "<response>") {
              const v = this.resolveRejects[u];
              return delete this.resolveRejects[u], v ? void (o.error ? v.reject(Br(o.error)) : v.resolve(Br(o.data))) : void 0;
            }
            if (!this.messageHandlers[o.type])
              return void this.completeTask(u, new Error(`Could not find a registered handler for ${o.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
            const d = Br(o.data), g = new AbortController();
            this.abortControllers[u] = g;
            try {
              const v = yield this.messageHandlers[o.type](o.sourceMapId, d, g);
              this.completeTask(u, null, v);
            } catch (v) {
              this.completeTask(u, v);
            }
          });
        }
        completeTask(u, o, d) {
          const g = [];
          delete this.abortControllers[u];
          const v = { id: u, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: o ? Xl(o) : null, data: Xl(d, g) };
          this.target.postMessage(v, { transfer: g });
        }
        remove() {
          this.invoker.remove(), this.subscription.unsubscribe();
        }
      }, c.G = qe, c.H = function() {
        var u = new Qh(16);
        return Qh != Float32Array && (u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0), u[0] = 1, u[5] = 1, u[10] = 1, u[15] = 1, u;
      }, c.I = d0, c.J = function(u, o, d) {
        var g, v, w, S, P, B, k, j, q, Z, ee, oe, pe = d[0], we = d[1], Pe = d[2];
        return o === u ? (u[12] = o[0] * pe + o[4] * we + o[8] * Pe + o[12], u[13] = o[1] * pe + o[5] * we + o[9] * Pe + o[13], u[14] = o[2] * pe + o[6] * we + o[10] * Pe + o[14], u[15] = o[3] * pe + o[7] * we + o[11] * Pe + o[15]) : (v = o[1], w = o[2], S = o[3], P = o[4], B = o[5], k = o[6], j = o[7], q = o[8], Z = o[9], ee = o[10], oe = o[11], u[0] = g = o[0], u[1] = v, u[2] = w, u[3] = S, u[4] = P, u[5] = B, u[6] = k, u[7] = j, u[8] = q, u[9] = Z, u[10] = ee, u[11] = oe, u[12] = g * pe + P * we + q * Pe + o[12], u[13] = v * pe + B * we + Z * Pe + o[13], u[14] = w * pe + k * we + ee * Pe + o[14], u[15] = S * pe + j * we + oe * Pe + o[15]), u;
      }, c.K = function(u, o, d) {
        var g = d[0], v = d[1], w = d[2];
        return u[0] = o[0] * g, u[1] = o[1] * g, u[2] = o[2] * g, u[3] = o[3] * g, u[4] = o[4] * v, u[5] = o[5] * v, u[6] = o[6] * v, u[7] = o[7] * v, u[8] = o[8] * w, u[9] = o[9] * w, u[10] = o[10] * w, u[11] = o[11] * w, u[12] = o[12], u[13] = o[13], u[14] = o[14], u[15] = o[15], u;
      }, c.L = Fv, c.M = function(u, o) {
        const d = {};
        for (let g = 0; g < o.length; g++) {
          const v = o[g];
          v in u && (d[v] = u[v]);
        }
        return d;
      }, c.N = Cu, c.O = Lb, c.P = T, c.Q = Mb, c.R = ta, c.S = na, c.T = ll, c.U = H, c.V = J, c.W = ht, c.X = ar, c.Y = M, c.Z = ng, c._ = l, c.a = Ce, c.a$ = function(u, o) {
        var d = u[0], g = u[1], v = u[2], w = u[3], S = u[4], P = u[5], B = u[6], k = u[7], j = u[8], q = u[9], Z = u[10], ee = u[11], oe = u[12], pe = u[13], we = u[14], Pe = u[15], He = o[0], ke = o[1], Ge = o[2], at = o[3], bt = o[4], Ut = o[5], ln = o[6], jt = o[7], Dt = o[8], rn = o[9], Zt = o[10], Jt = o[11], gt = o[12], sn = o[13], tn = o[14], Cn = o[15];
        return Math.abs(d - He) <= ks * Math.max(1, Math.abs(d), Math.abs(He)) && Math.abs(g - ke) <= ks * Math.max(1, Math.abs(g), Math.abs(ke)) && Math.abs(v - Ge) <= ks * Math.max(1, Math.abs(v), Math.abs(Ge)) && Math.abs(w - at) <= ks * Math.max(1, Math.abs(w), Math.abs(at)) && Math.abs(S - bt) <= ks * Math.max(1, Math.abs(S), Math.abs(bt)) && Math.abs(P - Ut) <= ks * Math.max(1, Math.abs(P), Math.abs(Ut)) && Math.abs(B - ln) <= ks * Math.max(1, Math.abs(B), Math.abs(ln)) && Math.abs(k - jt) <= ks * Math.max(1, Math.abs(k), Math.abs(jt)) && Math.abs(j - Dt) <= ks * Math.max(1, Math.abs(j), Math.abs(Dt)) && Math.abs(q - rn) <= ks * Math.max(1, Math.abs(q), Math.abs(rn)) && Math.abs(Z - Zt) <= ks * Math.max(1, Math.abs(Z), Math.abs(Zt)) && Math.abs(ee - Jt) <= ks * Math.max(1, Math.abs(ee), Math.abs(Jt)) && Math.abs(oe - gt) <= ks * Math.max(1, Math.abs(oe), Math.abs(gt)) && Math.abs(pe - sn) <= ks * Math.max(1, Math.abs(pe), Math.abs(sn)) && Math.abs(we - tn) <= ks * Math.max(1, Math.abs(we), Math.abs(tn)) && Math.abs(Pe - Cn) <= ks * Math.max(1, Math.abs(Pe), Math.abs(Cn));
      }, c.a0 = Vi, c.a1 = w0, c.a2 = mt, c.a3 = (u) => {
        const o = window.document.createElement("video");
        return o.muted = !0, new Promise((d) => {
          o.onloadstart = () => {
            d(o);
          };
          for (const g of u) {
            const v = window.document.createElement("source");
            At(g) || (o.crossOrigin = "Anonymous"), v.src = g, o.appendChild(v);
          }
        });
      }, c.a4 = function() {
        return ye++;
      }, c.a5 = Ot, c.a6 = sd, c.a7 = Gn, c.a8 = Nc, c.a9 = pi, c.aA = function(u) {
        u = u.slice();
        const o = /* @__PURE__ */ Object.create(null);
        for (let d = 0; d < u.length; d++)
          o[u[d].id] = u[d];
        for (let d = 0; d < u.length; d++)
          "ref" in u[d] && (u[d] = Qt(u[d], o[u[d].ref]));
        return u;
      }, c.aB = function(u) {
        if (u.type === "custom")
          return new IC(u);
        switch (u.type) {
          case "background":
            return new SC(u);
          case "circle":
            return new d3(u);
          case "fill":
            return new P3(u);
          case "fill-extrusion":
            return new q3(u);
          case "heatmap":
            return new p3(u);
          case "hillshade":
            return new m3(u);
          case "line":
            return new K3(u);
          case "raster":
            return new CC(u);
          case "symbol":
            return new tg(u);
        }
      }, c.aC = ae, c.aD = function(u, o) {
        if (!u)
          return [{ command: "setStyle", args: [o] }];
        let d = [];
        try {
          if (!pt(u.version, o.version))
            return [{ command: "setStyle", args: [o] }];
          pt(u.center, o.center) || d.push({ command: "setCenter", args: [o.center] }), pt(u.zoom, o.zoom) || d.push({ command: "setZoom", args: [o.zoom] }), pt(u.bearing, o.bearing) || d.push({ command: "setBearing", args: [o.bearing] }), pt(u.pitch, o.pitch) || d.push({ command: "setPitch", args: [o.pitch] }), pt(u.sprite, o.sprite) || d.push({ command: "setSprite", args: [o.sprite] }), pt(u.glyphs, o.glyphs) || d.push({ command: "setGlyphs", args: [o.glyphs] }), pt(u.transition, o.transition) || d.push({ command: "setTransition", args: [o.transition] }), pt(u.light, o.light) || d.push({ command: "setLight", args: [o.light] }), pt(u.terrain, o.terrain) || d.push({ command: "setTerrain", args: [o.terrain] }), pt(u.sky, o.sky) || d.push({ command: "setSky", args: [o.sky] }), pt(u.projection, o.projection) || d.push({ command: "setProjection", args: [o.projection] });
          const g = {}, v = [];
          (function(S, P, B, k) {
            let j;
            for (j in P = P || {}, S = S || {})
              Object.prototype.hasOwnProperty.call(S, j) && (Object.prototype.hasOwnProperty.call(P, j) || Ft(j, B, k));
            for (j in P)
              Object.prototype.hasOwnProperty.call(P, j) && (Object.prototype.hasOwnProperty.call(S, j) ? pt(S[j], P[j]) || (S[j].type === "geojson" && P[j].type === "geojson" && Tn(S, P, j) ? Et(B, { command: "setGeoJSONSourceData", args: [j, P[j].data] }) : nn(j, P, B, k)) : Lt(j, P, B));
          })(u.sources, o.sources, v, g);
          const w = [];
          u.layers && u.layers.forEach((S) => {
            "source" in S && g[S.source] ? d.push({ command: "removeLayer", args: [S.id] }) : w.push(S);
          }), d = d.concat(v), function(S, P, B) {
            P = P || [];
            const k = (S = S || []).map(On), j = P.map(On), q = S.reduce(Un, {}), Z = P.reduce(Un, {}), ee = k.slice(), oe = /* @__PURE__ */ Object.create(null);
            let pe, we, Pe, He, ke;
            for (let Ge = 0, at = 0; Ge < k.length; Ge++)
              pe = k[Ge], Object.prototype.hasOwnProperty.call(Z, pe) ? at++ : (Et(B, { command: "removeLayer", args: [pe] }), ee.splice(ee.indexOf(pe, at), 1));
            for (let Ge = 0, at = 0; Ge < j.length; Ge++)
              pe = j[j.length - 1 - Ge], ee[ee.length - 1 - Ge] !== pe && (Object.prototype.hasOwnProperty.call(q, pe) ? (Et(B, { command: "removeLayer", args: [pe] }), ee.splice(ee.lastIndexOf(pe, ee.length - at), 1)) : at++, He = ee[ee.length - Ge], Et(B, { command: "addLayer", args: [Z[pe], He] }), ee.splice(ee.length - Ge, 0, pe), oe[pe] = !0);
            for (let Ge = 0; Ge < j.length; Ge++)
              if (pe = j[Ge], we = q[pe], Pe = Z[pe], !oe[pe] && !pt(we, Pe))
                if (pt(we.source, Pe.source) && pt(we["source-layer"], Pe["source-layer"]) && pt(we.type, Pe.type)) {
                  for (ke in xn(we.layout, Pe.layout, B, pe, null, "setLayoutProperty"), xn(we.paint, Pe.paint, B, pe, null, "setPaintProperty"), pt(we.filter, Pe.filter) || Et(B, { command: "setFilter", args: [pe, Pe.filter] }), pt(we.minzoom, Pe.minzoom) && pt(we.maxzoom, Pe.maxzoom) || Et(B, { command: "setLayerZoomRange", args: [pe, Pe.minzoom, Pe.maxzoom] }), we)
                    Object.prototype.hasOwnProperty.call(we, ke) && ke !== "layout" && ke !== "paint" && ke !== "filter" && ke !== "metadata" && ke !== "minzoom" && ke !== "maxzoom" && (ke.indexOf("paint.") === 0 ? xn(we[ke], Pe[ke], B, pe, ke.slice(6), "setPaintProperty") : pt(we[ke], Pe[ke]) || Et(B, { command: "setLayerProperty", args: [pe, ke, Pe[ke]] }));
                  for (ke in Pe)
                    Object.prototype.hasOwnProperty.call(Pe, ke) && !Object.prototype.hasOwnProperty.call(we, ke) && ke !== "layout" && ke !== "paint" && ke !== "filter" && ke !== "metadata" && ke !== "minzoom" && ke !== "maxzoom" && (ke.indexOf("paint.") === 0 ? xn(we[ke], Pe[ke], B, pe, ke.slice(6), "setPaintProperty") : pt(we[ke], Pe[ke]) || Et(B, { command: "setLayerProperty", args: [pe, ke, Pe[ke]] }));
                } else
                  Et(B, { command: "removeLayer", args: [pe] }), He = ee[ee.lastIndexOf(pe) + 1], Et(B, { command: "addLayer", args: [Pe, He] });
          }(w, o.layers, d);
        } catch (g) {
          console.warn("Unable to compute style diff:", g), d = [{ command: "setStyle", args: [o] }];
        }
        return d;
      }, c.aE = function(u) {
        const o = [], d = u.id;
        return d === void 0 && o.push({ message: `layers.${d}: missing required property "id"` }), u.render === void 0 && o.push({ message: `layers.${d}: missing required method "render"` }), u.renderingMode && u.renderingMode !== "2d" && u.renderingMode !== "3d" && o.push({ message: `layers.${d}: property "renderingMode" must be either "2d" or "3d"` }), o;
      }, c.aF = function u(o, d) {
        if (Array.isArray(o)) {
          if (!Array.isArray(d) || o.length !== d.length)
            return !1;
          for (let g = 0; g < o.length; g++)
            if (!u(o[g], d[g]))
              return !1;
          return !0;
        }
        if (typeof o == "object" && o !== null && d !== null) {
          if (typeof d != "object" || Object.keys(o).length !== Object.keys(d).length)
            return !1;
          for (const g in o)
            if (!u(o[g], d[g]))
              return !1;
          return !0;
        }
        return o === d;
      }, c.aG = Ve, c.aH = Fe, c.aI = class extends Dc {
        constructor(u, o) {
          super(u, o), this.current = 0;
        }
        set(u) {
          this.current !== u && (this.current = u, this.gl.uniform1i(this.location, u));
        }
      }, c.aJ = hh, c.aK = class extends Dc {
        constructor(u, o) {
          super(u, o), this.current = Vp;
        }
        set(u) {
          if (u[12] !== this.current[12] || u[0] !== this.current[0])
            return this.current = u, void this.gl.uniformMatrix4fv(this.location, !1, u);
          for (let o = 1; o < 16; o++)
            if (u[o] !== this.current[o]) {
              this.current = u, this.gl.uniformMatrix4fv(this.location, !1, u);
              break;
            }
        }
      }, c.aL = dh, c.aM = lf, c.aN = Xn, c.aO = class extends Dc {
        constructor(u, o) {
          super(u, o), this.current = [0, 0, 0];
        }
        set(u) {
          u[0] === this.current[0] && u[1] === this.current[1] && u[2] === this.current[2] || (this.current = u, this.gl.uniform3f(this.location, u[0], u[1], u[2]));
        }
      }, c.aP = class extends Dc {
        constructor(u, o) {
          super(u, o), this.current = [0, 0];
        }
        set(u) {
          u[0] === this.current[0] && u[1] === this.current[1] || (this.current = u, this.gl.uniform2f(this.location, u[0], u[1]));
        }
      }, c.aQ = function(u, o, d, g, v, w, S) {
        var P = 1 / (o - d), B = 1 / (g - v), k = 1 / (w - S);
        return u[0] = -2 * P, u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = -2 * B, u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[10] = 2 * k, u[11] = 0, u[12] = (o + d) * P, u[13] = (v + g) * B, u[14] = (S + w) * k, u[15] = 1, u;
      }, c.aR = h3, c.aS = class extends Me {
      }, c.aT = nC, c.aU = class extends ot {
      }, c.aV = function(u) {
        return u <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(u) / Math.LN2));
      }, c.aW = Uv, c.aX = Ar, c.aY = nr, c.aZ = class extends vt {
      }, c.a_ = function(u, o) {
        return u[0] === o[0] && u[1] === o[1] && u[2] === o[2] && u[3] === o[3] && u[4] === o[4] && u[5] === o[5] && u[6] === o[6] && u[7] === o[7] && u[8] === o[8] && u[9] === o[9] && u[10] === o[10] && u[11] === o[11] && u[12] === o[12] && u[13] === o[13] && u[14] === o[14] && u[15] === o[15];
      }, c.aa = kb, c.ab = function(u) {
        const o = {};
        if (u.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (d, g, v, w) => {
          const S = v || w;
          return o[g] = !S || S.toLowerCase(), "";
        }), o["max-age"]) {
          const d = parseInt(o["max-age"], 10);
          isNaN(d) ? delete o["max-age"] : o["max-age"] = d;
        }
        return o;
      }, c.ac = function(u, o) {
        const d = [];
        for (const g in u)
          g in o || d.push(g);
        return d;
      }, c.ad = Se, c.ae = function(u, o, d) {
        var g = Math.sin(d), v = Math.cos(d), w = o[0], S = o[1], P = o[2], B = o[3], k = o[4], j = o[5], q = o[6], Z = o[7];
        return o !== u && (u[8] = o[8], u[9] = o[9], u[10] = o[10], u[11] = o[11], u[12] = o[12], u[13] = o[13], u[14] = o[14], u[15] = o[15]), u[0] = w * v + k * g, u[1] = S * v + j * g, u[2] = P * v + q * g, u[3] = B * v + Z * g, u[4] = k * v - w * g, u[5] = j * v - S * g, u[6] = q * v - P * g, u[7] = Z * v - B * g, u;
      }, c.af = function(u) {
        var o = new Qh(16);
        return o[0] = u[0], o[1] = u[1], o[2] = u[2], o[3] = u[3], o[4] = u[4], o[5] = u[5], o[6] = u[6], o[7] = u[7], o[8] = u[8], o[9] = u[9], o[10] = u[10], o[11] = u[11], o[12] = u[12], o[13] = u[13], o[14] = u[14], o[15] = u[15], o;
      }, c.ag = Hp, c.ah = function(u, o) {
        let d = 0, g = 0;
        if (u.kind === "constant")
          g = u.layoutSize;
        else if (u.kind !== "source") {
          const { interpolationType: v, minZoom: w, maxZoom: S } = u, P = v ? Se(yn.interpolationFactor(v, o, w, S), 0, 1) : 0;
          u.kind === "camera" ? g = Nr.number(u.minSize, u.maxSize, P) : d = P;
        }
        return { uSizeT: d, uSize: g };
      }, c.aj = function(u, o, d) {
        let { uSize: g, uSizeT: v } = o, { lowerSize: w, upperSize: S } = d;
        return u.kind === "source" ? w / Ql : u.kind === "composite" ? Nr.number(w / Ql, S / Ql, v) : g;
      }, c.ak = m0, c.al = function(u, o, d, g) {
        const v = o.y - u.y, w = o.x - u.x, S = g.y - d.y, P = g.x - d.x, B = S * w - P * v;
        if (B === 0)
          return null;
        const k = (P * (u.y - d.y) - S * (u.x - d.x)) / B;
        return new T(u.x + k * w, u.y + k * v);
      }, c.am = jb, c.an = pf, c.ao = Zm, c.ap = function(u) {
        let o = 1 / 0, d = 1 / 0, g = -1 / 0, v = -1 / 0;
        for (const w of u)
          o = Math.min(o, w.x), d = Math.min(d, w.y), g = Math.max(g, w.x), v = Math.max(v, w.y);
        return [o, d, g, v];
      }, c.aq = Or, c.as = g0, c.at = function(u, o) {
        var d = o[0], g = o[1], v = o[2], w = o[3], S = o[4], P = o[5], B = o[6], k = o[7], j = o[8], q = o[9], Z = o[10], ee = o[11], oe = o[12], pe = o[13], we = o[14], Pe = o[15], He = d * P - g * S, ke = d * B - v * S, Ge = d * k - w * S, at = g * B - v * P, bt = g * k - w * P, Ut = v * k - w * B, ln = j * pe - q * oe, jt = j * we - Z * oe, Dt = j * Pe - ee * oe, rn = q * we - Z * pe, Zt = q * Pe - ee * pe, Jt = Z * Pe - ee * we, gt = He * Jt - ke * Zt + Ge * rn + at * Dt - bt * jt + Ut * ln;
        return gt ? (u[0] = (P * Jt - B * Zt + k * rn) * (gt = 1 / gt), u[1] = (v * Zt - g * Jt - w * rn) * gt, u[2] = (pe * Ut - we * bt + Pe * at) * gt, u[3] = (Z * bt - q * Ut - ee * at) * gt, u[4] = (B * Dt - S * Jt - k * jt) * gt, u[5] = (d * Jt - v * Dt + w * jt) * gt, u[6] = (we * Ge - oe * Ut - Pe * ke) * gt, u[7] = (j * Ut - Z * Ge + ee * ke) * gt, u[8] = (S * Zt - P * Dt + k * ln) * gt, u[9] = (g * Dt - d * Zt - w * ln) * gt, u[10] = (oe * bt - pe * Ge + Pe * He) * gt, u[11] = (q * Ge - j * bt - ee * He) * gt, u[12] = (P * jt - S * rn - B * ln) * gt, u[13] = (d * rn - g * jt + v * ln) * gt, u[14] = (pe * ke - oe * at - we * He) * gt, u[15] = (j * at - q * ke + Z * He) * gt, u) : null;
      }, c.au = E0, c.av = p0, c.aw = S0, c.ax = function() {
        const u = {}, o = re.$version;
        for (const d in re.$root) {
          const g = re.$root[d];
          if (g.required) {
            let v = null;
            v = d === "version" ? o : g.type === "array" ? [] : {}, v != null && (u[d] = v);
          }
        }
        return u;
      }, c.ay = As, c.az = Ke, c.b = lt, c.b0 = function(u, o) {
        return u[0] = o[0], u[1] = o[1], u[2] = o[2], u[3] = o[3], u[4] = o[4], u[5] = o[5], u[6] = o[6], u[7] = o[7], u[8] = o[8], u[9] = o[9], u[10] = o[10], u[11] = o[11], u[12] = o[12], u[13] = o[13], u[14] = o[14], u[15] = o[15], u;
      }, c.b1 = function(u, o, d) {
        return u[0] = o[0] * d[0], u[1] = o[1] * d[1], u[2] = o[2] * d[2], u[3] = o[3] * d[3], u;
      }, c.b2 = function(u, o) {
        return u[0] * o[0] + u[1] * o[1] + u[2] * o[2] + u[3] * o[3];
      }, c.b3 = De, c.b4 = Ob, c.b5 = Bb, c.b6 = function(u, o, d, g, v) {
        var w, S = 1 / Math.tan(o / 2);
        return u[0] = S / d, u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = S, u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[11] = -1, u[12] = 0, u[13] = 0, u[15] = 0, v != null && v !== 1 / 0 ? (u[10] = (v + g) * (w = 1 / (g - v)), u[14] = 2 * v * g * w) : (u[10] = -1, u[14] = -2 * g), u;
      }, c.b7 = function(u, o, d) {
        var g = Math.sin(d), v = Math.cos(d), w = o[4], S = o[5], P = o[6], B = o[7], k = o[8], j = o[9], q = o[10], Z = o[11];
        return o !== u && (u[0] = o[0], u[1] = o[1], u[2] = o[2], u[3] = o[3], u[12] = o[12], u[13] = o[13], u[14] = o[14], u[15] = o[15]), u[4] = w * v + k * g, u[5] = S * v + j * g, u[6] = P * v + q * g, u[7] = B * v + Z * g, u[8] = k * v - w * g, u[9] = j * v - S * g, u[10] = q * v - P * g, u[11] = Z * v - B * g, u;
      }, c.b8 = ce, c.b9 = me, c.bA = function(u) {
        return u.message === se;
      }, c.bB = Kr, c.bC = Ds, c.ba = function(u) {
        return u * Math.PI / 180;
      }, c.bb = function(u, o) {
        return u[0] = o[0], u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = o[1], u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[10] = o[2], u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, u;
      }, c.bc = class extends D {
      }, c.bd = b0, c.be = zC, c.bg = We, c.bh = function(u, o) {
        Ce.REGISTERED_PROTOCOLS[u] = o;
      }, c.bi = function(u) {
        delete Ce.REGISTERED_PROTOCOLS[u];
      }, c.bj = function(u, o) {
        const d = {};
        for (let v = 0; v < u.length; v++) {
          const w = o && o[u[v].id] || du(u[v]);
          o && (o[u[v].id] = w);
          let S = d[w];
          S || (S = d[w] = []), S.push(u[v]);
        }
        const g = [];
        for (const v in d)
          g.push(d[v]);
        return g;
      }, c.bk = zt, c.bl = Db, c.bm = Nb, c.bn = gb, c.bo = function(u) {
        u.bucket.createArrays(), u.bucket.tilePixelRatio = ar / (512 * u.bucket.overscaling), u.bucket.compareText = {}, u.bucket.iconsNeedLinear = !1;
        const o = u.bucket.layers[0], d = o.layout, g = o._unevaluatedLayout._values, v = { layoutIconSize: g["icon-size"].possiblyEvaluate(new pi(u.bucket.zoom + 1), u.canonical), layoutTextSize: g["text-size"].possiblyEvaluate(new pi(u.bucket.zoom + 1), u.canonical), textMaxSize: g["text-size"].possiblyEvaluate(new pi(18)) };
        if (u.bucket.textSizeData.kind === "composite") {
          const { minZoom: k, maxZoom: j } = u.bucket.textSizeData;
          v.compositeTextSizes = [g["text-size"].possiblyEvaluate(new pi(k), u.canonical), g["text-size"].possiblyEvaluate(new pi(j), u.canonical)];
        }
        if (u.bucket.iconSizeData.kind === "composite") {
          const { minZoom: k, maxZoom: j } = u.bucket.iconSizeData;
          v.compositeIconSizes = [g["icon-size"].possiblyEvaluate(new pi(k), u.canonical), g["icon-size"].possiblyEvaluate(new pi(j), u.canonical)];
        }
        const w = d.get("text-line-height") * Or, S = d.get("text-rotation-alignment") !== "viewport" && d.get("symbol-placement") !== "point", P = d.get("text-keep-upright"), B = d.get("text-size");
        for (const k of u.bucket.features) {
          const j = d.get("text-font").evaluate(k, {}, u.canonical).join(","), q = B.evaluate(k, {}, u.canonical), Z = v.layoutTextSize.evaluate(k, {}, u.canonical), ee = v.layoutIconSize.evaluate(k, {}, u.canonical), oe = { horizontal: {}, vertical: void 0 }, pe = k.text;
          let we, Pe = [0, 0];
          if (pe) {
            const Ge = pe.toString(), at = d.get("text-letter-spacing").evaluate(k, {}, u.canonical) * Or, bt = Zh(Ge) ? at : 0, Ut = d.get("text-anchor").evaluate(k, {}, u.canonical), ln = Zb(o, k, u.canonical);
            if (!ln) {
              const Zt = d.get("text-radial-offset").evaluate(k, {}, u.canonical);
              Pe = Zt ? $b(Ut, [Zt * Or, A0]) : d.get("text-offset").evaluate(k, {}, u.canonical).map((Jt) => Jt * Or);
            }
            let jt = S ? "center" : d.get("text-justify").evaluate(k, {}, u.canonical);
            const Dt = d.get("symbol-placement") === "point" ? d.get("text-max-width").evaluate(k, {}, u.canonical) * Or : 1 / 0, rn = () => {
              u.bucket.allowVerticalPlacement && sh(Ge) && (oe.vertical = Kp(pe, u.glyphMap, u.glyphPositions, u.imagePositions, j, Dt, w, Ut, "left", bt, Pe, c.ai.vertical, !0, Z, q));
            };
            if (!S && ln) {
              const Zt = /* @__PURE__ */ new Set();
              if (jt === "auto")
                for (let gt = 0; gt < ln.values.length; gt += 2)
                  Zt.add(E0(ln.values[gt]));
              else
                Zt.add(jt);
              let Jt = !1;
              for (const gt of Zt)
                if (!oe.horizontal[gt])
                  if (Jt)
                    oe.horizontal[gt] = oe.horizontal[0];
                  else {
                    const sn = Kp(pe, u.glyphMap, u.glyphPositions, u.imagePositions, j, Dt, w, "center", gt, bt, Pe, c.ai.horizontal, !1, Z, q);
                    sn && (oe.horizontal[gt] = sn, Jt = sn.positionedLines.length === 1);
                  }
              rn();
            } else {
              jt === "auto" && (jt = E0(Ut));
              const Zt = Kp(pe, u.glyphMap, u.glyphPositions, u.imagePositions, j, Dt, w, Ut, jt, bt, Pe, c.ai.horizontal, !1, Z, q);
              Zt && (oe.horizontal[jt] = Zt), rn(), sh(Ge) && S && P && (oe.vertical = Kp(pe, u.glyphMap, u.glyphPositions, u.imagePositions, j, Dt, w, Ut, jt, bt, Pe, c.ai.vertical, !1, Z, q));
            }
          }
          let He = !1;
          if (k.icon && k.icon.name) {
            const Ge = u.imageMap[k.icon.name];
            Ge && (we = bC(u.imagePositions[k.icon.name], d.get("icon-offset").evaluate(k, {}, u.canonical), d.get("icon-anchor").evaluate(k, {}, u.canonical)), He = !!Ge.sdf, u.bucket.sdfIcons === void 0 ? u.bucket.sdfIcons = He : u.bucket.sdfIcons !== He && Te("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (Ge.pixelRatio !== u.bucket.pixelRatio || d.get("icon-rotate").constantOr(1) !== 0) && (u.bucket.iconsNeedLinear = !0));
          }
          const ke = Kb(oe.horizontal) || oe.vertical;
          u.bucket.iconsInText = !!ke && ke.iconsInText, (ke || we) && kC(u.bucket, k, oe, we, u.imageMap, v, Z, ee, Pe, He, u.canonical);
        }
        u.showCollisionBoxes && u.bucket.generateCollisionDebugBuffers();
      }, c.bp = l0, c.bq = s0, c.br = a0, c.bs = Eu, c.bt = u0, c.bu = class {
        constructor(u) {
          this._marks = { start: [u.url, "start"].join("#"), end: [u.url, "end"].join("#"), measure: u.url.toString() }, performance.mark(this._marks.start);
        }
        finish() {
          performance.mark(this._marks.end);
          let u = performance.getEntriesByName(this._marks.measure);
          return u.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), u = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), u;
        }
      }, c.bv = function(u, o, d, g, v) {
        return l(this, void 0, void 0, function* () {
          if (J())
            try {
              return yield ht(u, o, d, g, v);
            } catch {
            }
          return function(w, S, P, B, k) {
            const j = w.width, q = w.height;
            ct && Pt || (ct = new OffscreenCanvas(j, q), Pt = ct.getContext("2d", { willReadFrequently: !0 })), ct.width = j, ct.height = q, Pt.drawImage(w, 0, 0, j, q);
            const Z = Pt.getImageData(S, P, B, k);
            return Pt.clearRect(0, 0, j, q), Z.data;
          }(u, o, d, g, v);
        });
      }, c.bw = Fb, c.bx = m, c.by = y, c.bz = ob, c.c = Ae, c.d = (u) => l(void 0, void 0, void 0, function* () {
        if (u.byteLength === 0)
          return createImageBitmap(new ImageData(1, 1));
        const o = new Blob([new Uint8Array(u)], { type: "image/png" });
        try {
          return createImageBitmap(o);
        } catch (d) {
          throw new Error(`Could not load image because of ${d.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
        }
      }), c.e = Le, c.f = (u) => new Promise((o, d) => {
        const g = new Image();
        g.onload = () => {
          o(g), URL.revokeObjectURL(g.src), g.onload = null, window.requestAnimationFrame(() => {
            g.src = Ye;
          });
        }, g.onerror = () => d(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
        const v = new Blob([new Uint8Array(u)], { type: "image/png" });
        g.src = u.byteLength ? URL.createObjectURL(v) : Ye;
      }), c.g = Ue, c.h = (u, o) => Ze(Le(u, { type: "json" }), o), c.i = tt, c.j = on, c.k = kt, c.l = (u, o) => Ze(Le(u, { type: "arrayBuffer" }), o), c.m = Ze, c.n = function(u) {
        return new u0(u).readFields(fC, []);
      }, c.o = _f, c.p = pb, c.q = _, c.r = sf, c.s = At, c.t = rh, c.u = Vt, c.v = re, c.w = Te, c.x = ws, c.y = function(u) {
        let [o, d, g] = u;
        return d += 90, d *= Math.PI / 180, g *= Math.PI / 180, { x: o * Math.cos(d) * Math.sin(g), y: o * Math.sin(d) * Math.sin(g), z: o * Math.cos(g) };
      }, c.z = Nr;
    }), r("worker", ["./shared"], function(c) {
      class l {
        constructor(X) {
          this.keyCache = {}, X && this.replace(X);
        }
        replace(X) {
          this._layerConfigs = {}, this._layers = {}, this.update(X, []);
        }
        update(X, $) {
          for (const _e of X) {
            this._layerConfigs[_e.id] = _e;
            const Oe = this._layers[_e.id] = c.aB(_e);
            Oe._featureFilter = c.a7(Oe.filter), this.keyCache[_e.id] && delete this.keyCache[_e.id];
          }
          for (const _e of $)
            delete this.keyCache[_e], delete this._layerConfigs[_e], delete this._layers[_e];
          this.familiesBySource = {};
          const he = c.bj(Object.values(this._layerConfigs), this.keyCache);
          for (const _e of he) {
            const Oe = _e.map((Xe) => this._layers[Xe.id]), je = Oe[0];
            if (je.visibility === "none")
              continue;
            const Be = je.source || "";
            let Ie = this.familiesBySource[Be];
            Ie || (Ie = this.familiesBySource[Be] = {});
            const nt = je.sourceLayer || "_geojsonTileLayer";
            let ft = Ie[nt];
            ft || (ft = Ie[nt] = []), ft.push(Oe);
          }
        }
      }
      class m {
        constructor(X) {
          const $ = {}, he = [];
          for (const Be in X) {
            const Ie = X[Be], nt = $[Be] = {};
            for (const ft in Ie) {
              const Xe = Ie[+ft];
              if (!Xe || Xe.bitmap.width === 0 || Xe.bitmap.height === 0)
                continue;
              const xt = { x: 0, y: 0, w: Xe.bitmap.width + 2, h: Xe.bitmap.height + 2 };
              he.push(xt), nt[ft] = { rect: xt, metrics: Xe.metrics };
            }
          }
          const { w: _e, h: Oe } = c.p(he), je = new c.o({ width: _e || 1, height: Oe || 1 });
          for (const Be in X) {
            const Ie = X[Be];
            for (const nt in Ie) {
              const ft = Ie[+nt];
              if (!ft || ft.bitmap.width === 0 || ft.bitmap.height === 0)
                continue;
              const Xe = $[Be][nt].rect;
              c.o.copy(ft.bitmap, je, { x: 0, y: 0 }, { x: Xe.x + 1, y: Xe.y + 1 }, ft.bitmap);
            }
          }
          this.image = je, this.positions = $;
        }
      }
      c.bk("GlyphAtlas", m);
      class y {
        constructor(X) {
          this.tileID = new c.S(X.tileID.overscaledZ, X.tileID.wrap, X.tileID.canonical.z, X.tileID.canonical.x, X.tileID.canonical.y), this.uid = X.uid, this.zoom = X.zoom, this.pixelRatio = X.pixelRatio, this.tileSize = X.tileSize, this.source = X.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = X.showCollisionBoxes, this.collectResourceTiming = !!X.collectResourceTiming, this.returnDependencies = !!X.returnDependencies, this.promoteId = X.promoteId, this.inFlightDependencies = [];
        }
        parse(X, $, he, _e) {
          return c._(this, void 0, void 0, function* () {
            this.status = "parsing", this.data = X, this.collisionBoxArray = new c.a5();
            const Oe = new c.bl(Object.keys(X.layers).sort()), je = new c.bm(this.tileID, this.promoteId);
            je.bucketLayerIDs = [];
            const Be = {}, Ie = { featureIndex: je, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: he }, nt = $.familiesBySource[this.source];
            for (const dn in nt) {
              const Dn = X.layers[dn];
              if (!Dn)
                continue;
              Dn.version === 1 && c.w(`Vector tile source "${this.source}" layer "${dn}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
              const Jn = Oe.encode(dn), di = [];
              for (let Bi = 0; Bi < Dn.length; Bi++) {
                const Xi = Dn.feature(Bi), yo = je.getId(Xi, dn);
                di.push({ feature: Xi, id: yo, index: Bi, sourceLayerIndex: Jn });
              }
              for (const Bi of nt[dn]) {
                const Xi = Bi[0];
                Xi.source !== this.source && c.w(`layer.source = ${Xi.source} does not equal this.source = ${this.source}`), Xi.minzoom && this.zoom < Math.floor(Xi.minzoom) || Xi.maxzoom && this.zoom >= Xi.maxzoom || Xi.visibility !== "none" && (A(Bi, this.zoom, he), (Be[Xi.id] = Xi.createBucket({ index: je.bucketLayerIDs.length, layers: Bi, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: Jn, sourceID: this.source })).populate(di, Ie, this.tileID.canonical), je.bucketLayerIDs.push(Bi.map((yo) => yo.id)));
              }
            }
            const ft = c.aG(Ie.glyphDependencies, (dn) => Object.keys(dn).map(Number));
            this.inFlightDependencies.forEach((dn) => dn == null ? void 0 : dn.abort()), this.inFlightDependencies = [];
            let Xe = Promise.resolve({});
            if (Object.keys(ft).length) {
              const dn = new AbortController();
              this.inFlightDependencies.push(dn), Xe = _e.sendAsync({ type: "GG", data: { stacks: ft, source: this.source, tileID: this.tileID, type: "glyphs" } }, dn);
            }
            const xt = Object.keys(Ie.iconDependencies);
            let $t = Promise.resolve({});
            if (xt.length) {
              const dn = new AbortController();
              this.inFlightDependencies.push(dn), $t = _e.sendAsync({ type: "GI", data: { icons: xt, source: this.source, tileID: this.tileID, type: "icons" } }, dn);
            }
            const Kt = Object.keys(Ie.patternDependencies);
            let _n = Promise.resolve({});
            if (Kt.length) {
              const dn = new AbortController();
              this.inFlightDependencies.push(dn), _n = _e.sendAsync({ type: "GI", data: { icons: Kt, source: this.source, tileID: this.tileID, type: "patterns" } }, dn);
            }
            const [An, an, Fn] = yield Promise.all([Xe, $t, _n]), Yn = new m(An), Kn = new c.bn(an, Fn);
            for (const dn in Be) {
              const Dn = Be[dn];
              Dn instanceof c.a6 ? (A(Dn.layers, this.zoom, he), c.bo({ bucket: Dn, glyphMap: An, glyphPositions: Yn.positions, imageMap: an, imagePositions: Kn.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical })) : Dn.hasPattern && (Dn instanceof c.bp || Dn instanceof c.bq || Dn instanceof c.br) && (A(Dn.layers, this.zoom, he), Dn.addFeatures(Ie, this.tileID.canonical, Kn.patternPositions));
            }
            return this.status = "done", { buckets: Object.values(Be).filter((dn) => !dn.isEmpty()), featureIndex: je, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: Yn.image, imageAtlas: Kn, glyphMap: this.returnDependencies ? An : null, iconMap: this.returnDependencies ? an : null, glyphPositions: this.returnDependencies ? Yn.positions : null };
          });
        }
      }
      function A(ve, X, $) {
        const he = new c.a9(X);
        for (const _e of ve)
          _e.recalculate(he, $);
      }
      class T {
        constructor(X, $, he) {
          this.actor = X, this.layerIndex = $, this.availableImages = he, this.fetching = {}, this.loading = {}, this.loaded = {};
        }
        loadVectorTile(X, $) {
          return c._(this, void 0, void 0, function* () {
            const he = yield c.l(X.request, $);
            try {
              return { vectorTile: new c.bs.VectorTile(new c.bt(he.data)), rawData: he.data, cacheControl: he.cacheControl, expires: he.expires };
            } catch (_e) {
              const Oe = new Uint8Array(he.data);
              let je = `Unable to parse the tile at ${X.request.url}, `;
              throw je += Oe[0] === 31 && Oe[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${_e.message}`, new Error(je);
            }
          });
        }
        loadTile(X) {
          return c._(this, void 0, void 0, function* () {
            const $ = X.uid, he = !!(X && X.request && X.request.collectResourceTiming) && new c.bu(X.request), _e = new y(X);
            this.loading[$] = _e;
            const Oe = new AbortController();
            _e.abort = Oe;
            try {
              const je = yield this.loadVectorTile(X, Oe);
              if (delete this.loading[$], !je)
                return null;
              const Be = je.rawData, Ie = {};
              je.expires && (Ie.expires = je.expires), je.cacheControl && (Ie.cacheControl = je.cacheControl);
              const nt = {};
              if (he) {
                const Xe = he.finish();
                Xe && (nt.resourceTiming = JSON.parse(JSON.stringify(Xe)));
              }
              _e.vectorTile = je.vectorTile;
              const ft = _e.parse(je.vectorTile, this.layerIndex, this.availableImages, this.actor);
              this.loaded[$] = _e, this.fetching[$] = { rawTileData: Be, cacheControl: Ie, resourceTiming: nt };
              try {
                const Xe = yield ft;
                return c.e({ rawTileData: Be.slice(0) }, Xe, Ie, nt);
              } finally {
                delete this.fetching[$];
              }
            } catch (je) {
              throw delete this.loading[$], _e.status = "done", this.loaded[$] = _e, je;
            }
          });
        }
        reloadTile(X) {
          return c._(this, void 0, void 0, function* () {
            const $ = X.uid;
            if (!this.loaded || !this.loaded[$])
              throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
            const he = this.loaded[$];
            if (he.showCollisionBoxes = X.showCollisionBoxes, he.status === "parsing") {
              const _e = yield he.parse(he.vectorTile, this.layerIndex, this.availableImages, this.actor);
              let Oe;
              if (this.fetching[$]) {
                const { rawTileData: je, cacheControl: Be, resourceTiming: Ie } = this.fetching[$];
                delete this.fetching[$], Oe = c.e({ rawTileData: je.slice(0) }, _e, Be, Ie);
              } else
                Oe = _e;
              return Oe;
            }
            if (he.status === "done" && he.vectorTile)
              return he.parse(he.vectorTile, this.layerIndex, this.availableImages, this.actor);
          });
        }
        abortTile(X) {
          return c._(this, void 0, void 0, function* () {
            const $ = this.loading, he = X.uid;
            $ && $[he] && $[he].abort && ($[he].abort.abort(), delete $[he]);
          });
        }
        removeTile(X) {
          return c._(this, void 0, void 0, function* () {
            this.loaded && this.loaded[X.uid] && delete this.loaded[X.uid];
          });
        }
      }
      class I {
        constructor() {
          this.loaded = {};
        }
        loadTile(X) {
          return c._(this, void 0, void 0, function* () {
            const { uid: $, encoding: he, rawImageData: _e, redFactor: Oe, greenFactor: je, blueFactor: Be, baseShift: Ie } = X, nt = _e.width + 2, ft = _e.height + 2, Xe = c.b(_e) ? new c.R({ width: nt, height: ft }, yield c.bv(_e, -1, -1, nt, ft)) : _e, xt = new c.bw($, Xe, he, Oe, je, Be, Ie);
            return this.loaded = this.loaded || {}, this.loaded[$] = xt, xt;
          });
        }
        removeTile(X) {
          const $ = this.loaded, he = X.uid;
          $ && $[he] && delete $[he];
        }
      }
      function L(ve, X) {
        if (ve.length !== 0) {
          N(ve[0], X);
          for (var $ = 1; $ < ve.length; $++)
            N(ve[$], !X);
        }
      }
      function N(ve, X) {
        for (var $ = 0, he = 0, _e = 0, Oe = ve.length, je = Oe - 1; _e < Oe; je = _e++) {
          var Be = (ve[_e][0] - ve[je][0]) * (ve[je][1] + ve[_e][1]), Ie = $ + Be;
          he += Math.abs($) >= Math.abs(Be) ? $ - Ie + Be : Be - Ie + $, $ = Ie;
        }
        $ + he >= 0 != !!X && ve.reverse();
      }
      var z = c.bx(function ve(X, $) {
        var he, _e = X && X.type;
        if (_e === "FeatureCollection")
          for (he = 0; he < X.features.length; he++)
            ve(X.features[he], $);
        else if (_e === "GeometryCollection")
          for (he = 0; he < X.geometries.length; he++)
            ve(X.geometries[he], $);
        else if (_e === "Feature")
          ve(X.geometry, $);
        else if (_e === "Polygon")
          L(X.coordinates, $);
        else if (_e === "MultiPolygon")
          for (he = 0; he < X.coordinates.length; he++)
            L(X.coordinates[he], $);
        return X;
      });
      const V = c.bs.VectorTileFeature.prototype.toGeoJSON;
      var H = { exports: {} }, J = c.by, ce = c.bs.VectorTileFeature, me = Se;
      function Se(ve, X) {
        this.options = X || {}, this.features = ve, this.length = ve.length;
      }
      function De(ve, X) {
        this.id = typeof ve.id == "number" ? ve.id : void 0, this.type = ve.type, this.rawGeometry = ve.type === 1 ? [ve.geometry] : ve.geometry, this.properties = ve.tags, this.extent = X || 4096;
      }
      Se.prototype.feature = function(ve) {
        return new De(this.features[ve], this.options.extent);
      }, De.prototype.loadGeometry = function() {
        var ve = this.rawGeometry;
        this.geometry = [];
        for (var X = 0; X < ve.length; X++) {
          for (var $ = ve[X], he = [], _e = 0; _e < $.length; _e++)
            he.push(new J($[_e][0], $[_e][1]));
          this.geometry.push(he);
        }
        return this.geometry;
      }, De.prototype.bbox = function() {
        this.geometry || this.loadGeometry();
        for (var ve = this.geometry, X = 1 / 0, $ = -1 / 0, he = 1 / 0, _e = -1 / 0, Oe = 0; Oe < ve.length; Oe++)
          for (var je = ve[Oe], Be = 0; Be < je.length; Be++) {
            var Ie = je[Be];
            X = Math.min(X, Ie.x), $ = Math.max($, Ie.x), he = Math.min(he, Ie.y), _e = Math.max(_e, Ie.y);
          }
        return [X, he, $, _e];
      }, De.prototype.toGeoJSON = ce.prototype.toGeoJSON;
      var Le = c.bz, ye = me;
      function Ve(ve) {
        var X = new Le();
        return function($, he) {
          for (var _e in $.layers)
            he.writeMessage(3, Fe, $.layers[_e]);
        }(ve, X), X.finish();
      }
      function Fe(ve, X) {
        var $;
        X.writeVarintField(15, ve.version || 1), X.writeStringField(1, ve.name || ""), X.writeVarintField(5, ve.extent || 4096);
        var he = { keys: [], values: [], keycache: {}, valuecache: {} };
        for ($ = 0; $ < ve.length; $++)
          he.feature = ve.feature($), X.writeMessage(2, ae, he);
        var _e = he.keys;
        for ($ = 0; $ < _e.length; $++)
          X.writeStringField(3, _e[$]);
        var Oe = he.values;
        for ($ = 0; $ < Oe.length; $++)
          X.writeMessage(4, st, Oe[$]);
      }
      function ae(ve, X) {
        var $ = ve.feature;
        $.id !== void 0 && X.writeVarintField(1, $.id), X.writeMessage(2, de, ve), X.writeVarintField(3, $.type), X.writeMessage(4, tt, $);
      }
      function de(ve, X) {
        var $ = ve.feature, he = ve.keys, _e = ve.values, Oe = ve.keycache, je = ve.valuecache;
        for (var Be in $.properties) {
          var Ie = $.properties[Be], nt = Oe[Be];
          if (Ie !== null) {
            nt === void 0 && (he.push(Be), Oe[Be] = nt = he.length - 1), X.writeVarint(nt);
            var ft = typeof Ie;
            ft !== "string" && ft !== "boolean" && ft !== "number" && (Ie = JSON.stringify(Ie));
            var Xe = ft + ":" + Ie, xt = je[Xe];
            xt === void 0 && (_e.push(Ie), je[Xe] = xt = _e.length - 1), X.writeVarint(xt);
          }
        }
      }
      function Te(ve, X) {
        return (X << 3) + (7 & ve);
      }
      function be(ve) {
        return ve << 1 ^ ve >> 31;
      }
      function tt(ve, X) {
        for (var $ = ve.loadGeometry(), he = ve.type, _e = 0, Oe = 0, je = $.length, Be = 0; Be < je; Be++) {
          var Ie = $[Be], nt = 1;
          he === 1 && (nt = Ie.length), X.writeVarint(Te(1, nt));
          for (var ft = he === 3 ? Ie.length - 1 : Ie.length, Xe = 0; Xe < ft; Xe++) {
            Xe === 1 && he !== 1 && X.writeVarint(Te(2, ft - 1));
            var xt = Ie[Xe].x - _e, $t = Ie[Xe].y - Oe;
            X.writeVarint(be(xt)), X.writeVarint(be($t)), _e += xt, Oe += $t;
          }
          he === 3 && X.writeVarint(Te(7, 1));
        }
      }
      function st(ve, X) {
        var $ = typeof ve;
        $ === "string" ? X.writeStringField(1, ve) : $ === "boolean" ? X.writeBooleanField(7, ve) : $ === "number" && (ve % 1 != 0 ? X.writeDoubleField(3, ve) : ve < 0 ? X.writeSVarintField(6, ve) : X.writeVarintField(5, ve));
      }
      H.exports = Ve, H.exports.fromVectorTileJs = Ve, H.exports.fromGeojsonVt = function(ve, X) {
        X = X || {};
        var $ = {};
        for (var he in ve)
          $[he] = new ye(ve[he].features, X), $[he].name = he, $[he].version = X.version, $[he].extent = X.extent;
        return Ve({ layers: $ });
      }, H.exports.GeoJSONWrapper = ye;
      var lt = c.bx(H.exports);
      const Ye = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: (ve) => ve }, ht = Math.fround || (ct = new Float32Array(1), (ve) => (ct[0] = +ve, ct[0]));
      var ct;
      const Pt = 3, se = 5, Ae = 6;
      class Ce {
        constructor(X) {
          this.options = Object.assign(Object.create(Ye), X), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
        }
        load(X) {
          const { log: $, minZoom: he, maxZoom: _e } = this.options;
          $ && console.time("total time");
          const Oe = `prepare ${X.length} points`;
          $ && console.time(Oe), this.points = X;
          const je = [];
          for (let Ie = 0; Ie < X.length; Ie++) {
            const nt = X[Ie];
            if (!nt.geometry)
              continue;
            const [ft, Xe] = nt.geometry.coordinates, xt = ht(We(ft)), $t = ht(Ke(Xe));
            je.push(xt, $t, 1 / 0, Ie, -1, 1), this.options.reduce && je.push(0);
          }
          let Be = this.trees[_e + 1] = this._createTree(je);
          $ && console.timeEnd(Oe);
          for (let Ie = _e; Ie >= he; Ie--) {
            const nt = +Date.now();
            Be = this.trees[Ie] = this._createTree(this._cluster(Be, Ie)), $ && console.log("z%d: %d clusters in %dms", Ie, Be.numItems, +Date.now() - nt);
          }
          return $ && console.timeEnd("total time"), this;
        }
        getClusters(X, $) {
          let he = ((X[0] + 180) % 360 + 360) % 360 - 180;
          const _e = Math.max(-90, Math.min(90, X[1]));
          let Oe = X[2] === 180 ? 180 : ((X[2] + 180) % 360 + 360) % 360 - 180;
          const je = Math.max(-90, Math.min(90, X[3]));
          if (X[2] - X[0] >= 360)
            he = -180, Oe = 180;
          else if (he > Oe) {
            const Xe = this.getClusters([he, _e, 180, je], $), xt = this.getClusters([-180, _e, Oe, je], $);
            return Xe.concat(xt);
          }
          const Be = this.trees[this._limitZoom($)], Ie = Be.range(We(he), Ke(je), We(Oe), Ke(_e)), nt = Be.data, ft = [];
          for (const Xe of Ie) {
            const xt = this.stride * Xe;
            ft.push(nt[xt + se] > 1 ? Ue(nt, xt, this.clusterProps) : this.points[nt[xt + Pt]]);
          }
          return ft;
        }
        getChildren(X) {
          const $ = this._getOriginId(X), he = this._getOriginZoom(X), _e = "No cluster with the specified id.", Oe = this.trees[he];
          if (!Oe)
            throw new Error(_e);
          const je = Oe.data;
          if ($ * this.stride >= je.length)
            throw new Error(_e);
          const Be = this.options.radius / (this.options.extent * Math.pow(2, he - 1)), Ie = Oe.within(je[$ * this.stride], je[$ * this.stride + 1], Be), nt = [];
          for (const ft of Ie) {
            const Xe = ft * this.stride;
            je[Xe + 4] === X && nt.push(je[Xe + se] > 1 ? Ue(je, Xe, this.clusterProps) : this.points[je[Xe + Pt]]);
          }
          if (nt.length === 0)
            throw new Error(_e);
          return nt;
        }
        getLeaves(X, $, he) {
          const _e = [];
          return this._appendLeaves(_e, X, $ = $ || 10, he = he || 0, 0), _e;
        }
        getTile(X, $, he) {
          const _e = this.trees[this._limitZoom(X)], Oe = Math.pow(2, X), { extent: je, radius: Be } = this.options, Ie = Be / je, nt = (he - Ie) / Oe, ft = (he + 1 + Ie) / Oe, Xe = { features: [] };
          return this._addTileFeatures(_e.range(($ - Ie) / Oe, nt, ($ + 1 + Ie) / Oe, ft), _e.data, $, he, Oe, Xe), $ === 0 && this._addTileFeatures(_e.range(1 - Ie / Oe, nt, 1, ft), _e.data, Oe, he, Oe, Xe), $ === Oe - 1 && this._addTileFeatures(_e.range(0, nt, Ie / Oe, ft), _e.data, -1, he, Oe, Xe), Xe.features.length ? Xe : null;
        }
        getClusterExpansionZoom(X) {
          let $ = this._getOriginZoom(X) - 1;
          for (; $ <= this.options.maxZoom; ) {
            const he = this.getChildren(X);
            if ($++, he.length !== 1)
              break;
            X = he[0].properties.cluster_id;
          }
          return $;
        }
        _appendLeaves(X, $, he, _e, Oe) {
          const je = this.getChildren($);
          for (const Be of je) {
            const Ie = Be.properties;
            if (Ie && Ie.cluster ? Oe + Ie.point_count <= _e ? Oe += Ie.point_count : Oe = this._appendLeaves(X, Ie.cluster_id, he, _e, Oe) : Oe < _e ? Oe++ : X.push(Be), X.length === he)
              break;
          }
          return Oe;
        }
        _createTree(X) {
          const $ = new c.aw(X.length / this.stride | 0, this.options.nodeSize, Float32Array);
          for (let he = 0; he < X.length; he += this.stride)
            $.add(X[he], X[he + 1]);
          return $.finish(), $.data = X, $;
        }
        _addTileFeatures(X, $, he, _e, Oe, je) {
          for (const Be of X) {
            const Ie = Be * this.stride, nt = $[Ie + se] > 1;
            let ft, Xe, xt;
            if (nt)
              ft = qe($, Ie, this.clusterProps), Xe = $[Ie], xt = $[Ie + 1];
            else {
              const _n = this.points[$[Ie + Pt]];
              ft = _n.properties;
              const [An, an] = _n.geometry.coordinates;
              Xe = We(An), xt = Ke(an);
            }
            const $t = { type: 1, geometry: [[Math.round(this.options.extent * (Xe * Oe - he)), Math.round(this.options.extent * (xt * Oe - _e))]], tags: ft };
            let Kt;
            Kt = nt || this.options.generateId ? $[Ie + Pt] : this.points[$[Ie + Pt]].id, Kt !== void 0 && ($t.id = Kt), je.features.push($t);
          }
        }
        _limitZoom(X) {
          return Math.max(this.options.minZoom, Math.min(Math.floor(+X), this.options.maxZoom + 1));
        }
        _cluster(X, $) {
          const { radius: he, extent: _e, reduce: Oe, minPoints: je } = this.options, Be = he / (_e * Math.pow(2, $)), Ie = X.data, nt = [], ft = this.stride;
          for (let Xe = 0; Xe < Ie.length; Xe += ft) {
            if (Ie[Xe + 2] <= $)
              continue;
            Ie[Xe + 2] = $;
            const xt = Ie[Xe], $t = Ie[Xe + 1], Kt = X.within(Ie[Xe], Ie[Xe + 1], Be), _n = Ie[Xe + se];
            let An = _n;
            for (const an of Kt) {
              const Fn = an * ft;
              Ie[Fn + 2] > $ && (An += Ie[Fn + se]);
            }
            if (An > _n && An >= je) {
              let an, Fn = xt * _n, Yn = $t * _n, Kn = -1;
              const dn = ((Xe / ft | 0) << 5) + ($ + 1) + this.points.length;
              for (const Dn of Kt) {
                const Jn = Dn * ft;
                if (Ie[Jn + 2] <= $)
                  continue;
                Ie[Jn + 2] = $;
                const di = Ie[Jn + se];
                Fn += Ie[Jn] * di, Yn += Ie[Jn + 1] * di, Ie[Jn + 4] = dn, Oe && (an || (an = this._map(Ie, Xe, !0), Kn = this.clusterProps.length, this.clusterProps.push(an)), Oe(an, this._map(Ie, Jn)));
              }
              Ie[Xe + 4] = dn, nt.push(Fn / An, Yn / An, 1 / 0, dn, -1, An), Oe && nt.push(Kn);
            } else {
              for (let an = 0; an < ft; an++)
                nt.push(Ie[Xe + an]);
              if (An > 1)
                for (const an of Kt) {
                  const Fn = an * ft;
                  if (!(Ie[Fn + 2] <= $)) {
                    Ie[Fn + 2] = $;
                    for (let Yn = 0; Yn < ft; Yn++)
                      nt.push(Ie[Fn + Yn]);
                  }
                }
            }
          }
          return nt;
        }
        _getOriginId(X) {
          return X - this.points.length >> 5;
        }
        _getOriginZoom(X) {
          return (X - this.points.length) % 32;
        }
        _map(X, $, he) {
          if (X[$ + se] > 1) {
            const je = this.clusterProps[X[$ + Ae]];
            return he ? Object.assign({}, je) : je;
          }
          const _e = this.points[X[$ + Pt]].properties, Oe = this.options.map(_e);
          return he && Oe === _e ? Object.assign({}, Oe) : Oe;
        }
      }
      function Ue(ve, X, $) {
        return { type: "Feature", id: ve[X + Pt], properties: qe(ve, X, $), geometry: { type: "Point", coordinates: [(he = ve[X], 360 * (he - 0.5)), Ze(ve[X + 1])] } };
        var he;
      }
      function qe(ve, X, $) {
        const he = ve[X + se], _e = he >= 1e4 ? `${Math.round(he / 1e3)}k` : he >= 1e3 ? Math.round(he / 100) / 10 + "k" : he, Oe = ve[X + Ae], je = Oe === -1 ? {} : Object.assign({}, $[Oe]);
        return Object.assign(je, { cluster: !0, cluster_id: ve[X + Pt], point_count: he, point_count_abbreviated: _e });
      }
      function We(ve) {
        return ve / 360 + 0.5;
      }
      function Ke(ve) {
        const X = Math.sin(ve * Math.PI / 180), $ = 0.5 - 0.25 * Math.log((1 + X) / (1 - X)) / Math.PI;
        return $ < 0 ? 0 : $ > 1 ? 1 : $;
      }
      function Ze(ve) {
        const X = (180 - 360 * ve) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(X)) / Math.PI - 90;
      }
      function At(ve, X, $, he) {
        let _e = he;
        const Oe = X + ($ - X >> 1);
        let je, Be = $ - X;
        const Ie = ve[X], nt = ve[X + 1], ft = ve[$], Xe = ve[$ + 1];
        for (let xt = X + 3; xt < $; xt += 3) {
          const $t = It(ve[xt], ve[xt + 1], Ie, nt, ft, Xe);
          if ($t > _e)
            je = xt, _e = $t;
          else if ($t === _e) {
            const Kt = Math.abs(xt - Oe);
            Kt < Be && (je = xt, Be = Kt);
          }
        }
        _e > he && (je - X > 3 && At(ve, X, je, he), ve[je + 2] = _e, $ - je > 3 && At(ve, je, $, he));
      }
      function It(ve, X, $, he, _e, Oe) {
        let je = _e - $, Be = Oe - he;
        if (je !== 0 || Be !== 0) {
          const Ie = ((ve - $) * je + (X - he) * Be) / (je * je + Be * Be);
          Ie > 1 ? ($ = _e, he = Oe) : Ie > 0 && ($ += je * Ie, he += Be * Ie);
        }
        return je = ve - $, Be = X - he, je * je + Be * Be;
      }
      function Rt(ve, X, $, he) {
        const _e = { id: ve ?? null, type: X, geometry: $, tags: he, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        if (X === "Point" || X === "MultiPoint" || X === "LineString")
          kt(_e, $);
        else if (X === "Polygon")
          kt(_e, $[0]);
        else if (X === "MultiLineString")
          for (const Oe of $)
            kt(_e, Oe);
        else if (X === "MultiPolygon")
          for (const Oe of $)
            kt(_e, Oe[0]);
        return _e;
      }
      function kt(ve, X) {
        for (let $ = 0; $ < X.length; $ += 3)
          ve.minX = Math.min(ve.minX, X[$]), ve.minY = Math.min(ve.minY, X[$ + 1]), ve.maxX = Math.max(ve.maxX, X[$]), ve.maxY = Math.max(ve.maxY, X[$ + 1]);
      }
      function on(ve, X, $, he) {
        if (!X.geometry)
          return;
        const _e = X.geometry.coordinates;
        if (_e && _e.length === 0)
          return;
        const Oe = X.geometry.type, je = Math.pow($.tolerance / ((1 << $.maxZoom) * $.extent), 2);
        let Be = [], Ie = X.id;
        if ($.promoteId ? Ie = X.properties[$.promoteId] : $.generateId && (Ie = he || 0), Oe === "Point")
          ut(_e, Be);
        else if (Oe === "MultiPoint")
          for (const nt of _e)
            ut(nt, Be);
        else if (Oe === "LineString")
          re(_e, Be, je, !1);
        else if (Oe === "MultiLineString") {
          if ($.lineMetrics) {
            for (const nt of _e)
              Be = [], re(nt, Be, je, !1), ve.push(Rt(Ie, "LineString", Be, X.properties));
            return;
          }
          mn(_e, Be, je, !1);
        } else if (Oe === "Polygon")
          mn(_e, Be, je, !0);
        else {
          if (Oe !== "MultiPolygon") {
            if (Oe === "GeometryCollection") {
              for (const nt of X.geometry.geometries)
                on(ve, { id: Ie, geometry: nt, properties: X.properties }, $, he);
              return;
            }
            throw new Error("Input data is not a valid GeoJSON object.");
          }
          for (const nt of _e) {
            const ft = [];
            mn(nt, ft, je, !0), Be.push(ft);
          }
        }
        ve.push(Rt(Ie, Oe, Be, X.properties));
      }
      function ut(ve, X) {
        X.push(Qt(ve[0]), pt(ve[1]), 0);
      }
      function re(ve, X, $, he) {
        let _e, Oe, je = 0;
        for (let Ie = 0; Ie < ve.length; Ie++) {
          const nt = Qt(ve[Ie][0]), ft = pt(ve[Ie][1]);
          X.push(nt, ft, 0), Ie > 0 && (je += he ? (_e * ft - nt * Oe) / 2 : Math.sqrt(Math.pow(nt - _e, 2) + Math.pow(ft - Oe, 2))), _e = nt, Oe = ft;
        }
        const Be = X.length - 3;
        X[2] = 1, At(X, 0, Be, $), X[Be + 2] = 1, X.size = Math.abs(je), X.start = 0, X.end = X.size;
      }
      function mn(ve, X, $, he) {
        for (let _e = 0; _e < ve.length; _e++) {
          const Oe = [];
          re(ve[_e], Oe, $, he), X.push(Oe);
        }
      }
      function Qt(ve) {
        return ve / 360 + 0.5;
      }
      function pt(ve) {
        const X = Math.sin(ve * Math.PI / 180), $ = 0.5 - 0.25 * Math.log((1 + X) / (1 - X)) / Math.PI;
        return $ < 0 ? 0 : $ > 1 ? 1 : $;
      }
      function Et(ve, X, $, he, _e, Oe, je, Be) {
        if (he /= X, Oe >= ($ /= X) && je < he)
          return ve;
        if (je < $ || Oe >= he)
          return null;
        const Ie = [];
        for (const nt of ve) {
          const ft = nt.geometry;
          let Xe = nt.type;
          const xt = _e === 0 ? nt.minX : nt.minY, $t = _e === 0 ? nt.maxX : nt.maxY;
          if (xt >= $ && $t < he) {
            Ie.push(nt);
            continue;
          }
          if ($t < $ || xt >= he)
            continue;
          let Kt = [];
          if (Xe === "Point" || Xe === "MultiPoint")
            Lt(ft, Kt, $, he, _e);
          else if (Xe === "LineString")
            Ft(ft, Kt, $, he, _e, !1, Be.lineMetrics);
          else if (Xe === "MultiLineString")
            Tn(ft, Kt, $, he, _e, !1);
          else if (Xe === "Polygon")
            Tn(ft, Kt, $, he, _e, !0);
          else if (Xe === "MultiPolygon")
            for (const _n of ft) {
              const An = [];
              Tn(_n, An, $, he, _e, !0), An.length && Kt.push(An);
            }
          if (Kt.length) {
            if (Be.lineMetrics && Xe === "LineString") {
              for (const _n of Kt)
                Ie.push(Rt(nt.id, Xe, _n, nt.tags));
              continue;
            }
            Xe !== "LineString" && Xe !== "MultiLineString" || (Kt.length === 1 ? (Xe = "LineString", Kt = Kt[0]) : Xe = "MultiLineString"), Xe !== "Point" && Xe !== "MultiPoint" || (Xe = Kt.length === 3 ? "Point" : "MultiPoint"), Ie.push(Rt(nt.id, Xe, Kt, nt.tags));
          }
        }
        return Ie.length ? Ie : null;
      }
      function Lt(ve, X, $, he, _e) {
        for (let Oe = 0; Oe < ve.length; Oe += 3) {
          const je = ve[Oe + _e];
          je >= $ && je <= he && xn(X, ve[Oe], ve[Oe + 1], ve[Oe + 2]);
        }
      }
      function Ft(ve, X, $, he, _e, Oe, je) {
        let Be = nn(ve);
        const Ie = _e === 0 ? On : Un;
        let nt, ft, Xe = ve.start;
        for (let An = 0; An < ve.length - 3; An += 3) {
          const an = ve[An], Fn = ve[An + 1], Yn = ve[An + 2], Kn = ve[An + 3], dn = ve[An + 4], Dn = _e === 0 ? an : Fn, Jn = _e === 0 ? Kn : dn;
          let di = !1;
          je && (nt = Math.sqrt(Math.pow(an - Kn, 2) + Math.pow(Fn - dn, 2))), Dn < $ ? Jn > $ && (ft = Ie(Be, an, Fn, Kn, dn, $), je && (Be.start = Xe + nt * ft)) : Dn > he ? Jn < he && (ft = Ie(Be, an, Fn, Kn, dn, he), je && (Be.start = Xe + nt * ft)) : xn(Be, an, Fn, Yn), Jn < $ && Dn >= $ && (ft = Ie(Be, an, Fn, Kn, dn, $), di = !0), Jn > he && Dn <= he && (ft = Ie(Be, an, Fn, Kn, dn, he), di = !0), !Oe && di && (je && (Be.end = Xe + nt * ft), X.push(Be), Be = nn(ve)), je && (Xe += nt);
        }
        let xt = ve.length - 3;
        const $t = ve[xt], Kt = ve[xt + 1], _n = _e === 0 ? $t : Kt;
        _n >= $ && _n <= he && xn(Be, $t, Kt, ve[xt + 2]), xt = Be.length - 3, Oe && xt >= 3 && (Be[xt] !== Be[0] || Be[xt + 1] !== Be[1]) && xn(Be, Be[0], Be[1], Be[2]), Be.length && X.push(Be);
      }
      function nn(ve) {
        const X = [];
        return X.size = ve.size, X.start = ve.start, X.end = ve.end, X;
      }
      function Tn(ve, X, $, he, _e, Oe) {
        for (const je of ve)
          Ft(je, X, $, he, _e, Oe, !1);
      }
      function xn(ve, X, $, he) {
        ve.push(X, $, he);
      }
      function On(ve, X, $, he, _e, Oe) {
        const je = (Oe - X) / (he - X);
        return xn(ve, Oe, $ + (_e - $) * je, 1), je;
      }
      function Un(ve, X, $, he, _e, Oe) {
        const je = (Oe - $) / (_e - $);
        return xn(ve, X + (he - X) * je, Oe, 1), je;
      }
      function mt(ve, X) {
        const $ = [];
        for (let he = 0; he < ve.length; he++) {
          const _e = ve[he], Oe = _e.type;
          let je;
          if (Oe === "Point" || Oe === "MultiPoint" || Oe === "LineString")
            je = hn(_e.geometry, X);
          else if (Oe === "MultiLineString" || Oe === "Polygon") {
            je = [];
            for (const Be of _e.geometry)
              je.push(hn(Be, X));
          } else if (Oe === "MultiPolygon") {
            je = [];
            for (const Be of _e.geometry) {
              const Ie = [];
              for (const nt of Be)
                Ie.push(hn(nt, X));
              je.push(Ie);
            }
          }
          $.push(Rt(_e.id, Oe, je, _e.tags));
        }
        return $;
      }
      function hn(ve, X) {
        const $ = [];
        $.size = ve.size, ve.start !== void 0 && ($.start = ve.start, $.end = ve.end);
        for (let he = 0; he < ve.length; he += 3)
          $.push(ve[he] + X, ve[he + 1], ve[he + 2]);
        return $;
      }
      function wn(ve, X) {
        if (ve.transformed)
          return ve;
        const $ = 1 << ve.z, he = ve.x, _e = ve.y;
        for (const Oe of ve.features) {
          const je = Oe.geometry, Be = Oe.type;
          if (Oe.geometry = [], Be === 1)
            for (let Ie = 0; Ie < je.length; Ie += 2)
              Oe.geometry.push(Bt(je[Ie], je[Ie + 1], X, $, he, _e));
          else
            for (let Ie = 0; Ie < je.length; Ie++) {
              const nt = [];
              for (let ft = 0; ft < je[Ie].length; ft += 2)
                nt.push(Bt(je[Ie][ft], je[Ie][ft + 1], X, $, he, _e));
              Oe.geometry.push(nt);
            }
        }
        return ve.transformed = !0, ve;
      }
      function Bt(ve, X, $, he, _e, Oe) {
        return [Math.round($ * (ve * he - _e)), Math.round($ * (X * he - Oe))];
      }
      function bi(ve, X, $, he, _e) {
        const Oe = X === _e.maxZoom ? 0 : _e.tolerance / ((1 << X) * _e.extent), je = { features: [], numPoints: 0, numSimplified: 0, numFeatures: ve.length, source: null, x: $, y: he, z: X, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 };
        for (const Be of ve)
          _t(je, Be, Oe, _e);
        return je;
      }
      function _t(ve, X, $, he) {
        const _e = X.geometry, Oe = X.type, je = [];
        if (ve.minX = Math.min(ve.minX, X.minX), ve.minY = Math.min(ve.minY, X.minY), ve.maxX = Math.max(ve.maxX, X.maxX), ve.maxY = Math.max(ve.maxY, X.maxY), Oe === "Point" || Oe === "MultiPoint")
          for (let Be = 0; Be < _e.length; Be += 3)
            je.push(_e[Be], _e[Be + 1]), ve.numPoints++, ve.numSimplified++;
        else if (Oe === "LineString")
          bn(je, _e, ve, $, !1, !1);
        else if (Oe === "MultiLineString" || Oe === "Polygon")
          for (let Be = 0; Be < _e.length; Be++)
            bn(je, _e[Be], ve, $, Oe === "Polygon", Be === 0);
        else if (Oe === "MultiPolygon")
          for (let Be = 0; Be < _e.length; Be++) {
            const Ie = _e[Be];
            for (let nt = 0; nt < Ie.length; nt++)
              bn(je, Ie[nt], ve, $, !0, nt === 0);
          }
        if (je.length) {
          let Be = X.tags || null;
          if (Oe === "LineString" && he.lineMetrics) {
            Be = {};
            for (const nt in X.tags)
              Be[nt] = X.tags[nt];
            Be.mapbox_clip_start = _e.start / _e.size, Be.mapbox_clip_end = _e.end / _e.size;
          }
          const Ie = { geometry: je, type: Oe === "Polygon" || Oe === "MultiPolygon" ? 3 : Oe === "LineString" || Oe === "MultiLineString" ? 2 : 1, tags: Be };
          X.id !== null && (Ie.id = X.id), ve.features.push(Ie);
        }
      }
      function bn(ve, X, $, he, _e, Oe) {
        const je = he * he;
        if (he > 0 && X.size < (_e ? je : he))
          return void ($.numPoints += X.length / 3);
        const Be = [];
        for (let Ie = 0; Ie < X.length; Ie += 3)
          (he === 0 || X[Ie + 2] > je) && ($.numSimplified++, Be.push(X[Ie], X[Ie + 1])), $.numPoints++;
        _e && function(Ie, nt) {
          let ft = 0;
          for (let Xe = 0, xt = Ie.length, $t = xt - 2; Xe < xt; $t = Xe, Xe += 2)
            ft += (Ie[Xe] - Ie[$t]) * (Ie[Xe + 1] + Ie[$t + 1]);
          if (ft > 0 === nt)
            for (let Xe = 0, xt = Ie.length; Xe < xt / 2; Xe += 2) {
              const $t = Ie[Xe], Kt = Ie[Xe + 1];
              Ie[Xe] = Ie[xt - 2 - Xe], Ie[Xe + 1] = Ie[xt - 1 - Xe], Ie[xt - 2 - Xe] = $t, Ie[xt - 1 - Xe] = Kt;
            }
        }(Be, Oe), ve.push(Be);
      }
      const Gt = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 };
      class qn {
        constructor(X, $) {
          const he = ($ = this.options = function(Oe, je) {
            for (const Be in je)
              Oe[Be] = je[Be];
            return Oe;
          }(Object.create(Gt), $)).debug;
          if (he && console.time("preprocess data"), $.maxZoom < 0 || $.maxZoom > 24)
            throw new Error("maxZoom should be in the 0-24 range");
          if ($.promoteId && $.generateId)
            throw new Error("promoteId and generateId cannot be used together.");
          let _e = function(Oe, je) {
            const Be = [];
            if (Oe.type === "FeatureCollection")
              for (let Ie = 0; Ie < Oe.features.length; Ie++)
                on(Be, Oe.features[Ie], je, Ie);
            else
              on(Be, Oe.type === "Feature" ? Oe : { geometry: Oe }, je);
            return Be;
          }(X, $);
          this.tiles = {}, this.tileCoords = [], he && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", $.indexMaxZoom, $.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), _e = function(Oe, je) {
            const Be = je.buffer / je.extent;
            let Ie = Oe;
            const nt = Et(Oe, 1, -1 - Be, Be, 0, -1, 2, je), ft = Et(Oe, 1, 1 - Be, 2 + Be, 0, -1, 2, je);
            return (nt || ft) && (Ie = Et(Oe, 1, -Be, 1 + Be, 0, -1, 2, je) || [], nt && (Ie = mt(nt, 1).concat(Ie)), ft && (Ie = Ie.concat(mt(ft, -1)))), Ie;
          }(_e, $), _e.length && this.splitTile(_e, 0, 0, 0), he && (_e.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        splitTile(X, $, he, _e, Oe, je, Be) {
          const Ie = [X, $, he, _e], nt = this.options, ft = nt.debug;
          for (; Ie.length; ) {
            _e = Ie.pop(), he = Ie.pop(), $ = Ie.pop(), X = Ie.pop();
            const Xe = 1 << $, xt = er($, he, _e);
            let $t = this.tiles[xt];
            if (!$t && (ft > 1 && console.time("creation"), $t = this.tiles[xt] = bi(X, $, he, _e, nt), this.tileCoords.push({ z: $, x: he, y: _e }), ft)) {
              ft > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", $, he, _e, $t.numFeatures, $t.numPoints, $t.numSimplified), console.timeEnd("creation"));
              const di = `z${$}`;
              this.stats[di] = (this.stats[di] || 0) + 1, this.total++;
            }
            if ($t.source = X, Oe == null) {
              if ($ === nt.indexMaxZoom || $t.numPoints <= nt.indexMaxPoints)
                continue;
            } else {
              if ($ === nt.maxZoom || $ === Oe)
                continue;
              if (Oe != null) {
                const di = Oe - $;
                if (he !== je >> di || _e !== Be >> di)
                  continue;
              }
            }
            if ($t.source = null, X.length === 0)
              continue;
            ft > 1 && console.time("clipping");
            const Kt = 0.5 * nt.buffer / nt.extent, _n = 0.5 - Kt, An = 0.5 + Kt, an = 1 + Kt;
            let Fn = null, Yn = null, Kn = null, dn = null, Dn = Et(X, Xe, he - Kt, he + An, 0, $t.minX, $t.maxX, nt), Jn = Et(X, Xe, he + _n, he + an, 0, $t.minX, $t.maxX, nt);
            X = null, Dn && (Fn = Et(Dn, Xe, _e - Kt, _e + An, 1, $t.minY, $t.maxY, nt), Yn = Et(Dn, Xe, _e + _n, _e + an, 1, $t.minY, $t.maxY, nt), Dn = null), Jn && (Kn = Et(Jn, Xe, _e - Kt, _e + An, 1, $t.minY, $t.maxY, nt), dn = Et(Jn, Xe, _e + _n, _e + an, 1, $t.minY, $t.maxY, nt), Jn = null), ft > 1 && console.timeEnd("clipping"), Ie.push(Fn || [], $ + 1, 2 * he, 2 * _e), Ie.push(Yn || [], $ + 1, 2 * he, 2 * _e + 1), Ie.push(Kn || [], $ + 1, 2 * he + 1, 2 * _e), Ie.push(dn || [], $ + 1, 2 * he + 1, 2 * _e + 1);
          }
        }
        getTile(X, $, he) {
          X = +X, $ = +$, he = +he;
          const _e = this.options, { extent: Oe, debug: je } = _e;
          if (X < 0 || X > 24)
            return null;
          const Be = 1 << X, Ie = er(X, $ = $ + Be & Be - 1, he);
          if (this.tiles[Ie])
            return wn(this.tiles[Ie], Oe);
          je > 1 && console.log("drilling down to z%d-%d-%d", X, $, he);
          let nt, ft = X, Xe = $, xt = he;
          for (; !nt && ft > 0; )
            ft--, Xe >>= 1, xt >>= 1, nt = this.tiles[er(ft, Xe, xt)];
          return nt && nt.source ? (je > 1 && (console.log("found parent tile z%d-%d-%d", ft, Xe, xt), console.time("drilling down")), this.splitTile(nt.source, ft, Xe, xt, X, $, he), je > 1 && console.timeEnd("drilling down"), this.tiles[Ie] ? wn(this.tiles[Ie], Oe) : null) : null;
        }
      }
      function er(ve, X, $) {
        return 32 * ((1 << ve) * $ + X) + ve;
      }
      function Nt(ve, X) {
        return X ? ve.properties[X] : ve.id;
      }
      function vr(ve, X) {
        if (ve == null)
          return !0;
        if (ve.type === "Feature")
          return Nt(ve, X) != null;
        if (ve.type === "FeatureCollection") {
          const $ = /* @__PURE__ */ new Set();
          for (const he of ve.features) {
            const _e = Nt(he, X);
            if (_e == null || $.has(_e))
              return !1;
            $.add(_e);
          }
          return !0;
        }
        return !1;
      }
      function ii(ve, X) {
        const $ = /* @__PURE__ */ new Map();
        if (ve != null)
          if (ve.type === "Feature")
            $.set(Nt(ve, X), ve);
          else
            for (const he of ve.features)
              $.set(Nt(he, X), he);
        return $;
      }
      class sr extends T {
        constructor() {
          super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
        }
        loadVectorTile(X, $) {
          return c._(this, void 0, void 0, function* () {
            const he = X.tileID.canonical;
            if (!this._geoJSONIndex)
              throw new Error("Unable to parse the data into a cluster or geojson");
            const _e = this._geoJSONIndex.getTile(he.z, he.x, he.y);
            if (!_e)
              return null;
            const Oe = new class {
              constructor(Be) {
                this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = c.X, this.length = Be.length, this._features = Be;
              }
              feature(Be) {
                return new class {
                  constructor(Ie) {
                    this._feature = Ie, this.extent = c.X, this.type = Ie.type, this.properties = Ie.tags, "id" in Ie && !isNaN(Ie.id) && (this.id = parseInt(Ie.id, 10));
                  }
                  loadGeometry() {
                    if (this._feature.type === 1) {
                      const Ie = [];
                      for (const nt of this._feature.geometry)
                        Ie.push([new c.P(nt[0], nt[1])]);
                      return Ie;
                    }
                    {
                      const Ie = [];
                      for (const nt of this._feature.geometry) {
                        const ft = [];
                        for (const Xe of nt)
                          ft.push(new c.P(Xe[0], Xe[1]));
                        Ie.push(ft);
                      }
                      return Ie;
                    }
                  }
                  toGeoJSON(Ie, nt, ft) {
                    return V.call(this, Ie, nt, ft);
                  }
                }(this._features[Be]);
              }
            }(_e.features);
            let je = lt(Oe);
            return je.byteOffset === 0 && je.byteLength === je.buffer.byteLength || (je = new Uint8Array(je)), { vectorTile: Oe, rawData: je.buffer };
          });
        }
        loadData(X) {
          return c._(this, void 0, void 0, function* () {
            var $;
            ($ = this._pendingRequest) === null || $ === void 0 || $.abort();
            const he = !!(X && X.request && X.request.collectResourceTiming) && new c.bu(X.request);
            this._pendingRequest = new AbortController();
            try {
              this._pendingData = this.loadAndProcessGeoJSON(X, this._pendingRequest), this._geoJSONIndex = X.cluster ? new Ce(function(je) {
                let { superclusterOptions: Be, clusterProperties: Ie } = je;
                if (!Ie || !Be)
                  return Be;
                const nt = {}, ft = {}, Xe = { accumulated: null, zoom: 0 }, xt = { properties: null }, $t = Object.keys(Ie);
                for (const Kt of $t) {
                  const [_n, An] = Ie[Kt], an = c.bB(An), Fn = c.bB(typeof _n == "string" ? [_n, ["accumulated"], ["get", Kt]] : _n);
                  nt[Kt] = an.value, ft[Kt] = Fn.value;
                }
                return Be.map = (Kt) => {
                  xt.properties = Kt;
                  const _n = {};
                  for (const An of $t)
                    _n[An] = nt[An].evaluate(Xe, xt);
                  return _n;
                }, Be.reduce = (Kt, _n) => {
                  xt.properties = _n;
                  for (const An of $t)
                    Xe.accumulated = Kt[An], Kt[An] = ft[An].evaluate(Xe, xt);
                }, Be;
              }(X)).load((yield this._pendingData).features) : (_e = yield this._pendingData, new qn(_e, X.geojsonVtOptions)), this.loaded = {};
              const Oe = {};
              if (he) {
                const je = he.finish();
                je && (Oe.resourceTiming = {}, Oe.resourceTiming[X.source] = JSON.parse(JSON.stringify(je)));
              }
              return Oe;
            } catch (Oe) {
              if (delete this._pendingRequest, c.bA(Oe))
                return { abandoned: !0 };
              throw Oe;
            }
            var _e;
          });
        }
        getData() {
          return c._(this, void 0, void 0, function* () {
            return this._pendingData;
          });
        }
        reloadTile(X) {
          const $ = this.loaded;
          return $ && $[X.uid] ? super.reloadTile(X) : this.loadTile(X);
        }
        loadAndProcessGeoJSON(X, $) {
          return c._(this, void 0, void 0, function* () {
            let he = yield this.loadGeoJSON(X, $);
            if (delete this._pendingRequest, typeof he != "object")
              throw new Error(`Input data given to '${X.source}' is not a valid GeoJSON object.`);
            if (z(he, !0), X.filter) {
              const _e = c.bB(X.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
              if (_e.result === "error")
                throw new Error(_e.value.map((je) => `${je.key}: ${je.message}`).join(", "));
              he = { type: "FeatureCollection", features: he.features.filter((je) => _e.value.evaluate({ zoom: 0 }, je)) };
            }
            return he;
          });
        }
        loadGeoJSON(X, $) {
          return c._(this, void 0, void 0, function* () {
            const { promoteId: he } = X;
            if (X.request) {
              const _e = yield c.h(X.request, $);
              return this._dataUpdateable = vr(_e.data, he) ? ii(_e.data, he) : void 0, _e.data;
            }
            if (typeof X.data == "string")
              try {
                const _e = JSON.parse(X.data);
                return this._dataUpdateable = vr(_e, he) ? ii(_e, he) : void 0, _e;
              } catch {
                throw new Error(`Input data given to '${X.source}' is not a valid GeoJSON object.`);
              }
            if (!X.dataDiff)
              throw new Error(`Input data given to '${X.source}' is not a valid GeoJSON object.`);
            if (!this._dataUpdateable)
              throw new Error(`Cannot update existing geojson data in ${X.source}`);
            return function(_e, Oe, je) {
              var Be, Ie, nt, ft;
              if (Oe.removeAll && _e.clear(), Oe.remove)
                for (const Xe of Oe.remove)
                  _e.delete(Xe);
              if (Oe.add)
                for (const Xe of Oe.add) {
                  const xt = Nt(Xe, je);
                  xt != null && _e.set(xt, Xe);
                }
              if (Oe.update)
                for (const Xe of Oe.update) {
                  let xt = _e.get(Xe.id);
                  if (xt == null)
                    continue;
                  const $t = !Xe.removeAllProperties && (((Be = Xe.removeProperties) === null || Be === void 0 ? void 0 : Be.length) > 0 || ((Ie = Xe.addOrUpdateProperties) === null || Ie === void 0 ? void 0 : Ie.length) > 0);
                  if ((Xe.newGeometry || Xe.removeAllProperties || $t) && (xt = Object.assign({}, xt), _e.set(Xe.id, xt), $t && (xt.properties = Object.assign({}, xt.properties))), Xe.newGeometry && (xt.geometry = Xe.newGeometry), Xe.removeAllProperties)
                    xt.properties = {};
                  else if (((nt = Xe.removeProperties) === null || nt === void 0 ? void 0 : nt.length) > 0)
                    for (const Kt of Xe.removeProperties)
                      Object.prototype.hasOwnProperty.call(xt.properties, Kt) && delete xt.properties[Kt];
                  if (((ft = Xe.addOrUpdateProperties) === null || ft === void 0 ? void 0 : ft.length) > 0)
                    for (const { key: Kt, value: _n } of Xe.addOrUpdateProperties)
                      xt.properties[Kt] = _n;
                }
            }(this._dataUpdateable, X.dataDiff, he), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
          });
        }
        removeSource(X) {
          return c._(this, void 0, void 0, function* () {
            this._pendingRequest && this._pendingRequest.abort();
          });
        }
        getClusterExpansionZoom(X) {
          return this._geoJSONIndex.getClusterExpansionZoom(X.clusterId);
        }
        getClusterChildren(X) {
          return this._geoJSONIndex.getChildren(X.clusterId);
        }
        getClusterLeaves(X) {
          return this._geoJSONIndex.getLeaves(X.clusterId, X.limit, X.offset);
        }
      }
      class or {
        constructor(X) {
          this.self = X, this.actor = new c.F(X), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = ($, he) => {
            if (this.externalWorkerSourceTypes[$])
              throw new Error(`Worker source with name "${$}" already registered.`);
            this.externalWorkerSourceTypes[$] = he;
          }, this.self.addProtocol = c.bh, this.self.removeProtocol = c.bi, this.self.registerRTLTextPlugin = ($) => {
            if (c.bC.isParsed())
              throw new Error("RTL text plugin already registered.");
            c.bC.setMethods($);
          }, this.actor.registerMessageHandler("LDT", ($, he) => this._getDEMWorkerSource($, he.source).loadTile(he)), this.actor.registerMessageHandler("RDT", ($, he) => c._(this, void 0, void 0, function* () {
            this._getDEMWorkerSource($, he.source).removeTile(he);
          })), this.actor.registerMessageHandler("GCEZ", ($, he) => c._(this, void 0, void 0, function* () {
            return this._getWorkerSource($, he.type, he.source).getClusterExpansionZoom(he);
          })), this.actor.registerMessageHandler("GCC", ($, he) => c._(this, void 0, void 0, function* () {
            return this._getWorkerSource($, he.type, he.source).getClusterChildren(he);
          })), this.actor.registerMessageHandler("GCL", ($, he) => c._(this, void 0, void 0, function* () {
            return this._getWorkerSource($, he.type, he.source).getClusterLeaves(he);
          })), this.actor.registerMessageHandler("LD", ($, he) => this._getWorkerSource($, he.type, he.source).loadData(he)), this.actor.registerMessageHandler("GD", ($, he) => this._getWorkerSource($, he.type, he.source).getData()), this.actor.registerMessageHandler("LT", ($, he) => this._getWorkerSource($, he.type, he.source).loadTile(he)), this.actor.registerMessageHandler("RT", ($, he) => this._getWorkerSource($, he.type, he.source).reloadTile(he)), this.actor.registerMessageHandler("AT", ($, he) => this._getWorkerSource($, he.type, he.source).abortTile(he)), this.actor.registerMessageHandler("RMT", ($, he) => this._getWorkerSource($, he.type, he.source).removeTile(he)), this.actor.registerMessageHandler("RS", ($, he) => c._(this, void 0, void 0, function* () {
            if (!this.workerSources[$] || !this.workerSources[$][he.type] || !this.workerSources[$][he.type][he.source])
              return;
            const _e = this.workerSources[$][he.type][he.source];
            delete this.workerSources[$][he.type][he.source], _e.removeSource !== void 0 && _e.removeSource(he);
          })), this.actor.registerMessageHandler("RM", ($) => c._(this, void 0, void 0, function* () {
            delete this.layerIndexes[$], delete this.availableImages[$], delete this.workerSources[$], delete this.demWorkerSources[$];
          })), this.actor.registerMessageHandler("SR", ($, he) => c._(this, void 0, void 0, function* () {
            this.referrer = he;
          })), this.actor.registerMessageHandler("SRPS", ($, he) => this._syncRTLPluginState($, he)), this.actor.registerMessageHandler("IS", ($, he) => c._(this, void 0, void 0, function* () {
            this.self.importScripts(he);
          })), this.actor.registerMessageHandler("SI", ($, he) => this._setImages($, he)), this.actor.registerMessageHandler("UL", ($, he) => c._(this, void 0, void 0, function* () {
            this._getLayerIndex($).update(he.layers, he.removedIds);
          })), this.actor.registerMessageHandler("SL", ($, he) => c._(this, void 0, void 0, function* () {
            this._getLayerIndex($).replace(he);
          }));
        }
        _setImages(X, $) {
          return c._(this, void 0, void 0, function* () {
            this.availableImages[X] = $;
            for (const he in this.workerSources[X]) {
              const _e = this.workerSources[X][he];
              for (const Oe in _e)
                _e[Oe].availableImages = $;
            }
          });
        }
        _syncRTLPluginState(X, $) {
          return c._(this, void 0, void 0, function* () {
            if (c.bC.isParsed())
              return c.bC.getState();
            if ($.pluginStatus !== "loading")
              return c.bC.setState($), $;
            const he = $.pluginURL;
            if (this.self.importScripts(he), c.bC.isParsed()) {
              const _e = { pluginStatus: "loaded", pluginURL: he };
              return c.bC.setState(_e), _e;
            }
            throw c.bC.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${he}`);
          });
        }
        _getAvailableImages(X) {
          let $ = this.availableImages[X];
          return $ || ($ = []), $;
        }
        _getLayerIndex(X) {
          let $ = this.layerIndexes[X];
          return $ || ($ = this.layerIndexes[X] = new l()), $;
        }
        _getWorkerSource(X, $, he) {
          if (this.workerSources[X] || (this.workerSources[X] = {}), this.workerSources[X][$] || (this.workerSources[X][$] = {}), !this.workerSources[X][$][he]) {
            const _e = { sendAsync: (Oe, je) => (Oe.targetMapId = X, this.actor.sendAsync(Oe, je)) };
            switch ($) {
              case "vector":
                this.workerSources[X][$][he] = new T(_e, this._getLayerIndex(X), this._getAvailableImages(X));
                break;
              case "geojson":
                this.workerSources[X][$][he] = new sr(_e, this._getLayerIndex(X), this._getAvailableImages(X));
                break;
              default:
                this.workerSources[X][$][he] = new this.externalWorkerSourceTypes[$](_e, this._getLayerIndex(X), this._getAvailableImages(X));
            }
          }
          return this.workerSources[X][$][he];
        }
        _getDEMWorkerSource(X, $) {
          return this.demWorkerSources[X] || (this.demWorkerSources[X] = {}), this.demWorkerSources[X][$] || (this.demWorkerSources[X][$] = new I()), this.demWorkerSources[X][$];
        }
      }
      return c.i(self) && (self.worker = new or(self)), or;
    }), r("index", ["exports", "./shared"], function(c, l) {
      var m = "4.5.0";
      let y, A;
      const T = { now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frameAsync: (E) => new Promise((a, f) => {
        const _ = requestAnimationFrame(a);
        E.signal.addEventListener("abort", () => {
          cancelAnimationFrame(_), f(l.c());
        });
      }), getImageData(E) {
        let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        return this.getImageCanvasContext(E).getImageData(-a, -a, E.width + 2 * a, E.height + 2 * a);
      }, getImageCanvasContext(E) {
        const a = window.document.createElement("canvas"), f = a.getContext("2d", { willReadFrequently: !0 });
        if (!f)
          throw new Error("failed to create canvas 2d context");
        return a.width = E.width, a.height = E.height, f.drawImage(E, 0, 0, E.width, E.height), f;
      }, resolveURL: (E) => (y || (y = document.createElement("a")), y.href = E, y.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
        return !!matchMedia && (A == null && (A = matchMedia("(prefers-reduced-motion: reduce)")), A.matches);
      } };
      class I {
        static testProp(a) {
          if (!I.docStyle)
            return a[0];
          for (let f = 0; f < a.length; f++)
            if (a[f] in I.docStyle)
              return a[f];
          return a[0];
        }
        static create(a, f, _) {
          const h = window.document.createElement(a);
          return f !== void 0 && (h.className = f), _ && _.appendChild(h), h;
        }
        static createNS(a, f) {
          return window.document.createElementNS(a, f);
        }
        static disableDrag() {
          I.docStyle && I.selectProp && (I.userSelect = I.docStyle[I.selectProp], I.docStyle[I.selectProp] = "none");
        }
        static enableDrag() {
          I.docStyle && I.selectProp && (I.docStyle[I.selectProp] = I.userSelect);
        }
        static setTransform(a, f) {
          a.style[I.transformProp] = f;
        }
        static addEventListener(a, f, _) {
          let h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          a.addEventListener(f, _, "passive" in h ? h : h.capture);
        }
        static removeEventListener(a, f, _) {
          let h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          a.removeEventListener(f, _, "passive" in h ? h : h.capture);
        }
        static suppressClickInternal(a) {
          a.preventDefault(), a.stopPropagation(), window.removeEventListener("click", I.suppressClickInternal, !0);
        }
        static suppressClick() {
          window.addEventListener("click", I.suppressClickInternal, !0), window.setTimeout(() => {
            window.removeEventListener("click", I.suppressClickInternal, !0);
          }, 0);
        }
        static getScale(a) {
          const f = a.getBoundingClientRect();
          return { x: f.width / a.offsetWidth || 1, y: f.height / a.offsetHeight || 1, boundingClientRect: f };
        }
        static getPoint(a, f, _) {
          const h = f.boundingClientRect;
          return new l.P((_.clientX - h.left) / f.x - a.clientLeft, (_.clientY - h.top) / f.y - a.clientTop);
        }
        static mousePos(a, f) {
          const _ = I.getScale(a);
          return I.getPoint(a, _, f);
        }
        static touchPos(a, f) {
          const _ = [], h = I.getScale(a);
          for (let p = 0; p < f.length; p++)
            _.push(I.getPoint(a, h, f[p]));
          return _;
        }
        static mouseButton(a) {
          return a.button;
        }
        static remove(a) {
          a.parentNode && a.parentNode.removeChild(a);
        }
      }
      I.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, I.selectProp = I.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), I.transformProp = I.testProp(["transform", "WebkitTransform"]);
      const L = { supported: !1, testSupport: function(E) {
        !V && z && (H ? J(E) : N = E);
      } };
      let N, z, V = !1, H = !1;
      function J(E) {
        const a = E.createTexture();
        E.bindTexture(E.TEXTURE_2D, a);
        try {
          if (E.texImage2D(E.TEXTURE_2D, 0, E.RGBA, E.RGBA, E.UNSIGNED_BYTE, z), E.isContextLost())
            return;
          L.supported = !0;
        } catch {
        }
        E.deleteTexture(a), V = !0;
      }
      var ce;
      typeof document < "u" && (z = document.createElement("img"), z.onload = () => {
        N && J(N), N = null, H = !0;
      }, z.onerror = () => {
        V = !0, N = null;
      }, z.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(E) {
        let a, f, _, h;
        E.resetRequestQueue = () => {
          a = [], f = 0, _ = 0, h = {};
        }, E.addThrottleControl = (C) => {
          const M = _++;
          return h[M] = C, M;
        }, E.removeThrottleControl = (C) => {
          delete h[C], b();
        }, E.getImage = function(C, M) {
          let R = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
          return new Promise((O, D) => {
            L.supported && (C.headers || (C.headers = {}), C.headers.accept = "image/webp,*/*"), l.e(C, { type: "image" }), a.push({ abortController: M, requestParameters: C, supportImageRefresh: R, state: "queued", onError: (U) => {
              D(U);
            }, onSuccess: (U) => {
              O(U);
            } }), b();
          });
        };
        const p = (C) => l._(this, void 0, void 0, function* () {
          C.state = "running";
          const { requestParameters: M, supportImageRefresh: R, onError: O, onSuccess: D, abortController: U } = C, W = R === !1 && !l.i(self) && !l.g(M.url) && (!M.headers || Object.keys(M.headers).reduce((K, fe) => K && fe === "accept", !0));
          f++;
          const Q = W ? x(M, U) : l.m(M, U);
          try {
            const K = yield Q;
            delete C.abortController, C.state = "completed", K.data instanceof HTMLImageElement || l.b(K.data) ? D(K) : K.data && D({ data: yield (Y = K.data, typeof createImageBitmap == "function" ? l.d(Y) : l.f(Y)), cacheControl: K.cacheControl, expires: K.expires });
          } catch (K) {
            delete C.abortController, O(K);
          } finally {
            f--, b();
          }
          var Y;
        }), b = () => {
          const C = (() => {
            for (const M of Object.keys(h))
              if (h[M]())
                return !0;
            return !1;
          })() ? l.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : l.a.MAX_PARALLEL_IMAGE_REQUESTS;
          for (let M = f; M < C && a.length > 0; M++) {
            const R = a.shift();
            R.abortController.signal.aborted ? M-- : p(R);
          }
        }, x = (C, M) => new Promise((R, O) => {
          const D = new Image(), U = C.url, W = C.credentials;
          W && W === "include" ? D.crossOrigin = "use-credentials" : (W && W === "same-origin" || !l.s(U)) && (D.crossOrigin = "anonymous"), M.signal.addEventListener("abort", () => {
            D.src = "", O(l.c());
          }), D.fetchPriority = "high", D.onload = () => {
            D.onerror = D.onload = null, R({ data: D });
          }, D.onerror = () => {
            D.onerror = D.onload = null, M.signal.aborted || O(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          }, D.src = U;
        });
      }(ce || (ce = {})), ce.resetRequestQueue();
      class me {
        constructor(a) {
          this._transformRequestFn = a;
        }
        transformRequest(a, f) {
          return this._transformRequestFn && this._transformRequestFn(a, f) || { url: a };
        }
        setTransformRequest(a) {
          this._transformRequestFn = a;
        }
      }
      function Se(E) {
        var a = new l.A(3);
        return a[0] = E[0], a[1] = E[1], a[2] = E[2], a;
      }
      var De, Le = function(E, a, f) {
        return E[0] = a[0] - f[0], E[1] = a[1] - f[1], E[2] = a[2] - f[2], E;
      };
      De = new l.A(3), l.A != Float32Array && (De[0] = 0, De[1] = 0, De[2] = 0);
      var ye = function(E) {
        var a = E[0], f = E[1];
        return a * a + f * f;
      };
      function Ve(E) {
        const a = [];
        if (typeof E == "string")
          a.push({ id: "default", url: E });
        else if (E && E.length > 0) {
          const f = [];
          for (const { id: _, url: h } of E) {
            const p = `${_}${h}`;
            f.indexOf(p) === -1 && (f.push(p), a.push({ id: _, url: h }));
          }
        }
        return a;
      }
      function Fe(E, a, f) {
        const _ = E.split("?");
        return _[0] += `${a}${f}`, _.join("?");
      }
      (function() {
        var E = new l.A(2);
        l.A != Float32Array && (E[0] = 0, E[1] = 0);
      })();
      class ae {
        constructor(a, f, _, h) {
          this.context = a, this.format = _, this.texture = a.gl.createTexture(), this.update(f, h);
        }
        update(a, f, _) {
          const { width: h, height: p } = a, b = !(this.size && this.size[0] === h && this.size[1] === p || _), { context: x } = this, { gl: C } = x;
          if (this.useMipmap = !!(f && f.useMipmap), C.bindTexture(C.TEXTURE_2D, this.texture), x.pixelStoreUnpackFlipY.set(!1), x.pixelStoreUnpack.set(1), x.pixelStoreUnpackPremultiplyAlpha.set(this.format === C.RGBA && (!f || f.premultiply !== !1)), b)
            this.size = [h, p], a instanceof HTMLImageElement || a instanceof HTMLCanvasElement || a instanceof HTMLVideoElement || a instanceof ImageData || l.b(a) ? C.texImage2D(C.TEXTURE_2D, 0, this.format, this.format, C.UNSIGNED_BYTE, a) : C.texImage2D(C.TEXTURE_2D, 0, this.format, h, p, 0, this.format, C.UNSIGNED_BYTE, a.data);
          else {
            const { x: M, y: R } = _ || { x: 0, y: 0 };
            a instanceof HTMLImageElement || a instanceof HTMLCanvasElement || a instanceof HTMLVideoElement || a instanceof ImageData || l.b(a) ? C.texSubImage2D(C.TEXTURE_2D, 0, M, R, C.RGBA, C.UNSIGNED_BYTE, a) : C.texSubImage2D(C.TEXTURE_2D, 0, M, R, h, p, C.RGBA, C.UNSIGNED_BYTE, a.data);
          }
          this.useMipmap && this.isSizePowerOfTwo() && C.generateMipmap(C.TEXTURE_2D);
        }
        bind(a, f, _) {
          const { context: h } = this, { gl: p } = h;
          p.bindTexture(p.TEXTURE_2D, this.texture), _ !== p.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (_ = p.LINEAR), a !== this.filter && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, a), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, _ || a), this.filter = a), f !== this.wrap && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, f), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, f), this.wrap = f);
        }
        isSizePowerOfTwo() {
          return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
        }
        destroy() {
          const { gl: a } = this.context;
          a.deleteTexture(this.texture), this.texture = null;
        }
      }
      function de(E) {
        const { userImage: a } = E;
        return !!(a && a.render && a.render()) && (E.data.replace(new Uint8Array(a.data.buffer)), !0);
      }
      class Te extends l.E {
        constructor() {
          super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new l.R({ width: 1, height: 1 }), this.dirty = !0;
        }
        isLoaded() {
          return this.loaded;
        }
        setLoaded(a) {
          if (this.loaded !== a && (this.loaded = a, a)) {
            for (const { ids: f, promiseResolve: _ } of this.requestors)
              _(this._getImagesForIds(f));
            this.requestors = [];
          }
        }
        getImage(a) {
          const f = this.images[a];
          if (f && !f.data && f.spriteData) {
            const _ = f.spriteData;
            f.data = new l.R({ width: _.width, height: _.height }, _.context.getImageData(_.x, _.y, _.width, _.height).data), f.spriteData = null;
          }
          return f;
        }
        addImage(a, f) {
          if (this.images[a])
            throw new Error(`Image id ${a} already exist, use updateImage instead`);
          this._validate(a, f) && (this.images[a] = f);
        }
        _validate(a, f) {
          let _ = !0;
          const h = f.data || f.spriteData;
          return this._validateStretch(f.stretchX, h && h.width) || (this.fire(new l.j(new Error(`Image "${a}" has invalid "stretchX" value`))), _ = !1), this._validateStretch(f.stretchY, h && h.height) || (this.fire(new l.j(new Error(`Image "${a}" has invalid "stretchY" value`))), _ = !1), this._validateContent(f.content, f) || (this.fire(new l.j(new Error(`Image "${a}" has invalid "content" value`))), _ = !1), _;
        }
        _validateStretch(a, f) {
          if (!a)
            return !0;
          let _ = 0;
          for (const h of a) {
            if (h[0] < _ || h[1] < h[0] || f < h[1])
              return !1;
            _ = h[1];
          }
          return !0;
        }
        _validateContent(a, f) {
          if (!a)
            return !0;
          if (a.length !== 4)
            return !1;
          const _ = f.spriteData, h = _ && _.width || f.data.width, p = _ && _.height || f.data.height;
          return !(a[0] < 0 || h < a[0] || a[1] < 0 || p < a[1] || a[2] < 0 || h < a[2] || a[3] < 0 || p < a[3] || a[2] < a[0] || a[3] < a[1]);
        }
        updateImage(a, f) {
          let _ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
          const h = this.getImage(a);
          if (_ && (h.data.width !== f.data.width || h.data.height !== f.data.height))
            throw new Error(`size mismatch between old image (${h.data.width}x${h.data.height}) and new image (${f.data.width}x${f.data.height}).`);
          f.version = h.version + 1, this.images[a] = f, this.updatedImages[a] = !0;
        }
        removeImage(a) {
          const f = this.images[a];
          delete this.images[a], delete this.patterns[a], f.userImage && f.userImage.onRemove && f.userImage.onRemove();
        }
        listImages() {
          return Object.keys(this.images);
        }
        getImages(a) {
          return new Promise((f, _) => {
            let h = !0;
            if (!this.isLoaded())
              for (const p of a)
                this.images[p] || (h = !1);
            this.isLoaded() || h ? f(this._getImagesForIds(a)) : this.requestors.push({ ids: a, promiseResolve: f });
          });
        }
        _getImagesForIds(a) {
          const f = {};
          for (const _ of a) {
            let h = this.getImage(_);
            h || (this.fire(new l.k("styleimagemissing", { id: _ })), h = this.getImage(_)), h ? f[_] = { data: h.data.clone(), pixelRatio: h.pixelRatio, sdf: h.sdf, version: h.version, stretchX: h.stretchX, stretchY: h.stretchY, content: h.content, textFitWidth: h.textFitWidth, textFitHeight: h.textFitHeight, hasRenderCallback: !!(h.userImage && h.userImage.render) } : l.w(`Image "${_}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
          }
          return f;
        }
        getPixelSize() {
          const { width: a, height: f } = this.atlasImage;
          return { width: a, height: f };
        }
        getPattern(a) {
          const f = this.patterns[a], _ = this.getImage(a);
          if (!_)
            return null;
          if (f && f.position.version === _.version)
            return f.position;
          if (f)
            f.position.version = _.version;
          else {
            const h = { w: _.data.width + 2, h: _.data.height + 2, x: 0, y: 0 }, p = new l.I(h, _);
            this.patterns[a] = { bin: h, position: p };
          }
          return this._updatePatternAtlas(), this.patterns[a].position;
        }
        bind(a) {
          const f = a.gl;
          this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new ae(a, this.atlasImage, f.RGBA), this.atlasTexture.bind(f.LINEAR, f.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas() {
          const a = [];
          for (const p in this.patterns)
            a.push(this.patterns[p].bin);
          const { w: f, h: _ } = l.p(a), h = this.atlasImage;
          h.resize({ width: f || 1, height: _ || 1 });
          for (const p in this.patterns) {
            const { bin: b } = this.patterns[p], x = b.x + 1, C = b.y + 1, M = this.getImage(p).data, R = M.width, O = M.height;
            l.R.copy(M, h, { x: 0, y: 0 }, { x, y: C }, { width: R, height: O }), l.R.copy(M, h, { x: 0, y: O - 1 }, { x, y: C - 1 }, { width: R, height: 1 }), l.R.copy(M, h, { x: 0, y: 0 }, { x, y: C + O }, { width: R, height: 1 }), l.R.copy(M, h, { x: R - 1, y: 0 }, { x: x - 1, y: C }, { width: 1, height: O }), l.R.copy(M, h, { x: 0, y: 0 }, { x: x + R, y: C }, { width: 1, height: O });
          }
          this.dirty = !0;
        }
        beginFrame() {
          this.callbackDispatchedThisFrame = {};
        }
        dispatchRenderCallbacks(a) {
          for (const f of a) {
            if (this.callbackDispatchedThisFrame[f])
              continue;
            this.callbackDispatchedThisFrame[f] = !0;
            const _ = this.getImage(f);
            _ || l.w(`Image with ID: "${f}" was not found`), de(_) && this.updateImage(f, _);
          }
        }
      }
      const be = 1e20;
      function tt(E, a, f, _, h, p, b, x, C) {
        for (let M = a; M < a + _; M++)
          st(E, f * p + M, p, h, b, x, C);
        for (let M = f; M < f + h; M++)
          st(E, M * p + a, 1, _, b, x, C);
      }
      function st(E, a, f, _, h, p, b) {
        p[0] = 0, b[0] = -be, b[1] = be, h[0] = E[a];
        for (let x = 1, C = 0, M = 0; x < _; x++) {
          h[x] = E[a + x * f];
          const R = x * x;
          do {
            const O = p[C];
            M = (h[x] - h[O] + R - O * O) / (x - O) / 2;
          } while (M <= b[C] && --C > -1);
          C++, p[C] = x, b[C] = M, b[C + 1] = be;
        }
        for (let x = 0, C = 0; x < _; x++) {
          for (; b[C + 1] < x; )
            C++;
          const M = p[C], R = x - M;
          E[a + x * f] = h[M] + R * R;
        }
      }
      class lt {
        constructor(a, f) {
          this.requestManager = a, this.localIdeographFontFamily = f, this.entries = {};
        }
        setURL(a) {
          this.url = a;
        }
        getGlyphs(a) {
          return l._(this, void 0, void 0, function* () {
            const f = [];
            for (const p in a)
              for (const b of a[p])
                f.push(this._getAndCacheGlyphsPromise(p, b));
            const _ = yield Promise.all(f), h = {};
            for (const { stack: p, id: b, glyph: x } of _)
              h[p] || (h[p] = {}), h[p][b] = x && { id: x.id, bitmap: x.bitmap.clone(), metrics: x.metrics };
            return h;
          });
        }
        _getAndCacheGlyphsPromise(a, f) {
          return l._(this, void 0, void 0, function* () {
            let _ = this.entries[a];
            _ || (_ = this.entries[a] = { glyphs: {}, requests: {}, ranges: {} });
            let h = _.glyphs[f];
            if (h !== void 0)
              return { stack: a, id: f, glyph: h };
            if (h = this._tinySDF(_, a, f), h)
              return _.glyphs[f] = h, { stack: a, id: f, glyph: h };
            const p = Math.floor(f / 256);
            if (256 * p > 65535)
              throw new Error("glyphs > 65535 not supported");
            if (_.ranges[p])
              return { stack: a, id: f, glyph: h };
            if (!this.url)
              throw new Error("glyphsUrl is not set");
            if (!_.requests[p]) {
              const x = lt.loadGlyphRange(a, p, this.url, this.requestManager);
              _.requests[p] = x;
            }
            const b = yield _.requests[p];
            for (const x in b)
              this._doesCharSupportLocalGlyph(+x) || (_.glyphs[+x] = b[+x]);
            return _.ranges[p] = !0, { stack: a, id: f, glyph: b[f] || null };
          });
        }
        _doesCharSupportLocalGlyph(a) {
          return !!this.localIdeographFontFamily && (l.u["CJK Unified Ideographs"](a) || l.u["Hangul Syllables"](a) || l.u.Hiragana(a) || l.u.Katakana(a));
        }
        _tinySDF(a, f, _) {
          const h = this.localIdeographFontFamily;
          if (!h || !this._doesCharSupportLocalGlyph(_))
            return;
          let p = a.tinySDF;
          if (!p) {
            let x = "400";
            /bold/i.test(f) ? x = "900" : /medium/i.test(f) ? x = "500" : /light/i.test(f) && (x = "200"), p = a.tinySDF = new lt.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: h, fontWeight: x });
          }
          const b = p.draw(String.fromCharCode(_));
          return { id: _, bitmap: new l.o({ width: b.width || 60, height: b.height || 60 }, b.data), metrics: { width: b.glyphWidth / 2 || 24, height: b.glyphHeight / 2 || 24, left: b.glyphLeft / 2 + 0.5 || 0, top: b.glyphTop / 2 - 27.5 || -8, advance: b.glyphAdvance / 2 || 24, isDoubleResolution: !0 } };
        }
      }
      lt.loadGlyphRange = function(E, a, f, _) {
        return l._(this, void 0, void 0, function* () {
          const h = 256 * a, p = h + 255, b = _.transformRequest(f.replace("{fontstack}", E).replace("{range}", `${h}-${p}`), "Glyphs"), x = yield l.l(b, new AbortController());
          if (!x || !x.data)
            throw new Error(`Could not load glyph range. range: ${a}, ${h}-${p}`);
          const C = {};
          for (const M of l.n(x.data))
            C[M.id] = M;
          return C;
        });
      }, lt.TinySDF = class {
        constructor() {
          let { fontSize: E = 24, buffer: a = 3, radius: f = 8, cutoff: _ = 0.25, fontFamily: h = "sans-serif", fontWeight: p = "normal", fontStyle: b = "normal" } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          this.buffer = a, this.cutoff = _, this.radius = f;
          const x = this.size = E + 4 * a, C = this._createCanvas(x), M = this.ctx = C.getContext("2d", { willReadFrequently: !0 });
          M.font = `${b} ${p} ${E}px ${h}`, M.textBaseline = "alphabetic", M.textAlign = "left", M.fillStyle = "black", this.gridOuter = new Float64Array(x * x), this.gridInner = new Float64Array(x * x), this.f = new Float64Array(x), this.z = new Float64Array(x + 1), this.v = new Uint16Array(x);
        }
        _createCanvas(E) {
          const a = document.createElement("canvas");
          return a.width = a.height = E, a;
        }
        draw(E) {
          const { width: a, actualBoundingBoxAscent: f, actualBoundingBoxDescent: _, actualBoundingBoxLeft: h, actualBoundingBoxRight: p } = this.ctx.measureText(E), b = Math.ceil(f), x = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(p - h))), C = Math.min(this.size - this.buffer, b + Math.ceil(_)), M = x + 2 * this.buffer, R = C + 2 * this.buffer, O = Math.max(M * R, 0), D = new Uint8ClampedArray(O), U = { data: D, width: M, height: R, glyphWidth: x, glyphHeight: C, glyphTop: b, glyphLeft: 0, glyphAdvance: a };
          if (x === 0 || C === 0)
            return U;
          const { ctx: W, buffer: Q, gridInner: Y, gridOuter: K } = this;
          W.clearRect(Q, Q, x, C), W.fillText(E, Q, Q + b);
          const fe = W.getImageData(Q, Q, x, C);
          K.fill(be, 0, O), Y.fill(0, 0, O);
          for (let ne = 0; ne < C; ne++)
            for (let ie = 0; ie < x; ie++) {
              const le = fe.data[4 * (ne * x + ie) + 3] / 255;
              if (le === 0)
                continue;
              const xe = (ne + Q) * M + ie + Q;
              if (le === 1)
                K[xe] = 0, Y[xe] = be;
              else {
                const Me = 0.5 - le;
                K[xe] = Me > 0 ? Me * Me : 0, Y[xe] = Me < 0 ? Me * Me : 0;
              }
            }
          tt(K, 0, 0, M, R, M, this.f, this.v, this.z), tt(Y, Q, Q, x, C, M, this.f, this.v, this.z);
          for (let ne = 0; ne < O; ne++) {
            const ie = Math.sqrt(K[ne]) - Math.sqrt(Y[ne]);
            D[ne] = Math.round(255 - 255 * (ie / this.radius + this.cutoff));
          }
          return U;
        }
      };
      class Ye {
        constructor() {
          this.specification = l.v.light.position;
        }
        possiblyEvaluate(a, f) {
          return l.y(a.expression.evaluate(f));
        }
        interpolate(a, f, _) {
          return { x: l.z.number(a.x, f.x, _), y: l.z.number(a.y, f.y, _), z: l.z.number(a.z, f.z, _) };
        }
      }
      let ht;
      class ct extends l.E {
        constructor(a) {
          super(), ht = ht || new l.q({ anchor: new l.D(l.v.light.anchor), position: new Ye(), color: new l.D(l.v.light.color), intensity: new l.D(l.v.light.intensity) }), this._transitionable = new l.T(ht), this.setLight(a), this._transitioning = this._transitionable.untransitioned();
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(a) {
          let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          if (!this._validate(l.r, a, f))
            for (const _ in a) {
              const h = a[_];
              _.endsWith("-transition") ? this._transitionable.setTransition(_.slice(0, -11), h) : this._transitionable.setValue(_, h);
            }
        }
        updateTransitions(a) {
          this._transitioning = this._transitionable.transitioned(a, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(a) {
          this.properties = this._transitioning.possiblyEvaluate(a);
        }
        _validate(a, f, _) {
          return (!_ || _.validate !== !1) && l.t(this, a.call(l.x, { value: f, style: { glyphs: !0, sprite: !0 }, styleSpec: l.v }));
        }
      }
      const Pt = new l.q({ "sky-color": new l.D(l.v.sky["sky-color"]), "horizon-color": new l.D(l.v.sky["horizon-color"]), "fog-color": new l.D(l.v.sky["fog-color"]), "fog-ground-blend": new l.D(l.v.sky["fog-ground-blend"]), "horizon-fog-blend": new l.D(l.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new l.D(l.v.sky["sky-horizon-blend"]), "atmosphere-blend": new l.D(l.v.sky["atmosphere-blend"]) });
      class se extends l.E {
        constructor(a) {
          super(), this._transitionable = new l.T(Pt), this.setSky(a), this._transitioning = this._transitionable.untransitioned();
        }
        setSky(a) {
          let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          if (!this._validate(l.B, a, f))
            for (const _ in a) {
              const h = a[_];
              _.endsWith("-transition") ? this._transitionable.setTransition(_.slice(0, -11), h) : this._transitionable.setValue(_, h);
            }
        }
        getSky() {
          return this._transitionable.serialize();
        }
        updateTransitions(a) {
          this._transitioning = this._transitionable.transitioned(a, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(a) {
          this.properties = this._transitioning.possiblyEvaluate(a);
        }
        _validate(a, f) {
          let _ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return (_ == null ? void 0 : _.validate) !== !1 && l.t(this, a.call(l.x, l.e({ value: f, style: { glyphs: !0, sprite: !0 }, styleSpec: l.v })));
        }
        calculateFogBlendOpacity(a) {
          return a < 60 ? 0 : a < 70 ? (a - 60) / 10 : 1;
        }
      }
      class Ae {
        constructor(a, f) {
          this.width = a, this.height = f, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
        }
        getDash(a, f) {
          const _ = a.join(",") + String(f);
          return this.dashEntry[_] || (this.dashEntry[_] = this.addDash(a, f)), this.dashEntry[_];
        }
        getDashRanges(a, f, _) {
          const h = [];
          let p = a.length % 2 == 1 ? -a[a.length - 1] * _ : 0, b = a[0] * _, x = !0;
          h.push({ left: p, right: b, isDash: x, zeroLength: a[0] === 0 });
          let C = a[0];
          for (let M = 1; M < a.length; M++) {
            x = !x;
            const R = a[M];
            p = C * _, C += R, b = C * _, h.push({ left: p, right: b, isDash: x, zeroLength: R === 0 });
          }
          return h;
        }
        addRoundDash(a, f, _) {
          const h = f / 2;
          for (let p = -_; p <= _; p++) {
            const b = this.width * (this.nextRow + _ + p);
            let x = 0, C = a[x];
            for (let M = 0; M < this.width; M++) {
              M / C.right > 1 && (C = a[++x]);
              const R = Math.abs(M - C.left), O = Math.abs(M - C.right), D = Math.min(R, O);
              let U;
              const W = p / _ * (h + 1);
              if (C.isDash) {
                const Q = h - Math.abs(W);
                U = Math.sqrt(D * D + Q * Q);
              } else
                U = h - Math.sqrt(D * D + W * W);
              this.data[b + M] = Math.max(0, Math.min(255, U + 128));
            }
          }
        }
        addRegularDash(a) {
          for (let x = a.length - 1; x >= 0; --x) {
            const C = a[x], M = a[x + 1];
            C.zeroLength ? a.splice(x, 1) : M && M.isDash === C.isDash && (M.left = C.left, a.splice(x, 1));
          }
          const f = a[0], _ = a[a.length - 1];
          f.isDash === _.isDash && (f.left = _.left - this.width, _.right = f.right + this.width);
          const h = this.width * this.nextRow;
          let p = 0, b = a[p];
          for (let x = 0; x < this.width; x++) {
            x / b.right > 1 && (b = a[++p]);
            const C = Math.abs(x - b.left), M = Math.abs(x - b.right), R = Math.min(C, M);
            this.data[h + x] = Math.max(0, Math.min(255, (b.isDash ? R : -R) + 128));
          }
        }
        addDash(a, f) {
          const _ = f ? 7 : 0, h = 2 * _ + 1;
          if (this.nextRow + h > this.height)
            return l.w("LineAtlas out of space"), null;
          let p = 0;
          for (let x = 0; x < a.length; x++)
            p += a[x];
          if (p !== 0) {
            const x = this.width / p, C = this.getDashRanges(a, this.width, x);
            f ? this.addRoundDash(C, x, _) : this.addRegularDash(C);
          }
          const b = { y: (this.nextRow + _ + 0.5) / this.height, height: 2 * _ / this.height, width: p };
          return this.nextRow += h, this.dirty = !0, b;
        }
        bind(a) {
          const f = a.gl;
          this.texture ? (f.bindTexture(f.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, f.texSubImage2D(f.TEXTURE_2D, 0, 0, 0, this.width, this.height, f.ALPHA, f.UNSIGNED_BYTE, this.data))) : (this.texture = f.createTexture(), f.bindTexture(f.TEXTURE_2D, this.texture), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, f.REPEAT), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, f.REPEAT), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, f.LINEAR), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, f.LINEAR), f.texImage2D(f.TEXTURE_2D, 0, f.ALPHA, this.width, this.height, 0, f.ALPHA, f.UNSIGNED_BYTE, this.data));
        }
      }
      const Ce = "maplibre_preloaded_worker_pool";
      class Ue {
        constructor() {
          this.active = {};
        }
        acquire(a) {
          if (!this.workers)
            for (this.workers = []; this.workers.length < Ue.workerCount; )
              this.workers.push(new Worker(l.a.WORKER_URL));
          return this.active[a] = !0, this.workers.slice();
        }
        release(a) {
          delete this.active[a], this.numActive() === 0 && (this.workers.forEach((f) => {
            f.terminate();
          }), this.workers = null);
        }
        isPreloaded() {
          return !!this.active[Ce];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      const qe = Math.floor(T.hardwareConcurrency / 2);
      let We, Ke;
      function Ze() {
        return We || (We = new Ue()), We;
      }
      Ue.workerCount = l.C(globalThis) ? Math.max(Math.min(qe, 3), 1) : 1;
      class At {
        constructor(a, f) {
          this.workerPool = a, this.actors = [], this.currentActor = 0, this.id = f;
          const _ = this.workerPool.acquire(f);
          for (let h = 0; h < _.length; h++) {
            const p = new l.F(_[h], f);
            p.name = `Worker ${h}`, this.actors.push(p);
          }
          if (!this.actors.length)
            throw new Error("No actors found");
        }
        broadcast(a, f) {
          const _ = [];
          for (const h of this.actors)
            _.push(h.sendAsync({ type: a, data: f }));
          return Promise.all(_);
        }
        getActor() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }
        remove() {
          let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
          this.actors.forEach((f) => {
            f.remove();
          }), this.actors = [], a && this.workerPool.release(this.id);
        }
        registerMessageHandler(a, f) {
          for (const _ of this.actors)
            _.registerMessageHandler(a, f);
        }
      }
      function It() {
        return Ke || (Ke = new At(Ze(), l.G), Ke.registerMessageHandler("GR", (E, a, f) => l.m(a, f))), Ke;
      }
      function Rt(E, a) {
        const f = l.H();
        return l.J(f, f, [1, 1, 0]), l.K(f, f, [0.5 * E.width, 0.5 * E.height, 1]), l.L(f, f, E.calculatePosMatrix(a.toUnwrapped()));
      }
      function kt(E, a, f, _, h, p) {
        const b = function(O, D, U) {
          if (O)
            for (const W of O) {
              const Q = D[W];
              if (Q && Q.source === U && Q.type === "fill-extrusion")
                return !0;
            }
          else
            for (const W in D) {
              const Q = D[W];
              if (Q.source === U && Q.type === "fill-extrusion")
                return !0;
            }
          return !1;
        }(h && h.layers, a, E.id), x = p.maxPitchScaleFactor(), C = E.tilesIn(_, x, b);
        C.sort(on);
        const M = [];
        for (const O of C)
          M.push({ wrappedTileID: O.tileID.wrapped().key, queryResults: O.tile.queryRenderedFeatures(a, f, E._state, O.queryGeometry, O.cameraQueryGeometry, O.scale, h, p, x, Rt(E.transform, O.tileID)) });
        const R = function(O) {
          const D = {}, U = {};
          for (const W of O) {
            const Q = W.queryResults, Y = W.wrappedTileID, K = U[Y] = U[Y] || {};
            for (const fe in Q) {
              const ne = Q[fe], ie = K[fe] = K[fe] || {}, le = D[fe] = D[fe] || [];
              for (const xe of ne)
                ie[xe.featureIndex] || (ie[xe.featureIndex] = !0, le.push(xe));
            }
          }
          return D;
        }(M);
        for (const O in R)
          R[O].forEach((D) => {
            const U = D.feature, W = E.getFeatureState(U.layer["source-layer"], U.id);
            U.source = U.layer.source, U.layer["source-layer"] && (U.sourceLayer = U.layer["source-layer"]), U.state = W;
          });
        return R;
      }
      function on(E, a) {
        const f = E.tileID, _ = a.tileID;
        return f.overscaledZ - _.overscaledZ || f.canonical.y - _.canonical.y || f.wrap - _.wrap || f.canonical.x - _.canonical.x;
      }
      function ut(E, a, f) {
        return l._(this, void 0, void 0, function* () {
          let _ = E;
          if (E.url ? _ = (yield l.h(a.transformRequest(E.url, "Source"), f)).data : yield T.frameAsync(f), !_)
            return null;
          const h = l.M(l.e(_, E), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
          return "vector_layers" in _ && _.vector_layers && (h.vectorLayerIds = _.vector_layers.map((p) => p.id)), h;
        });
      }
      class re {
        constructor(a, f) {
          a && (f ? this.setSouthWest(a).setNorthEast(f) : Array.isArray(a) && (a.length === 4 ? this.setSouthWest([a[0], a[1]]).setNorthEast([a[2], a[3]]) : this.setSouthWest(a[0]).setNorthEast(a[1])));
        }
        setNorthEast(a) {
          return this._ne = a instanceof l.N ? new l.N(a.lng, a.lat) : l.N.convert(a), this;
        }
        setSouthWest(a) {
          return this._sw = a instanceof l.N ? new l.N(a.lng, a.lat) : l.N.convert(a), this;
        }
        extend(a) {
          const f = this._sw, _ = this._ne;
          let h, p;
          if (a instanceof l.N)
            h = a, p = a;
          else {
            if (!(a instanceof re))
              return Array.isArray(a) ? a.length === 4 || a.every(Array.isArray) ? this.extend(re.convert(a)) : this.extend(l.N.convert(a)) : a && ("lng" in a || "lon" in a) && "lat" in a ? this.extend(l.N.convert(a)) : this;
            if (h = a._sw, p = a._ne, !h || !p)
              return this;
          }
          return f || _ ? (f.lng = Math.min(h.lng, f.lng), f.lat = Math.min(h.lat, f.lat), _.lng = Math.max(p.lng, _.lng), _.lat = Math.max(p.lat, _.lat)) : (this._sw = new l.N(h.lng, h.lat), this._ne = new l.N(p.lng, p.lat)), this;
        }
        getCenter() {
          return new l.N((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new l.N(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new l.N(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(a) {
          const { lng: f, lat: _ } = l.N.convert(a);
          let h = this._sw.lng <= f && f <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (h = this._sw.lng >= f && f >= this._ne.lng), this._sw.lat <= _ && _ <= this._ne.lat && h;
        }
        static convert(a) {
          return a instanceof re ? a : a && new re(a);
        }
        static fromLngLat(a) {
          const _ = 360 * (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0) / 40075017, h = _ / Math.cos(Math.PI / 180 * a.lat);
          return new re(new l.N(a.lng - h, a.lat - _), new l.N(a.lng + h, a.lat + _));
        }
      }
      class mn {
        constructor(a, f, _) {
          this.bounds = re.convert(this.validateBounds(a)), this.minzoom = f || 0, this.maxzoom = _ || 24;
        }
        validateBounds(a) {
          return Array.isArray(a) && a.length === 4 ? [Math.max(-180, a[0]), Math.max(-90, a[1]), Math.min(180, a[2]), Math.min(90, a[3])] : [-180, -90, 180, 90];
        }
        contains(a) {
          const f = Math.pow(2, a.z), _ = Math.floor(l.O(this.bounds.getWest()) * f), h = Math.floor(l.Q(this.bounds.getNorth()) * f), p = Math.ceil(l.O(this.bounds.getEast()) * f), b = Math.ceil(l.Q(this.bounds.getSouth()) * f);
          return a.x >= _ && a.x < p && a.y >= h && a.y < b;
        }
      }
      class Qt extends l.E {
        constructor(a, f, _, h) {
          if (super(), this.id = a, this.dispatcher = _, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, l.e(this, l.M(f, ["url", "scheme", "tileSize", "promoteId"])), this._options = l.e({ type: "vector" }, f), this._collectResourceTiming = f.collectResourceTiming, this.tileSize !== 512)
            throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(h);
        }
        load() {
          return l._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new l.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
            try {
              const a = yield ut(this._options, this.map._requestManager, this._tileJSONRequest);
              this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), a && (l.e(this, a), a.bounds && (this.tileBounds = new mn(a.bounds, this.minzoom, this.maxzoom)), this.fire(new l.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new l.k("data", { dataType: "source", sourceDataType: "content" })));
            } catch (a) {
              this._tileJSONRequest = null, this.fire(new l.j(a));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        hasTile(a) {
          return !this.tileBounds || this.tileBounds.contains(a.canonical);
        }
        onAdd(a) {
          this.map = a, this.load();
        }
        setSourceProperty(a) {
          this._tileJSONRequest && this._tileJSONRequest.abort(), a(), this.load();
        }
        setTiles(a) {
          return this.setSourceProperty(() => {
            this._options.tiles = a;
          }), this;
        }
        setUrl(a) {
          return this.setSourceProperty(() => {
            this.url = a, this._options.url = a;
          }), this;
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
        }
        serialize() {
          return l.e({}, this._options);
        }
        loadTile(a) {
          return l._(this, void 0, void 0, function* () {
            const f = a.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), _ = { request: this.map._requestManager.transformRequest(f, "Tile"), uid: a.uid, tileID: a.tileID, zoom: a.tileID.overscaledZ, tileSize: this.tileSize * a.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            _.request.collectResourceTiming = this._collectResourceTiming;
            let h = "RT";
            if (a.actor && a.state !== "expired") {
              if (a.state === "loading")
                return new Promise((p, b) => {
                  a.reloadPromise = { resolve: p, reject: b };
                });
            } else
              a.actor = this.dispatcher.getActor(), h = "LT";
            a.abortController = new AbortController();
            try {
              const p = yield a.actor.sendAsync({ type: h, data: _ }, a.abortController);
              if (delete a.abortController, a.aborted)
                return;
              this._afterTileLoadWorkerResponse(a, p);
            } catch (p) {
              if (delete a.abortController, a.aborted)
                return;
              if (p && p.status !== 404)
                throw p;
              this._afterTileLoadWorkerResponse(a, null);
            }
          });
        }
        _afterTileLoadWorkerResponse(a, f) {
          if (f && f.resourceTiming && (a.resourceTiming = f.resourceTiming), f && this.map._refreshExpiredTiles && a.setExpiryData(f), a.loadVectorData(f, this.map.painter), a.reloadPromise) {
            const _ = a.reloadPromise;
            a.reloadPromise = null, this.loadTile(a).then(_.resolve).catch(_.reject);
          }
        }
        abortTile(a) {
          return l._(this, void 0, void 0, function* () {
            a.abortController && (a.abortController.abort(), delete a.abortController), a.actor && (yield a.actor.sendAsync({ type: "AT", data: { uid: a.uid, type: this.type, source: this.id } }));
          });
        }
        unloadTile(a) {
          return l._(this, void 0, void 0, function* () {
            a.unloadVectorData(), a.actor && (yield a.actor.sendAsync({ type: "RMT", data: { uid: a.uid, type: this.type, source: this.id } }));
          });
        }
        hasTransition() {
          return !1;
        }
      }
      class pt extends l.E {
        constructor(a, f, _, h) {
          super(), this.id = a, this.dispatcher = _, this.setEventedParent(h), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = l.e({ type: "raster" }, f), l.e(this, l.M(f, ["url", "scheme", "tileSize"]));
        }
        load() {
          return l._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new l.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
            try {
              const a = yield ut(this._options, this.map._requestManager, this._tileJSONRequest);
              this._tileJSONRequest = null, this._loaded = !0, a && (l.e(this, a), a.bounds && (this.tileBounds = new mn(a.bounds, this.minzoom, this.maxzoom)), this.fire(new l.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new l.k("data", { dataType: "source", sourceDataType: "content" })));
            } catch (a) {
              this._tileJSONRequest = null, this.fire(new l.j(a));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        onAdd(a) {
          this.map = a, this.load();
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
        }
        setSourceProperty(a) {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), a(), this.load();
        }
        setTiles(a) {
          return this.setSourceProperty(() => {
            this._options.tiles = a;
          }), this;
        }
        setUrl(a) {
          return this.setSourceProperty(() => {
            this.url = a, this._options.url = a;
          }), this;
        }
        serialize() {
          return l.e({}, this._options);
        }
        hasTile(a) {
          return !this.tileBounds || this.tileBounds.contains(a.canonical);
        }
        loadTile(a) {
          return l._(this, void 0, void 0, function* () {
            const f = a.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
            a.abortController = new AbortController();
            try {
              const _ = yield ce.getImage(this.map._requestManager.transformRequest(f, "Tile"), a.abortController, this.map._refreshExpiredTiles);
              if (delete a.abortController, a.aborted)
                return void (a.state = "unloaded");
              if (_ && _.data) {
                this.map._refreshExpiredTiles && _.cacheControl && _.expires && a.setExpiryData({ cacheControl: _.cacheControl, expires: _.expires });
                const h = this.map.painter.context, p = h.gl, b = _.data;
                a.texture = this.map.painter.getTileTexture(b.width), a.texture ? a.texture.update(b, { useMipmap: !0 }) : (a.texture = new ae(h, b, p.RGBA, { useMipmap: !0 }), a.texture.bind(p.LINEAR, p.CLAMP_TO_EDGE, p.LINEAR_MIPMAP_NEAREST), h.extTextureFilterAnisotropic && p.texParameterf(p.TEXTURE_2D, h.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, h.extTextureFilterAnisotropicMax)), a.state = "loaded";
              }
            } catch (_) {
              if (delete a.abortController, a.aborted)
                a.state = "unloaded";
              else if (_)
                throw a.state = "errored", _;
            }
          });
        }
        abortTile(a) {
          return l._(this, void 0, void 0, function* () {
            a.abortController && (a.abortController.abort(), delete a.abortController);
          });
        }
        unloadTile(a) {
          return l._(this, void 0, void 0, function* () {
            a.texture && this.map.painter.saveTileTexture(a.texture);
          });
        }
        hasTransition() {
          return !1;
        }
      }
      class Et extends pt {
        constructor(a, f, _, h) {
          super(a, f, _, h), this.type = "raster-dem", this.maxzoom = 22, this._options = l.e({ type: "raster-dem" }, f), this.encoding = f.encoding || "mapbox", this.redFactor = f.redFactor, this.greenFactor = f.greenFactor, this.blueFactor = f.blueFactor, this.baseShift = f.baseShift;
        }
        loadTile(a) {
          return l._(this, void 0, void 0, function* () {
            const f = a.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), _ = this.map._requestManager.transformRequest(f, "Tile");
            a.neighboringTiles = this._getNeighboringTiles(a.tileID), a.abortController = new AbortController();
            try {
              const h = yield ce.getImage(_, a.abortController, this.map._refreshExpiredTiles);
              if (delete a.abortController, a.aborted)
                return void (a.state = "unloaded");
              if (h && h.data) {
                const p = h.data;
                this.map._refreshExpiredTiles && h.cacheControl && h.expires && a.setExpiryData({ cacheControl: h.cacheControl, expires: h.expires });
                const b = l.b(p) && l.U() ? p : yield this.readImageNow(p), x = { type: this.type, uid: a.uid, source: this.id, rawImageData: b, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                if (!a.actor || a.state === "expired") {
                  a.actor = this.dispatcher.getActor();
                  const C = yield a.actor.sendAsync({ type: "LDT", data: x });
                  a.dem = C, a.needsHillshadePrepare = !0, a.needsTerrainPrepare = !0, a.state = "loaded";
                }
              }
            } catch (h) {
              if (delete a.abortController, a.aborted)
                a.state = "unloaded";
              else if (h)
                throw a.state = "errored", h;
            }
          });
        }
        readImageNow(a) {
          return l._(this, void 0, void 0, function* () {
            if (typeof VideoFrame < "u" && l.V()) {
              const f = a.width + 2, _ = a.height + 2;
              try {
                return new l.R({ width: f, height: _ }, yield l.W(a, -1, -1, f, _));
              } catch {
              }
            }
            return T.getImageData(a, 1);
          });
        }
        _getNeighboringTiles(a) {
          const f = a.canonical, _ = Math.pow(2, f.z), h = (f.x - 1 + _) % _, p = f.x === 0 ? a.wrap - 1 : a.wrap, b = (f.x + 1 + _) % _, x = f.x + 1 === _ ? a.wrap + 1 : a.wrap, C = {};
          return C[new l.S(a.overscaledZ, p, f.z, h, f.y).key] = { backfilled: !1 }, C[new l.S(a.overscaledZ, x, f.z, b, f.y).key] = { backfilled: !1 }, f.y > 0 && (C[new l.S(a.overscaledZ, p, f.z, h, f.y - 1).key] = { backfilled: !1 }, C[new l.S(a.overscaledZ, a.wrap, f.z, f.x, f.y - 1).key] = { backfilled: !1 }, C[new l.S(a.overscaledZ, x, f.z, b, f.y - 1).key] = { backfilled: !1 }), f.y + 1 < _ && (C[new l.S(a.overscaledZ, p, f.z, h, f.y + 1).key] = { backfilled: !1 }, C[new l.S(a.overscaledZ, a.wrap, f.z, f.x, f.y + 1).key] = { backfilled: !1 }, C[new l.S(a.overscaledZ, x, f.z, b, f.y + 1).key] = { backfilled: !1 }), C;
        }
        unloadTile(a) {
          return l._(this, void 0, void 0, function* () {
            a.demTexture && this.map.painter.saveTileTexture(a.demTexture), a.fbo && (a.fbo.destroy(), delete a.fbo), a.dem && delete a.dem, delete a.neighboringTiles, a.state = "unloaded", a.actor && (yield a.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: a.uid, source: this.id } }));
          });
        }
      }
      class Lt extends l.E {
        constructor(a, f, _, h) {
          super(), this.id = a, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._pendingLoads = 0, this.actor = _.getActor(), this.setEventedParent(h), this._data = f.data, this._options = l.e({}, f), this._collectResourceTiming = f.collectResourceTiming, f.maxzoom !== void 0 && (this.maxzoom = f.maxzoom), f.type && (this.type = f.type), f.attribution && (this.attribution = f.attribution), this.promoteId = f.promoteId;
          const p = l.X / this.tileSize;
          this.workerOptions = l.e({ source: this.id, cluster: f.cluster || !1, geojsonVtOptions: { buffer: (f.buffer !== void 0 ? f.buffer : 128) * p, tolerance: (f.tolerance !== void 0 ? f.tolerance : 0.375) * p, extent: l.X, maxZoom: this.maxzoom, lineMetrics: f.lineMetrics || !1, generateId: f.generateId || !1 }, superclusterOptions: { maxZoom: f.clusterMaxZoom !== void 0 ? f.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, f.clusterMinPoints || 2), extent: l.X, radius: (f.clusterRadius || 50) * p, log: !1, generateId: f.generateId || !1 }, clusterProperties: f.clusterProperties, filter: f.filter }, f.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
        }
        load() {
          return l._(this, void 0, void 0, function* () {
            yield this._updateWorkerData();
          });
        }
        onAdd(a) {
          this.map = a, this.load();
        }
        setData(a) {
          return this._data = a, this._updateWorkerData(), this;
        }
        updateData(a) {
          return this._updateWorkerData(a), this;
        }
        getData() {
          return l._(this, void 0, void 0, function* () {
            const a = l.e({ type: this.type }, this.workerOptions);
            return this.actor.sendAsync({ type: "GD", data: a });
          });
        }
        setClusterOptions(a) {
          return this.workerOptions.cluster = a.cluster, a && (a.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = a.clusterRadius), a.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = a.clusterMaxZoom)), this._updateWorkerData(), this;
        }
        getClusterExpansionZoom(a) {
          return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: a, source: this.id } });
        }
        getClusterChildren(a) {
          return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: a, source: this.id } });
        }
        getClusterLeaves(a, f, _) {
          return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: a, limit: f, offset: _ } });
        }
        _updateWorkerData(a) {
          return l._(this, void 0, void 0, function* () {
            const f = l.e({ type: this.type }, this.workerOptions);
            a ? f.dataDiff = a : typeof this._data == "string" ? (f.request = this.map._requestManager.transformRequest(T.resolveURL(this._data), "Source"), f.request.collectResourceTiming = this._collectResourceTiming) : f.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new l.k("dataloading", { dataType: "source" }));
            try {
              const _ = yield this.actor.sendAsync({ type: "LD", data: f });
              if (this._pendingLoads--, this._removed || _.abandoned)
                return void this.fire(new l.k("dataabort", { dataType: "source" }));
              let h = null;
              _.resourceTiming && _.resourceTiming[this.id] && (h = _.resourceTiming[this.id].slice(0));
              const p = { dataType: "source" };
              this._collectResourceTiming && h && h.length > 0 && l.e(p, { resourceTiming: h }), this.fire(new l.k("data", Object.assign(Object.assign({}, p), { sourceDataType: "metadata" }))), this.fire(new l.k("data", Object.assign(Object.assign({}, p), { sourceDataType: "content" })));
            } catch (_) {
              if (this._pendingLoads--, this._removed)
                return void this.fire(new l.k("dataabort", { dataType: "source" }));
              this.fire(new l.j(_));
            }
          });
        }
        loaded() {
          return this._pendingLoads === 0;
        }
        loadTile(a) {
          return l._(this, void 0, void 0, function* () {
            const f = a.actor ? "RT" : "LT";
            a.actor = this.actor;
            const _ = { type: this.type, uid: a.uid, tileID: a.tileID, zoom: a.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            a.abortController = new AbortController();
            const h = yield this.actor.sendAsync({ type: f, data: _ }, a.abortController);
            delete a.abortController, a.unloadVectorData(), a.aborted || a.loadVectorData(h, this.map.painter, f === "RT");
          });
        }
        abortTile(a) {
          return l._(this, void 0, void 0, function* () {
            a.abortController && (a.abortController.abort(), delete a.abortController), a.aborted = !0;
          });
        }
        unloadTile(a) {
          return l._(this, void 0, void 0, function* () {
            a.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: a.uid, type: this.type, source: this.id } });
          });
        }
        onRemove() {
          this._removed = !0, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
        }
        serialize() {
          return l.e({}, this._options, { type: this.type, data: this._data });
        }
        hasTransition() {
          return !1;
        }
      }
      var Ft = l.Y([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
      class nn extends l.E {
        constructor(a, f, _, h) {
          super(), this.id = a, this.dispatcher = _, this.coordinates = f.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(h), this.options = f;
        }
        load(a) {
          return l._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new l.k("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
            try {
              const f = yield ce.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
              this._request = null, this._loaded = !0, f && f.data && (this.image = f.data, a && (this.coordinates = a), this._finishLoading());
            } catch (f) {
              this._request = null, this._loaded = !0, this.fire(new l.j(f));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        updateImage(a) {
          return a.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = a.url, this.load(a.coordinates).finally(() => {
            this.texture = null;
          }), this) : this;
        }
        _finishLoading() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new l.k("data", { dataType: "source", sourceDataType: "metadata" })));
        }
        onAdd(a) {
          this.map = a, this.load();
        }
        onRemove() {
          this._request && (this._request.abort(), this._request = null);
        }
        setCoordinates(a) {
          this.coordinates = a;
          const f = a.map(l.Z.fromLngLat);
          this.tileID = function(h) {
            let p = 1 / 0, b = 1 / 0, x = -1 / 0, C = -1 / 0;
            for (const D of h)
              p = Math.min(p, D.x), b = Math.min(b, D.y), x = Math.max(x, D.x), C = Math.max(C, D.y);
            const M = Math.max(x - p, C - b), R = Math.max(0, Math.floor(-Math.log(M) / Math.LN2)), O = Math.pow(2, R);
            return new l.a1(R, Math.floor((p + x) / 2 * O), Math.floor((b + C) / 2 * O));
          }(f), this.minzoom = this.maxzoom = this.tileID.z;
          const _ = f.map((h) => this.tileID.getTilePoint(h)._round());
          return this._boundsArray = new l.$(), this._boundsArray.emplaceBack(_[0].x, _[0].y, 0, 0), this._boundsArray.emplaceBack(_[1].x, _[1].y, l.X, 0), this._boundsArray.emplaceBack(_[3].x, _[3].y, 0, l.X), this._boundsArray.emplaceBack(_[2].x, _[2].y, l.X, l.X), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new l.k("data", { dataType: "source", sourceDataType: "content" })), this;
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || !this.image)
            return;
          const a = this.map.painter.context, f = a.gl;
          this.boundsBuffer || (this.boundsBuffer = a.createVertexBuffer(this._boundsArray, Ft.members)), this.boundsSegments || (this.boundsSegments = l.a0.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new ae(a, this.image, f.RGBA), this.texture.bind(f.LINEAR, f.CLAMP_TO_EDGE));
          let _ = !1;
          for (const h in this.tiles) {
            const p = this.tiles[h];
            p.state !== "loaded" && (p.state = "loaded", p.texture = this.texture, _ = !0);
          }
          _ && this.fire(new l.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        loadTile(a) {
          return l._(this, void 0, void 0, function* () {
            this.tileID && this.tileID.equals(a.tileID.canonical) ? (this.tiles[String(a.tileID.wrap)] = a, a.buckets = {}) : a.state = "errored";
          });
        }
        serialize() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }
        hasTransition() {
          return !1;
        }
      }
      class Tn extends nn {
        constructor(a, f, _, h) {
          super(a, f, _, h), this.roundZoom = !0, this.type = "video", this.options = f;
        }
        load() {
          return l._(this, void 0, void 0, function* () {
            this._loaded = !1;
            const a = this.options;
            this.urls = [];
            for (const f of a.urls)
              this.urls.push(this.map._requestManager.transformRequest(f, "Source").url);
            try {
              const f = yield l.a3(this.urls);
              if (this._loaded = !0, !f)
                return;
              this.video = f, this.video.loop = !0, this.video.addEventListener("playing", () => {
                this.map.triggerRepaint();
              }), this.map && this.video.play(), this._finishLoading();
            } catch (f) {
              this.fire(new l.j(f));
            }
          });
        }
        pause() {
          this.video && this.video.pause();
        }
        play() {
          this.video && this.video.play();
        }
        seek(a) {
          if (this.video) {
            const f = this.video.seekable;
            a < f.start(0) || a > f.end(0) ? this.fire(new l.j(new l.a2(`sources.${this.id}`, null, `Playback for this video can be set only between the ${f.start(0)} and ${f.end(0)}-second mark.`))) : this.video.currentTime = a;
          }
        }
        getVideo() {
          return this.video;
        }
        onAdd(a) {
          this.map || (this.map = a, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2)
            return;
          const a = this.map.painter.context, f = a.gl;
          this.boundsBuffer || (this.boundsBuffer = a.createVertexBuffer(this._boundsArray, Ft.members)), this.boundsSegments || (this.boundsSegments = l.a0.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(f.LINEAR, f.CLAMP_TO_EDGE), f.texSubImage2D(f.TEXTURE_2D, 0, 0, 0, f.RGBA, f.UNSIGNED_BYTE, this.video)) : (this.texture = new ae(a, this.video, f.RGBA), this.texture.bind(f.LINEAR, f.CLAMP_TO_EDGE));
          let _ = !1;
          for (const h in this.tiles) {
            const p = this.tiles[h];
            p.state !== "loaded" && (p.state = "loaded", p.texture = this.texture, _ = !0);
          }
          _ && this.fire(new l.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        serialize() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }
        hasTransition() {
          return this.video && !this.video.paused;
        }
      }
      class xn extends nn {
        constructor(a, f, _, h) {
          super(a, f, _, h), f.coordinates ? Array.isArray(f.coordinates) && f.coordinates.length === 4 && !f.coordinates.some((p) => !Array.isArray(p) || p.length !== 2 || p.some((b) => typeof b != "number")) || this.fire(new l.j(new l.a2(`sources.${a}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new l.j(new l.a2(`sources.${a}`, null, 'missing required property "coordinates"'))), f.animate && typeof f.animate != "boolean" && this.fire(new l.j(new l.a2(`sources.${a}`, null, 'optional "animate" property must be a boolean value'))), f.canvas ? typeof f.canvas == "string" || f.canvas instanceof HTMLCanvasElement || this.fire(new l.j(new l.a2(`sources.${a}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new l.j(new l.a2(`sources.${a}`, null, 'missing required property "canvas"'))), this.options = f, this.animate = f.animate === void 0 || f.animate;
        }
        load() {
          return l._(this, void 0, void 0, function* () {
            this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new l.j(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
              this._playing = !0, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this.prepare(), this._playing = !1);
            }, this._finishLoading());
          });
        }
        getCanvas() {
          return this.canvas;
        }
        onAdd(a) {
          this.map = a, this.load(), this.canvas && this.animate && this.play();
        }
        onRemove() {
          this.pause();
        }
        prepare() {
          let a = !1;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, a = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, a = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0)
            return;
          const f = this.map.painter.context, _ = f.gl;
          this.boundsBuffer || (this.boundsBuffer = f.createVertexBuffer(this._boundsArray, Ft.members)), this.boundsSegments || (this.boundsSegments = l.a0.simpleSegment(0, 0, 4, 2)), this.texture ? (a || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new ae(f, this.canvas, _.RGBA, { premultiply: !0 });
          let h = !1;
          for (const p in this.tiles) {
            const b = this.tiles[p];
            b.state !== "loaded" && (b.state = "loaded", b.texture = this.texture, h = !0);
          }
          h && this.fire(new l.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        serialize() {
          return { type: "canvas", coordinates: this.coordinates };
        }
        hasTransition() {
          return this._playing;
        }
        _hasInvalidDimensions() {
          for (const a of [this.canvas.width, this.canvas.height])
            if (isNaN(a) || a <= 0)
              return !0;
          return !1;
        }
      }
      const On = {}, Un = (E) => {
        switch (E) {
          case "geojson":
            return Lt;
          case "image":
            return nn;
          case "raster":
            return pt;
          case "raster-dem":
            return Et;
          case "vector":
            return Qt;
          case "video":
            return Tn;
          case "canvas":
            return xn;
        }
        return On[E];
      }, mt = "RTLPluginLoaded";
      class hn extends l.E {
        constructor() {
          super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = It();
        }
        _syncState(a) {
          return this.status = a, this.dispatcher.broadcast("SRPS", { pluginStatus: a, pluginURL: this.url }).catch((f) => {
            throw this.status = "error", f;
          });
        }
        getRTLTextPluginStatus() {
          return this.status;
        }
        clearRTLTextPlugin() {
          this.status = "unavailable", this.url = null;
        }
        setRTLTextPlugin(a) {
          return l._(this, arguments, void 0, function(f) {
            var _ = this;
            let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
            return function* () {
              if (_.url)
                throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (_.url = T.resolveURL(f), !_.url)
                throw new Error(`requested url ${f} is invalid`);
              if (_.status === "unavailable") {
                if (!h)
                  return _._requestImport();
                _.status = "deferred", _._syncState(_.status);
              } else if (_.status === "requested")
                return _._requestImport();
            }();
          });
        }
        _requestImport() {
          return l._(this, void 0, void 0, function* () {
            yield this._syncState("loading"), this.status = "loaded", this.fire(new l.k(mt));
          });
        }
        lazyLoad() {
          this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
        }
      }
      let wn = null;
      function Bt() {
        return wn || (wn = new hn()), wn;
      }
      class bi {
        constructor(a, f) {
          this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = a, this.uid = l.a4(), this.uses = 0, this.tileSize = f, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
        }
        registerFadeDuration(a) {
          const f = a + this.timeAdded;
          f < this.fadeEndTime || (this.fadeEndTime = f);
        }
        wasRequested() {
          return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
        }
        clearTextures(a) {
          this.demTexture && a.saveTileTexture(this.demTexture), this.demTexture = null;
        }
        loadVectorData(a, f, _) {
          if (this.hasData() && this.unloadVectorData(), this.state = "loaded", a) {
            a.featureIndex && (this.latestFeatureIndex = a.featureIndex, a.rawTileData ? (this.latestRawTileData = a.rawTileData, this.latestFeatureIndex.rawTileData = a.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = a.collisionBoxArray, this.buckets = function(h, p) {
              const b = {};
              if (!p)
                return b;
              for (const x of h) {
                const C = x.layerIds.map((M) => p.getLayer(M)).filter(Boolean);
                if (C.length !== 0) {
                  x.layers = C, x.stateDependentLayerIds && (x.stateDependentLayers = x.stateDependentLayerIds.map((M) => C.filter((R) => R.id === M)[0]));
                  for (const M of C)
                    b[M.id] = x;
                }
              }
              return b;
            }(a.buckets, f.style), this.hasSymbolBuckets = !1;
            for (const h in this.buckets) {
              const p = this.buckets[h];
              if (p instanceof l.a6) {
                if (this.hasSymbolBuckets = !0, !_)
                  break;
                p.justReloaded = !0;
              }
            }
            if (this.hasRTLText = !1, this.hasSymbolBuckets)
              for (const h in this.buckets) {
                const p = this.buckets[h];
                if (p instanceof l.a6 && p.hasRTLText) {
                  this.hasRTLText = !0, Bt().lazyLoad();
                  break;
                }
              }
            this.queryPadding = 0;
            for (const h in this.buckets) {
              const p = this.buckets[h];
              this.queryPadding = Math.max(this.queryPadding, f.style.getLayer(h).queryRadius(p));
            }
            a.imageAtlas && (this.imageAtlas = a.imageAtlas), a.glyphAtlasImage && (this.glyphAtlasImage = a.glyphAtlasImage);
          } else
            this.collisionBoxArray = new l.a5();
        }
        unloadVectorData() {
          for (const a in this.buckets)
            this.buckets[a].destroy();
          this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
        }
        getBucket(a) {
          return this.buckets[a.id];
        }
        upload(a) {
          for (const _ in this.buckets) {
            const h = this.buckets[_];
            h.uploadPending() && h.upload(a);
          }
          const f = a.gl;
          this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new ae(a, this.imageAtlas.image, f.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new ae(a, this.glyphAtlasImage, f.ALPHA), this.glyphAtlasImage = null);
        }
        prepare(a) {
          this.imageAtlas && this.imageAtlas.patchUpdatedImages(a, this.imageAtlasTexture);
        }
        queryRenderedFeatures(a, f, _, h, p, b, x, C, M, R) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: h, cameraQueryGeometry: p, scale: b, tileSize: this.tileSize, pixelPosMatrix: R, transform: C, params: x, queryPadding: this.queryPadding * M }, a, f, _) : {};
        }
        querySourceFeatures(a, f) {
          const _ = this.latestFeatureIndex;
          if (!_ || !_.rawTileData)
            return;
          const h = _.loadVTLayers(), p = f && f.sourceLayer ? f.sourceLayer : "", b = h._geojsonTileLayer || h[p];
          if (!b)
            return;
          const x = l.a7(f && f.filter), { z: C, x: M, y: R } = this.tileID.canonical, O = { z: C, x: M, y: R };
          for (let D = 0; D < b.length; D++) {
            const U = b.feature(D);
            if (x.needGeometry) {
              const Y = l.a8(U, !0);
              if (!x.filter(new l.a9(this.tileID.overscaledZ), Y, this.tileID.canonical))
                continue;
            } else if (!x.filter(new l.a9(this.tileID.overscaledZ), U))
              continue;
            const W = _.getId(U, p), Q = new l.aa(U, C, M, R, W);
            Q.tile = O, a.push(Q);
          }
        }
        hasData() {
          return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
        }
        patternsLoaded() {
          return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }
        setExpiryData(a) {
          const f = this.expirationTime;
          if (a.cacheControl) {
            const _ = l.ab(a.cacheControl);
            _["max-age"] && (this.expirationTime = Date.now() + 1e3 * _["max-age"]);
          } else
            a.expires && (this.expirationTime = new Date(a.expires).getTime());
          if (this.expirationTime) {
            const _ = Date.now();
            let h = !1;
            if (this.expirationTime > _)
              h = !1;
            else if (f)
              if (this.expirationTime < f)
                h = !0;
              else {
                const p = this.expirationTime - f;
                p ? this.expirationTime = _ + Math.max(p, 3e4) : h = !0;
              }
            else
              h = !0;
            h ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime)
            return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
        }
        setFeatureState(a, f) {
          if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(a).length === 0)
            return;
          const _ = this.latestFeatureIndex.loadVTLayers();
          for (const h in this.buckets) {
            if (!f.style.hasLayer(h))
              continue;
            const p = this.buckets[h], b = p.layers[0].sourceLayer || "_geojsonTileLayer", x = _[b], C = a[b];
            if (!x || !C || Object.keys(C).length === 0)
              continue;
            p.update(C, x, this.imageAtlas && this.imageAtlas.patternPositions || {});
            const M = f && f.style && f.style.getLayer(h);
            M && (this.queryPadding = Math.max(this.queryPadding, M.queryRadius(p)));
          }
        }
        holdingForFade() {
          return this.symbolFadeHoldUntil !== void 0;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < T.now();
        }
        clearFadeHold() {
          this.symbolFadeHoldUntil = void 0;
        }
        setHoldDuration(a) {
          this.symbolFadeHoldUntil = T.now() + a;
        }
        setDependencies(a, f) {
          const _ = {};
          for (const h of f)
            _[h] = !0;
          this.dependencies[a] = _;
        }
        hasDependency(a, f) {
          for (const _ of a) {
            const h = this.dependencies[_];
            if (h) {
              for (const p of f)
                if (h[p])
                  return !0;
            }
          }
          return !1;
        }
      }
      class _t {
        constructor(a, f) {
          this.max = a, this.onRemove = f, this.reset();
        }
        reset() {
          for (const a in this.data)
            for (const f of this.data[a])
              f.timeout && clearTimeout(f.timeout), this.onRemove(f.value);
          return this.data = {}, this.order = [], this;
        }
        add(a, f, _) {
          const h = a.wrapped().key;
          this.data[h] === void 0 && (this.data[h] = []);
          const p = { value: f, timeout: void 0 };
          if (_ !== void 0 && (p.timeout = setTimeout(() => {
            this.remove(a, p);
          }, _)), this.data[h].push(p), this.order.push(h), this.order.length > this.max) {
            const b = this._getAndRemoveByKey(this.order[0]);
            b && this.onRemove(b);
          }
          return this;
        }
        has(a) {
          return a.wrapped().key in this.data;
        }
        getAndRemove(a) {
          return this.has(a) ? this._getAndRemoveByKey(a.wrapped().key) : null;
        }
        _getAndRemoveByKey(a) {
          const f = this.data[a].shift();
          return f.timeout && clearTimeout(f.timeout), this.data[a].length === 0 && delete this.data[a], this.order.splice(this.order.indexOf(a), 1), f.value;
        }
        getByKey(a) {
          const f = this.data[a];
          return f ? f[0].value : null;
        }
        get(a) {
          return this.has(a) ? this.data[a.wrapped().key][0].value : null;
        }
        remove(a, f) {
          if (!this.has(a))
            return this;
          const _ = a.wrapped().key, h = f === void 0 ? 0 : this.data[_].indexOf(f), p = this.data[_][h];
          return this.data[_].splice(h, 1), p.timeout && clearTimeout(p.timeout), this.data[_].length === 0 && delete this.data[_], this.onRemove(p.value), this.order.splice(this.order.indexOf(_), 1), this;
        }
        setMaxSize(a) {
          for (this.max = a; this.order.length > this.max; ) {
            const f = this._getAndRemoveByKey(this.order[0]);
            f && this.onRemove(f);
          }
          return this;
        }
        filter(a) {
          const f = [];
          for (const _ in this.data)
            for (const h of this.data[_])
              a(h.value) || f.push(h);
          for (const _ of f)
            this.remove(_.value.tileID, _);
        }
      }
      class bn {
        constructor() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        }
        updateState(a, f, _) {
          const h = String(f);
          if (this.stateChanges[a] = this.stateChanges[a] || {}, this.stateChanges[a][h] = this.stateChanges[a][h] || {}, l.e(this.stateChanges[a][h], _), this.deletedStates[a] === null) {
            this.deletedStates[a] = {};
            for (const p in this.state[a])
              p !== h && (this.deletedStates[a][p] = null);
          } else if (this.deletedStates[a] && this.deletedStates[a][h] === null) {
            this.deletedStates[a][h] = {};
            for (const p in this.state[a][h])
              _[p] || (this.deletedStates[a][h][p] = null);
          } else
            for (const p in _)
              this.deletedStates[a] && this.deletedStates[a][h] && this.deletedStates[a][h][p] === null && delete this.deletedStates[a][h][p];
        }
        removeFeatureState(a, f, _) {
          if (this.deletedStates[a] === null)
            return;
          const h = String(f);
          if (this.deletedStates[a] = this.deletedStates[a] || {}, _ && f !== void 0)
            this.deletedStates[a][h] !== null && (this.deletedStates[a][h] = this.deletedStates[a][h] || {}, this.deletedStates[a][h][_] = null);
          else if (f !== void 0)
            if (this.stateChanges[a] && this.stateChanges[a][h])
              for (_ in this.deletedStates[a][h] = {}, this.stateChanges[a][h])
                this.deletedStates[a][h][_] = null;
            else
              this.deletedStates[a][h] = null;
          else
            this.deletedStates[a] = null;
        }
        getState(a, f) {
          const _ = String(f), h = l.e({}, (this.state[a] || {})[_], (this.stateChanges[a] || {})[_]);
          if (this.deletedStates[a] === null)
            return {};
          if (this.deletedStates[a]) {
            const p = this.deletedStates[a][f];
            if (p === null)
              return {};
            for (const b in p)
              delete h[b];
          }
          return h;
        }
        initializeTileState(a, f) {
          a.setFeatureState(this.state, f);
        }
        coalesceChanges(a, f) {
          const _ = {};
          for (const h in this.stateChanges) {
            this.state[h] = this.state[h] || {};
            const p = {};
            for (const b in this.stateChanges[h])
              this.state[h][b] || (this.state[h][b] = {}), l.e(this.state[h][b], this.stateChanges[h][b]), p[b] = this.state[h][b];
            _[h] = p;
          }
          for (const h in this.deletedStates) {
            this.state[h] = this.state[h] || {};
            const p = {};
            if (this.deletedStates[h] === null)
              for (const b in this.state[h])
                p[b] = {}, this.state[h][b] = {};
            else
              for (const b in this.deletedStates[h]) {
                if (this.deletedStates[h][b] === null)
                  this.state[h][b] = {};
                else
                  for (const x of Object.keys(this.deletedStates[h][b]))
                    delete this.state[h][b][x];
                p[b] = this.state[h][b];
              }
            _[h] = _[h] || {}, l.e(_[h], p);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(_).length !== 0)
            for (const h in a)
              a[h].setFeatureState(_, f);
        }
      }
      class Gt extends l.E {
        constructor(a, f, _) {
          super(), this.id = a, this.dispatcher = _, this.on("data", (h) => this._dataHandler(h)), this.on("dataloading", () => {
            this._sourceErrored = !1;
          }), this.on("error", () => {
            this._sourceErrored = this._source.loaded();
          }), this._source = ((h, p, b, x) => {
            const C = new (Un(p.type))(h, p, b, x);
            if (C.id !== h)
              throw new Error(`Expected Source id to be ${h} instead of ${C.id}`);
            return C;
          })(a, f, _, this), this._tiles = {}, this._cache = new _t(0, (h) => this._unloadTile(h)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new bn(), this._didEmitContent = !1, this._updated = !1;
        }
        onAdd(a) {
          this.map = a, this._maxTileCacheSize = a ? a._maxTileCacheSize : null, this._maxTileCacheZoomLevels = a ? a._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(a);
        }
        onRemove(a) {
          this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(a);
        }
        loaded() {
          if (this._sourceErrored)
            return !0;
          if (!this._sourceLoaded || !this._source.loaded())
            return !1;
          if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain))
            return !0;
          if (!this._updated)
            return !1;
          for (const a in this._tiles) {
            const f = this._tiles[a];
            if (f.state !== "loaded" && f.state !== "errored")
              return !1;
          }
          return !0;
        }
        getSource() {
          return this._source;
        }
        pause() {
          this._paused = !0;
        }
        resume() {
          if (!this._paused)
            return;
          const a = this._shouldReloadOnResume;
          this._paused = !1, this._shouldReloadOnResume = !1, a && this.reload(), this.transform && this.update(this.transform, this.terrain);
        }
        _loadTile(a, f, _) {
          return l._(this, void 0, void 0, function* () {
            try {
              yield this._source.loadTile(a), this._tileLoaded(a, f, _);
            } catch (h) {
              a.state = "errored", h.status !== 404 ? this._source.fire(new l.j(h, { tile: a })) : this.update(this.transform, this.terrain);
            }
          });
        }
        _unloadTile(a) {
          this._source.unloadTile && this._source.unloadTile(a);
        }
        _abortTile(a) {
          this._source.abortTile && this._source.abortTile(a), this._source.fire(new l.k("dataabort", { tile: a, coord: a.tileID, dataType: "source" }));
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(a) {
          this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
          for (const f in this._tiles) {
            const _ = this._tiles[f];
            _.upload(a), _.prepare(this.map.style.imageManager);
          }
        }
        getIds() {
          return Object.values(this._tiles).map((a) => a.tileID).sort(qn).map((a) => a.key);
        }
        getRenderableIds(a) {
          const f = [];
          for (const _ in this._tiles)
            this._isIdRenderable(_, a) && f.push(this._tiles[_]);
          return a ? f.sort((_, h) => {
            const p = _.tileID, b = h.tileID, x = new l.P(p.canonical.x, p.canonical.y)._rotate(this.transform.angle), C = new l.P(b.canonical.x, b.canonical.y)._rotate(this.transform.angle);
            return p.overscaledZ - b.overscaledZ || C.y - x.y || C.x - x.x;
          }).map((_) => _.tileID.key) : f.map((_) => _.tileID).sort(qn).map((_) => _.key);
        }
        hasRenderableParent(a) {
          const f = this.findLoadedParent(a, 0);
          return !!f && this._isIdRenderable(f.tileID.key);
        }
        _isIdRenderable(a, f) {
          return this._tiles[a] && this._tiles[a].hasData() && !this._coveredTiles[a] && (f || !this._tiles[a].holdingForFade());
        }
        reload() {
          if (this._paused)
            this._shouldReloadOnResume = !0;
          else {
            this._cache.reset();
            for (const a in this._tiles)
              this._tiles[a].state !== "errored" && this._reloadTile(a, "reloading");
          }
        }
        _reloadTile(a, f) {
          return l._(this, void 0, void 0, function* () {
            const _ = this._tiles[a];
            _ && (_.state !== "loading" && (_.state = f), yield this._loadTile(_, a, f));
          });
        }
        _tileLoaded(a, f, _) {
          a.timeAdded = T.now(), _ === "expired" && (a.refreshedUponExpiration = !0), this._setTileReloadTimer(f, a), this.getSource().type === "raster-dem" && a.dem && this._backfillDEM(a), this._state.initializeTileState(a, this.map ? this.map.painter : null), a.aborted || this._source.fire(new l.k("data", { dataType: "source", tile: a, coord: a.tileID }));
        }
        _backfillDEM(a) {
          const f = this.getRenderableIds();
          for (let h = 0; h < f.length; h++) {
            const p = f[h];
            if (a.neighboringTiles && a.neighboringTiles[p]) {
              const b = this.getTileByID(p);
              _(a, b), _(b, a);
            }
          }
          function _(h, p) {
            h.needsHillshadePrepare = !0, h.needsTerrainPrepare = !0;
            let b = p.tileID.canonical.x - h.tileID.canonical.x;
            const x = p.tileID.canonical.y - h.tileID.canonical.y, C = Math.pow(2, h.tileID.canonical.z), M = p.tileID.key;
            b === 0 && x === 0 || Math.abs(x) > 1 || (Math.abs(b) > 1 && (Math.abs(b + C) === 1 ? b += C : Math.abs(b - C) === 1 && (b -= C)), p.dem && h.dem && (h.dem.backfillBorder(p.dem, b, x), h.neighboringTiles && h.neighboringTiles[M] && (h.neighboringTiles[M].backfilled = !0)));
          }
        }
        getTile(a) {
          return this.getTileByID(a.key);
        }
        getTileByID(a) {
          return this._tiles[a];
        }
        _retainLoadedChildren(a, f, _, h) {
          for (const p in this._tiles) {
            let b = this._tiles[p];
            if (h[p] || !b.hasData() || b.tileID.overscaledZ <= f || b.tileID.overscaledZ > _)
              continue;
            let x = b.tileID;
            for (; b && b.tileID.overscaledZ > f + 1; ) {
              const M = b.tileID.scaledTo(b.tileID.overscaledZ - 1);
              b = this._tiles[M.key], b && b.hasData() && (x = M);
            }
            let C = x;
            for (; C.overscaledZ > f; )
              if (C = C.scaledTo(C.overscaledZ - 1), a[C.key]) {
                h[x.key] = x;
                break;
              }
          }
        }
        findLoadedParent(a, f) {
          if (a.key in this._loadedParentTiles) {
            const _ = this._loadedParentTiles[a.key];
            return _ && _.tileID.overscaledZ >= f ? _ : null;
          }
          for (let _ = a.overscaledZ - 1; _ >= f; _--) {
            const h = a.scaledTo(_), p = this._getLoadedTile(h);
            if (p)
              return p;
          }
        }
        findLoadedSibling(a) {
          return this._getLoadedTile(a);
        }
        _getLoadedTile(a) {
          const f = this._tiles[a.key];
          return f && f.hasData() ? f : this._cache.getByKey(a.wrapped().key);
        }
        updateCacheSize(a) {
          const f = Math.ceil(a.width / this._source.tileSize) + 1, _ = Math.ceil(a.height / this._source.tileSize) + 1, h = Math.floor(f * _ * (this._maxTileCacheZoomLevels === null ? l.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), p = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, h) : h;
          this._cache.setMaxSize(p);
        }
        handleWrapJump(a) {
          const f = Math.round((a - (this._prevLng === void 0 ? a : this._prevLng)) / 360);
          if (this._prevLng = a, f) {
            const _ = {};
            for (const h in this._tiles) {
              const p = this._tiles[h];
              p.tileID = p.tileID.unwrapTo(p.tileID.wrap + f), _[p.tileID.key] = p;
            }
            this._tiles = _;
            for (const h in this._timers)
              clearTimeout(this._timers[h]), delete this._timers[h];
            for (const h in this._tiles)
              this._setTileReloadTimer(h, this._tiles[h]);
          }
        }
        _updateCoveredAndRetainedTiles(a, f, _, h, p, b) {
          const x = {}, C = {}, M = Object.keys(a), R = T.now();
          for (const O of M) {
            const D = a[O], U = this._tiles[O];
            if (!U || U.fadeEndTime !== 0 && U.fadeEndTime <= R)
              continue;
            const W = this.findLoadedParent(D, f), Q = this.findLoadedSibling(D), Y = W || Q || null;
            Y && (this._addTile(Y.tileID), x[Y.tileID.key] = Y.tileID), C[O] = D;
          }
          this._retainLoadedChildren(C, h, _, a);
          for (const O in x)
            a[O] || (this._coveredTiles[O] = !0, a[O] = x[O]);
          if (b) {
            const O = {}, D = {};
            for (const U of p)
              this._tiles[U.key].hasData() ? O[U.key] = U : D[U.key] = U;
            for (const U in D) {
              const W = D[U].children(this._source.maxzoom);
              this._tiles[W[0].key] && this._tiles[W[1].key] && this._tiles[W[2].key] && this._tiles[W[3].key] && (O[W[0].key] = a[W[0].key] = W[0], O[W[1].key] = a[W[1].key] = W[1], O[W[2].key] = a[W[2].key] = W[2], O[W[3].key] = a[W[3].key] = W[3], delete D[U]);
            }
            for (const U in D) {
              const W = D[U], Q = this.findLoadedParent(W, this._source.minzoom), Y = this.findLoadedSibling(W), K = Q || Y || null;
              if (K) {
                O[K.tileID.key] = a[K.tileID.key] = K.tileID;
                for (const fe in O)
                  O[fe].isChildOf(K.tileID) && delete O[fe];
              }
            }
            for (const U in this._tiles)
              O[U] || (this._coveredTiles[U] = !0);
          }
        }
        update(a, f) {
          if (!this._sourceLoaded || this._paused)
            return;
          let _;
          this.transform = a, this.terrain = f, this.updateCacheSize(a), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? _ = a.getVisibleUnwrappedCoordinates(this._source.tileID).map((R) => new l.S(R.canonical.z, R.wrap, R.canonical.z, R.canonical.x, R.canonical.y)) : (_ = a.coveringTiles({ tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: f }), this._source.hasTile && (_ = _.filter((R) => this._source.hasTile(R)))) : _ = [];
          const h = a.coveringZoomLevel(this._source), p = Math.max(h - Gt.maxOverzooming, this._source.minzoom), b = Math.max(h + Gt.maxUnderzooming, this._source.minzoom);
          if (this.usedForTerrain) {
            const R = {};
            for (const O of _)
              if (O.canonical.z > this._source.minzoom) {
                const D = O.scaledTo(O.canonical.z - 1);
                R[D.key] = D;
                const U = O.scaledTo(Math.max(this._source.minzoom, Math.min(O.canonical.z, 5)));
                R[U.key] = U;
              }
            _ = _.concat(Object.values(R));
          }
          const x = _.length === 0 && !this._updated && this._didEmitContent;
          this._updated = !0, x && this.fire(new l.k("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
          const C = this._updateRetainedTiles(_, h);
          er(this._source.type) && this._updateCoveredAndRetainedTiles(C, p, b, h, _, f);
          for (const R in C)
            this._tiles[R].clearFadeHold();
          const M = l.ac(this._tiles, C);
          for (const R of M) {
            const O = this._tiles[R];
            O.hasSymbolBuckets && !O.holdingForFade() ? O.setHoldDuration(this.map._fadeDuration) : O.hasSymbolBuckets && !O.symbolFadeFinished() || this._removeTile(R);
          }
          this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
        }
        releaseSymbolFadeTiles() {
          for (const a in this._tiles)
            this._tiles[a].holdingForFade() && this._removeTile(a);
        }
        _updateRetainedTiles(a, f) {
          var _;
          const h = {}, p = {}, b = Math.max(f - Gt.maxOverzooming, this._source.minzoom), x = Math.max(f + Gt.maxUnderzooming, this._source.minzoom), C = {};
          for (const M of a) {
            const R = this._addTile(M);
            h[M.key] = M, R.hasData() || f < this._source.maxzoom && (C[M.key] = M);
          }
          this._retainLoadedChildren(C, f, x, h);
          for (const M of a) {
            let R = this._tiles[M.key];
            if (R.hasData())
              continue;
            if (f + 1 > this._source.maxzoom) {
              const D = M.children(this._source.maxzoom)[0], U = this.getTile(D);
              if (U && U.hasData()) {
                h[D.key] = D;
                continue;
              }
            } else {
              const D = M.children(this._source.maxzoom);
              if (h[D[0].key] && h[D[1].key] && h[D[2].key] && h[D[3].key])
                continue;
            }
            let O = R.wasRequested();
            for (let D = M.overscaledZ - 1; D >= b; --D) {
              const U = M.scaledTo(D);
              if (p[U.key])
                break;
              if (p[U.key] = !0, R = this.getTile(U), !R && O && (R = this._addTile(U)), R) {
                const W = R.hasData();
                if ((W || !(!((_ = this.map) === null || _ === void 0) && _.cancelPendingTileRequestsWhileZooming) || O) && (h[U.key] = U), O = R.wasRequested(), W)
                  break;
              }
            }
          }
          return h;
        }
        _updateLoadedParentTileCache() {
          this._loadedParentTiles = {};
          for (const a in this._tiles) {
            const f = [];
            let _, h = this._tiles[a].tileID;
            for (; h.overscaledZ > 0; ) {
              if (h.key in this._loadedParentTiles) {
                _ = this._loadedParentTiles[h.key];
                break;
              }
              f.push(h.key);
              const p = h.scaledTo(h.overscaledZ - 1);
              if (_ = this._getLoadedTile(p), _)
                break;
              h = p;
            }
            for (const p of f)
              this._loadedParentTiles[p] = _;
          }
        }
        _updateLoadedSiblingTileCache() {
          this._loadedSiblingTiles = {};
          for (const a in this._tiles) {
            const f = this._tiles[a].tileID, _ = this._getLoadedTile(f);
            this._loadedSiblingTiles[f.key] = _;
          }
        }
        _addTile(a) {
          let f = this._tiles[a.key];
          if (f)
            return f;
          f = this._cache.getAndRemove(a), f && (this._setTileReloadTimer(a.key, f), f.tileID = a, this._state.initializeTileState(f, this.map ? this.map.painter : null), this._cacheTimers[a.key] && (clearTimeout(this._cacheTimers[a.key]), delete this._cacheTimers[a.key], this._setTileReloadTimer(a.key, f)));
          const _ = f;
          return f || (f = new bi(a, this._source.tileSize * a.overscaleFactor()), this._loadTile(f, a.key, f.state)), f.uses++, this._tiles[a.key] = f, _ || this._source.fire(new l.k("dataloading", { tile: f, coord: f.tileID, dataType: "source" })), f;
        }
        _setTileReloadTimer(a, f) {
          a in this._timers && (clearTimeout(this._timers[a]), delete this._timers[a]);
          const _ = f.getExpiryTimeout();
          _ && (this._timers[a] = setTimeout(() => {
            this._reloadTile(a, "expired"), delete this._timers[a];
          }, _));
        }
        _removeTile(a) {
          const f = this._tiles[a];
          f && (f.uses--, delete this._tiles[a], this._timers[a] && (clearTimeout(this._timers[a]), delete this._timers[a]), f.uses > 0 || (f.hasData() && f.state !== "reloading" ? this._cache.add(f.tileID, f, f.getExpiryTimeout()) : (f.aborted = !0, this._abortTile(f), this._unloadTile(f))));
        }
        _dataHandler(a) {
          const f = a.sourceDataType;
          a.dataType === "source" && f === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && a.dataType === "source" && f === "content" && (this.reload(), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0);
        }
        clearTiles() {
          this._shouldReloadOnResume = !1, this._paused = !1;
          for (const a in this._tiles)
            this._removeTile(a);
          this._cache.reset();
        }
        tilesIn(a, f, _) {
          const h = [], p = this.transform;
          if (!p)
            return h;
          const b = _ ? p.getCameraQueryGeometry(a) : a, x = a.map((W) => p.pointCoordinate(W, this.terrain)), C = b.map((W) => p.pointCoordinate(W, this.terrain)), M = this.getIds();
          let R = 1 / 0, O = 1 / 0, D = -1 / 0, U = -1 / 0;
          for (const W of C)
            R = Math.min(R, W.x), O = Math.min(O, W.y), D = Math.max(D, W.x), U = Math.max(U, W.y);
          for (let W = 0; W < M.length; W++) {
            const Q = this._tiles[M[W]];
            if (Q.holdingForFade())
              continue;
            const Y = Q.tileID, K = Math.pow(2, p.zoom - Q.tileID.overscaledZ), fe = f * Q.queryPadding * l.X / Q.tileSize / K, ne = [Y.getTilePoint(new l.Z(R, O)), Y.getTilePoint(new l.Z(D, U))];
            if (ne[0].x - fe < l.X && ne[0].y - fe < l.X && ne[1].x + fe >= 0 && ne[1].y + fe >= 0) {
              const ie = x.map((xe) => Y.getTilePoint(xe)), le = C.map((xe) => Y.getTilePoint(xe));
              h.push({ tile: Q, tileID: Y, queryGeometry: ie, cameraQueryGeometry: le, scale: K });
            }
          }
          return h;
        }
        getVisibleCoordinates(a) {
          const f = this.getRenderableIds(a).map((_) => this._tiles[_].tileID);
          for (const _ of f)
            _.posMatrix = this.transform.calculatePosMatrix(_.toUnwrapped());
          return f;
        }
        hasTransition() {
          if (this._source.hasTransition())
            return !0;
          if (er(this._source.type)) {
            const a = T.now();
            for (const f in this._tiles)
              if (this._tiles[f].fadeEndTime >= a)
                return !0;
          }
          return !1;
        }
        setFeatureState(a, f, _) {
          this._state.updateState(a = a || "_geojsonTileLayer", f, _);
        }
        removeFeatureState(a, f, _) {
          this._state.removeFeatureState(a = a || "_geojsonTileLayer", f, _);
        }
        getFeatureState(a, f) {
          return this._state.getState(a = a || "_geojsonTileLayer", f);
        }
        setDependencies(a, f, _) {
          const h = this._tiles[a];
          h && h.setDependencies(f, _);
        }
        reloadTilesForDependencies(a, f) {
          for (const _ in this._tiles)
            this._tiles[_].hasDependency(a, f) && this._reloadTile(_, "reloading");
          this._cache.filter((_) => !_.hasDependency(a, f));
        }
      }
      function qn(E, a) {
        const f = Math.abs(2 * E.wrap) - +(E.wrap < 0), _ = Math.abs(2 * a.wrap) - +(a.wrap < 0);
        return E.overscaledZ - a.overscaledZ || _ - f || a.canonical.y - E.canonical.y || a.canonical.x - E.canonical.x;
      }
      function er(E) {
        return E === "raster" || E === "image" || E === "video";
      }
      Gt.maxOverzooming = 10, Gt.maxUnderzooming = 3;
      class Nt {
        constructor(a, f) {
          this.reset(a, f);
        }
        reset(a, f) {
          this.points = a || [], this._distances = [0];
          for (let _ = 1; _ < this.points.length; _++)
            this._distances[_] = this._distances[_ - 1] + this.points[_].dist(this.points[_ - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(f || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }
        lerp(a) {
          if (this.points.length === 1)
            return this.points[0];
          a = l.ad(a, 0, 1);
          let f = 1, _ = this._distances[f];
          const h = a * this.paddedLength + this.padding;
          for (; _ < h && f < this._distances.length; )
            _ = this._distances[++f];
          const p = f - 1, b = this._distances[p], x = _ - b, C = x > 0 ? (h - b) / x : 0;
          return this.points[p].mult(1 - C).add(this.points[f].mult(C));
        }
      }
      function vr(E, a) {
        let f = !0;
        return E === "always" || E !== "never" && a !== "never" || (f = !1), f;
      }
      class ii {
        constructor(a, f, _) {
          const h = this.boxCells = [], p = this.circleCells = [];
          this.xCellCount = Math.ceil(a / _), this.yCellCount = Math.ceil(f / _);
          for (let b = 0; b < this.xCellCount * this.yCellCount; b++)
            h.push([]), p.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = a, this.height = f, this.xScale = this.xCellCount / a, this.yScale = this.yCellCount / f, this.boxUid = 0, this.circleUid = 0;
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(a, f, _, h, p) {
          this._forEachCell(f, _, h, p, this._insertBoxCell, this.boxUid++), this.boxKeys.push(a), this.bboxes.push(f), this.bboxes.push(_), this.bboxes.push(h), this.bboxes.push(p);
        }
        insertCircle(a, f, _, h) {
          this._forEachCell(f - h, _ - h, f + h, _ + h, this._insertCircleCell, this.circleUid++), this.circleKeys.push(a), this.circles.push(f), this.circles.push(_), this.circles.push(h);
        }
        _insertBoxCell(a, f, _, h, p, b) {
          this.boxCells[p].push(b);
        }
        _insertCircleCell(a, f, _, h, p, b) {
          this.circleCells[p].push(b);
        }
        _query(a, f, _, h, p, b, x) {
          if (_ < 0 || a > this.width || h < 0 || f > this.height)
            return [];
          const C = [];
          if (a <= 0 && f <= 0 && this.width <= _ && this.height <= h) {
            if (p)
              return [{ key: null, x1: a, y1: f, x2: _, y2: h }];
            for (let M = 0; M < this.boxKeys.length; M++)
              C.push({ key: this.boxKeys[M], x1: this.bboxes[4 * M], y1: this.bboxes[4 * M + 1], x2: this.bboxes[4 * M + 2], y2: this.bboxes[4 * M + 3] });
            for (let M = 0; M < this.circleKeys.length; M++) {
              const R = this.circles[3 * M], O = this.circles[3 * M + 1], D = this.circles[3 * M + 2];
              C.push({ key: this.circleKeys[M], x1: R - D, y1: O - D, x2: R + D, y2: O + D });
            }
          } else
            this._forEachCell(a, f, _, h, this._queryCell, C, { hitTest: p, overlapMode: b, seenUids: { box: {}, circle: {} } }, x);
          return C;
        }
        query(a, f, _, h) {
          return this._query(a, f, _, h, !1, null);
        }
        hitTest(a, f, _, h, p, b) {
          return this._query(a, f, _, h, !0, p, b).length > 0;
        }
        hitTestCircle(a, f, _, h, p) {
          const b = a - _, x = a + _, C = f - _, M = f + _;
          if (x < 0 || b > this.width || M < 0 || C > this.height)
            return !1;
          const R = [];
          return this._forEachCell(b, C, x, M, this._queryCellCircle, R, { hitTest: !0, overlapMode: h, circle: { x: a, y: f, radius: _ }, seenUids: { box: {}, circle: {} } }, p), R.length > 0;
        }
        _queryCell(a, f, _, h, p, b, x, C) {
          const { seenUids: M, hitTest: R, overlapMode: O } = x, D = this.boxCells[p];
          if (D !== null) {
            const W = this.bboxes;
            for (const Q of D)
              if (!M.box[Q]) {
                M.box[Q] = !0;
                const Y = 4 * Q, K = this.boxKeys[Q];
                if (a <= W[Y + 2] && f <= W[Y + 3] && _ >= W[Y + 0] && h >= W[Y + 1] && (!C || C(K)) && (!R || !vr(O, K.overlapMode)) && (b.push({ key: K, x1: W[Y], y1: W[Y + 1], x2: W[Y + 2], y2: W[Y + 3] }), R))
                  return !0;
              }
          }
          const U = this.circleCells[p];
          if (U !== null) {
            const W = this.circles;
            for (const Q of U)
              if (!M.circle[Q]) {
                M.circle[Q] = !0;
                const Y = 3 * Q, K = this.circleKeys[Q];
                if (this._circleAndRectCollide(W[Y], W[Y + 1], W[Y + 2], a, f, _, h) && (!C || C(K)) && (!R || !vr(O, K.overlapMode))) {
                  const fe = W[Y], ne = W[Y + 1], ie = W[Y + 2];
                  if (b.push({ key: K, x1: fe - ie, y1: ne - ie, x2: fe + ie, y2: ne + ie }), R)
                    return !0;
                }
              }
          }
          return !1;
        }
        _queryCellCircle(a, f, _, h, p, b, x, C) {
          const { circle: M, seenUids: R, overlapMode: O } = x, D = this.boxCells[p];
          if (D !== null) {
            const W = this.bboxes;
            for (const Q of D)
              if (!R.box[Q]) {
                R.box[Q] = !0;
                const Y = 4 * Q, K = this.boxKeys[Q];
                if (this._circleAndRectCollide(M.x, M.y, M.radius, W[Y + 0], W[Y + 1], W[Y + 2], W[Y + 3]) && (!C || C(K)) && !vr(O, K.overlapMode))
                  return b.push(!0), !0;
              }
          }
          const U = this.circleCells[p];
          if (U !== null) {
            const W = this.circles;
            for (const Q of U)
              if (!R.circle[Q]) {
                R.circle[Q] = !0;
                const Y = 3 * Q, K = this.circleKeys[Q];
                if (this._circlesCollide(W[Y], W[Y + 1], W[Y + 2], M.x, M.y, M.radius) && (!C || C(K)) && !vr(O, K.overlapMode))
                  return b.push(!0), !0;
              }
          }
        }
        _forEachCell(a, f, _, h, p, b, x, C) {
          const M = this._convertToXCellCoord(a), R = this._convertToYCellCoord(f), O = this._convertToXCellCoord(_), D = this._convertToYCellCoord(h);
          for (let U = M; U <= O; U++)
            for (let W = R; W <= D; W++)
              if (p.call(this, a, f, _, h, this.xCellCount * W + U, b, x, C))
                return;
        }
        _convertToXCellCoord(a) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(a * this.xScale)));
        }
        _convertToYCellCoord(a) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(a * this.yScale)));
        }
        _circlesCollide(a, f, _, h, p, b) {
          const x = h - a, C = p - f, M = _ + b;
          return M * M > x * x + C * C;
        }
        _circleAndRectCollide(a, f, _, h, p, b, x) {
          const C = (b - h) / 2, M = Math.abs(a - (h + C));
          if (M > C + _)
            return !1;
          const R = (x - p) / 2, O = Math.abs(f - (p + R));
          if (O > R + _)
            return !1;
          if (M <= C || O <= R)
            return !0;
          const D = M - C, U = O - R;
          return D * D + U * U <= _ * _;
        }
      }
      function sr(E, a, f, _, h) {
        const p = l.H();
        return a ? (l.K(p, p, [1 / h, 1 / h, 1]), f || l.ae(p, p, _.angle)) : l.L(p, _.labelPlaneMatrix, E), p;
      }
      function or(E, a, f, _, h) {
        if (a) {
          const p = l.af(E);
          return l.K(p, p, [h, h, 1]), f || l.ae(p, p, -_.angle), p;
        }
        return _.glCoordMatrix;
      }
      function ve(E, a, f) {
        let _;
        f ? (_ = [E.x, E.y, f(E.x, E.y), 1], l.ag(_, _, a)) : (_ = [E.x, E.y, 0, 1], function(p, b, x) {
          const C = b[0], M = b[1];
          p[0] = x[0] * C + x[4] * M + x[12], p[1] = x[1] * C + x[5] * M + x[13], p[3] = x[3] * C + x[7] * M + x[15];
        }(_, _, a));
        const h = _[3];
        return { point: new l.P(_[0] / h, _[1] / h), signedDistanceFromCamera: h, isOccluded: !1 };
      }
      function X(E, a) {
        return 0.5 + E / a * 0.5;
      }
      function $(E, a) {
        return E.x >= -a[0] && E.x <= a[0] && E.y >= -a[1] && E.y <= a[1];
      }
      function he(E, a, f, _, h, p, b, x, C, M, R, O, D, U, W) {
        const Q = _ ? E.textSizeData : E.iconSizeData, Y = l.ah(Q, f.transform.zoom), K = [256 / f.width * 2 + 1, 256 / f.height * 2 + 1], fe = _ ? E.text.dynamicLayoutVertexArray : E.icon.dynamicLayoutVertexArray;
        fe.clear();
        const ne = E.lineVertexArray, ie = _ ? E.text.placedSymbolArray : E.icon.placedSymbolArray, le = f.transform.width / f.transform.height;
        let xe = !1;
        for (let Me = 0; Me < ie.length; Me++) {
          const Ne = ie.get(Me);
          if (Ne.hidden || Ne.writingMode === l.ai.vertical && !xe) {
            Kt(Ne.numGlyphs, fe);
            continue;
          }
          xe = !1;
          const ot = ve(new l.P(Ne.anchorX, Ne.anchorY), a, W);
          if (!$(ot.point, K)) {
            Kt(Ne.numGlyphs, fe);
            continue;
          }
          const et = X(f.transform.cameraToCenterDistance, ot.signedDistanceFromCamera), rt = l.aj(Q, Y, Ne), $e = b ? rt / et : rt * et, Ct = { getElevation: W, labelPlaneMatrix: h, lineVertexArray: ne, pitchWithMap: b, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, projection: M, tileAnchorPoint: new l.P(Ne.anchorX, Ne.anchorY), unwrappedTileID: R, width: O, height: D, translation: U }, qt = je(Ct, Ne, $e, !1, x, a, p, E.glyphOffsetArray, fe, le, C);
          xe = qt.useVertical, (qt.notEnoughRoom || xe || qt.needsFlipping && je(Ct, Ne, $e, !0, x, a, p, E.glyphOffsetArray, fe, le, C).notEnoughRoom) && Kt(Ne.numGlyphs, fe);
        }
        _ ? E.text.dynamicLayoutVertexBuffer.updateData(fe) : E.icon.dynamicLayoutVertexBuffer.updateData(fe);
      }
      function _e(E, a, f, _, h, p, b, x) {
        const C = p.glyphStartIndex + p.numGlyphs, M = p.lineStartIndex, R = p.lineStartIndex + p.lineLength, O = a.getoffsetX(p.glyphStartIndex), D = a.getoffsetX(C - 1), U = xt(E * O, f, _, h, p.segment, M, R, x, b);
        if (!U)
          return null;
        const W = xt(E * D, f, _, h, p.segment, M, R, x, b);
        return W ? x.projectionCache.anyProjectionOccluded ? null : { first: U, last: W } : null;
      }
      function Oe(E, a, f, _) {
        return E === l.ai.horizontal && Math.abs(f.y - a.y) > Math.abs(f.x - a.x) * _ ? { useVertical: !0 } : (E === l.ai.vertical ? a.y < f.y : a.x > f.x) ? { needsFlipping: !0 } : null;
      }
      function je(E, a, f, _, h, p, b, x, C, M, R) {
        const O = f / 24, D = a.lineOffsetX * O, U = a.lineOffsetY * O;
        let W;
        if (a.numGlyphs > 1) {
          const Q = a.glyphStartIndex + a.numGlyphs, Y = a.lineStartIndex, K = a.lineStartIndex + a.lineLength, fe = _e(O, x, D, U, _, a, R, E);
          if (!fe)
            return { notEnoughRoom: !0 };
          const ne = ve(fe.first.point, b, E.getElevation).point, ie = ve(fe.last.point, b, E.getElevation).point;
          if (h && !_) {
            const le = Oe(a.writingMode, ne, ie, M);
            if (le)
              return le;
          }
          W = [fe.first];
          for (let le = a.glyphStartIndex + 1; le < Q - 1; le++)
            W.push(xt(O * x.getoffsetX(le), D, U, _, a.segment, Y, K, E, R));
          W.push(fe.last);
        } else {
          if (h && !_) {
            const Y = ve(E.tileAnchorPoint, p, E.getElevation).point, K = a.lineStartIndex + a.segment + 1, fe = new l.P(E.lineVertexArray.getx(K), E.lineVertexArray.gety(K)), ne = ve(fe, p, E.getElevation), ie = ne.signedDistanceFromCamera > 0 ? ne.point : function(xe, Me, Ne, ot, et, rt) {
              return Be(xe, Me, Ne, 1, et, rt);
            }(E.tileAnchorPoint, fe, Y, 0, p, E), le = Oe(a.writingMode, Y, ie, M);
            if (le)
              return le;
          }
          const Q = xt(O * x.getoffsetX(a.glyphStartIndex), D, U, _, a.segment, a.lineStartIndex, a.lineStartIndex + a.lineLength, E, R);
          if (!Q || E.projectionCache.anyProjectionOccluded)
            return { notEnoughRoom: !0 };
          W = [Q];
        }
        for (const Q of W)
          l.ak(C, Q.point, Q.angle);
        return {};
      }
      function Be(E, a, f, _, h, p) {
        const b = E.add(E.sub(a)._unit()), x = h !== void 0 ? ve(b, h, p.getElevation).point : nt(b.x, b.y, p).point, C = f.sub(x);
        return f.add(C._mult(_ / C.mag()));
      }
      function Ie(E, a, f) {
        const _ = a.projectionCache;
        if (_.projections[E])
          return _.projections[E];
        const h = new l.P(a.lineVertexArray.getx(E), a.lineVertexArray.gety(E)), p = nt(h.x, h.y, a);
        if (p.signedDistanceFromCamera > 0)
          return _.projections[E] = p.point, _.anyProjectionOccluded = _.anyProjectionOccluded || p.isOccluded, p.point;
        const b = E - f.direction;
        return function(x, C, M, R, O) {
          return Be(x, C, M, R, void 0, O);
        }(f.distanceFromAnchor === 0 ? a.tileAnchorPoint : new l.P(a.lineVertexArray.getx(b), a.lineVertexArray.gety(b)), h, f.previousVertex, f.absOffsetX - f.distanceFromAnchor + 1, a);
      }
      function nt(E, a, f) {
        const _ = E + f.translation[0], h = a + f.translation[1];
        let p;
        return !f.pitchWithMap && f.projection.useSpecialProjectionForSymbols ? (p = f.projection.projectTileCoordinates(_, h, f.unwrappedTileID, f.getElevation), p.point.x = (0.5 * p.point.x + 0.5) * f.width, p.point.y = (0.5 * -p.point.y + 0.5) * f.height) : (p = ve(new l.P(_, h), f.labelPlaneMatrix, f.getElevation), p.isOccluded = !1), p;
      }
      function ft(E, a, f) {
        return E._unit()._perp()._mult(a * f);
      }
      function Xe(E, a, f, _, h, p, b, x, C) {
        if (x.projectionCache.offsets[E])
          return x.projectionCache.offsets[E];
        const M = f.add(a);
        if (E + C.direction < _ || E + C.direction >= h)
          return x.projectionCache.offsets[E] = M, M;
        const R = Ie(E + C.direction, x, C), O = ft(R.sub(f), b, C.direction), D = f.add(O), U = R.add(O);
        return x.projectionCache.offsets[E] = l.al(p, M, D, U) || M, x.projectionCache.offsets[E];
      }
      function xt(E, a, f, _, h, p, b, x, C) {
        const M = _ ? E - a : E + a;
        let R = M > 0 ? 1 : -1, O = 0;
        _ && (R *= -1, O = Math.PI), R < 0 && (O += Math.PI);
        let D, U = R > 0 ? p + h : p + h + 1;
        x.projectionCache.cachedAnchorPoint ? D = x.projectionCache.cachedAnchorPoint : (D = nt(x.tileAnchorPoint.x, x.tileAnchorPoint.y, x).point, x.projectionCache.cachedAnchorPoint = D);
        let W, Q, Y = D, K = D, fe = 0, ne = 0;
        const ie = Math.abs(M), le = [];
        let xe;
        for (; fe + ne <= ie; ) {
          if (U += R, U < p || U >= b)
            return null;
          fe += ne, K = Y, Q = W;
          const ot = { absOffsetX: ie, direction: R, distanceFromAnchor: fe, previousVertex: K };
          if (Y = Ie(U, x, ot), f === 0)
            le.push(K), xe = Y.sub(K);
          else {
            let et;
            const rt = Y.sub(K);
            et = rt.mag() === 0 ? ft(Ie(U + R, x, ot).sub(Y), f, R) : ft(rt, f, R), Q || (Q = K.add(et)), W = Xe(U, et, Y, p, b, Q, f, x, ot), le.push(Q), xe = W.sub(Q);
          }
          ne = xe.mag();
        }
        const Me = xe._mult((ie - fe) / ne)._add(Q || K), Ne = O + Math.atan2(Y.y - K.y, Y.x - K.x);
        return le.push(Me), { point: Me, angle: C ? Ne : 0, path: le };
      }
      const $t = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
      function Kt(E, a) {
        for (let f = 0; f < E; f++) {
          const _ = a.length;
          a.resize(_ + 4), a.float32.set($t, 3 * _);
        }
      }
      const _n = 100;
      class An {
        constructor(a, f) {
          let _ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new ii(a.width + 200, a.height + 200, 25), h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : new ii(a.width + 200, a.height + 200, 25);
          this.transform = a, this.mapProjection = f, this.grid = _, this.ignoredGrid = h, this.pitchFactor = Math.cos(a._pitch) * a.cameraToCenterDistance, this.screenRightBoundary = a.width + _n, this.screenBottomBoundary = a.height + _n, this.gridRightBoundary = a.width + 200, this.gridBottomBoundary = a.height + 200, this.perspectiveRatioCutoff = 0.6;
        }
        placeCollisionBox(a, f, _, h, p, b, x, C, M, R, O) {
          const D = a.anchorPointX + C[0], U = a.anchorPointY + C[1], W = this.projectAndGetPerspectiveRatio(h, D, U, p, R), Q = this._projectCollisionBox(a, _, h, p, b, x, C, W, R, O), [Y, K, fe, ne] = Q.box;
          return this.mapProjection.useSpecialProjectionForSymbols && (b ? Q.allPointsOccluded : this.mapProjection.isOccluded(D, U, p)) || W.perspectiveRatio < this.perspectiveRatioCutoff || !this.isInsideGrid(Y, K, fe, ne) || f !== "always" && this.grid.hitTest(Y, K, fe, ne, f, M) ? { box: [Y, K, fe, ne], placeable: !1, offscreen: !1 } : { box: [Y, K, fe, ne], placeable: !0, offscreen: this.isOffscreen(Y, K, fe, ne) };
        }
        placeCollisionCircles(a, f, _, h, p, b, x, C, M, R, O, D, U, W, Q, Y) {
          const K = [], fe = new l.P(f.anchorX, f.anchorY), ne = this.getPerspectiveRatio(b, fe.x, fe.y, x, Y), ie = (O ? p / ne : p * ne) / l.aq, le = { getElevation: Y, labelPlaneMatrix: C, lineVertexArray: _, pitchWithMap: O, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, projection: this.mapProjection, tileAnchorPoint: fe, unwrappedTileID: x, width: this.transform.width, height: this.transform.height, translation: Q }, xe = _e(ie, h, f.lineOffsetX * ie, f.lineOffsetY * ie, !1, f, !1, le);
          let Me = !1, Ne = !1, ot = !0;
          if (xe) {
            const et = 0.5 * U * ne + W, rt = new l.P(-100, -100), $e = new l.P(this.screenRightBoundary, this.screenBottomBoundary), Ct = new Nt(), qt = xe.first, yt = xe.last;
            let vt = [];
            for (let Ot = qt.path.length - 1; Ot >= 1; Ot--)
              vt.push(qt.path[Ot]);
            for (let Ot = 1; Ot < yt.path.length; Ot++)
              vt.push(yt.path[Ot]);
            const Ht = 2.5 * et;
            if (M) {
              const Ot = this.projectPathToScreenSpace(vt, le, M);
              vt = Ot.some((gn) => gn.signedDistanceFromCamera <= 0) ? [] : Ot.map((gn) => gn.point);
            }
            let Sn = [];
            if (vt.length > 0) {
              const Ot = vt[0].clone(), gn = vt[0].clone();
              for (let Wn = 1; Wn < vt.length; Wn++)
                Ot.x = Math.min(Ot.x, vt[Wn].x), Ot.y = Math.min(Ot.y, vt[Wn].y), gn.x = Math.max(gn.x, vt[Wn].x), gn.y = Math.max(gn.y, vt[Wn].y);
              Sn = Ot.x >= rt.x && gn.x <= $e.x && Ot.y >= rt.y && gn.y <= $e.y ? [vt] : gn.x < rt.x || Ot.x > $e.x || gn.y < rt.y || Ot.y > $e.y ? [] : l.am([vt], rt.x, rt.y, $e.x, $e.y);
            }
            for (const Ot of Sn) {
              Ct.reset(Ot, 0.25 * et);
              let gn = 0;
              gn = Ct.length <= 0.5 * et ? 1 : Math.ceil(Ct.paddedLength / Ht) + 1;
              for (let Wn = 0; Wn < gn; Wn++) {
                const Qn = Wn / Math.max(gn - 1, 1), ji = Ct.lerp(Qn), En = ji.x + _n, Li = ji.y + _n;
                K.push(En, Li, et, 0);
                const Ai = En - et, ni = Li - et, ri = En + et, ki = Li + et;
                if (ot = ot && this.isOffscreen(Ai, ni, ri, ki), Ne = Ne || this.isInsideGrid(Ai, ni, ri, ki), a !== "always" && this.grid.hitTestCircle(En, Li, et, a, D) && (Me = !0, !R))
                  return { circles: [], offscreen: !1, collisionDetected: Me };
              }
            }
          }
          return { circles: !R && Me || !Ne || ne < this.perspectiveRatioCutoff ? [] : K, offscreen: ot, collisionDetected: Me };
        }
        projectPathToScreenSpace(a, f, _) {
          return a.map((h) => ve(h, _, f.getElevation));
        }
        queryRenderedSymbols(a) {
          if (a.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0)
            return {};
          const f = [];
          let _ = 1 / 0, h = 1 / 0, p = -1 / 0, b = -1 / 0;
          for (const R of a) {
            const O = new l.P(R.x + _n, R.y + _n);
            _ = Math.min(_, O.x), h = Math.min(h, O.y), p = Math.max(p, O.x), b = Math.max(b, O.y), f.push(O);
          }
          const x = this.grid.query(_, h, p, b).concat(this.ignoredGrid.query(_, h, p, b)), C = {}, M = {};
          for (const R of x) {
            const O = R.key;
            if (C[O.bucketInstanceId] === void 0 && (C[O.bucketInstanceId] = {}), C[O.bucketInstanceId][O.featureIndex])
              continue;
            const D = [new l.P(R.x1, R.y1), new l.P(R.x2, R.y1), new l.P(R.x2, R.y2), new l.P(R.x1, R.y2)];
            l.an(f, D) && (C[O.bucketInstanceId][O.featureIndex] = !0, M[O.bucketInstanceId] === void 0 && (M[O.bucketInstanceId] = []), M[O.bucketInstanceId].push(O.featureIndex));
          }
          return M;
        }
        insertCollisionBox(a, f, _, h, p, b) {
          (_ ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: h, featureIndex: p, collisionGroupID: b, overlapMode: f }, a[0], a[1], a[2], a[3]);
        }
        insertCollisionCircles(a, f, _, h, p, b) {
          const x = _ ? this.ignoredGrid : this.grid, C = { bucketInstanceId: h, featureIndex: p, collisionGroupID: b, overlapMode: f };
          for (let M = 0; M < a.length; M += 4)
            x.insertCircle(C, a[M], a[M + 1], a[M + 2]);
        }
        projectAndGetPerspectiveRatio(a, f, _, h, p) {
          const b = this.mapProjection.useSpecialProjectionForSymbols ? this.mapProjection.projectTileCoordinates(f, _, h, p) : ve(new l.P(f, _), a, p);
          return { point: new l.P((b.point.x + 1) / 2 * this.transform.width + _n, (1 - b.point.y) / 2 * this.transform.height + _n), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / b.signedDistanceFromCamera * 0.5, isOccluded: b.isOccluded, signedDistanceFromCamera: b.signedDistanceFromCamera };
        }
        getPerspectiveRatio(a, f, _, h, p) {
          const b = this.mapProjection.useSpecialProjectionForSymbols ? this.mapProjection.projectTileCoordinates(f, _, h, p) : ve(new l.P(f, _), a, p);
          return 0.5 + this.transform.cameraToCenterDistance / b.signedDistanceFromCamera * 0.5;
        }
        isOffscreen(a, f, _, h) {
          return _ < _n || a >= this.screenRightBoundary || h < _n || f > this.screenBottomBoundary;
        }
        isInsideGrid(a, f, _, h) {
          return _ >= 0 && a < this.gridRightBoundary && h >= 0 && f < this.gridBottomBoundary;
        }
        getViewportMatrix() {
          const a = l.ao([]);
          return l.J(a, a, [-100, -100, 0]), a;
        }
        _projectCollisionBox(a, f, _, h, p, b, x, C, M, R) {
          const O = f * C.perspectiveRatio;
          let D = new l.P(1, 0), U = new l.P(0, 1);
          const W = new l.P(a.anchorPointX + x[0], a.anchorPointY + x[1]);
          if (b && !p) {
            const et = this.projectAndGetPerspectiveRatio(_, W.x + 1, W.y, h, M).point.sub(C.point).unit(), rt = Math.atan(et.y / et.x) + (et.x < 0 ? Math.PI : 0), $e = Math.sin(rt), Ct = Math.cos(rt);
            D = new l.P(Ct, $e), U = new l.P(-$e, Ct);
          } else if (!b && p) {
            const et = -this.transform.angle, rt = Math.sin(et), $e = Math.cos(et);
            D = new l.P($e, rt), U = new l.P(-rt, $e);
          }
          let Q = C.point, Y = O;
          if (p) {
            Q = W;
            const et = this.transform.zoom - Math.floor(this.transform.zoom);
            Y = Math.pow(2, -et), Y *= this.mapProjection.getPitchedTextCorrection(this.transform, W, h), R || (Y *= l.ad(0.5 + C.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4));
          }
          R && (Q = Q.add(D.mult(R.x * Y)).add(U.mult(R.y * Y)));
          const K = a.x1 * Y, fe = a.x2 * Y, ne = (K + fe) / 2, ie = a.y1 * Y, le = a.y2 * Y, xe = (ie + le) / 2, Me = [{ offsetX: K, offsetY: ie }, { offsetX: ne, offsetY: ie }, { offsetX: fe, offsetY: ie }, { offsetX: fe, offsetY: xe }, { offsetX: fe, offsetY: le }, { offsetX: ne, offsetY: le }, { offsetX: K, offsetY: le }, { offsetX: K, offsetY: xe }];
          let Ne = [];
          for (const { offsetX: et, offsetY: rt } of Me)
            Ne.push(new l.P(Q.x + D.x * et + U.x * rt, Q.y + D.y * et + U.y * rt));
          let ot = !1;
          if (p) {
            const et = Ne.map((rt) => this.projectAndGetPerspectiveRatio(_, rt.x, rt.y, h, M));
            ot = et.some((rt) => !rt.isOccluded), Ne = et.map((rt) => rt.point);
          } else
            ot = !0;
          return { box: l.ap(Ne), allPointsOccluded: !ot };
        }
      }
      function an(E, a, f) {
        return a * (l.X / (E.tileSize * Math.pow(2, f - E.tileID.overscaledZ)));
      }
      class Fn {
        constructor(a, f, _, h) {
          this.opacity = a ? Math.max(0, Math.min(1, a.opacity + (a.placed ? f : -f))) : h && _ ? 1 : 0, this.placed = _;
        }
        isHidden() {
          return this.opacity === 0 && !this.placed;
        }
      }
      class Yn {
        constructor(a, f, _, h, p) {
          this.text = new Fn(a ? a.text : null, f, _, p), this.icon = new Fn(a ? a.icon : null, f, h, p);
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }
      class Kn {
        constructor(a, f, _) {
          this.text = a, this.icon = f, this.skipFade = _;
        }
      }
      class dn {
        constructor() {
          this.invProjMatrix = l.H(), this.viewportMatrix = l.H(), this.circles = [];
        }
      }
      class Dn {
        constructor(a, f, _, h, p) {
          this.bucketInstanceId = a, this.featureIndex = f, this.sourceLayerIndex = _, this.bucketIndex = h, this.tileID = p;
        }
      }
      class Jn {
        constructor(a) {
          this.crossSourceCollisions = a, this.maxGroupID = 0, this.collisionGroups = {};
        }
        get(a) {
          if (this.crossSourceCollisions)
            return { ID: 0, predicate: null };
          if (!this.collisionGroups[a]) {
            const f = ++this.maxGroupID;
            this.collisionGroups[a] = { ID: f, predicate: (_) => _.collisionGroupID === f };
          }
          return this.collisionGroups[a];
        }
      }
      function di(E, a, f, _, h) {
        const { horizontalAlign: p, verticalAlign: b } = l.av(E);
        return new l.P(-(p - 0.5) * a + _[0] * h, -(b - 0.5) * f + _[1] * h);
      }
      class Bi {
        constructor(a, f, _, h, p, b) {
          this.transform = a.clone(), this.terrain = _, this.collisionIndex = new An(this.transform, f), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = h, this.retainedQueryData = {}, this.collisionGroups = new Jn(p), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = b, b && (b.prevPlacement = void 0), this.placedOrientations = {};
        }
        _getTerrainElevationFunc(a) {
          const f = this.terrain;
          return f ? (_, h) => f.getElevation(a, _, h) : null;
        }
        getBucketParts(a, f, _, h) {
          const p = _.getBucket(f), b = _.latestFeatureIndex;
          if (!p || !b || f.id !== p.layerIds[0])
            return;
          const x = _.collisionBoxArray, C = p.layers[0].layout, M = p.layers[0].paint, R = Math.pow(2, this.transform.zoom - _.tileID.overscaledZ), O = _.tileSize / l.X, D = _.tileID.toUnwrapped(), U = this.transform.calculatePosMatrix(D), W = C.get("text-pitch-alignment") === "map", Q = C.get("text-rotation-alignment") === "map", Y = an(_, 1, this.transform.zoom), K = this.collisionIndex.mapProjection.translatePosition(this.transform, _, M.get("text-translate"), M.get("text-translate-anchor")), fe = this.collisionIndex.mapProjection.translatePosition(this.transform, _, M.get("icon-translate"), M.get("icon-translate-anchor")), ne = sr(U, W, Q, this.transform, Y);
          let ie = null;
          if (W) {
            const xe = or(U, W, Q, this.transform, Y);
            ie = l.L([], this.transform.labelPlaneMatrix, xe);
          }
          this.retainedQueryData[p.bucketInstanceId] = new Dn(p.bucketInstanceId, b, p.sourceLayerIndex, p.index, _.tileID);
          const le = { bucket: p, layout: C, translationText: K, translationIcon: fe, posMatrix: U, unwrappedTileID: D, textLabelPlaneMatrix: ne, labelToScreenMatrix: ie, scale: R, textPixelRatio: O, holdingForFade: _.holdingForFade(), collisionBoxArray: x, partiallyEvaluatedTextSize: l.ah(p.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(p.sourceID) };
          if (h)
            for (const xe of p.sortKeyRanges) {
              const { sortKey: Me, symbolInstanceStart: Ne, symbolInstanceEnd: ot } = xe;
              a.push({ sortKey: Me, symbolInstanceStart: Ne, symbolInstanceEnd: ot, parameters: le });
            }
          else
            a.push({ symbolInstanceStart: 0, symbolInstanceEnd: p.symbolInstances.length, parameters: le });
        }
        attemptAnchorPlacement(a, f, _, h, p, b, x, C, M, R, O, D, U, W, Q, Y, K, fe, ne) {
          const ie = l.ar[a.textAnchor], le = [a.textOffset0, a.textOffset1], xe = di(ie, _, h, le, p), Me = this.collisionIndex.placeCollisionBox(f, D, C, M, R, x, b, Y, O.predicate, ne, xe);
          if ((!fe || this.collisionIndex.placeCollisionBox(fe, D, C, M, R, x, b, K, O.predicate, ne, xe).placeable) && Me.placeable) {
            let Ne;
            if (this.prevPlacement && this.prevPlacement.variableOffsets[U.crossTileID] && this.prevPlacement.placements[U.crossTileID] && this.prevPlacement.placements[U.crossTileID].text && (Ne = this.prevPlacement.variableOffsets[U.crossTileID].anchor), U.crossTileID === 0)
              throw new Error("symbolInstance.crossTileID can't be 0");
            return this.variableOffsets[U.crossTileID] = { textOffset: le, width: _, height: h, anchor: ie, textBoxScale: p, prevAnchor: Ne }, this.markUsedJustification(W, ie, U, Q), W.allowVerticalPlacement && (this.markUsedOrientation(W, Q, U), this.placedOrientations[U.crossTileID] = Q), { shift: xe, placedGlyphBoxes: Me };
          }
        }
        placeLayerBucketPart(a, f, _) {
          const { bucket: h, layout: p, translationText: b, translationIcon: x, posMatrix: C, unwrappedTileID: M, textLabelPlaneMatrix: R, labelToScreenMatrix: O, textPixelRatio: D, holdingForFade: U, collisionBoxArray: W, partiallyEvaluatedTextSize: Q, collisionGroup: Y } = a.parameters, K = p.get("text-optional"), fe = p.get("icon-optional"), ne = l.as(p, "text-overlap", "text-allow-overlap"), ie = ne === "always", le = l.as(p, "icon-overlap", "icon-allow-overlap"), xe = le === "always", Me = p.get("text-rotation-alignment") === "map", Ne = p.get("text-pitch-alignment") === "map", ot = p.get("icon-text-fit") !== "none", et = p.get("symbol-z-order") === "viewport-y", rt = ie && (xe || !h.hasIconData() || fe), $e = xe && (ie || !h.hasTextData() || K);
          !h.collisionArrays && W && h.deserializeCollisionBoxes(W);
          const Ct = this._getTerrainElevationFunc(this.retainedQueryData[h.bucketInstanceId].tileID), qt = (yt, vt, Ht) => {
            var Sn, Ot;
            if (f[yt.crossTileID])
              return;
            if (U)
              return void (this.placements[yt.crossTileID] = new Kn(!1, !1, !1));
            let gn = !1, Wn = !1, Qn = !0, ji = null, En = { box: null, placeable: !1, offscreen: null }, Li = { box: null, placeable: !1, offscreen: null }, Ai = null, ni = null, ri = null, ki = 0, Ar = 0, Es = 0;
            vt.textFeatureIndex ? ki = vt.textFeatureIndex : yt.useRuntimeCollisionCircles && (ki = yt.featureIndex), vt.verticalTextFeatureIndex && (Ar = vt.verticalTextFeatureIndex);
            const Yi = vt.textBox;
            if (Yi) {
              const Gi = (Rr) => {
                let mr = l.ai.horizontal;
                if (h.allowVerticalPlacement && !Rr && this.prevPlacement) {
                  const nr = this.prevPlacement.placedOrientations[yt.crossTileID];
                  nr && (this.placedOrientations[yt.crossTileID] = nr, mr = nr, this.markUsedOrientation(h, mr, yt));
                }
                return mr;
              }, si = (Rr, mr) => {
                if (h.allowVerticalPlacement && yt.numVerticalGlyphVertices > 0 && vt.verticalTextBox) {
                  for (const nr of h.writingModes)
                    if (nr === l.ai.vertical ? (En = mr(), Li = En) : En = Rr(), En && En.placeable)
                      break;
                } else
                  En = Rr();
              }, Io = yt.textAnchorOffsetStartIndex, cl = yt.textAnchorOffsetEndIndex;
              if (cl === Io) {
                const Rr = (mr, nr) => {
                  const Ei = this.collisionIndex.placeCollisionBox(mr, ne, D, C, M, Ne, Me, b, Y.predicate, Ct);
                  return Ei && Ei.placeable && (this.markUsedOrientation(h, nr, yt), this.placedOrientations[yt.crossTileID] = nr), Ei;
                };
                si(() => Rr(Yi, l.ai.horizontal), () => {
                  const mr = vt.verticalTextBox;
                  return h.allowVerticalPlacement && yt.numVerticalGlyphVertices > 0 && mr ? Rr(mr, l.ai.vertical) : { box: null, offscreen: null };
                }), Gi(En && En.placeable);
              } else {
                let Rr = l.ar[(Ot = (Sn = this.prevPlacement) === null || Sn === void 0 ? void 0 : Sn.variableOffsets[yt.crossTileID]) === null || Ot === void 0 ? void 0 : Ot.anchor];
                const mr = (Ei, Ur, Da) => {
                  const Vi = Ei.x2 - Ei.x1, ch = Ei.y2 - Ei.y1, ul = yt.textBoxScale, Fc = ot && le === "never" ? Ur : null;
                  let ho = null, _u = ne === "never" ? 1 : 2, Zl = "never";
                  Rr && _u++;
                  for (let hl = 0; hl < _u; hl++) {
                    for (let uh = Io; uh < cl; uh++) {
                      const yu = h.textAnchorOffsets.get(uh);
                      if (Rr && yu.textAnchor !== Rr)
                        continue;
                      const ka = this.attemptAnchorPlacement(yu, Ei, Vi, ch, ul, Me, Ne, D, C, M, Y, Zl, yt, h, Da, b, x, Fc, Ct);
                      if (ka && (ho = ka.placedGlyphBoxes, ho && ho.placeable))
                        return gn = !0, ji = ka.shift, ho;
                    }
                    Rr ? Rr = null : Zl = ne;
                  }
                  return _ && !ho && (ho = { box: this.collisionIndex.placeCollisionBox(Yi, "always", D, C, M, Ne, Me, b, Y.predicate, Ct, new l.P(0, 0)).box, offscreen: !1, placeable: !1 }), ho;
                };
                si(() => mr(Yi, vt.iconBox, l.ai.horizontal), () => {
                  const Ei = vt.verticalTextBox;
                  return h.allowVerticalPlacement && (!En || !En.placeable) && yt.numVerticalGlyphVertices > 0 && Ei ? mr(Ei, vt.verticalIconBox, l.ai.vertical) : { box: null, occluded: !0, offscreen: null };
                }), En && (gn = En.placeable, Qn = En.offscreen);
                const nr = Gi(En && En.placeable);
                if (!gn && this.prevPlacement) {
                  const Ei = this.prevPlacement.variableOffsets[yt.crossTileID];
                  Ei && (this.variableOffsets[yt.crossTileID] = Ei, this.markUsedJustification(h, Ei.anchor, yt, nr));
                }
              }
            }
            if (Ai = En, gn = Ai && Ai.placeable, Qn = Ai && Ai.offscreen, yt.useRuntimeCollisionCircles) {
              const Gi = h.text.placedSymbolArray.get(yt.centerJustifiedTextSymbolIndex), si = l.aj(h.textSizeData, Q, Gi), Io = p.get("text-padding");
              ni = this.collisionIndex.placeCollisionCircles(ne, Gi, h.lineVertexArray, h.glyphOffsetArray, si, C, M, R, O, _, Ne, Y.predicate, yt.collisionCircleDiameter, Io, b, Ct), ni.circles.length && ni.collisionDetected && !_ && l.w("Collisions detected, but collision boxes are not shown"), gn = ie || ni.circles.length > 0 && !ni.collisionDetected, Qn = Qn && ni.offscreen;
            }
            if (vt.iconFeatureIndex && (Es = vt.iconFeatureIndex), vt.iconBox) {
              const Gi = (si) => this.collisionIndex.placeCollisionBox(si, le, D, C, M, Ne, Me, x, Y.predicate, Ct, ot && ji ? ji : void 0);
              Li && Li.placeable && vt.verticalIconBox ? (ri = Gi(vt.verticalIconBox), Wn = ri.placeable) : (ri = Gi(vt.iconBox), Wn = ri.placeable), Qn = Qn && ri.offscreen;
            }
            const ts = K || yt.numHorizontalGlyphVertices === 0 && yt.numVerticalGlyphVertices === 0, Co = fe || yt.numIconVertices === 0;
            ts || Co ? Co ? ts || (Wn = Wn && gn) : gn = Wn && gn : Wn = gn = Wn && gn;
            const Fa = Wn && ri.placeable;
            if (gn && Ai.placeable && this.collisionIndex.insertCollisionBox(Ai.box, ne, p.get("text-ignore-placement"), h.bucketInstanceId, Li && Li.placeable && Ar ? Ar : ki, Y.ID), Fa && this.collisionIndex.insertCollisionBox(ri.box, le, p.get("icon-ignore-placement"), h.bucketInstanceId, Es, Y.ID), ni && gn && this.collisionIndex.insertCollisionCircles(ni.circles, ne, p.get("text-ignore-placement"), h.bucketInstanceId, ki, Y.ID), _ && this.storeCollisionData(h.bucketInstanceId, Ht, vt, Ai, ri, ni), yt.crossTileID === 0)
              throw new Error("symbolInstance.crossTileID can't be 0");
            if (h.bucketInstanceId === 0)
              throw new Error("bucket.bucketInstanceId can't be 0");
            this.placements[yt.crossTileID] = new Kn(gn || rt, Wn || $e, Qn || h.justReloaded), f[yt.crossTileID] = !0;
          };
          if (et) {
            if (a.symbolInstanceStart !== 0)
              throw new Error("bucket.bucketInstanceId should be 0");
            const yt = h.getSortedSymbolIndexes(this.transform.angle);
            for (let vt = yt.length - 1; vt >= 0; --vt) {
              const Ht = yt[vt];
              qt(h.symbolInstances.get(Ht), h.collisionArrays[Ht], Ht);
            }
          } else
            for (let yt = a.symbolInstanceStart; yt < a.symbolInstanceEnd; yt++)
              qt(h.symbolInstances.get(yt), h.collisionArrays[yt], yt);
          if (_ && h.bucketInstanceId in this.collisionCircleArrays) {
            const yt = this.collisionCircleArrays[h.bucketInstanceId];
            l.at(yt.invProjMatrix, C), yt.viewportMatrix = this.collisionIndex.getViewportMatrix();
          }
          h.justReloaded = !1;
        }
        storeCollisionData(a, f, _, h, p, b) {
          if (_.textBox || _.iconBox) {
            let x, C;
            this.collisionBoxArrays.has(a) ? x = this.collisionBoxArrays.get(a) : (x = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(a, x)), x.has(f) ? C = x.get(f) : (C = { text: null, icon: null }, x.set(f, C)), _.textBox && (C.text = h.box), _.iconBox && (C.icon = p.box);
          }
          if (b) {
            let x = this.collisionCircleArrays[a];
            x === void 0 && (x = this.collisionCircleArrays[a] = new dn());
            for (let C = 0; C < b.circles.length; C += 4)
              x.circles.push(b.circles[C + 0]), x.circles.push(b.circles[C + 1]), x.circles.push(b.circles[C + 2]), x.circles.push(b.collisionDetected ? 1 : 0);
          }
        }
        markUsedJustification(a, f, _, h) {
          let p;
          p = h === l.ai.vertical ? _.verticalPlacedTextSymbolIndex : { left: _.leftJustifiedTextSymbolIndex, center: _.centerJustifiedTextSymbolIndex, right: _.rightJustifiedTextSymbolIndex }[l.au(f)];
          const b = [_.leftJustifiedTextSymbolIndex, _.centerJustifiedTextSymbolIndex, _.rightJustifiedTextSymbolIndex, _.verticalPlacedTextSymbolIndex];
          for (const x of b)
            x >= 0 && (a.text.placedSymbolArray.get(x).crossTileID = p >= 0 && x !== p ? 0 : _.crossTileID);
        }
        markUsedOrientation(a, f, _) {
          const h = f === l.ai.horizontal || f === l.ai.horizontalOnly ? f : 0, p = f === l.ai.vertical ? f : 0, b = [_.leftJustifiedTextSymbolIndex, _.centerJustifiedTextSymbolIndex, _.rightJustifiedTextSymbolIndex];
          for (const x of b)
            a.text.placedSymbolArray.get(x).placedOrientation = h;
          _.verticalPlacedTextSymbolIndex && (a.text.placedSymbolArray.get(_.verticalPlacedTextSymbolIndex).placedOrientation = p);
        }
        commit(a) {
          this.commitTime = a, this.zoomAtLastRecencyCheck = this.transform.zoom;
          const f = this.prevPlacement;
          let _ = !1;
          this.prevZoomAdjustment = f ? f.zoomAdjustment(this.transform.zoom) : 0;
          const h = f ? f.symbolFadeChange(a) : 1, p = f ? f.opacities : {}, b = f ? f.variableOffsets : {}, x = f ? f.placedOrientations : {};
          for (const C in this.placements) {
            const M = this.placements[C], R = p[C];
            R ? (this.opacities[C] = new Yn(R, h, M.text, M.icon), _ = _ || M.text !== R.text.placed || M.icon !== R.icon.placed) : (this.opacities[C] = new Yn(null, h, M.text, M.icon, M.skipFade), _ = _ || M.text || M.icon);
          }
          for (const C in p) {
            const M = p[C];
            if (!this.opacities[C]) {
              const R = new Yn(M, h, !1, !1);
              R.isHidden() || (this.opacities[C] = R, _ = _ || M.text.placed || M.icon.placed);
            }
          }
          for (const C in b)
            this.variableOffsets[C] || !this.opacities[C] || this.opacities[C].isHidden() || (this.variableOffsets[C] = b[C]);
          for (const C in x)
            this.placedOrientations[C] || !this.opacities[C] || this.opacities[C].isHidden() || (this.placedOrientations[C] = x[C]);
          if (f && f.lastPlacementChangeTime === void 0)
            throw new Error("Last placement time for previous placement is not defined");
          _ ? this.lastPlacementChangeTime = a : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = f ? f.lastPlacementChangeTime : a);
        }
        updateLayerOpacities(a, f) {
          const _ = {};
          for (const h of f) {
            const p = h.getBucket(a);
            p && h.latestFeatureIndex && a.id === p.layerIds[0] && this.updateBucketOpacities(p, h.tileID, _, h.collisionBoxArray);
          }
        }
        updateBucketOpacities(a, f, _, h) {
          a.hasTextData() && (a.text.opacityVertexArray.clear(), a.text.hasVisibleVertices = !1), a.hasIconData() && (a.icon.opacityVertexArray.clear(), a.icon.hasVisibleVertices = !1), a.hasIconCollisionBoxData() && a.iconCollisionBox.collisionVertexArray.clear(), a.hasTextCollisionBoxData() && a.textCollisionBox.collisionVertexArray.clear();
          const p = a.layers[0], b = p.layout, x = new Yn(null, 0, !1, !1, !0), C = b.get("text-allow-overlap"), M = b.get("icon-allow-overlap"), R = p._unevaluatedLayout.hasValue("text-variable-anchor") || p._unevaluatedLayout.hasValue("text-variable-anchor-offset"), O = b.get("text-rotation-alignment") === "map", D = b.get("text-pitch-alignment") === "map", U = b.get("icon-text-fit") !== "none", W = new Yn(null, 0, C && (M || !a.hasIconData() || b.get("icon-optional")), M && (C || !a.hasTextData() || b.get("text-optional")), !0);
          !a.collisionArrays && h && (a.hasIconCollisionBoxData() || a.hasTextCollisionBoxData()) && a.deserializeCollisionBoxes(h);
          const Q = (K, fe, ne) => {
            for (let ie = 0; ie < fe / 4; ie++)
              K.opacityVertexArray.emplaceBack(ne);
            K.hasVisibleVertices = K.hasVisibleVertices || ne !== fi;
          }, Y = this.collisionBoxArrays.get(a.bucketInstanceId);
          for (let K = 0; K < a.symbolInstances.length; K++) {
            const fe = a.symbolInstances.get(K), { numHorizontalGlyphVertices: ne, numVerticalGlyphVertices: ie, crossTileID: le } = fe;
            let xe = this.opacities[le];
            _[le] ? xe = x : xe || (xe = W, this.opacities[le] = xe), _[le] = !0;
            const Me = fe.numIconVertices > 0, Ne = this.placedOrientations[fe.crossTileID], ot = Ne === l.ai.vertical, et = Ne === l.ai.horizontal || Ne === l.ai.horizontalOnly;
            if (ne > 0 || ie > 0) {
              const $e = Ii(xe.text);
              Q(a.text, ne, ot ? fi : $e), Q(a.text, ie, et ? fi : $e);
              const Ct = xe.text.isHidden();
              [fe.rightJustifiedTextSymbolIndex, fe.centerJustifiedTextSymbolIndex, fe.leftJustifiedTextSymbolIndex].forEach((vt) => {
                vt >= 0 && (a.text.placedSymbolArray.get(vt).hidden = Ct || ot ? 1 : 0);
              }), fe.verticalPlacedTextSymbolIndex >= 0 && (a.text.placedSymbolArray.get(fe.verticalPlacedTextSymbolIndex).hidden = Ct || et ? 1 : 0);
              const qt = this.variableOffsets[fe.crossTileID];
              qt && this.markUsedJustification(a, qt.anchor, fe, Ne);
              const yt = this.placedOrientations[fe.crossTileID];
              yt && (this.markUsedJustification(a, "left", fe, yt), this.markUsedOrientation(a, yt, fe));
            }
            if (Me) {
              const $e = Ii(xe.icon), Ct = !(U && fe.verticalPlacedIconSymbolIndex && ot);
              fe.placedIconSymbolIndex >= 0 && (Q(a.icon, fe.numIconVertices, Ct ? $e : fi), a.icon.placedSymbolArray.get(fe.placedIconSymbolIndex).hidden = xe.icon.isHidden()), fe.verticalPlacedIconSymbolIndex >= 0 && (Q(a.icon, fe.numVerticalIconVertices, Ct ? fi : $e), a.icon.placedSymbolArray.get(fe.verticalPlacedIconSymbolIndex).hidden = xe.icon.isHidden());
            }
            const rt = Y && Y.has(K) ? Y.get(K) : { text: null, icon: null };
            if (a.hasIconCollisionBoxData() || a.hasTextCollisionBoxData()) {
              const $e = a.collisionArrays[K];
              if ($e) {
                let Ct = new l.P(0, 0);
                if ($e.textBox || $e.verticalTextBox) {
                  let qt = !0;
                  if (R) {
                    const yt = this.variableOffsets[le];
                    yt ? (Ct = di(yt.anchor, yt.width, yt.height, yt.textOffset, yt.textBoxScale), O && Ct._rotate(D ? this.transform.angle : -this.transform.angle)) : qt = !1;
                  }
                  if ($e.textBox || $e.verticalTextBox) {
                    let yt;
                    $e.textBox && (yt = ot), $e.verticalTextBox && (yt = et), Xi(a.textCollisionBox.collisionVertexArray, xe.text.placed, !qt || yt, rt.text, Ct.x, Ct.y);
                  }
                }
                if ($e.iconBox || $e.verticalIconBox) {
                  const qt = !!(!et && $e.verticalIconBox);
                  let yt;
                  $e.iconBox && (yt = qt), $e.verticalIconBox && (yt = !qt), Xi(a.iconCollisionBox.collisionVertexArray, xe.icon.placed, yt, rt.icon, U ? Ct.x : 0, U ? Ct.y : 0);
                }
              }
            }
          }
          if (a.sortFeatures(this.transform.angle), this.retainedQueryData[a.bucketInstanceId] && (this.retainedQueryData[a.bucketInstanceId].featureSortOrder = a.featureSortOrder), a.hasTextData() && a.text.opacityVertexBuffer && a.text.opacityVertexBuffer.updateData(a.text.opacityVertexArray), a.hasIconData() && a.icon.opacityVertexBuffer && a.icon.opacityVertexBuffer.updateData(a.icon.opacityVertexArray), a.hasIconCollisionBoxData() && a.iconCollisionBox.collisionVertexBuffer && a.iconCollisionBox.collisionVertexBuffer.updateData(a.iconCollisionBox.collisionVertexArray), a.hasTextCollisionBoxData() && a.textCollisionBox.collisionVertexBuffer && a.textCollisionBox.collisionVertexBuffer.updateData(a.textCollisionBox.collisionVertexArray), a.text.opacityVertexArray.length !== a.text.layoutVertexArray.length / 4)
            throw new Error(`bucket.text.opacityVertexArray.length (= ${a.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${a.text.layoutVertexArray.length}) / 4`);
          if (a.icon.opacityVertexArray.length !== a.icon.layoutVertexArray.length / 4)
            throw new Error(`bucket.icon.opacityVertexArray.length (= ${a.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${a.icon.layoutVertexArray.length}) / 4`);
          if (a.bucketInstanceId in this.collisionCircleArrays) {
            const K = this.collisionCircleArrays[a.bucketInstanceId];
            a.placementInvProjMatrix = K.invProjMatrix, a.placementViewportMatrix = K.viewportMatrix, a.collisionCircleArray = K.circles, delete this.collisionCircleArrays[a.bucketInstanceId];
          }
        }
        symbolFadeChange(a) {
          return this.fadeDuration === 0 ? 1 : (a - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }
        zoomAdjustment(a) {
          return Math.max(0, (this.transform.zoom - a) / 1.5);
        }
        hasTransitions(a) {
          return this.stale || a - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(a, f) {
          const _ = this.zoomAtLastRecencyCheck === f ? 1 - this.zoomAdjustment(f) : 1;
          return this.zoomAtLastRecencyCheck = f, this.commitTime + this.fadeDuration * _ > a;
        }
        setStale() {
          this.stale = !0;
        }
      }
      function Xi(E, a, f, _, h, p) {
        _ && _.length !== 0 || (_ = [0, 0, 0, 0]);
        const b = _[0] - _n, x = _[1] - _n, C = _[2] - _n, M = _[3] - _n;
        E.emplaceBack(a ? 1 : 0, f ? 1 : 0, h || 0, p || 0, b, x), E.emplaceBack(a ? 1 : 0, f ? 1 : 0, h || 0, p || 0, C, x), E.emplaceBack(a ? 1 : 0, f ? 1 : 0, h || 0, p || 0, C, M), E.emplaceBack(a ? 1 : 0, f ? 1 : 0, h || 0, p || 0, b, M);
      }
      const yo = Math.pow(2, 25), Xn = Math.pow(2, 24), br = Math.pow(2, 17), Hr = Math.pow(2, 16), Ri = Math.pow(2, 9), Oi = Math.pow(2, 8), Ys = Math.pow(2, 1);
      function Ii(E) {
        if (E.opacity === 0 && !E.placed)
          return 0;
        if (E.opacity === 1 && E.placed)
          return 4294967295;
        const a = E.placed ? 1 : 0, f = Math.floor(127 * E.opacity);
        return f * yo + a * Xn + f * br + a * Hr + f * Ri + a * Oi + f * Ys + a;
      }
      const fi = 0;
      function zo() {
        return { isOccluded: (E, a, f) => !1, getPitchedTextCorrection: (E, a, f) => 1, get useSpecialProjectionForSymbols() {
          return !1;
        }, projectTileCoordinates(E, a, f, _) {
          throw new Error("Not implemented.");
        }, translatePosition: (E, a, f, _) => function(h, p, b, x) {
          let C = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
          if (!b[0] && !b[1])
            return [0, 0];
          const M = C ? x === "map" ? h.angle : 0 : x === "viewport" ? -h.angle : 0;
          if (M) {
            const R = Math.sin(M), O = Math.cos(M);
            b = [b[0] * O - b[1] * R, b[0] * R + b[1] * O];
          }
          return [C ? b[0] : an(p, b[0], h.zoom), C ? b[1] : an(p, b[1], h.zoom)];
        }(E, a, f, _), getCircleRadiusCorrection: (E) => 1 };
      }
      class _s {
        constructor(a) {
          this._sortAcrossTiles = a.layout.get("symbol-z-order") !== "viewport-y" && !a.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
        }
        continuePlacement(a, f, _, h, p) {
          const b = this._bucketParts;
          for (; this._currentTileIndex < a.length; )
            if (f.getBucketParts(b, h, a[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, p())
              return !0;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, b.sort((x, C) => x.sortKey - C.sortKey)); this._currentPartIndex < b.length; )
            if (f.placeLayerBucketPart(b[this._currentPartIndex], this._seenCrossTileIDs, _), this._currentPartIndex++, p())
              return !0;
          return !1;
        }
      }
      class xi {
        constructor(a, f, _, h, p, b, x, C) {
          this.placement = new Bi(a, zo(), f, b, x, C), this._currentPlacementIndex = _.length - 1, this._forceFullPlacement = h, this._showCollisionBoxes = p, this._done = !1;
        }
        isDone() {
          return this._done;
        }
        continuePlacement(a, f, _) {
          const h = T.now(), p = () => !this._forceFullPlacement && T.now() - h > 2;
          for (; this._currentPlacementIndex >= 0; ) {
            const b = f[a[this._currentPlacementIndex]], x = this.placement.collisionIndex.transform.zoom;
            if (b.type === "symbol" && (!b.minzoom || b.minzoom <= x) && (!b.maxzoom || b.maxzoom > x)) {
              if (this._inProgressLayer || (this._inProgressLayer = new _s(b)), this._inProgressLayer.continuePlacement(_[b.source], this.placement, this._showCollisionBoxes, b, p))
                return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = !0;
        }
        commit(a) {
          return this.placement.commit(a), this.placement;
        }
      }
      const Nn = 512 / l.X / 2;
      class Wr {
        constructor(a, f, _) {
          this.tileID = a, this.bucketInstanceId = _, this._symbolsByKey = {};
          const h = /* @__PURE__ */ new Map();
          for (let p = 0; p < f.length; p++) {
            const b = f.get(p), x = b.key, C = h.get(x);
            C ? C.push(b) : h.set(x, [b]);
          }
          for (const [p, b] of h) {
            const x = { positions: b.map((C) => ({ x: Math.floor(C.anchorX * Nn), y: Math.floor(C.anchorY * Nn) })), crossTileIDs: b.map((C) => C.crossTileID) };
            if (x.positions.length > 128) {
              const C = new l.aw(x.positions.length, 16, Uint16Array);
              for (const { x: M, y: R } of x.positions)
                C.add(M, R);
              C.finish(), delete x.positions, x.index = C;
            }
            this._symbolsByKey[p] = x;
          }
        }
        getScaledCoordinates(a, f) {
          const { x: _, y: h, z: p } = this.tileID.canonical, { x: b, y: x, z: C } = f.canonical, M = Nn / Math.pow(2, C - p), R = (x * l.X + a.anchorY) * M, O = h * l.X * Nn;
          return { x: Math.floor((b * l.X + a.anchorX) * M - _ * l.X * Nn), y: Math.floor(R - O) };
        }
        findMatches(a, f, _) {
          const h = this.tileID.canonical.z < f.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - f.canonical.z);
          for (let p = 0; p < a.length; p++) {
            const b = a.get(p);
            if (b.crossTileID)
              continue;
            const x = this._symbolsByKey[b.key];
            if (!x)
              continue;
            const C = this.getScaledCoordinates(b, f);
            if (x.index) {
              const M = x.index.range(C.x - h, C.y - h, C.x + h, C.y + h).sort();
              for (const R of M) {
                const O = x.crossTileIDs[R];
                if (!_[O]) {
                  _[O] = !0, b.crossTileID = O;
                  break;
                }
              }
            } else if (x.positions)
              for (let M = 0; M < x.positions.length; M++) {
                const R = x.positions[M], O = x.crossTileIDs[M];
                if (Math.abs(R.x - C.x) <= h && Math.abs(R.y - C.y) <= h && !_[O]) {
                  _[O] = !0, b.crossTileID = O;
                  break;
                }
              }
          }
        }
        getCrossTileIDsLists() {
          return Object.values(this._symbolsByKey).map((a) => {
            let { crossTileIDs: f } = a;
            return f;
          });
        }
      }
      class _i {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }
      class Ks {
        constructor() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        }
        handleWrapJump(a) {
          const f = Math.round((a - this.lng) / 360);
          if (f !== 0)
            for (const _ in this.indexes) {
              const h = this.indexes[_], p = {};
              for (const b in h) {
                const x = h[b];
                x.tileID = x.tileID.unwrapTo(x.tileID.wrap + f), p[x.tileID.key] = x;
              }
              this.indexes[_] = p;
            }
          this.lng = a;
        }
        addBucket(a, f, _) {
          if (this.indexes[a.overscaledZ] && this.indexes[a.overscaledZ][a.key]) {
            if (this.indexes[a.overscaledZ][a.key].bucketInstanceId === f.bucketInstanceId)
              return !1;
            this.removeBucketCrossTileIDs(a.overscaledZ, this.indexes[a.overscaledZ][a.key]);
          }
          for (let p = 0; p < f.symbolInstances.length; p++)
            f.symbolInstances.get(p).crossTileID = 0;
          this.usedCrossTileIDs[a.overscaledZ] || (this.usedCrossTileIDs[a.overscaledZ] = {});
          const h = this.usedCrossTileIDs[a.overscaledZ];
          for (const p in this.indexes) {
            const b = this.indexes[p];
            if (Number(p) > a.overscaledZ)
              for (const x in b) {
                const C = b[x];
                C.tileID.isChildOf(a) && C.findMatches(f.symbolInstances, a, h);
              }
            else {
              const x = b[a.scaledTo(Number(p)).key];
              x && x.findMatches(f.symbolInstances, a, h);
            }
          }
          for (let p = 0; p < f.symbolInstances.length; p++) {
            const b = f.symbolInstances.get(p);
            b.crossTileID || (b.crossTileID = _.generate(), h[b.crossTileID] = !0);
          }
          return this.indexes[a.overscaledZ] === void 0 && (this.indexes[a.overscaledZ] = {}), this.indexes[a.overscaledZ][a.key] = new Wr(a, f.symbolInstances, f.bucketInstanceId), !0;
        }
        removeBucketCrossTileIDs(a, f) {
          for (const _ of f.getCrossTileIDsLists())
            for (const h of _)
              delete this.usedCrossTileIDs[a][h];
        }
        removeStaleBuckets(a) {
          let f = !1;
          for (const _ in this.indexes) {
            const h = this.indexes[_];
            for (const p in h)
              a[h[p].bucketInstanceId] || (this.removeBucketCrossTileIDs(_, h[p]), delete h[p], f = !0);
          }
          return f;
        }
      }
      class hr {
        constructor() {
          this.layerIndexes = {}, this.crossTileIDs = new _i(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        }
        addLayer(a, f, _) {
          let h = this.layerIndexes[a.id];
          h === void 0 && (h = this.layerIndexes[a.id] = new Ks());
          let p = !1;
          const b = {};
          h.handleWrapJump(_);
          for (const x of f) {
            const C = x.getBucket(a);
            C && a.id === C.layerIds[0] && (C.bucketInstanceId || (C.bucketInstanceId = ++this.maxBucketInstanceId), h.addBucket(x.tileID, C, this.crossTileIDs) && (p = !0), b[C.bucketInstanceId] = !0);
          }
          return h.removeStaleBuckets(b) && (p = !0), p;
        }
        pruneUnusedLayers(a) {
          const f = {};
          a.forEach((_) => {
            f[_] = !0;
          });
          for (const _ in this.layerIndexes)
            f[_] || delete this.layerIndexes[_];
        }
      }
      const Qs = (E, a) => l.t(E, a && a.filter((f) => f.identifier !== "source.canvas")), Ji = l.ax();
      class Pr extends l.E {
        constructor(a) {
          let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          super(), this._rtlPluginLoaded = () => {
            for (const _ in this.sourceCaches) {
              const h = this.sourceCaches[_].getSource().type;
              h !== "vector" && h !== "geojson" || this.sourceCaches[_].reload();
            }
          }, this.map = a, this.dispatcher = new At(Ze(), a._getMapId()), this.dispatcher.registerMessageHandler("GG", (_, h) => this.getGlyphs(_, h)), this.dispatcher.registerMessageHandler("GI", (_, h) => this.getImages(_, h)), this.imageManager = new Te(), this.imageManager.setEventedParent(this), this.glyphManager = new lt(a._requestManager, f.localIdeographFontFamily), this.lineAtlas = new Ae(256, 512), this.crossTileSymbolIndex = new hr(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new l.ay(), this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("SR", l.az()), Bt().on(mt, this._rtlPluginLoaded), this.on("data", (_) => {
            if (_.dataType !== "source" || _.sourceDataType !== "metadata")
              return;
            const h = this.sourceCaches[_.sourceId];
            if (!h)
              return;
            const p = h.getSource();
            if (p && p.vectorLayerIds)
              for (const b in this._layers) {
                const x = this._layers[b];
                x.source === p.id && this._validateLayer(x);
              }
          });
        }
        loadURL(a) {
          let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ = arguments.length > 2 ? arguments[2] : void 0;
          this.fire(new l.k("dataloading", { dataType: "style" })), f.validate = typeof f.validate != "boolean" || f.validate;
          const h = this.map._requestManager.transformRequest(a, "Style");
          this._loadStyleRequest = new AbortController(), l.h(h, this._loadStyleRequest).then((p) => {
            this._loadStyleRequest = null, this._load(p.data, f, _);
          }).catch((p) => {
            this._loadStyleRequest = null, p && this.fire(new l.j(p));
          });
        }
        loadJSON(a) {
          let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ = arguments.length > 2 ? arguments[2] : void 0;
          this.fire(new l.k("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), T.frameAsync(this._frameRequest).then(() => {
            this._frameRequest = null, f.validate = f.validate !== !1, this._load(a, f, _);
          }).catch(() => {
          });
        }
        loadEmpty() {
          this.fire(new l.k("dataloading", { dataType: "style" })), this._load(Ji, { validate: !1 });
        }
        _load(a, f, _) {
          var h;
          const p = f.transformStyle ? f.transformStyle(_, a) : a;
          if (!f.validate || !Qs(this, l.x(p))) {
            this._loaded = !0, this.stylesheet = p;
            for (const b in p.sources)
              this.addSource(b, p.sources[b], { validate: !1 });
            p.sprite ? this._loadSprite(p.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(p.glyphs), this._createLayers(), this.light = new ct(this.stylesheet.light), this.sky = new se(this.stylesheet.sky), this.map.setTerrain((h = this.stylesheet.terrain) !== null && h !== void 0 ? h : null), this.fire(new l.k("data", { dataType: "style" })), this.fire(new l.k("style.load"));
          }
        }
        _createLayers() {
          const a = l.aA(this.stylesheet.layers);
          this.dispatcher.broadcast("SL", a), this._order = a.map((f) => f.id), this._layers = {}, this._serializedLayers = null;
          for (const f of a) {
            const _ = l.aB(f);
            _.setEventedParent(this, { layer: { id: f.id } }), this._layers[f.id] = _;
          }
        }
        _loadSprite(a) {
          let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, _ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, h;
          this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController(), function(p, b, x, C) {
            return l._(this, void 0, void 0, function* () {
              const M = Ve(p), R = x > 1 ? "@2x" : "", O = {}, D = {};
              for (const { id: U, url: W } of M) {
                const Q = b.transformRequest(Fe(W, R, ".json"), "SpriteJSON");
                O[U] = l.h(Q, C);
                const Y = b.transformRequest(Fe(W, R, ".png"), "SpriteImage");
                D[U] = ce.getImage(Y, C);
              }
              return yield Promise.all([...Object.values(O), ...Object.values(D)]), function(U, W) {
                return l._(this, void 0, void 0, function* () {
                  const Q = {};
                  for (const Y in U) {
                    Q[Y] = {};
                    const K = T.getImageCanvasContext((yield W[Y]).data), fe = (yield U[Y]).data;
                    for (const ne in fe) {
                      const { width: ie, height: le, x: xe, y: Me, sdf: Ne, pixelRatio: ot, stretchX: et, stretchY: rt, content: $e, textFitWidth: Ct, textFitHeight: qt } = fe[ne];
                      Q[Y][ne] = { data: null, pixelRatio: ot, sdf: Ne, stretchX: et, stretchY: rt, content: $e, textFitWidth: Ct, textFitHeight: qt, spriteData: { width: ie, height: le, x: xe, y: Me, context: K } };
                    }
                  }
                  return Q;
                });
              }(O, D);
            });
          }(a, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((p) => {
            if (this._spriteRequest = null, p)
              for (const b in p) {
                this._spritesImagesIds[b] = [];
                const x = this._spritesImagesIds[b] ? this._spritesImagesIds[b].filter((C) => !(C in p)) : [];
                for (const C of x)
                  this.imageManager.removeImage(C), this._changedImages[C] = !0;
                for (const C in p[b]) {
                  const M = b === "default" ? C : `${b}:${C}`;
                  this._spritesImagesIds[b].push(M), M in this.imageManager.images ? this.imageManager.updateImage(M, p[b][C], !1) : this.imageManager.addImage(M, p[b][C]), f && (this._changedImages[M] = !0);
                }
              }
          }).catch((p) => {
            this._spriteRequest = null, h = p, this.fire(new l.j(h));
          }).finally(() => {
            this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), f && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new l.k("data", { dataType: "style" })), _ && _(h);
          });
        }
        _unloadSprite() {
          for (const a of Object.values(this._spritesImagesIds).flat())
            this.imageManager.removeImage(a), this._changedImages[a] = !0;
          this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new l.k("data", { dataType: "style" }));
        }
        _validateLayer(a) {
          const f = this.sourceCaches[a.source];
          if (!f)
            return;
          const _ = a.sourceLayer;
          if (!_)
            return;
          const h = f.getSource();
          (h.type === "geojson" || h.vectorLayerIds && h.vectorLayerIds.indexOf(_) === -1) && this.fire(new l.j(new Error(`Source layer "${_}" does not exist on source "${h.id}" as specified by style layer "${a.id}".`)));
        }
        loaded() {
          if (!this._loaded || Object.keys(this._updatedSources).length)
            return !1;
          for (const a in this.sourceCaches)
            if (!this.sourceCaches[a].loaded())
              return !1;
          return !!this.imageManager.isLoaded();
        }
        _serializeByIds(a) {
          const f = this._serializedAllLayers();
          if (!a || a.length === 0)
            return Object.values(f);
          const _ = [];
          for (const h of a)
            f[h] && _.push(f[h]);
          return _;
        }
        _serializedAllLayers() {
          let a = this._serializedLayers;
          if (a)
            return a;
          a = this._serializedLayers = {};
          const f = Object.keys(this._layers);
          for (const _ of f) {
            const h = this._layers[_];
            h.type !== "custom" && (a[_] = h.serialize());
          }
          return a;
        }
        hasTransitions() {
          if (this.light && this.light.hasTransition() || this.sky && this.sky.hasTransition())
            return !0;
          for (const a in this.sourceCaches)
            if (this.sourceCaches[a].hasTransition())
              return !0;
          for (const a in this._layers)
            if (this._layers[a].hasTransition())
              return !0;
          return !1;
        }
        _checkLoaded() {
          if (!this._loaded)
            throw new Error("Style is not done loading.");
        }
        update(a) {
          if (!this._loaded)
            return;
          const f = this._changed;
          if (f) {
            const h = Object.keys(this._updatedLayers), p = Object.keys(this._removedLayers);
            (h.length || p.length) && this._updateWorkerLayers(h, p);
            for (const b in this._updatedSources) {
              const x = this._updatedSources[b];
              if (x === "reload")
                this._reloadSource(b);
              else {
                if (x !== "clear")
                  throw new Error(`Invalid action ${x}`);
                this._clearSource(b);
              }
            }
            this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
            for (const b in this._updatedPaintProps)
              this._layers[b].updateTransitions(a);
            this.light.updateTransitions(a), this.sky.updateTransitions(a), this._resetUpdates();
          }
          const _ = {};
          for (const h in this.sourceCaches) {
            const p = this.sourceCaches[h];
            _[h] = p.used, p.used = !1;
          }
          for (const h of this._order) {
            const p = this._layers[h];
            p.recalculate(a, this._availableImages), !p.isHidden(a.zoom) && p.source && (this.sourceCaches[p.source].used = !0);
          }
          for (const h in _) {
            const p = this.sourceCaches[h];
            !!_[h] != !!p.used && p.fire(new l.k("data", { sourceDataType: "visibility", dataType: "source", sourceId: h }));
          }
          this.light.recalculate(a), this.sky.recalculate(a), this.z = a.zoom, f && this.fire(new l.k("data", { dataType: "style" }));
        }
        _updateTilesForChangedImages() {
          const a = Object.keys(this._changedImages);
          if (a.length) {
            for (const f in this.sourceCaches)
              this.sourceCaches[f].reloadTilesForDependencies(["icons", "patterns"], a);
            this._changedImages = {};
          }
        }
        _updateTilesForChangedGlyphs() {
          if (this._glyphsDidChange) {
            for (const a in this.sourceCaches)
              this.sourceCaches[a].reloadTilesForDependencies(["glyphs"], [""]);
            this._glyphsDidChange = !1;
          }
        }
        _updateWorkerLayers(a, f) {
          this.dispatcher.broadcast("UL", { layers: this._serializeByIds(a), removedIds: f });
        }
        _resetUpdates() {
          this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1;
        }
        setState(a) {
          let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var _;
          this._checkLoaded();
          const h = this.serialize();
          if (a = f.transformStyle ? f.transformStyle(h, a) : a, ((_ = f.validate) === null || _ === void 0 || _) && Qs(this, l.x(a)))
            return !1;
          (a = l.aC(a)).layers = l.aA(a.layers);
          const p = l.aD(h, a), b = this._getOperationsToPerform(p);
          if (b.unimplemented.length > 0)
            throw new Error(`Unimplemented: ${b.unimplemented.join(", ")}.`);
          if (b.operations.length === 0)
            return !1;
          for (const x of b.operations)
            x();
          return this.stylesheet = a, this._serializedLayers = null, !0;
        }
        _getOperationsToPerform(a) {
          const f = [], _ = [];
          for (const h of a)
            switch (h.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
                continue;
              case "addLayer":
                f.push(() => this.addLayer.apply(this, h.args));
                break;
              case "removeLayer":
                f.push(() => this.removeLayer.apply(this, h.args));
                break;
              case "setPaintProperty":
                f.push(() => this.setPaintProperty.apply(this, h.args));
                break;
              case "setLayoutProperty":
                f.push(() => this.setLayoutProperty.apply(this, h.args));
                break;
              case "setFilter":
                f.push(() => this.setFilter.apply(this, h.args));
                break;
              case "addSource":
                f.push(() => this.addSource.apply(this, h.args));
                break;
              case "removeSource":
                f.push(() => this.removeSource.apply(this, h.args));
                break;
              case "setLayerZoomRange":
                f.push(() => this.setLayerZoomRange.apply(this, h.args));
                break;
              case "setLight":
                f.push(() => this.setLight.apply(this, h.args));
                break;
              case "setGeoJSONSourceData":
                f.push(() => this.setGeoJSONSourceData.apply(this, h.args));
                break;
              case "setGlyphs":
                f.push(() => this.setGlyphs.apply(this, h.args));
                break;
              case "setSprite":
                f.push(() => this.setSprite.apply(this, h.args));
                break;
              case "setSky":
                f.push(() => this.setSky.apply(this, h.args));
                break;
              case "setTerrain":
                f.push(() => this.map.setTerrain.apply(this, h.args));
                break;
              case "setTransition":
                f.push(() => {
                });
                break;
              default:
                _.push(h.command);
            }
          return { operations: f, unimplemented: _ };
        }
        addImage(a, f) {
          if (this.getImage(a))
            return this.fire(new l.j(new Error(`An image named "${a}" already exists.`)));
          this.imageManager.addImage(a, f), this._afterImageUpdated(a);
        }
        updateImage(a, f) {
          this.imageManager.updateImage(a, f);
        }
        getImage(a) {
          return this.imageManager.getImage(a);
        }
        removeImage(a) {
          if (!this.getImage(a))
            return this.fire(new l.j(new Error(`An image named "${a}" does not exist.`)));
          this.imageManager.removeImage(a), this._afterImageUpdated(a);
        }
        _afterImageUpdated(a) {
          this._availableImages = this.imageManager.listImages(), this._changedImages[a] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new l.k("data", { dataType: "style" }));
        }
        listImages() {
          return this._checkLoaded(), this.imageManager.listImages();
        }
        addSource(a, f) {
          let _ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          if (this._checkLoaded(), this.sourceCaches[a] !== void 0)
            throw new Error(`Source "${a}" already exists.`);
          if (!f.type)
            throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(f).join(", ")}.`);
          if (["vector", "raster", "geojson", "video", "image"].indexOf(f.type) >= 0 && this._validate(l.x.source, `sources.${a}`, f, null, _))
            return;
          this.map && this.map._collectResourceTiming && (f.collectResourceTiming = !0);
          const h = this.sourceCaches[a] = new Gt(a, f, this.dispatcher);
          h.style = this, h.setEventedParent(this, () => ({ isSourceLoaded: h.loaded(), source: h.serialize(), sourceId: a })), h.onAdd(this.map), this._changed = !0;
        }
        removeSource(a) {
          if (this._checkLoaded(), this.sourceCaches[a] === void 0)
            throw new Error("There is no source with this ID");
          for (const _ in this._layers)
            if (this._layers[_].source === a)
              return this.fire(new l.j(new Error(`Source "${a}" cannot be removed while layer "${_}" is using it.`)));
          const f = this.sourceCaches[a];
          delete this.sourceCaches[a], delete this._updatedSources[a], f.fire(new l.k("data", { sourceDataType: "metadata", dataType: "source", sourceId: a })), f.setEventedParent(null), f.onRemove(this.map), this._changed = !0;
        }
        setGeoJSONSourceData(a, f) {
          if (this._checkLoaded(), this.sourceCaches[a] === void 0)
            throw new Error(`There is no source with this ID=${a}`);
          const _ = this.sourceCaches[a].getSource();
          if (_.type !== "geojson")
            throw new Error(`geojsonSource.type is ${_.type}, which is !== 'geojson`);
          _.setData(f), this._changed = !0;
        }
        getSource(a) {
          return this.sourceCaches[a] && this.sourceCaches[a].getSource();
        }
        addLayer(a, f) {
          let _ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          this._checkLoaded();
          const h = a.id;
          if (this.getLayer(h))
            return void this.fire(new l.j(new Error(`Layer "${h}" already exists on this map.`)));
          let p;
          if (a.type === "custom") {
            if (Qs(this, l.aE(a)))
              return;
            p = l.aB(a);
          } else {
            if ("source" in a && typeof a.source == "object" && (this.addSource(h, a.source), a = l.aC(a), a = l.e(a, { source: h })), this._validate(l.x.layer, `layers.${h}`, a, { arrayIndex: -1 }, _))
              return;
            p = l.aB(a), this._validateLayer(p), p.setEventedParent(this, { layer: { id: h } });
          }
          const b = f ? this._order.indexOf(f) : this._order.length;
          if (f && b === -1)
            this.fire(new l.j(new Error(`Cannot add layer "${h}" before non-existing layer "${f}".`)));
          else {
            if (this._order.splice(b, 0, h), this._layerOrderChanged = !0, this._layers[h] = p, this._removedLayers[h] && p.source && p.type !== "custom") {
              const x = this._removedLayers[h];
              delete this._removedLayers[h], x.type !== p.type ? this._updatedSources[p.source] = "clear" : (this._updatedSources[p.source] = "reload", this.sourceCaches[p.source].pause());
            }
            this._updateLayer(p), p.onAdd && p.onAdd(this.map);
          }
        }
        moveLayer(a, f) {
          if (this._checkLoaded(), this._changed = !0, !this._layers[a])
            return void this.fire(new l.j(new Error(`The layer '${a}' does not exist in the map's style and cannot be moved.`)));
          if (a === f)
            return;
          const _ = this._order.indexOf(a);
          this._order.splice(_, 1);
          const h = f ? this._order.indexOf(f) : this._order.length;
          f && h === -1 ? this.fire(new l.j(new Error(`Cannot move layer "${a}" before non-existing layer "${f}".`))) : (this._order.splice(h, 0, a), this._layerOrderChanged = !0);
        }
        removeLayer(a) {
          this._checkLoaded();
          const f = this._layers[a];
          if (!f)
            return void this.fire(new l.j(new Error(`Cannot remove non-existing layer "${a}".`)));
          f.setEventedParent(null);
          const _ = this._order.indexOf(a);
          this._order.splice(_, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[a] = f, delete this._layers[a], this._serializedLayers && delete this._serializedLayers[a], delete this._updatedLayers[a], delete this._updatedPaintProps[a], f.onRemove && f.onRemove(this.map);
        }
        getLayer(a) {
          return this._layers[a];
        }
        getLayersOrder() {
          return [...this._order];
        }
        hasLayer(a) {
          return a in this._layers;
        }
        setLayerZoomRange(a, f, _) {
          this._checkLoaded();
          const h = this.getLayer(a);
          h ? h.minzoom === f && h.maxzoom === _ || (f != null && (h.minzoom = f), _ != null && (h.maxzoom = _), this._updateLayer(h)) : this.fire(new l.j(new Error(`Cannot set the zoom range of non-existing layer "${a}".`)));
        }
        setFilter(a, f) {
          let _ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          this._checkLoaded();
          const h = this.getLayer(a);
          if (h) {
            if (!l.aF(h.filter, f))
              return f == null ? (h.filter = void 0, void this._updateLayer(h)) : void (this._validate(l.x.filter, `layers.${h.id}.filter`, f, null, _) || (h.filter = l.aC(f), this._updateLayer(h)));
          } else
            this.fire(new l.j(new Error(`Cannot filter non-existing layer "${a}".`)));
        }
        getFilter(a) {
          return l.aC(this.getLayer(a).filter);
        }
        setLayoutProperty(a, f, _) {
          let h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          this._checkLoaded();
          const p = this.getLayer(a);
          p ? l.aF(p.getLayoutProperty(f), _) || (p.setLayoutProperty(f, _, h), this._updateLayer(p)) : this.fire(new l.j(new Error(`Cannot style non-existing layer "${a}".`)));
        }
        getLayoutProperty(a, f) {
          const _ = this.getLayer(a);
          if (_)
            return _.getLayoutProperty(f);
          this.fire(new l.j(new Error(`Cannot get style of non-existing layer "${a}".`)));
        }
        setPaintProperty(a, f, _) {
          let h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          this._checkLoaded();
          const p = this.getLayer(a);
          p ? l.aF(p.getPaintProperty(f), _) || (p.setPaintProperty(f, _, h) && this._updateLayer(p), this._changed = !0, this._updatedPaintProps[a] = !0, this._serializedLayers = null) : this.fire(new l.j(new Error(`Cannot style non-existing layer "${a}".`)));
        }
        getPaintProperty(a, f) {
          return this.getLayer(a).getPaintProperty(f);
        }
        setFeatureState(a, f) {
          this._checkLoaded();
          const _ = a.source, h = a.sourceLayer, p = this.sourceCaches[_];
          if (p === void 0)
            return void this.fire(new l.j(new Error(`The source '${_}' does not exist in the map's style.`)));
          const b = p.getSource().type;
          b === "geojson" && h ? this.fire(new l.j(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : b !== "vector" || h ? (a.id === void 0 && this.fire(new l.j(new Error("The feature id parameter must be provided."))), p.setFeatureState(h, a.id, f)) : this.fire(new l.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        removeFeatureState(a, f) {
          this._checkLoaded();
          const _ = a.source, h = this.sourceCaches[_];
          if (h === void 0)
            return void this.fire(new l.j(new Error(`The source '${_}' does not exist in the map's style.`)));
          const p = h.getSource().type, b = p === "vector" ? a.sourceLayer : void 0;
          p !== "vector" || b ? f && typeof a.id != "string" && typeof a.id != "number" ? this.fire(new l.j(new Error("A feature id is required to remove its specific state property."))) : h.removeFeatureState(b, a.id, f) : this.fire(new l.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        getFeatureState(a) {
          this._checkLoaded();
          const f = a.source, _ = a.sourceLayer, h = this.sourceCaches[f];
          if (h !== void 0)
            return h.getSource().type !== "vector" || _ ? (a.id === void 0 && this.fire(new l.j(new Error("The feature id parameter must be provided."))), h.getFeatureState(_, a.id)) : void this.fire(new l.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
          this.fire(new l.j(new Error(`The source '${f}' does not exist in the map's style.`)));
        }
        getTransition() {
          return l.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
        }
        serialize() {
          if (!this._loaded)
            return;
          const a = l.aG(this.sourceCaches, (p) => p.serialize()), f = this._serializeByIds(this._order), _ = this.map.getTerrain() || void 0, h = this.stylesheet;
          return l.aH({ version: h.version, name: h.name, metadata: h.metadata, light: h.light, sky: h.sky, center: h.center, zoom: h.zoom, bearing: h.bearing, pitch: h.pitch, sprite: h.sprite, glyphs: h.glyphs, transition: h.transition, sources: a, layers: f, terrain: _ }, (p) => p !== void 0);
        }
        _updateLayer(a) {
          this._updatedLayers[a.id] = !0, a.source && !this._updatedSources[a.source] && this.sourceCaches[a.source].getSource().type !== "raster" && (this._updatedSources[a.source] = "reload", this.sourceCaches[a.source].pause()), this._serializedLayers = null, this._changed = !0;
        }
        _flattenAndSortRenderedFeatures(a) {
          const f = (b) => this._layers[b].type === "fill-extrusion", _ = {}, h = [];
          for (let b = this._order.length - 1; b >= 0; b--) {
            const x = this._order[b];
            if (f(x)) {
              _[x] = b;
              for (const C of a) {
                const M = C[x];
                if (M)
                  for (const R of M)
                    h.push(R);
              }
            }
          }
          h.sort((b, x) => x.intersectionZ - b.intersectionZ);
          const p = [];
          for (let b = this._order.length - 1; b >= 0; b--) {
            const x = this._order[b];
            if (f(x))
              for (let C = h.length - 1; C >= 0; C--) {
                const M = h[C].feature;
                if (_[M.layer.id] < b)
                  break;
                p.push(M), h.pop();
              }
            else
              for (const C of a) {
                const M = C[x];
                if (M)
                  for (const R of M)
                    p.push(R.feature);
              }
          }
          return p;
        }
        queryRenderedFeatures(a, f, _) {
          f && f.filter && this._validate(l.x.filter, "queryRenderedFeatures.filter", f.filter, null, f);
          const h = {};
          if (f && f.layers) {
            if (!Array.isArray(f.layers))
              return this.fire(new l.j(new Error("parameters.layers must be an Array."))), [];
            for (const x of f.layers) {
              const C = this._layers[x];
              if (!C)
                return this.fire(new l.j(new Error(`The layer '${x}' does not exist in the map's style and cannot be queried for features.`))), [];
              h[C.source] = !0;
            }
          }
          const p = [];
          f.availableImages = this._availableImages;
          const b = this._serializedAllLayers();
          for (const x in this.sourceCaches)
            f.layers && !h[x] || p.push(kt(this.sourceCaches[x], this._layers, b, a, f, _));
          return this.placement && p.push(function(x, C, M, R, O, D, U) {
            const W = {}, Q = D.queryRenderedSymbols(R), Y = [];
            for (const K of Object.keys(Q).map(Number))
              Y.push(U[K]);
            Y.sort(on);
            for (const K of Y) {
              const fe = K.featureIndex.lookupSymbolFeatures(Q[K.bucketInstanceId], C, K.bucketIndex, K.sourceLayerIndex, O.filter, O.layers, O.availableImages, x);
              for (const ne in fe) {
                const ie = W[ne] = W[ne] || [], le = fe[ne];
                le.sort((xe, Me) => {
                  const Ne = K.featureSortOrder;
                  if (Ne) {
                    const ot = Ne.indexOf(xe.featureIndex);
                    return Ne.indexOf(Me.featureIndex) - ot;
                  }
                  return Me.featureIndex - xe.featureIndex;
                });
                for (const xe of le)
                  ie.push(xe);
              }
            }
            for (const K in W)
              W[K].forEach((fe) => {
                const ne = fe.feature, ie = M[x[K].source].getFeatureState(ne.layer["source-layer"], ne.id);
                ne.source = ne.layer.source, ne.layer["source-layer"] && (ne.sourceLayer = ne.layer["source-layer"]), ne.state = ie;
              });
            return W;
          }(this._layers, b, this.sourceCaches, a, f, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(p);
        }
        querySourceFeatures(a, f) {
          f && f.filter && this._validate(l.x.filter, "querySourceFeatures.filter", f.filter, null, f);
          const _ = this.sourceCaches[a];
          return _ ? function(h, p) {
            const b = h.getRenderableIds().map((M) => h.getTileByID(M)), x = [], C = {};
            for (let M = 0; M < b.length; M++) {
              const R = b[M], O = R.tileID.canonical.key;
              C[O] || (C[O] = !0, R.querySourceFeatures(x, p));
            }
            return x;
          }(_, f) : [];
        }
        getLight() {
          return this.light.getLight();
        }
        setLight(a) {
          let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          this._checkLoaded();
          const _ = this.light.getLight();
          let h = !1;
          for (const b in a)
            if (!l.aF(a[b], _[b])) {
              h = !0;
              break;
            }
          if (!h)
            return;
          const p = { now: T.now(), transition: l.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
          this.light.setLight(a, f), this.light.updateTransitions(p);
        }
        getSky() {
          var a;
          return (a = this.stylesheet) === null || a === void 0 ? void 0 : a.sky;
        }
        setSky(a) {
          let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          const _ = this.sky.getSky();
          let h = !1;
          a || _ && (h = !0);
          for (const b in a)
            if (!l.aF(a[b], _[b])) {
              h = !0;
              break;
            }
          if (!h)
            return;
          const p = { now: T.now(), transition: l.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
          this.stylesheet.sky = a, this.sky.setSky(a, f), this.sky.updateTransitions(p);
        }
        _validate(a, f, _, h) {
          let p = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
          return (!p || p.validate !== !1) && Qs(this, a.call(l.x, l.e({ key: f, style: this.serialize(), value: _, styleSpec: l.v }, h)));
        }
        _remove() {
          let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
          this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), Bt().off(mt, this._rtlPluginLoaded);
          for (const f in this._layers)
            this._layers[f].setEventedParent(null);
          for (const f in this.sourceCaches) {
            const _ = this.sourceCaches[f];
            _.setEventedParent(null), _.onRemove(this.map);
          }
          this.imageManager.setEventedParent(null), this.setEventedParent(null), a && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(a);
        }
        _clearSource(a) {
          this.sourceCaches[a].clearTiles();
        }
        _reloadSource(a) {
          this.sourceCaches[a].resume(), this.sourceCaches[a].reload();
        }
        _updateSources(a) {
          for (const f in this.sourceCaches)
            this.sourceCaches[f].update(a, this.map.terrain);
        }
        _generateCollisionBoxes() {
          for (const a in this.sourceCaches)
            this._reloadSource(a);
        }
        _updatePlacement(a, f, _, h) {
          let p = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1, b = !1, x = !1;
          const C = {};
          for (const M of this._order) {
            const R = this._layers[M];
            if (R.type !== "symbol")
              continue;
            if (!C[R.source]) {
              const D = this.sourceCaches[R.source];
              C[R.source] = D.getRenderableIds(!0).map((U) => D.getTileByID(U)).sort((U, W) => W.tileID.overscaledZ - U.tileID.overscaledZ || (U.tileID.isLessThan(W.tileID) ? -1 : 1));
            }
            const O = this.crossTileSymbolIndex.addLayer(R, C[R.source], a.center.lng);
            b = b || O;
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((p = p || this._layerOrderChanged || _ === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(T.now(), a.zoom)) && (this.pauseablePlacement = new xi(a, this.map.terrain, this._order, p, f, _, h, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, C), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(T.now()), x = !0), b && this.pauseablePlacement.placement.setStale()), x || b)
            for (const M of this._order) {
              const R = this._layers[M];
              R.type === "symbol" && this.placement.updateLayerOpacities(R, C[R.source]);
            }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(T.now());
        }
        _releaseSymbolFadeTiles() {
          for (const a in this.sourceCaches)
            this.sourceCaches[a].releaseSymbolFadeTiles();
        }
        getImages(a, f) {
          return l._(this, void 0, void 0, function* () {
            const _ = yield this.imageManager.getImages(f.icons);
            this._updateTilesForChangedImages();
            const h = this.sourceCaches[f.source];
            return h && h.setDependencies(f.tileID.key, f.type, f.icons), _;
          });
        }
        getGlyphs(a, f) {
          return l._(this, void 0, void 0, function* () {
            const _ = yield this.glyphManager.getGlyphs(f.stacks), h = this.sourceCaches[f.source];
            return h && h.setDependencies(f.tileID.key, f.type, [""]), _;
          });
        }
        getGlyphsUrl() {
          return this.stylesheet.glyphs || null;
        }
        setGlyphs(a) {
          let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          this._checkLoaded(), a && this._validate(l.x.glyphs, "glyphs", a, null, f) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = a, this.glyphManager.entries = {}, this.glyphManager.setURL(a));
        }
        addSprite(a, f) {
          let _ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, h = arguments.length > 3 ? arguments[3] : void 0;
          this._checkLoaded();
          const p = [{ id: a, url: f }], b = [...Ve(this.stylesheet.sprite), ...p];
          this._validate(l.x.sprite, "sprite", b, null, _) || (this.stylesheet.sprite = b, this._loadSprite(p, !0, h));
        }
        removeSprite(a) {
          this._checkLoaded();
          const f = Ve(this.stylesheet.sprite);
          if (f.find((_) => _.id === a)) {
            if (this._spritesImagesIds[a])
              for (const _ of this._spritesImagesIds[a])
                this.imageManager.removeImage(_), this._changedImages[_] = !0;
            f.splice(f.findIndex((_) => _.id === a), 1), this.stylesheet.sprite = f.length > 0 ? f : void 0, delete this._spritesImagesIds[a], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new l.k("data", { dataType: "style" }));
          } else
            this.fire(new l.j(new Error(`Sprite "${a}" doesn't exists on this map.`)));
        }
        getSprite() {
          return Ve(this.stylesheet.sprite);
        }
        setSprite(a) {
          let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ = arguments.length > 2 ? arguments[2] : void 0;
          this._checkLoaded(), a && this._validate(l.x.sprite, "sprite", a, null, f) || (this.stylesheet.sprite = a, a ? this._loadSprite(a, !0, _) : (this._unloadSprite(), _ && _(null)));
        }
      }
      var dr = l.Y([{ name: "a_pos", type: "Int16", components: 2 }]);
      const Xr = { prelude: jn(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}`), background: jn(`uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), backgroundPattern: jn(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: jn(`varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: jn("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: jn(`uniform highp float u_intensity;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}`), heatmapTexture: jn(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: jn("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_anchor_pos;attribute vec2 a_placed;attribute vec2 a_box_real;uniform mat4 u_matrix;uniform vec2 u_pixel_extrude_scale;varying float v_placed;varying float v_notUsed;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: jn("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: jn("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}"), fill: jn(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_FragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);}`), fillOutline: jn(`varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), fillOutlinePattern: jn(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), fillPattern: jn(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: jn(`varying vec4 v_color;void main() {gl_FragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: jn(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: jn(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: jn(`uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;
#define PI 3.141592653589793
void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), line: jn(`uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: jn(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: jn(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: jn(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), raster: jn(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: jn(`uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec2 v_tex;varying float v_fade_opacity;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: jn(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec2 v_data0;varying vec3 v_data1;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: jn(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec4 v_data0;varying vec4 v_data1;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: jn("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;varying vec2 v_texture_pos;varying float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture2D(u_texture,v_texture_pos);if (v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);gl_FragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {gl_FragColor=surface_color;}}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform mat4 u_fog_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;varying float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: jn("varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: jn("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);}"), sky: jn("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform float u_horizon;uniform float u_sky_horizon_blend;void main() {float y=gl_FragCoord.y;if (y > u_horizon) {float blend=y-u_horizon;if (blend < u_sky_horizon_blend) {gl_FragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {gl_FragColor=u_sky_color;}}}", "attribute vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
      function jn(E, a) {
        const f = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, _ = a.match(/attribute ([\w]+) ([\w]+)/g), h = E.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), p = a.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), b = p ? p.concat(h) : h, x = {};
        return { fragmentSource: E = E.replace(f, (C, M, R, O, D) => (x[D] = !0, M === "define" ? `
#ifndef HAS_UNIFORM_u_${D}
varying ${R} ${O} ${D};
#else
uniform ${R} ${O} u_${D};
#endif
` : `
#ifdef HAS_UNIFORM_u_${D}
    ${R} ${O} ${D} = u_${D};
#endif
`)), vertexSource: a = a.replace(f, (C, M, R, O, D) => {
          const U = O === "float" ? "vec2" : "vec4", W = D.match(/color/) ? "color" : U;
          return x[D] ? M === "define" ? `
#ifndef HAS_UNIFORM_u_${D}
uniform lowp float u_${D}_t;
attribute ${R} ${U} a_${D};
varying ${R} ${O} ${D};
#else
uniform ${R} ${O} u_${D};
#endif
` : W === "vec4" ? `
#ifndef HAS_UNIFORM_u_${D}
    ${D} = a_${D};
#else
    ${R} ${O} ${D} = u_${D};
#endif
` : `
#ifndef HAS_UNIFORM_u_${D}
    ${D} = unpack_mix_${W}(a_${D}, u_${D}_t);
#else
    ${R} ${O} ${D} = u_${D};
#endif
` : M === "define" ? `
#ifndef HAS_UNIFORM_u_${D}
uniform lowp float u_${D}_t;
attribute ${R} ${U} a_${D};
#else
uniform ${R} ${O} u_${D};
#endif
` : W === "vec4" ? `
#ifndef HAS_UNIFORM_u_${D}
    ${R} ${O} ${D} = a_${D};
#else
    ${R} ${O} ${D} = u_${D};
#endif
` : `
#ifndef HAS_UNIFORM_u_${D}
    ${R} ${O} ${D} = unpack_mix_${W}(a_${D}, u_${D}_t);
#else
    ${R} ${O} ${D} = u_${D};
#endif
`;
        }), staticAttributes: _, staticUniforms: b };
      }
      class Uo {
        constructor() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
        }
        bind(a, f, _, h, p, b, x, C, M) {
          this.context = a;
          let R = this.boundPaintVertexBuffers.length !== h.length;
          for (let O = 0; !R && O < h.length; O++)
            this.boundPaintVertexBuffers[O] !== h[O] && (R = !0);
          !this.vao || this.boundProgram !== f || this.boundLayoutVertexBuffer !== _ || R || this.boundIndexBuffer !== p || this.boundVertexOffset !== b || this.boundDynamicVertexBuffer !== x || this.boundDynamicVertexBuffer2 !== C || this.boundDynamicVertexBuffer3 !== M ? this.freshBind(f, _, h, p, b, x, C, M) : (a.bindVertexArray.set(this.vao), x && x.bind(), p && p.dynamicDraw && p.bind(), C && C.bind(), M && M.bind());
        }
        freshBind(a, f, _, h, p, b, x, C) {
          const M = a.numAttributes, R = this.context, O = R.gl;
          this.vao && this.destroy(), this.vao = R.createVertexArray(), R.bindVertexArray.set(this.vao), this.boundProgram = a, this.boundLayoutVertexBuffer = f, this.boundPaintVertexBuffers = _, this.boundIndexBuffer = h, this.boundVertexOffset = p, this.boundDynamicVertexBuffer = b, this.boundDynamicVertexBuffer2 = x, this.boundDynamicVertexBuffer3 = C, f.enableAttributes(O, a);
          for (const D of _)
            D.enableAttributes(O, a);
          b && b.enableAttributes(O, a), x && x.enableAttributes(O, a), C && C.enableAttributes(O, a), f.bind(), f.setVertexAttribPointers(O, a, p);
          for (const D of _)
            D.bind(), D.setVertexAttribPointers(O, a, p);
          b && (b.bind(), b.setVertexAttribPointers(O, a, p)), h && h.bind(), x && (x.bind(), x.setVertexAttribPointers(O, a, p)), C && (C.bind(), C.setVertexAttribPointers(O, a, p)), R.currentNumAttributes = M;
        }
        destroy() {
          this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
        }
      }
      const ma = (E, a, f, _, h) => ({ u_matrix: E, u_texture: 0, u_ele_delta: a, u_fog_matrix: f, u_fog_color: _ ? _.properties.get("fog-color") : l.aN.white, u_fog_ground_blend: _ ? _.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: _ ? _.calculateFogBlendOpacity(h) : 0, u_horizon_color: _ ? _.properties.get("horizon-color") : l.aN.white, u_horizon_fog_blend: _ ? _.properties.get("horizon-fog-blend") : 1 });
      function jo(E) {
        const a = [];
        for (let f = 0; f < E.length; f++) {
          if (E[f] === null)
            continue;
          const _ = E[f].split(" ");
          a.push(_.pop());
        }
        return a;
      }
      class ue {
        constructor(a, f, _, h, p, b) {
          const x = a.gl;
          this.program = x.createProgram();
          const C = jo(f.staticAttributes), M = _ ? _.getBinderAttributes() : [], R = C.concat(M), O = Xr.prelude.staticUniforms ? jo(Xr.prelude.staticUniforms) : [], D = f.staticUniforms ? jo(f.staticUniforms) : [], U = _ ? _.getBinderUniforms() : [], W = O.concat(D).concat(U), Q = [];
          for (const xe of W)
            Q.indexOf(xe) < 0 && Q.push(xe);
          const Y = _ ? _.defines() : [];
          p && Y.push("#define OVERDRAW_INSPECTOR;"), b && Y.push("#define TERRAIN3D;");
          const K = Y.concat(Xr.prelude.fragmentSource, f.fragmentSource).join(`
`), fe = Y.concat(Xr.prelude.vertexSource, f.vertexSource).join(`
`), ne = x.createShader(x.FRAGMENT_SHADER);
          if (x.isContextLost())
            return void (this.failedToCreate = !0);
          if (x.shaderSource(ne, K), x.compileShader(ne), !x.getShaderParameter(ne, x.COMPILE_STATUS))
            throw new Error(`Could not compile fragment shader: ${x.getShaderInfoLog(ne)}`);
          x.attachShader(this.program, ne);
          const ie = x.createShader(x.VERTEX_SHADER);
          if (x.isContextLost())
            return void (this.failedToCreate = !0);
          if (x.shaderSource(ie, fe), x.compileShader(ie), !x.getShaderParameter(ie, x.COMPILE_STATUS))
            throw new Error(`Could not compile vertex shader: ${x.getShaderInfoLog(ie)}`);
          x.attachShader(this.program, ie), this.attributes = {};
          const le = {};
          this.numAttributes = R.length;
          for (let xe = 0; xe < this.numAttributes; xe++)
            R[xe] && (x.bindAttribLocation(this.program, xe, R[xe]), this.attributes[R[xe]] = xe);
          if (x.linkProgram(this.program), !x.getProgramParameter(this.program, x.LINK_STATUS))
            throw new Error(`Program failed to link: ${x.getProgramInfoLog(this.program)}`);
          x.deleteShader(ie), x.deleteShader(ne);
          for (let xe = 0; xe < Q.length; xe++) {
            const Me = Q[xe];
            if (Me && !le[Me]) {
              const Ne = x.getUniformLocation(this.program, Me);
              Ne && (le[Me] = Ne);
            }
          }
          this.fixedUniforms = h(a, le), this.terrainUniforms = ((xe, Me) => ({ u_depth: new l.aI(xe, Me.u_depth), u_terrain: new l.aI(xe, Me.u_terrain), u_terrain_dim: new l.aJ(xe, Me.u_terrain_dim), u_terrain_matrix: new l.aK(xe, Me.u_terrain_matrix), u_terrain_unpack: new l.aL(xe, Me.u_terrain_unpack), u_terrain_exaggeration: new l.aJ(xe, Me.u_terrain_exaggeration) }))(a, le), this.binderUniforms = _ ? _.getUniforms(a, le) : [];
        }
        draw(a, f, _, h, p, b, x, C, M, R, O, D, U, W, Q, Y, K, fe) {
          const ne = a.gl;
          if (this.failedToCreate)
            return;
          if (a.program.set(this.program), a.setDepthMode(_), a.setStencilMode(h), a.setColorMode(p), a.setCullFace(b), C) {
            a.activeTexture.set(ne.TEXTURE2), ne.bindTexture(ne.TEXTURE_2D, C.depthTexture), a.activeTexture.set(ne.TEXTURE3), ne.bindTexture(ne.TEXTURE_2D, C.texture);
            for (const le in this.terrainUniforms)
              this.terrainUniforms[le].set(C[le]);
          }
          for (const le in this.fixedUniforms)
            this.fixedUniforms[le].set(x[le]);
          Q && Q.setUniforms(a, this.binderUniforms, U, { zoom: W });
          let ie = 0;
          switch (f) {
            case ne.LINES:
              ie = 2;
              break;
            case ne.TRIANGLES:
              ie = 3;
              break;
            case ne.LINE_STRIP:
              ie = 1;
          }
          for (const le of D.get()) {
            const xe = le.vaos || (le.vaos = {});
            (xe[M] || (xe[M] = new Uo())).bind(a, this, R, Q ? Q.getPaintVertexBuffers() : [], O, le.vertexOffset, Y, K, fe), ne.drawElements(f, le.primitiveLength * ie, ne.UNSIGNED_SHORT, le.primitiveOffset * ie * 2);
          }
        }
      }
      function ge(E, a, f) {
        const _ = 1 / an(f, 1, a.transform.tileZoom), h = Math.pow(2, f.tileID.overscaledZ), p = f.tileSize * Math.pow(2, a.transform.tileZoom) / h, b = p * (f.tileID.canonical.x + f.tileID.wrap * h), x = p * f.tileID.canonical.y;
        return { u_image: 0, u_texsize: f.imageAtlasTexture.size, u_scale: [_, E.fromScale, E.toScale], u_fade: E.t, u_pixel_coord_upper: [b >> 16, x >> 16], u_pixel_coord_lower: [65535 & b, 65535 & x] };
      }
      const Re = (E, a, f, _) => {
        const h = a.style.light, p = h.properties.get("position"), b = [p.x, p.y, p.z], x = function() {
          var M = new l.A(9);
          return l.A != Float32Array && (M[1] = 0, M[2] = 0, M[3] = 0, M[5] = 0, M[6] = 0, M[7] = 0), M[0] = 1, M[4] = 1, M[8] = 1, M;
        }();
        h.properties.get("anchor") === "viewport" && function(M, R) {
          var O = Math.sin(R), D = Math.cos(R);
          M[0] = D, M[1] = O, M[2] = 0, M[3] = -O, M[4] = D, M[5] = 0, M[6] = 0, M[7] = 0, M[8] = 1;
        }(x, -a.transform.angle), function(M, R, O) {
          var D = R[0], U = R[1], W = R[2];
          M[0] = D * O[0] + U * O[3] + W * O[6], M[1] = D * O[1] + U * O[4] + W * O[7], M[2] = D * O[2] + U * O[5] + W * O[8];
        }(b, b, x);
        const C = h.properties.get("color");
        return { u_matrix: E, u_lightpos: b, u_lightintensity: h.properties.get("intensity"), u_lightcolor: [C.r, C.g, C.b], u_vertical_gradient: +f, u_opacity: _ };
      }, it = (E, a, f, _, h, p, b) => l.e(Re(E, a, f, _), ge(p, a, b), { u_height_factor: -Math.pow(2, h.overscaledZ) / b.tileSize / 8 }), St = (E) => ({ u_matrix: E }), Wt = (E, a, f, _) => l.e(St(E), ge(f, a, _)), Pn = (E, a) => ({ u_matrix: E, u_world: a }), Fi = (E, a, f, _, h) => l.e(Wt(E, a, f, _), { u_world: h }), Di = (E, a, f, _) => {
        const h = E.transform;
        let p, b;
        if (_.paint.get("circle-pitch-alignment") === "map") {
          const x = an(f, 1, h.zoom);
          p = !0, b = [x, x];
        } else
          p = !1, b = h.pixelsToGLUnits;
        return { u_camera_to_center_distance: h.cameraToCenterDistance, u_scale_with_map: +(_.paint.get("circle-pitch-scale") === "map"), u_matrix: E.translatePosMatrix(a.posMatrix, f, _.paint.get("circle-translate"), _.paint.get("circle-translate-anchor")), u_pitch_with_map: +p, u_device_pixel_ratio: E.pixelRatio, u_extrude_scale: b };
      }, fr = (E, a, f) => ({ u_matrix: E, u_inv_matrix: a, u_camera_to_center_distance: f.cameraToCenterDistance, u_viewport_size: [f.width, f.height] }), ti = function(E, a) {
        let f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
        return { u_matrix: E, u_color: a, u_overlay: 0, u_overlay_scale: f };
      }, Qa = (E) => ({ u_matrix: E }), Nr = (E, a, f, _) => ({ u_matrix: E, u_extrude_scale: an(a, 1, f), u_intensity: _ });
      function yn(E, a) {
        const f = Math.pow(2, a.canonical.z), _ = a.canonical.y;
        return [new l.Z(0, _ / f).toLngLat().lat, new l.Z(0, (_ + 1) / f).toLngLat().lat];
      }
      const el = (E, a, f, _) => {
        const h = E.transform;
        return { u_matrix: tl(E, a, f, _), u_ratio: 1 / an(a, 1, h.zoom), u_device_pixel_ratio: E.pixelRatio, u_units_to_pixels: [1 / h.pixelsToGLUnits[0], 1 / h.pixelsToGLUnits[1]] };
      }, Rl = (E, a, f, _, h) => l.e(el(E, a, f, h), { u_image: 0, u_image_height: _ }), eo = (E, a, f, _, h) => {
        const p = E.transform, b = vo(a, p);
        return { u_matrix: tl(E, a, f, h), u_texsize: a.imageAtlasTexture.size, u_ratio: 1 / an(a, 1, p.zoom), u_device_pixel_ratio: E.pixelRatio, u_image: 0, u_scale: [b, _.fromScale, _.toScale], u_fade: _.t, u_units_to_pixels: [1 / p.pixelsToGLUnits[0], 1 / p.pixelsToGLUnits[1]] };
      }, vc = (E, a, f, _, h, p) => {
        const b = E.lineAtlas, x = vo(a, E.transform), C = f.layout.get("line-cap") === "round", M = b.getDash(_.from, C), R = b.getDash(_.to, C), O = M.width * h.fromScale, D = R.width * h.toScale;
        return l.e(el(E, a, f, p), { u_patternscale_a: [x / O, -M.height / 2], u_patternscale_b: [x / D, -R.height / 2], u_sdfgamma: b.width / (256 * Math.min(O, D) * E.pixelRatio) / 2, u_image: 0, u_tex_y_a: M.y, u_tex_y_b: R.y, u_mix: h.t });
      };
      function vo(E, a) {
        return 1 / an(E, 1, a.tileZoom);
      }
      function tl(E, a, f, _) {
        return E.translatePosMatrix(_ ? _.posMatrix : a.tileID.posMatrix, a, f.paint.get("line-translate"), f.paint.get("line-translate-anchor"));
      }
      const bc = (E, a, f, _, h) => {
        return { u_matrix: E, u_tl_parent: a, u_scale_parent: f, u_buffer_scale: 1, u_fade_t: _.mix, u_opacity: _.opacity * h.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: h.paint.get("raster-brightness-min"), u_brightness_high: h.paint.get("raster-brightness-max"), u_saturation_factor: (b = h.paint.get("raster-saturation"), b > 0 ? 1 - 1 / (1.001 - b) : -b), u_contrast_factor: (p = h.paint.get("raster-contrast"), p > 0 ? 1 / (1 - p) : 1 + p), u_spin_weights: Ku(h.paint.get("raster-hue-rotate")) };
        var p, b;
      };
      function Ku(E) {
        E *= Math.PI / 180;
        const a = Math.sin(E), f = Math.cos(E);
        return [(2 * f + 1) / 3, (-Math.sqrt(3) * a - f + 1) / 3, (Math.sqrt(3) * a - f + 1) / 3];
      }
      const su = (E, a, f, _, h, p, b, x, C, M, R, O, D, U) => {
        const W = b.transform;
        return { u_is_size_zoom_constant: +(E === "constant" || E === "source"), u_is_size_feature_constant: +(E === "constant" || E === "camera"), u_size_t: a ? a.uSizeT : 0, u_size: a ? a.uSize : 0, u_camera_to_center_distance: W.cameraToCenterDistance, u_pitch: W.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +f, u_aspect_ratio: W.width / W.height, u_fade_change: b.options.fadeDuration ? b.symbolFadeChange : 1, u_matrix: x, u_label_plane_matrix: C, u_coord_matrix: M, u_is_text: +O, u_pitch_with_map: +_, u_is_along_line: h, u_is_variable_anchor: p, u_texsize: D, u_texture: 0, u_translation: R, u_pitched_scale: U };
      }, ou = (E, a, f, _, h, p, b, x, C, M, R, O, D, U, W) => {
        const Q = b.transform;
        return l.e(su(E, a, f, _, h, p, b, x, C, M, R, O, D, W), { u_gamma_scale: _ ? Math.cos(Q._pitch) * Q.cameraToCenterDistance : 1, u_device_pixel_ratio: b.pixelRatio, u_is_halo: +U });
      }, xc = (E, a, f, _, h, p, b, x, C, M, R, O, D, U) => l.e(ou(E, a, f, _, h, p, b, x, C, M, R, !0, O, !0, U), { u_texsize_icon: D, u_texture_icon: 1 }), bo = (E, a, f) => ({ u_matrix: E, u_opacity: a, u_color: f }), xo = (E, a, f, _, h, p) => l.e(function(b, x, C, M) {
        const R = C.imageManager.getPattern(b.from.toString()), O = C.imageManager.getPattern(b.to.toString()), { width: D, height: U } = C.imageManager.getPixelSize(), W = Math.pow(2, M.tileID.overscaledZ), Q = M.tileSize * Math.pow(2, C.transform.tileZoom) / W, Y = Q * (M.tileID.canonical.x + M.tileID.wrap * W), K = Q * M.tileID.canonical.y;
        return { u_image: 0, u_pattern_tl_a: R.tl, u_pattern_br_a: R.br, u_pattern_tl_b: O.tl, u_pattern_br_b: O.br, u_texsize: [D, U], u_mix: x.t, u_pattern_size_a: R.displaySize, u_pattern_size_b: O.displaySize, u_scale_a: x.fromScale, u_scale_b: x.toScale, u_tile_units_to_pixels: 1 / an(M, 1, C.transform.tileZoom), u_pixel_coord_upper: [Y >> 16, K >> 16], u_pixel_coord_lower: [65535 & Y, 65535 & K] };
      }(_, p, f, h), { u_matrix: E, u_opacity: a }), Ol = { fillExtrusion: (E, a) => ({ u_matrix: new l.aK(E, a.u_matrix), u_lightpos: new l.aO(E, a.u_lightpos), u_lightintensity: new l.aJ(E, a.u_lightintensity), u_lightcolor: new l.aO(E, a.u_lightcolor), u_vertical_gradient: new l.aJ(E, a.u_vertical_gradient), u_opacity: new l.aJ(E, a.u_opacity) }), fillExtrusionPattern: (E, a) => ({ u_matrix: new l.aK(E, a.u_matrix), u_lightpos: new l.aO(E, a.u_lightpos), u_lightintensity: new l.aJ(E, a.u_lightintensity), u_lightcolor: new l.aO(E, a.u_lightcolor), u_vertical_gradient: new l.aJ(E, a.u_vertical_gradient), u_height_factor: new l.aJ(E, a.u_height_factor), u_image: new l.aI(E, a.u_image), u_texsize: new l.aP(E, a.u_texsize), u_pixel_coord_upper: new l.aP(E, a.u_pixel_coord_upper), u_pixel_coord_lower: new l.aP(E, a.u_pixel_coord_lower), u_scale: new l.aO(E, a.u_scale), u_fade: new l.aJ(E, a.u_fade), u_opacity: new l.aJ(E, a.u_opacity) }), fill: (E, a) => ({ u_matrix: new l.aK(E, a.u_matrix) }), fillPattern: (E, a) => ({ u_matrix: new l.aK(E, a.u_matrix), u_image: new l.aI(E, a.u_image), u_texsize: new l.aP(E, a.u_texsize), u_pixel_coord_upper: new l.aP(E, a.u_pixel_coord_upper), u_pixel_coord_lower: new l.aP(E, a.u_pixel_coord_lower), u_scale: new l.aO(E, a.u_scale), u_fade: new l.aJ(E, a.u_fade) }), fillOutline: (E, a) => ({ u_matrix: new l.aK(E, a.u_matrix), u_world: new l.aP(E, a.u_world) }), fillOutlinePattern: (E, a) => ({ u_matrix: new l.aK(E, a.u_matrix), u_world: new l.aP(E, a.u_world), u_image: new l.aI(E, a.u_image), u_texsize: new l.aP(E, a.u_texsize), u_pixel_coord_upper: new l.aP(E, a.u_pixel_coord_upper), u_pixel_coord_lower: new l.aP(E, a.u_pixel_coord_lower), u_scale: new l.aO(E, a.u_scale), u_fade: new l.aJ(E, a.u_fade) }), circle: (E, a) => ({ u_camera_to_center_distance: new l.aJ(E, a.u_camera_to_center_distance), u_scale_with_map: new l.aI(E, a.u_scale_with_map), u_pitch_with_map: new l.aI(E, a.u_pitch_with_map), u_extrude_scale: new l.aP(E, a.u_extrude_scale), u_device_pixel_ratio: new l.aJ(E, a.u_device_pixel_ratio), u_matrix: new l.aK(E, a.u_matrix) }), collisionBox: (E, a) => ({ u_matrix: new l.aK(E, a.u_matrix), u_pixel_extrude_scale: new l.aP(E, a.u_pixel_extrude_scale) }), collisionCircle: (E, a) => ({ u_matrix: new l.aK(E, a.u_matrix), u_inv_matrix: new l.aK(E, a.u_inv_matrix), u_camera_to_center_distance: new l.aJ(E, a.u_camera_to_center_distance), u_viewport_size: new l.aP(E, a.u_viewport_size) }), debug: (E, a) => ({ u_color: new l.aM(E, a.u_color), u_matrix: new l.aK(E, a.u_matrix), u_overlay: new l.aI(E, a.u_overlay), u_overlay_scale: new l.aJ(E, a.u_overlay_scale) }), clippingMask: (E, a) => ({ u_matrix: new l.aK(E, a.u_matrix) }), heatmap: (E, a) => ({ u_extrude_scale: new l.aJ(E, a.u_extrude_scale), u_intensity: new l.aJ(E, a.u_intensity), u_matrix: new l.aK(E, a.u_matrix) }), heatmapTexture: (E, a) => ({ u_matrix: new l.aK(E, a.u_matrix), u_world: new l.aP(E, a.u_world), u_image: new l.aI(E, a.u_image), u_color_ramp: new l.aI(E, a.u_color_ramp), u_opacity: new l.aJ(E, a.u_opacity) }), hillshade: (E, a) => ({ u_matrix: new l.aK(E, a.u_matrix), u_image: new l.aI(E, a.u_image), u_latrange: new l.aP(E, a.u_latrange), u_light: new l.aP(E, a.u_light), u_shadow: new l.aM(E, a.u_shadow), u_highlight: new l.aM(E, a.u_highlight), u_accent: new l.aM(E, a.u_accent) }), hillshadePrepare: (E, a) => ({ u_matrix: new l.aK(E, a.u_matrix), u_image: new l.aI(E, a.u_image), u_dimension: new l.aP(E, a.u_dimension), u_zoom: new l.aJ(E, a.u_zoom), u_unpack: new l.aL(E, a.u_unpack) }), line: (E, a) => ({ u_matrix: new l.aK(E, a.u_matrix), u_ratio: new l.aJ(E, a.u_ratio), u_device_pixel_ratio: new l.aJ(E, a.u_device_pixel_ratio), u_units_to_pixels: new l.aP(E, a.u_units_to_pixels) }), lineGradient: (E, a) => ({ u_matrix: new l.aK(E, a.u_matrix), u_ratio: new l.aJ(E, a.u_ratio), u_device_pixel_ratio: new l.aJ(E, a.u_device_pixel_ratio), u_units_to_pixels: new l.aP(E, a.u_units_to_pixels), u_image: new l.aI(E, a.u_image), u_image_height: new l.aJ(E, a.u_image_height) }), linePattern: (E, a) => ({ u_matrix: new l.aK(E, a.u_matrix), u_texsize: new l.aP(E, a.u_texsize), u_ratio: new l.aJ(E, a.u_ratio), u_device_pixel_ratio: new l.aJ(E, a.u_device_pixel_ratio), u_image: new l.aI(E, a.u_image), u_units_to_pixels: new l.aP(E, a.u_units_to_pixels), u_scale: new l.aO(E, a.u_scale), u_fade: new l.aJ(E, a.u_fade) }), lineSDF: (E, a) => ({ u_matrix: new l.aK(E, a.u_matrix), u_ratio: new l.aJ(E, a.u_ratio), u_device_pixel_ratio: new l.aJ(E, a.u_device_pixel_ratio), u_units_to_pixels: new l.aP(E, a.u_units_to_pixels), u_patternscale_a: new l.aP(E, a.u_patternscale_a), u_patternscale_b: new l.aP(E, a.u_patternscale_b), u_sdfgamma: new l.aJ(E, a.u_sdfgamma), u_image: new l.aI(E, a.u_image), u_tex_y_a: new l.aJ(E, a.u_tex_y_a), u_tex_y_b: new l.aJ(E, a.u_tex_y_b), u_mix: new l.aJ(E, a.u_mix) }), raster: (E, a) => ({ u_matrix: new l.aK(E, a.u_matrix), u_tl_parent: new l.aP(E, a.u_tl_parent), u_scale_parent: new l.aJ(E, a.u_scale_parent), u_buffer_scale: new l.aJ(E, a.u_buffer_scale), u_fade_t: new l.aJ(E, a.u_fade_t), u_opacity: new l.aJ(E, a.u_opacity), u_image0: new l.aI(E, a.u_image0), u_image1: new l.aI(E, a.u_image1), u_brightness_low: new l.aJ(E, a.u_brightness_low), u_brightness_high: new l.aJ(E, a.u_brightness_high), u_saturation_factor: new l.aJ(E, a.u_saturation_factor), u_contrast_factor: new l.aJ(E, a.u_contrast_factor), u_spin_weights: new l.aO(E, a.u_spin_weights) }), symbolIcon: (E, a) => ({ u_is_size_zoom_constant: new l.aI(E, a.u_is_size_zoom_constant), u_is_size_feature_constant: new l.aI(E, a.u_is_size_feature_constant), u_size_t: new l.aJ(E, a.u_size_t), u_size: new l.aJ(E, a.u_size), u_camera_to_center_distance: new l.aJ(E, a.u_camera_to_center_distance), u_pitch: new l.aJ(E, a.u_pitch), u_rotate_symbol: new l.aI(E, a.u_rotate_symbol), u_aspect_ratio: new l.aJ(E, a.u_aspect_ratio), u_fade_change: new l.aJ(E, a.u_fade_change), u_matrix: new l.aK(E, a.u_matrix), u_label_plane_matrix: new l.aK(E, a.u_label_plane_matrix), u_coord_matrix: new l.aK(E, a.u_coord_matrix), u_is_text: new l.aI(E, a.u_is_text), u_pitch_with_map: new l.aI(E, a.u_pitch_with_map), u_is_along_line: new l.aI(E, a.u_is_along_line), u_is_variable_anchor: new l.aI(E, a.u_is_variable_anchor), u_texsize: new l.aP(E, a.u_texsize), u_texture: new l.aI(E, a.u_texture), u_translation: new l.aP(E, a.u_translation), u_pitched_scale: new l.aJ(E, a.u_pitched_scale) }), symbolSDF: (E, a) => ({ u_is_size_zoom_constant: new l.aI(E, a.u_is_size_zoom_constant), u_is_size_feature_constant: new l.aI(E, a.u_is_size_feature_constant), u_size_t: new l.aJ(E, a.u_size_t), u_size: new l.aJ(E, a.u_size), u_camera_to_center_distance: new l.aJ(E, a.u_camera_to_center_distance), u_pitch: new l.aJ(E, a.u_pitch), u_rotate_symbol: new l.aI(E, a.u_rotate_symbol), u_aspect_ratio: new l.aJ(E, a.u_aspect_ratio), u_fade_change: new l.aJ(E, a.u_fade_change), u_matrix: new l.aK(E, a.u_matrix), u_label_plane_matrix: new l.aK(E, a.u_label_plane_matrix), u_coord_matrix: new l.aK(E, a.u_coord_matrix), u_is_text: new l.aI(E, a.u_is_text), u_pitch_with_map: new l.aI(E, a.u_pitch_with_map), u_is_along_line: new l.aI(E, a.u_is_along_line), u_is_variable_anchor: new l.aI(E, a.u_is_variable_anchor), u_texsize: new l.aP(E, a.u_texsize), u_texture: new l.aI(E, a.u_texture), u_gamma_scale: new l.aJ(E, a.u_gamma_scale), u_device_pixel_ratio: new l.aJ(E, a.u_device_pixel_ratio), u_is_halo: new l.aI(E, a.u_is_halo), u_translation: new l.aP(E, a.u_translation), u_pitched_scale: new l.aJ(E, a.u_pitched_scale) }), symbolTextAndIcon: (E, a) => ({ u_is_size_zoom_constant: new l.aI(E, a.u_is_size_zoom_constant), u_is_size_feature_constant: new l.aI(E, a.u_is_size_feature_constant), u_size_t: new l.aJ(E, a.u_size_t), u_size: new l.aJ(E, a.u_size), u_camera_to_center_distance: new l.aJ(E, a.u_camera_to_center_distance), u_pitch: new l.aJ(E, a.u_pitch), u_rotate_symbol: new l.aI(E, a.u_rotate_symbol), u_aspect_ratio: new l.aJ(E, a.u_aspect_ratio), u_fade_change: new l.aJ(E, a.u_fade_change), u_matrix: new l.aK(E, a.u_matrix), u_label_plane_matrix: new l.aK(E, a.u_label_plane_matrix), u_coord_matrix: new l.aK(E, a.u_coord_matrix), u_is_text: new l.aI(E, a.u_is_text), u_pitch_with_map: new l.aI(E, a.u_pitch_with_map), u_is_along_line: new l.aI(E, a.u_is_along_line), u_is_variable_anchor: new l.aI(E, a.u_is_variable_anchor), u_texsize: new l.aP(E, a.u_texsize), u_texsize_icon: new l.aP(E, a.u_texsize_icon), u_texture: new l.aI(E, a.u_texture), u_texture_icon: new l.aI(E, a.u_texture_icon), u_gamma_scale: new l.aJ(E, a.u_gamma_scale), u_device_pixel_ratio: new l.aJ(E, a.u_device_pixel_ratio), u_is_halo: new l.aI(E, a.u_is_halo), u_translation: new l.aP(E, a.u_translation), u_pitched_scale: new l.aJ(E, a.u_pitched_scale) }), background: (E, a) => ({ u_matrix: new l.aK(E, a.u_matrix), u_opacity: new l.aJ(E, a.u_opacity), u_color: new l.aM(E, a.u_color) }), backgroundPattern: (E, a) => ({ u_matrix: new l.aK(E, a.u_matrix), u_opacity: new l.aJ(E, a.u_opacity), u_image: new l.aI(E, a.u_image), u_pattern_tl_a: new l.aP(E, a.u_pattern_tl_a), u_pattern_br_a: new l.aP(E, a.u_pattern_br_a), u_pattern_tl_b: new l.aP(E, a.u_pattern_tl_b), u_pattern_br_b: new l.aP(E, a.u_pattern_br_b), u_texsize: new l.aP(E, a.u_texsize), u_mix: new l.aJ(E, a.u_mix), u_pattern_size_a: new l.aP(E, a.u_pattern_size_a), u_pattern_size_b: new l.aP(E, a.u_pattern_size_b), u_scale_a: new l.aJ(E, a.u_scale_a), u_scale_b: new l.aJ(E, a.u_scale_b), u_pixel_coord_upper: new l.aP(E, a.u_pixel_coord_upper), u_pixel_coord_lower: new l.aP(E, a.u_pixel_coord_lower), u_tile_units_to_pixels: new l.aJ(E, a.u_tile_units_to_pixels) }), terrain: (E, a) => ({ u_matrix: new l.aK(E, a.u_matrix), u_texture: new l.aI(E, a.u_texture), u_ele_delta: new l.aJ(E, a.u_ele_delta), u_fog_matrix: new l.aK(E, a.u_fog_matrix), u_fog_color: new l.aM(E, a.u_fog_color), u_fog_ground_blend: new l.aJ(E, a.u_fog_ground_blend), u_fog_ground_blend_opacity: new l.aJ(E, a.u_fog_ground_blend_opacity), u_horizon_color: new l.aM(E, a.u_horizon_color), u_horizon_fog_blend: new l.aJ(E, a.u_horizon_fog_blend) }), terrainDepth: (E, a) => ({ u_matrix: new l.aK(E, a.u_matrix), u_ele_delta: new l.aJ(E, a.u_ele_delta) }), terrainCoords: (E, a) => ({ u_matrix: new l.aK(E, a.u_matrix), u_texture: new l.aI(E, a.u_texture), u_terrain_coords_id: new l.aJ(E, a.u_terrain_coords_id), u_ele_delta: new l.aJ(E, a.u_ele_delta) }), sky: (E, a) => ({ u_sky_color: new l.aM(E, a.u_sky_color), u_horizon_color: new l.aM(E, a.u_horizon_color), u_horizon: new l.aJ(E, a.u_horizon), u_sky_horizon_blend: new l.aJ(E, a.u_sky_horizon_blend) }) };
      class Go {
        constructor(a, f, _) {
          this.context = a;
          const h = a.gl;
          this.buffer = h.createBuffer(), this.dynamicDraw = !!_, this.context.unbindVAO(), a.bindElementBuffer.set(this.buffer), h.bufferData(h.ELEMENT_ARRAY_BUFFER, f.arrayBuffer, this.dynamicDraw ? h.DYNAMIC_DRAW : h.STATIC_DRAW), this.dynamicDraw || delete f.arrayBuffer;
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(a) {
          const f = this.context.gl;
          if (!this.dynamicDraw)
            throw new Error("Attempted to update data while not in dynamic mode.");
          this.context.unbindVAO(), this.bind(), f.bufferSubData(f.ELEMENT_ARRAY_BUFFER, 0, a.arrayBuffer);
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const nl = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
      class Jr {
        constructor(a, f, _, h) {
          this.length = f.length, this.attributes = _, this.itemSize = f.bytesPerElement, this.dynamicDraw = h, this.context = a;
          const p = a.gl;
          this.buffer = p.createBuffer(), a.bindVertexBuffer.set(this.buffer), p.bufferData(p.ARRAY_BUFFER, f.arrayBuffer, this.dynamicDraw ? p.DYNAMIC_DRAW : p.STATIC_DRAW), this.dynamicDraw || delete f.arrayBuffer;
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(a) {
          if (a.length !== this.length)
            throw new Error(`Length of new data is ${a.length}, which doesn't match current length of ${this.length}`);
          const f = this.context.gl;
          this.bind(), f.bufferSubData(f.ARRAY_BUFFER, 0, a.arrayBuffer);
        }
        enableAttributes(a, f) {
          for (let _ = 0; _ < this.attributes.length; _++) {
            const h = f.attributes[this.attributes[_].name];
            h !== void 0 && a.enableVertexAttribArray(h);
          }
        }
        setVertexAttribPointers(a, f, _) {
          for (let h = 0; h < this.attributes.length; h++) {
            const p = this.attributes[h], b = f.attributes[p.name];
            b !== void 0 && a.vertexAttribPointer(b, p.components, a[nl[p.type]], !1, this.itemSize, p.offset + this.itemSize * (_ || 0));
          }
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const Fl = /* @__PURE__ */ new WeakMap();
      function Vo(E) {
        var a;
        if (Fl.has(E))
          return Fl.get(E);
        {
          const f = (a = E.getParameter(E.VERSION)) === null || a === void 0 ? void 0 : a.startsWith("WebGL 2.0");
          return Fl.set(E, f), f;
        }
      }
      class Hn {
        constructor(a) {
          this.gl = a.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
        }
        get() {
          return this.current;
        }
        set(a) {
        }
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }
      class _a extends Hn {
        getDefault() {
          return l.aN.transparent;
        }
        set(a) {
          const f = this.current;
          (a.r !== f.r || a.g !== f.g || a.b !== f.b || a.a !== f.a || this.dirty) && (this.gl.clearColor(a.r, a.g, a.b, a.a), this.current = a, this.dirty = !1);
        }
      }
      class qo extends Hn {
        getDefault() {
          return 1;
        }
        set(a) {
          (a !== this.current || this.dirty) && (this.gl.clearDepth(a), this.current = a, this.dirty = !1);
        }
      }
      class to extends Hn {
        getDefault() {
          return 0;
        }
        set(a) {
          (a !== this.current || this.dirty) && (this.gl.clearStencil(a), this.current = a, this.dirty = !1);
        }
      }
      class Qu extends Hn {
        getDefault() {
          return [!0, !0, !0, !0];
        }
        set(a) {
          const f = this.current;
          (a[0] !== f[0] || a[1] !== f[1] || a[2] !== f[2] || a[3] !== f[3] || this.dirty) && (this.gl.colorMask(a[0], a[1], a[2], a[3]), this.current = a, this.dirty = !1);
        }
      }
      class ys extends Hn {
        getDefault() {
          return !0;
        }
        set(a) {
          (a !== this.current || this.dirty) && (this.gl.depthMask(a), this.current = a, this.dirty = !1);
        }
      }
      class no extends Hn {
        getDefault() {
          return 255;
        }
        set(a) {
          (a !== this.current || this.dirty) && (this.gl.stencilMask(a), this.current = a, this.dirty = !1);
        }
      }
      class Dl extends Hn {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(a) {
          const f = this.current;
          (a.func !== f.func || a.ref !== f.ref || a.mask !== f.mask || this.dirty) && (this.gl.stencilFunc(a.func, a.ref, a.mask), this.current = a, this.dirty = !1);
        }
      }
      class il extends Hn {
        getDefault() {
          const a = this.gl;
          return [a.KEEP, a.KEEP, a.KEEP];
        }
        set(a) {
          const f = this.current;
          (a[0] !== f[0] || a[1] !== f[1] || a[2] !== f[2] || this.dirty) && (this.gl.stencilOp(a[0], a[1], a[2]), this.current = a, this.dirty = !1);
        }
      }
      class au extends Hn {
        getDefault() {
          return !1;
        }
        set(a) {
          if (a === this.current && !this.dirty)
            return;
          const f = this.gl;
          a ? f.enable(f.STENCIL_TEST) : f.disable(f.STENCIL_TEST), this.current = a, this.dirty = !1;
        }
      }
      class ya extends Hn {
        getDefault() {
          return [0, 1];
        }
        set(a) {
          const f = this.current;
          (a[0] !== f[0] || a[1] !== f[1] || this.dirty) && (this.gl.depthRange(a[0], a[1]), this.current = a, this.dirty = !1);
        }
      }
      class lu extends Hn {
        getDefault() {
          return !1;
        }
        set(a) {
          if (a === this.current && !this.dirty)
            return;
          const f = this.gl;
          a ? f.enable(f.DEPTH_TEST) : f.disable(f.DEPTH_TEST), this.current = a, this.dirty = !1;
        }
      }
      class kl extends Hn {
        getDefault() {
          return this.gl.LESS;
        }
        set(a) {
          (a !== this.current || this.dirty) && (this.gl.depthFunc(a), this.current = a, this.dirty = !1);
        }
      }
      class Nl extends Hn {
        getDefault() {
          return !1;
        }
        set(a) {
          if (a === this.current && !this.dirty)
            return;
          const f = this.gl;
          a ? f.enable(f.BLEND) : f.disable(f.BLEND), this.current = a, this.dirty = !1;
        }
      }
      class wc extends Hn {
        getDefault() {
          const a = this.gl;
          return [a.ONE, a.ZERO];
        }
        set(a) {
          const f = this.current;
          (a[0] !== f[0] || a[1] !== f[1] || this.dirty) && (this.gl.blendFunc(a[0], a[1]), this.current = a, this.dirty = !1);
        }
      }
      class Ps extends Hn {
        getDefault() {
          return l.aN.transparent;
        }
        set(a) {
          const f = this.current;
          (a.r !== f.r || a.g !== f.g || a.b !== f.b || a.a !== f.a || this.dirty) && (this.gl.blendColor(a.r, a.g, a.b, a.a), this.current = a, this.dirty = !1);
        }
      }
      class zl extends Hn {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(a) {
          (a !== this.current || this.dirty) && (this.gl.blendEquation(a), this.current = a, this.dirty = !1);
        }
      }
      class Ac extends Hn {
        getDefault() {
          return !1;
        }
        set(a) {
          if (a === this.current && !this.dirty)
            return;
          const f = this.gl;
          a ? f.enable(f.CULL_FACE) : f.disable(f.CULL_FACE), this.current = a, this.dirty = !1;
        }
      }
      class cu extends Hn {
        getDefault() {
          return this.gl.BACK;
        }
        set(a) {
          (a !== this.current || this.dirty) && (this.gl.cullFace(a), this.current = a, this.dirty = !1);
        }
      }
      class uu extends Hn {
        getDefault() {
          return this.gl.CCW;
        }
        set(a) {
          (a !== this.current || this.dirty) && (this.gl.frontFace(a), this.current = a, this.dirty = !1);
        }
      }
      class wo extends Hn {
        getDefault() {
          return null;
        }
        set(a) {
          (a !== this.current || this.dirty) && (this.gl.useProgram(a), this.current = a, this.dirty = !1);
        }
      }
      class rl extends Hn {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(a) {
          (a !== this.current || this.dirty) && (this.gl.activeTexture(a), this.current = a, this.dirty = !1);
        }
      }
      class va extends Hn {
        getDefault() {
          const a = this.gl;
          return [0, 0, a.drawingBufferWidth, a.drawingBufferHeight];
        }
        set(a) {
          const f = this.current;
          (a[0] !== f[0] || a[1] !== f[1] || a[2] !== f[2] || a[3] !== f[3] || this.dirty) && (this.gl.viewport(a[0], a[1], a[2], a[3]), this.current = a, this.dirty = !1);
        }
      }
      class ba extends Hn {
        getDefault() {
          return null;
        }
        set(a) {
          if (a === this.current && !this.dirty)
            return;
          const f = this.gl;
          f.bindFramebuffer(f.FRAMEBUFFER, a), this.current = a, this.dirty = !1;
        }
      }
      class Ec extends Hn {
        getDefault() {
          return null;
        }
        set(a) {
          if (a === this.current && !this.dirty)
            return;
          const f = this.gl;
          f.bindRenderbuffer(f.RENDERBUFFER, a), this.current = a, this.dirty = !1;
        }
      }
      class F extends Hn {
        getDefault() {
          return null;
        }
        set(a) {
          if (a === this.current && !this.dirty)
            return;
          const f = this.gl;
          f.bindTexture(f.TEXTURE_2D, a), this.current = a, this.dirty = !1;
        }
      }
      class te extends Hn {
        getDefault() {
          return null;
        }
        set(a) {
          if (a === this.current && !this.dirty)
            return;
          const f = this.gl;
          f.bindBuffer(f.ARRAY_BUFFER, a), this.current = a, this.dirty = !1;
        }
      }
      class Ee extends Hn {
        getDefault() {
          return null;
        }
        set(a) {
          const f = this.gl;
          f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, a), this.current = a, this.dirty = !1;
        }
      }
      class ze extends Hn {
        getDefault() {
          return null;
        }
        set(a) {
          var f;
          if (a === this.current && !this.dirty)
            return;
          const _ = this.gl;
          Vo(_) ? _.bindVertexArray(a) : (f = _.getExtension("OES_vertex_array_object")) === null || f === void 0 || f.bindVertexArrayOES(a), this.current = a, this.dirty = !1;
        }
      }
      class Je extends Hn {
        getDefault() {
          return 4;
        }
        set(a) {
          if (a === this.current && !this.dirty)
            return;
          const f = this.gl;
          f.pixelStorei(f.UNPACK_ALIGNMENT, a), this.current = a, this.dirty = !1;
        }
      }
      class dt extends Hn {
        getDefault() {
          return !1;
        }
        set(a) {
          if (a === this.current && !this.dirty)
            return;
          const f = this.gl;
          f.pixelStorei(f.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a), this.current = a, this.dirty = !1;
        }
      }
      class Tt extends Hn {
        getDefault() {
          return !1;
        }
        set(a) {
          if (a === this.current && !this.dirty)
            return;
          const f = this.gl;
          f.pixelStorei(f.UNPACK_FLIP_Y_WEBGL, a), this.current = a, this.dirty = !1;
        }
      }
      class Xt extends Hn {
        constructor(a, f) {
          super(a), this.context = a, this.parent = f;
        }
        getDefault() {
          return null;
        }
      }
      class vn extends Xt {
        setDirty() {
          this.dirty = !0;
        }
        set(a) {
          if (a === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const f = this.gl;
          f.framebufferTexture2D(f.FRAMEBUFFER, f.COLOR_ATTACHMENT0, f.TEXTURE_2D, a, 0), this.current = a, this.dirty = !1;
        }
      }
      class Ln extends Xt {
        set(a) {
          if (a === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const f = this.gl;
          f.framebufferRenderbuffer(f.FRAMEBUFFER, f.DEPTH_ATTACHMENT, f.RENDERBUFFER, a), this.current = a, this.dirty = !1;
        }
      }
      class zn extends Xt {
        set(a) {
          if (a === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const f = this.gl;
          f.framebufferRenderbuffer(f.FRAMEBUFFER, f.DEPTH_STENCIL_ATTACHMENT, f.RENDERBUFFER, a), this.current = a, this.dirty = !1;
        }
      }
      class $n {
        constructor(a, f, _, h, p) {
          this.context = a, this.width = f, this.height = _;
          const b = a.gl, x = this.framebuffer = b.createFramebuffer();
          if (this.colorAttachment = new vn(a, x), h)
            this.depthAttachment = p ? new zn(a, x) : new Ln(a, x);
          else if (p)
            throw new Error("Stencil cannot be set without depth");
          if (b.checkFramebufferStatus(b.FRAMEBUFFER) !== b.FRAMEBUFFER_COMPLETE)
            throw new Error("Framebuffer is not complete");
        }
        destroy() {
          const a = this.context.gl, f = this.colorAttachment.get();
          if (f && a.deleteTexture(f), this.depthAttachment) {
            const _ = this.depthAttachment.get();
            _ && a.deleteRenderbuffer(_);
          }
          a.deleteFramebuffer(this.framebuffer);
        }
      }
      class In {
        constructor(a, f, _) {
          this.blendFunction = a, this.blendColor = f, this.mask = _;
        }
      }
      In.Replace = [1, 0], In.disabled = new In(In.Replace, l.aN.transparent, [!1, !1, !1, !1]), In.unblended = new In(In.Replace, l.aN.transparent, [!0, !0, !0, !0]), In.alphaBlended = new In([1, 771], l.aN.transparent, [!0, !0, !0, !0]);
      class $i {
        constructor(a) {
          var f, _;
          if (this.gl = a, this.clearColor = new _a(this), this.clearDepth = new qo(this), this.clearStencil = new to(this), this.colorMask = new Qu(this), this.depthMask = new ys(this), this.stencilMask = new no(this), this.stencilFunc = new Dl(this), this.stencilOp = new il(this), this.stencilTest = new au(this), this.depthRange = new ya(this), this.depthTest = new lu(this), this.depthFunc = new kl(this), this.blend = new Nl(this), this.blendFunc = new wc(this), this.blendColor = new Ps(this), this.blendEquation = new zl(this), this.cullFace = new Ac(this), this.cullFaceSide = new cu(this), this.frontFace = new uu(this), this.program = new wo(this), this.activeTexture = new rl(this), this.viewport = new va(this), this.bindFramebuffer = new ba(this), this.bindRenderbuffer = new Ec(this), this.bindTexture = new F(this), this.bindVertexBuffer = new te(this), this.bindElementBuffer = new Ee(this), this.bindVertexArray = new ze(this), this.pixelStoreUnpack = new Je(this), this.pixelStoreUnpackPremultiplyAlpha = new dt(this), this.pixelStoreUnpackFlipY = new Tt(this), this.extTextureFilterAnisotropic = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = a.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE), Vo(a)) {
            this.HALF_FLOAT = a.HALF_FLOAT;
            const h = a.getExtension("EXT_color_buffer_half_float");
            this.RGBA16F = (f = a.RGBA16F) !== null && f !== void 0 ? f : h == null ? void 0 : h.RGBA16F_EXT, this.RGB16F = (_ = a.RGB16F) !== null && _ !== void 0 ? _ : h == null ? void 0 : h.RGB16F_EXT, a.getExtension("EXT_color_buffer_float");
          } else {
            a.getExtension("EXT_color_buffer_half_float"), a.getExtension("OES_texture_half_float_linear");
            const h = a.getExtension("OES_texture_half_float");
            this.HALF_FLOAT = h == null ? void 0 : h.HALF_FLOAT_OES;
          }
        }
        setDefault() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
        }
        createIndexBuffer(a, f) {
          return new Go(this, a, f);
        }
        createVertexBuffer(a, f, _) {
          return new Jr(this, a, f, _);
        }
        createRenderbuffer(a, f, _) {
          const h = this.gl, p = h.createRenderbuffer();
          return this.bindRenderbuffer.set(p), h.renderbufferStorage(h.RENDERBUFFER, a, f, _), this.bindRenderbuffer.set(null), p;
        }
        createFramebuffer(a, f, _, h) {
          return new $n(this, a, f, _, h);
        }
        clear(a) {
          let { color: f, depth: _, stencil: h } = a;
          const p = this.gl;
          let b = 0;
          f && (b |= p.COLOR_BUFFER_BIT, this.clearColor.set(f), this.colorMask.set([!0, !0, !0, !0])), _ !== void 0 && (b |= p.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(_), this.depthMask.set(!0)), h !== void 0 && (b |= p.STENCIL_BUFFER_BIT, this.clearStencil.set(h), this.stencilMask.set(255)), p.clear(b);
        }
        setCullFace(a) {
          a.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(a.mode), this.frontFace.set(a.frontFace));
        }
        setDepthMode(a) {
          a.func !== this.gl.ALWAYS || a.mask ? (this.depthTest.set(!0), this.depthFunc.set(a.func), this.depthMask.set(a.mask), this.depthRange.set(a.range)) : this.depthTest.set(!1);
        }
        setStencilMode(a) {
          a.test.func !== this.gl.ALWAYS || a.mask ? (this.stencilTest.set(!0), this.stencilMask.set(a.mask), this.stencilOp.set([a.fail, a.depthFail, a.pass]), this.stencilFunc.set({ func: a.test.func, ref: a.ref, mask: a.test.mask })) : this.stencilTest.set(!1);
        }
        setColorMode(a) {
          l.aF(a.blendFunction, In.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(a.blendFunction), this.blendColor.set(a.blendColor)), this.colorMask.set(a.mask);
        }
        createVertexArray() {
          var a;
          return Vo(this.gl) ? this.gl.createVertexArray() : (a = this.gl.getExtension("OES_vertex_array_object")) === null || a === void 0 ? void 0 : a.createVertexArrayOES();
        }
        deleteVertexArray(a) {
          var f;
          return Vo(this.gl) ? this.gl.deleteVertexArray(a) : (f = this.gl.getExtension("OES_vertex_array_object")) === null || f === void 0 ? void 0 : f.deleteVertexArrayOES(a);
        }
        unbindVAO() {
          this.bindVertexArray.set(null);
        }
      }
      class fn {
        constructor(a, f, _) {
          this.func = a, this.mask = f, this.range = _;
        }
      }
      fn.ReadOnly = !1, fn.ReadWrite = !0, fn.disabled = new fn(519, fn.ReadOnly, [0, 1]);
      const xr = 7680;
      class kn {
        constructor(a, f, _, h, p, b) {
          this.test = a, this.ref = f, this.mask = _, this.fail = h, this.depthFail = p, this.pass = b;
        }
      }
      kn.disabled = new kn({ func: 519, mask: 0 }, 0, 0, xr, xr, xr);
      class Zn {
        constructor(a, f, _) {
          this.enable = a, this.mode = f, this.frontFace = _;
        }
      }
      let zr;
      function Ao(E, a, f, _, h) {
        const p = E.context, b = p.gl, x = E.useProgram("collisionBox"), C = [];
        let M = 0, R = 0;
        for (let K = 0; K < _.length; K++) {
          const fe = _[K], ne = a.getTile(fe).getBucket(f);
          if (!ne)
            continue;
          const ie = h ? ne.textCollisionBox : ne.iconCollisionBox, le = ne.collisionCircleArray;
          if (le.length > 0) {
            const xe = l.H();
            l.aR(xe, ne.placementInvProjMatrix, E.transform.glCoordMatrix), l.aR(xe, xe, ne.placementViewportMatrix), C.push({ circleArray: le, circleOffset: R, transform: fe.posMatrix, invTransform: xe, coord: fe }), M += le.length / 4, R = M;
          }
          ie && x.draw(p, b.LINES, fn.disabled, kn.disabled, E.colorModeForRenderPass(), Zn.disabled, { u_matrix: fe.posMatrix, u_pixel_extrude_scale: [1 / (O = E.transform).width, 1 / O.height] }, E.style.map.terrain && E.style.map.terrain.getTerrainData(fe), f.id, ie.layoutVertexBuffer, ie.indexBuffer, ie.segments, null, E.transform.zoom, null, null, ie.collisionVertexBuffer);
        }
        var O;
        if (!h || !C.length)
          return;
        const D = E.useProgram("collisionCircle"), U = new l.aS();
        U.resize(4 * M), U._trim();
        let W = 0;
        for (const K of C)
          for (let fe = 0; fe < K.circleArray.length / 4; fe++) {
            const ne = 4 * fe, ie = K.circleArray[ne + 0], le = K.circleArray[ne + 1], xe = K.circleArray[ne + 2], Me = K.circleArray[ne + 3];
            U.emplace(W++, ie, le, xe, Me, 0), U.emplace(W++, ie, le, xe, Me, 1), U.emplace(W++, ie, le, xe, Me, 2), U.emplace(W++, ie, le, xe, Me, 3);
          }
        (!zr || zr.length < 2 * M) && (zr = function(K) {
          const fe = 2 * K, ne = new l.aU();
          ne.resize(fe), ne._trim();
          for (let ie = 0; ie < fe; ie++) {
            const le = 6 * ie;
            ne.uint16[le + 0] = 4 * ie + 0, ne.uint16[le + 1] = 4 * ie + 1, ne.uint16[le + 2] = 4 * ie + 2, ne.uint16[le + 3] = 4 * ie + 2, ne.uint16[le + 4] = 4 * ie + 3, ne.uint16[le + 5] = 4 * ie + 0;
          }
          return ne;
        }(M));
        const Q = p.createIndexBuffer(zr, !0), Y = p.createVertexBuffer(U, l.aT.members, !0);
        for (const K of C) {
          const fe = fr(K.transform, K.invTransform, E.transform);
          D.draw(p, b.TRIANGLES, fn.disabled, kn.disabled, E.colorModeForRenderPass(), Zn.disabled, fe, E.style.map.terrain && E.style.map.terrain.getTerrainData(K.coord), f.id, Y, Q, l.a0.simpleSegment(0, 2 * K.circleOffset, K.circleArray.length, K.circleArray.length / 2), null, E.transform.zoom, null, null, null);
        }
        Y.destroy(), Q.destroy();
      }
      Zn.disabled = new Zn(!1, 1029, 2305), Zn.backCCW = new Zn(!0, 1029, 2305);
      const Ul = l.ao(new Float32Array(16));
      function xa(E, a, f, _, h, p) {
        const { horizontalAlign: b, verticalAlign: x } = l.av(E);
        return new l.P((-(b - 0.5) * a / h + _[0]) * p, (-(x - 0.5) * f / h + _[1]) * p);
      }
      function wa(E, a, f, _, h, p) {
        const b = a.tileAnchorPoint.add(new l.P(a.translation[0], a.translation[1]));
        if (a.pitchWithMap) {
          let x = _.mult(p);
          return f || (x = x.rotate(-h)), ve(b.add(x), a.labelPlaneMatrix, a.getElevation).point;
        }
        if (f) {
          const x = nt(a.tileAnchorPoint.x + 1, a.tileAnchorPoint.y, a).point.sub(E), C = Math.atan(x.y / x.x) + (x.x < 0 ? Math.PI : 0);
          return E.add(_.rotate(C));
        }
        return E.add(_);
      }
      function Ho(E, a, f, _, h, p, b, x, C, M, R, O, D, U) {
        const W = E.text.placedSymbolArray, Q = E.text.dynamicLayoutVertexArray, Y = E.icon.dynamicLayoutVertexArray, K = {};
        Q.clear();
        for (let fe = 0; fe < W.length; fe++) {
          const ne = W.get(fe), ie = ne.hidden || !ne.crossTileID || E.allowVerticalPlacement && !ne.placedOrientation ? null : _[ne.crossTileID];
          if (ie) {
            const le = new l.P(ne.anchorX, ne.anchorY), xe = { getElevation: U, width: h.width, height: h.height, labelPlaneMatrix: p, lineVertexArray: null, pitchWithMap: f, projection: R, projectionCache: null, tileAnchorPoint: le, translation: O, unwrappedTileID: D }, Me = f ? ve(le, b, U) : nt(le.x, le.y, xe), Ne = X(h.cameraToCenterDistance, Me.signedDistanceFromCamera);
            let ot = l.aj(E.textSizeData, C, ne) * Ne / l.aq;
            f && (ot *= E.tilePixelRatio / x);
            const { width: et, height: rt, anchor: $e, textOffset: Ct, textBoxScale: qt } = ie, yt = xa($e, et, rt, Ct, qt, ot), vt = R.getPitchedTextCorrection(h, le.add(new l.P(O[0], O[1])), D), Ht = wa(Me.point, xe, a, yt, h.angle, vt), Sn = E.allowVerticalPlacement && ne.placedOrientation === l.ai.vertical ? Math.PI / 2 : 0;
            for (let Ot = 0; Ot < ne.numGlyphs; Ot++)
              l.ak(Q, Ht, Sn);
            M && ne.associatedIconIndex >= 0 && (K[ne.associatedIconIndex] = { shiftedAnchor: Ht, angle: Sn });
          } else
            Kt(ne.numGlyphs, Q);
        }
        if (M) {
          Y.clear();
          const fe = E.icon.placedSymbolArray;
          for (let ne = 0; ne < fe.length; ne++) {
            const ie = fe.get(ne);
            if (ie.hidden)
              Kt(ie.numGlyphs, Y);
            else {
              const le = K[ne];
              if (le)
                for (let xe = 0; xe < ie.numGlyphs; xe++)
                  l.ak(Y, le.shiftedAnchor, le.angle);
              else
                Kt(ie.numGlyphs, Y);
            }
          }
          E.icon.dynamicLayoutVertexBuffer.updateData(Y);
        }
        E.text.dynamicLayoutVertexBuffer.updateData(Q);
      }
      function sl(E, a, f) {
        return f.iconsInText && a ? "symbolTextAndIcon" : E ? "symbolSDF" : "symbolIcon";
      }
      function Ls(E, a, f, _, h, p, b, x, C, M, R, O) {
        const D = E.context, U = D.gl, W = E.transform, Q = zo(), Y = x === "map", K = C === "map", fe = x !== "viewport" && f.layout.get("symbol-placement") !== "point", ne = Y && !K && !fe, ie = !K && fe, le = !f.layout.get("symbol-sort-key").isConstant();
        let xe = !1;
        const Me = E.depthModeForSublayer(0, fn.ReadOnly), Ne = f._unevaluatedLayout.hasValue("text-variable-anchor") || f._unevaluatedLayout.hasValue("text-variable-anchor-offset"), ot = [], et = Q.getCircleRadiusCorrection(W);
        for (const rt of _) {
          const $e = a.getTile(rt), Ct = $e.getBucket(f);
          if (!Ct)
            continue;
          const qt = h ? Ct.text : Ct.icon;
          if (!qt || !qt.segments.get().length || !qt.hasVisibleVertices)
            continue;
          const yt = qt.programConfigurations.get(f.id), vt = h || Ct.sdfIcons, Ht = h ? Ct.textSizeData : Ct.iconSizeData, Sn = K || W.pitch !== 0, Ot = E.useProgram(sl(vt, h, Ct), yt), gn = l.ah(Ht, W.zoom), Wn = E.style.map.terrain && E.style.map.terrain.getTerrainData(rt);
          let Qn, ji, En, Li, Ai = [0, 0], ni = null;
          if (h)
            ji = $e.glyphAtlasTexture, En = U.LINEAR, Qn = $e.glyphAtlasTexture.size, Ct.iconsInText && (Ai = $e.imageAtlasTexture.size, ni = $e.imageAtlasTexture, Li = Sn || E.options.rotating || E.options.zooming || Ht.kind === "composite" || Ht.kind === "camera" ? U.LINEAR : U.NEAREST);
          else {
            const Ei = f.layout.get("icon-size").constantOr(0) !== 1 || Ct.iconsNeedLinear;
            ji = $e.imageAtlasTexture, En = vt || E.options.rotating || E.options.zooming || Ei || Sn ? U.LINEAR : U.NEAREST, Qn = $e.imageAtlasTexture.size;
          }
          const ri = an($e, 1, E.transform.zoom), ki = ie ? rt.posMatrix : Ul, Ar = sr(ki, K, Y, E.transform, ri), Es = or(ki, K, Y, E.transform, ri), Yi = or(rt.posMatrix, K, Y, E.transform, ri), ts = Q.translatePosition(E.transform, $e, p, b), Co = Ne && Ct.hasTextData(), Fa = f.layout.get("icon-text-fit") !== "none" && Co && Ct.hasIconData();
          if (fe) {
            const Ei = E.style.map.terrain ? (Da, Vi) => E.style.map.terrain.getElevation(rt, Da, Vi) : null, Ur = f.layout.get("text-rotation-alignment") === "map";
            he(Ct, rt.posMatrix, E, h, Ar, Yi, K, M, Ur, Q, rt.toUnwrapped(), W.width, W.height, ts, Ei);
          }
          const Gi = rt.posMatrix, si = h && Ne || Fa, Io = fe || si ? Ul : Ar, cl = Es, Rr = vt && f.paint.get(h ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
          let mr;
          mr = vt ? Ct.iconsInText ? xc(Ht.kind, gn, ne, K, fe, si, E, Gi, Io, cl, ts, Qn, Ai, et) : ou(Ht.kind, gn, ne, K, fe, si, E, Gi, Io, cl, ts, h, Qn, !0, et) : su(Ht.kind, gn, ne, K, fe, si, E, Gi, Io, cl, ts, h, Qn, et);
          const nr = { program: Ot, buffers: qt, uniformValues: mr, atlasTexture: ji, atlasTextureIcon: ni, atlasInterpolation: En, atlasInterpolationIcon: Li, isSDF: vt, hasHalo: Rr };
          if (le && Ct.canOverlap) {
            xe = !0;
            const Ei = qt.segments.get();
            for (const Ur of Ei)
              ot.push({ segments: new l.a0([Ur]), sortKey: Ur.sortKey, state: nr, terrainData: Wn });
          } else
            ot.push({ segments: qt.segments, sortKey: 0, state: nr, terrainData: Wn });
        }
        xe && ot.sort((rt, $e) => rt.sortKey - $e.sortKey);
        for (const rt of ot) {
          const $e = rt.state;
          if (D.activeTexture.set(U.TEXTURE0), $e.atlasTexture.bind($e.atlasInterpolation, U.CLAMP_TO_EDGE), $e.atlasTextureIcon && (D.activeTexture.set(U.TEXTURE1), $e.atlasTextureIcon && $e.atlasTextureIcon.bind($e.atlasInterpolationIcon, U.CLAMP_TO_EDGE)), $e.isSDF) {
            const Ct = $e.uniformValues;
            $e.hasHalo && (Ct.u_is_halo = 1, Ms($e.buffers, rt.segments, f, E, $e.program, Me, R, O, Ct, rt.terrainData)), Ct.u_is_halo = 0;
          }
          Ms($e.buffers, rt.segments, f, E, $e.program, Me, R, O, $e.uniformValues, rt.terrainData);
        }
      }
      function Ms(E, a, f, _, h, p, b, x, C, M) {
        const R = _.context;
        h.draw(R, R.gl.TRIANGLES, p, b, x, Zn.disabled, C, M, f.id, E.layoutVertexBuffer, E.indexBuffer, a, f.paint, _.transform.zoom, E.programConfigurations.get(f.id), E.dynamicLayoutVertexBuffer, E.opacityVertexBuffer);
      }
      function Pi(E, a, f, _, h) {
        if (!f || !_ || !_.imageAtlas)
          return;
        const p = _.imageAtlas.patternPositions;
        let b = p[f.to.toString()], x = p[f.from.toString()];
        if (!b && x && (b = x), !x && b && (x = b), !b || !x) {
          const C = h.getPaintProperty(a);
          b = p[C], x = p[C];
        }
        b && x && E.setConstantPatternPositions(b, x);
      }
      function Aa(E, a, f, _, h, p, b) {
        const x = E.context.gl, C = "fill-pattern", M = f.paint.get(C), R = M && M.constantOr(1), O = f.getCrossfadeParameters();
        let D, U, W, Q, Y;
        b ? (U = R && !f.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", D = x.LINES) : (U = R ? "fillPattern" : "fill", D = x.TRIANGLES);
        const K = M.constantOr(null);
        for (const fe of _) {
          const ne = a.getTile(fe);
          if (R && !ne.patternsLoaded())
            continue;
          const ie = ne.getBucket(f);
          if (!ie)
            continue;
          const le = ie.programConfigurations.get(f.id), xe = E.useProgram(U, le), Me = E.style.map.terrain && E.style.map.terrain.getTerrainData(fe);
          R && (E.context.activeTexture.set(x.TEXTURE0), ne.imageAtlasTexture.bind(x.LINEAR, x.CLAMP_TO_EDGE), le.updatePaintBuffers(O)), Pi(le, C, K, ne, f);
          const Ne = Me ? fe : null, ot = E.translatePosMatrix(Ne ? Ne.posMatrix : fe.posMatrix, ne, f.paint.get("fill-translate"), f.paint.get("fill-translate-anchor"));
          if (b) {
            Q = ie.indexBuffer2, Y = ie.segments2;
            const et = [x.drawingBufferWidth, x.drawingBufferHeight];
            W = U === "fillOutlinePattern" && R ? Fi(ot, E, O, ne, et) : Pn(ot, et);
          } else
            Q = ie.indexBuffer, Y = ie.segments, W = R ? Wt(ot, E, O, ne) : St(ot);
          xe.draw(E.context, D, h, E.stencilModeForClipping(fe), p, Zn.disabled, W, Me, f.id, ie.layoutVertexBuffer, Q, Y, f.paint, E.transform.zoom, le);
        }
      }
      function Wo(E, a, f, _, h, p, b) {
        const x = E.context, C = x.gl, M = "fill-extrusion-pattern", R = f.paint.get(M), O = R.constantOr(1), D = f.getCrossfadeParameters(), U = f.paint.get("fill-extrusion-opacity"), W = R.constantOr(null);
        for (const Q of _) {
          const Y = a.getTile(Q), K = Y.getBucket(f);
          if (!K)
            continue;
          const fe = E.style.map.terrain && E.style.map.terrain.getTerrainData(Q), ne = K.programConfigurations.get(f.id), ie = E.useProgram(O ? "fillExtrusionPattern" : "fillExtrusion", ne);
          O && (E.context.activeTexture.set(C.TEXTURE0), Y.imageAtlasTexture.bind(C.LINEAR, C.CLAMP_TO_EDGE), ne.updatePaintBuffers(D)), Pi(ne, M, W, Y, f);
          const le = E.translatePosMatrix(Q.posMatrix, Y, f.paint.get("fill-extrusion-translate"), f.paint.get("fill-extrusion-translate-anchor")), xe = f.paint.get("fill-extrusion-vertical-gradient"), Me = O ? it(le, E, xe, U, Q, D, Y) : Re(le, E, xe, U);
          ie.draw(x, x.gl.TRIANGLES, h, p, b, Zn.backCCW, Me, fe, f.id, K.layoutVertexBuffer, K.indexBuffer, K.segments, f.paint, E.transform.zoom, ne, E.style.map.terrain && K.centroidVertexBuffer);
        }
      }
      function Ea(E, a, f, _, h, p, b) {
        const x = E.context, C = x.gl, M = f.fbo;
        if (!M)
          return;
        const R = E.useProgram("hillshade"), O = E.style.map.terrain && E.style.map.terrain.getTerrainData(a);
        x.activeTexture.set(C.TEXTURE0), C.bindTexture(C.TEXTURE_2D, M.colorAttachment.get()), R.draw(x, C.TRIANGLES, h, p, b, Zn.disabled, ((D, U, W, Q) => {
          const Y = W.paint.get("hillshade-shadow-color"), K = W.paint.get("hillshade-highlight-color"), fe = W.paint.get("hillshade-accent-color");
          let ne = W.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
          W.paint.get("hillshade-illumination-anchor") === "viewport" && (ne -= D.transform.angle);
          const ie = !D.options.moving;
          return { u_matrix: Q ? Q.posMatrix : D.transform.calculatePosMatrix(U.tileID.toUnwrapped(), ie), u_image: 0, u_latrange: yn(0, U.tileID), u_light: [W.paint.get("hillshade-exaggeration"), ne], u_shadow: Y, u_highlight: K, u_accent: fe };
        })(E, f, _, O ? a : null), O, _.id, E.rasterBoundsBuffer, E.quadTriangleIndexBuffer, E.rasterBoundsSegments);
      }
      function io(E, a, f, _, h, p) {
        const b = E.context, x = b.gl, C = a.dem;
        if (C && C.data) {
          const M = C.dim, R = C.stride, O = C.getPixels();
          if (b.activeTexture.set(x.TEXTURE1), b.pixelStoreUnpackPremultiplyAlpha.set(!1), a.demTexture = a.demTexture || E.getTileTexture(R), a.demTexture) {
            const U = a.demTexture;
            U.update(O, { premultiply: !1 }), U.bind(x.NEAREST, x.CLAMP_TO_EDGE);
          } else
            a.demTexture = new ae(b, O, x.RGBA, { premultiply: !1 }), a.demTexture.bind(x.NEAREST, x.CLAMP_TO_EDGE);
          b.activeTexture.set(x.TEXTURE0);
          let D = a.fbo;
          if (!D) {
            const U = new ae(b, { width: M, height: M, data: null }, x.RGBA);
            U.bind(x.LINEAR, x.CLAMP_TO_EDGE), D = a.fbo = b.createFramebuffer(M, M, !0, !1), D.colorAttachment.set(U.texture);
          }
          b.bindFramebuffer.set(D.framebuffer), b.viewport.set([0, 0, M, M]), E.useProgram("hillshadePrepare").draw(b, x.TRIANGLES, _, h, p, Zn.disabled, ((U, W) => {
            const Q = W.stride, Y = l.H();
            return l.aQ(Y, 0, l.X, -l.X, 0, 0, 1), l.J(Y, Y, [0, -l.X, 0]), { u_matrix: Y, u_image: 1, u_dimension: [Q, Q], u_zoom: U.overscaledZ, u_unpack: W.getUnpackVector() };
          })(a.tileID, C), null, f.id, E.rasterBoundsBuffer, E.quadTriangleIndexBuffer, E.rasterBoundsSegments), a.needsHillshadePrepare = !1;
        }
      }
      function Lr(E, a, f, _, h, p) {
        const b = _.paint.get("raster-fade-duration");
        if (!p && b > 0) {
          const x = T.now(), C = (x - E.timeAdded) / b, M = a ? (x - a.timeAdded) / b : -1, R = f.getSource(), O = h.coveringZoomLevel({ tileSize: R.tileSize, roundZoom: R.roundZoom }), D = !a || Math.abs(a.tileID.overscaledZ - O) > Math.abs(E.tileID.overscaledZ - O), U = D && E.refreshedUponExpiration ? 1 : l.ad(D ? C : 1 - M, 0, 1);
          return E.refreshedUponExpiration && C >= 1 && (E.refreshedUponExpiration = !1), a ? { opacity: 1, mix: 1 - U } : { opacity: U, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      const jl = new l.aN(1, 0, 0, 1), Xo = new l.aN(0, 1, 0, 1), ol = new l.aN(0, 0, 1, 1), Bs = new l.aN(1, 0, 1, 1), Eo = new l.aN(0, 1, 1, 1);
      function Jo(E, a, f, _) {
        vs(E, 0, a + f / 2, E.transform.width, f, _);
      }
      function Sc(E, a, f, _) {
        vs(E, a - f / 2, 0, f, E.transform.height, _);
      }
      function vs(E, a, f, _, h, p) {
        const b = E.context, x = b.gl;
        x.enable(x.SCISSOR_TEST), x.scissor(a * E.pixelRatio, f * E.pixelRatio, _ * E.pixelRatio, h * E.pixelRatio), b.clear({ color: p }), x.disable(x.SCISSOR_TEST);
      }
      function Mn(E, a, f) {
        const _ = E.context, h = _.gl, p = f.posMatrix, b = E.useProgram("debug"), x = fn.disabled, C = kn.disabled, M = E.colorModeForRenderPass(), R = "$debug", O = E.style.map.terrain && E.style.map.terrain.getTerrainData(f);
        _.activeTexture.set(h.TEXTURE0);
        const D = a.getTileByID(f.key).latestRawTileData, U = Math.floor((D && D.byteLength || 0) / 1024), W = a.getTile(f).tileSize, Q = 512 / Math.min(W, 512) * (f.overscaledZ / E.transform.zoom) * 0.5;
        let Y = f.canonical.toString();
        f.overscaledZ !== f.canonical.z && (Y += ` => ${f.overscaledZ}`), function(K, fe) {
          K.initDebugOverlayCanvas();
          const ne = K.debugOverlayCanvas, ie = K.context.gl, le = K.debugOverlayCanvas.getContext("2d");
          le.clearRect(0, 0, ne.width, ne.height), le.shadowColor = "white", le.shadowBlur = 2, le.lineWidth = 1.5, le.strokeStyle = "white", le.textBaseline = "top", le.font = "bold 36px Open Sans, sans-serif", le.fillText(fe, 5, 5), le.strokeText(fe, 5, 5), K.debugOverlayTexture.update(ne), K.debugOverlayTexture.bind(ie.LINEAR, ie.CLAMP_TO_EDGE);
        }(E, `${Y} ${U}kB`), b.draw(_, h.TRIANGLES, x, C, In.alphaBlended, Zn.disabled, ti(p, l.aN.transparent, Q), null, R, E.debugBuffer, E.quadTriangleIndexBuffer, E.debugSegments), b.draw(_, h.LINE_STRIP, x, C, M, Zn.disabled, ti(p, l.aN.red), O, R, E.debugBuffer, E.tileBorderIndexBuffer, E.debugSegments);
      }
      function $r(E, a, f) {
        const _ = E.context, h = _.gl, p = E.colorModeForRenderPass(), b = new fn(h.LEQUAL, fn.ReadWrite, E.depthRangeFor3D), x = E.useProgram("terrain"), C = a.getTerrainMesh();
        _.bindFramebuffer.set(null), _.viewport.set([0, 0, E.width, E.height]);
        for (const M of f) {
          const R = E.renderToTexture.getTexture(M), O = a.getTerrainData(M.tileID);
          _.activeTexture.set(h.TEXTURE0), h.bindTexture(h.TEXTURE_2D, R.texture);
          const D = E.transform.calculatePosMatrix(M.tileID.toUnwrapped()), U = a.getMeshFrameDelta(E.transform.zoom), W = E.transform.calculateFogMatrix(M.tileID.toUnwrapped()), Q = ma(D, U, W, E.style.sky, E.transform.pitch);
          x.draw(_, h.TRIANGLES, b, kn.disabled, p, Zn.backCCW, Q, O, "terrain", C.vertexBuffer, C.indexBuffer, C.segments);
        }
      }
      class $o {
        constructor(a, f, _) {
          this.vertexBuffer = a, this.indexBuffer = f, this.segments = _;
        }
        destroy() {
          this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
        }
      }
      class ro {
        constructor(a, f) {
          this.context = new $i(a), this.transform = f, this._tileTextures = {}, this.terrainFacilitator = { dirty: !0, matrix: l.ao(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = Gt.maxUnderzooming + Gt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new hr();
        }
        resize(a, f, _) {
          if (this.width = Math.floor(a * _), this.height = Math.floor(f * _), this.pixelRatio = _, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
            for (const h of this.style._order)
              this.style._layers[h].resize();
        }
        setup() {
          const a = this.context, f = new l.aX();
          f.emplaceBack(0, 0), f.emplaceBack(l.X, 0), f.emplaceBack(0, l.X), f.emplaceBack(l.X, l.X), this.tileExtentBuffer = a.createVertexBuffer(f, dr.members), this.tileExtentSegments = l.a0.simpleSegment(0, 0, 4, 2);
          const _ = new l.aX();
          _.emplaceBack(0, 0), _.emplaceBack(l.X, 0), _.emplaceBack(0, l.X), _.emplaceBack(l.X, l.X), this.debugBuffer = a.createVertexBuffer(_, dr.members), this.debugSegments = l.a0.simpleSegment(0, 0, 4, 5);
          const h = new l.$();
          h.emplaceBack(0, 0, 0, 0), h.emplaceBack(l.X, 0, l.X, 0), h.emplaceBack(0, l.X, 0, l.X), h.emplaceBack(l.X, l.X, l.X, l.X), this.rasterBoundsBuffer = a.createVertexBuffer(h, Ft.members), this.rasterBoundsSegments = l.a0.simpleSegment(0, 0, 4, 2);
          const p = new l.aX();
          p.emplaceBack(0, 0), p.emplaceBack(1, 0), p.emplaceBack(0, 1), p.emplaceBack(1, 1), this.viewportBuffer = a.createVertexBuffer(p, dr.members), this.viewportSegments = l.a0.simpleSegment(0, 0, 4, 2);
          const b = new l.aZ();
          b.emplaceBack(0), b.emplaceBack(1), b.emplaceBack(3), b.emplaceBack(2), b.emplaceBack(0), this.tileBorderIndexBuffer = a.createIndexBuffer(b);
          const x = new l.aY();
          x.emplaceBack(0, 1, 2), x.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = a.createIndexBuffer(x);
          const C = this.context.gl;
          this.stencilClearMode = new kn({ func: C.ALWAYS, mask: 0 }, 0, 255, C.ZERO, C.ZERO, C.ZERO);
        }
        clearStencil() {
          const a = this.context, f = a.gl;
          this.nextStencilID = 1, this.currentStencilSource = void 0;
          const _ = l.H();
          l.aQ(_, 0, this.width, this.height, 0, 0, 1), l.K(_, _, [f.drawingBufferWidth, f.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(a, f.TRIANGLES, fn.disabled, this.stencilClearMode, In.disabled, Zn.disabled, Qa(_), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }
        _renderTileClippingMasks(a, f) {
          if (this.currentStencilSource === a.source || !a.isTileClipped() || !f || !f.length)
            return;
          this.currentStencilSource = a.source;
          const _ = this.context, h = _.gl;
          this.nextStencilID + f.length > 256 && this.clearStencil(), _.setColorMode(In.disabled), _.setDepthMode(fn.disabled);
          const p = this.useProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (const b of f) {
            const x = this._tileClippingMaskIDs[b.key] = this.nextStencilID++, C = this.style.map.terrain && this.style.map.terrain.getTerrainData(b);
            p.draw(_, h.TRIANGLES, fn.disabled, new kn({ func: h.ALWAYS, mask: 0 }, x, 255, h.KEEP, h.KEEP, h.REPLACE), In.disabled, Zn.disabled, Qa(b.posMatrix), C, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
        }
        stencilModeFor3D() {
          this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
          const a = this.nextStencilID++, f = this.context.gl;
          return new kn({ func: f.NOTEQUAL, mask: 255 }, a, 255, f.KEEP, f.KEEP, f.REPLACE);
        }
        stencilModeForClipping(a) {
          const f = this.context.gl;
          return new kn({ func: f.EQUAL, mask: 255 }, this._tileClippingMaskIDs[a.key], 0, f.KEEP, f.KEEP, f.REPLACE);
        }
        stencilConfigForOverlap(a) {
          const f = this.context.gl, _ = a.sort((b, x) => x.overscaledZ - b.overscaledZ), h = _[_.length - 1].overscaledZ, p = _[0].overscaledZ - h + 1;
          if (p > 1) {
            this.currentStencilSource = void 0, this.nextStencilID + p > 256 && this.clearStencil();
            const b = {};
            for (let x = 0; x < p; x++)
              b[x + h] = new kn({ func: f.GEQUAL, mask: 255 }, x + this.nextStencilID, 255, f.KEEP, f.KEEP, f.REPLACE);
            return this.nextStencilID += p, [b, _];
          }
          return [{ [h]: kn.disabled }, _];
        }
        colorModeForRenderPass() {
          const a = this.context.gl;
          return this._showOverdrawInspector ? new In([a.CONSTANT_COLOR, a.ONE], new l.aN(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? In.unblended : In.alphaBlended;
        }
        depthModeForSublayer(a, f, _) {
          if (!this.opaquePassEnabledForLayer())
            return fn.disabled;
          const h = 1 - ((1 + this.currentLayer) * this.numSublayers + a) * this.depthEpsilon;
          return new fn(_ || this.context.gl.LEQUAL, f, [h, h]);
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        render(a, f) {
          this.style = a, this.options = f, this.lineAtlas = a.lineAtlas, this.imageManager = a.imageManager, this.glyphManager = a.glyphManager, this.symbolFadeChange = a.placement.symbolFadeChange(T.now()), this.imageManager.beginFrame();
          const _ = this.style._order, h = this.style.sourceCaches, p = {}, b = {}, x = {};
          for (const C in h) {
            const M = h[C];
            M.used && M.prepare(this.context), p[C] = M.getVisibleCoordinates(), b[C] = p[C].slice().reverse(), x[C] = M.getVisibleCoordinates(!0).reverse();
          }
          this.opaquePassCutoff = 1 / 0;
          for (let C = 0; C < _.length; C++)
            if (this.style._layers[_[C]].is3D()) {
              this.opaquePassCutoff = C;
              break;
            }
          this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
          for (const C of _) {
            const M = this.style._layers[C];
            if (!M.hasOffscreenPass() || M.isHidden(this.transform.zoom))
              continue;
            const R = b[M.source];
            (M.type === "custom" || R.length) && this.renderLayer(this, h[M.source], M, R);
          }
          if (this.context.bindFramebuffer.set(null), this.context.clear({ color: f.showOverdrawInspector ? l.aN.black : l.aN.transparent, depth: 1 }), this.clearStencil(), this.style.stylesheet.sky && function(C, M) {
            const R = C.context, O = R.gl, D = ((K, fe, ne) => ({ u_sky_color: K.properties.get("sky-color"), u_horizon_color: K.properties.get("horizon-color"), u_horizon: (fe.height / 2 + fe.getHorizon()) * ne, u_sky_horizon_blend: K.properties.get("sky-horizon-blend") * fe.height / 2 * ne }))(M, C.style.map.transform, C.pixelRatio), U = new fn(O.LEQUAL, fn.ReadWrite, [0, 1]), W = kn.disabled, Q = C.colorModeForRenderPass(), Y = C.useProgram("sky");
            if (!M.mesh) {
              const K = new l.aX();
              K.emplaceBack(-1, -1), K.emplaceBack(1, -1), K.emplaceBack(1, 1), K.emplaceBack(-1, 1);
              const fe = new l.aY();
              fe.emplaceBack(0, 1, 2), fe.emplaceBack(0, 2, 3), M.mesh = new $o(R.createVertexBuffer(K, dr.members), R.createIndexBuffer(fe), l.a0.simpleSegment(0, 0, K.length, fe.length));
            }
            Y.draw(R, O.TRIANGLES, U, W, Q, Zn.disabled, D, void 0, "sky", M.mesh.vertexBuffer, M.mesh.indexBuffer, M.mesh.segments);
          }(this, this.style.sky), this._showOverdrawInspector = f.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (a._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture)
            for (this.renderPass = "opaque", this.currentLayer = _.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const C = this.style._layers[_[this.currentLayer]], M = h[C.source], R = p[C.source];
              this._renderTileClippingMasks(C, R), this.renderLayer(this, M, C, R);
            }
          for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < _.length; this.currentLayer++) {
            const C = this.style._layers[_[this.currentLayer]], M = h[C.source];
            if (this.renderToTexture && this.renderToTexture.renderLayer(C))
              continue;
            const R = (C.type === "symbol" ? x : b)[C.source];
            this._renderTileClippingMasks(C, p[C.source]), this.renderLayer(this, M, C, R);
          }
          if (this.options.showTileBoundaries) {
            const C = function(M, R) {
              let O = null;
              const D = Object.values(M._layers).flatMap((Y) => Y.source && !Y.isHidden(R) ? [M.sourceCaches[Y.source]] : []), U = D.filter((Y) => Y.getSource().type === "vector"), W = D.filter((Y) => Y.getSource().type !== "vector"), Q = (Y) => {
                (!O || O.getSource().maxzoom < Y.getSource().maxzoom) && (O = Y);
              };
              return U.forEach((Y) => Q(Y)), O || W.forEach((Y) => Q(Y)), O;
            }(this.style, this.transform.zoom);
            C && function(M, R, O) {
              for (let D = 0; D < O.length; D++)
                Mn(M, R, O[D]);
            }(this, C, C.getVisibleCoordinates());
          }
          this.options.showPadding && function(C) {
            const M = C.transform.padding;
            Jo(C, C.transform.height - (M.top || 0), 3, jl), Jo(C, M.bottom || 0, 3, Xo), Sc(C, M.left || 0, 3, ol), Sc(C, C.transform.width - (M.right || 0), 3, Bs);
            const R = C.transform.centerPoint;
            (function(O, D, U, W) {
              vs(O, D - 1, U - 10, 2, 20, W), vs(O, D - 10, U - 1, 20, 2, W);
            })(C, R.x, C.transform.height - R.y, Eo);
          }(this), this.context.setDefault();
        }
        maybeDrawDepthAndCoords(a) {
          if (!this.style || !this.style.map || !this.style.map.terrain)
            return;
          const f = this.terrainFacilitator.matrix, _ = this.transform.modelViewProjectionMatrix;
          let h = this.terrainFacilitator.dirty;
          h || (h = a ? !l.a_(f, _) : !l.a$(f, _)), h || (h = this.style.map.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime).length > 0), h && (l.b0(f, _), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, function(p, b) {
            const x = p.context, C = x.gl, M = In.unblended, R = new fn(C.LEQUAL, fn.ReadWrite, [0, 1]), O = b.getTerrainMesh(), D = b.sourceCache.getRenderableTiles(), U = p.useProgram("terrainDepth");
            x.bindFramebuffer.set(b.getFramebuffer("depth").framebuffer), x.viewport.set([0, 0, p.width / devicePixelRatio, p.height / devicePixelRatio]), x.clear({ color: l.aN.transparent, depth: 1 });
            for (const W of D) {
              const Q = b.getTerrainData(W.tileID), Y = { u_matrix: p.transform.calculatePosMatrix(W.tileID.toUnwrapped()), u_ele_delta: b.getMeshFrameDelta(p.transform.zoom) };
              U.draw(x, C.TRIANGLES, R, kn.disabled, M, Zn.backCCW, Y, Q, "terrain", O.vertexBuffer, O.indexBuffer, O.segments);
            }
            x.bindFramebuffer.set(null), x.viewport.set([0, 0, p.width, p.height]);
          }(this, this.style.map.terrain), function(p, b) {
            const x = p.context, C = x.gl, M = In.unblended, R = new fn(C.LEQUAL, fn.ReadWrite, [0, 1]), O = b.getTerrainMesh(), D = b.getCoordsTexture(), U = b.sourceCache.getRenderableTiles(), W = p.useProgram("terrainCoords");
            x.bindFramebuffer.set(b.getFramebuffer("coords").framebuffer), x.viewport.set([0, 0, p.width / devicePixelRatio, p.height / devicePixelRatio]), x.clear({ color: l.aN.transparent, depth: 1 }), b.coordsIndex = [];
            for (const Q of U) {
              const Y = b.getTerrainData(Q.tileID);
              x.activeTexture.set(C.TEXTURE0), C.bindTexture(C.TEXTURE_2D, D.texture);
              const K = { u_matrix: p.transform.calculatePosMatrix(Q.tileID.toUnwrapped()), u_terrain_coords_id: (255 - b.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: b.getMeshFrameDelta(p.transform.zoom) };
              W.draw(x, C.TRIANGLES, R, kn.disabled, M, Zn.backCCW, K, Y, "terrain", O.vertexBuffer, O.indexBuffer, O.segments), b.coordsIndex.push(Q.tileID.key);
            }
            x.bindFramebuffer.set(null), x.viewport.set([0, 0, p.width, p.height]);
          }(this, this.style.map.terrain));
        }
        renderLayer(a, f, _, h) {
          if (!_.isHidden(this.transform.zoom) && (_.type === "background" || _.type === "custom" || (h || []).length))
            switch (this.id = _.id, _.type) {
              case "symbol":
                (function(p, b, x, C, M) {
                  if (p.renderPass !== "translucent")
                    return;
                  const R = kn.disabled, O = p.colorModeForRenderPass();
                  (x._unevaluatedLayout.hasValue("text-variable-anchor") || x._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(D, U, W, Q, Y, K, fe, ne, ie) {
                    const le = U.transform, xe = zo(), Me = Y === "map", Ne = K === "map";
                    for (const ot of D) {
                      const et = Q.getTile(ot), rt = et.getBucket(W);
                      if (!rt || !rt.text || !rt.text.segments.get().length)
                        continue;
                      const $e = l.ah(rt.textSizeData, le.zoom), Ct = an(et, 1, U.transform.zoom), qt = sr(ot.posMatrix, Ne, Me, U.transform, Ct), yt = W.layout.get("icon-text-fit") !== "none" && rt.hasIconData();
                      if ($e) {
                        const vt = Math.pow(2, le.zoom - et.tileID.overscaledZ), Ht = U.style.map.terrain ? (Ot, gn) => U.style.map.terrain.getElevation(ot, Ot, gn) : null, Sn = xe.translatePosition(le, et, fe, ne);
                        Ho(rt, Me, Ne, ie, le, qt, ot.posMatrix, vt, $e, yt, xe, Sn, ot.toUnwrapped(), Ht);
                      }
                    }
                  }(C, p, x, b, x.layout.get("text-rotation-alignment"), x.layout.get("text-pitch-alignment"), x.paint.get("text-translate"), x.paint.get("text-translate-anchor"), M), x.paint.get("icon-opacity").constantOr(1) !== 0 && Ls(p, b, x, C, !1, x.paint.get("icon-translate"), x.paint.get("icon-translate-anchor"), x.layout.get("icon-rotation-alignment"), x.layout.get("icon-pitch-alignment"), x.layout.get("icon-keep-upright"), R, O), x.paint.get("text-opacity").constantOr(1) !== 0 && Ls(p, b, x, C, !0, x.paint.get("text-translate"), x.paint.get("text-translate-anchor"), x.layout.get("text-rotation-alignment"), x.layout.get("text-pitch-alignment"), x.layout.get("text-keep-upright"), R, O), b.map.showCollisionBoxes && (Ao(p, b, x, C, !0), Ao(p, b, x, C, !1));
                })(a, f, _, h, this.style.placement.variableOffsets);
                break;
              case "circle":
                (function(p, b, x, C) {
                  if (p.renderPass !== "translucent")
                    return;
                  const M = x.paint.get("circle-opacity"), R = x.paint.get("circle-stroke-width"), O = x.paint.get("circle-stroke-opacity"), D = !x.layout.get("circle-sort-key").isConstant();
                  if (M.constantOr(1) === 0 && (R.constantOr(1) === 0 || O.constantOr(1) === 0))
                    return;
                  const U = p.context, W = U.gl, Q = p.depthModeForSublayer(0, fn.ReadOnly), Y = kn.disabled, K = p.colorModeForRenderPass(), fe = [];
                  for (let ne = 0; ne < C.length; ne++) {
                    const ie = C[ne], le = b.getTile(ie), xe = le.getBucket(x);
                    if (!xe)
                      continue;
                    const Me = xe.programConfigurations.get(x.id), Ne = p.useProgram("circle", Me), ot = xe.layoutVertexBuffer, et = xe.indexBuffer, rt = p.style.map.terrain && p.style.map.terrain.getTerrainData(ie), $e = { programConfiguration: Me, program: Ne, layoutVertexBuffer: ot, indexBuffer: et, uniformValues: Di(p, ie, le, x), terrainData: rt };
                    if (D) {
                      const Ct = xe.segments.get();
                      for (const qt of Ct)
                        fe.push({ segments: new l.a0([qt]), sortKey: qt.sortKey, state: $e });
                    } else
                      fe.push({ segments: xe.segments, sortKey: 0, state: $e });
                  }
                  D && fe.sort((ne, ie) => ne.sortKey - ie.sortKey);
                  for (const ne of fe) {
                    const { programConfiguration: ie, program: le, layoutVertexBuffer: xe, indexBuffer: Me, uniformValues: Ne, terrainData: ot } = ne.state;
                    le.draw(U, W.TRIANGLES, Q, Y, K, Zn.disabled, Ne, ot, x.id, xe, Me, ne.segments, x.paint, p.transform.zoom, ie);
                  }
                })(a, f, _, h);
                break;
              case "heatmap":
                (function(p, b, x, C) {
                  if (x.paint.get("heatmap-opacity") !== 0)
                    if (p.renderPass === "offscreen") {
                      const M = p.context, R = M.gl, O = kn.disabled, D = new In([R.ONE, R.ONE], l.aN.transparent, [!0, !0, !0, !0]);
                      (function(U, W, Q) {
                        const Y = U.gl;
                        U.activeTexture.set(Y.TEXTURE1), U.viewport.set([0, 0, W.width / 4, W.height / 4]);
                        let K = Q.heatmapFbo;
                        if (K)
                          Y.bindTexture(Y.TEXTURE_2D, K.colorAttachment.get()), U.bindFramebuffer.set(K.framebuffer);
                        else {
                          const fe = Y.createTexture();
                          Y.bindTexture(Y.TEXTURE_2D, fe), Y.texParameteri(Y.TEXTURE_2D, Y.TEXTURE_WRAP_S, Y.CLAMP_TO_EDGE), Y.texParameteri(Y.TEXTURE_2D, Y.TEXTURE_WRAP_T, Y.CLAMP_TO_EDGE), Y.texParameteri(Y.TEXTURE_2D, Y.TEXTURE_MIN_FILTER, Y.LINEAR), Y.texParameteri(Y.TEXTURE_2D, Y.TEXTURE_MAG_FILTER, Y.LINEAR), K = Q.heatmapFbo = U.createFramebuffer(W.width / 4, W.height / 4, !1, !1), function(ne, ie, le, xe) {
                            var Me, Ne;
                            const ot = ne.gl, et = (Me = ne.HALF_FLOAT) !== null && Me !== void 0 ? Me : ot.UNSIGNED_BYTE, rt = (Ne = ne.RGBA16F) !== null && Ne !== void 0 ? Ne : ot.RGBA;
                            ot.texImage2D(ot.TEXTURE_2D, 0, rt, ie.width / 4, ie.height / 4, 0, ot.RGBA, et, null), xe.colorAttachment.set(le);
                          }(U, W, fe, K);
                        }
                      })(M, p, x), M.clear({ color: l.aN.transparent });
                      for (let U = 0; U < C.length; U++) {
                        const W = C[U];
                        if (b.hasRenderableParent(W))
                          continue;
                        const Q = b.getTile(W), Y = Q.getBucket(x);
                        if (!Y)
                          continue;
                        const K = Y.programConfigurations.get(x.id), fe = p.useProgram("heatmap", K), { zoom: ne } = p.transform;
                        fe.draw(M, R.TRIANGLES, fn.disabled, O, D, Zn.disabled, Nr(W.posMatrix, Q, ne, x.paint.get("heatmap-intensity")), null, x.id, Y.layoutVertexBuffer, Y.indexBuffer, Y.segments, x.paint, p.transform.zoom, K);
                      }
                      M.viewport.set([0, 0, p.width, p.height]);
                    } else
                      p.renderPass === "translucent" && (p.context.setColorMode(p.colorModeForRenderPass()), function(M, R) {
                        const O = M.context, D = O.gl, U = R.heatmapFbo;
                        if (!U)
                          return;
                        O.activeTexture.set(D.TEXTURE0), D.bindTexture(D.TEXTURE_2D, U.colorAttachment.get()), O.activeTexture.set(D.TEXTURE1);
                        let W = R.colorRampTexture;
                        W || (W = R.colorRampTexture = new ae(O, R.colorRamp, D.RGBA)), W.bind(D.LINEAR, D.CLAMP_TO_EDGE), M.useProgram("heatmapTexture").draw(O, D.TRIANGLES, fn.disabled, kn.disabled, M.colorModeForRenderPass(), Zn.disabled, ((Q, Y, K, fe) => {
                          const ne = l.H();
                          l.aQ(ne, 0, Q.width, Q.height, 0, 0, 1);
                          const ie = Q.context.gl;
                          return { u_matrix: ne, u_world: [ie.drawingBufferWidth, ie.drawingBufferHeight], u_image: 0, u_color_ramp: 1, u_opacity: Y.paint.get("heatmap-opacity") };
                        })(M, R), null, R.id, M.viewportBuffer, M.quadTriangleIndexBuffer, M.viewportSegments, R.paint, M.transform.zoom);
                      }(p, x));
                })(a, f, _, h);
                break;
              case "line":
                (function(p, b, x, C) {
                  if (p.renderPass !== "translucent")
                    return;
                  const M = x.paint.get("line-opacity"), R = x.paint.get("line-width");
                  if (M.constantOr(1) === 0 || R.constantOr(1) === 0)
                    return;
                  const O = p.depthModeForSublayer(0, fn.ReadOnly), D = p.colorModeForRenderPass(), U = x.paint.get("line-dasharray"), W = x.paint.get("line-pattern"), Q = W.constantOr(1), Y = x.paint.get("line-gradient"), K = x.getCrossfadeParameters(), fe = Q ? "linePattern" : U ? "lineSDF" : Y ? "lineGradient" : "line", ne = p.context, ie = ne.gl;
                  let le = !0;
                  for (const xe of C) {
                    const Me = b.getTile(xe);
                    if (Q && !Me.patternsLoaded())
                      continue;
                    const Ne = Me.getBucket(x);
                    if (!Ne)
                      continue;
                    const ot = Ne.programConfigurations.get(x.id), et = p.context.program.get(), rt = p.useProgram(fe, ot), $e = le || rt.program !== et, Ct = p.style.map.terrain && p.style.map.terrain.getTerrainData(xe), qt = W.constantOr(null);
                    if (qt && Me.imageAtlas) {
                      const Ht = Me.imageAtlas, Sn = Ht.patternPositions[qt.to.toString()], Ot = Ht.patternPositions[qt.from.toString()];
                      Sn && Ot && ot.setConstantPatternPositions(Sn, Ot);
                    }
                    const yt = Ct ? xe : null, vt = Q ? eo(p, Me, x, K, yt) : U ? vc(p, Me, x, U, K, yt) : Y ? Rl(p, Me, x, Ne.lineClipsArray.length, yt) : el(p, Me, x, yt);
                    if (Q)
                      ne.activeTexture.set(ie.TEXTURE0), Me.imageAtlasTexture.bind(ie.LINEAR, ie.CLAMP_TO_EDGE), ot.updatePaintBuffers(K);
                    else if (U && ($e || p.lineAtlas.dirty))
                      ne.activeTexture.set(ie.TEXTURE0), p.lineAtlas.bind(ne);
                    else if (Y) {
                      const Ht = Ne.gradients[x.id];
                      let Sn = Ht.texture;
                      if (x.gradientVersion !== Ht.version) {
                        let Ot = 256;
                        if (x.stepInterpolant) {
                          const gn = b.getSource().maxzoom, Wn = xe.canonical.z === gn ? Math.ceil(1 << p.transform.maxZoom - xe.canonical.z) : 1;
                          Ot = l.ad(l.aV(Ne.maxLineLength / l.X * 1024 * Wn), 256, ne.maxTextureSize);
                        }
                        Ht.gradient = l.aW({ expression: x.gradientExpression(), evaluationKey: "lineProgress", resolution: Ot, image: Ht.gradient || void 0, clips: Ne.lineClipsArray }), Ht.texture ? Ht.texture.update(Ht.gradient) : Ht.texture = new ae(ne, Ht.gradient, ie.RGBA), Ht.version = x.gradientVersion, Sn = Ht.texture;
                      }
                      ne.activeTexture.set(ie.TEXTURE0), Sn.bind(x.stepInterpolant ? ie.NEAREST : ie.LINEAR, ie.CLAMP_TO_EDGE);
                    }
                    rt.draw(ne, ie.TRIANGLES, O, p.stencilModeForClipping(xe), D, Zn.disabled, vt, Ct, x.id, Ne.layoutVertexBuffer, Ne.indexBuffer, Ne.segments, x.paint, p.transform.zoom, ot, Ne.layoutVertexBuffer2), le = !1;
                  }
                })(a, f, _, h);
                break;
              case "fill":
                (function(p, b, x, C) {
                  const M = x.paint.get("fill-color"), R = x.paint.get("fill-opacity");
                  if (R.constantOr(1) === 0)
                    return;
                  const O = p.colorModeForRenderPass(), D = x.paint.get("fill-pattern"), U = p.opaquePassEnabledForLayer() && !D.constantOr(1) && M.constantOr(l.aN.transparent).a === 1 && R.constantOr(0) === 1 ? "opaque" : "translucent";
                  if (p.renderPass === U) {
                    const W = p.depthModeForSublayer(1, p.renderPass === "opaque" ? fn.ReadWrite : fn.ReadOnly);
                    Aa(p, b, x, C, W, O, !1);
                  }
                  if (p.renderPass === "translucent" && x.paint.get("fill-antialias")) {
                    const W = p.depthModeForSublayer(x.getPaintProperty("fill-outline-color") ? 2 : 0, fn.ReadOnly);
                    Aa(p, b, x, C, W, O, !0);
                  }
                })(a, f, _, h);
                break;
              case "fill-extrusion":
                (function(p, b, x, C) {
                  const M = x.paint.get("fill-extrusion-opacity");
                  if (M !== 0 && p.renderPass === "translucent") {
                    const R = new fn(p.context.gl.LEQUAL, fn.ReadWrite, p.depthRangeFor3D);
                    if (M !== 1 || x.paint.get("fill-extrusion-pattern").constantOr(1))
                      Wo(p, b, x, C, R, kn.disabled, In.disabled), Wo(p, b, x, C, R, p.stencilModeFor3D(), p.colorModeForRenderPass());
                    else {
                      const O = p.colorModeForRenderPass();
                      Wo(p, b, x, C, R, kn.disabled, O);
                    }
                  }
                })(a, f, _, h);
                break;
              case "hillshade":
                (function(p, b, x, C) {
                  if (p.renderPass !== "offscreen" && p.renderPass !== "translucent")
                    return;
                  const M = p.context, R = p.depthModeForSublayer(0, fn.ReadOnly), O = p.colorModeForRenderPass(), [D, U] = p.renderPass === "translucent" ? p.stencilConfigForOverlap(C) : [{}, C];
                  for (const W of U) {
                    const Q = b.getTile(W);
                    Q.needsHillshadePrepare !== void 0 && Q.needsHillshadePrepare && p.renderPass === "offscreen" ? io(p, Q, x, R, kn.disabled, O) : p.renderPass === "translucent" && Ea(p, W, Q, x, R, D[W.overscaledZ], O);
                  }
                  M.viewport.set([0, 0, p.width, p.height]);
                })(a, f, _, h);
                break;
              case "raster":
                (function(p, b, x, C) {
                  if (p.renderPass !== "translucent" || x.paint.get("raster-opacity") === 0 || !C.length)
                    return;
                  const M = p.context, R = M.gl, O = b.getSource(), D = p.useProgram("raster"), U = p.colorModeForRenderPass(), [W, Q] = O instanceof nn ? [{}, C] : p.stencilConfigForOverlap(C), Y = Q[Q.length - 1].overscaledZ, K = !p.options.moving;
                  for (const fe of Q) {
                    const ne = p.depthModeForSublayer(fe.overscaledZ - Y, x.paint.get("raster-opacity") === 1 ? fn.ReadWrite : fn.ReadOnly, R.LESS), ie = b.getTile(fe);
                    ie.registerFadeDuration(x.paint.get("raster-fade-duration"));
                    const le = b.findLoadedParent(fe, 0), xe = b.findLoadedSibling(fe), Me = Lr(ie, le || xe || null, b, x, p.transform, p.style.map.terrain);
                    let Ne, ot;
                    const et = x.paint.get("raster-resampling") === "nearest" ? R.NEAREST : R.LINEAR;
                    M.activeTexture.set(R.TEXTURE0), ie.texture.bind(et, R.CLAMP_TO_EDGE, R.LINEAR_MIPMAP_NEAREST), M.activeTexture.set(R.TEXTURE1), le ? (le.texture.bind(et, R.CLAMP_TO_EDGE, R.LINEAR_MIPMAP_NEAREST), Ne = Math.pow(2, le.tileID.overscaledZ - ie.tileID.overscaledZ), ot = [ie.tileID.canonical.x * Ne % 1, ie.tileID.canonical.y * Ne % 1]) : ie.texture.bind(et, R.CLAMP_TO_EDGE, R.LINEAR_MIPMAP_NEAREST);
                    const rt = p.style.map.terrain && p.style.map.terrain.getTerrainData(fe), $e = rt ? fe : null, Ct = $e ? $e.posMatrix : p.transform.calculatePosMatrix(fe.toUnwrapped(), K), qt = bc(Ct, ot || [0, 0], Ne || 1, Me, x);
                    O instanceof nn ? D.draw(M, R.TRIANGLES, ne, kn.disabled, U, Zn.disabled, qt, rt, x.id, O.boundsBuffer, p.quadTriangleIndexBuffer, O.boundsSegments) : D.draw(M, R.TRIANGLES, ne, W[fe.overscaledZ], U, Zn.disabled, qt, rt, x.id, p.rasterBoundsBuffer, p.quadTriangleIndexBuffer, p.rasterBoundsSegments);
                  }
                })(a, f, _, h);
                break;
              case "background":
                (function(p, b, x, C) {
                  const M = x.paint.get("background-color"), R = x.paint.get("background-opacity");
                  if (R === 0)
                    return;
                  const O = p.context, D = O.gl, U = p.transform, W = U.tileSize, Q = x.paint.get("background-pattern");
                  if (p.isPatternMissing(Q))
                    return;
                  const Y = !Q && M.a === 1 && R === 1 && p.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                  if (p.renderPass !== Y)
                    return;
                  const K = kn.disabled, fe = p.depthModeForSublayer(0, Y === "opaque" ? fn.ReadWrite : fn.ReadOnly), ne = p.colorModeForRenderPass(), ie = p.useProgram(Q ? "backgroundPattern" : "background"), le = C || U.coveringTiles({ tileSize: W, terrain: p.style.map.terrain });
                  Q && (O.activeTexture.set(D.TEXTURE0), p.imageManager.bind(p.context));
                  const xe = x.getCrossfadeParameters();
                  for (const Me of le) {
                    const Ne = C ? Me.posMatrix : p.transform.calculatePosMatrix(Me.toUnwrapped()), ot = Q ? xo(Ne, R, p, Q, { tileID: Me, tileSize: W }, xe) : bo(Ne, R, M), et = p.style.map.terrain && p.style.map.terrain.getTerrainData(Me);
                    ie.draw(O, D.TRIANGLES, fe, K, ne, Zn.disabled, ot, et, x.id, p.tileExtentBuffer, p.quadTriangleIndexBuffer, p.tileExtentSegments);
                  }
                })(a, 0, _, h);
                break;
              case "custom":
                (function(p, b, x) {
                  const C = p.context, M = x.implementation;
                  if (p.renderPass === "offscreen") {
                    const R = M.prerender;
                    R && (p.setCustomLayerDefaults(), C.setColorMode(p.colorModeForRenderPass()), R.call(M, C.gl, p.transform.customLayerMatrix()), C.setDirty(), p.setBaseState());
                  } else if (p.renderPass === "translucent") {
                    p.setCustomLayerDefaults(), C.setColorMode(p.colorModeForRenderPass()), C.setStencilMode(kn.disabled);
                    const R = M.renderingMode === "3d" ? new fn(p.context.gl.LEQUAL, fn.ReadWrite, p.depthRangeFor3D) : p.depthModeForSublayer(0, fn.ReadOnly);
                    C.setDepthMode(R), M.render(C.gl, p.transform.customLayerMatrix()), C.setDirty(), p.setBaseState(), C.bindFramebuffer.set(null);
                  }
                })(a, 0, _);
            }
        }
        translatePosMatrix(a, f, _, h, p) {
          if (!_[0] && !_[1])
            return a;
          const b = p ? h === "map" ? this.transform.angle : 0 : h === "viewport" ? -this.transform.angle : 0;
          if (b) {
            const M = Math.sin(b), R = Math.cos(b);
            _ = [_[0] * R - _[1] * M, _[0] * M + _[1] * R];
          }
          const x = [p ? _[0] : an(f, _[0], this.transform.zoom), p ? _[1] : an(f, _[1], this.transform.zoom), 0], C = new Float32Array(16);
          return l.J(C, a, x), C;
        }
        saveTileTexture(a) {
          const f = this._tileTextures[a.size[0]];
          f ? f.push(a) : this._tileTextures[a.size[0]] = [a];
        }
        getTileTexture(a) {
          const f = this._tileTextures[a];
          return f && f.length > 0 ? f.pop() : null;
        }
        isPatternMissing(a) {
          if (!a)
            return !1;
          if (!a.from || !a.to)
            return !0;
          const f = this.imageManager.getPattern(a.from.toString()), _ = this.imageManager.getPattern(a.to.toString());
          return !f || !_;
        }
        useProgram(a, f) {
          this.cache = this.cache || {};
          const _ = a + (f ? f.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.map.terrain ? "/terrain" : "");
          return this.cache[_] || (this.cache[_] = new ue(this.context, Xr[a], f, Ol[a], this._showOverdrawInspector, this.style.map.terrain)), this.cache[_];
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          const a = this.context.gl;
          this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(a.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new ae(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
        }
        destroy() {
          this.debugOverlayTexture && this.debugOverlayTexture.destroy();
        }
        overLimit() {
          const { drawingBufferWidth: a, drawingBufferHeight: f } = this.context.gl;
          return this.width !== a || this.height !== f;
        }
      }
      class Zr {
        constructor(a, f) {
          this.points = a, this.planes = f;
        }
        static fromInvProjectionMatrix(a, f, _) {
          const h = Math.pow(2, _), p = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((x) => {
            const C = 1 / (x = l.ag([], x, a))[3] / f * h;
            return l.b1(x, x, [C, C, 1 / x[3], C]);
          }), b = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((x) => {
            const C = function(D, U) {
              var W = U[0], Q = U[1], Y = U[2], K = W * W + Q * Q + Y * Y;
              return K > 0 && (K = 1 / Math.sqrt(K)), D[0] = U[0] * K, D[1] = U[1] * K, D[2] = U[2] * K, D;
            }([], function(D, U, W) {
              var Q = U[0], Y = U[1], K = U[2], fe = W[0], ne = W[1], ie = W[2];
              return D[0] = Y * ie - K * ne, D[1] = K * fe - Q * ie, D[2] = Q * ne - Y * fe, D;
            }([], Le([], p[x[0]], p[x[1]]), Le([], p[x[2]], p[x[1]]))), M = -((R = C)[0] * (O = p[x[1]])[0] + R[1] * O[1] + R[2] * O[2]);
            var R, O;
            return C.concat(M);
          });
          return new Zr(p, b);
        }
      }
      class Zo {
        constructor(a, f) {
          this.min = a, this.max = f, this.center = function(_, h, p) {
            return _[0] = 0.5 * h[0], _[1] = 0.5 * h[1], _[2] = 0.5 * h[2], _;
          }([], function(_, h, p) {
            return _[0] = h[0] + p[0], _[1] = h[1] + p[1], _[2] = h[2] + p[2], _;
          }([], this.min, this.max));
        }
        quadrant(a) {
          const f = [a % 2 == 0, a < 2], _ = Se(this.min), h = Se(this.max);
          for (let p = 0; p < f.length; p++)
            _[p] = f[p] ? this.min[p] : this.center[p], h[p] = f[p] ? this.center[p] : this.max[p];
          return h[2] = this.max[2], new Zo(_, h);
        }
        distanceX(a) {
          return Math.max(Math.min(this.max[0], a[0]), this.min[0]) - a[0];
        }
        distanceY(a) {
          return Math.max(Math.min(this.max[1], a[1]), this.min[1]) - a[1];
        }
        intersects(a) {
          const f = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]];
          let _ = !0;
          for (let h = 0; h < a.planes.length; h++) {
            const p = a.planes[h];
            let b = 0;
            for (let x = 0; x < f.length; x++)
              l.b2(p, f[x]) >= 0 && b++;
            if (b === 0)
              return 0;
            b !== f.length && (_ = !1);
          }
          if (_)
            return 2;
          for (let h = 0; h < 3; h++) {
            let p = Number.MAX_VALUE, b = -Number.MAX_VALUE;
            for (let x = 0; x < a.points.length; x++) {
              const C = a.points[x][h] - this.min[h];
              p = Math.min(p, C), b = Math.max(b, C);
            }
            if (b < 0 || p > this.max[h] - this.min[h])
              return 0;
          }
          return 1;
        }
      }
      class os {
        constructor() {
          let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, _ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
          if (isNaN(a) || a < 0 || isNaN(f) || f < 0 || isNaN(_) || _ < 0 || isNaN(h) || h < 0)
            throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
          this.top = a, this.bottom = f, this.left = _, this.right = h;
        }
        interpolate(a, f, _) {
          return f.top != null && a.top != null && (this.top = l.z.number(a.top, f.top, _)), f.bottom != null && a.bottom != null && (this.bottom = l.z.number(a.bottom, f.bottom, _)), f.left != null && a.left != null && (this.left = l.z.number(a.left, f.left, _)), f.right != null && a.right != null && (this.right = l.z.number(a.right, f.right, _)), this;
        }
        getCenter(a, f) {
          const _ = l.ad((this.left + a - this.right) / 2, 0, a), h = l.ad((this.top + f - this.bottom) / 2, 0, f);
          return new l.P(_, h);
        }
        equals(a) {
          return this.top === a.top && this.bottom === a.bottom && this.left === a.left && this.right === a.right;
        }
        clone() {
          return new os(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        }
      }
      const Sa = 85.051129;
      class al {
        constructor(a, f, _, h, p) {
          this.tileSize = 512, this._renderWorldCopies = p === void 0 || !!p, this._minZoom = a || 0, this._maxZoom = f || 22, this._minPitch = _ ?? 0, this._maxPitch = h ?? 60, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new l.N(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = !0, this._edgeInsets = new os(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this._fogMatrixCache = {}, this.minElevationForCurrentTile = 0;
        }
        clone() {
          const a = new al(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
          return a.apply(this), a;
        }
        apply(a) {
          this.tileSize = a.tileSize, this.latRange = a.latRange, this.width = a.width, this.height = a.height, this._center = a._center, this._elevation = a._elevation, this.minElevationForCurrentTile = a.minElevationForCurrentTile, this.zoom = a.zoom, this.angle = a.angle, this._fov = a._fov, this._pitch = a._pitch, this._unmodified = a._unmodified, this._edgeInsets = a._edgeInsets.clone(), this._calcMatrices();
        }
        get minZoom() {
          return this._minZoom;
        }
        set minZoom(a) {
          this._minZoom !== a && (this._minZoom = a, this.zoom = Math.max(this.zoom, a));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        set maxZoom(a) {
          this._maxZoom !== a && (this._maxZoom = a, this.zoom = Math.min(this.zoom, a));
        }
        get minPitch() {
          return this._minPitch;
        }
        set minPitch(a) {
          this._minPitch !== a && (this._minPitch = a, this.pitch = Math.max(this.pitch, a));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        set maxPitch(a) {
          this._maxPitch !== a && (this._maxPitch = a, this.pitch = Math.min(this.pitch, a));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies;
        }
        set renderWorldCopies(a) {
          a === void 0 ? a = !0 : a === null && (a = !1), this._renderWorldCopies = a;
        }
        get worldSize() {
          return this.tileSize * this.scale;
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new l.P(this.width, this.height);
        }
        get bearing() {
          return -this.angle / Math.PI * 180;
        }
        set bearing(a) {
          const f = -l.b3(a, -180, 180) * Math.PI / 180;
          this.angle !== f && (this._unmodified = !1, this.angle = f, this._calcMatrices(), this.rotationMatrix = function() {
            var _ = new l.A(4);
            return l.A != Float32Array && (_[1] = 0, _[2] = 0), _[0] = 1, _[3] = 1, _;
          }(), function(_, h, p) {
            var b = h[0], x = h[1], C = h[2], M = h[3], R = Math.sin(p), O = Math.cos(p);
            _[0] = b * O + C * R, _[1] = x * O + M * R, _[2] = b * -R + C * O, _[3] = x * -R + M * O;
          }(this.rotationMatrix, this.rotationMatrix, this.angle));
        }
        get pitch() {
          return this._pitch / Math.PI * 180;
        }
        set pitch(a) {
          const f = l.ad(a, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitch !== f && (this._unmodified = !1, this._pitch = f, this._calcMatrices());
        }
        get fov() {
          return this._fov / Math.PI * 180;
        }
        set fov(a) {
          a = Math.max(0.01, Math.min(60, a)), this._fov !== a && (this._unmodified = !1, this._fov = a / 180 * Math.PI, this._calcMatrices());
        }
        get zoom() {
          return this._zoom;
        }
        set zoom(a) {
          const f = Math.min(Math.max(a, this.minZoom), this.maxZoom);
          this._zoom !== f && (this._unmodified = !1, this._zoom = f, this.tileZoom = Math.max(0, Math.floor(f)), this.scale = this.zoomScale(f), this._constrain(), this._calcMatrices());
        }
        get center() {
          return this._center;
        }
        set center(a) {
          a.lat === this._center.lat && a.lng === this._center.lng || (this._unmodified = !1, this._center = a, this._constrain(), this._calcMatrices());
        }
        get elevation() {
          return this._elevation;
        }
        set elevation(a) {
          a !== this._elevation && (this._elevation = a, this._constrain(), this._calcMatrices());
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        set padding(a) {
          this._edgeInsets.equals(a) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, a, 1), this._calcMatrices());
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this.width, this.height);
        }
        isPaddingEqual(a) {
          return this._edgeInsets.equals(a);
        }
        interpolatePadding(a, f, _) {
          this._unmodified = !1, this._edgeInsets.interpolate(a, f, _), this._constrain(), this._calcMatrices();
        }
        coveringZoomLevel(a) {
          const f = (a.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / a.tileSize));
          return Math.max(0, f);
        }
        getVisibleUnwrappedCoordinates(a) {
          const f = [new l.b4(0, a)];
          if (this._renderWorldCopies) {
            const _ = this.pointCoordinate(new l.P(0, 0)), h = this.pointCoordinate(new l.P(this.width, 0)), p = this.pointCoordinate(new l.P(this.width, this.height)), b = this.pointCoordinate(new l.P(0, this.height)), x = Math.floor(Math.min(_.x, h.x, p.x, b.x)), C = Math.floor(Math.max(_.x, h.x, p.x, b.x)), M = 1;
            for (let R = x - M; R <= C + M; R++)
              R !== 0 && f.push(new l.b4(R, a));
          }
          return f;
        }
        coveringTiles(a) {
          var f, _;
          let h = this.coveringZoomLevel(a);
          const p = h;
          if (a.minzoom !== void 0 && h < a.minzoom)
            return [];
          a.maxzoom !== void 0 && h > a.maxzoom && (h = a.maxzoom);
          const b = this.pointCoordinate(this.getCameraPoint()), x = l.Z.fromLngLat(this.center), C = Math.pow(2, h), M = [C * b.x, C * b.y, 0], R = [C * x.x, C * x.y, 0], O = Zr.fromInvProjectionMatrix(this.invModelViewProjectionMatrix, this.worldSize, h);
          let D = a.minzoom || 0;
          !a.terrain && this.pitch <= 60 && this._edgeInsets.top < 0.1 && (D = h);
          const U = a.terrain ? 2 / Math.min(this.tileSize, a.tileSize) * this.tileSize : 3, W = (ne) => ({ aabb: new Zo([ne * C, 0, 0], [(ne + 1) * C, C, 0]), zoom: 0, x: 0, y: 0, wrap: ne, fullyVisible: !1 }), Q = [], Y = [], K = h, fe = a.reparseOverscaled ? p : h;
          if (this._renderWorldCopies)
            for (let ne = 1; ne <= 3; ne++)
              Q.push(W(-ne)), Q.push(W(ne));
          for (Q.push(W(0)); Q.length > 0; ) {
            const ne = Q.pop(), ie = ne.x, le = ne.y;
            let xe = ne.fullyVisible;
            if (!xe) {
              const rt = ne.aabb.intersects(O);
              if (rt === 0)
                continue;
              xe = rt === 2;
            }
            const Me = a.terrain ? M : R, Ne = ne.aabb.distanceX(Me), ot = ne.aabb.distanceY(Me), et = Math.max(Math.abs(Ne), Math.abs(ot));
            if (ne.zoom === K || et > U + (1 << K - ne.zoom) - 2 && ne.zoom >= D) {
              const rt = K - ne.zoom, $e = M[0] - 0.5 - (ie << rt), Ct = M[1] - 0.5 - (le << rt);
              Y.push({ tileID: new l.S(ne.zoom === K ? fe : ne.zoom, ne.wrap, ne.zoom, ie, le), distanceSq: ye([R[0] - 0.5 - ie, R[1] - 0.5 - le]), tileDistanceToCamera: Math.sqrt($e * $e + Ct * Ct) });
            } else
              for (let rt = 0; rt < 4; rt++) {
                const $e = (ie << 1) + rt % 2, Ct = (le << 1) + (rt >> 1), qt = ne.zoom + 1;
                let yt = ne.aabb.quadrant(rt);
                if (a.terrain) {
                  const vt = new l.S(qt, ne.wrap, qt, $e, Ct), Ht = a.terrain.getMinMaxElevation(vt), Sn = (f = Ht.minElevation) !== null && f !== void 0 ? f : this.elevation, Ot = (_ = Ht.maxElevation) !== null && _ !== void 0 ? _ : this.elevation;
                  yt = new Zo([yt.min[0], yt.min[1], Sn], [yt.max[0], yt.max[1], Ot]);
                }
                Q.push({ aabb: yt, zoom: qt, x: $e, y: Ct, wrap: ne.wrap, fullyVisible: xe });
              }
          }
          return Y.sort((ne, ie) => ne.distanceSq - ie.distanceSq).map((ne) => ne.tileID);
        }
        resize(a, f) {
          this.width = a, this.height = f, this.pixelsToGLUnits = [2 / a, -2 / f], this._constrain(), this._calcMatrices();
        }
        get unmodified() {
          return this._unmodified;
        }
        zoomScale(a) {
          return Math.pow(2, a);
        }
        scaleZoom(a) {
          return Math.log(a) / Math.LN2;
        }
        project(a) {
          const f = l.ad(a.lat, -85.051129, Sa);
          return new l.P(l.O(a.lng) * this.worldSize, l.Q(f) * this.worldSize);
        }
        unproject(a) {
          return new l.Z(a.x / this.worldSize, a.y / this.worldSize).toLngLat();
        }
        get point() {
          return this.project(this.center);
        }
        getCameraPosition() {
          return { lngLat: this.pointLocation(this.getCameraPoint()), altitude: Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter + this.elevation };
        }
        recalculateZoom(a) {
          const f = this.elevation, _ = Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter, h = this.pointLocation(this.centerPoint, a), p = a.getElevationForLngLatZoom(h, this.tileZoom);
          if (!(this.elevation - p))
            return;
          const b = _ + f - p, x = Math.cos(this._pitch) * this.cameraToCenterDistance / b / l.b5(1, h.lat), C = this.scaleZoom(x / this.tileSize);
          this._elevation = p, this._center = h, this.zoom = C;
        }
        setLocationAtPoint(a, f) {
          const _ = this.pointCoordinate(f), h = this.pointCoordinate(this.centerPoint), p = this.locationCoordinate(a), b = new l.Z(p.x - (_.x - h.x), p.y - (_.y - h.y));
          this.center = this.coordinateLocation(b), this._renderWorldCopies && (this.center = this.center.wrap());
        }
        locationPoint(a, f) {
          return f ? this.coordinatePoint(this.locationCoordinate(a), f.getElevationForLngLatZoom(a, this.tileZoom), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(a));
        }
        pointLocation(a, f) {
          return this.coordinateLocation(this.pointCoordinate(a, f));
        }
        locationCoordinate(a) {
          return l.Z.fromLngLat(a);
        }
        coordinateLocation(a) {
          return a && a.toLngLat();
        }
        pointCoordinate(a, f) {
          if (f) {
            const D = f.pointCoordinate(a);
            if (D != null)
              return D;
          }
          const _ = [a.x, a.y, 0, 1], h = [a.x, a.y, 1, 1];
          l.ag(_, _, this.pixelMatrixInverse), l.ag(h, h, this.pixelMatrixInverse);
          const p = _[3], b = h[3], x = _[1] / p, C = h[1] / b, M = _[2] / p, R = h[2] / b, O = M === R ? 0 : (0 - M) / (R - M);
          return new l.Z(l.z.number(_[0] / p, h[0] / b, O) / this.worldSize, l.z.number(x, C, O) / this.worldSize);
        }
        coordinatePoint(a) {
          let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, _ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.pixelMatrix;
          const h = [a.x * this.worldSize, a.y * this.worldSize, f, 1];
          return l.ag(h, h, _), new l.P(h[0] / h[3], h[1] / h[3]);
        }
        getBounds() {
          const a = Math.max(0, this.height / 2 - this.getHorizon());
          return new re().extend(this.pointLocation(new l.P(0, a))).extend(this.pointLocation(new l.P(this.width, a))).extend(this.pointLocation(new l.P(this.width, this.height))).extend(this.pointLocation(new l.P(0, this.height)));
        }
        getMaxBounds() {
          return this.latRange && this.latRange.length === 2 && this.lngRange && this.lngRange.length === 2 ? new re([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
        }
        getHorizon() {
          return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;
        }
        setMaxBounds(a) {
          a ? (this.lngRange = [a.getWest(), a.getEast()], this.latRange = [a.getSouth(), a.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-85.051129, Sa]);
        }
        calculateTileMatrix(a) {
          const f = a.canonical, _ = this.worldSize / this.zoomScale(f.z), h = f.x + Math.pow(2, f.z) * a.wrap, p = l.ao(new Float64Array(16));
          return l.J(p, p, [h * _, f.y * _, 0]), l.K(p, p, [_ / l.X, _ / l.X, 1]), p;
        }
        calculatePosMatrix(a) {
          let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
          const _ = a.key, h = f ? this._alignedPosMatrixCache : this._posMatrixCache;
          if (h[_])
            return h[_];
          const p = this.calculateTileMatrix(a);
          return l.L(p, f ? this.alignedModelViewProjectionMatrix : this.modelViewProjectionMatrix, p), h[_] = new Float32Array(p), h[_];
        }
        calculateFogMatrix(a) {
          const f = a.key, _ = this._fogMatrixCache;
          if (_[f])
            return _[f];
          const h = this.calculateTileMatrix(a);
          return l.L(h, this.fogMatrix, h), _[f] = new Float32Array(h), _[f];
        }
        customLayerMatrix() {
          return this.mercatorMatrix.slice();
        }
        getConstrained(a, f) {
          f = l.ad(+f, this.minZoom, this.maxZoom);
          const _ = { center: new l.N(a.lng, a.lat), zoom: f };
          let h = this.lngRange;
          if (!this._renderWorldCopies && h === null) {
            const ne = 179.9999999999;
            h = [-ne, ne];
          }
          const p = this.tileSize * this.zoomScale(_.zoom);
          let b = 0, x = p, C = 0, M = p, R = 0, O = 0;
          const { x: D, y: U } = this.size;
          if (this.latRange) {
            const ne = this.latRange;
            b = l.Q(ne[1]) * p, x = l.Q(ne[0]) * p, x - b < U && (R = U / (x - b));
          }
          h && (C = l.b3(l.O(h[0]) * p, 0, p), M = l.b3(l.O(h[1]) * p, 0, p), M < C && (M += p), M - C < D && (O = D / (M - C)));
          const { x: W, y: Q } = this.project.call({ worldSize: p }, a);
          let Y, K;
          const fe = Math.max(O || 0, R || 0);
          if (fe) {
            const ne = new l.P(O ? (M + C) / 2 : W, R ? (x + b) / 2 : Q);
            return _.center = this.unproject.call({ worldSize: p }, ne).wrap(), _.zoom += this.scaleZoom(fe), _;
          }
          if (this.latRange) {
            const ne = U / 2;
            Q - ne < b && (K = b + ne), Q + ne > x && (K = x - ne);
          }
          if (h) {
            const ne = (C + M) / 2;
            let ie = W;
            this._renderWorldCopies && (ie = l.b3(W, ne - p / 2, ne + p / 2));
            const le = D / 2;
            ie - le < C && (Y = C + le), ie + le > M && (Y = M - le);
          }
          if (Y !== void 0 || K !== void 0) {
            const ne = new l.P(Y ?? W, K ?? Q);
            _.center = this.unproject.call({ worldSize: p }, ne).wrap();
          }
          return _;
        }
        _constrain() {
          if (!this.center || !this.width || !this.height || this._constraining)
            return;
          this._constraining = !0;
          const a = this._unmodified, { center: f, zoom: _ } = this.getConstrained(this.center, this.zoom);
          this.center = f, this.zoom = _, this._unmodified = a, this._constraining = !1;
        }
        _calcMatrices() {
          if (!this.height)
            return;
          const a = this.centerOffset, f = this.point.x, _ = this.point.y;
          this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height, this._pixelPerMeter = l.b5(1, this.center.lat) * this.worldSize;
          let h = l.ao(new Float64Array(16));
          l.K(h, h, [this.width / 2, -this.height / 2, 1]), l.J(h, h, [1, -1, 0]), this.labelPlaneMatrix = h, h = l.ao(new Float64Array(16)), l.K(h, h, [1, -1, 1]), l.J(h, h, [-1, -1, 0]), l.K(h, h, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = h;
          const p = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch), b = Math.min(this.elevation, this.minElevationForCurrentTile), x = p - b * this._pixelPerMeter / Math.cos(this._pitch), C = b < 0 ? x : p, M = Math.PI / 2 + this._pitch, R = this._fov * (0.5 + a.y / this.height), O = Math.sin(R) * C / Math.sin(l.ad(Math.PI - M - R, 0.01, Math.PI - 0.01)), D = this.getHorizon(), U = 2 * Math.atan(D / this.cameraToCenterDistance) * (0.5 + a.y / (2 * D)), W = Math.sin(U) * C / Math.sin(l.ad(Math.PI - M - U, 0.01, Math.PI - 0.01)), Q = Math.min(O, W), Y = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * Q + C), K = this.height / 50;
          h = new Float64Array(16), l.b6(h, this._fov, this.width / this.height, K, Y), h[8] = 2 * -a.x / this.width, h[9] = 2 * a.y / this.height, l.K(h, h, [1, -1, 1]), l.J(h, h, [0, 0, -this.cameraToCenterDistance]), l.b7(h, h, this._pitch), l.ae(h, h, this.angle), l.J(h, h, [-f, -_, 0]), this.mercatorMatrix = l.K([], h, [this.worldSize, this.worldSize, this.worldSize]), l.K(h, h, [1, 1, this._pixelPerMeter]), this.pixelMatrix = l.L(new Float64Array(16), this.labelPlaneMatrix, h), l.J(h, h, [0, 0, -this.elevation]), this.modelViewProjectionMatrix = h, this.invModelViewProjectionMatrix = l.at([], h), this.fogMatrix = new Float64Array(16), l.b6(this.fogMatrix, this._fov, this.width / this.height, p, Y), this.fogMatrix[8] = 2 * -a.x / this.width, this.fogMatrix[9] = 2 * a.y / this.height, l.K(this.fogMatrix, this.fogMatrix, [1, -1, 1]), l.J(this.fogMatrix, this.fogMatrix, [0, 0, -this.cameraToCenterDistance]), l.b7(this.fogMatrix, this.fogMatrix, this._pitch), l.ae(this.fogMatrix, this.fogMatrix, this.angle), l.J(this.fogMatrix, this.fogMatrix, [-f, -_, 0]), l.K(this.fogMatrix, this.fogMatrix, [1, 1, this._pixelPerMeter]), l.J(this.fogMatrix, this.fogMatrix, [0, 0, -this.elevation]), this.pixelMatrix3D = l.L(new Float64Array(16), this.labelPlaneMatrix, h);
          const fe = this.width % 2 / 2, ne = this.height % 2 / 2, ie = Math.cos(this.angle), le = Math.sin(this.angle), xe = f - Math.round(f) + ie * fe + le * ne, Me = _ - Math.round(_) + ie * ne + le * fe, Ne = new Float64Array(h);
          if (l.J(Ne, Ne, [xe > 0.5 ? xe - 1 : xe, Me > 0.5 ? Me - 1 : Me, 0]), this.alignedModelViewProjectionMatrix = Ne, h = l.at(new Float64Array(16), this.pixelMatrix), !h)
            throw new Error("failed to invert matrix");
          this.pixelMatrixInverse = h, this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this._fogMatrixCache = {};
        }
        maxPitchScaleFactor() {
          if (!this.pixelMatrixInverse)
            return 1;
          const a = this.pointCoordinate(new l.P(0, 0)), f = [a.x * this.worldSize, a.y * this.worldSize, 0, 1];
          return l.ag(f, f, this.pixelMatrix)[3] / this.cameraToCenterDistance;
        }
        getCameraPoint() {
          const a = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
          return this.centerPoint.add(new l.P(0, a));
        }
        getCameraQueryGeometry(a) {
          const f = this.getCameraPoint();
          if (a.length === 1)
            return [a[0], f];
          {
            let _ = f.x, h = f.y, p = f.x, b = f.y;
            for (const x of a)
              _ = Math.min(_, x.x), h = Math.min(h, x.y), p = Math.max(p, x.x), b = Math.max(b, x.y);
            return [new l.P(_, h), new l.P(p, h), new l.P(p, b), new l.P(_, b), new l.P(_, h)];
          }
        }
        lngLatToCameraDepth(a, f) {
          const _ = this.locationCoordinate(a), h = [_.x * this.worldSize, _.y * this.worldSize, f, 1];
          return l.ag(h, h, this.modelViewProjectionMatrix), h[2] / h[3];
        }
      }
      function so(E, a) {
        var f = this;
        let _, h = !1, p = null, b = null;
        const x = () => {
          p = null, h && (E.apply(b, _), p = setTimeout(x, a), h = !1);
        };
        return function() {
          for (var C = arguments.length, M = new Array(C), R = 0; R < C; R++)
            M[R] = arguments[R];
          return h = !0, b = f, _ = M, p || x(), p;
        };
      }
      class Yr {
        constructor(a) {
          this._getCurrentHash = () => {
            const f = window.location.hash.replace("#", "");
            if (this._hashName) {
              let _;
              return f.split("&").map((h) => h.split("=")).forEach((h) => {
                h[0] === this._hashName && (_ = h);
              }), (_ && _[1] || "").split("/");
            }
            return f.split("/");
          }, this._onHashChange = () => {
            const f = this._getCurrentHash();
            if (f.length >= 3 && !f.some((_) => isNaN(_))) {
              const _ = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(f[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+f[2], +f[1]], zoom: +f[0], bearing: _, pitch: +(f[4] || 0) }), !0;
            }
            return !1;
          }, this._updateHashUnthrottled = () => {
            const f = window.location.href.replace(/(#.+)?$/, this.getHashString());
            try {
              window.history.replaceState(window.history.state, null, f);
            } catch {
            }
          }, this._updateHash = so(this._updateHashUnthrottled, 300), this._hashName = a && encodeURIComponent(a);
        }
        addTo(a) {
          return this._map = a, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
        }
        remove() {
          return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
        }
        getHashString(a) {
          const f = this._map.getCenter(), _ = Math.round(100 * this._map.getZoom()) / 100, h = Math.ceil((_ * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), p = Math.pow(10, h), b = Math.round(f.lng * p) / p, x = Math.round(f.lat * p) / p, C = this._map.getBearing(), M = this._map.getPitch();
          let R = "";
          if (R += a ? `/${b}/${x}/${_}` : `${_}/${x}/${b}`, (C || M) && (R += "/" + Math.round(10 * C) / 10), M && (R += `/${Math.round(M)}`), this._hashName) {
            const O = this._hashName;
            let D = !1;
            const U = window.location.hash.slice(1).split("&").map((W) => {
              const Q = W.split("=")[0];
              return Q === O ? (D = !0, `${Q}=${R}`) : W;
            }).filter((W) => W);
            return D || U.push(`${O}=${R}`), `#${U.join("&")}`;
          }
          return `#${R}`;
        }
      }
      const Kr = { linearity: 0.3, easing: l.b8(0, 0, 0.3, 1) }, Yo = l.e({ deceleration: 2500, maxSpeed: 1400 }, Kr), Ta = l.e({ deceleration: 20, maxSpeed: 1400 }, Kr), Ca = l.e({ deceleration: 1e3, maxSpeed: 360 }, Kr), oo = l.e({ deceleration: 1e3, maxSpeed: 90 }, Kr);
      class Ia {
        constructor(a) {
          this._map = a, this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(a) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: T.now(), settings: a });
        }
        _drainInertiaBuffer() {
          const a = this._inertiaBuffer, f = T.now();
          for (; a.length > 0 && f - a[0].time > 160; )
            a.shift();
        }
        _onMoveEnd(a) {
          if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
            return;
          const f = { zoom: 0, bearing: 0, pitch: 0, pan: new l.P(0, 0), pinchAround: void 0, around: void 0 };
          for (const { settings: p } of this._inertiaBuffer)
            f.zoom += p.zoomDelta || 0, f.bearing += p.bearingDelta || 0, f.pitch += p.pitchDelta || 0, p.panDelta && f.pan._add(p.panDelta), p.around && (f.around = p.around), p.pinchAround && (f.pinchAround = p.pinchAround);
          const _ = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, h = {};
          if (f.pan.mag()) {
            const p = Rs(f.pan.mag(), _, l.e({}, Yo, a || {}));
            h.offset = f.pan.mult(p.amount / f.pan.mag()), h.center = this._map.transform.center, Mr(h, p);
          }
          if (f.zoom) {
            const p = Rs(f.zoom, _, Ta);
            h.zoom = this._map.transform.zoom + p.amount, Mr(h, p);
          }
          if (f.bearing) {
            const p = Rs(f.bearing, _, Ca);
            h.bearing = this._map.transform.bearing + l.ad(p.amount, -179, 179), Mr(h, p);
          }
          if (f.pitch) {
            const p = Rs(f.pitch, _, oo);
            h.pitch = this._map.transform.pitch + p.amount, Mr(h, p);
          }
          if (h.zoom || h.bearing) {
            const p = f.pinchAround === void 0 ? f.around : f.pinchAround;
            h.around = p ? this._map.unproject(p) : this._map.getCenter();
          }
          return this.clear(), l.e(h, { noMoveStart: !0 });
        }
      }
      function Mr(E, a) {
        (!E.duration || E.duration < a.duration) && (E.duration = a.duration, E.easing = a.easing);
      }
      function Rs(E, a, f) {
        const { maxSpeed: _, linearity: h, deceleration: p } = f, b = l.ad(E * h / (a / 1e3), -_, _), x = Math.abs(b) / (p * h);
        return { easing: f.easing, duration: 1e3 * x, amount: b * (x / 2) };
      }
      class Gn extends l.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(a, f, _) {
          let h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          const p = I.mousePos(f.getCanvas(), _), b = f.unproject(p);
          super(a, l.e({ point: p, lngLat: b, originalEvent: _ }, h)), this._defaultPrevented = !1, this.target = f;
        }
      }
      class ci extends l.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(a, f, _) {
          const h = a === "touchend" ? _.changedTouches : _.touches, p = I.touchPos(f.getCanvasContainer(), h), b = p.map((C) => f.unproject(C)), x = p.reduce((C, M, R, O) => C.add(M.div(O.length)), new l.P(0, 0));
          super(a, { points: p, point: x, lngLats: b, lngLat: f.unproject(x), originalEvent: _ }), this._defaultPrevented = !1;
        }
      }
      class Zi extends l.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(a, f, _) {
          super(a, { originalEvent: _ }), this._defaultPrevented = !1;
        }
      }
      class tr {
        constructor(a, f) {
          this._map = a, this._clickTolerance = f.clickTolerance;
        }
        reset() {
          delete this._mousedownPos;
        }
        wheel(a) {
          return this._firePreventable(new Zi(a.type, this._map, a));
        }
        mousedown(a, f) {
          return this._mousedownPos = f, this._firePreventable(new Gn(a.type, this._map, a));
        }
        mouseup(a) {
          this._map.fire(new Gn(a.type, this._map, a));
        }
        click(a, f) {
          this._mousedownPos && this._mousedownPos.dist(f) >= this._clickTolerance || this._map.fire(new Gn(a.type, this._map, a));
        }
        dblclick(a) {
          return this._firePreventable(new Gn(a.type, this._map, a));
        }
        mouseover(a) {
          this._map.fire(new Gn(a.type, this._map, a));
        }
        mouseout(a) {
          this._map.fire(new Gn(a.type, this._map, a));
        }
        touchstart(a) {
          return this._firePreventable(new ci(a.type, this._map, a));
        }
        touchmove(a) {
          this._map.fire(new ci(a.type, this._map, a));
        }
        touchend(a) {
          this._map.fire(new ci(a.type, this._map, a));
        }
        touchcancel(a) {
          this._map.fire(new ci(a.type, this._map, a));
        }
        _firePreventable(a) {
          if (this._map.fire(a), a.defaultPrevented)
            return {};
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {
        }
        disable() {
        }
      }
      class ao {
        constructor(a) {
          this._map = a;
        }
        reset() {
          this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
        }
        mousemove(a) {
          this._map.fire(new Gn(a.type, this._map, a));
        }
        mousedown() {
          this._delayContextMenu = !0, this._ignoreContextMenu = !1;
        }
        mouseup() {
          this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Gn("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }
        contextmenu(a) {
          this._delayContextMenu ? this._contextMenuEvent = a : this._ignoreContextMenu || this._map.fire(new Gn(a.type, this._map, a)), this._map.listens("contextmenu") && a.preventDefault();
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {
        }
        disable() {
        }
      }
      class bs {
        constructor(a) {
          this._map = a;
        }
        get transform() {
          return this._map._requestedCameraState || this._map.transform;
        }
        get center() {
          return { lng: this.transform.center.lng, lat: this.transform.center.lat };
        }
        get zoom() {
          return this.transform.zoom;
        }
        get pitch() {
          return this.transform.pitch;
        }
        get bearing() {
          return this.transform.bearing;
        }
        unproject(a) {
          return this.transform.pointLocation(l.P.convert(a), this._map.terrain);
        }
      }
      class Pa {
        constructor(a, f) {
          this._map = a, this._tr = new bs(a), this._el = a.getCanvasContainer(), this._container = a.getContainer(), this._clickTolerance = f.clickTolerance || 1;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = !0);
        }
        disable() {
          this.isEnabled() && (this._enabled = !1);
        }
        mousedown(a, f) {
          this.isEnabled() && a.shiftKey && a.button === 0 && (I.disableDrag(), this._startPos = this._lastPos = f, this._active = !0);
        }
        mousemoveWindow(a, f) {
          if (!this._active)
            return;
          const _ = f;
          if (this._lastPos.equals(_) || !this._box && _.dist(this._startPos) < this._clickTolerance)
            return;
          const h = this._startPos;
          this._lastPos = _, this._box || (this._box = I.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", a));
          const p = Math.min(h.x, _.x), b = Math.max(h.x, _.x), x = Math.min(h.y, _.y), C = Math.max(h.y, _.y);
          I.setTransform(this._box, `translate(${p}px,${x}px)`), this._box.style.width = b - p + "px", this._box.style.height = C - x + "px";
        }
        mouseupWindow(a, f) {
          if (!this._active || a.button !== 0)
            return;
          const _ = this._startPos, h = f;
          if (this.reset(), I.suppressClick(), _.x !== h.x || _.y !== h.y)
            return this._map.fire(new l.k("boxzoomend", { originalEvent: a })), { cameraAnimation: (p) => p.fitScreenCoordinates(_, h, this._tr.bearing, { linear: !0 }) };
          this._fireEvent("boxzoomcancel", a);
        }
        keydown(a) {
          this._active && a.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", a));
        }
        reset() {
          this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (I.remove(this._box), this._box = null), I.enableDrag(), delete this._startPos, delete this._lastPos;
        }
        _fireEvent(a, f) {
          return this._map.fire(new l.k(a, { originalEvent: f }));
        }
      }
      function Ko(E, a) {
        if (E.length !== a.length)
          throw new Error(`The number of touches and points are not equal - touches ${E.length}, points ${a.length}`);
        const f = {};
        for (let _ = 0; _ < E.length; _++)
          f[E[_].identifier] = a[_];
        return f;
      }
      class hu {
        constructor(a) {
          this.reset(), this.numTouches = a.numTouches;
        }
        reset() {
          delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
        }
        touchstart(a, f, _) {
          (this.centroid || _.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = a.timeStamp), _.length === this.numTouches && (this.centroid = function(h) {
            const p = new l.P(0, 0);
            for (const b of h)
              p._add(b);
            return p.div(h.length);
          }(f), this.touches = Ko(_, f)));
        }
        touchmove(a, f, _) {
          if (this.aborted || !this.centroid)
            return;
          const h = Ko(_, f);
          for (const p in this.touches) {
            const b = h[p];
            (!b || b.dist(this.touches[p]) > 30) && (this.aborted = !0);
          }
        }
        touchend(a, f, _) {
          if ((!this.centroid || a.timeStamp - this.startTime > 500) && (this.aborted = !0), _.length === 0) {
            const h = !this.aborted && this.centroid;
            if (this.reset(), h)
              return h;
          }
        }
      }
      class du {
        constructor(a) {
          this.singleTap = new hu(a), this.numTaps = a.numTaps, this.reset();
        }
        reset() {
          this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
        }
        touchstart(a, f, _) {
          this.singleTap.touchstart(a, f, _);
        }
        touchmove(a, f, _) {
          this.singleTap.touchmove(a, f, _);
        }
        touchend(a, f, _) {
          const h = this.singleTap.touchend(a, f, _);
          if (h) {
            const p = a.timeStamp - this.lastTime < 500, b = !this.lastTap || this.lastTap.dist(h) < 30;
            if (p && b || this.reset(), this.count++, this.lastTime = a.timeStamp, this.lastTap = h, this.count === this.numTaps)
              return this.reset(), h;
          }
        }
      }
      class eh {
        constructor(a) {
          this._tr = new bs(a), this._zoomIn = new du({ numTouches: 1, numTaps: 2 }), this._zoomOut = new du({ numTouches: 2, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(a, f, _) {
          this._zoomIn.touchstart(a, f, _), this._zoomOut.touchstart(a, f, _);
        }
        touchmove(a, f, _) {
          this._zoomIn.touchmove(a, f, _), this._zoomOut.touchmove(a, f, _);
        }
        touchend(a, f, _) {
          const h = this._zoomIn.touchend(a, f, _), p = this._zoomOut.touchend(a, f, _), b = this._tr;
          return h ? (this._active = !0, a.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (x) => x.easeTo({ duration: 300, zoom: b.zoom + 1, around: b.unproject(h) }, { originalEvent: a }) }) : p ? (this._active = !0, a.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (x) => x.easeTo({ duration: 300, zoom: b.zoom - 1, around: b.unproject(p) }, { originalEvent: a }) }) : void 0;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class wi {
        constructor(a) {
          this._enabled = !!a.enable, this._moveStateManager = a.moveStateManager, this._clickTolerance = a.clickTolerance || 1, this._moveFunction = a.move, this._activateOnStart = !!a.activateOnStart, a.assignEvents(this), this.reset();
        }
        reset(a) {
          this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(a);
        }
        _move() {
          const a = this._moveFunction(...arguments);
          if (a.bearingDelta || a.pitchDelta || a.around || a.panDelta)
            return this._active = !0, a;
        }
        dragStart(a, f) {
          this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(a) && (this._moveStateManager.startMove(a), this._lastPoint = f.length ? f[0] : f, this._activateOnStart && this._lastPoint && (this._active = !0));
        }
        dragMove(a, f) {
          if (!this.isEnabled())
            return;
          const _ = this._lastPoint;
          if (!_)
            return;
          if (a.preventDefault(), !this._moveStateManager.isValidMoveEvent(a))
            return void this.reset(a);
          const h = f.length ? f[0] : f;
          return !this._moved && h.dist(_) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = h, this._move(_, h));
        }
        dragEnd(a) {
          this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(a) && (this._moved && I.suppressClick(), this.reset(a));
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        getClickTolerance() {
          return this._clickTolerance;
        }
      }
      const La = { 0: 1, 2: 2 };
      class Qr {
        constructor(a) {
          this._correctEvent = a.checkCorrectEvent;
        }
        startMove(a) {
          const f = I.mouseButton(a);
          this._eventButton = f;
        }
        endMove(a) {
          delete this._eventButton;
        }
        isValidStartEvent(a) {
          return this._correctEvent(a);
        }
        isValidMoveEvent(a) {
          return !function(f, _) {
            const h = La[_];
            return f.buttons === void 0 || (f.buttons & h) !== h;
          }(a, this._eventButton);
        }
        isValidEndEvent(a) {
          return I.mouseButton(a) === this._eventButton;
        }
      }
      class Gl {
        constructor() {
          this._firstTouch = void 0;
        }
        _isOneFingerTouch(a) {
          return a.targetTouches.length === 1;
        }
        _isSameTouchEvent(a) {
          return a.targetTouches[0].identifier === this._firstTouch;
        }
        startMove(a) {
          this._firstTouch = a.targetTouches[0].identifier;
        }
        endMove(a) {
          delete this._firstTouch;
        }
        isValidStartEvent(a) {
          return this._isOneFingerTouch(a);
        }
        isValidMoveEvent(a) {
          return this._isOneFingerTouch(a) && this._isSameTouchEvent(a);
        }
        isValidEndEvent(a) {
          return this._isOneFingerTouch(a) && this._isSameTouchEvent(a);
        }
      }
      const Ma = (E) => {
        E.mousedown = E.dragStart, E.mousemoveWindow = E.dragMove, E.mouseup = E.dragEnd, E.contextmenu = (a) => {
          a.preventDefault();
        };
      }, es = (E) => {
        let { enable: a, clickTolerance: f, bearingDegreesPerPixelMoved: _ = 0.8 } = E;
        const h = new Qr({ checkCorrectEvent: (p) => I.mouseButton(p) === 0 && p.ctrlKey || I.mouseButton(p) === 2 });
        return new wi({ clickTolerance: f, move: (p, b) => ({ bearingDelta: (b.x - p.x) * _ }), moveStateManager: h, enable: a, assignEvents: Ma });
      }, wr = (E) => {
        let { enable: a, clickTolerance: f, pitchDegreesPerPixelMoved: _ = -0.5 } = E;
        const h = new Qr({ checkCorrectEvent: (p) => I.mouseButton(p) === 0 && p.ctrlKey || I.mouseButton(p) === 2 });
        return new wi({ clickTolerance: f, move: (p, b) => ({ pitchDelta: (b.y - p.y) * _ }), moveStateManager: h, enable: a, assignEvents: Ma });
      };
      class Ba {
        constructor(a, f) {
          this._clickTolerance = a.clickTolerance || 1, this._map = f, this.reset();
        }
        reset() {
          this._active = !1, this._touches = {}, this._sum = new l.P(0, 0);
        }
        minTouchs() {
          return this._map.cooperativeGestures.isEnabled() ? 2 : 1;
        }
        touchstart(a, f, _) {
          return this._calculateTransform(a, f, _);
        }
        touchmove(a, f, _) {
          if (this._active && !(_.length < this.minTouchs()))
            return a.preventDefault(), this._calculateTransform(a, f, _);
        }
        touchend(a, f, _) {
          this._calculateTransform(a, f, _), this._active && _.length < this.minTouchs() && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(a, f, _) {
          _.length > 0 && (this._active = !0);
          const h = Ko(_, f), p = new l.P(0, 0), b = new l.P(0, 0);
          let x = 0;
          for (const M in h) {
            const R = h[M], O = this._touches[M];
            O && (p._add(R), b._add(R.sub(O)), x++, h[M] = R);
          }
          if (this._touches = h, x < this.minTouchs() || !b.mag())
            return;
          const C = b.div(x);
          return this._sum._add(C), this._sum.mag() < this._clickTolerance ? void 0 : { around: p.div(x), panDelta: C };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Ra {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = !1, delete this._firstTwoTouches;
        }
        touchstart(a, f, _) {
          this._firstTwoTouches || _.length < 2 || (this._firstTwoTouches = [_[0].identifier, _[1].identifier], this._start([f[0], f[1]]));
        }
        touchmove(a, f, _) {
          if (!this._firstTwoTouches)
            return;
          a.preventDefault();
          const [h, p] = this._firstTwoTouches, b = Vl(_, f, h), x = Vl(_, f, p);
          if (!b || !x)
            return;
          const C = this._aroundCenter ? null : b.add(x).div(2);
          return this._move([b, x], C, a);
        }
        touchend(a, f, _) {
          if (!this._firstTwoTouches)
            return;
          const [h, p] = this._firstTwoTouches, b = Vl(_, f, h), x = Vl(_, f, p);
          b && x || (this._active && I.suppressClick(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(a) {
          this._enabled = !0, this._aroundCenter = !!a && a.around === "center";
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
      }
      function Vl(E, a, f) {
        for (let _ = 0; _ < E.length; _++)
          if (E[_].identifier === f)
            return a[_];
      }
      function ql(E, a) {
        return Math.log(E / a) / Math.LN2;
      }
      class Hl extends Ra {
        reset() {
          super.reset(), delete this._distance, delete this._startDistance;
        }
        _start(a) {
          this._startDistance = this._distance = a[0].dist(a[1]);
        }
        _move(a, f) {
          const _ = this._distance;
          if (this._distance = a[0].dist(a[1]), this._active || !(Math.abs(ql(this._distance, this._startDistance)) < 0.1))
            return this._active = !0, { zoomDelta: ql(this._distance, _), pinchAround: f };
        }
      }
      function Tc(E, a) {
        return 180 * E.angleWith(a) / Math.PI;
      }
      class fu extends Ra {
        reset() {
          super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
        }
        _start(a) {
          this._startVector = this._vector = a[0].sub(a[1]), this._minDiameter = a[0].dist(a[1]);
        }
        _move(a, f, _) {
          const h = this._vector;
          if (this._vector = a[0].sub(a[1]), this._active || !this._isBelowThreshold(this._vector))
            return this._active = !0, { bearingDelta: Tc(this._vector, h), pinchAround: f };
        }
        _isBelowThreshold(a) {
          this._minDiameter = Math.min(this._minDiameter, a.mag());
          const f = 25 / (Math.PI * this._minDiameter) * 360, _ = Tc(a, this._startVector);
          return Math.abs(_) < f;
        }
      }
      function lo(E) {
        return Math.abs(E.y) > Math.abs(E.x);
      }
      class Cc extends Ra {
        constructor(a) {
          super(), this._currentTouchCount = 0, this._map = a;
        }
        reset() {
          super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
        }
        touchstart(a, f, _) {
          super.touchstart(a, f, _), this._currentTouchCount = _.length;
        }
        _start(a) {
          this._lastPoints = a, lo(a[0].sub(a[1])) && (this._valid = !1);
        }
        _move(a, f, _) {
          if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3)
            return;
          const h = a[0].sub(this._lastPoints[0]), p = a[1].sub(this._lastPoints[1]);
          return this._valid = this.gestureBeginsVertically(h, p, _.timeStamp), this._valid ? (this._lastPoints = a, this._active = !0, { pitchDelta: (h.y + p.y) / 2 * -0.5 }) : void 0;
        }
        gestureBeginsVertically(a, f, _) {
          if (this._valid !== void 0)
            return this._valid;
          const h = a.mag() >= 2, p = f.mag() >= 2;
          if (!h && !p)
            return;
          if (!h || !p)
            return this._firstMove === void 0 && (this._firstMove = _), _ - this._firstMove < 100 && void 0;
          const b = a.y > 0 == f.y > 0;
          return lo(a) && lo(f) && b;
        }
      }
      const Ic = { panStep: 100, bearingStep: 15, pitchStep: 10 };
      class Pc {
        constructor(a) {
          this._tr = new bs(a);
          const f = Ic;
          this._panStep = f.panStep, this._bearingStep = f.bearingStep, this._pitchStep = f.pitchStep, this._rotationDisabled = !1;
        }
        reset() {
          this._active = !1;
        }
        keydown(a) {
          if (a.altKey || a.ctrlKey || a.metaKey)
            return;
          let f = 0, _ = 0, h = 0, p = 0, b = 0;
          switch (a.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              f = 1;
              break;
            case 189:
            case 109:
            case 173:
              f = -1;
              break;
            case 37:
              a.shiftKey ? _ = -1 : (a.preventDefault(), p = -1);
              break;
            case 39:
              a.shiftKey ? _ = 1 : (a.preventDefault(), p = 1);
              break;
            case 38:
              a.shiftKey ? h = 1 : (a.preventDefault(), b = -1);
              break;
            case 40:
              a.shiftKey ? h = -1 : (a.preventDefault(), b = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (_ = 0, h = 0), { cameraAnimation: (x) => {
            const C = this._tr;
            x.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Wh, zoom: f ? Math.round(C.zoom) + f * (a.shiftKey ? 2 : 1) : C.zoom, bearing: C.bearing + _ * this._bearingStep, pitch: C.pitch + h * this._pitchStep, offset: [-p * this._panStep, -b * this._panStep], center: C.center }, { originalEvent: a });
          } };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = !0;
        }
        enableRotation() {
          this._rotationDisabled = !1;
        }
      }
      function Wh(E) {
        return E * (2 - E);
      }
      const th = 4.000244140625;
      class pu {
        constructor(a, f) {
          this._onTimeout = (_) => {
            this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(_);
          }, this._map = a, this._tr = new bs(a), this._triggerRenderFrame = f, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222;
        }
        setZoomRate(a) {
          this._defaultZoomRate = a;
        }
        setWheelZoomRate(a) {
          this._wheelZoomRate = a;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active || this._finishTimeout !== void 0;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(a) {
          this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!a && a.around === "center");
        }
        disable() {
          this.isEnabled() && (this._enabled = !1);
        }
        wheel(a) {
          if (!this.isEnabled() || this._map.cooperativeGestures.isEnabled() && !a[this._map.cooperativeGestures._bypassKey])
            return;
          let f = a.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * a.deltaY : a.deltaY;
          const _ = T.now(), h = _ - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = _, f !== 0 && f % th == 0 ? this._type = "wheel" : f !== 0 && Math.abs(f) < 4 ? this._type = "trackpad" : h > 400 ? (this._type = null, this._lastValue = f, this._timeout = setTimeout(this._onTimeout, 40, a)) : this._type || (this._type = Math.abs(h * f) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, f += this._lastValue)), a.shiftKey && f && (f /= 4), this._type && (this._lastWheelEvent = a, this._delta -= f, this._active || this._start(a)), a.preventDefault();
        }
        _start(a) {
          if (!this._delta)
            return;
          this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          const f = I.mousePos(this._map.getCanvas(), a), _ = this._tr;
          this._around = f.y > _.transform.height / 2 - _.transform.getHorizon() ? l.N.convert(this._aroundCenter ? _.center : _.unproject(f)) : l.N.convert(_.center), this._aroundPoint = _.transform.locationPoint(this._around), this._frameId || (this._frameId = !0, this._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId || (this._frameId = null, !this.isActive()))
            return;
          const a = this._tr.transform;
          if (this._delta !== 0) {
            const x = this._type === "wheel" && Math.abs(this._delta) > th ? this._wheelZoomRate : this._defaultZoomRate;
            let C = 2 / (1 + Math.exp(-Math.abs(this._delta * x)));
            this._delta < 0 && C !== 0 && (C = 1 / C);
            const M = typeof this._targetZoom == "number" ? a.zoomScale(this._targetZoom) : a.scale;
            this._targetZoom = Math.min(a.maxZoom, Math.max(a.minZoom, a.scaleZoom(M * C))), this._type === "wheel" && (this._startZoom = a.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
          }
          const f = typeof this._targetZoom == "number" ? this._targetZoom : a.zoom, _ = this._startZoom, h = this._easing;
          let p, b = !1;
          if (this._type === "wheel" && _ && h) {
            const x = Math.min((T.now() - this._lastWheelEventTime) / 200, 1), C = h(x);
            p = l.z.number(_, f, C), x < 1 ? this._frameId || (this._frameId = !0) : b = !0;
          } else
            p = f, b = !0;
          return this._active = !0, b && (this._active = !1, this._finishTimeout = setTimeout(() => {
            this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
          }, 200)), { noInertia: !0, needsRenderFrame: !b, zoomDelta: p - a.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
        }
        _smoothOutEasing(a) {
          let f = l.b9;
          if (this._prevEase) {
            const _ = this._prevEase, h = (T.now() - _.start) / _.duration, p = _.easing(h + 0.01) - _.easing(h), b = 0.27 / Math.sqrt(p * p + 1e-4) * 0.01, x = Math.sqrt(0.0729 - b * b);
            f = l.b8(b, x, 0.25, 1);
          }
          return this._prevEase = { start: T.now(), duration: a, easing: f }, f;
        }
        reset() {
          this._active = !1, this._zooming = !1, delete this._targetZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
        }
      }
      class nh {
        constructor(a, f) {
          this._clickZoom = a, this._tapZoom = f;
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }
      class Lc {
        constructor(a) {
          this._tr = new bs(a), this.reset();
        }
        reset() {
          this._active = !1;
        }
        dblclick(a, f) {
          return a.preventDefault(), { cameraAnimation: (_) => {
            _.easeTo({ duration: 300, zoom: this._tr.zoom + (a.shiftKey ? -1 : 1), around: this._tr.unproject(f) }, { originalEvent: a });
          } };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Xh {
        constructor() {
          this._tap = new du({ numTouches: 1, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
        }
        touchstart(a, f, _) {
          if (!this._swipePoint)
            if (this._tapTime) {
              const h = f[0], p = a.timeStamp - this._tapTime < 500, b = this._tapPoint.dist(h) < 30;
              p && b ? _.length > 0 && (this._swipePoint = h, this._swipeTouch = _[0].identifier) : this.reset();
            } else
              this._tap.touchstart(a, f, _);
        }
        touchmove(a, f, _) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (_[0].identifier !== this._swipeTouch)
                return;
              const h = f[0], p = h.y - this._swipePoint.y;
              return this._swipePoint = h, a.preventDefault(), this._active = !0, { zoomDelta: p / 128 };
            }
          } else
            this._tap.touchmove(a, f, _);
        }
        touchend(a, f, _) {
          if (this._tapTime)
            this._swipePoint && _.length === 0 && this.reset();
          else {
            const h = this._tap.touchend(a, f, _);
            h && (this._tapTime = a.timeStamp, this._tapPoint = h);
          }
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Os {
        constructor(a, f, _) {
          this._el = a, this._mousePan = f, this._touchPan = _;
        }
        enable(a) {
          this._inertiaOptions = a || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
        }
        disable() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }
      class co {
        constructor(a, f, _) {
          this._pitchWithRotate = a.pitchWithRotate, this._mouseRotate = f, this._mousePitch = _;
        }
        enable() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
        }
        disable() {
          this._mouseRotate.disable(), this._mousePitch.disable();
        }
        isEnabled() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
        }
        isActive() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive();
        }
      }
      class Mc {
        constructor(a, f, _, h) {
          this._el = a, this._touchZoom = f, this._touchRotate = _, this._tapDragZoom = h, this._rotationDisabled = !1, this._enabled = !0;
        }
        enable(a) {
          this._touchZoom.enable(a), this._rotationDisabled || this._touchRotate.enable(a), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
        }
        disable() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
        }
        isEnabled() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }
        isActive() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }
        disableRotation() {
          this._rotationDisabled = !0, this._touchRotate.disable();
        }
        enableRotation() {
          this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }
      class xs {
        constructor(a, f) {
          this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = a, this._options = f, this._enabled = !1;
        }
        isActive() {
          return !1;
        }
        reset() {
        }
        _setupUI() {
          if (this._container)
            return;
          const a = this._map.getCanvasContainer();
          a.classList.add("maplibregl-cooperative-gestures"), this._container = I.create("div", "maplibregl-cooperative-gesture-screen", a);
          let f = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
          this._bypassKey === "metaKey" && (f = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
          const _ = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), h = document.createElement("div");
          h.className = "maplibregl-desktop-message", h.textContent = f, this._container.appendChild(h);
          const p = document.createElement("div");
          p.className = "maplibregl-mobile-message", p.textContent = _, this._container.appendChild(p), this._container.setAttribute("aria-hidden", "true");
        }
        _destoryUI() {
          this._container && (I.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
        }
        enable() {
          this._setupUI(), this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this._destoryUI();
        }
        isEnabled() {
          return this._enabled;
        }
        touchmove(a) {
          this._onCooperativeGesture(a.touches.length === 1);
        }
        wheel(a) {
          this._map.scrollZoom.isEnabled() && this._onCooperativeGesture(!a[this._bypassKey]);
        }
        _onCooperativeGesture(a) {
          this._enabled && a && (this._container.classList.add("maplibregl-show"), setTimeout(() => {
            this._container.classList.remove("maplibregl-show");
          }, 100));
        }
      }
      const ws = (E) => E.zoom || E.drag || E.pitch || E.rotate;
      class sf extends l.k {
      }
      function ih(E) {
        return E.panDelta && E.panDelta.mag() || E.zoomDelta || E.bearingDelta || E.pitchDelta;
      }
      class Jh {
        constructor(a, f) {
          this.handleWindowEvent = (h) => {
            this.handleEvent(h, `${h.type}Window`);
          }, this.handleEvent = (h, p) => {
            if (h.type === "blur")
              return void this.stop(!0);
            this._updatingCamera = !0;
            const b = h.type === "renderFrame" ? void 0 : h, x = { needsRenderFrame: !1 }, C = {}, M = {}, R = h.touches, O = R ? this._getMapTouches(R) : void 0, D = O ? I.touchPos(this._map.getCanvas(), O) : I.mousePos(this._map.getCanvas(), h);
            for (const { handlerName: Q, handler: Y, allowed: K } of this._handlers) {
              if (!Y.isEnabled())
                continue;
              let fe;
              this._blockedByActive(M, K, Q) ? Y.reset() : Y[p || h.type] && (fe = Y[p || h.type](h, D, O), this.mergeHandlerResult(x, C, fe, Q, b), fe && fe.needsRenderFrame && this._triggerRenderFrame()), (fe || Y.isActive()) && (M[Q] = Y);
            }
            const U = {};
            for (const Q in this._previousActiveHandlers)
              M[Q] || (U[Q] = b);
            this._previousActiveHandlers = M, (Object.keys(U).length || ih(x)) && (this._changes.push([x, C, U]), this._triggerRenderFrame()), (Object.keys(M).length || ih(x)) && this._map._stop(!0), this._updatingCamera = !1;
            const { cameraAnimation: W } = x;
            W && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], W(this._map));
          }, this._map = a, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Ia(a), this._bearingSnap = f.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(f);
          const _ = this._el;
          this._listeners = [[_, "touchstart", { passive: !0 }], [_, "touchmove", { passive: !1 }], [_, "touchend", void 0], [_, "touchcancel", void 0], [_, "mousedown", void 0], [_, "mousemove", void 0], [_, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [_, "mouseover", void 0], [_, "mouseout", void 0], [_, "dblclick", void 0], [_, "click", void 0], [_, "keydown", { capture: !1 }], [_, "keyup", void 0], [_, "wheel", { passive: !1 }], [_, "contextmenu", void 0], [window, "blur", void 0]];
          for (const [h, p, b] of this._listeners)
            I.addEventListener(h, p, h === document ? this.handleWindowEvent : this.handleEvent, b);
        }
        destroy() {
          for (const [a, f, _] of this._listeners)
            I.removeEventListener(a, f, a === document ? this.handleWindowEvent : this.handleEvent, _);
        }
        _addDefaultHandlers(a) {
          const f = this._map, _ = f.getCanvasContainer();
          this._add("mapEvent", new tr(f, a));
          const h = f.boxZoom = new Pa(f, a);
          this._add("boxZoom", h), a.interactive && a.boxZoom && h.enable();
          const p = f.cooperativeGestures = new xs(f, a.cooperativeGestures);
          this._add("cooperativeGestures", p), a.cooperativeGestures && p.enable();
          const b = new eh(f), x = new Lc(f);
          f.doubleClickZoom = new nh(x, b), this._add("tapZoom", b), this._add("clickZoom", x), a.interactive && a.doubleClickZoom && f.doubleClickZoom.enable();
          const C = new Xh();
          this._add("tapDragZoom", C);
          const M = f.touchPitch = new Cc(f);
          this._add("touchPitch", M), a.interactive && a.touchPitch && f.touchPitch.enable(a.touchPitch);
          const R = es(a), O = wr(a);
          f.dragRotate = new co(a, R, O), this._add("mouseRotate", R, ["mousePitch"]), this._add("mousePitch", O, ["mouseRotate"]), a.interactive && a.dragRotate && f.dragRotate.enable();
          const D = ((fe) => {
            let { enable: ne, clickTolerance: ie } = fe;
            const le = new Qr({ checkCorrectEvent: (xe) => I.mouseButton(xe) === 0 && !xe.ctrlKey });
            return new wi({ clickTolerance: ie, move: (xe, Me) => ({ around: Me, panDelta: Me.sub(xe) }), activateOnStart: !0, moveStateManager: le, enable: ne, assignEvents: Ma });
          })(a), U = new Ba(a, f);
          f.dragPan = new Os(_, D, U), this._add("mousePan", D), this._add("touchPan", U, ["touchZoom", "touchRotate"]), a.interactive && a.dragPan && f.dragPan.enable(a.dragPan);
          const W = new fu(), Q = new Hl();
          f.touchZoomRotate = new Mc(_, Q, W, C), this._add("touchRotate", W, ["touchPan", "touchZoom"]), this._add("touchZoom", Q, ["touchPan", "touchRotate"]), a.interactive && a.touchZoomRotate && f.touchZoomRotate.enable(a.touchZoomRotate);
          const Y = f.scrollZoom = new pu(f, () => this._triggerRenderFrame());
          this._add("scrollZoom", Y, ["mousePan"]), a.interactive && a.scrollZoom && f.scrollZoom.enable(a.scrollZoom);
          const K = f.keyboard = new Pc(f);
          this._add("keyboard", K), a.interactive && a.keyboard && f.keyboard.enable(), this._add("blockableMapEvent", new ao(f));
        }
        _add(a, f, _) {
          this._handlers.push({ handlerName: a, handler: f, allowed: _ }), this._handlersById[a] = f;
        }
        stop(a) {
          if (!this._updatingCamera) {
            for (const { handler: f } of this._handlers)
              f.reset();
            this._inertia.clear(), this._fireEvents({}, {}, a), this._changes = [];
          }
        }
        isActive() {
          for (const { handler: a } of this._handlers)
            if (a.isActive())
              return !0;
          return !1;
        }
        isZooming() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return !!ws(this._eventsInProgress) || this.isZooming();
        }
        _blockedByActive(a, f, _) {
          for (const h in a)
            if (h !== _ && (!f || f.indexOf(h) < 0))
              return !0;
          return !1;
        }
        _getMapTouches(a) {
          const f = [];
          for (const _ of a)
            this._el.contains(_.target) && f.push(_);
          return f;
        }
        mergeHandlerResult(a, f, _, h, p) {
          if (!_)
            return;
          l.e(a, _);
          const b = { handlerName: h, originalEvent: _.originalEvent || p };
          _.zoomDelta !== void 0 && (f.zoom = b), _.panDelta !== void 0 && (f.drag = b), _.pitchDelta !== void 0 && (f.pitch = b), _.bearingDelta !== void 0 && (f.rotate = b);
        }
        _applyChanges() {
          const a = {}, f = {}, _ = {};
          for (const [h, p, b] of this._changes)
            h.panDelta && (a.panDelta = (a.panDelta || new l.P(0, 0))._add(h.panDelta)), h.zoomDelta && (a.zoomDelta = (a.zoomDelta || 0) + h.zoomDelta), h.bearingDelta && (a.bearingDelta = (a.bearingDelta || 0) + h.bearingDelta), h.pitchDelta && (a.pitchDelta = (a.pitchDelta || 0) + h.pitchDelta), h.around !== void 0 && (a.around = h.around), h.pinchAround !== void 0 && (a.pinchAround = h.pinchAround), h.noInertia && (a.noInertia = h.noInertia), l.e(f, p), l.e(_, b);
          this._updateMapTransform(a, f, _), this._changes = [];
        }
        _updateMapTransform(a, f, _) {
          const h = this._map, p = h._getTransformForUpdate(), b = h.terrain;
          if (!(ih(a) || b && this._terrainMovement))
            return this._fireEvents(f, _, !0);
          let { panDelta: x, zoomDelta: C, bearingDelta: M, pitchDelta: R, around: O, pinchAround: D } = a;
          D !== void 0 && (O = D), h._stop(!0), O = O || h.transform.centerPoint;
          const U = p.pointLocation(x ? O.sub(x) : O);
          M && (p.bearing += M), R && (p.pitch += R), C && (p.zoom += C), b ? this._terrainMovement || !f.drag && !f.zoom ? f.drag && this._terrainMovement ? p.center = p.pointLocation(p.centerPoint.sub(x)) : p.setLocationAtPoint(U, O) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, p.setLocationAtPoint(U, O)) : p.setLocationAtPoint(U, O), h._applyUpdatedTransform(p), this._map._update(), a.noInertia || this._inertia.record(a), this._fireEvents(f, _, !0);
        }
        _fireEvents(a, f, _) {
          const h = ws(this._eventsInProgress), p = ws(a), b = {};
          for (const O in a) {
            const { originalEvent: D } = a[O];
            this._eventsInProgress[O] || (b[`${O}start`] = D), this._eventsInProgress[O] = a[O];
          }
          !h && p && this._fireEvent("movestart", p.originalEvent);
          for (const O in b)
            this._fireEvent(O, b[O]);
          p && this._fireEvent("move", p.originalEvent);
          for (const O in a) {
            const { originalEvent: D } = a[O];
            this._fireEvent(O, D);
          }
          const x = {};
          let C;
          for (const O in this._eventsInProgress) {
            const { handlerName: D, originalEvent: U } = this._eventsInProgress[O];
            this._handlersById[D].isActive() || (delete this._eventsInProgress[O], C = f[D] || U, x[`${O}end`] = C);
          }
          for (const O in x)
            this._fireEvent(O, x[O]);
          const M = ws(this._eventsInProgress), R = (h || p) && !M;
          if (R && this._terrainMovement && (this._map._elevationFreeze = !1, this._terrainMovement = !1, this._map.transform.recalculateZoom(this._map.terrain)), _ && R) {
            this._updatingCamera = !0;
            const O = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), D = (U) => U !== 0 && -this._bearingSnap < U && U < this._bearingSnap;
            !O || !O.essential && T.prefersReducedMotion ? (this._map.fire(new l.k("moveend", { originalEvent: C })), D(this._map.getBearing()) && this._map.resetNorth()) : (D(O.bearing || this._map.getBearing()) && (O.bearing = 0), O.freezeElevation = !0, this._map.easeTo(O, { originalEvent: C })), this._updatingCamera = !1;
          }
        }
        _fireEvent(a, f) {
          this._map.fire(new l.k(a, f ? { originalEvent: f } : {}));
        }
        _requestFrame() {
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add((a) => {
            delete this._frameId, this.handleEvent(new sf("renderFrame", { timeStamp: a })), this._applyChanges();
          });
        }
        _triggerRenderFrame() {
          this._frameId === void 0 && (this._frameId = this._requestFrame());
        }
      }
      class of extends l.E {
        constructor(a, f) {
          super(), this._renderFrameCallback = () => {
            const _ = Math.min((T.now() - this._easeStart) / this._easeOptions.duration, 1);
            this._onEaseFrame(this._easeOptions.easing(_)), _ < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }, this._moving = !1, this._zooming = !1, this.transform = a, this._bearingSnap = f.bearingSnap, this.on("moveend", () => {
            delete this._requestedCameraState;
          });
        }
        getCenter() {
          return new l.N(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(a, f) {
          return this.jumpTo({ center: a }, f);
        }
        panBy(a, f, _) {
          return a = l.P.convert(a).mult(-1), this.panTo(this.transform.center, l.e({ offset: a }, f), _);
        }
        panTo(a, f, _) {
          return this.easeTo(l.e({ center: a }, f), _);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(a, f) {
          return this.jumpTo({ zoom: a }, f), this;
        }
        zoomTo(a, f, _) {
          return this.easeTo(l.e({ zoom: a }, f), _);
        }
        zoomIn(a, f) {
          return this.zoomTo(this.getZoom() + 1, a, f), this;
        }
        zoomOut(a, f) {
          return this.zoomTo(this.getZoom() - 1, a, f), this;
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(a, f) {
          return this.jumpTo({ bearing: a }, f), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(a, f) {
          return this.jumpTo({ padding: a }, f), this;
        }
        rotateTo(a, f, _) {
          return this.easeTo(l.e({ bearing: a }, f), _);
        }
        resetNorth(a, f) {
          return this.rotateTo(0, l.e({ duration: 1e3 }, a), f), this;
        }
        resetNorthPitch(a, f) {
          return this.easeTo(l.e({ bearing: 0, pitch: 0, duration: 1e3 }, a), f), this;
        }
        snapToNorth(a, f) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(a, f) : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(a, f) {
          return this.jumpTo({ pitch: a }, f), this;
        }
        cameraForBounds(a, f) {
          a = re.convert(a);
          const _ = f && f.bearing || 0;
          return this._cameraForBoxAndBearing(a.getNorthWest(), a.getSouthEast(), _, f);
        }
        _cameraForBoxAndBearing(a, f, _, h) {
          const p = { top: 0, bottom: 0, right: 0, left: 0 };
          if (typeof (h = l.e({ padding: p, offset: [0, 0], maxZoom: this.transform.maxZoom }, h)).padding == "number") {
            const rt = h.padding;
            h.padding = { top: rt, bottom: rt, right: rt, left: rt };
          }
          h.padding = l.e(p, h.padding);
          const b = this.transform, x = b.padding, C = new re(a, f), M = b.project(C.getNorthWest()), R = b.project(C.getNorthEast()), O = b.project(C.getSouthEast()), D = b.project(C.getSouthWest()), U = l.ba(-_), W = M.rotate(U), Q = R.rotate(U), Y = O.rotate(U), K = D.rotate(U), fe = new l.P(Math.max(W.x, Q.x, K.x, Y.x), Math.max(W.y, Q.y, K.y, Y.y)), ne = new l.P(Math.min(W.x, Q.x, K.x, Y.x), Math.min(W.y, Q.y, K.y, Y.y)), ie = fe.sub(ne), le = (b.width - (x.left + x.right + h.padding.left + h.padding.right)) / ie.x, xe = (b.height - (x.top + x.bottom + h.padding.top + h.padding.bottom)) / ie.y;
          if (xe < 0 || le < 0)
            return void l.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          const Me = Math.min(b.scaleZoom(b.scale * Math.min(le, xe)), h.maxZoom), Ne = l.P.convert(h.offset), ot = new l.P((h.padding.left - h.padding.right) / 2, (h.padding.top - h.padding.bottom) / 2).rotate(l.ba(_)), et = Ne.add(ot).mult(b.scale / b.zoomScale(Me));
          return { center: b.unproject(M.add(O).div(2).sub(et)), zoom: Me, bearing: _ };
        }
        fitBounds(a, f, _) {
          return this._fitInternal(this.cameraForBounds(a, f), f, _);
        }
        fitScreenCoordinates(a, f, _, h, p) {
          return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(l.P.convert(a)), this.transform.pointLocation(l.P.convert(f)), _, h), h, p);
        }
        _fitInternal(a, f, _) {
          return a ? (delete (f = l.e(a, f)).padding, f.linear ? this.easeTo(f, _) : this.flyTo(f, _)) : this;
        }
        jumpTo(a, f) {
          this.stop();
          const _ = this._getTransformForUpdate();
          let h = !1, p = !1, b = !1;
          return "zoom" in a && _.zoom !== +a.zoom && (h = !0, _.zoom = +a.zoom), a.center !== void 0 && (_.center = l.N.convert(a.center)), "bearing" in a && _.bearing !== +a.bearing && (p = !0, _.bearing = +a.bearing), "pitch" in a && _.pitch !== +a.pitch && (b = !0, _.pitch = +a.pitch), a.padding == null || _.isPaddingEqual(a.padding) || (_.padding = a.padding), this._applyUpdatedTransform(_), this.fire(new l.k("movestart", f)).fire(new l.k("move", f)), h && this.fire(new l.k("zoomstart", f)).fire(new l.k("zoom", f)).fire(new l.k("zoomend", f)), p && this.fire(new l.k("rotatestart", f)).fire(new l.k("rotate", f)).fire(new l.k("rotateend", f)), b && this.fire(new l.k("pitchstart", f)).fire(new l.k("pitch", f)).fire(new l.k("pitchend", f)), this.fire(new l.k("moveend", f));
        }
        calculateCameraOptionsFromTo(a, f, _) {
          let h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
          const p = l.Z.fromLngLat(a, f), b = l.Z.fromLngLat(_, h), x = b.x - p.x, C = b.y - p.y, M = b.z - p.z, R = Math.hypot(x, C, M);
          if (R === 0)
            throw new Error("Can't calculate camera options with same From and To");
          const O = Math.hypot(x, C), D = this.transform.scaleZoom(this.transform.cameraToCenterDistance / R / this.transform.tileSize), U = 180 * Math.atan2(x, -C) / Math.PI;
          let W = 180 * Math.acos(O / R) / Math.PI;
          return W = M < 0 ? 90 - W : 90 + W, { center: b.toLngLat(), zoom: D, pitch: W, bearing: U };
        }
        easeTo(a, f) {
          var _;
          this._stop(!1, a.easeId), ((a = l.e({ offset: [0, 0], duration: 500, easing: l.b9 }, a)).animate === !1 || !a.essential && T.prefersReducedMotion) && (a.duration = 0);
          const h = this._getTransformForUpdate(), p = this.getZoom(), b = this.getBearing(), x = this.getPitch(), C = this.getPadding(), M = "bearing" in a ? this._normalizeBearing(a.bearing, b) : b, R = "pitch" in a ? +a.pitch : x, O = "padding" in a ? a.padding : h.padding, D = l.P.convert(a.offset);
          let U = h.centerPoint.add(D);
          const W = h.pointLocation(U), { center: Q, zoom: Y } = h.getConstrained(l.N.convert(a.center || W), (_ = a.zoom) !== null && _ !== void 0 ? _ : p);
          this._normalizeCenter(Q);
          const K = h.project(W), fe = h.project(Q).sub(K), ne = h.zoomScale(Y - p);
          let ie, le;
          a.around && (ie = l.N.convert(a.around), le = h.locationPoint(ie));
          const xe = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return this._zooming = this._zooming || Y !== p, this._rotating = this._rotating || b !== M, this._pitching = this._pitching || R !== x, this._padding = !h.isPaddingEqual(O), this._easeId = a.easeId, this._prepareEase(f, a.noMoveStart, xe), this.terrain && this._prepareElevation(Q), this._ease((Me) => {
            if (this._zooming && (h.zoom = l.z.number(p, Y, Me)), this._rotating && (h.bearing = l.z.number(b, M, Me)), this._pitching && (h.pitch = l.z.number(x, R, Me)), this._padding && (h.interpolatePadding(C, O, Me), U = h.centerPoint.add(D)), this.terrain && !a.freezeElevation && this._updateElevation(Me), ie)
              h.setLocationAtPoint(ie, le);
            else {
              const Ne = h.zoomScale(h.zoom - p), ot = Y > p ? Math.min(2, ne) : Math.max(0.5, ne), et = Math.pow(ot, 1 - Me), rt = h.unproject(K.add(fe.mult(Me * et)).mult(Ne));
              h.setLocationAtPoint(h.renderWorldCopies ? rt.wrap() : rt, U);
            }
            this._applyUpdatedTransform(h), this._fireMoveEvents(f);
          }, (Me) => {
            this.terrain && a.freezeElevation && this._finalizeElevation(), this._afterEase(f, Me);
          }, a), this;
        }
        _prepareEase(a, f) {
          let _ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          this._moving = !0, f || _.moving || this.fire(new l.k("movestart", a)), this._zooming && !_.zooming && this.fire(new l.k("zoomstart", a)), this._rotating && !_.rotating && this.fire(new l.k("rotatestart", a)), this._pitching && !_.pitching && this.fire(new l.k("pitchstart", a));
        }
        _prepareElevation(a) {
          this._elevationCenter = a, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(a, this.transform.tileZoom), this._elevationFreeze = !0;
        }
        _updateElevation(a) {
          this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
          const f = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
          if (a < 1 && f !== this._elevationTarget) {
            const _ = this._elevationTarget - this._elevationStart;
            this._elevationStart += a * (_ - (f - (_ * a + this._elevationStart)) / (1 - a)), this._elevationTarget = f;
          }
          this.transform.elevation = l.z.number(this._elevationStart, this._elevationTarget, a);
        }
        _finalizeElevation() {
          this._elevationFreeze = !1, this.transform.recalculateZoom(this.terrain);
        }
        _getTransformForUpdate() {
          return this.transformCameraUpdate ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
        }
        _applyUpdatedTransform(a) {
          if (!this.transformCameraUpdate)
            return;
          const f = a.clone(), { center: _, zoom: h, pitch: p, bearing: b, elevation: x } = this.transformCameraUpdate(f);
          _ && (f.center = _), h !== void 0 && (f.zoom = h), p !== void 0 && (f.pitch = p), b !== void 0 && (f.bearing = b), x !== void 0 && (f.elevation = x), this.transform.apply(f);
        }
        _fireMoveEvents(a) {
          this.fire(new l.k("move", a)), this._zooming && this.fire(new l.k("zoom", a)), this._rotating && this.fire(new l.k("rotate", a)), this._pitching && this.fire(new l.k("pitch", a));
        }
        _afterEase(a, f) {
          if (this._easeId && f && this._easeId === f)
            return;
          delete this._easeId;
          const _ = this._zooming, h = this._rotating, p = this._pitching;
          this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, _ && this.fire(new l.k("zoomend", a)), h && this.fire(new l.k("rotateend", a)), p && this.fire(new l.k("pitchend", a)), this.fire(new l.k("moveend", a));
        }
        flyTo(a, f) {
          var _;
          if (!a.essential && T.prefersReducedMotion) {
            const vt = l.M(a, ["center", "zoom", "bearing", "pitch", "around"]);
            return this.jumpTo(vt, f);
          }
          this.stop(), a = l.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: l.b9 }, a);
          const h = this._getTransformForUpdate(), p = this.getZoom(), b = this.getBearing(), x = this.getPitch(), C = this.getPadding(), M = "bearing" in a ? this._normalizeBearing(a.bearing, b) : b, R = "pitch" in a ? +a.pitch : x, O = "padding" in a ? a.padding : h.padding, D = l.P.convert(a.offset);
          let U = h.centerPoint.add(D);
          const W = h.pointLocation(U), { center: Q, zoom: Y } = h.getConstrained(l.N.convert(a.center || W), (_ = a.zoom) !== null && _ !== void 0 ? _ : p);
          this._normalizeCenter(Q);
          const K = h.zoomScale(Y - p), fe = h.project(W), ne = h.project(Q).sub(fe);
          let ie = a.curve;
          const le = Math.max(h.width, h.height), xe = le / K, Me = ne.mag();
          if ("minZoom" in a) {
            const vt = l.ad(Math.min(a.minZoom, p, Y), h.minZoom, h.maxZoom), Ht = le / h.zoomScale(vt - p);
            ie = Math.sqrt(Ht / Me * 2);
          }
          const Ne = ie * ie;
          function ot(vt) {
            const Ht = (xe * xe - le * le + (vt ? -1 : 1) * Ne * Ne * Me * Me) / (2 * (vt ? xe : le) * Ne * Me);
            return Math.log(Math.sqrt(Ht * Ht + 1) - Ht);
          }
          function et(vt) {
            return (Math.exp(vt) - Math.exp(-vt)) / 2;
          }
          function rt(vt) {
            return (Math.exp(vt) + Math.exp(-vt)) / 2;
          }
          const $e = ot(!1);
          let Ct = function(vt) {
            return rt($e) / rt($e + ie * vt);
          }, qt = function(vt) {
            return le * ((rt($e) * (et(Ht = $e + ie * vt) / rt(Ht)) - et($e)) / Ne) / Me;
            var Ht;
          }, yt = (ot(!0) - $e) / ie;
          if (Math.abs(Me) < 1e-6 || !isFinite(yt)) {
            if (Math.abs(le - xe) < 1e-6)
              return this.easeTo(a, f);
            const vt = xe < le ? -1 : 1;
            yt = Math.abs(Math.log(xe / le)) / ie, qt = () => 0, Ct = (Ht) => Math.exp(vt * ie * Ht);
          }
          return a.duration = "duration" in a ? +a.duration : 1e3 * yt / ("screenSpeed" in a ? +a.screenSpeed / ie : +a.speed), a.maxDuration && a.duration > a.maxDuration && (a.duration = 0), this._zooming = !0, this._rotating = b !== M, this._pitching = R !== x, this._padding = !h.isPaddingEqual(O), this._prepareEase(f, !1), this.terrain && this._prepareElevation(Q), this._ease((vt) => {
            const Ht = vt * yt, Sn = 1 / Ct(Ht);
            h.zoom = vt === 1 ? Y : p + h.scaleZoom(Sn), this._rotating && (h.bearing = l.z.number(b, M, vt)), this._pitching && (h.pitch = l.z.number(x, R, vt)), this._padding && (h.interpolatePadding(C, O, vt), U = h.centerPoint.add(D)), this.terrain && !a.freezeElevation && this._updateElevation(vt);
            const Ot = vt === 1 ? Q : h.unproject(fe.add(ne.mult(qt(Ht))).mult(Sn));
            h.setLocationAtPoint(h.renderWorldCopies ? Ot.wrap() : Ot, U), this._applyUpdatedTransform(h), this._fireMoveEvents(f);
          }, () => {
            this.terrain && a.freezeElevation && this._finalizeElevation(), this._afterEase(f);
          }, a), this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _stop(a, f) {
          var _;
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
            const h = this._onEaseEnd;
            delete this._onEaseEnd, h.call(this, f);
          }
          return a || (_ = this.handlers) === null || _ === void 0 || _.stop(!1), this;
        }
        _ease(a, f, _) {
          _.animate === !1 || _.duration === 0 ? (a(1), f()) : (this._easeStart = T.now(), this._easeOptions = _, this._onEaseFrame = a, this._onEaseEnd = f, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }
        _normalizeBearing(a, f) {
          a = l.b3(a, -180, 180);
          const _ = Math.abs(a - f);
          return Math.abs(a - 360 - f) < _ && (a -= 360), Math.abs(a + 360 - f) < _ && (a += 360), a;
        }
        _normalizeCenter(a) {
          const f = this.transform;
          if (!f.renderWorldCopies || f.lngRange)
            return;
          const _ = a.lng - f.center.lng;
          a.lng += _ > 180 ? -360 : _ < -180 ? 360 : 0;
        }
        queryTerrainElevation(a) {
          return this.terrain ? this.terrain.getElevationForLngLatZoom(l.N.convert(a), this.transform.tileZoom) - this.transform.elevation : null;
        }
      }
      const rh = { compact: !0, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
      class Wl {
        constructor() {
          let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : rh;
          this._toggleAttribution = () => {
            this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
          }, this._updateData = (f) => {
            !f || f.sourceDataType !== "metadata" && f.sourceDataType !== "visibility" && f.dataType !== "style" && f.type !== "terrain" || this._updateAttributions();
          }, this._updateCompact = () => {
            this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
          }, this._updateCompactMinimize = () => {
            this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
          }, this.options = a;
        }
        getDefaultPosition() {
          return "bottom-right";
        }
        onAdd(a) {
          return this._map = a, this._compact = this.options.compact, this._container = I.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = I.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = I.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
        }
        onRemove() {
          I.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
        }
        _setElementTitle(a, f) {
          const _ = this._map._getUIString(`AttributionControl.${f}`);
          a.title = _, a.setAttribute("aria-label", _);
        }
        _updateAttributions() {
          if (!this._map.style)
            return;
          let a = [];
          if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? a = a.concat(this.options.customAttribution.map((h) => typeof h != "string" ? "" : h)) : typeof this.options.customAttribution == "string" && a.push(this.options.customAttribution)), this._map.style.stylesheet) {
            const h = this._map.style.stylesheet;
            this.styleOwner = h.owner, this.styleId = h.id;
          }
          const f = this._map.style.sourceCaches;
          for (const h in f) {
            const p = f[h];
            if (p.used || p.usedForTerrain) {
              const b = p.getSource();
              b.attribution && a.indexOf(b.attribution) < 0 && a.push(b.attribution);
            }
          }
          a = a.filter((h) => String(h).trim()), a.sort((h, p) => h.length - p.length), a = a.filter((h, p) => {
            for (let b = p + 1; b < a.length; b++)
              if (a[b].indexOf(h) >= 0)
                return !1;
            return !0;
          });
          const _ = a.join(" | ");
          _ !== this._attribHTML && (this._attribHTML = _, a.length ? (this._innerContainer.innerHTML = _, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
        }
      }
      class So {
        constructor() {
          let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          this._updateCompact = () => {
            const f = this._container.children;
            if (f.length) {
              const _ = f[0];
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && _.classList.add("maplibregl-compact") : _.classList.remove("maplibregl-compact");
            }
          }, this.options = a;
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(a) {
          this._map = a, this._compact = this.options && this.options.compact, this._container = I.create("div", "maplibregl-ctrl");
          const f = I.create("a", "maplibregl-ctrl-logo");
          return f.target = "_blank", f.rel = "noopener nofollow", f.href = "https://maplibre.org/", f.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), f.setAttribute("rel", "noopener nofollow"), this._container.appendChild(f), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }
        onRemove() {
          I.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
        }
      }
      class zt {
        constructor() {
          this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
        }
        add(a) {
          const f = ++this._id;
          return this._queue.push({ callback: a, id: f, cancelled: !1 }), f;
        }
        remove(a) {
          const f = this._currentlyRunning, _ = f ? this._queue.concat(f) : this._queue;
          for (const h of _)
            if (h.id === a)
              return void (h.cancelled = !0);
        }
        run() {
          let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          if (this._currentlyRunning)
            throw new Error("Attempting to run(), but is already running.");
          const f = this._currentlyRunning = this._queue;
          this._queue = [];
          for (const _ of f)
            if (!_.cancelled && (_.callback(a), this._cleared))
              break;
          this._cleared = !1, this._currentlyRunning = !1;
        }
        clear() {
          this._currentlyRunning && (this._cleared = !0), this._queue = [];
        }
      }
      var Fs = l.Y([{ name: "a_pos3d", type: "Int16", components: 3 }]);
      class uo extends l.E {
        constructor(a) {
          super(), this.sourceCache = a, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, a.usedForTerrain = !0, a.tileSize = this.tileSize * 2 ** this.deltaZoom;
        }
        destruct() {
          this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null;
        }
        update(a, f) {
          this.sourceCache.update(a, f), this._renderableTilesKeys = [];
          const _ = {};
          for (const h of a.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: !1, terrain: f }))
            _[h.key] = !0, this._renderableTilesKeys.push(h.key), this._tiles[h.key] || (h.posMatrix = new Float64Array(16), l.aQ(h.posMatrix, 0, l.X, 0, l.X, 0, 1), this._tiles[h.key] = new bi(h, this.tileSize));
          for (const h in this._tiles)
            _[h] || delete this._tiles[h];
        }
        freeRtt(a) {
          for (const f in this._tiles) {
            const _ = this._tiles[f];
            (!a || _.tileID.equals(a) || _.tileID.isChildOf(a) || a.isChildOf(_.tileID)) && (_.rtt = []);
          }
        }
        getRenderableTiles() {
          return this._renderableTilesKeys.map((a) => this.getTileByID(a));
        }
        getTileByID(a) {
          return this._tiles[a];
        }
        getTerrainCoords(a) {
          const f = {};
          for (const _ of this._renderableTilesKeys) {
            const h = this._tiles[_].tileID;
            if (h.canonical.equals(a.canonical)) {
              const p = a.clone();
              p.posMatrix = new Float64Array(16), l.aQ(p.posMatrix, 0, l.X, 0, l.X, 0, 1), f[_] = p;
            } else if (h.canonical.isChildOf(a.canonical)) {
              const p = a.clone();
              p.posMatrix = new Float64Array(16);
              const b = h.canonical.z - a.canonical.z, x = h.canonical.x - (h.canonical.x >> b << b), C = h.canonical.y - (h.canonical.y >> b << b), M = l.X >> b;
              l.aQ(p.posMatrix, 0, M, 0, M, 0, 1), l.J(p.posMatrix, p.posMatrix, [-x * M, -C * M, 0]), f[_] = p;
            } else if (a.canonical.isChildOf(h.canonical)) {
              const p = a.clone();
              p.posMatrix = new Float64Array(16);
              const b = a.canonical.z - h.canonical.z, x = a.canonical.x - (a.canonical.x >> b << b), C = a.canonical.y - (a.canonical.y >> b << b), M = l.X >> b;
              l.aQ(p.posMatrix, 0, l.X, 0, l.X, 0, 1), l.J(p.posMatrix, p.posMatrix, [x * M, C * M, 0]), l.K(p.posMatrix, p.posMatrix, [1 / 2 ** b, 1 / 2 ** b, 0]), f[_] = p;
            }
          }
          return f;
        }
        getSourceTile(a, f) {
          const _ = this.sourceCache._source;
          let h = a.overscaledZ - this.deltaZoom;
          if (h > _.maxzoom && (h = _.maxzoom), h < _.minzoom)
            return null;
          this._sourceTileCache[a.key] || (this._sourceTileCache[a.key] = a.scaledTo(h).key);
          let p = this.sourceCache.getTileByID(this._sourceTileCache[a.key]);
          if ((!p || !p.dem) && f)
            for (; h >= _.minzoom && (!p || !p.dem); )
              p = this.sourceCache.getTileByID(a.scaledTo(h--).key);
          return p;
        }
        tilesAfterTime() {
          let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Date.now();
          return Object.values(this._tiles).filter((f) => f.timeAdded >= a);
        }
      }
      class $h {
        constructor(a, f, _) {
          this.painter = a, this.sourceCache = new uo(f), this.options = _, this.exaggeration = typeof _.exaggeration == "number" ? _.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
        }
        getDEMElevation(a, f, _) {
          let h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : l.X;
          var p;
          if (!(f >= 0 && f < h && _ >= 0 && _ < h))
            return 0;
          const b = this.getTerrainData(a), x = (p = b.tile) === null || p === void 0 ? void 0 : p.dem;
          if (!x)
            return 0;
          const C = function(W, Q, Y) {
            var K = Q[0], fe = Q[1];
            return W[0] = Y[0] * K + Y[4] * fe + Y[12], W[1] = Y[1] * K + Y[5] * fe + Y[13], W;
          }([], [f / h * l.X, _ / h * l.X], b.u_terrain_matrix), M = [C[0] * x.dim, C[1] * x.dim], R = Math.floor(M[0]), O = Math.floor(M[1]), D = M[0] - R, U = M[1] - O;
          return x.get(R, O) * (1 - D) * (1 - U) + x.get(R + 1, O) * D * (1 - U) + x.get(R, O + 1) * (1 - D) * U + x.get(R + 1, O + 1) * D * U;
        }
        getElevationForLngLatZoom(a, f) {
          const { tileID: _, mercatorX: h, mercatorY: p } = this._getOverscaledTileIDFromLngLatZoom(a, f);
          return this.getElevation(_, h % l.X, p % l.X, l.X);
        }
        getElevation(a, f, _) {
          let h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : l.X;
          return this.getDEMElevation(a, f, _, h) * this.exaggeration;
        }
        getTerrainData(a) {
          if (!this._emptyDemTexture) {
            const h = this.painter.context, p = new l.R({ width: 1, height: 1 }, new Uint8Array(4));
            this._emptyDepthTexture = new ae(h, p, h.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new ae(h, new l.R({ width: 1, height: 1 }), h.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(h.gl.NEAREST, h.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = l.ao([]);
          }
          const f = this.sourceCache.getSourceTile(a, !0);
          if (f && f.dem && (!f.demTexture || f.needsTerrainPrepare)) {
            const h = this.painter.context;
            f.demTexture = this.painter.getTileTexture(f.dem.stride), f.demTexture ? f.demTexture.update(f.dem.getPixels(), { premultiply: !1 }) : f.demTexture = new ae(h, f.dem.getPixels(), h.gl.RGBA, { premultiply: !1 }), f.demTexture.bind(h.gl.NEAREST, h.gl.CLAMP_TO_EDGE), f.needsTerrainPrepare = !1;
          }
          const _ = f && f + f.tileID.key + a.key;
          if (_ && !this._demMatrixCache[_]) {
            const h = this.sourceCache.sourceCache._source.maxzoom;
            let p = a.canonical.z - f.tileID.canonical.z;
            a.overscaledZ > a.canonical.z && (a.canonical.z >= h ? p = a.canonical.z - h : l.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
            const b = a.canonical.x - (a.canonical.x >> p << p), x = a.canonical.y - (a.canonical.y >> p << p), C = l.bb(new Float64Array(16), [1 / (l.X << p), 1 / (l.X << p), 0]);
            l.J(C, C, [b * l.X, x * l.X, 0]), this._demMatrixCache[a.key] = { matrix: C, coord: a };
          }
          return { u_depth: 2, u_terrain: 3, u_terrain_dim: f && f.dem && f.dem.dim || 1, u_terrain_matrix: _ ? this._demMatrixCache[a.key].matrix : this._emptyDemMatrix, u_terrain_unpack: f && f.dem && f.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (f && f.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: f };
        }
        getFramebuffer(a) {
          const f = this.painter, _ = f.width / devicePixelRatio, h = f.height / devicePixelRatio;
          return !this._fbo || this._fbo.width === _ && this._fbo.height === h || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new ae(f.context, { width: _, height: h, data: null }, f.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(f.context.gl.NEAREST, f.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new ae(f.context, { width: _, height: h, data: null }, f.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(f.context.gl.NEAREST, f.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = f.context.createFramebuffer(_, h, !0, !1), this._fbo.depthAttachment.set(f.context.createRenderbuffer(f.context.gl.DEPTH_COMPONENT16, _, h))), this._fbo.colorAttachment.set(a === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
        }
        getCoordsTexture() {
          const a = this.painter.context;
          if (this._coordsTexture)
            return this._coordsTexture;
          const f = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
          for (let p = 0, b = 0; p < this._coordsTextureSize; p++)
            for (let x = 0; x < this._coordsTextureSize; x++, b += 4)
              f[b + 0] = 255 & x, f[b + 1] = 255 & p, f[b + 2] = x >> 8 << 4 | p >> 8, f[b + 3] = 0;
          const _ = new l.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(f.buffer)), h = new ae(a, _, a.gl.RGBA, { premultiply: !1 });
          return h.bind(a.gl.NEAREST, a.gl.CLAMP_TO_EDGE), this._coordsTexture = h, h;
        }
        pointCoordinate(a) {
          this.painter.maybeDrawDepthAndCoords(!0);
          const f = new Uint8Array(4), _ = this.painter.context, h = _.gl, p = Math.round(a.x * this.painter.pixelRatio / devicePixelRatio), b = Math.round(a.y * this.painter.pixelRatio / devicePixelRatio), x = Math.round(this.painter.height / devicePixelRatio);
          _.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), h.readPixels(p, x - b - 1, 1, 1, h.RGBA, h.UNSIGNED_BYTE, f), _.bindFramebuffer.set(null);
          const C = f[0] + (f[2] >> 4 << 8), M = f[1] + ((15 & f[2]) << 8), R = this.coordsIndex[255 - f[3]], O = R && this.sourceCache.getTileByID(R);
          if (!O)
            return null;
          const D = this._coordsTextureSize, U = (1 << O.tileID.canonical.z) * D;
          return new l.Z((O.tileID.canonical.x * D + C) / U + O.tileID.wrap, (O.tileID.canonical.y * D + M) / U, this.getElevation(O.tileID, C, M, D));
        }
        depthAtPoint(a) {
          const f = new Uint8Array(4), _ = this.painter.context, h = _.gl;
          return _.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), h.readPixels(a.x, this.painter.height / devicePixelRatio - a.y - 1, 1, 1, h.RGBA, h.UNSIGNED_BYTE, f), _.bindFramebuffer.set(null), (f[0] / 16777216 + f[1] / 65536 + f[2] / 256 + f[3]) / 256;
        }
        getTerrainMesh() {
          if (this._mesh)
            return this._mesh;
          const a = this.painter.context, f = new l.bc(), _ = new l.aY(), h = this.meshSize, p = l.X / h, b = h * h;
          for (let O = 0; O <= h; O++)
            for (let D = 0; D <= h; D++)
              f.emplaceBack(D * p, O * p, 0);
          for (let O = 0; O < b; O += h + 1)
            for (let D = 0; D < h; D++)
              _.emplaceBack(D + O, h + D + O + 1, h + D + O + 2), _.emplaceBack(D + O, h + D + O + 2, D + O + 1);
          const x = f.length, C = x + 2 * (h + 1);
          for (const O of [0, 1])
            for (let D = 0; D <= h; D++)
              for (const U of [0, 1])
                f.emplaceBack(D * p, O * l.X, U);
          for (let O = 0; O < 2 * h; O += 2)
            _.emplaceBack(C + O, C + O + 1, C + O + 3), _.emplaceBack(C + O, C + O + 3, C + O + 2), _.emplaceBack(x + O, x + O + 3, x + O + 1), _.emplaceBack(x + O, x + O + 2, x + O + 3);
          const M = f.length, R = M + 2 * (h + 1);
          for (const O of [0, 1])
            for (let D = 0; D <= h; D++)
              for (const U of [0, 1])
                f.emplaceBack(O * l.X, D * p, U);
          for (let O = 0; O < 2 * h; O += 2)
            _.emplaceBack(M + O, M + O + 1, M + O + 3), _.emplaceBack(M + O, M + O + 3, M + O + 2), _.emplaceBack(R + O, R + O + 3, R + O + 1), _.emplaceBack(R + O, R + O + 2, R + O + 3);
          return this._mesh = new $o(a.createVertexBuffer(f, Fs.members), a.createIndexBuffer(_), l.a0.simpleSegment(0, 0, f.length, _.length)), this._mesh;
        }
        getMeshFrameDelta(a) {
          return 2 * Math.PI * l.bd / Math.pow(2, a) / 5;
        }
        getMinTileElevationForLngLatZoom(a, f) {
          var _;
          const { tileID: h } = this._getOverscaledTileIDFromLngLatZoom(a, f);
          return (_ = this.getMinMaxElevation(h).minElevation) !== null && _ !== void 0 ? _ : 0;
        }
        getMinMaxElevation(a) {
          const f = this.getTerrainData(a).tile, _ = { minElevation: null, maxElevation: null };
          return f && f.dem && (_.minElevation = f.dem.min * this.exaggeration, _.maxElevation = f.dem.max * this.exaggeration), _;
        }
        _getOverscaledTileIDFromLngLatZoom(a, f) {
          const _ = l.Z.fromLngLat(a.wrap()), h = (1 << f) * l.X, p = _.x * h, b = _.y * h, x = Math.floor(p / l.X), C = Math.floor(b / l.X);
          return { tileID: new l.S(f, 0, f, x, C), mercatorX: p, mercatorY: b };
        }
      }
      class Xl {
        constructor(a, f, _) {
          this._context = a, this._size = f, this._tileSize = _, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
        }
        destruct() {
          for (const a of this._objects)
            a.texture.destroy(), a.fbo.destroy();
        }
        _createObject(a) {
          const f = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), _ = new ae(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
          return _.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), f.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), f.colorAttachment.set(_.texture), { id: a, fbo: f, texture: _, stamp: -1, inUse: !1 };
        }
        getObjectForId(a) {
          return this._objects[a];
        }
        useObject(a) {
          a.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter((f) => a.id !== f), this._recentlyUsed.push(a.id);
        }
        stampObject(a) {
          a.stamp = ++this._stamp;
        }
        getOrCreateFreeObject() {
          for (const f of this._recentlyUsed)
            if (!this._objects[f].inUse)
              return this._objects[f];
          if (this._objects.length >= this._size)
            throw new Error("No free RenderPool available, call freeAllObjects() required!");
          const a = this._createObject(this._objects.length);
          return this._objects.push(a), a;
        }
        freeObject(a) {
          a.inUse = !1;
        }
        freeAllObjects() {
          for (const a of this._objects)
            this.freeObject(a);
        }
        isFull() {
          return !(this._objects.length < this._size) && this._objects.some((a) => !a.inUse) === !1;
        }
      }
      const Br = { background: !0, fill: !0, line: !0, raster: !0, hillshade: !0 };
      class As {
        constructor(a, f) {
          this.painter = a, this.terrain = f, this.pool = new Xl(a.context, 30, f.sourceCache.tileSize * f.qualityFactor);
        }
        destruct() {
          this.pool.destruct();
        }
        getTexture(a) {
          return this.pool.getObjectForId(a.rtt[this._stacks.length - 1].id).texture;
        }
        prepareForRender(a, f) {
          this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = a._order.filter((_) => !a._layers[_].isHidden(f)), this._coordsDescendingInv = {};
          for (const _ in a.sourceCaches) {
            this._coordsDescendingInv[_] = {};
            const h = a.sourceCaches[_].getVisibleCoordinates();
            for (const p of h) {
              const b = this.terrain.sourceCache.getTerrainCoords(p);
              for (const x in b)
                this._coordsDescendingInv[_][x] || (this._coordsDescendingInv[_][x] = []), this._coordsDescendingInv[_][x].push(b[x]);
            }
          }
          this._coordsDescendingInvStr = {};
          for (const _ of a._order) {
            const h = a._layers[_], p = h.source;
            if (Br[h.type] && !this._coordsDescendingInvStr[p]) {
              this._coordsDescendingInvStr[p] = {};
              for (const b in this._coordsDescendingInv[p])
                this._coordsDescendingInvStr[p][b] = this._coordsDescendingInv[p][b].map((x) => x.key).sort().join();
            }
          }
          for (const _ of this._renderableTiles)
            for (const h in this._coordsDescendingInvStr) {
              const p = this._coordsDescendingInvStr[h][_.tileID.key];
              p && p !== _.rttCoords[h] && (_.rtt = []);
            }
        }
        renderLayer(a) {
          if (a.isHidden(this.painter.transform.zoom))
            return !1;
          const f = a.type, _ = this.painter, h = this._renderableLayerIds[this._renderableLayerIds.length - 1] === a.id;
          if (Br[f] && (this._prevType && Br[this._prevType] || this._stacks.push([]), this._prevType = f, this._stacks[this._stacks.length - 1].push(a.id), !h))
            return !0;
          if (Br[this._prevType] || Br[f] && h) {
            this._prevType = f;
            const p = this._stacks.length - 1, b = this._stacks[p] || [];
            for (const x of this._renderableTiles) {
              if (this.pool.isFull() && ($r(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(x), x.rtt[p]) {
                const M = this.pool.getObjectForId(x.rtt[p].id);
                if (M.stamp === x.rtt[p].stamp) {
                  this.pool.useObject(M);
                  continue;
                }
              }
              const C = this.pool.getOrCreateFreeObject();
              this.pool.useObject(C), this.pool.stampObject(C), x.rtt[p] = { id: C.id, stamp: C.stamp }, _.context.bindFramebuffer.set(C.fbo.framebuffer), _.context.clear({ color: l.aN.transparent, stencil: 0 }), _.currentStencilSource = void 0;
              for (let M = 0; M < b.length; M++) {
                const R = _.style._layers[b[M]], O = R.source ? this._coordsDescendingInv[R.source][x.tileID.key] : [x.tileID];
                _.context.viewport.set([0, 0, C.fbo.width, C.fbo.height]), _._renderTileClippingMasks(R, O), _.renderLayer(_, _.style.sourceCaches[R.source], R, O), R.source && (x.rttCoords[R.source] = this._coordsDescendingInvStr[R.source][x.tileID.key]);
              }
            }
            return $r(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects(), Br[f];
          }
          return !1;
        }
      }
      const Vt = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use  + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, sh = m, Zh = { hash: !1, interactive: !0, bearingSnap: 7, attributionControl: rh, maplibreLogo: !1, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, refreshExpiredTiles: !0, scrollZoom: !0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, trackResize: !0, center: [0, 0], zoom: 0, bearing: 0, pitch: 0, renderWorldCopies: !0, maxTileCacheSize: null, maxTileCacheZoomLevels: l.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: !0, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: !0, validateStyle: !0, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: !0 }, oh = (E) => {
        E.touchstart = E.dragStart, E.touchmoveWindow = E.dragMove, E.touchend = E.dragEnd;
      }, gu = { showCompass: !0, showZoom: !0, visualizePitch: !1 };
      class ah {
        constructor(a, f) {
          let _ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
          this.mousedown = (b) => {
            this.startMouse(l.e({}, b, { ctrlKey: !0, preventDefault: () => b.preventDefault() }), I.mousePos(this.element, b)), I.addEventListener(window, "mousemove", this.mousemove), I.addEventListener(window, "mouseup", this.mouseup);
          }, this.mousemove = (b) => {
            this.moveMouse(b, I.mousePos(this.element, b));
          }, this.mouseup = (b) => {
            this.mouseRotate.dragEnd(b), this.mousePitch && this.mousePitch.dragEnd(b), this.offTemp();
          }, this.touchstart = (b) => {
            b.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = I.touchPos(this.element, b.targetTouches)[0], this.startTouch(b, this._startPos), I.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), I.addEventListener(window, "touchend", this.touchend));
          }, this.touchmove = (b) => {
            b.targetTouches.length !== 1 ? this.reset() : (this._lastPos = I.touchPos(this.element, b.targetTouches)[0], this.moveTouch(b, this._lastPos));
          }, this.touchend = (b) => {
            b.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this.reset = () => {
            this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), this.touchRotate.reset(), this.touchPitch && this.touchPitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this._clickTolerance = 10;
          const h = a.dragRotate._mouseRotate.getClickTolerance(), p = a.dragRotate._mousePitch.getClickTolerance();
          this.element = f, this.mouseRotate = es({ clickTolerance: h, enable: !0 }), this.touchRotate = ((b) => {
            let { enable: x, clickTolerance: C, bearingDegreesPerPixelMoved: M = 0.8 } = b;
            const R = new Gl();
            return new wi({ clickTolerance: C, move: (O, D) => ({ bearingDelta: (D.x - O.x) * M }), moveStateManager: R, enable: x, assignEvents: oh });
          })({ clickTolerance: h, enable: !0 }), this.map = a, _ && (this.mousePitch = wr({ clickTolerance: p, enable: !0 }), this.touchPitch = ((b) => {
            let { enable: x, clickTolerance: C, pitchDegreesPerPixelMoved: M = -0.5 } = b;
            const R = new Gl();
            return new wi({ clickTolerance: C, move: (O, D) => ({ pitchDelta: (D.y - O.y) * M }), moveStateManager: R, enable: x, assignEvents: oh });
          })({ clickTolerance: p, enable: !0 })), I.addEventListener(f, "mousedown", this.mousedown), I.addEventListener(f, "touchstart", this.touchstart, { passive: !1 }), I.addEventListener(f, "touchcancel", this.reset);
        }
        startMouse(a, f) {
          this.mouseRotate.dragStart(a, f), this.mousePitch && this.mousePitch.dragStart(a, f), I.disableDrag();
        }
        startTouch(a, f) {
          this.touchRotate.dragStart(a, f), this.touchPitch && this.touchPitch.dragStart(a, f), I.disableDrag();
        }
        moveMouse(a, f) {
          const _ = this.map, { bearingDelta: h } = this.mouseRotate.dragMove(a, f) || {};
          if (h && _.setBearing(_.getBearing() + h), this.mousePitch) {
            const { pitchDelta: p } = this.mousePitch.dragMove(a, f) || {};
            p && _.setPitch(_.getPitch() + p);
          }
        }
        moveTouch(a, f) {
          const _ = this.map, { bearingDelta: h } = this.touchRotate.dragMove(a, f) || {};
          if (h && _.setBearing(_.getBearing() + h), this.touchPitch) {
            const { pitchDelta: p } = this.touchPitch.dragMove(a, f) || {};
            p && _.setPitch(_.getPitch() + p);
          }
        }
        off() {
          const a = this.element;
          I.removeEventListener(a, "mousedown", this.mousedown), I.removeEventListener(a, "touchstart", this.touchstart, { passive: !1 }), I.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), I.removeEventListener(window, "touchend", this.touchend), I.removeEventListener(a, "touchcancel", this.reset), this.offTemp();
        }
        offTemp() {
          I.enableDrag(), I.removeEventListener(window, "mousemove", this.mousemove), I.removeEventListener(window, "mouseup", this.mouseup), I.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), I.removeEventListener(window, "touchend", this.touchend);
        }
      }
      let Oa;
      function Bc(E, a, f) {
        const _ = new l.N(E.lng, E.lat);
        if (E = new l.N(E.lng, E.lat), a) {
          const h = new l.N(E.lng - 360, E.lat), p = new l.N(E.lng + 360, E.lat), b = f.locationPoint(E).distSqr(a);
          f.locationPoint(h).distSqr(a) < b ? E = h : f.locationPoint(p).distSqr(a) < b && (E = p);
        }
        for (; Math.abs(E.lng - f.center.lng) > 180; ) {
          const h = f.locationPoint(E);
          if (h.x >= 0 && h.y >= 0 && h.x <= f.width && h.y <= f.height)
            break;
          E.lng > f.center.lng ? E.lng -= 360 : E.lng += 360;
        }
        return E.lng !== _.lng && f.locationPoint(E).y > f.height / 2 - f.getHorizon() ? E : _;
      }
      const Jl = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      function Ds(E, a, f) {
        const _ = E.classList;
        for (const h in Jl)
          _.remove(`maplibregl-${f}-anchor-${h}`);
        _.add(`maplibregl-${f}-anchor-${a}`);
      }
      class pi extends l.E {
        constructor(a) {
          if (super(), this._onKeyPress = (f) => {
            const _ = f.code, h = f.charCode || f.keyCode;
            _ !== "Space" && _ !== "Enter" && h !== 32 && h !== 13 || this.togglePopup();
          }, this._onMapClick = (f) => {
            const _ = f.originalEvent.target, h = this._element;
            this._popup && (_ === h || h.contains(_)) && this.togglePopup();
          }, this._update = (f) => {
            var _;
            if (!this._map)
              return;
            const h = this._map.loaded() && !this._map.isMoving();
            ((f == null ? void 0 : f.type) === "terrain" || (f == null ? void 0 : f.type) === "render" && !h) && this._map.once("render", this._update), this._lngLat = this._map.transform.renderWorldCopies ? Bc(this._lngLat, this._flatPos, this._map.transform) : (_ = this._lngLat) === null || _ === void 0 ? void 0 : _.wrap(), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationPoint(this._lngLat)._add(this._offset));
            let p = "";
            this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? p = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (p = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
            let b = "";
            this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? b = "rotateX(0deg)" : this._pitchAlignment === "map" && (b = `rotateX(${this._map.getPitch()}deg)`), f && f.type !== "moveend" || (this._pos = this._pos.round()), I.setTransform(this._element, `${Jl[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${b} ${p}`), T.frameAsync(new AbortController()).then(() => {
              this._updateOpacity(f && f.type === "moveend");
            }).catch(() => {
            });
          }, this._onMove = (f) => {
            if (!this._isDragging) {
              const _ = this._clickTolerance || this._map._clickTolerance;
              this._isDragging = f.point.dist(this._pointerdownPos) >= _;
            }
            this._isDragging && (this._pos = f.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new l.k("dragstart"))), this.fire(new l.k("drag")));
          }, this._onUp = () => {
            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new l.k("dragend")), this._state = "inactive";
          }, this._addDragHandler = (f) => {
            this._element.contains(f.originalEvent.target) && (f.preventDefault(), this._positionDelta = f.point.sub(this._pos).add(this._offset), this._pointerdownPos = f.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
          }, this._anchor = a && a.anchor || "center", this._color = a && a.color || "#3FB1CE", this._scale = a && a.scale || 1, this._draggable = a && a.draggable || !1, this._clickTolerance = a && a.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = a && a.rotation || 0, this._rotationAlignment = a && a.rotationAlignment || "auto", this._pitchAlignment = a && a.pitchAlignment && a.pitchAlignment !== "auto" ? a.pitchAlignment : this._rotationAlignment, this.setOpacity(), this.setOpacity(a == null ? void 0 : a.opacity, a == null ? void 0 : a.opacityWhenCovered), a && a.element)
            this._element = a.element, this._offset = l.P.convert(a && a.offset || [0, 0]);
          else {
            this._defaultMarker = !0, this._element = I.create("div");
            const f = I.createNS("http://www.w3.org/2000/svg", "svg"), _ = 41, h = 27;
            f.setAttributeNS(null, "display", "block"), f.setAttributeNS(null, "height", `${_}px`), f.setAttributeNS(null, "width", `${h}px`), f.setAttributeNS(null, "viewBox", `0 0 ${h} ${_}`);
            const p = I.createNS("http://www.w3.org/2000/svg", "g");
            p.setAttributeNS(null, "stroke", "none"), p.setAttributeNS(null, "stroke-width", "1"), p.setAttributeNS(null, "fill", "none"), p.setAttributeNS(null, "fill-rule", "evenodd");
            const b = I.createNS("http://www.w3.org/2000/svg", "g");
            b.setAttributeNS(null, "fill-rule", "nonzero");
            const x = I.createNS("http://www.w3.org/2000/svg", "g");
            x.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), x.setAttributeNS(null, "fill", "#000000");
            const C = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
            for (const K of C) {
              const fe = I.createNS("http://www.w3.org/2000/svg", "ellipse");
              fe.setAttributeNS(null, "opacity", "0.04"), fe.setAttributeNS(null, "cx", "10.5"), fe.setAttributeNS(null, "cy", "5.80029008"), fe.setAttributeNS(null, "rx", K.rx), fe.setAttributeNS(null, "ry", K.ry), x.appendChild(fe);
            }
            const M = I.createNS("http://www.w3.org/2000/svg", "g");
            M.setAttributeNS(null, "fill", this._color);
            const R = I.createNS("http://www.w3.org/2000/svg", "path");
            R.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), M.appendChild(R);
            const O = I.createNS("http://www.w3.org/2000/svg", "g");
            O.setAttributeNS(null, "opacity", "0.25"), O.setAttributeNS(null, "fill", "#000000");
            const D = I.createNS("http://www.w3.org/2000/svg", "path");
            D.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), O.appendChild(D);
            const U = I.createNS("http://www.w3.org/2000/svg", "g");
            U.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), U.setAttributeNS(null, "fill", "#FFFFFF");
            const W = I.createNS("http://www.w3.org/2000/svg", "g");
            W.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
            const Q = I.createNS("http://www.w3.org/2000/svg", "circle");
            Q.setAttributeNS(null, "fill", "#000000"), Q.setAttributeNS(null, "opacity", "0.25"), Q.setAttributeNS(null, "cx", "5.5"), Q.setAttributeNS(null, "cy", "5.5"), Q.setAttributeNS(null, "r", "5.4999962");
            const Y = I.createNS("http://www.w3.org/2000/svg", "circle");
            Y.setAttributeNS(null, "fill", "#FFFFFF"), Y.setAttributeNS(null, "cx", "5.5"), Y.setAttributeNS(null, "cy", "5.5"), Y.setAttributeNS(null, "r", "5.4999962"), W.appendChild(Q), W.appendChild(Y), b.appendChild(x), b.appendChild(M), b.appendChild(O), b.appendChild(U), b.appendChild(W), f.appendChild(b), f.setAttributeNS(null, "height", _ * this._scale + "px"), f.setAttributeNS(null, "width", h * this._scale + "px"), this._element.appendChild(f), this._offset = l.P.convert(a && a.offset || [0, -14]);
          }
          if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (f) => {
            f.preventDefault();
          }), this._element.addEventListener("mousedown", (f) => {
            f.preventDefault();
          }), Ds(this._element, this._anchor, "marker"), a && a.className)
            for (const f of a.className.split(" "))
              this._element.classList.add(f);
          this._popup = null;
        }
        addTo(a) {
          return this.remove(), this._map = a, this._element.setAttribute("aria-label", a._getUIString("Marker.Title")), a.getCanvasContainer().appendChild(this._element), a.on("move", this._update), a.on("moveend", this._update), a.on("terrain", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
        }
        remove() {
          return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), I.remove(this._element), this._popup && this._popup.remove(), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(a) {
          return this._lngLat = l.N.convert(a), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
        }
        getElement() {
          return this._element;
        }
        setPopup(a) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), a) {
            if (!("offset" in a.options)) {
              const h = Math.abs(13.5) / Math.SQRT2;
              a.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [h, -1 * (38.1 - 13.5 + h)], "bottom-right": [-h, -1 * (38.1 - 13.5 + h)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
            }
            this._popup = a, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
          }
          return this;
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          const a = this._popup;
          return this._element.style.opacity === this._opacityWhenCovered ? this : a ? (a.isOpen() ? a.remove() : (a.setLngLat(this._lngLat), a.addTo(this._map)), this) : this;
        }
        _updateOpacity() {
          let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
          var f, _;
          if (!(!((f = this._map) === null || f === void 0) && f.terrain))
            return void (this._element.style.opacity !== this._opacity && (this._element.style.opacity = this._opacity));
          if (a)
            this._opacityTimeout = null;
          else {
            if (this._opacityTimeout)
              return;
            this._opacityTimeout = setTimeout(() => {
              this._opacityTimeout = null;
            }, 100);
          }
          const h = this._map, p = h.terrain.depthAtPoint(this._pos), b = h.terrain.getElevationForLngLatZoom(this._lngLat, h.transform.tileZoom);
          if (h.transform.lngLatToCameraDepth(this._lngLat, b) - p < 6e-3)
            return void (this._element.style.opacity = this._opacity);
          const x = -this._offset.y / h.transform._pixelPerMeter, C = Math.sin(h.getPitch() * Math.PI / 180) * x, M = h.terrain.depthAtPoint(new l.P(this._pos.x, this._pos.y - this._offset.y)), R = h.transform.lngLatToCameraDepth(this._lngLat, b + C) - M > 6e-3;
          !((_ = this._popup) === null || _ === void 0) && _.isOpen() && R && this._popup.remove(), this._element.style.opacity = R ? this._opacityWhenCovered : this._opacity;
        }
        getOffset() {
          return this._offset;
        }
        setOffset(a) {
          return this._offset = l.P.convert(a), this._update(), this;
        }
        addClassName(a) {
          this._element.classList.add(a);
        }
        removeClassName(a) {
          this._element.classList.remove(a);
        }
        toggleClassName(a) {
          return this._element.classList.toggle(a);
        }
        setDraggable(a) {
          return this._draggable = !!a, this._map && (a ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(a) {
          return this._rotation = a || 0, this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(a) {
          return this._rotationAlignment = a || "auto", this._update(), this;
        }
        getRotationAlignment() {
          return this._rotationAlignment;
        }
        setPitchAlignment(a) {
          return this._pitchAlignment = a && a !== "auto" ? a : this._rotationAlignment, this._update(), this;
        }
        getPitchAlignment() {
          return this._pitchAlignment;
        }
        setOpacity(a, f) {
          return a === void 0 && f === void 0 && (this._opacity = "1", this._opacityWhenCovered = "0.2"), a !== void 0 && (this._opacity = a), f !== void 0 && (this._opacityWhenCovered = f), this._map && this._updateOpacity(!0), this;
        }
      }
      const Rc = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 };
      let $l = 0, ll = !1;
      const Yh = { maxWidth: 100, unit: "metric" };
      function lh(E, a, f) {
        const _ = f && f.maxWidth || 100, h = E._container.clientHeight / 2, p = E.unproject([0, h]), b = E.unproject([_, h]), x = p.distanceTo(b);
        if (f && f.unit === "imperial") {
          const C = 3.2808 * x;
          C > 5280 ? Oc(a, _, C / 5280, E._getUIString("ScaleControl.Miles")) : Oc(a, _, C, E._getUIString("ScaleControl.Feet"));
        } else
          f && f.unit === "nautical" ? Oc(a, _, x / 1852, E._getUIString("ScaleControl.NauticalMiles")) : x >= 1e3 ? Oc(a, _, x / 1e3, E._getUIString("ScaleControl.Kilometers")) : Oc(a, _, x, E._getUIString("ScaleControl.Meters"));
      }
      function Oc(E, a, f, _) {
        const h = function(p) {
          const b = Math.pow(10, `${Math.floor(p)}`.length - 1);
          let x = p / b;
          return x = x >= 10 ? 10 : x >= 5 ? 5 : x >= 3 ? 3 : x >= 2 ? 2 : x >= 1 ? 1 : function(C) {
            const M = Math.pow(10, Math.ceil(-Math.log(C) / Math.LN10));
            return Math.round(C * M) / M;
          }(x), b * x;
        }(f);
        E.style.width = a * (h / f) + "px", E.innerHTML = `${h}&nbsp;${_}`;
      }
      const To = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px", subpixelPositioning: !1 }, mu = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
      function en(E) {
        if (E) {
          if (typeof E == "number") {
            const a = Math.round(Math.abs(E) / Math.SQRT2);
            return { center: new l.P(0, 0), top: new l.P(0, E), "top-left": new l.P(a, a), "top-right": new l.P(-a, a), bottom: new l.P(0, -E), "bottom-left": new l.P(a, -a), "bottom-right": new l.P(-a, -a), left: new l.P(E, 0), right: new l.P(-E, 0) };
          }
          if (E instanceof l.P || Array.isArray(E)) {
            const a = l.P.convert(E);
            return { center: a, top: a, "top-left": a, "top-right": a, bottom: a, "bottom-left": a, "bottom-right": a, left: a, right: a };
          }
          return { center: l.P.convert(E.center || [0, 0]), top: l.P.convert(E.top || [0, 0]), "top-left": l.P.convert(E["top-left"] || [0, 0]), "top-right": l.P.convert(E["top-right"] || [0, 0]), bottom: l.P.convert(E.bottom || [0, 0]), "bottom-left": l.P.convert(E["bottom-left"] || [0, 0]), "bottom-right": l.P.convert(E["bottom-right"] || [0, 0]), left: l.P.convert(E.left || [0, 0]), right: l.P.convert(E.right || [0, 0]) };
        }
        return en(new l.P(0, 0));
      }
      const pn = m;
      c.AJAXError = l.bg, c.Evented = l.E, c.LngLat = l.N, c.MercatorCoordinate = l.Z, c.Point = l.P, c.addProtocol = l.bh, c.config = l.a, c.removeProtocol = l.bi, c.AttributionControl = Wl, c.BoxZoomHandler = Pa, c.CanvasSource = xn, c.CooperativeGesturesHandler = xs, c.DoubleClickZoomHandler = nh, c.DragPanHandler = Os, c.DragRotateHandler = co, c.EdgeInsets = os, c.FullscreenControl = class extends l.E {
        constructor() {
          let E = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          super(), this._onFullscreenChange = () => {
            var a;
            let f = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
            for (; !((a = f == null ? void 0 : f.shadowRoot) === null || a === void 0) && a.fullscreenElement; )
              f = f.shadowRoot.fullscreenElement;
            f === this._container !== this._fullscreen && this._handleFullscreenChange();
          }, this._onClickFullscreen = () => {
            this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
          }, this._fullscreen = !1, E && E.container && (E.container instanceof HTMLElement ? this._container = E.container : l.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
        }
        onAdd(E) {
          return this._map = E, this._container || (this._container = this._map.getContainer()), this._controlContainer = I.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
        }
        onRemove() {
          I.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _setupUI() {
          const E = this._fullscreenButton = I.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
          I.create("span", "maplibregl-ctrl-icon", E).setAttribute("aria-hidden", "true"), E.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _updateTitle() {
          const E = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", E), this._fullscreenButton.title = E;
        }
        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }
        _isFullscreen() {
          return this._fullscreen;
        }
        _handleFullscreenChange() {
          this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new l.k("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new l.k("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
        }
        _exitFullscreen() {
          window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
        }
        _requestFullscreen() {
          this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
        }
        _togglePseudoFullScreen() {
          this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
        }
      }, c.GeoJSONSource = Lt, c.GeolocateControl = class extends l.E {
        constructor(E) {
          super(), this._onSuccess = (a) => {
            if (this._map) {
              if (this._isOutOfMapMaxBounds(a))
                return this._setErrorState(), this.fire(new l.k("outofmaxbounds", a)), this._updateMarker(), void this._finish();
              if (this.options.trackUserLocation)
                switch (this._lastKnownPosition = a, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
              this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(a), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(a), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new l.k("geolocate", a)), this._finish();
            }
          }, this._updateCamera = (a) => {
            const f = new l.N(a.coords.longitude, a.coords.latitude), _ = a.coords.accuracy, h = this._map.getBearing(), p = l.e({ bearing: h }, this.options.fitBoundsOptions), b = re.fromLngLat(f, _);
            this._map.fitBounds(b, p, { geolocateSource: !0 });
          }, this._updateMarker = (a) => {
            if (a) {
              const f = new l.N(a.coords.longitude, a.coords.latitude);
              this._accuracyCircleMarker.setLngLat(f).addTo(this._map), this._userLocationDotMarker.setLngLat(f).addTo(this._map), this._accuracy = a.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            } else
              this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
          }, this._onZoom = () => {
            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          }, this._onError = (a) => {
            if (this._map) {
              if (this.options.trackUserLocation)
                if (a.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                  const f = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = f, this._geolocateButton.setAttribute("aria-label", f), this._geolocationWatchID !== void 0 && this._clearWatch();
                } else {
                  if (a.code === 3 && ll)
                    return;
                  this._setErrorState();
                }
              this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new l.k("error", a)), this._finish();
            }
          }, this._finish = () => {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
          }, this._setupUI = (a) => {
            if (this._map) {
              if (this._container.addEventListener("contextmenu", (f) => f.preventDefault()), this._geolocateButton = I.create("button", "maplibregl-ctrl-geolocate", this._container), I.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", a === !1) {
                l.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                const f = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.disabled = !0, this._geolocateButton.title = f, this._geolocateButton.setAttribute("aria-label", f);
              } else {
                const f = this._map._getUIString("GeolocateControl.FindMyLocation");
                this._geolocateButton.title = f, this._geolocateButton.setAttribute("aria-label", f);
              }
              this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = I.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new pi({ element: this._dotElement }), this._circleElement = I.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new pi({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (f) => {
                f.geolocateSource || this._watchState !== "ACTIVE_LOCK" || f.originalEvent && f.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new l.k("trackuserlocationend")), this.fire(new l.k("userlocationlostfocus")));
              });
            }
          }, this.options = l.e({}, Rc, E);
        }
        onAdd(E) {
          return this._map = E, this._container = I.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), function() {
            return l._(this, arguments, void 0, function() {
              let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
              return function* () {
                if (Oa !== void 0 && !a)
                  return Oa;
                if (window.navigator.permissions === void 0)
                  return Oa = !!window.navigator.geolocation, Oa;
                try {
                  Oa = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
                } catch {
                  Oa = !!window.navigator.geolocation;
                }
                return Oa;
              }();
            });
          }().then((a) => this._setupUI(a)), this._container;
        }
        onRemove() {
          this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), I.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, $l = 0, ll = !1;
        }
        _isOutOfMapMaxBounds(E) {
          const a = this._map.getMaxBounds(), f = E.coords;
          return a && (f.longitude < a.getWest() || f.longitude > a.getEast() || f.latitude < a.getSouth() || f.latitude > a.getNorth());
        }
        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "ACTIVE_ERROR":
              break;
            default:
              throw new Error(`Unexpected watchState ${this._watchState}`);
          }
        }
        _updateCircleRadius() {
          const E = this._map.getBounds(), a = E.getSouthEast(), f = E.getNorthEast(), _ = a.distanceTo(f), h = Math.ceil(this._accuracy / (_ / this._map._container.clientHeight) * 2);
          this._circleElement.style.width = `${h}px`, this._circleElement.style.height = `${h}px`;
        }
        trigger() {
          if (!this._setup)
            return l.w("Geolocate control triggered before added to a map"), !1;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new l.k("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                $l--, ll = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new l.k("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new l.k("trackuserlocationstart")), this.fire(new l.k("userlocationfocus"));
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                break;
              case "OFF":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            if (this._watchState === "OFF" && this._geolocationWatchID !== void 0)
              this._clearWatch();
            else if (this._geolocationWatchID === void 0) {
              let E;
              this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), $l++, $l > 1 ? (E = { maximumAge: 6e5, timeout: 0 }, ll = !0) : (E = this.options.positionOptions, ll = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, E);
            }
          } else
            window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return !0;
        }
        _clearWatch() {
          window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }
      }, c.Hash = Yr, c.ImageSource = nn, c.KeyboardHandler = Pc, c.LngLatBounds = re, c.LogoControl = So, c.Map = class extends of {
        constructor(E) {
          l.be.mark(l.bf.create);
          const a = Object.assign(Object.assign({}, Zh), E);
          if (a.minZoom != null && a.maxZoom != null && a.minZoom > a.maxZoom)
            throw new Error("maxZoom must be greater than or equal to minZoom");
          if (a.minPitch != null && a.maxPitch != null && a.minPitch > a.maxPitch)
            throw new Error("maxPitch must be greater than or equal to minPitch");
          if (a.minPitch != null && a.minPitch < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (a.maxPitch != null && a.maxPitch > 85)
            throw new Error("maxPitch must be less than or equal to 85");
          if (super(new al(a.minZoom, a.maxZoom, a.minPitch, a.maxPitch, a.renderWorldCopies), { bearingSnap: a.bearingSnap }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new zt(), this._controls = [], this._mapId = l.a4(), this._contextLost = (f) => {
            f.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new l.k("webglcontextlost", { originalEvent: f }));
          }, this._contextRestored = (f) => {
            this._setupPainter(), this.resize(), this._update(), this.fire(new l.k("webglcontextrestored", { originalEvent: f }));
          }, this._onMapScroll = (f) => {
            if (f.target === this._container)
              return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
          }, this._onWindowOnline = () => {
            this._update();
          }, this._interactive = a.interactive, this._maxTileCacheSize = a.maxTileCacheSize, this._maxTileCacheZoomLevels = a.maxTileCacheZoomLevels, this._failIfMajorPerformanceCaveat = a.failIfMajorPerformanceCaveat === !0, this._preserveDrawingBuffer = a.preserveDrawingBuffer === !0, this._antialias = a.antialias === !0, this._trackResize = a.trackResize === !0, this._bearingSnap = a.bearingSnap, this._refreshExpiredTiles = a.refreshExpiredTiles === !0, this._fadeDuration = a.fadeDuration, this._crossSourceCollisions = a.crossSourceCollisions === !0, this._collectResourceTiming = a.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, Vt), a.locale), this._clickTolerance = a.clickTolerance, this._overridePixelRatio = a.pixelRatio, this._maxCanvasSize = a.maxCanvasSize, this.transformCameraUpdate = a.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = a.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = ce.addThrottleControl(() => this.isMoving()), this._requestManager = new me(a.transformRequest), typeof a.container == "string") {
            if (this._container = document.getElementById(a.container), !this._container)
              throw new Error(`Container '${a.container}' not found.`);
          } else {
            if (!(a.container instanceof HTMLElement))
              throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = a.container;
          }
          if (a.maxBounds && this.setMaxBounds(a.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(!1)).on("moveend", () => this._update(!1)).on("zoom", () => this._update(!0)).on("terrain", () => {
            this.painter.terrainFacilitator.dirty = !0, this._update(!0);
          }).once("idle", () => {
            this._idleTriggered = !0;
          }), typeof window < "u") {
            addEventListener("online", this._onWindowOnline, !1);
            let f = !1;
            const _ = so((h) => {
              this._trackResize && !this._removed && this.resize(h)._update();
            }, 50);
            this._resizeObserver = new ResizeObserver((h) => {
              f ? _(h) : f = !0;
            }), this._resizeObserver.observe(this._container);
          }
          this.handlers = new Jh(this, a), this._hash = a.hash && new Yr(typeof a.hash == "string" && a.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: a.center, zoom: a.zoom, bearing: a.bearing, pitch: a.pitch }), a.bounds && (this.resize(), this.fitBounds(a.bounds, l.e({}, a.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = a.localIdeographFontFamily, this._validateStyle = a.validateStyle, a.style && this.setStyle(a.style, { localIdeographFontFamily: a.localIdeographFontFamily }), a.attributionControl && this.addControl(new Wl(typeof a.attributionControl == "boolean" ? void 0 : a.attributionControl)), a.maplibreLogo && this.addControl(new So(), a.logoPosition), this.on("style.load", () => {
            this.transform.unmodified && this.jumpTo(this.style.stylesheet);
          }), this.on("data", (f) => {
            this._update(f.dataType === "style"), this.fire(new l.k(`${f.dataType}data`, f));
          }), this.on("dataloading", (f) => {
            this.fire(new l.k(`${f.dataType}dataloading`, f));
          }), this.on("dataabort", (f) => {
            this.fire(new l.k("sourcedataabort", f));
          });
        }
        _getMapId() {
          return this._mapId;
        }
        addControl(E, a) {
          if (a === void 0 && (a = E.getDefaultPosition ? E.getDefaultPosition() : "top-right"), !E || !E.onAdd)
            return this.fire(new l.j(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          const f = E.onAdd(this);
          this._controls.push(E);
          const _ = this._controlPositions[a];
          return a.indexOf("bottom") !== -1 ? _.insertBefore(f, _.firstChild) : _.appendChild(f), this;
        }
        removeControl(E) {
          if (!E || !E.onRemove)
            return this.fire(new l.j(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          const a = this._controls.indexOf(E);
          return a > -1 && this._controls.splice(a, 1), E.onRemove(this), this;
        }
        hasControl(E) {
          return this._controls.indexOf(E) > -1;
        }
        calculateCameraOptionsFromTo(E, a, f, _) {
          return _ == null && this.terrain && (_ = this.terrain.getElevationForLngLatZoom(f, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(E, a, f, _);
        }
        resize(E) {
          var a;
          const f = this._containerDimensions(), _ = f[0], h = f[1], p = this._getClampedPixelRatio(_, h);
          if (this._resizeCanvas(_, h, p), this.painter.resize(_, h, p), this.painter.overLimit()) {
            const x = this.painter.context.gl;
            this._maxCanvasSize = [x.drawingBufferWidth, x.drawingBufferHeight];
            const C = this._getClampedPixelRatio(_, h);
            this._resizeCanvas(_, h, C), this.painter.resize(_, h, C);
          }
          this.transform.resize(_, h), (a = this._requestedCameraState) === null || a === void 0 || a.resize(_, h);
          const b = !this._moving;
          return b && (this.stop(), this.fire(new l.k("movestart", E)).fire(new l.k("move", E))), this.fire(new l.k("resize", E)), b && this.fire(new l.k("moveend", E)), this;
        }
        _getClampedPixelRatio(E, a) {
          const { 0: f, 1: _ } = this._maxCanvasSize, h = this.getPixelRatio(), p = E * h, b = a * h;
          return Math.min(p > f ? f / p : 1, b > _ ? _ / b : 1) * h;
        }
        getPixelRatio() {
          var E;
          return (E = this._overridePixelRatio) !== null && E !== void 0 ? E : devicePixelRatio;
        }
        setPixelRatio(E) {
          this._overridePixelRatio = E, this.resize();
        }
        getBounds() {
          return this.transform.getBounds();
        }
        getMaxBounds() {
          return this.transform.getMaxBounds();
        }
        setMaxBounds(E) {
          return this.transform.setMaxBounds(re.convert(E)), this._update();
        }
        setMinZoom(E) {
          if ((E = E ?? -2) >= -2 && E <= this.transform.maxZoom)
            return this.transform.minZoom = E, this._update(), this.getZoom() < E && this.setZoom(E), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }
        getMinZoom() {
          return this.transform.minZoom;
        }
        setMaxZoom(E) {
          if ((E = E ?? 22) >= this.transform.minZoom)
            return this.transform.maxZoom = E, this._update(), this.getZoom() > E && this.setZoom(E), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        setMinPitch(E) {
          if ((E = E ?? 0) < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (E >= 0 && E <= this.transform.maxPitch)
            return this.transform.minPitch = E, this._update(), this.getPitch() < E && this.setPitch(E), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }
        getMinPitch() {
          return this.transform.minPitch;
        }
        setMaxPitch(E) {
          if ((E = E ?? 60) > 85)
            throw new Error("maxPitch must be less than or equal to 85");
          if (E >= this.transform.minPitch)
            return this.transform.maxPitch = E, this._update(), this.getPitch() > E && this.setPitch(E), this;
          throw new Error("maxPitch must be greater than the current minPitch");
        }
        getMaxPitch() {
          return this.transform.maxPitch;
        }
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        setRenderWorldCopies(E) {
          return this.transform.renderWorldCopies = E, this._update();
        }
        project(E) {
          return this.transform.locationPoint(l.N.convert(E), this.style && this.terrain);
        }
        unproject(E) {
          return this.transform.pointLocation(l.P.convert(E), this.terrain);
        }
        isMoving() {
          var E;
          return this._moving || ((E = this.handlers) === null || E === void 0 ? void 0 : E.isMoving());
        }
        isZooming() {
          var E;
          return this._zooming || ((E = this.handlers) === null || E === void 0 ? void 0 : E.isZooming());
        }
        isRotating() {
          var E;
          return this._rotating || ((E = this.handlers) === null || E === void 0 ? void 0 : E.isRotating());
        }
        _createDelegatedListener(E, a, f) {
          if (E === "mouseenter" || E === "mouseover") {
            let _ = !1;
            return { layer: a, listener: f, delegates: { mousemove: (p) => {
              const b = this.getLayer(a) ? this.queryRenderedFeatures(p.point, { layers: [a] }) : [];
              b.length ? _ || (_ = !0, f.call(this, new Gn(E, this, p.originalEvent, { features: b }))) : _ = !1;
            }, mouseout: () => {
              _ = !1;
            } } };
          }
          if (E === "mouseleave" || E === "mouseout") {
            let _ = !1;
            return { layer: a, listener: f, delegates: { mousemove: (b) => {
              (this.getLayer(a) ? this.queryRenderedFeatures(b.point, { layers: [a] }) : []).length ? _ = !0 : _ && (_ = !1, f.call(this, new Gn(E, this, b.originalEvent)));
            }, mouseout: (b) => {
              _ && (_ = !1, f.call(this, new Gn(E, this, b.originalEvent)));
            } } };
          }
          {
            const _ = (h) => {
              const p = this.getLayer(a) ? this.queryRenderedFeatures(h.point, { layers: [a] }) : [];
              p.length && (h.features = p, f.call(this, h), delete h.features);
            };
            return { layer: a, listener: f, delegates: { [E]: _ } };
          }
        }
        on(E, a, f) {
          if (f === void 0)
            return super.on(E, a);
          const _ = this._createDelegatedListener(E, a, f);
          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[E] = this._delegatedListeners[E] || [], this._delegatedListeners[E].push(_);
          for (const h in _.delegates)
            this.on(h, _.delegates[h]);
          return this;
        }
        once(E, a, f) {
          if (f === void 0)
            return super.once(E, a);
          const _ = this._createDelegatedListener(E, a, f);
          for (const h in _.delegates)
            this.once(h, _.delegates[h]);
          return this;
        }
        off(E, a, f) {
          return f === void 0 ? super.off(E, a) : (this._delegatedListeners && this._delegatedListeners[E] && ((_) => {
            const h = this._delegatedListeners[E];
            for (let p = 0; p < h.length; p++) {
              const b = h[p];
              if (b.layer === a && b.listener === f) {
                for (const x in b.delegates)
                  this.off(x, b.delegates[x]);
                return h.splice(p, 1), this;
              }
            }
          })(), this);
        }
        queryRenderedFeatures(E, a) {
          if (!this.style)
            return [];
          let f;
          const _ = E instanceof l.P || Array.isArray(E), h = _ ? E : [[0, 0], [this.transform.width, this.transform.height]];
          if (a = a || (_ ? {} : E) || {}, h instanceof l.P || typeof h[0] == "number")
            f = [l.P.convert(h)];
          else {
            const p = l.P.convert(h[0]), b = l.P.convert(h[1]);
            f = [p, new l.P(b.x, p.y), b, new l.P(p.x, b.y), p];
          }
          return this.style.queryRenderedFeatures(f, a, this.transform);
        }
        querySourceFeatures(E, a) {
          return this.style.querySourceFeatures(E, a);
        }
        setStyle(E, a) {
          return (a = l.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, a)).diff !== !1 && a.localIdeographFontFamily === this._localIdeographFontFamily && this.style && E ? (this._diffStyle(E, a), this) : (this._localIdeographFontFamily = a.localIdeographFontFamily, this._updateStyle(E, a));
        }
        setTransformRequest(E) {
          return this._requestManager.setTransformRequest(E), this;
        }
        _getUIString(E) {
          const a = this._locale[E];
          if (a == null)
            throw new Error(`Missing UI string '${E}'`);
          return a;
        }
        _updateStyle(E, a) {
          if (a.transformStyle && this.style && !this.style._loaded)
            return void this.style.once("style.load", () => this._updateStyle(E, a));
          const f = this.style && a.transformStyle ? this.style.serialize() : void 0;
          return this.style && (this.style.setEventedParent(null), this.style._remove(!E)), E ? (this.style = new Pr(this, a || {}), this.style.setEventedParent(this, { style: this.style }), typeof E == "string" ? this.style.loadURL(E, a, f) : this.style.loadJSON(E, a, f), this) : (delete this.style, this);
        }
        _lazyInitEmptyStyle() {
          this.style || (this.style = new Pr(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }
        _diffStyle(E, a) {
          if (typeof E == "string") {
            const f = this._requestManager.transformRequest(E, "Style");
            l.h(f, new AbortController()).then((_) => {
              this._updateDiff(_.data, a);
            }).catch((_) => {
              _ && this.fire(new l.j(_));
            });
          } else
            typeof E == "object" && this._updateDiff(E, a);
        }
        _updateDiff(E, a) {
          try {
            this.style.setState(E, a) && this._update(!0);
          } catch (f) {
            l.w(`Unable to perform style diff: ${f.message || f.error || f}.  Rebuilding the style from scratch.`), this._updateStyle(E, a);
          }
        }
        getStyle() {
          if (this.style)
            return this.style.serialize();
        }
        isStyleLoaded() {
          return this.style ? this.style.loaded() : l.w("There is no style added to the map.");
        }
        addSource(E, a) {
          return this._lazyInitEmptyStyle(), this.style.addSource(E, a), this._update(!0);
        }
        isSourceLoaded(E) {
          const a = this.style && this.style.sourceCaches[E];
          if (a !== void 0)
            return a.loaded();
          this.fire(new l.j(new Error(`There is no source with ID '${E}'`)));
        }
        setTerrain(E) {
          if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), E) {
            const a = this.style.sourceCaches[E.source];
            if (!a)
              throw new Error(`cannot load terrain, because there exists no source with ID: ${E.source}`);
            this.terrain === null && a.reload();
            for (const f in this.style._layers) {
              const _ = this.style._layers[f];
              _.type === "hillshade" && _.source === E.source && l.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
            }
            this.terrain = new $h(this.painter, a, E), this.painter.renderToTexture = new As(this.painter, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._terrainDataCallback = (f) => {
              f.dataType === "style" ? this.terrain.sourceCache.freeRtt() : f.dataType === "source" && f.tile && (f.sourceId !== E.source || this._elevationFreeze || (this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.terrain.sourceCache.freeRtt(f.tile.tileID));
            }, this.style.on("data", this._terrainDataCallback);
          } else
            this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0;
          return this.fire(new l.k("terrain", { terrain: E })), this;
        }
        getTerrain() {
          var E, a;
          return (a = (E = this.terrain) === null || E === void 0 ? void 0 : E.options) !== null && a !== void 0 ? a : null;
        }
        areTilesLoaded() {
          const E = this.style && this.style.sourceCaches;
          for (const a in E) {
            const f = E[a]._tiles;
            for (const _ in f) {
              const h = f[_];
              if (h.state !== "loaded" && h.state !== "errored")
                return !1;
            }
          }
          return !0;
        }
        removeSource(E) {
          return this.style.removeSource(E), this._update(!0);
        }
        getSource(E) {
          return this.style.getSource(E);
        }
        addImage(E, a) {
          let f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          const { pixelRatio: _ = 1, sdf: h = !1, stretchX: p, stretchY: b, content: x, textFitWidth: C, textFitHeight: M } = f;
          if (this._lazyInitEmptyStyle(), !(a instanceof HTMLImageElement || l.b(a))) {
            if (a.width === void 0 || a.height === void 0)
              return this.fire(new l.j(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            {
              const { width: R, height: O, data: D } = a, U = a;
              return this.style.addImage(E, { data: new l.R({ width: R, height: O }, new Uint8Array(D)), pixelRatio: _, stretchX: p, stretchY: b, content: x, textFitWidth: C, textFitHeight: M, sdf: h, version: 0, userImage: U }), U.onAdd && U.onAdd(this, E), this;
            }
          }
          {
            const { width: R, height: O, data: D } = T.getImageData(a);
            this.style.addImage(E, { data: new l.R({ width: R, height: O }, D), pixelRatio: _, stretchX: p, stretchY: b, content: x, textFitWidth: C, textFitHeight: M, sdf: h, version: 0 });
          }
        }
        updateImage(E, a) {
          const f = this.style.getImage(E);
          if (!f)
            return this.fire(new l.j(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          const _ = a instanceof HTMLImageElement || l.b(a) ? T.getImageData(a) : a, { width: h, height: p, data: b } = _;
          if (h === void 0 || p === void 0)
            return this.fire(new l.j(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          if (h !== f.data.width || p !== f.data.height)
            return this.fire(new l.j(new Error("The width and height of the updated image must be that same as the previous version of the image")));
          const x = !(a instanceof HTMLImageElement || l.b(a));
          return f.data.replace(b, x), this.style.updateImage(E, f), this;
        }
        getImage(E) {
          return this.style.getImage(E);
        }
        hasImage(E) {
          return E ? !!this.style.getImage(E) : (this.fire(new l.j(new Error("Missing required image id"))), !1);
        }
        removeImage(E) {
          this.style.removeImage(E);
        }
        loadImage(E) {
          return ce.getImage(this._requestManager.transformRequest(E, "Image"), new AbortController());
        }
        listImages() {
          return this.style.listImages();
        }
        addLayer(E, a) {
          return this._lazyInitEmptyStyle(), this.style.addLayer(E, a), this._update(!0);
        }
        moveLayer(E, a) {
          return this.style.moveLayer(E, a), this._update(!0);
        }
        removeLayer(E) {
          return this.style.removeLayer(E), this._update(!0);
        }
        getLayer(E) {
          return this.style.getLayer(E);
        }
        getLayersOrder() {
          return this.style.getLayersOrder();
        }
        setLayerZoomRange(E, a, f) {
          return this.style.setLayerZoomRange(E, a, f), this._update(!0);
        }
        setFilter(E, a) {
          let f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return this.style.setFilter(E, a, f), this._update(!0);
        }
        getFilter(E) {
          return this.style.getFilter(E);
        }
        setPaintProperty(E, a, f) {
          let _ = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          return this.style.setPaintProperty(E, a, f, _), this._update(!0);
        }
        getPaintProperty(E, a) {
          return this.style.getPaintProperty(E, a);
        }
        setLayoutProperty(E, a, f) {
          let _ = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          return this.style.setLayoutProperty(E, a, f, _), this._update(!0);
        }
        getLayoutProperty(E, a) {
          return this.style.getLayoutProperty(E, a);
        }
        setGlyphs(E) {
          let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return this._lazyInitEmptyStyle(), this.style.setGlyphs(E, a), this._update(!0);
        }
        getGlyphs() {
          return this.style.getGlyphsUrl();
        }
        addSprite(E, a) {
          let f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return this._lazyInitEmptyStyle(), this.style.addSprite(E, a, f, (_) => {
            _ || this._update(!0);
          }), this;
        }
        removeSprite(E) {
          return this._lazyInitEmptyStyle(), this.style.removeSprite(E), this._update(!0);
        }
        getSprite() {
          return this.style.getSprite();
        }
        setSprite(E) {
          let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return this._lazyInitEmptyStyle(), this.style.setSprite(E, a, (f) => {
            f || this._update(!0);
          }), this;
        }
        setLight(E) {
          let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return this._lazyInitEmptyStyle(), this.style.setLight(E, a), this._update(!0);
        }
        getLight() {
          return this.style.getLight();
        }
        setSky(E) {
          return this._lazyInitEmptyStyle(), this.style.setSky(E), this._update(!0);
        }
        getSky() {
          return this.style.getSky();
        }
        setFeatureState(E, a) {
          return this.style.setFeatureState(E, a), this._update();
        }
        removeFeatureState(E, a) {
          return this.style.removeFeatureState(E, a), this._update();
        }
        getFeatureState(E) {
          return this.style.getFeatureState(E);
        }
        getContainer() {
          return this._container;
        }
        getCanvasContainer() {
          return this._canvasContainer;
        }
        getCanvas() {
          return this._canvas;
        }
        _containerDimensions() {
          let E = 0, a = 0;
          return this._container && (E = this._container.clientWidth || 400, a = this._container.clientHeight || 300), [E, a];
        }
        _setupContainer() {
          const E = this._container;
          E.classList.add("maplibregl-map");
          const a = this._canvasContainer = I.create("div", "maplibregl-canvas-container", E);
          this._interactive && a.classList.add("maplibregl-interactive"), this._canvas = I.create("canvas", "maplibregl-canvas", a), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
          const f = this._containerDimensions(), _ = this._getClampedPixelRatio(f[0], f[1]);
          this._resizeCanvas(f[0], f[1], _);
          const h = this._controlContainer = I.create("div", "maplibregl-control-container", E), p = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((b) => {
            p[b] = I.create("div", `maplibregl-ctrl-${b} `, h);
          }), this._container.addEventListener("scroll", this._onMapScroll, !1);
        }
        _resizeCanvas(E, a, f) {
          this._canvas.width = Math.floor(f * E), this._canvas.height = Math.floor(f * a), this._canvas.style.width = `${E}px`, this._canvas.style.height = `${a}px`;
        }
        _setupPainter() {
          const E = { alpha: !0, stencil: !0, depth: !0, failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || !1 };
          let a = null;
          this._canvas.addEventListener("webglcontextcreationerror", (_) => {
            a = { requestedAttributes: E }, _ && (a.statusMessage = _.statusMessage, a.type = _.type);
          }, { once: !0 });
          const f = this._canvas.getContext("webgl2", E) || this._canvas.getContext("webgl", E);
          if (!f) {
            const _ = "Failed to initialize WebGL";
            throw a ? (a.message = _, new Error(JSON.stringify(a))) : new Error(_);
          }
          this.painter = new ro(f, this.transform), L.testSupport(f);
        }
        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }
        _update(E) {
          return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || E, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
        }
        _requestRenderFrame(E) {
          return this._update(), this._renderTaskQueue.add(E);
        }
        _cancelRenderFrame(E) {
          this._renderTaskQueue.remove(E);
        }
        _render(E) {
          const a = this._idleTriggered ? this._fadeDuration : 0;
          if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(E), this._removed)
            return;
          let f = !1;
          if (this.style && this._styleDirty) {
            this._styleDirty = !1;
            const h = this.transform.zoom, p = T.now();
            this.style.zoomHistory.update(h, p);
            const b = new l.a9(h, { now: p, fadeDuration: a, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), x = b.crossFadingFactor();
            x === 1 && x === this._crossFadingFactor || (f = !0, this._crossFadingFactor = x), this.style.update(b);
          }
          this.style && this._sourcesDirty && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._elevationFreeze || (this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, a, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: a, showPadding: this.showPadding }), this.fire(new l.k("render")), this.loaded() && !this._loaded && (this._loaded = !0, l.be.mark(l.bf.load), this.fire(new l.k("load"))), this.style && (this.style.hasTransitions() || f) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
          const _ = this._sourcesDirty || this._styleDirty || this._placementDirty;
          return _ || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new l.k("idle")), !this._loaded || this._fullyLoaded || _ || (this._fullyLoaded = !0, l.be.mark(l.bf.fullLoad)), this;
        }
        redraw() {
          return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
        }
        remove() {
          var E;
          this._hash && this._hash.remove();
          for (const f of this._controls)
            f.onRemove(this);
          this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), ce.removeThrottleControl(this._imageQueueHandle), (E = this._resizeObserver) === null || E === void 0 || E.disconnect();
          const a = this.painter.context.gl.getExtension("WEBGL_lose_context");
          a != null && a.loseContext && a.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), I.remove(this._canvasContainer), I.remove(this._controlContainer), this._container.classList.remove("maplibregl-map"), l.be.clearMetrics(), this._removed = !0, this.fire(new l.k("remove"));
        }
        triggerRepaint() {
          this.style && !this._frameRequest && (this._frameRequest = new AbortController(), T.frameAsync(this._frameRequest).then((E) => {
            l.be.frame(E), this._frameRequest = null, this._render(E);
          }).catch(() => {
          }));
        }
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(E) {
          this._showTileBoundaries !== E && (this._showTileBoundaries = E, this._update());
        }
        get showPadding() {
          return !!this._showPadding;
        }
        set showPadding(E) {
          this._showPadding !== E && (this._showPadding = E, this._update());
        }
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(E) {
          this._showCollisionBoxes !== E && (this._showCollisionBoxes = E, E ? this.style._generateCollisionBoxes() : this._update());
        }
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(E) {
          this._showOverdrawInspector !== E && (this._showOverdrawInspector = E, this._update());
        }
        get repaint() {
          return !!this._repaint;
        }
        set repaint(E) {
          this._repaint !== E && (this._repaint = E, this.triggerRepaint());
        }
        get vertices() {
          return !!this._vertices;
        }
        set vertices(E) {
          this._vertices = E, this._update();
        }
        get version() {
          return sh;
        }
        getCameraTargetElevation() {
          return this.transform.elevation;
        }
      }, c.MapMouseEvent = Gn, c.MapTouchEvent = ci, c.MapWheelEvent = Zi, c.Marker = pi, c.NavigationControl = class {
        constructor(E) {
          this._updateZoomButtons = () => {
            const a = this._map.getZoom(), f = a === this._map.getMaxZoom(), _ = a === this._map.getMinZoom();
            this._zoomInButton.disabled = f, this._zoomOutButton.disabled = _, this._zoomInButton.setAttribute("aria-disabled", f.toString()), this._zoomOutButton.setAttribute("aria-disabled", _.toString());
          }, this._rotateCompassArrow = () => {
            const a = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
            this._compassIcon.style.transform = a;
          }, this._setButtonTitle = (a, f) => {
            const _ = this._map._getUIString(`NavigationControl.${f}`);
            a.title = _, a.setAttribute("aria-label", _);
          }, this.options = l.e({}, gu, E), this._container = I.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (a) => a.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (a) => this._map.zoomIn({}, { originalEvent: a })), I.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (a) => this._map.zoomOut({}, { originalEvent: a })), I.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (a) => {
            this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: a }) : this._map.resetNorth({}, { originalEvent: a });
          }), this._compassIcon = I.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
        }
        onAdd(E) {
          return this._map = E, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new ah(this._map, this._compass, this.options.visualizePitch)), this._container;
        }
        onRemove() {
          I.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
        }
        _createButton(E, a) {
          const f = I.create("button", E, this._container);
          return f.type = "button", f.addEventListener("click", a), f;
        }
      }, c.Popup = class extends l.E {
        constructor(E) {
          super(), this.remove = () => (this._content && I.remove(this._content), this._container && (I.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new l.k("close"))), this), this._onMouseUp = (a) => {
            this._update(a.point);
          }, this._onMouseMove = (a) => {
            this._update(a.point);
          }, this._onDrag = (a) => {
            this._update(a.point);
          }, this._update = (a) => {
            var f;
            if (!this._map || !this._lngLat && !this._trackPointer || !this._content)
              return;
            if (!this._container) {
              if (this._container = I.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = I.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className)
                for (const x of this.options.className.split(" "))
                  this._container.classList.add(x);
              this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
            }
            if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = this._map.transform.renderWorldCopies && !this._trackPointer ? Bc(this._lngLat, this._flatPos, this._map.transform) : (f = this._lngLat) === null || f === void 0 ? void 0 : f.wrap(), this._trackPointer && !a)
              return;
            const _ = this._flatPos = this._pos = this._trackPointer && a ? a : this._map.project(this._lngLat);
            this._map.terrain && (this._flatPos = this._trackPointer && a ? a : this._map.transform.locationPoint(this._lngLat));
            let h = this.options.anchor;
            const p = en(this.options.offset);
            if (!h) {
              const x = this._container.offsetWidth, C = this._container.offsetHeight;
              let M;
              M = _.y + p.bottom.y < C ? ["top"] : _.y > this._map.transform.height - C ? ["bottom"] : [], _.x < x / 2 ? M.push("left") : _.x > this._map.transform.width - x / 2 && M.push("right"), h = M.length === 0 ? "bottom" : M.join("-");
            }
            let b = _.add(p[h]);
            this.options.subpixelPositioning || (b = b.round()), I.setTransform(this._container, `${Jl[h]} translate(${b.x}px,${b.y}px)`), Ds(this._container, h, "popup");
          }, this._onClose = () => {
            this.remove();
          }, this.options = l.e(Object.create(To), E);
        }
        addTo(E) {
          return this._map && this.remove(), this._map = E, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new l.k("open")), this;
        }
        isOpen() {
          return !!this._map;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(E) {
          return this._lngLat = l.N.convert(E), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
        }
        trackPointer() {
          return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
        }
        getElement() {
          return this._container;
        }
        setText(E) {
          return this.setDOMContent(document.createTextNode(E));
        }
        setHTML(E) {
          const a = document.createDocumentFragment(), f = document.createElement("body");
          let _;
          for (f.innerHTML = E; _ = f.firstChild, _; )
            a.appendChild(_);
          return this.setDOMContent(a);
        }
        getMaxWidth() {
          var E;
          return (E = this._container) === null || E === void 0 ? void 0 : E.style.maxWidth;
        }
        setMaxWidth(E) {
          return this.options.maxWidth = E, this._update(), this;
        }
        setDOMContent(E) {
          if (this._content)
            for (; this._content.hasChildNodes(); )
              this._content.firstChild && this._content.removeChild(this._content.firstChild);
          else
            this._content = I.create("div", "maplibregl-popup-content", this._container);
          return this._content.appendChild(E), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
        }
        addClassName(E) {
          return this._container && this._container.classList.add(E), this;
        }
        removeClassName(E) {
          return this._container && this._container.classList.remove(E), this;
        }
        setOffset(E) {
          return this.options.offset = E, this._update(), this;
        }
        toggleClassName(E) {
          if (this._container)
            return this._container.classList.toggle(E);
        }
        setSubpixelPositioning(E) {
          this.options.subpixelPositioning = E;
        }
        _createCloseButton() {
          this.options.closeButton && (this._closeButton = I.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
        }
        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container)
            return;
          const E = this._container.querySelector(mu);
          E && E.focus();
        }
      }, c.RasterDEMTileSource = Et, c.RasterTileSource = pt, c.ScaleControl = class {
        constructor(E) {
          this._onMove = () => {
            lh(this._map, this._container, this.options);
          }, this.setUnit = (a) => {
            this.options.unit = a, lh(this._map, this._container, this.options);
          }, this.options = Object.assign(Object.assign({}, Yh), E);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(E) {
          return this._map = E, this._container = I.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", E.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
        }
        onRemove() {
          I.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
        }
      }, c.ScrollZoomHandler = pu, c.Style = Pr, c.TerrainControl = class {
        constructor(E) {
          this._toggleTerrain = () => {
            this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
          }, this._updateTerrainIcon = () => {
            this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
          }, this.options = E;
        }
        onAdd(E) {
          return this._map = E, this._container = I.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = I.create("button", "maplibregl-ctrl-terrain", this._container), I.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
        }
        onRemove() {
          I.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
        }
      }, c.TwoFingersTouchPitchHandler = Cc, c.TwoFingersTouchRotateHandler = fu, c.TwoFingersTouchZoomHandler = Hl, c.TwoFingersTouchZoomRotateHandler = Mc, c.VectorTileSource = Qt, c.VideoSource = Tn, c.addSourceType = (E, a) => l._(void 0, void 0, void 0, function* () {
        if (Un(E))
          throw new Error(`A source type called "${E}" already exists.`);
        ((f, _) => {
          On[f] = _;
        })(E, a);
      }), c.clearPrewarmedResources = function() {
        const E = We;
        E && (E.isPreloaded() && E.numActive() === 1 ? (E.release(Ce), We = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, c.getMaxParallelImageRequests = function() {
        return l.a.MAX_PARALLEL_IMAGE_REQUESTS;
      }, c.getRTLTextPluginStatus = function() {
        return Bt().getRTLTextPluginStatus();
      }, c.getVersion = function() {
        return pn;
      }, c.getWorkerCount = function() {
        return Ue.workerCount;
      }, c.getWorkerUrl = function() {
        return l.a.WORKER_URL;
      }, c.importScriptInWorkers = function(E) {
        return It().broadcast("IS", E);
      }, c.prewarm = function() {
        Ze().acquire(Ce);
      }, c.setMaxParallelImageRequests = function(E) {
        l.a.MAX_PARALLEL_IMAGE_REQUESTS = E;
      }, c.setRTLTextPlugin = function(E, a) {
        return Bt().setRTLTextPlugin(E, a);
      }, c.setWorkerCount = function(E) {
        Ue.workerCount = E;
      }, c.setWorkerUrl = function(E) {
        l.a.WORKER_URL = E;
      };
    });
    var s = t;
    return s;
  });
})(h5);
var f5 = h5.exports;
const hs = /* @__PURE__ */ Ap(f5);
var gs;
(function(n) {
  n[n.Unknown = 0] = "Unknown", n[n.Point = 1] = "Point", n[n.LineString = 2] = "LineString", n[n.Polygon = 3] = "Polygon", n[n.MultiPoint = 4] = "MultiPoint", n[n.MultiLineString = 5] = "MultiLineString", n[n.MultiPolygon = 6] = "MultiPolygon", n[n.GeometryCollection = 7] = "GeometryCollection", n[n.CircularString = 8] = "CircularString", n[n.CompoundCurve = 9] = "CompoundCurve", n[n.CurvePolygon = 10] = "CurvePolygon", n[n.MultiCurve = 11] = "MultiCurve", n[n.MultiSurface = 12] = "MultiSurface", n[n.Curve = 13] = "Curve", n[n.Surface = 14] = "Surface", n[n.PolyhedralSurface = 15] = "PolyhedralSurface", n[n.TIN = 16] = "TIN", n[n.Triangle = 17] = "Triangle";
})(gs || (gs = {}));
const Mf = 4, Bf = 4, Ep = 4, ju = new Int32Array(2), a2 = new Float32Array(ju.buffer), l2 = new Float64Array(ju.buffer), cg = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
var $_;
(function(n) {
  n[n.UTF8_BYTES = 1] = "UTF8_BYTES", n[n.UTF16_STRING = 2] = "UTF16_STRING";
})($_ || ($_ = {}));
class Qc {
  /**
   * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
   */
  constructor(e) {
    this.bytes_ = e, this.position_ = 0, this.text_decoder_ = new TextDecoder();
  }
  /**
   * Create and allocate a new ByteBuffer with a given size.
   */
  static allocate(e) {
    return new Qc(new Uint8Array(e));
  }
  clear() {
    this.position_ = 0;
  }
  /**
   * Get the underlying `Uint8Array`.
   */
  bytes() {
    return this.bytes_;
  }
  /**
   * Get the buffer's position.
   */
  position() {
    return this.position_;
  }
  /**
   * Set the buffer's position.
   */
  setPosition(e) {
    this.position_ = e;
  }
  /**
   * Get the buffer's capacity.
   */
  capacity() {
    return this.bytes_.length;
  }
  readInt8(e) {
    return this.readUint8(e) << 24 >> 24;
  }
  readUint8(e) {
    return this.bytes_[e];
  }
  readInt16(e) {
    return this.readUint16(e) << 16 >> 16;
  }
  readUint16(e) {
    return this.bytes_[e] | this.bytes_[e + 1] << 8;
  }
  readInt32(e) {
    return this.bytes_[e] | this.bytes_[e + 1] << 8 | this.bytes_[e + 2] << 16 | this.bytes_[e + 3] << 24;
  }
  readUint32(e) {
    return this.readInt32(e) >>> 0;
  }
  readInt64(e) {
    return BigInt.asIntN(64, BigInt(this.readUint32(e)) + (BigInt(this.readUint32(e + 4)) << BigInt(32)));
  }
  readUint64(e) {
    return BigInt.asUintN(64, BigInt(this.readUint32(e)) + (BigInt(this.readUint32(e + 4)) << BigInt(32)));
  }
  readFloat32(e) {
    return ju[0] = this.readInt32(e), a2[0];
  }
  readFloat64(e) {
    return ju[cg ? 0 : 1] = this.readInt32(e), ju[cg ? 1 : 0] = this.readInt32(e + 4), l2[0];
  }
  writeInt8(e, t) {
    this.bytes_[e] = t;
  }
  writeUint8(e, t) {
    this.bytes_[e] = t;
  }
  writeInt16(e, t) {
    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8;
  }
  writeUint16(e, t) {
    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8;
  }
  writeInt32(e, t) {
    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8, this.bytes_[e + 2] = t >> 16, this.bytes_[e + 3] = t >> 24;
  }
  writeUint32(e, t) {
    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8, this.bytes_[e + 2] = t >> 16, this.bytes_[e + 3] = t >> 24;
  }
  writeInt64(e, t) {
    this.writeInt32(e, Number(BigInt.asIntN(32, t))), this.writeInt32(e + 4, Number(BigInt.asIntN(32, t >> BigInt(32))));
  }
  writeUint64(e, t) {
    this.writeUint32(e, Number(BigInt.asUintN(32, t))), this.writeUint32(e + 4, Number(BigInt.asUintN(32, t >> BigInt(32))));
  }
  writeFloat32(e, t) {
    a2[0] = t, this.writeInt32(e, ju[0]);
  }
  writeFloat64(e, t) {
    l2[0] = t, this.writeInt32(e, ju[cg ? 0 : 1]), this.writeInt32(e + 4, ju[cg ? 1 : 0]);
  }
  /**
   * Return the file identifier.   Behavior is undefined for FlatBuffers whose
   * schema does not include a file_identifier (likely points at padding or the
   * start of a the root vtable).
   */
  getBufferIdentifier() {
    if (this.bytes_.length < this.position_ + Mf + Bf)
      throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
    let e = "";
    for (let t = 0; t < Bf; t++)
      e += String.fromCharCode(this.readInt8(this.position_ + Mf + t));
    return e;
  }
  /**
   * Look up a field in the vtable, return an offset into the object, or 0 if the
   * field is not present.
   */
  __offset(e, t) {
    const i = e - this.readInt32(e);
    return t < this.readInt16(i) ? this.readInt16(i + t) : 0;
  }
  /**
   * Initialize any Table-derived type to point to the union at the given offset.
   */
  __union(e, t) {
    return e.bb_pos = t + this.readInt32(t), e.bb = this, e;
  }
  /**
   * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
   * This allocates a new string and converts to wide chars upon each access.
   *
   * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the
   * "optionalEncoding" argument. This is useful for avoiding conversion when
   * the data will just be packaged back up in another FlatBuffer later on.
   *
   * @param offset
   * @param opt_encoding Defaults to UTF16_STRING
   */
  __string(e, t) {
    e += this.readInt32(e);
    const i = this.readInt32(e);
    e += Mf;
    const r = this.bytes_.subarray(e, e + i);
    return t === $_.UTF8_BYTES ? r : this.text_decoder_.decode(r);
  }
  /**
   * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
   * if a string then return a new one
   *
   * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
   * makes the behaviour of __union_with_string different compared to __union
   */
  __union_with_string(e, t) {
    return typeof e == "string" ? this.__string(t) : this.__union(e, t);
  }
  /**
   * Retrieve the relative offset stored at "offset"
   */
  __indirect(e) {
    return e + this.readInt32(e);
  }
  /**
   * Get the start of data of a vector whose offset is stored at "offset" in this object.
   */
  __vector(e) {
    return e + this.readInt32(e) + Mf;
  }
  /**
   * Get the length of a vector whose offset is stored at "offset" in this object.
   */
  __vector_len(e) {
    return this.readInt32(e + this.readInt32(e));
  }
  __has_identifier(e) {
    if (e.length != Bf)
      throw new Error("FlatBuffers: file identifier must be length " + Bf);
    for (let t = 0; t < Bf; t++)
      if (e.charCodeAt(t) != this.readInt8(this.position() + Mf + t))
        return !1;
    return !0;
  }
  /**
   * A helper function for generating list for obj api
   */
  createScalarList(e, t) {
    const i = [];
    for (let r = 0; r < t; ++r) {
      const s = e(r);
      s !== null && i.push(s);
    }
    return i;
  }
  /**
   * A helper function for generating list for obj api
   * @param listAccessor function that accepts an index and return data at that index
   * @param listLength listLength
   * @param res result list
   */
  createObjList(e, t) {
    const i = [];
    for (let r = 0; r < t; ++r) {
      const s = e(r);
      s !== null && i.push(s.unpack());
    }
    return i;
  }
}
let KC = class Bo {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsGeometry(e, t) {
    return (t || new Bo()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsGeometry(e, t) {
    return e.setPosition(e.position() + Ep), (t || new Bo()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  ends(e) {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readUint32(this.bb.__vector(this.bb_pos + t) + e * 4) : 0;
  }
  endsLength() {
    const e = this.bb.__offset(this.bb_pos, 4);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  endsArray() {
    const e = this.bb.__offset(this.bb_pos, 4);
    return e ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  xy(e) {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + e * 8) : 0;
  }
  xyLength() {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  xyArray() {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  z(e) {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + e * 8) : 0;
  }
  zLength() {
    const e = this.bb.__offset(this.bb_pos, 8);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  zArray() {
    const e = this.bb.__offset(this.bb_pos, 8);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  m(e) {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + e * 8) : 0;
  }
  mLength() {
    const e = this.bb.__offset(this.bb_pos, 10);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  mArray() {
    const e = this.bb.__offset(this.bb_pos, 10);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  t(e) {
    const t = this.bb.__offset(this.bb_pos, 12);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + e * 8) : 0;
  }
  tLength() {
    const e = this.bb.__offset(this.bb_pos, 12);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  tArray() {
    const e = this.bb.__offset(this.bb_pos, 12);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  tm(e) {
    const t = this.bb.__offset(this.bb_pos, 14);
    return t ? this.bb.readUint64(this.bb.__vector(this.bb_pos + t) + e * 8) : BigInt(0);
  }
  tmLength() {
    const e = this.bb.__offset(this.bb_pos, 14);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  type() {
    const e = this.bb.__offset(this.bb_pos, 16);
    return e ? this.bb.readUint8(this.bb_pos + e) : gs.Unknown;
  }
  parts(e, t) {
    const i = this.bb.__offset(this.bb_pos, 18);
    return i ? (t || new Bo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + e * 4), this.bb) : null;
  }
  partsLength() {
    const e = this.bb.__offset(this.bb_pos, 18);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  static startGeometry(e) {
    e.startObject(8);
  }
  static addEnds(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static createEndsVector(e, t) {
    e.startVector(4, t.length, 4);
    for (let i = t.length - 1; i >= 0; i--)
      e.addInt32(t[i]);
    return e.endVector();
  }
  static startEndsVector(e, t) {
    e.startVector(4, t, 4);
  }
  static addXy(e, t) {
    e.addFieldOffset(1, t, 0);
  }
  static createXyVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let i = t.length - 1; i >= 0; i--)
      e.addFloat64(t[i]);
    return e.endVector();
  }
  static startXyVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addZ(e, t) {
    e.addFieldOffset(2, t, 0);
  }
  static createZVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let i = t.length - 1; i >= 0; i--)
      e.addFloat64(t[i]);
    return e.endVector();
  }
  static startZVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addM(e, t) {
    e.addFieldOffset(3, t, 0);
  }
  static createMVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let i = t.length - 1; i >= 0; i--)
      e.addFloat64(t[i]);
    return e.endVector();
  }
  static startMVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addT(e, t) {
    e.addFieldOffset(4, t, 0);
  }
  static createTVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let i = t.length - 1; i >= 0; i--)
      e.addFloat64(t[i]);
    return e.endVector();
  }
  static startTVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addTm(e, t) {
    e.addFieldOffset(5, t, 0);
  }
  static createTmVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let i = t.length - 1; i >= 0; i--)
      e.addInt64(t[i]);
    return e.endVector();
  }
  static startTmVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addType(e, t) {
    e.addFieldInt8(6, t, gs.Unknown);
  }
  static addParts(e, t) {
    e.addFieldOffset(7, t, 0);
  }
  static createPartsVector(e, t) {
    e.startVector(4, t.length, 4);
    for (let i = t.length - 1; i >= 0; i--)
      e.addOffset(t[i]);
    return e.endVector();
  }
  static startPartsVector(e, t) {
    e.startVector(4, t, 4);
  }
  static endGeometry(e) {
    return e.endObject();
  }
  static createGeometry(e, t, i, r, s, c, l, m, y) {
    return Bo.startGeometry(e), Bo.addEnds(e, t), Bo.addXy(e, i), Bo.addZ(e, r), Bo.addM(e, s), Bo.addT(e, c), Bo.addTm(e, l), Bo.addType(e, m), Bo.addParts(e, y), Bo.endGeometry(e);
  }
};
function Z_(n, e) {
  const t = [];
  for (let i = 0; i < n.length; i += 2) {
    const r = [n[i], n[i + 1]];
    e && r.push(e[i >> 1]), t.push(r);
  }
  return t;
}
function c2(n, e, t) {
  if (!t || t.length === 0)
    return [Z_(n, e)];
  let i = 0;
  const r = Array.from(t).map((c) => n.slice(i, i = c << 1));
  let s;
  return e && (i = 0, s = Array.from(t).map((c) => e.slice(i, i = c))), r.map((c, l) => Z_(c, s ? s[l] : void 0));
}
function QC(n, e) {
  const t = n.xyArray(), i = n.zArray();
  switch (e) {
    case gs.Point: {
      const r = Array.from(t);
      return i && r.push(i[0]), r;
    }
    case gs.MultiPoint:
    case gs.LineString:
      return Z_(t, i);
    case gs.MultiLineString:
      return c2(t, i, n.endsArray());
    case gs.Polygon:
      return c2(t, i, n.endsArray());
  }
}
function Y_(n, e) {
  let t = e;
  if (t === gs.Unknown && (t = n.type()), t === gs.GeometryCollection) {
    const r = [];
    for (let s = 0; s < n.partsLength(); s++) {
      const c = n.parts(s), l = c.type();
      r.push(Y_(c, l));
    }
    return {
      type: gs[t],
      geometries: r
    };
  } else if (t === gs.MultiPolygon) {
    const r = [];
    for (let s = 0; s < n.partsLength(); s++)
      r.push(Y_(n.parts(s), gs.Polygon));
    return {
      type: gs[t],
      coordinates: r.map((s) => s.coordinates)
    };
  }
  const i = QC(n, t);
  return {
    type: gs[t],
    coordinates: i
  };
}
var fs;
(function(n) {
  n[n.Byte = 0] = "Byte", n[n.UByte = 1] = "UByte", n[n.Bool = 2] = "Bool", n[n.Short = 3] = "Short", n[n.UShort = 4] = "UShort", n[n.Int = 5] = "Int", n[n.UInt = 6] = "UInt", n[n.Long = 7] = "Long", n[n.ULong = 8] = "ULong", n[n.Float = 9] = "Float", n[n.Double = 10] = "Double", n[n.String = 11] = "String", n[n.Json = 12] = "Json", n[n.DateTime = 13] = "DateTime", n[n.Binary = 14] = "Binary";
})(fs || (fs = {}));
class ds {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsColumn(e, t) {
    return (t || new ds()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsColumn(e, t) {
    return e.setPosition(e.position() + Ep), (t || new ds()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  name(e) {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  type() {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.readUint8(this.bb_pos + e) : fs.Byte;
  }
  title(e) {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  description(e) {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  width() {
    const e = this.bb.__offset(this.bb_pos, 12);
    return e ? this.bb.readInt32(this.bb_pos + e) : -1;
  }
  precision() {
    const e = this.bb.__offset(this.bb_pos, 14);
    return e ? this.bb.readInt32(this.bb_pos + e) : -1;
  }
  scale() {
    const e = this.bb.__offset(this.bb_pos, 16);
    return e ? this.bb.readInt32(this.bb_pos + e) : -1;
  }
  nullable() {
    const e = this.bb.__offset(this.bb_pos, 18);
    return e ? !!this.bb.readInt8(this.bb_pos + e) : !0;
  }
  unique() {
    const e = this.bb.__offset(this.bb_pos, 20);
    return e ? !!this.bb.readInt8(this.bb_pos + e) : !1;
  }
  primaryKey() {
    const e = this.bb.__offset(this.bb_pos, 22);
    return e ? !!this.bb.readInt8(this.bb_pos + e) : !1;
  }
  metadata(e) {
    const t = this.bb.__offset(this.bb_pos, 24);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  static startColumn(e) {
    e.startObject(11);
  }
  static addName(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addType(e, t) {
    e.addFieldInt8(1, t, fs.Byte);
  }
  static addTitle(e, t) {
    e.addFieldOffset(2, t, 0);
  }
  static addDescription(e, t) {
    e.addFieldOffset(3, t, 0);
  }
  static addWidth(e, t) {
    e.addFieldInt32(4, t, -1);
  }
  static addPrecision(e, t) {
    e.addFieldInt32(5, t, -1);
  }
  static addScale(e, t) {
    e.addFieldInt32(6, t, -1);
  }
  static addNullable(e, t) {
    e.addFieldInt8(7, +t, 1);
  }
  static addUnique(e, t) {
    e.addFieldInt8(8, +t, 0);
  }
  static addPrimaryKey(e, t) {
    e.addFieldInt8(9, +t, 0);
  }
  static addMetadata(e, t) {
    e.addFieldOffset(10, t, 0);
  }
  static endColumn(e) {
    const t = e.endObject();
    return e.requiredField(t, 4), t;
  }
  static createColumn(e, t, i, r, s, c, l, m, y, A, T, I) {
    return ds.startColumn(e), ds.addName(e, t), ds.addType(e, i), ds.addTitle(e, r), ds.addDescription(e, s), ds.addWidth(e, c), ds.addPrecision(e, l), ds.addScale(e, m), ds.addNullable(e, y), ds.addUnique(e, A), ds.addPrimaryKey(e, T), ds.addMetadata(e, I), ds.endColumn(e);
  }
}
class wl {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsFeature(e, t) {
    return (t || new wl()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsFeature(e, t) {
    return e.setPosition(e.position() + Ep), (t || new wl()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  geometry(e) {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? (e || new KC()).__init(this.bb.__indirect(this.bb_pos + t), this.bb) : null;
  }
  properties(e) {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readUint8(this.bb.__vector(this.bb_pos + t) + e) : 0;
  }
  propertiesLength() {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  propertiesArray() {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  columns(e, t) {
    const i = this.bb.__offset(this.bb_pos, 8);
    return i ? (t || new ds()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + e * 4), this.bb) : null;
  }
  columnsLength() {
    const e = this.bb.__offset(this.bb_pos, 8);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  static startFeature(e) {
    e.startObject(3);
  }
  static addGeometry(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addProperties(e, t) {
    e.addFieldOffset(1, t, 0);
  }
  static createPropertiesVector(e, t) {
    e.startVector(1, t.length, 1);
    for (let i = t.length - 1; i >= 0; i--)
      e.addInt8(t[i]);
    return e.endVector();
  }
  static startPropertiesVector(e, t) {
    e.startVector(1, t, 1);
  }
  static addColumns(e, t) {
    e.addFieldOffset(2, t, 0);
  }
  static createColumnsVector(e, t) {
    e.startVector(4, t.length, 4);
    for (let i = t.length - 1; i >= 0; i--)
      e.addOffset(t[i]);
    return e.endVector();
  }
  static startColumnsVector(e, t) {
    e.startVector(4, t, 4);
  }
  static endFeature(e) {
    return e.endObject();
  }
  static finishFeatureBuffer(e, t) {
    e.finish(t);
  }
  static finishSizePrefixedFeatureBuffer(e, t) {
    e.finish(t, void 0, !0);
  }
  static createFeature(e, t, i, r) {
    return wl.startFeature(e), wl.addGeometry(e, t), wl.addProperties(e, i), wl.addColumns(e, r), wl.endFeature(e);
  }
}
new TextEncoder();
const u2 = new TextDecoder();
function eI(n, e) {
  const t = {};
  if (!e || e.length === 0)
    return t;
  const i = n.propertiesArray();
  if (!i)
    return t;
  const r = new DataView(i.buffer, i.byteOffset), s = n.propertiesLength();
  let c = 0;
  for (; c < s; ) {
    const l = r.getUint16(c, !0);
    c += 2;
    const m = e[l], y = m.name;
    switch (m.type) {
      case fs.Bool: {
        t[y] = !!r.getUint8(c), c += 1;
        break;
      }
      case fs.Byte: {
        t[y] = r.getInt8(c), c += 1;
        break;
      }
      case fs.UByte: {
        t[y] = r.getUint8(c), c += 1;
        break;
      }
      case fs.Short: {
        t[y] = r.getInt16(c, !0), c += 2;
        break;
      }
      case fs.UShort: {
        t[y] = r.getUint16(c, !0), c += 2;
        break;
      }
      case fs.Int: {
        t[y] = r.getInt32(c, !0), c += 4;
        break;
      }
      case fs.UInt: {
        t[y] = r.getUint32(c, !0), c += 4;
        break;
      }
      case fs.Long: {
        t[y] = Number(r.getBigInt64(c, !0)), c += 8;
        break;
      }
      case fs.ULong: {
        t[y] = Number(r.getBigUint64(c, !0)), c += 8;
        break;
      }
      case fs.Float: {
        t[y] = r.getFloat32(c, !0), c += 4;
        break;
      }
      case fs.Double: {
        t[y] = r.getFloat64(c, !0), c += 8;
        break;
      }
      case fs.DateTime:
      case fs.String: {
        const A = r.getUint32(c, !0);
        c += 4, t[y] = u2.decode(i.subarray(c, c + A)), c += A;
        break;
      }
      case fs.Json: {
        const A = r.getUint32(c, !0);
        c += 4;
        const T = u2.decode(i.subarray(c, c + A));
        t[y] = JSON.parse(T), c += A;
        break;
      }
      default:
        throw new Error("Unknown type " + m.type);
    }
  }
  return t;
}
function a1(n, e) {
  const t = e.columns;
  return {
    type: "Feature",
    geometry: Y_(n.geometry(), e.geometryType),
    properties: eI(n, t)
  };
}
const l1 = new Uint8Array(0);
function tI() {
  return this._source.cancel();
}
function nI(n, e) {
  if (!n.length)
    return e;
  if (!e.length)
    return n;
  var t = new Uint8Array(n.length + e.length);
  return t.set(n), t.set(e, n.length), t;
}
function iI() {
  var n = this, e = n._array.subarray(n._index);
  return n._source.read().then(function(t) {
    return n._array = l1, n._index = 0, t.done ? e.length > 0 ? {
      done: !1,
      value: e
    } : {
      done: !0,
      value: void 0
    } : {
      done: !1,
      value: nI(e, t.value)
    };
  });
}
function rI(n) {
  if ((n |= 0) < 0)
    throw new Error("invalid length");
  var e = this, t = this._array.length - this._index;
  if (this._index + n <= this._array.length)
    return Promise.resolve(this._array.subarray(this._index, this._index += n));
  var i = new Uint8Array(n);
  return i.set(this._array.subarray(this._index)), function r() {
    return e._source.read().then(function(s) {
      return s.done ? (e._array = l1, e._index = 0, t > 0 ? i.subarray(0, t) : null) : t + s.value.length >= n ? (e._array = s.value, e._index = n - t, i.set(s.value.subarray(0, n - t), t), i) : (i.set(s.value, t), t += s.value.length, r());
    });
  }();
}
function sI(n) {
  return typeof n.slice == "function" ? n : new Im(typeof n.read == "function" ? n : n.getReader());
}
function Im(n) {
  this._source = n, this._array = l1, this._index = 0;
}
Im.prototype.read = iI;
Im.prototype.slice = rI;
Im.prototype.cancel = tI;
class Va {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsCrs(e, t) {
    return (t || new Va()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsCrs(e, t) {
    return e.setPosition(e.position() + Ep), (t || new Va()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  org(e) {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  code() {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.readInt32(this.bb_pos + e) : 0;
  }
  name(e) {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  description(e) {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  wkt(e) {
    const t = this.bb.__offset(this.bb_pos, 12);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  codeString(e) {
    const t = this.bb.__offset(this.bb_pos, 14);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  static startCrs(e) {
    e.startObject(6);
  }
  static addOrg(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addCode(e, t) {
    e.addFieldInt32(1, t, 0);
  }
  static addName(e, t) {
    e.addFieldOffset(2, t, 0);
  }
  static addDescription(e, t) {
    e.addFieldOffset(3, t, 0);
  }
  static addWkt(e, t) {
    e.addFieldOffset(4, t, 0);
  }
  static addCodeString(e, t) {
    e.addFieldOffset(5, t, 0);
  }
  static endCrs(e) {
    return e.endObject();
  }
  static createCrs(e, t, i, r, s, c, l) {
    return Va.startCrs(e), Va.addOrg(e, t), Va.addCode(e, i), Va.addName(e, r), Va.addDescription(e, s), Va.addWkt(e, c), Va.addCodeString(e, l), Va.endCrs(e);
  }
}
class sm {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsHeader(e, t) {
    return (t || new sm()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsHeader(e, t) {
    return e.setPosition(e.position() + Ep), (t || new sm()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  name(e) {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  envelope(e) {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + e * 8) : 0;
  }
  envelopeLength() {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  envelopeArray() {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  geometryType() {
    const e = this.bb.__offset(this.bb_pos, 8);
    return e ? this.bb.readUint8(this.bb_pos + e) : gs.Unknown;
  }
  hasZ() {
    const e = this.bb.__offset(this.bb_pos, 10);
    return e ? !!this.bb.readInt8(this.bb_pos + e) : !1;
  }
  hasM() {
    const e = this.bb.__offset(this.bb_pos, 12);
    return e ? !!this.bb.readInt8(this.bb_pos + e) : !1;
  }
  hasT() {
    const e = this.bb.__offset(this.bb_pos, 14);
    return e ? !!this.bb.readInt8(this.bb_pos + e) : !1;
  }
  hasTm() {
    const e = this.bb.__offset(this.bb_pos, 16);
    return e ? !!this.bb.readInt8(this.bb_pos + e) : !1;
  }
  columns(e, t) {
    const i = this.bb.__offset(this.bb_pos, 18);
    return i ? (t || new ds()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + e * 4), this.bb) : null;
  }
  columnsLength() {
    const e = this.bb.__offset(this.bb_pos, 18);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  featuresCount() {
    const e = this.bb.__offset(this.bb_pos, 20);
    return e ? this.bb.readUint64(this.bb_pos + e) : BigInt("0");
  }
  indexNodeSize() {
    const e = this.bb.__offset(this.bb_pos, 22);
    return e ? this.bb.readUint16(this.bb_pos + e) : 16;
  }
  crs(e) {
    const t = this.bb.__offset(this.bb_pos, 24);
    return t ? (e || new Va()).__init(this.bb.__indirect(this.bb_pos + t), this.bb) : null;
  }
  title(e) {
    const t = this.bb.__offset(this.bb_pos, 26);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  description(e) {
    const t = this.bb.__offset(this.bb_pos, 28);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  metadata(e) {
    const t = this.bb.__offset(this.bb_pos, 30);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  static startHeader(e) {
    e.startObject(14);
  }
  static addName(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addEnvelope(e, t) {
    e.addFieldOffset(1, t, 0);
  }
  static createEnvelopeVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let i = t.length - 1; i >= 0; i--)
      e.addFloat64(t[i]);
    return e.endVector();
  }
  static startEnvelopeVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addGeometryType(e, t) {
    e.addFieldInt8(2, t, gs.Unknown);
  }
  static addHasZ(e, t) {
    e.addFieldInt8(3, +t, 0);
  }
  static addHasM(e, t) {
    e.addFieldInt8(4, +t, 0);
  }
  static addHasT(e, t) {
    e.addFieldInt8(5, +t, 0);
  }
  static addHasTm(e, t) {
    e.addFieldInt8(6, +t, 0);
  }
  static addColumns(e, t) {
    e.addFieldOffset(7, t, 0);
  }
  static createColumnsVector(e, t) {
    e.startVector(4, t.length, 4);
    for (let i = t.length - 1; i >= 0; i--)
      e.addOffset(t[i]);
    return e.endVector();
  }
  static startColumnsVector(e, t) {
    e.startVector(4, t, 4);
  }
  static addFeaturesCount(e, t) {
    e.addFieldInt64(8, t, BigInt("0"));
  }
  static addIndexNodeSize(e, t) {
    e.addFieldInt16(9, t, 16);
  }
  static addCrs(e, t) {
    e.addFieldOffset(10, t, 0);
  }
  static addTitle(e, t) {
    e.addFieldOffset(11, t, 0);
  }
  static addDescription(e, t) {
    e.addFieldOffset(12, t, 0);
  }
  static addMetadata(e, t) {
    e.addFieldOffset(13, t, 0);
  }
  static endHeader(e) {
    return e.endObject();
  }
  static finishHeaderBuffer(e, t) {
    e.finish(t);
  }
  static finishSizePrefixedHeaderBuffer(e, t) {
    e.finish(t, void 0, !0);
  }
}
function c1(n) {
  const e = sm.getRootAsHeader(n), t = e.featuresCount(), i = e.indexNodeSize(), r = [];
  for (let m = 0; m < e.columnsLength(); m++) {
    const y = e.columns(m);
    if (!y)
      throw new Error("Column unexpectedly missing");
    if (!y.name())
      throw new Error("Column name unexpectedly missing");
    r.push({
      name: y.name(),
      type: y.type(),
      title: y.title(),
      description: y.description(),
      width: y.width(),
      precision: y.precision(),
      scale: y.scale(),
      nullable: y.nullable(),
      unique: y.unique(),
      primary_key: y.primaryKey()
    });
  }
  const s = e.crs(), c = s ? {
    org: s.org(),
    code: s.code(),
    name: s.name(),
    description: s.description(),
    wkt: s.wkt(),
    code_string: s.codeString()
  } : null;
  return {
    geometryType: e.geometryType(),
    columns: r,
    envelope: null,
    featuresCount: Number(t),
    indexNodeSize: i,
    crs: c,
    title: e.title(),
    description: e.description(),
    metadata: e.metadata()
  };
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var K_ = function(n, e) {
  return K_ = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(t, i) {
    t.__proto__ = i;
  } || function(t, i) {
    for (var r in i)
      i.hasOwnProperty(r) && (t[r] = i[r]);
  }, K_(n, e);
};
function oI(n, e) {
  K_(n, e);
  function t() {
    this.constructor = n;
  }
  n.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
function Ud(n, e, t, i) {
  function r(s) {
    return s instanceof t ? s : new t(function(c) {
      c(s);
    });
  }
  return new (t || (t = Promise))(function(s, c) {
    function l(A) {
      try {
        y(i.next(A));
      } catch (T) {
        c(T);
      }
    }
    function m(A) {
      try {
        y(i.throw(A));
      } catch (T) {
        c(T);
      }
    }
    function y(A) {
      A.done ? s(A.value) : r(A.value).then(l, m);
    }
    y((i = i.apply(n, [])).next());
  });
}
function Xu(n, e) {
  var t = {
    label: 0,
    sent: function() {
      if (s[0] & 1)
        throw s[1];
      return s[1];
    },
    trys: [],
    ops: []
  }, i, r, s, c;
  return c = {
    next: l(0),
    throw: l(1),
    return: l(2)
  }, typeof Symbol == "function" && (c[Symbol.iterator] = function() {
    return this;
  }), c;
  function l(y) {
    return function(A) {
      return m([y, A]);
    };
  }
  function m(y) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (i = 1, r && (s = y[0] & 2 ? r.return : y[0] ? r.throw || ((s = r.return) && s.call(r), 0) : r.next) && !(s = s.call(r, y[1])).done)
          return s;
        switch (r = 0, s && (y = [y[0] & 2, s.value]), y[0]) {
          case 0:
          case 1:
            s = y;
            break;
          case 4:
            return t.label++, {
              value: y[1],
              done: !1
            };
          case 5:
            t.label++, r = y[1], y = [0];
            continue;
          case 7:
            y = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (y[0] === 6 || y[0] === 2)) {
              t = 0;
              continue;
            }
            if (y[0] === 3 && (!s || y[1] > s[0] && y[1] < s[3])) {
              t.label = y[1];
              break;
            }
            if (y[0] === 6 && t.label < s[1]) {
              t.label = s[1], s = y;
              break;
            }
            if (s && t.label < s[2]) {
              t.label = s[2], t.ops.push(y);
              break;
            }
            s[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        y = e.call(n, t);
      } catch (A) {
        y = [6, A], r = 0;
      } finally {
        i = s = 0;
      }
    if (y[0] & 5)
      throw y[1];
    return {
      value: y[0] ? y[1] : void 0,
      done: !0
    };
  }
}
function Kd(n) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && n[e], i = 0;
  if (t)
    return t.call(n);
  if (n && typeof n.length == "number")
    return {
      next: function() {
        return n && i >= n.length && (n = void 0), {
          value: n && n[i++],
          done: !n
        };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function cp(n) {
  return this instanceof cp ? (this.v = n, this) : new cp(n);
}
function aI(n, e, t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var i = t.apply(n, e || []), r, s = [];
  return r = {}, c("next"), c("throw"), c("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r;
  function c(I) {
    i[I] && (r[I] = function(L) {
      return new Promise(function(N, z) {
        s.push([I, L, N, z]) > 1 || l(I, L);
      });
    });
  }
  function l(I, L) {
    try {
      m(i[I](L));
    } catch (N) {
      T(s[0][3], N);
    }
  }
  function m(I) {
    I.value instanceof cp ? Promise.resolve(I.value.v).then(y, A) : T(s[0][2], I);
  }
  function y(I) {
    l("next", I);
  }
  function A(I) {
    l("throw", I);
  }
  function T(I, L) {
    I(L), s.shift(), s.length && l(s[0][0], s[0][1]);
  }
}
var p5 = (
  /** @class */
  function(n) {
    oI(e, n);
    function e(t) {
      var i = n.call(this, t) || this;
      return Object.defineProperty(i, "name", {
        value: "RepeaterOverflowError",
        enumerable: !1
      }), typeof Object.setPrototypeOf == "function" ? Object.setPrototypeOf(i, i.constructor.prototype) : i.__proto__ = i.constructor.prototype, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(i, i.constructor), i;
    }
    return e;
  }(Error)
);
(function() {
  function n(e) {
    if (e < 0)
      throw new RangeError("Capacity may not be less than 0");
    this._c = e, this._q = [];
  }
  return Object.defineProperty(n.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "full", {
    get: function() {
      return this._q.length >= this._c;
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.add = function(e) {
    if (this.full)
      throw new Error("Buffer full");
    this._q.push(e);
  }, n.prototype.remove = function() {
    if (this.empty)
      throw new Error("Buffer empty");
    return this._q.shift();
  }, n;
})();
(function() {
  function n(e) {
    if (e < 1)
      throw new RangeError("Capacity may not be less than 1");
    this._c = e, this._q = [];
  }
  return Object.defineProperty(n.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "full", {
    get: function() {
      return !1;
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.add = function(e) {
    for (; this._q.length >= this._c; )
      this._q.shift();
    this._q.push(e);
  }, n.prototype.remove = function() {
    if (this.empty)
      throw new Error("Buffer empty");
    return this._q.shift();
  }, n;
})();
(function() {
  function n(e) {
    if (e < 1)
      throw new RangeError("Capacity may not be less than 1");
    this._c = e, this._q = [];
  }
  return Object.defineProperty(n.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "full", {
    get: function() {
      return !1;
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.add = function(e) {
    this._q.length < this._c && this._q.push(e);
  }, n.prototype.remove = function() {
    if (this.empty)
      throw new Error("Buffer empty");
    return this._q.shift();
  }, n;
})();
function Q_(n) {
  n != null && typeof n.then == "function" && n.then(lm, lm);
}
var O0 = 0, h2 = 1, kh = 2, om = 3, ey = 4, am = 1024, lm = function() {
};
function Ld(n) {
  var e = n.err, t = Promise.resolve(n.execution).then(function(i) {
    if (e != null)
      throw e;
    return i;
  });
  return n.err = void 0, n.execution = t.then(function() {
  }, function() {
  }), n.pending === void 0 ? t : n.pending.then(function() {
    return t;
  });
}
function Th(n, e) {
  var t = n.state >= om;
  return Promise.resolve(e).then(function(i) {
    return !t && n.state >= ey ? Ld(n).then(function(r) {
      return {
        value: r,
        done: !0
      };
    }) : {
      value: i,
      done: t
    };
  });
}
function u1(n, e) {
  var t, i;
  if (!(n.state >= kh))
    if (n.state = kh, n.onnext(), n.onstop(), n.err == null && (n.err = e), n.pushes.length === 0 && (typeof n.buffer > "u" || n.buffer.empty))
      ep(n);
    else
      try {
        for (var r = Kd(n.pushes), s = r.next(); !s.done; s = r.next()) {
          var c = s.value;
          c.resolve();
        }
      } catch (l) {
        t = {
          error: l
        };
      } finally {
        try {
          s && !s.done && (i = r.return) && i.call(r);
        } finally {
          if (t)
            throw t.error;
        }
      }
}
function ep(n) {
  var e, t;
  if (!(n.state >= om)) {
    n.state < kh && u1(n), n.state = om, n.buffer = void 0;
    try {
      for (var i = Kd(n.nexts), r = i.next(); !r.done; r = i.next()) {
        var s = r.value, c = n.pending === void 0 ? Ld(n) : n.pending.then(function() {
          return Ld(n);
        });
        s.resolve(Th(n, c));
      }
    } catch (l) {
      e = {
        error: l
      };
    } finally {
      try {
        r && !r.done && (t = i.return) && t.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    n.pushes = [], n.nexts = [];
  }
}
function d2(n) {
  n.state >= ey || (n.state < om && ep(n), n.state = ey);
}
function lI(n, e) {
  if (Q_(e), n.pushes.length >= am)
    throw new p5("No more than " + am + " pending calls to push are allowed on a single repeater.");
  if (n.state >= kh)
    return Promise.resolve(void 0);
  var t = n.pending === void 0 ? Promise.resolve(e) : n.pending.then(function() {
    return e;
  });
  t = t.catch(function(m) {
    n.state < kh && (n.err = m), d2(n);
  });
  var i;
  if (n.nexts.length) {
    var r = n.nexts.shift();
    r.resolve(Th(n, t)), n.nexts.length ? i = Promise.resolve(n.nexts[0].value) : i = new Promise(function(m) {
      return n.onnext = m;
    });
  } else
    typeof n.buffer < "u" && !n.buffer.full ? (n.buffer.add(t), i = Promise.resolve(void 0)) : i = new Promise(function(m) {
      return n.pushes.push({
        resolve: m,
        value: t
      });
    });
  var s = !0, c = {}, l = i.catch(function(m) {
    if (s)
      throw m;
  });
  return c.then = function(m, y) {
    return s = !1, Promise.prototype.then.call(i, m, y);
  }, c.catch = function(m) {
    return s = !1, Promise.prototype.catch.call(i, m);
  }, c.finally = i.finally.bind(i), n.pending = t.then(function() {
    return l;
  }).catch(function(m) {
    n.err = m, d2(n);
  }), c;
}
function cI(n) {
  var e = u1.bind(null, n), t = new Promise(function(i) {
    return n.onstop = i;
  });
  return e.then = t.then.bind(t), e.catch = t.catch.bind(t), e.finally = t.finally.bind(t), e;
}
function uI(n) {
  if (!(n.state >= h2)) {
    n.state = h2;
    var e = lI.bind(null, n), t = cI(n);
    n.execution = new Promise(function(i) {
      return i(n.executor(e, t));
    }), n.execution.catch(function() {
      return u1(n);
    });
  }
}
var ug = /* @__PURE__ */ new WeakMap(), Sp = (
  /** @class */
  function() {
    function n(e, t) {
      ug.set(this, {
        executor: e,
        buffer: t,
        err: void 0,
        state: O0,
        pushes: [],
        nexts: [],
        pending: void 0,
        execution: void 0,
        onnext: lm,
        onstop: lm
      });
    }
    return n.prototype.next = function(e) {
      Q_(e);
      var t = ug.get(this);
      if (t === void 0)
        throw new Error("WeakMap error");
      if (t.nexts.length >= am)
        throw new p5("No more than " + am + " pending calls to next are allowed on a single repeater.");
      if (t.state <= O0 && uI(t), t.onnext(e), typeof t.buffer < "u" && !t.buffer.empty) {
        var i = Th(t, t.buffer.remove());
        if (t.pushes.length) {
          var r = t.pushes.shift();
          t.buffer.add(r.value), t.onnext = r.resolve;
        }
        return i;
      } else if (t.pushes.length) {
        var s = t.pushes.shift();
        return t.onnext = s.resolve, Th(t, s.value);
      } else if (t.state >= kh)
        return ep(t), Th(t, Ld(t));
      return new Promise(function(c) {
        return t.nexts.push({
          resolve: c,
          value: e
        });
      });
    }, n.prototype.return = function(e) {
      Q_(e);
      var t = ug.get(this);
      if (t === void 0)
        throw new Error("WeakMap error");
      return ep(t), t.execution = Promise.resolve(t.execution).then(function() {
        return e;
      }), Th(t, Ld(t));
    }, n.prototype.throw = function(e) {
      var t = ug.get(this);
      if (t === void 0)
        throw new Error("WeakMap error");
      return t.state <= O0 || t.state >= kh || typeof t.buffer < "u" && !t.buffer.empty ? (ep(t), t.err == null && (t.err = e), Th(t, Ld(t))) : this.next(Promise.reject(e));
    }, n.prototype[Symbol.asyncIterator] = function() {
      return this;
    }, n.race = hI, n.merge = dI, n.zip = fI, n.latest = pI, n;
  }()
);
function Pm(n, e) {
  var t, i, r = [], s = function(y) {
    y != null && typeof y[Symbol.asyncIterator] == "function" ? r.push(y[Symbol.asyncIterator]()) : y != null && typeof y[Symbol.iterator] == "function" ? r.push(y[Symbol.iterator]()) : r.push(function() {
      return aI(this, arguments, function() {
        return Xu(this, function(I) {
          switch (I.label) {
            case 0:
              return e.yieldValues ? [4, cp(y)] : [3, 3];
            case 1:
              return [4, I.sent()];
            case 2:
              I.sent(), I.label = 3;
            case 3:
              return e.returnValues ? [4, cp(y)] : [3, 5];
            case 4:
              return [2, I.sent()];
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }());
  };
  try {
    for (var c = Kd(n), l = c.next(); !l.done; l = c.next()) {
      var m = l.value;
      s(m);
    }
  } catch (y) {
    t = {
      error: y
    };
  } finally {
    try {
      l && !l.done && (i = c.return) && i.call(c);
    } finally {
      if (t)
        throw t.error;
    }
  }
  return r;
}
function hI(n) {
  var e = this, t = Pm(n, {
    returnValues: !0
  });
  return new Sp(function(i, r) {
    return Ud(e, void 0, void 0, function() {
      var s, c, l, m, y, A;
      return Xu(this, function(T) {
        switch (T.label) {
          case 0:
            if (!t.length)
              return r(), [
                2
                /*return*/
              ];
            c = !1, r.then(function() {
              s(), c = !0;
            }), T.label = 1;
          case 1:
            T.trys.push([1, , 5, 7]), m = void 0, y = 0, A = function() {
              var I, L, N, z, V, H;
              return Xu(this, function(J) {
                switch (J.label) {
                  case 0:
                    I = y;
                    try {
                      for (L = (V = void 0, Kd(t)), N = L.next(); !N.done; N = L.next())
                        z = N.value, Promise.resolve(z.next()).then(function(ce) {
                          ce.done ? (r(), l === void 0 && (l = ce)) : y === I && (y++, s(ce));
                        }, function(ce) {
                          return r(ce);
                        });
                    } catch (ce) {
                      V = {
                        error: ce
                      };
                    } finally {
                      try {
                        N && !N.done && (H = L.return) && H.call(L);
                      } finally {
                        if (V)
                          throw V.error;
                      }
                    }
                    return [4, new Promise(function(ce) {
                      return s = ce;
                    })];
                  case 1:
                    return m = J.sent(), m === void 0 ? [3, 3] : [4, i(m.value)];
                  case 2:
                    J.sent(), J.label = 3;
                  case 3:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            }, T.label = 2;
          case 2:
            return c ? [3, 4] : [5, A()];
          case 3:
            return T.sent(), [3, 2];
          case 4:
            return [2, l && l.value];
          case 5:
            return r(), [4, Promise.race(t.map(function(I) {
              return I.return && I.return();
            }))];
          case 6:
            return T.sent(), [
              7
              /*endfinally*/
            ];
          case 7:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
function dI(n) {
  var e = this, t = Pm(n, {
    yieldValues: !0
  });
  return new Sp(function(i, r) {
    return Ud(e, void 0, void 0, function() {
      var s, c, l, m = this;
      return Xu(this, function(y) {
        switch (y.label) {
          case 0:
            if (!t.length)
              return r(), [
                2
                /*return*/
              ];
            s = [], c = !1, r.then(function() {
              var A, T;
              c = !0;
              try {
                for (var I = Kd(s), L = I.next(); !L.done; L = I.next()) {
                  var N = L.value;
                  N();
                }
              } catch (z) {
                A = {
                  error: z
                };
              } finally {
                try {
                  L && !L.done && (T = I.return) && T.call(I);
                } finally {
                  if (A)
                    throw A.error;
                }
              }
            }), y.label = 1;
          case 1:
            return y.trys.push([1, , 3, 4]), [4, Promise.all(t.map(function(A, T) {
              return Ud(m, void 0, void 0, function() {
                var I, L;
                return Xu(this, function(N) {
                  switch (N.label) {
                    case 0:
                      N.trys.push([0, , 6, 9]), N.label = 1;
                    case 1:
                      return c ? [3, 5] : (Promise.resolve(A.next()).then(function(z) {
                        return s[T](z);
                      }, function(z) {
                        return r(z);
                      }), [4, new Promise(function(z) {
                        s[T] = z;
                      })]);
                    case 2:
                      return I = N.sent(), I === void 0 ? [3, 4] : I.done ? (l = I, [
                        2
                        /*return*/
                      ]) : [4, i(I.value)];
                    case 3:
                      N.sent(), N.label = 4;
                    case 4:
                      return [3, 1];
                    case 5:
                      return [3, 9];
                    case 6:
                      return L = A.return, L ? [4, A.return()] : [3, 8];
                    case 7:
                      L = N.sent(), N.label = 8;
                    case 8:
                      return [
                        7
                        /*endfinally*/
                      ];
                    case 9:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }))];
          case 2:
            return y.sent(), [2, l && l.value];
          case 3:
            return r(), [
              7
              /*endfinally*/
            ];
          case 4:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
function fI(n) {
  var e = this, t = Pm(n, {
    returnValues: !0
  });
  return new Sp(function(i, r) {
    return Ud(e, void 0, void 0, function() {
      var s, c, l, m;
      return Xu(this, function(y) {
        switch (y.label) {
          case 0:
            if (!t.length)
              return r(), [2, []];
            c = !1, r.then(function() {
              s(), c = !0;
            }), y.label = 1;
          case 1:
            y.trys.push([1, , 6, 8]), y.label = 2;
          case 2:
            return c ? [3, 5] : (Promise.all(t.map(function(A) {
              return A.next();
            })).then(function(A) {
              return s(A);
            }, function(A) {
              return r(A);
            }), [4, new Promise(function(A) {
              return s = A;
            })]);
          case 3:
            return l = y.sent(), l === void 0 ? [
              2
              /*return*/
            ] : (m = l.map(function(A) {
              return A.value;
            }), l.some(function(A) {
              return A.done;
            }) ? [2, m] : [4, i(m)]);
          case 4:
            return y.sent(), [3, 2];
          case 5:
            return [3, 8];
          case 6:
            return r(), [4, Promise.all(t.map(function(A) {
              return A.return && A.return();
            }))];
          case 7:
            return y.sent(), [
              7
              /*endfinally*/
            ];
          case 8:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
function pI(n) {
  var e = this, t = Pm(n, {
    yieldValues: !0,
    returnValues: !0
  });
  return new Sp(function(i, r) {
    return Ud(e, void 0, void 0, function() {
      var s, c, l, m, y, A = this;
      return Xu(this, function(T) {
        switch (T.label) {
          case 0:
            if (!t.length)
              return r(), [2, []];
            c = [], l = !1, r.then(function() {
              var I, L;
              s();
              try {
                for (var N = Kd(c), z = N.next(); !z.done; z = N.next()) {
                  var V = z.value;
                  V();
                }
              } catch (H) {
                I = {
                  error: H
                };
              } finally {
                try {
                  z && !z.done && (L = N.return) && L.call(N);
                } finally {
                  if (I)
                    throw I.error;
                }
              }
              l = !0;
            }), T.label = 1;
          case 1:
            return T.trys.push([1, , 5, 7]), Promise.all(t.map(function(I) {
              return I.next();
            })).then(function(I) {
              return s(I);
            }, function(I) {
              return r(I);
            }), [4, new Promise(function(I) {
              return s = I;
            })];
          case 2:
            return m = T.sent(), m === void 0 ? [
              2
              /*return*/
            ] : (y = m.map(function(I) {
              return I.value;
            }), m.every(function(I) {
              return I.done;
            }) ? [2, y] : [4, i(y.slice())]);
          case 3:
            return T.sent(), [4, Promise.all(t.map(function(I, L) {
              return Ud(A, void 0, void 0, function() {
                var N;
                return Xu(this, function(z) {
                  switch (z.label) {
                    case 0:
                      if (m[L].done)
                        return [2, m[L].value];
                      z.label = 1;
                    case 1:
                      return l ? [3, 4] : (Promise.resolve(I.next()).then(function(V) {
                        return c[L](V);
                      }, function(V) {
                        return r(V);
                      }), [4, new Promise(function(V) {
                        return c[L] = V;
                      })]);
                    case 2:
                      return N = z.sent(), N === void 0 ? [2, m[L].value] : N.done ? [2, N.value] : (y[L] = N.value, [4, i(y.slice())]);
                    case 3:
                      return z.sent(), [3, 1];
                    case 4:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }))];
          case 4:
            return [2, T.sent()];
          case 5:
            return r(), [4, Promise.all(t.map(function(I) {
              return I.return && I.return();
            }))];
          case 6:
            return T.sent(), [
              7
              /*endfinally*/
            ];
          case 7:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
let cm = class {
  constructor() {
    this._extraRequestThreshold = 256 * 1024;
  }
  extraRequestThreshold() {
    return this._extraRequestThreshold;
  }
  setExtraRequestThreshold(e) {
    if (e < 0)
      throw new Error("extraRequestThreshold cannot be negative");
    this._extraRequestThreshold = e;
  }
};
cm.global = new cm();
var xl;
(function(n) {
  n[n.Debug = 0] = "Debug", n[n.Info = 1] = "Info", n[n.Warn = 2] = "Warn", n[n.Error = 3] = "Error";
})(xl || (xl = {}));
class ms {
  static debug() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    this.log(xl.Debug, ...t);
  }
  static info() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    this.log(xl.Info, ...t);
  }
  static warn() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    this.log(xl.Warn, ...t);
  }
  static error() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    this.log(xl.Error, ...t);
  }
  static log(e) {
    if (!(this.logLevel > e)) {
      for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
        i[r - 1] = arguments[r];
      switch (e) {
        case xl.Debug: {
          console.debug(...i);
          break;
        }
        case xl.Info: {
          console.info(...i);
          break;
        }
        case xl.Warn: {
          console.warn(...i);
          break;
        }
        case xl.Error: {
          console.error(...i);
          break;
        }
      }
    }
  }
}
ms.logLevel = xl.Warn;
const Ch = 8 * 4 + 8, gI = 16;
function h1(n, e) {
  e = Math.min(Math.max(+e, 2), 65535);
  let t = n, i = t;
  do
    t = Math.ceil(t / e), i += t;
  while (t !== 1);
  return i * Ch;
}
function mI(n, e) {
  if (e < 2)
    throw new Error("Node size must be at least 2");
  if (n === 0)
    throw new Error("Number of items must be greater than 0");
  let t = n, i = t;
  const r = [t];
  do
    t = Math.ceil(t / e), i += t, r.push(t);
  while (t !== 1);
  const s = [];
  t = i;
  for (const l of r)
    s.push(t - l), t -= l;
  const c = [];
  for (let l = 0; l < r.length; l++)
    c.push([s[l], s[l] + r[l]]);
  return c;
}
async function* _I(n, e, t, i) {
  class r {
    constructor(N, z) {
      this._level = z, this.nodes = N;
    }
    level() {
      return this._level;
    }
    startNodeIdx() {
      return this.nodes[0];
    }
    endNodeIdx() {
      return this.nodes[1];
    }
    extendEndNodeIdx(N) {
      console.assert(N > this.nodes[1]), this.nodes[1] = N;
    }
    toString() {
      return `[NodeRange level: ${this._level}, nodes: ${this.nodes[0]}-${this.nodes[1]}]`;
    }
  }
  const {
    minX: s,
    minY: c,
    maxX: l,
    maxY: m
  } = t;
  ms.info(`tree items: ${n}, nodeSize: ${e}`);
  const y = mI(n, e), A = y[0][0], I = [(() => {
    const L = [0, 1], N = y.length - 1;
    return new r(L, N);
  })()];
  for (ms.debug(`starting stream search with queue: ${I}, numItems: ${n}, nodeSize: ${e}, levelBounds: ${y}`); I.length != 0; ) {
    const L = I.shift();
    ms.debug(`popped node: ${L}, queueLength: ${I.length}`);
    const N = L.startNodeIdx(), z = N >= A, V = (() => {
      const [, me] = y[L.level()], Se = Math.min(L.endNodeIdx() + e, me);
      return z && Se < me ? Se + 1 : Se;
    })(), H = V - N, J = await i(N * Ch, H * Ch), ce = new DataView(J);
    for (let me = N; me < V; me++) {
      const Se = me - N, De = Se * Ch;
      if (l < ce.getFloat64(De + 0, !0) || m < ce.getFloat64(De + 8, !0) || s > ce.getFloat64(De + 16, !0) || c > ce.getFloat64(De + 24, !0))
        continue;
      const Le = ce.getBigUint64(De + 32, !0);
      if (z) {
        const de = Le, Te = (() => {
          if (me < n - 1) {
            const tt = (Se + 1) * Ch;
            return ce.getBigUint64(tt + 32, !0) - de;
          } else
            return null;
        })(), be = me - A;
        yield [Number(de), be, Number(Te)];
        continue;
      }
      const ye = Le, Ve = cm.global.extraRequestThreshold() / Ch, Fe = I[I.length - 1];
      if (Fe !== void 0 && Fe.level() == L.level() - 1 && ye < Fe.endNodeIdx() + Ve) {
        ms.debug(`Merging "nodeRange" request into existing range: ${Fe}, newEndNodeIdx: ${Fe.endNodeIdx()} -> ${ye}`), Fe.extendEndNodeIdx(Number(ye));
        continue;
      }
      const ae = (() => {
        const de = L.level() - 1, Te = [Number(ye), Number(ye) + 1];
        return new r(Te, de);
      })();
      Fe !== void 0 && Fe.level() == ae.level() ? ms.info(`Same level, but too far away. Pushing new request for nodeIdx: ${ye} rather than merging with distant ${Fe}`) : ms.info(`Pushing new level for ${ae} onto queue with nearestNodeRange: ${Fe} since there's not already a range for this level.`), I.push(ae);
    }
  }
}
const Gu = new Uint8Array([102, 103, 98, 3, 102, 103, 98, 0]), Xc = 4;
class d1 {
  constructor(e, t, i, r, s) {
    this.headerClient = e, this.header = t, this.headerLength = i, this.indexLength = r, this.nocache = s;
  }
  static async open(e, t) {
    const r = new f2(e, t), s = (() => {
      const I = gI, L = 3;
      let N = 0, z;
      for (z = 0; z < L; z++) {
        const V = I ** z * Ch;
        N += V;
      }
      return N;
    })(), c = 2024 + s;
    ms.debug(`fetching header. minReqLength: ${c} (assumedHeaderLength: 2024, assumedIndexLength: ${s})`);
    {
      const I = new Uint8Array(await r.getRange(0, 8, c, "header"));
      if (!I.subarray(0, 3).every((L, N) => Gu[N] === L))
        throw ms.error(`bytes: ${I} != ${Gu}`), new Error("Not a FlatGeobuf file");
      ms.debug("magic bytes look good");
    }
    let l;
    {
      const I = await r.getRange(8, 4, c, "header");
      l = new DataView(I).getUint32(0, !0);
      const L = 1048576 * 10;
      if (l > L || l < 8)
        throw new Error("Invalid header size");
      ms.debug(`headerLength: ${l}`);
    }
    const m = await r.getRange(12, l, c, "header"), y = new Qc(new Uint8Array(m)), A = c1(y), T = h1(A.featuresCount, A.indexNodeSize);
    return ms.debug("completed: opening http reader"), new d1(r, A, l, T, t);
  }
  async *selectBbox(e) {
    const t = this.lengthBeforeTree(), i = this.headerClient, r = async function(m, y) {
      return i.getRange(t + m, y, 0, "index");
    }, s = [];
    let c = [];
    for await (const m of _I(this.header.featuresCount, this.header.indexNodeSize, e, r)) {
      const [y, ,] = m;
      let [, , A] = m;
      if (A || (ms.info("final feature"), A = 4), c.length == 0) {
        c.push([y, A]);
        continue;
      }
      const T = c[c.length - 1], I = y - (T[0] + T[1]);
      I > cm.global.extraRequestThreshold() && (ms.info(`Pushing new feature batch, since gap ${I} was too large`), s.push(c), c = []), c.push([y, A]);
    }
    this.headerClient.logUsage("header+index"), c.length > 0 && s.push(c);
    const l = s.flatMap((m) => this.readFeatureBatch(m, this.nocache));
    yield* Sp.merge(l);
  }
  lengthBeforeTree() {
    return Gu.length + Xc + this.headerLength;
  }
  lengthBeforeFeatures() {
    return this.lengthBeforeTree() + this.indexLength;
  }
  buildFeatureClient(e) {
    return new f2(this.headerClient.httpClient, e);
  }
  async *readFeatureBatch(e, t) {
    const [i] = e[0], [r, s] = e[e.length - 1], c = i, m = r + s - c, y = this.buildFeatureClient(t);
    let A = m;
    for (const [T] of e)
      yield await this.readFeature(y, T, A), A = 0;
    y.logUsage("feature");
  }
  async readFeature(e, t, i) {
    const r = t + this.lengthBeforeFeatures();
    let s;
    {
      const A = await e.getRange(r, 4, i, "feature length");
      s = new DataView(A).getUint32(0, !0);
    }
    const c = await e.getRange(r + 4, s, i, "feature data"), l = new Uint8Array(c), m = new Uint8Array(s + Xc);
    m.set(l, Xc);
    const y = new Qc(m);
    return y.setPosition(Xc), wl.getRootAsFeature(y);
  }
}
class f2 {
  constructor(e, t) {
    if (this.bytesEverUsed = 0, this.bytesEverFetched = 0, this.buffer = new ArrayBuffer(0), this.head = 0, typeof e == "string")
      this.httpClient = new p2(e, t);
    else if (e instanceof p2)
      this.httpClient = e;
    else
      throw new Error("Unknown source ");
  }
  async getRange(e, t, i, r) {
    this.bytesEverUsed += t;
    const s = e - this.head, c = s + t;
    if (s >= 0 && c <= this.buffer.byteLength)
      return this.buffer.slice(s, c);
    const l = Math.max(t, i);
    return this.bytesEverFetched += l, ms.debug(`requesting for new Range: ${e}-${e + l - 1}`), this.buffer = await this.httpClient.getRange(e, l, r), this.head = e, this.buffer.slice(0, t);
  }
  logUsage(e) {
    const t = e.split(" ")[0], i = this.bytesEverUsed, r = this.bytesEverFetched, s = (100 * i / r).toFixed(2);
    ms.info(`${t} bytes used/requested: ${i} / ${r} = ${s}%`);
  }
}
class p2 {
  constructor(e, t) {
    this.requestsEverMade = 0, this.bytesEverRequested = 0, this.url = e, this.nocache = t;
  }
  async getRange(e, t, i) {
    this.requestsEverMade += 1, this.bytesEverRequested += t;
    const r = `bytes=${e}-${e + t - 1}`;
    ms.info(`request: #${this.requestsEverMade}, purpose: ${i}), bytes: (this_request: ${t}, ever: ${this.bytesEverRequested}), Range: ${r}`);
    const s = {
      Range: r
    };
    return this.nocache && (s["Cache-Control"] = "no-cache, no-store"), (await fetch(this.url, {
      headers: s
    })).arrayBuffer();
  }
}
function yI(n, e, t) {
  if (!n.subarray(0, 3).every((A, T) => Gu[T] === A))
    throw new Error("Not a FlatGeobuf file");
  const i = new Qc(n), r = i.readUint32(Gu.length);
  i.setPosition(Gu.length + Xc);
  const s = c1(i);
  let c = Gu.length + Xc + r;
  const {
    indexNodeSize: l,
    featuresCount: m
  } = s;
  l > 0 && (c += h1(m, l));
  const y = [];
  for (; c < i.capacity(); ) {
    const A = i.readUint32(c);
    i.setPosition(c + Xc);
    const T = wl.getRootAsFeature(i);
    y.push(e(T, s)), c += Xc + A;
  }
  return y;
}
async function* vI(n, e, t) {
  const i = sI(n), r = async (I) => await i.slice(I);
  let s = new Uint8Array(await r(8));
  if (!s.subarray(0, 3).every((I, L) => Gu[L] === I))
    throw new Error("Not a FlatGeobuf file");
  s = new Uint8Array(await r(4));
  let c = new Qc(s);
  const l = c.readUint32(0);
  s = new Uint8Array(await r(l)), c = new Qc(s);
  const m = c1(c), {
    indexNodeSize: y,
    featuresCount: A
  } = m;
  if (y > 0) {
    const I = h1(A, y);
    await r(I);
  }
  let T;
  for (; T = await xI(r, m, e); )
    yield T;
}
function bI(n, e, t, i) {
  try {
    let r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
    return async function* () {
      const s = await d1.open(n, r);
      ms.debug("opened reader");
      for await (const c of s.selectBbox(e))
        yield t(c, s.header);
    }();
  } catch (r) {
    return Promise.reject(r);
  }
}
async function xI(n, e, t) {
  let i = new Uint8Array(await n(4, "feature length"));
  if (i.byteLength === 0)
    return;
  let r = new Qc(i);
  const s = r.readUint32(0);
  i = new Uint8Array(await n(s, "feature data"));
  const c = new Uint8Array(s + 4);
  c.set(i, 4), r = new Qc(c), r.setPosition(Xc);
  const l = wl.getRootAsFeature(r);
  return t(l, e);
}
function wI(n, e) {
  return {
    type: "FeatureCollection",
    features: yI(n, a1)
  };
}
function AI(n, e) {
  return vI(n, a1);
}
function EI(n, e, t) {
  let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  return bI(n, e, a1, t, i);
}
function g2(n, e, t) {
  let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  return n instanceof Uint8Array ? wI(n) : n instanceof ReadableStream ? AI(n) : EI(n, e, t, i);
}
class SI {
  constructor() {
    this._bearing = 0, this._pitch = 60, this._minpitchzoom = null;
  }
  onAdd(e) {
    this._map = e;
    let t = this;
    return this._btn = document.createElement("button"), this._btn.className = "maplibregl-ctrl-icon maplibregl-ctrl-pitchtoggle-3d", this._btn.id = "bt3D", this._btn.type = "button", this._btn["aria-label"] = "Vista 3D", this._btn.onclick = function() {
      if (t._btn.className.indexOf("3d") != -1) {
        let y = {
          pitch: t._pitch,
          bearing: t._bearing
        };
        t._minpitchzoom && e.getZoom() > t._minpitchzoom && (y.zoom = t._minpitchzoom);
        var i = 0, r = 38.5, s = 6, c = 62.33, {
          longitude: l,
          latitude: m
        } = e.getCenter();
        e.getZoom() < 10 ? e.setTerrain({
          source: "terrainMapZen",
          exaggeration: 1.5
        }) : l >= i && l <= s && m >= r && m <= c ? e.setTerrain({
          source: "terrainICGC",
          exaggeration: 1.2
        }) : e.setTerrain({
          source: "terrainMapZen",
          exaggeration: 1.5
        }), e.easeTo(y), t._btn.className = "maplibregl-ctrl-icon maplibregl-ctrl-pitchtoggle-2d";
      } else
        e.setTerrain(null), e.easeTo({
          pitch: 0,
          bearing: 0
        }), t._btn.className = "maplibregl-ctrl-icon maplibregl-ctrl-pitchtoggle-3d";
    }, this._container = document.createElement("div"), this._container.className = "maplibregl-ctrl maplibregl-ctrl-group", this._container.title = "Vista 3D", this._container.appendChild(this._btn), this._container;
  }
  onRemove() {
    this._container.parentNode.removeChild(this._container), this._map = void 0;
  }
}
function up(n) {
  "@babel/helpers - typeof";
  return up = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, up(n);
}
function TI(n, e) {
  if (up(n) != "object" || !n)
    return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var i = t.call(n, e || "default");
    if (up(i) != "object")
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
function CI(n) {
  var e = TI(n, "string");
  return up(e) == "symbol" ? e : e + "";
}
function G(n, e, t) {
  return e = CI(e), e in n ? Object.defineProperty(n, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : n[e] = t, n;
}
function Qi(n, e) {
  if (!n)
    throw new Error(e || "loader assertion failed.");
}
const Lm = !!(typeof process != "object" || String(process) !== "[object process]" || process.browser), m2 = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version);
m2 && parseFloat(m2[1]);
const II = "3.4.15";
function mc(n, e) {
  if (!n)
    throw new Error(e || "loaders.gl assertion failed.");
}
const F0 = {
  self: typeof self < "u" && self,
  window: typeof window < "u" && window,
  global: typeof global < "u" && global,
  document: typeof document < "u" && document
}, PI = F0.global || F0.self || F0.window || {}, Yc = typeof process != "object" || String(process) !== "[object process]" || process.browser, f1 = typeof importScripts == "function", LI = typeof window < "u" && typeof window.orientation < "u", _2 = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version);
_2 && parseFloat(_2[1]);
class MI {
  constructor(e, t) {
    G(this, "name", void 0), G(this, "workerThread", void 0), G(this, "isRunning", !0), G(this, "result", void 0), G(this, "_resolve", () => {
    }), G(this, "_reject", () => {
    }), this.name = e, this.workerThread = t, this.result = new Promise((i, r) => {
      this._resolve = i, this._reject = r;
    });
  }
  postMessage(e, t) {
    this.workerThread.postMessage({
      source: "loaders.gl",
      type: e,
      payload: t
    });
  }
  done(e) {
    mc(this.isRunning), this.isRunning = !1, this._resolve(e);
  }
  error(e) {
    mc(this.isRunning), this.isRunning = !1, this._reject(e);
  }
}
let D0 = class {
  terminate() {
  }
};
const k0 = /* @__PURE__ */ new Map();
function BI(n) {
  mc(n.source && !n.url || !n.source && n.url);
  let e = k0.get(n.source || n.url);
  return e || (n.url && (e = RI(n.url), k0.set(n.url, e)), n.source && (e = g5(n.source), k0.set(n.source, e))), mc(e), e;
}
function RI(n) {
  if (!n.startsWith("http"))
    return n;
  const e = OI(n);
  return g5(e);
}
function g5(n) {
  const e = new Blob([n], {
    type: "application/javascript"
  });
  return URL.createObjectURL(e);
}
function OI(n) {
  return `try {
  importScripts('`.concat(n, `');
} catch (error) {
  console.error(error);
  throw error;
}`);
}
function m5(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, t = arguments.length > 2 ? arguments[2] : void 0;
  const i = t || /* @__PURE__ */ new Set();
  if (n) {
    if (y2(n))
      i.add(n);
    else if (y2(n.buffer))
      i.add(n.buffer);
    else if (!ArrayBuffer.isView(n)) {
      if (e && typeof n == "object")
        for (const r in n)
          m5(n[r], e, i);
    }
  }
  return t === void 0 ? Array.from(i) : [];
}
function y2(n) {
  return n ? n instanceof ArrayBuffer || typeof MessagePort < "u" && n instanceof MessagePort || typeof ImageBitmap < "u" && n instanceof ImageBitmap || typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas : !1;
}
const N0 = () => {
};
class ty {
  static isSupported() {
    return typeof Worker < "u" && Yc || typeof D0 < "u" && !Yc;
  }
  constructor(e) {
    G(this, "name", void 0), G(this, "source", void 0), G(this, "url", void 0), G(this, "terminated", !1), G(this, "worker", void 0), G(this, "onMessage", void 0), G(this, "onError", void 0), G(this, "_loadableURL", "");
    const {
      name: t,
      source: i,
      url: r
    } = e;
    mc(i || r), this.name = t, this.source = i, this.url = r, this.onMessage = N0, this.onError = (s) => console.log(s), this.worker = Yc ? this._createBrowserWorker() : this._createNodeWorker();
  }
  destroy() {
    this.onMessage = N0, this.onError = N0, this.worker.terminate(), this.terminated = !0;
  }
  get isRunning() {
    return !!this.onMessage;
  }
  postMessage(e, t) {
    t = t || m5(e), this.worker.postMessage(e, t);
  }
  _getErrorFromErrorEvent(e) {
    let t = "Failed to load ";
    return t += "worker ".concat(this.name, " from ").concat(this.url, ". "), e.message && (t += "".concat(e.message, " in ")), e.lineno && (t += ":".concat(e.lineno, ":").concat(e.colno)), new Error(t);
  }
  _createBrowserWorker() {
    this._loadableURL = BI({
      source: this.source,
      url: this.url
    });
    const e = new Worker(this._loadableURL, {
      name: this.name
    });
    return e.onmessage = (t) => {
      t.data ? this.onMessage(t.data) : this.onError(new Error("No data received"));
    }, e.onerror = (t) => {
      this.onError(this._getErrorFromErrorEvent(t)), this.terminated = !0;
    }, e.onmessageerror = (t) => console.error(t), e;
  }
  _createNodeWorker() {
    let e;
    if (this.url) {
      const i = this.url.includes(":/") || this.url.startsWith("/") ? this.url : "./".concat(this.url);
      e = new D0(i, {
        eval: !1
      });
    } else if (this.source)
      e = new D0(this.source, {
        eval: !0
      });
    else
      throw new Error("no worker");
    return e.on("message", (t) => {
      this.onMessage(t);
    }), e.on("error", (t) => {
      this.onError(t);
    }), e.on("exit", (t) => {
    }), e;
  }
}
class FI {
  static isSupported() {
    return ty.isSupported();
  }
  constructor(e) {
    G(this, "name", "unnamed"), G(this, "source", void 0), G(this, "url", void 0), G(this, "maxConcurrency", 1), G(this, "maxMobileConcurrency", 1), G(this, "onDebug", () => {
    }), G(this, "reuseWorkers", !0), G(this, "props", {}), G(this, "jobQueue", []), G(this, "idleQueue", []), G(this, "count", 0), G(this, "isDestroyed", !1), this.source = e.source, this.url = e.url, this.setProps(e);
  }
  destroy() {
    this.idleQueue.forEach((e) => e.destroy()), this.isDestroyed = !0;
  }
  setProps(e) {
    this.props = {
      ...this.props,
      ...e
    }, e.name !== void 0 && (this.name = e.name), e.maxConcurrency !== void 0 && (this.maxConcurrency = e.maxConcurrency), e.maxMobileConcurrency !== void 0 && (this.maxMobileConcurrency = e.maxMobileConcurrency), e.reuseWorkers !== void 0 && (this.reuseWorkers = e.reuseWorkers), e.onDebug !== void 0 && (this.onDebug = e.onDebug);
  }
  async startJob(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (s, c, l) => s.done(l), i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (s, c) => s.error(c);
    const r = new Promise((s) => (this.jobQueue.push({
      name: e,
      onMessage: t,
      onError: i,
      onStart: s
    }), this));
    return this._startQueuedJob(), await r;
  }
  async _startQueuedJob() {
    if (!this.jobQueue.length)
      return;
    const e = this._getAvailableWorker();
    if (!e)
      return;
    const t = this.jobQueue.shift();
    if (t) {
      this.onDebug({
        message: "Starting job",
        name: t.name,
        workerThread: e,
        backlog: this.jobQueue.length
      });
      const i = new MI(t.name, e);
      e.onMessage = (r) => t.onMessage(i, r.type, r.payload), e.onError = (r) => t.onError(i, r), t.onStart(i);
      try {
        await i.result;
      } finally {
        this.returnWorkerToQueue(e);
      }
    }
  }
  returnWorkerToQueue(e) {
    this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency() ? (e.destroy(), this.count--) : this.idleQueue.push(e), this.isDestroyed || this._startQueuedJob();
  }
  _getAvailableWorker() {
    if (this.idleQueue.length > 0)
      return this.idleQueue.shift() || null;
    if (this.count < this._getMaxConcurrency()) {
      this.count++;
      const e = "".concat(this.name.toLowerCase(), " (#").concat(this.count, " of ").concat(this.maxConcurrency, ")");
      return new ty({
        name: e,
        source: this.source,
        url: this.url
      });
    }
    return null;
  }
  _getMaxConcurrency() {
    return LI ? this.maxMobileConcurrency : this.maxConcurrency;
  }
}
const DI = {
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: !0,
  onDebug: () => {
  }
};
class Hc {
  static isSupported() {
    return ty.isSupported();
  }
  static getWorkerFarm() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Hc._workerFarm = Hc._workerFarm || new Hc({}), Hc._workerFarm.setProps(e), Hc._workerFarm;
  }
  constructor(e) {
    G(this, "props", void 0), G(this, "workerPools", /* @__PURE__ */ new Map()), this.props = {
      ...DI
    }, this.setProps(e), this.workerPools = /* @__PURE__ */ new Map();
  }
  destroy() {
    for (const e of this.workerPools.values())
      e.destroy();
    this.workerPools = /* @__PURE__ */ new Map();
  }
  setProps(e) {
    this.props = {
      ...this.props,
      ...e
    };
    for (const t of this.workerPools.values())
      t.setProps(this._getWorkerPoolProps());
  }
  getWorkerPool(e) {
    const {
      name: t,
      source: i,
      url: r
    } = e;
    let s = this.workerPools.get(t);
    return s || (s = new FI({
      name: t,
      source: i,
      url: r
    }), s.setProps(this._getWorkerPoolProps()), this.workerPools.set(t, s)), s;
  }
  _getWorkerPoolProps() {
    return {
      maxConcurrency: this.props.maxConcurrency,
      maxMobileConcurrency: this.props.maxMobileConcurrency,
      reuseWorkers: this.props.reuseWorkers,
      onDebug: this.props.onDebug
    };
  }
}
G(Hc, "_workerFarm", void 0);
const kI = "latest";
function NI(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = e[n.id] || {}, i = "".concat(n.id, "-worker.js");
  let r = t.workerUrl;
  if (!r && n.id === "compression" && (r = e.workerUrl), e._workerType === "test" && (r = "modules/".concat(n.module, "/dist/").concat(i)), !r) {
    let s = n.version;
    s === "latest" && (s = kI);
    const c = s ? "@".concat(s) : "";
    r = "https://unpkg.com/@loaders.gl/".concat(n.module).concat(c, "/dist/").concat(i);
  }
  return mc(r), r;
}
function zI(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : II;
  mc(n, "no worker provided");
  const t = n.version;
  return !(!e || !t);
}
const UI = null, jI = null, ny = null, _5 = null, GI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  readFileAsArrayBuffer: UI,
  readFileAsText: jI,
  requireFromFile: ny,
  requireFromString: _5
}, Symbol.toStringTag, { value: "Module" })), VI = "3.4.15", z0 = {};
async function Rh(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  return e && (n = qI(n, e, t)), z0[n] = z0[n] || HI(n), await z0[n];
}
function qI(n, e, t) {
  if (n.startsWith("http"))
    return n;
  const i = t.modules || {};
  return i[n] ? i[n] : Yc ? t.CDN ? (mc(t.CDN.startsWith("http")), "".concat(t.CDN, "/").concat(e, "@").concat(VI, "/dist/libs/").concat(n)) : f1 ? "../src/libs/".concat(n) : "modules/".concat(e, "/src/libs/").concat(n) : "modules/".concat(e, "/dist/libs/").concat(n);
}
async function HI(n) {
  if (n.endsWith("wasm"))
    return await (await fetch(n)).arrayBuffer();
  if (!Yc)
    try {
      return GI && ny && await ny(n);
    } catch {
      return null;
    }
  if (f1)
    return importScripts(n);
  const t = await (await fetch(n)).text();
  return WI(t, n);
}
function WI(n, e) {
  if (!Yc)
    return _5;
  if (f1)
    return eval.call(PI, n), null;
  const t = document.createElement("script");
  t.id = e;
  try {
    t.appendChild(document.createTextNode(n));
  } catch {
    t.text = n;
  }
  return document.body.appendChild(t), null;
}
function XI(n, e) {
  return !Hc.isSupported() || !Yc && !(e != null && e._nodeWorkers) ? !1 : n.worker && (e == null ? void 0 : e.worker);
}
async function JI(n, e, t, i, r) {
  const s = n.id, c = NI(n, t), m = Hc.getWorkerFarm(t).getWorkerPool({
    name: s,
    url: c
  });
  t = JSON.parse(JSON.stringify(t)), i = JSON.parse(JSON.stringify(i || {}));
  const y = await m.startJob("process-on-worker", $I.bind(null, r));
  return y.postMessage("process", {
    input: e,
    options: t,
    context: i
  }), await (await y.result).result;
}
async function $I(n, e, t, i) {
  switch (t) {
    case "done":
      e.done(i);
      break;
    case "error":
      e.error(new Error(i.error));
      break;
    case "process":
      const {
        id: r,
        input: s,
        options: c
      } = i;
      try {
        const l = await n(s, c);
        e.postMessage("done", {
          id: r,
          result: l
        });
      } catch (l) {
        const m = l instanceof Error ? l.message : "unknown error";
        e.postMessage("error", {
          id: r,
          error: m
        });
      }
      break;
    default:
      console.warn("parse-with-worker unknown message ".concat(t));
  }
}
function ZI(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
  return typeof n == "string" ? n.slice(0, e) : ArrayBuffer.isView(n) ? v2(n.buffer, n.byteOffset, e) : n instanceof ArrayBuffer ? v2(n, 0, e) : "";
}
function v2(n, e, t) {
  if (n.byteLength <= e + t)
    return "";
  const i = new DataView(n);
  let r = "";
  for (let s = 0; s < t; s++)
    r += String.fromCharCode(i.getUint8(e + s));
  return r;
}
function YI(n) {
  try {
    return JSON.parse(n);
  } catch {
    throw new Error('Failed to parse JSON from data starting with "'.concat(ZI(n), '"'));
  }
}
function KI(n, e, t) {
  if (t = t || n.byteLength, n.byteLength < t || e.byteLength < t)
    return !1;
  const i = new Uint8Array(n), r = new Uint8Array(e);
  for (let s = 0; s < i.length; ++s)
    if (i[s] !== r[s])
      return !1;
  return !0;
}
function QI() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  const i = e.map((l) => l instanceof ArrayBuffer ? new Uint8Array(l) : l), r = i.reduce((l, m) => l + m.byteLength, 0), s = new Uint8Array(r);
  let c = 0;
  for (const l of i)
    s.set(l, c), c += l.byteLength;
  return s.buffer;
}
function p1(n, e, t) {
  const i = t !== void 0 ? new Uint8Array(n).subarray(e, e + t) : new Uint8Array(n).subarray(e);
  return new Uint8Array(i).buffer;
}
function Tp(n, e) {
  return Qi(n >= 0), Qi(e > 0), n + (e - 1) & ~(e - 1);
}
function eP(n, e, t) {
  let i;
  if (n instanceof ArrayBuffer)
    i = new Uint8Array(n);
  else {
    const r = n.byteOffset, s = n.byteLength;
    i = new Uint8Array(n.buffer || n.arrayBuffer, r, s);
  }
  return e.set(i, t), t + Tp(i.byteLength, 4);
}
async function tP(n) {
  const e = [];
  for await (const t of n)
    e.push(t);
  return QI(...e);
}
function b2() {
  let n;
  if (typeof window < "u" && window.performance)
    n = window.performance.now();
  else if (typeof process < "u" && process.hrtime) {
    const e = process.hrtime();
    n = e[0] * 1e3 + e[1] / 1e6;
  } else
    n = Date.now();
  return n;
}
class x2 {
  constructor(e, t) {
    G(this, "name", void 0), G(this, "type", void 0), G(this, "sampleSize", 1), G(this, "time", void 0), G(this, "count", void 0), G(this, "samples", void 0), G(this, "lastTiming", void 0), G(this, "lastSampleTime", void 0), G(this, "lastSampleCount", void 0), G(this, "_count", 0), G(this, "_time", 0), G(this, "_samples", 0), G(this, "_startTime", 0), G(this, "_timerPending", !1), this.name = e, this.type = t, this.reset();
  }
  setSampleSize(e) {
    return this.sampleSize = e, this;
  }
  incrementCount() {
    return this.addCount(1), this;
  }
  decrementCount() {
    return this.subtractCount(1), this;
  }
  addCount(e) {
    return this._count += e, this._samples++, this._checkSampling(), this;
  }
  subtractCount(e) {
    return this._count -= e, this._samples++, this._checkSampling(), this;
  }
  addTime(e) {
    return this._time += e, this.lastTiming = e, this._samples++, this._checkSampling(), this;
  }
  timeStart() {
    return this._startTime = b2(), this._timerPending = !0, this;
  }
  timeEnd() {
    return this._timerPending ? (this.addTime(b2() - this._startTime), this._timerPending = !1, this._checkSampling(), this) : this;
  }
  getSampleAverageCount() {
    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
  }
  getSampleAverageTime() {
    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
  }
  getSampleHz() {
    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
  }
  getAverageCount() {
    return this.samples > 0 ? this.count / this.samples : 0;
  }
  getAverageTime() {
    return this.samples > 0 ? this.time / this.samples : 0;
  }
  getHz() {
    return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
  }
  reset() {
    return this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this;
  }
  _checkSampling() {
    this._samples === this.sampleSize && (this.lastSampleTime = this._time, this.lastSampleCount = this._count, this.count += this._count, this.time += this._time, this.samples += this._samples, this._time = 0, this._count = 0, this._samples = 0);
  }
}
class Cp {
  constructor(e) {
    G(this, "id", void 0), G(this, "stats", {}), this.id = e.id, this.stats = {}, this._initializeStats(e.stats), Object.seal(this);
  }
  get(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "count";
    return this._getOrCreate({
      name: e,
      type: t
    });
  }
  get size() {
    return Object.keys(this.stats).length;
  }
  reset() {
    for (const e in this.stats)
      this.stats[e].reset();
    return this;
  }
  forEach(e) {
    for (const t in this.stats)
      e(this.stats[t]);
  }
  getTable() {
    const e = {};
    return this.forEach((t) => {
      e[t.name] = {
        time: t.time || 0,
        count: t.count || 0,
        average: t.getAverageTime() || 0,
        hz: t.getHz() || 0
      };
    }), e;
  }
  _initializeStats() {
    (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).forEach((t) => this._getOrCreate(t));
  }
  _getOrCreate(e) {
    if (!e || !e.name)
      return null;
    const {
      name: t,
      type: i
    } = e;
    return this.stats[t] || (e instanceof x2 ? this.stats[t] = e : this.stats[t] = new x2(t, i)), this.stats[t];
  }
}
const nP = "Queued Requests", iP = "Active Requests", rP = "Cancelled Requests", sP = "Queued Requests Ever", oP = "Active Requests Ever", aP = {
  id: "request-scheduler",
  throttleRequests: !0,
  maxRequests: 6
};
class lP {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    G(this, "props", void 0), G(this, "stats", void 0), G(this, "activeRequestCount", 0), G(this, "requestQueue", []), G(this, "requestMap", /* @__PURE__ */ new Map()), G(this, "deferredUpdate", null), this.props = {
      ...aP,
      ...e
    }, this.stats = new Cp({
      id: this.props.id
    }), this.stats.get(nP), this.stats.get(iP), this.stats.get(rP), this.stats.get(sP), this.stats.get(oP);
  }
  scheduleRequest(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : () => 0;
    if (!this.props.throttleRequests)
      return Promise.resolve({
        done: () => {
        }
      });
    if (this.requestMap.has(e))
      return this.requestMap.get(e);
    const i = {
      handle: e,
      priority: 0,
      getPriority: t
    }, r = new Promise((s) => (i.resolve = s, i));
    return this.requestQueue.push(i), this.requestMap.set(e, r), this._issueNewRequests(), r;
  }
  _issueRequest(e) {
    const {
      handle: t,
      resolve: i
    } = e;
    let r = !1;
    const s = () => {
      r || (r = !0, this.requestMap.delete(t), this.activeRequestCount--, this._issueNewRequests());
    };
    return this.activeRequestCount++, i ? i({
      done: s
    }) : Promise.resolve({
      done: s
    });
  }
  _issueNewRequests() {
    this.deferredUpdate || (this.deferredUpdate = setTimeout(() => this._issueNewRequestsAsync(), 0));
  }
  _issueNewRequestsAsync() {
    this.deferredUpdate = null;
    const e = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
    if (e !== 0) {
      this._updateAllRequests();
      for (let t = 0; t < e; ++t) {
        const i = this.requestQueue.shift();
        i && this._issueRequest(i);
      }
    }
  }
  _updateAllRequests() {
    const e = this.requestQueue;
    for (let t = 0; t < e.length; ++t) {
      const i = e[t];
      this._updateRequest(i) || (e.splice(t, 1), this.requestMap.delete(i.handle), t--);
    }
    e.sort((t, i) => t.priority - i.priority);
  }
  _updateRequest(e) {
    return e.priority = e.getPriority(e.handle), e.priority < 0 ? (e.resolve(null), !1) : !0;
  }
}
let cP = "";
const w2 = {};
function uP(n) {
  for (const e in w2)
    if (n.startsWith(e)) {
      const t = w2[e];
      n = n.replace(e, t);
    }
  return !n.startsWith("http://") && !n.startsWith("https://") && (n = "".concat(cP).concat(n)), n;
}
function hP(n) {
  return n && typeof n == "object" && n.isBuffer;
}
function y5(n) {
  if (hP(n))
    return n;
  if (n instanceof ArrayBuffer)
    return n;
  if (ArrayBuffer.isView(n))
    return n.byteOffset === 0 && n.byteLength === n.buffer.byteLength ? n.buffer : n.buffer.slice(n.byteOffset, n.byteOffset + n.byteLength);
  if (typeof n == "string") {
    const e = n;
    return new TextEncoder().encode(e).buffer;
  }
  if (n && typeof n == "object" && n._toArrayBuffer)
    return n._toArrayBuffer();
  throw new Error("toArrayBuffer");
}
function v5(n) {
  const e = n ? n.lastIndexOf("/") : -1;
  return e >= 0 ? n.substr(e + 1) : "";
}
function g1(n) {
  const e = n ? n.lastIndexOf("/") : -1;
  return e >= 0 ? n.substr(0, e) : "";
}
const dP = (n) => typeof n == "boolean", tp = (n) => typeof n == "function", Ip = (n) => n !== null && typeof n == "object", A2 = (n) => Ip(n) && n.constructor === {}.constructor, fP = (n) => n && typeof n[Symbol.iterator] == "function", pP = (n) => n && typeof n[Symbol.asyncIterator] == "function", jh = (n) => typeof Response < "u" && n instanceof Response || n && n.arrayBuffer && n.text && n.json, Gh = (n) => typeof Blob < "u" && n instanceof Blob, gP = (n) => n && typeof n == "object" && n.isBuffer, mP = (n) => typeof ReadableStream < "u" && n instanceof ReadableStream || Ip(n) && tp(n.tee) && tp(n.cancel) && tp(n.getReader), _P = (n) => Ip(n) && tp(n.read) && tp(n.pipe) && dP(n.readable), b5 = (n) => mP(n) || _P(n), yP = /^data:([-\w.]+\/[-\w.+]+)(;|,)/, vP = /^([-\w.]+\/[-\w.+]+)/;
function bP(n) {
  const e = vP.exec(n);
  return e ? e[1] : n;
}
function E2(n) {
  const e = yP.exec(n);
  return e ? e[1] : "";
}
const x5 = /\?.*/;
function xP(n) {
  const e = n.match(x5);
  return e && e[0];
}
function m1(n) {
  return n.replace(x5, "");
}
function Mm(n) {
  return jh(n) ? n.url : Gh(n) ? n.name || "" : typeof n == "string" ? n : "";
}
function _1(n) {
  if (jh(n)) {
    const e = n, t = e.headers.get("content-type") || "", i = m1(e.url);
    return bP(t) || E2(i);
  }
  return Gh(n) ? n.type || "" : typeof n == "string" ? E2(n) : "";
}
function wP(n) {
  return jh(n) ? n.headers["content-length"] || -1 : Gh(n) ? n.size : typeof n == "string" ? n.length : n instanceof ArrayBuffer || ArrayBuffer.isView(n) ? n.byteLength : -1;
}
async function w5(n) {
  if (jh(n))
    return n;
  const e = {}, t = wP(n);
  t >= 0 && (e["content-length"] = String(t));
  const i = Mm(n), r = _1(n);
  r && (e["content-type"] = r);
  const s = await SP(n);
  s && (e["x-first-bytes"] = s), typeof n == "string" && (n = new TextEncoder().encode(n));
  const c = new Response(n, {
    headers: e
  });
  return Object.defineProperty(c, "url", {
    value: i
  }), c;
}
async function AP(n) {
  if (!n.ok) {
    const e = await EP(n);
    throw new Error(e);
  }
}
async function EP(n) {
  let e = "Failed to fetch resource ".concat(n.url, " (").concat(n.status, "): ");
  try {
    const t = n.headers.get("Content-Type");
    let i = n.statusText;
    t.includes("application/json") && (i += " ".concat(await n.text())), e += i, e = e.length > 60 ? "".concat(e.slice(0, 60), "...") : e;
  } catch {
  }
  return e;
}
async function SP(n) {
  if (typeof n == "string")
    return "data:,".concat(n.slice(0, 5));
  if (n instanceof Blob) {
    const t = n.slice(0, 5);
    return await new Promise((i) => {
      const r = new FileReader();
      r.onload = (s) => {
        var c;
        return i(s == null || (c = s.target) === null || c === void 0 ? void 0 : c.result);
      }, r.readAsDataURL(t);
    });
  }
  if (n instanceof ArrayBuffer) {
    const t = n.slice(0, 5), i = TP(t);
    return "data:base64,".concat(i);
  }
  return null;
}
function TP(n) {
  let e = "";
  const t = new Uint8Array(n);
  for (let i = 0; i < t.byteLength; i++)
    e += String.fromCharCode(t[i]);
  return btoa(e);
}
async function S2(n, e) {
  if (typeof n == "string") {
    n = uP(n);
    let t = e;
    return e != null && e.fetch && typeof (e == null ? void 0 : e.fetch) != "function" && (t = e.fetch), await fetch(n, t);
  }
  return await w5(n);
}
function A5(n) {
  if (typeof window < "u" && typeof window.process == "object" && window.process.type === "renderer" || typeof process < "u" && typeof process.versions == "object" && process.versions.electron)
    return !0;
  const t = typeof navigator == "object" && typeof navigator.userAgent == "string" && navigator.userAgent;
  return !!(t && t.indexOf("Electron") >= 0);
}
function iu() {
  return !(typeof process == "object" && String(process) === "[object process]" && !process.browser) || A5();
}
const jg = {
  self: typeof self < "u" && self,
  window: typeof window < "u" && window,
  global: typeof global < "u" && global,
  document: typeof document < "u" && document,
  process: typeof process == "object" && process
}, hg = jg.window || jg.self || jg.global, Rf = jg.process || {}, E5 = typeof __VERSION__ < "u" ? __VERSION__ : "untranspiled source";
iu();
const U0 = globalThis;
function S5(n) {
  if (!iu())
    return "Node";
  if (A5())
    return "Electron";
  const t = (typeof navigator < "u" ? navigator : {}).userAgent || "";
  if (t.indexOf("Edge") > -1)
    return "Edge";
  const i = t.indexOf("MSIE ") !== -1, r = t.indexOf("Trident/") !== -1;
  return i || r ? "IE" : U0.chrome ? "Chrome" : U0.safari ? "Safari" : U0.mozInnerScreenX ? "Firefox" : "Unknown";
}
function CP(n) {
  try {
    const e = window[n], t = "__storage_test__";
    return e.setItem(t, t), e.removeItem(t), e;
  } catch {
    return null;
  }
}
class IP {
  constructor(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "sessionStorage";
    G(this, "storage", void 0), G(this, "id", void 0), G(this, "config", void 0), this.storage = CP(i), this.id = e, this.config = t, this._loadConfiguration();
  }
  getConfiguration() {
    return this.config;
  }
  setConfiguration(e) {
    if (Object.assign(this.config, e), this.storage) {
      const t = JSON.stringify(this.config);
      this.storage.setItem(this.id, t);
    }
  }
  _loadConfiguration() {
    let e = {};
    if (this.storage) {
      const t = this.storage.getItem(this.id);
      e = t ? JSON.parse(t) : {};
    }
    return Object.assign(this.config, e), this;
  }
}
function PP(n) {
  let e;
  return n < 10 ? e = "".concat(n.toFixed(2), "ms") : n < 100 ? e = "".concat(n.toFixed(1), "ms") : n < 1e3 ? e = "".concat(n.toFixed(0), "ms") : e = "".concat((n / 1e3).toFixed(2), "s"), e;
}
function LP(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;
  const t = Math.max(e - n.length, 0);
  return "".concat(" ".repeat(t)).concat(n);
}
function j0(n, e, t) {
  let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 600;
  const r = n.src.replace(/\(/g, "%28").replace(/\)/g, "%29");
  n.width > i && (t = Math.min(t, i / n.width));
  const s = n.width * t, c = n.height * t, l = ["font-size:1px;", "padding:".concat(Math.floor(c / 2), "px ").concat(Math.floor(s / 2), "px;"), "line-height:".concat(c, "px;"), "background:url(".concat(r, ");"), "background-size:".concat(s, "px ").concat(c, "px;"), "color:transparent;"].join("");
  return ["".concat(e, " %c+"), l];
}
let um;
(function(n) {
  n[n.BLACK = 30] = "BLACK", n[n.RED = 31] = "RED", n[n.GREEN = 32] = "GREEN", n[n.YELLOW = 33] = "YELLOW", n[n.BLUE = 34] = "BLUE", n[n.MAGENTA = 35] = "MAGENTA", n[n.CYAN = 36] = "CYAN", n[n.WHITE = 37] = "WHITE", n[n.BRIGHT_BLACK = 90] = "BRIGHT_BLACK", n[n.BRIGHT_RED = 91] = "BRIGHT_RED", n[n.BRIGHT_GREEN = 92] = "BRIGHT_GREEN", n[n.BRIGHT_YELLOW = 93] = "BRIGHT_YELLOW", n[n.BRIGHT_BLUE = 94] = "BRIGHT_BLUE", n[n.BRIGHT_MAGENTA = 95] = "BRIGHT_MAGENTA", n[n.BRIGHT_CYAN = 96] = "BRIGHT_CYAN", n[n.BRIGHT_WHITE = 97] = "BRIGHT_WHITE";
})(um || (um = {}));
function T2(n) {
  return typeof n == "string" ? um[n.toUpperCase()] || um.WHITE : n;
}
function MP(n, e, t) {
  return !iu && typeof n == "string" && (e && (e = T2(e), n = "\x1B[".concat(e, "m").concat(n, "\x1B[39m")), t && (e = T2(t), n = "\x1B[".concat(t + 10, "m").concat(n, "\x1B[49m"))), n;
}
function BP(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ["constructor"];
  const t = Object.getPrototypeOf(n), i = Object.getOwnPropertyNames(t);
  for (const r of i)
    typeof n[r] == "function" && (e.find((s) => r === s) || (n[r] = n[r].bind(n)));
}
function hm(n, e) {
  if (!n)
    throw new Error(e || "Assertion failed");
}
function cd() {
  let n;
  if (iu && "performance" in hg) {
    var e, t;
    n = hg == null || (e = hg.performance) === null || e === void 0 || (t = e.now) === null || t === void 0 ? void 0 : t.call(e);
  } else if ("hrtime" in Rf) {
    var i;
    const r = Rf == null || (i = Rf.hrtime) === null || i === void 0 ? void 0 : i.call(Rf);
    n = r[0] * 1e3 + r[1] / 1e6;
  } else
    n = Date.now();
  return n;
}
const ud = {
  debug: iu && console.debug || console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
}, RP = {
  enabled: !0,
  level: 0
};
function Wa() {
}
const C2 = {}, I2 = {
  once: !0
};
class Pp {
  constructor() {
    let {
      id: e
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      id: ""
    };
    G(this, "id", void 0), G(this, "VERSION", E5), G(this, "_startTs", cd()), G(this, "_deltaTs", cd()), G(this, "_storage", void 0), G(this, "userData", {}), G(this, "LOG_THROTTLE_TIMEOUT", 0), this.id = e, this.userData = {}, this._storage = new IP("__probe-".concat(this.id, "__"), RP), this.timeStamp("".concat(this.id, " started")), BP(this), Object.seal(this);
  }
  set level(e) {
    this.setLevel(e);
  }
  get level() {
    return this.getLevel();
  }
  isEnabled() {
    return this._storage.config.enabled;
  }
  getLevel() {
    return this._storage.config.level;
  }
  getTotal() {
    return Number((cd() - this._startTs).toPrecision(10));
  }
  getDelta() {
    return Number((cd() - this._deltaTs).toPrecision(10));
  }
  set priority(e) {
    this.level = e;
  }
  get priority() {
    return this.level;
  }
  getPriority() {
    return this.level;
  }
  enable() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    return this._storage.setConfiguration({
      enabled: e
    }), this;
  }
  setLevel(e) {
    return this._storage.setConfiguration({
      level: e
    }), this;
  }
  get(e) {
    return this._storage.config[e];
  }
  set(e, t) {
    this._storage.setConfiguration({
      [e]: t
    });
  }
  settings() {
    console.table ? console.table(this._storage.config) : console.log(this._storage.config);
  }
  assert(e, t) {
    hm(e, t);
  }
  warn(e) {
    return this._getLogFunction(0, e, ud.warn, arguments, I2);
  }
  error(e) {
    return this._getLogFunction(0, e, ud.error, arguments);
  }
  deprecated(e, t) {
    return this.warn("`".concat(e, "` is deprecated and will be removed in a later version. Use `").concat(t, "` instead"));
  }
  removed(e, t) {
    return this.error("`".concat(e, "` has been removed. Use `").concat(t, "` instead"));
  }
  probe(e, t) {
    return this._getLogFunction(e, t, ud.log, arguments, {
      time: !0,
      once: !0
    });
  }
  log(e, t) {
    return this._getLogFunction(e, t, ud.debug, arguments);
  }
  info(e, t) {
    return this._getLogFunction(e, t, console.info, arguments);
  }
  once(e, t) {
    for (var i = arguments.length, r = new Array(i > 2 ? i - 2 : 0), s = 2; s < i; s++)
      r[s - 2] = arguments[s];
    return this._getLogFunction(e, t, ud.debug || ud.info, arguments, I2);
  }
  table(e, t, i) {
    return t ? this._getLogFunction(e, t, console.table || Wa, i && [i], {
      tag: kP(t)
    }) : Wa;
  }
  image(e) {
    let {
      logLevel: t,
      priority: i,
      image: r,
      message: s = "",
      scale: c = 1
    } = e;
    return this._shouldLog(t || i) ? iu ? DP({
      image: r,
      message: s,
      scale: c
    }) : FP() : Wa;
  }
  time(e, t) {
    return this._getLogFunction(e, t, console.time ? console.time : console.info);
  }
  timeEnd(e, t) {
    return this._getLogFunction(e, t, console.timeEnd ? console.timeEnd : console.info);
  }
  timeStamp(e, t) {
    return this._getLogFunction(e, t, console.timeStamp || Wa);
  }
  group(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      collapsed: !1
    };
    const r = P2({
      logLevel: e,
      message: t,
      opts: i
    }), {
      collapsed: s
    } = i;
    return r.method = (s ? console.groupCollapsed : console.group) || console.info, this._getLogFunction(r);
  }
  groupCollapsed(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.group(e, t, Object.assign({}, i, {
      collapsed: !0
    }));
  }
  groupEnd(e) {
    return this._getLogFunction(e, "", console.groupEnd || Wa);
  }
  withGroup(e, t, i) {
    this.group(e, t)();
    try {
      i();
    } finally {
      this.groupEnd(e)();
    }
  }
  trace() {
    console.trace && console.trace();
  }
  _shouldLog(e) {
    return this.isEnabled() && this.getLevel() >= T5(e);
  }
  _getLogFunction(e, t, i, r, s) {
    if (this._shouldLog(e)) {
      s = P2({
        logLevel: e,
        message: t,
        args: r,
        opts: s
      }), i = i || s.method, hm(i), s.total = this.getTotal(), s.delta = this.getDelta(), this._deltaTs = cd();
      const c = s.tag || s.message;
      if (s.once)
        if (!C2[c])
          C2[c] = cd();
        else
          return Wa;
      return t = OP(this.id, s.message, s), i.bind(console, t, ...s.args);
    }
    return Wa;
  }
}
G(Pp, "VERSION", E5);
function T5(n) {
  if (!n)
    return 0;
  let e;
  switch (typeof n) {
    case "number":
      e = n;
      break;
    case "object":
      e = n.logLevel || n.priority || 0;
      break;
    default:
      return 0;
  }
  return hm(Number.isFinite(e) && e >= 0), e;
}
function P2(n) {
  const {
    logLevel: e,
    message: t
  } = n;
  n.logLevel = T5(e);
  const i = n.args ? Array.from(n.args) : [];
  for (; i.length && i.shift() !== t; )
    ;
  switch (typeof e) {
    case "string":
    case "function":
      t !== void 0 && i.unshift(t), n.message = e;
      break;
    case "object":
      Object.assign(n, e);
      break;
  }
  typeof n.message == "function" && (n.message = n.message());
  const r = typeof n.message;
  return hm(r === "string" || r === "object"), Object.assign(n, {
    args: i
  }, n.opts);
}
function OP(n, e, t) {
  if (typeof e == "string") {
    const i = t.time ? LP(PP(t.total)) : "";
    e = t.time ? "".concat(n, ": ").concat(i, "  ").concat(e) : "".concat(n, ": ").concat(e), e = MP(e, t.color, t.background);
  }
  return e;
}
function FP(n) {
  return console.warn("removed"), Wa;
}
function DP(n) {
  let {
    image: e,
    message: t = "",
    scale: i = 1
  } = n;
  if (typeof e == "string") {
    const s = new Image();
    return s.onload = () => {
      const c = j0(s, t, i);
      console.log(...c);
    }, s.src = e, Wa;
  }
  const r = e.nodeName || "";
  if (r.toLowerCase() === "img")
    return console.log(...j0(e, t, i)), Wa;
  if (r.toLowerCase() === "canvas") {
    const s = new Image();
    return s.onload = () => console.log(...j0(s, t, i)), s.src = e.toDataURL(), Wa;
  }
  return Wa;
}
function kP(n) {
  for (const e in n)
    for (const t in n[e])
      return t || "untitled";
  return "empty";
}
const L2 = new Pp({
  id: "loaders.gl"
});
class NP {
  log() {
    return () => {
    };
  }
  info() {
    return () => {
    };
  }
  warn() {
    return () => {
    };
  }
  error() {
    return () => {
    };
  }
}
class zP {
  constructor() {
    G(this, "console", void 0), this.console = console;
  }
  log() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return this.console.log.bind(this.console, ...t);
  }
  info() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return this.console.info.bind(this.console, ...t);
  }
  warn() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return this.console.warn.bind(this.console, ...t);
  }
  error() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return this.console.error.bind(this.console, ...t);
  }
}
const C5 = {
  fetch: null,
  mimeType: void 0,
  nothrow: !1,
  log: new zP(),
  CDN: "https://unpkg.com/@loaders.gl",
  worker: !0,
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: Lm,
  _nodeWorkers: !1,
  _workerType: "",
  limit: 0,
  _limitMB: 0,
  batchSize: "auto",
  batchDebounceMs: 0,
  metadata: !1,
  transforms: []
}, UP = {
  throws: "nothrow",
  dataType: "(no longer used)",
  uri: "baseUri",
  method: "fetch.method",
  headers: "fetch.headers",
  body: "fetch.body",
  mode: "fetch.mode",
  credentials: "fetch.credentials",
  cache: "fetch.cache",
  redirect: "fetch.redirect",
  referrer: "fetch.referrer",
  referrerPolicy: "fetch.referrerPolicy",
  integrity: "fetch.integrity",
  keepalive: "fetch.keepalive",
  signal: "fetch.signal"
};
function I5() {
  globalThis.loaders = globalThis.loaders || {};
  const {
    loaders: n
  } = globalThis;
  return n._state = n._state || {}, n._state;
}
const P5 = () => {
  const n = I5();
  return n.globalOptions = n.globalOptions || {
    ...C5
  }, n.globalOptions;
};
function jP(n, e, t, i) {
  return t = t || [], t = Array.isArray(t) ? t : [t], GP(n, t), qP(e, n, i);
}
function GP(n, e) {
  M2(n, null, C5, UP, e);
  for (const t of e) {
    const i = n && n[t.id] || {}, r = t.options && t.options[t.id] || {}, s = t.deprecatedOptions && t.deprecatedOptions[t.id] || {};
    M2(i, t.id, r, s, e);
  }
}
function M2(n, e, t, i, r) {
  const s = e || "Top level", c = e ? "".concat(e, ".") : "";
  for (const l in n) {
    const m = !e && Ip(n[l]), y = l === "baseUri" && !e, A = l === "workerUrl" && e;
    if (!(l in t) && !y && !A) {
      if (l in i)
        L2.warn("".concat(s, " loader option '").concat(c).concat(l, "' no longer supported, use '").concat(i[l], "'"))();
      else if (!m) {
        const T = VP(l, r);
        L2.warn("".concat(s, " loader option '").concat(c).concat(l, "' not recognized. ").concat(T))();
      }
    }
  }
}
function VP(n, e) {
  const t = n.toLowerCase();
  let i = "";
  for (const r of e)
    for (const s in r.options) {
      if (n === s)
        return "Did you mean '".concat(r.id, ".").concat(s, "'?");
      const c = s.toLowerCase();
      (t.startsWith(c) || c.startsWith(t)) && (i = i || "Did you mean '".concat(r.id, ".").concat(s, "'?"));
    }
  return i;
}
function qP(n, e, t) {
  const r = {
    ...n.options || {}
  };
  return HP(r, t), r.log === null && (r.log = new NP()), B2(r, P5()), B2(r, e), r;
}
function B2(n, e) {
  for (const t in e)
    if (t in e) {
      const i = e[t];
      A2(i) && A2(n[t]) ? n[t] = {
        ...n[t],
        ...e[t]
      } : n[t] = e[t];
    }
}
function HP(n, e) {
  e && !("baseUri" in n) && (n.baseUri = e);
}
function y1(n) {
  var e;
  return n ? (Array.isArray(n) && (n = n[0]), Array.isArray((e = n) === null || e === void 0 ? void 0 : e.extensions)) : !1;
}
function v1(n) {
  var e, t;
  Qi(n, "null loader"), Qi(y1(n), "invalid loader");
  let i;
  return Array.isArray(n) && (i = n[1], n = n[0], n = {
    ...n,
    options: {
      ...n.options,
      ...i
    }
  }), ((e = n) !== null && e !== void 0 && e.parseTextSync || (t = n) !== null && t !== void 0 && t.parseText) && (n.text = !0), n.text || (n.binary = !0), n;
}
const L5 = () => {
  const n = I5();
  return n.loaderRegistry = n.loaderRegistry || [], n.loaderRegistry;
};
function WP(n) {
  const e = L5();
  n = Array.isArray(n) ? n : [n];
  for (const t of n) {
    const i = v1(t);
    e.find((r) => i === r) || e.unshift(i);
  }
}
function XP() {
  return L5();
}
const JP = new Pp({
  id: "loaders.gl"
}), $P = /\.([^.]+)$/;
async function ZP(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], t = arguments.length > 2 ? arguments[2] : void 0, i = arguments.length > 3 ? arguments[3] : void 0;
  if (!M5(n))
    return null;
  let r = R2(n, e, {
    ...t,
    nothrow: !0
  }, i);
  if (r)
    return r;
  if (Gh(n) && (n = await n.slice(0, 10).arrayBuffer(), r = R2(n, e, t, i)), !r && !(t != null && t.nothrow))
    throw new Error(B5(n));
  return r;
}
function R2(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], t = arguments.length > 2 ? arguments[2] : void 0, i = arguments.length > 3 ? arguments[3] : void 0;
  if (!M5(n))
    return null;
  if (e && !Array.isArray(e))
    return v1(e);
  let r = [];
  e && (r = r.concat(e)), t != null && t.ignoreRegisteredLoaders || r.push(...XP()), KP(r);
  const s = YP(n, r, t, i);
  if (!s && !(t != null && t.nothrow))
    throw new Error(B5(n));
  return s;
}
function YP(n, e, t, i) {
  const r = Mm(n), s = _1(n), c = m1(r) || (i == null ? void 0 : i.url);
  let l = null, m = "";
  if (t != null && t.mimeType && (l = G0(e, t == null ? void 0 : t.mimeType), m = "match forced by supplied MIME type ".concat(t == null ? void 0 : t.mimeType)), l = l || QP(e, c), m = m || (l ? "matched url ".concat(c) : ""), l = l || G0(e, s), m = m || (l ? "matched MIME type ".concat(s) : ""), l = l || tL(e, n), m = m || (l ? "matched initial data ".concat(R5(n)) : ""), l = l || G0(e, t == null ? void 0 : t.fallbackMimeType), m = m || (l ? "matched fallback MIME type ".concat(s) : ""), m) {
    var y;
    JP.log(1, "selectLoader selected ".concat((y = l) === null || y === void 0 ? void 0 : y.name, ": ").concat(m, "."));
  }
  return l;
}
function M5(n) {
  return !(n instanceof Response && n.status === 204);
}
function B5(n) {
  const e = Mm(n), t = _1(n);
  let i = "No valid loader found (";
  i += e ? "".concat(v5(e), ", ") : "no url provided, ", i += "MIME type: ".concat(t ? '"'.concat(t, '"') : "not provided", ", ");
  const r = n ? R5(n) : "";
  return i += r ? ' first bytes: "'.concat(r, '"') : "first bytes: not available", i += ")", i;
}
function KP(n) {
  for (const e of n)
    v1(e);
}
function QP(n, e) {
  const t = e && $P.exec(e), i = t && t[1];
  return i ? eL(n, i) : null;
}
function eL(n, e) {
  e = e.toLowerCase();
  for (const t of n)
    for (const i of t.extensions)
      if (i.toLowerCase() === e)
        return t;
  return null;
}
function G0(n, e) {
  for (const t of n)
    if (t.mimeTypes && t.mimeTypes.includes(e) || e === "application/x.".concat(t.id))
      return t;
  return null;
}
function tL(n, e) {
  if (!e)
    return null;
  for (const t of n)
    if (typeof e == "string") {
      if (nL(e, t))
        return t;
    } else if (ArrayBuffer.isView(e)) {
      if (O2(e.buffer, e.byteOffset, t))
        return t;
    } else if (e instanceof ArrayBuffer && O2(e, 0, t))
      return t;
  return null;
}
function nL(n, e) {
  return e.testText ? e.testText(n) : (Array.isArray(e.tests) ? e.tests : [e.tests]).some((i) => n.startsWith(i));
}
function O2(n, e, t) {
  return (Array.isArray(t.tests) ? t.tests : [t.tests]).some((r) => iL(n, e, t, r));
}
function iL(n, e, t, i) {
  if (i instanceof ArrayBuffer)
    return KI(i, n, i.byteLength);
  switch (typeof i) {
    case "function":
      return i(n, t);
    case "string":
      const r = iy(n, e, i.length);
      return i === r;
    default:
      return !1;
  }
}
function R5(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
  return typeof n == "string" ? n.slice(0, e) : ArrayBuffer.isView(n) ? iy(n.buffer, n.byteOffset, e) : n instanceof ArrayBuffer ? iy(n, 0, e) : "";
}
function iy(n, e, t) {
  if (n.byteLength < e + t)
    return "";
  const i = new DataView(n);
  let r = "";
  for (let s = 0; s < t; s++)
    r += String.fromCharCode(i.getUint8(e + s));
  return r;
}
const rL = 256 * 1024;
function* sL(n, e) {
  const t = (e == null ? void 0 : e.chunkSize) || rL;
  let i = 0;
  const r = new TextEncoder();
  for (; i < n.length; ) {
    const s = Math.min(n.length - i, t), c = n.slice(i, i + s);
    i += s, yield r.encode(c);
  }
}
const oL = 256 * 1024;
function aL(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    const {
      chunkSize: t = oL
    } = e;
    let i = 0;
    for (; i < n.byteLength; ) {
      const r = Math.min(n.byteLength - i, t), s = new ArrayBuffer(r), c = new Uint8Array(n, i, r);
      new Uint8Array(s).set(c), i += r, yield s;
    }
  }();
}
const lL = 1024 * 1024;
async function* cL(n, e) {
  const t = (e == null ? void 0 : e.chunkSize) || lL;
  let i = 0;
  for (; i < n.size; ) {
    const r = i + t, s = await n.slice(i, r).arrayBuffer();
    i = r, yield s;
  }
}
function F2(n, e) {
  return Lm ? uL(n, e) : hL(n);
}
async function* uL(n, e) {
  const t = n.getReader();
  let i;
  try {
    for (; ; ) {
      const r = i || t.read();
      e != null && e._streamReadAhead && (i = t.read());
      const {
        done: s,
        value: c
      } = await r;
      if (s)
        return;
      yield y5(c);
    }
  } catch {
    t.releaseLock();
  }
}
async function* hL(n, e) {
  for await (const t of n)
    yield y5(t);
}
function dL(n, e) {
  if (typeof n == "string")
    return sL(n, e);
  if (n instanceof ArrayBuffer)
    return aL(n, e);
  if (Gh(n))
    return cL(n, e);
  if (b5(n))
    return F2(n, e);
  if (jh(n))
    return F2(n.body, e);
  throw new Error("makeIterator");
}
const O5 = "Cannot convert supplied data type";
function fL(n, e, t) {
  if (e.text && typeof n == "string")
    return n;
  if (gP(n) && (n = n.buffer), n instanceof ArrayBuffer) {
    const i = n;
    return e.text && !e.binary ? new TextDecoder("utf8").decode(i) : i;
  }
  if (ArrayBuffer.isView(n)) {
    if (e.text && !e.binary)
      return new TextDecoder("utf8").decode(n);
    let i = n.buffer;
    const r = n.byteLength || n.length;
    return (n.byteOffset !== 0 || r !== i.byteLength) && (i = i.slice(n.byteOffset, n.byteOffset + r)), i;
  }
  throw new Error(O5);
}
async function pL(n, e, t) {
  const i = n instanceof ArrayBuffer || ArrayBuffer.isView(n);
  if (typeof n == "string" || i)
    return fL(n, e);
  if (Gh(n) && (n = await w5(n)), jh(n)) {
    const r = n;
    return await AP(r), e.binary ? await r.arrayBuffer() : await r.text();
  }
  if (b5(n) && (n = dL(n, t)), fP(n) || pP(n))
    return tP(n);
  throw new Error(O5);
}
function F5(n, e) {
  const t = P5(), i = n || t;
  return typeof i.fetch == "function" ? i.fetch : Ip(i.fetch) ? (r) => S2(r, i) : e != null && e.fetch ? e == null ? void 0 : e.fetch : S2;
}
function gL(n, e, t) {
  if (t)
    return t;
  const i = {
    fetch: F5(e, n),
    ...n
  };
  if (i.url) {
    const r = m1(i.url);
    i.baseUrl = r, i.queryString = xP(i.url), i.filename = v5(r), i.baseUrl = g1(r);
  }
  return Array.isArray(i.loaders) || (i.loaders = null), i;
}
function mL(n, e) {
  if (!e && n && !Array.isArray(n))
    return n;
  let t;
  if (n && (t = Array.isArray(n) ? n : [n]), e && e.loaders) {
    const i = Array.isArray(e.loaders) ? e.loaders : [e.loaders];
    t = t ? [...t, ...i] : i;
  }
  return t && t.length ? t : null;
}
async function b1(n, e, t, i) {
  mc(!i || typeof i == "object"), e && !Array.isArray(e) && !y1(e) && (i = void 0, t = e, e = void 0), n = await n, t = t || {};
  const r = Mm(n), c = mL(e, i), l = await ZP(n, c, t);
  return l ? (t = jP(t, l, c, r), i = gL({
    url: r,
    parse: b1,
    loaders: c
  }, t, i || null), await _L(l, n, t, i)) : null;
}
async function _L(n, e, t, i) {
  if (zI(n), jh(e)) {
    const r = e, {
      ok: s,
      redirected: c,
      status: l,
      statusText: m,
      type: y,
      url: A
    } = r, T = Object.fromEntries(r.headers.entries());
    i.response = {
      headers: T,
      ok: s,
      redirected: c,
      status: l,
      statusText: m,
      type: y,
      url: A
    };
  }
  if (e = await pL(e, n, t), n.parseTextSync && typeof e == "string")
    return t.dataType = "text", n.parseTextSync(e, t, i, n);
  if (XI(n, t))
    return await JI(n, e, t, i, b1);
  if (n.parseText && typeof e == "string")
    return await n.parseText(e, t, i, n);
  if (n.parse)
    return await n.parse(e, t, i, n);
  throw mc(!n.parseSync), new Error("".concat(n.id, " loader - no parser found and worker is disabled"));
}
async function Ju(n, e, t, i) {
  !Array.isArray(e) && !y1(e) && (t = e, e = void 0);
  const r = F5(t);
  let s = n;
  return typeof n == "string" && (s = await r(n)), Gh(n) && (s = await r(n)), await b1(s, e, t);
}
const yL = "3.4.15", {
  _parseImageNode: vL
} = globalThis, ry = typeof Image < "u", sy = typeof ImageBitmap < "u", bL = !!vL, oy = Lm ? !0 : bL;
function xL(n) {
  switch (n) {
    case "auto":
      return sy || ry || oy;
    case "imagebitmap":
      return sy;
    case "image":
      return ry;
    case "data":
      return oy;
    default:
      throw new Error("@loaders.gl/images: image ".concat(n, " not supported in this environment"));
  }
}
function wL() {
  if (sy)
    return "imagebitmap";
  if (ry)
    return "image";
  if (oy)
    return "data";
  throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
}
function AL(n) {
  const e = SL(n);
  if (!e)
    throw new Error("Not an image");
  return e;
}
function EL(n) {
  switch (AL(n)) {
    case "data":
      return n;
    case "image":
    case "imagebitmap":
      const e = document.createElement("canvas"), t = e.getContext("2d");
      if (!t)
        throw new Error("getImageData");
      return e.width = n.width, e.height = n.height, t.drawImage(n, 0, 0), t.getImageData(0, 0, n.width, n.height);
    default:
      throw new Error("getImageData");
  }
}
function SL(n) {
  return typeof ImageBitmap < "u" && n instanceof ImageBitmap ? "imagebitmap" : typeof Image < "u" && n instanceof Image ? "image" : n && typeof n == "object" && n.data && n.width && n.height ? "data" : null;
}
const TL = /^data:image\/svg\+xml/, CL = /\.svg((\?|#).*)?$/;
function x1(n) {
  return n && (TL.test(n) || CL.test(n));
}
function IL(n, e) {
  if (x1(e)) {
    let i = new TextDecoder().decode(n);
    try {
      typeof unescape == "function" && typeof encodeURIComponent == "function" && (i = unescape(encodeURIComponent(i)));
    } catch (s) {
      throw new Error(s.message);
    }
    return "data:image/svg+xml;base64,".concat(btoa(i));
  }
  return D5(n, e);
}
function D5(n, e) {
  if (x1(e))
    throw new Error("SVG cannot be parsed directly to imagebitmap");
  return new Blob([new Uint8Array(n)]);
}
async function k5(n, e, t) {
  const i = IL(n, t), r = self.URL || self.webkitURL, s = typeof i != "string" && r.createObjectURL(i);
  try {
    return await PL(s || i, e);
  } finally {
    s && r.revokeObjectURL(s);
  }
}
async function PL(n, e) {
  const t = new Image();
  return t.src = n, e.image && e.image.decode && t.decode ? (await t.decode(), t) : await new Promise((i, r) => {
    try {
      t.onload = () => i(t), t.onerror = (s) => r(new Error("Could not load image ".concat(n, ": ").concat(s)));
    } catch (s) {
      r(s);
    }
  });
}
const LL = {};
let D2 = !0;
async function ML(n, e, t) {
  let i;
  x1(t) ? i = await k5(n, e, t) : i = D5(n, t);
  const r = e && e.imagebitmap;
  return await BL(i, r);
}
async function BL(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if ((RL(e) || !D2) && (e = null), e)
    try {
      return await createImageBitmap(n, e);
    } catch (t) {
      console.warn(t), D2 = !1;
    }
  return await createImageBitmap(n);
}
function RL(n) {
  for (const e in n || LL)
    return !1;
  return !0;
}
function OL(n) {
  return !NL(n, "ftyp", 4) || !(n[8] & 96) ? null : FL(n);
}
function FL(n) {
  switch (DL(n, 8, 12).replace("\0", " ").trim()) {
    case "avif":
    case "avis":
      return {
        extension: "avif",
        mimeType: "image/avif"
      };
    default:
      return null;
  }
}
function DL(n, e, t) {
  return String.fromCharCode(...n.slice(e, t));
}
function kL(n) {
  return [...n].map((e) => e.charCodeAt(0));
}
function NL(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const i = kL(e);
  for (let r = 0; r < i.length; ++r)
    if (i[r] !== n[r + t])
      return !1;
  return !0;
}
const lc = !1, np = !0;
function w1(n) {
  const e = Lp(n);
  return UL(e) || qL(e) || jL(e) || VL(e) || zL(e);
}
function zL(n) {
  const e = new Uint8Array(n instanceof DataView ? n.buffer : n), t = OL(e);
  return t ? {
    mimeType: t.mimeType,
    width: 0,
    height: 0
  } : null;
}
function UL(n) {
  const e = Lp(n);
  return e.byteLength >= 24 && e.getUint32(0, lc) === 2303741511 ? {
    mimeType: "image/png",
    width: e.getUint32(16, lc),
    height: e.getUint32(20, lc)
  } : null;
}
function jL(n) {
  const e = Lp(n);
  return e.byteLength >= 10 && e.getUint32(0, lc) === 1195984440 ? {
    mimeType: "image/gif",
    width: e.getUint16(6, np),
    height: e.getUint16(8, np)
  } : null;
}
function VL(n) {
  const e = Lp(n);
  return e.byteLength >= 14 && e.getUint16(0, lc) === 16973 && e.getUint32(2, np) === e.byteLength ? {
    mimeType: "image/bmp",
    width: e.getUint32(18, np),
    height: e.getUint32(22, np)
  } : null;
}
function qL(n) {
  const e = Lp(n);
  if (!(e.byteLength >= 3 && e.getUint16(0, lc) === 65496 && e.getUint8(2) === 255))
    return null;
  const {
    tableMarkers: i,
    sofMarkers: r
  } = HL();
  let s = 2;
  for (; s + 9 < e.byteLength; ) {
    const c = e.getUint16(s, lc);
    if (r.has(c))
      return {
        mimeType: "image/jpeg",
        height: e.getUint16(s + 5, lc),
        width: e.getUint16(s + 7, lc)
      };
    if (!i.has(c))
      return null;
    s += 2, s += e.getUint16(s, lc);
  }
  return null;
}
function HL() {
  const n = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);
  for (let t = 65504; t < 65520; ++t)
    n.add(t);
  return {
    tableMarkers: n,
    sofMarkers: /* @__PURE__ */ new Set([65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485, 65486, 65487, 65502])
  };
}
function Lp(n) {
  if (n instanceof DataView)
    return n;
  if (ArrayBuffer.isView(n))
    return new DataView(n.buffer);
  if (n instanceof ArrayBuffer)
    return new DataView(n);
  throw new Error("toDataView");
}
async function WL(n, e) {
  const {
    mimeType: t
  } = w1(n) || {}, i = globalThis._parseImageNode;
  return Qi(i), await i(n, t);
}
async function XL(n, e, t) {
  e = e || {};
  const r = (e.image || {}).type || "auto", {
    url: s
  } = t || {}, c = JL(r);
  let l;
  switch (c) {
    case "imagebitmap":
      l = await ML(n, e, s);
      break;
    case "image":
      l = await k5(n, e, s);
      break;
    case "data":
      l = await WL(n);
      break;
    default:
      Qi(!1);
  }
  return r === "data" && (l = EL(l)), l;
}
function JL(n) {
  switch (n) {
    case "auto":
    case "data":
      return wL();
    default:
      return xL(n), n;
  }
}
const $L = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"], ZL = ["image/png", "image/jpeg", "image/gif", "image/webp", "image/avif", "image/bmp", "image/vnd.microsoft.icon", "image/svg+xml"], YL = {
  image: {
    type: "auto",
    decode: !0
  }
}, N5 = {
  id: "image",
  module: "images",
  name: "Images",
  version: yL,
  mimeTypes: ZL,
  extensions: $L,
  parse: XL,
  tests: [(n) => !!w1(new DataView(n))],
  options: YL
}, V0 = {};
function KL(n) {
  if (V0[n] === void 0) {
    const e = Lm ? eM(n) : QL(n);
    V0[n] = e;
  }
  return V0[n];
}
function QL(n) {
  const e = ["image/png", "image/jpeg", "image/gif"], {
    _parseImageNode: t,
    _imageFormatsNode: i = e
  } = globalThis;
  return !!t && i.includes(n);
}
function eM(n) {
  switch (n) {
    case "image/avif":
    case "image/webp":
      return tM(n);
    default:
      return !0;
  }
}
function tM(n) {
  try {
    return document.createElement("canvas").toDataURL(n).indexOf("data:".concat(n)) === 0;
  } catch {
    return !1;
  }
}
const hi = new Pp({
  id: "deck"
}), Lu = {
  attributeUpdateStart: -1,
  attributeManagerUpdateStart: -1,
  attributeUpdateMessages: []
}, q0 = 1, Of = 2, H0 = 3, W0 = 4, nM = 2, iM = (n) => ({
  "layer.changeFlag": (e, t, i) => {
    n.log(H0, "".concat(e.id, " ").concat(t, ": "), i[t])();
  },
  "layer.initialize": (e) => {
    n.log(q0, "Initializing ".concat(e))();
  },
  "layer.update": (e, t) => {
    if (t) {
      const i = e.getChangeFlags();
      n.log(Of, "Updating ".concat(e, " because: ").concat(Object.keys(i).filter((r) => i[r]).join(", ")))();
    } else
      n.log(W0, "".concat(e, " does not need update"))();
  },
  "layer.matched": (e, t) => {
    t && n.log(W0, "Matched ".concat(e, ", state transfered"))();
  },
  "layer.finalize": (e) => {
    n.log(q0, "Finalizing ".concat(e))();
  },
  "compositeLayer.renderLayers": (e, t, i) => {
    t ? n.log(Of, "Composite layer rendered new subLayers ".concat(e), i)() : n.log(W0, "Composite layer reused subLayers ".concat(e), i)();
  },
  "layerManager.setLayers": (e, t, i) => {
    t && n.log(Of, "Updating ".concat(i.length, " deck layers"))();
  },
  "layerManager.activateViewport": (e, t) => {
    n.log(H0, "Viewport changed", t)();
  },
  "attributeManager.invalidate": (e, t, i) => {
    n.log(q0, i ? "invalidated attributes ".concat(i, " (").concat(t, ") for ").concat(e.id) : "invalidated all attributes for ".concat(e.id))();
  },
  "attributeManager.updateStart": (e) => {
    Lu.attributeUpdateMessages.length = 0, Lu.attributeManagerUpdateStart = Date.now();
  },
  "attributeManager.updateEnd": (e, t) => {
    const i = Math.round(Date.now() - Lu.attributeManagerUpdateStart);
    n.groupCollapsed(Of, "Updated attributes for ".concat(t, " instances in ").concat(e.id, " in ").concat(i, "ms"))();
    for (const r of Lu.attributeUpdateMessages)
      n.log(H0, r)();
    n.groupEnd(Of)();
  },
  "attribute.updateStart": (e) => {
    Lu.attributeUpdateStart = Date.now();
  },
  "attribute.allocate": (e, t) => {
    const i = "".concat(e.id, " allocated ").concat(t);
    Lu.attributeUpdateMessages.push(i);
  },
  "attribute.updateEnd": (e, t) => {
    const i = Math.round(Date.now() - Lu.attributeUpdateStart), r = "".concat(e.id, " updated ").concat(t, " in ").concat(i, "ms");
    Lu.attributeUpdateMessages.push(r);
  },
  "deckRenderer.renderLayers": (e, t, i) => {
    const {
      pass: r,
      redrawReason: s,
      stats: c
    } = i;
    for (const l of t) {
      const {
        totalCount: m,
        visibleCount: y,
        compositeCount: A,
        pickableCount: T
      } = l, L = m - A - y;
      n.log(nM, "RENDER #".concat(e.renderCount, "   ").concat(y, " (of ").concat(m, " layers) to ").concat(r, " because ").concat(s, "   (").concat(L, " hidden, ").concat(A, " composite ").concat(T, " pickable)"))(), c && c.get("Redraw Layers").add(y);
    }
  }
});
var rM = {};
let dm = {};
rM.NODE_ENV !== "production" && (dm = iM(hi));
function sM(n) {
  dm = n;
}
function Xs(n, e, t, i) {
  hi.level > 0 && dm[n] && dm[n].call(null, e, t, i);
}
function oM(n) {
  const e = n[0], t = n[n.length - 1];
  return e === "{" && t === "}" || e === "[" && t === "]";
}
const aM = {
  id: "JSON",
  name: "JSON",
  module: "",
  version: "",
  options: {},
  extensions: ["json", "geojson"],
  mimeTypes: ["application/json", "application/geo+json"],
  testText: oM,
  parseTextSync: JSON.parse
};
function lM() {
  const n = "8.9.36", e = globalThis.deck && globalThis.deck.VERSION;
  if (e && e !== n)
    throw new Error("deck.gl - multiple versions detected: ".concat(e, " vs ").concat(n));
  return e || (hi.log(1, "deck.gl ".concat(n))(), globalThis.deck = {
    ...globalThis.deck,
    VERSION: n,
    version: n,
    log: hi,
    _registerLoggers: sM
  }, WP([aM, [N5, {
    imagebitmap: {
      premultiplyAlpha: "none"
    }
  }]])), n;
}
const cM = lM(), li = {
  DEFAULT: -1,
  LNGLAT: 1,
  METER_OFFSETS: 2,
  LNGLAT_OFFSETS: 3,
  CARTESIAN: 0
};
Object.defineProperty(li, "IDENTITY", {
  get: () => (hi.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")(), 0)
});
const uc = {
  WEB_MERCATOR: 1,
  GLOBE: 2,
  WEB_MERCATOR_AUTO_OFFSET: 4,
  IDENTITY: 0
}, ay = {
  common: 0,
  meters: 1,
  pixels: 2
}, k2 = {
  click: {
    handler: "onClick"
  },
  panstart: {
    handler: "onDragStart"
  },
  panmove: {
    handler: "onDrag"
  },
  panend: {
    handler: "onDragEnd"
  }
}, cn = new Pp({
  id: "luma.gl"
});
function go(n, e) {
  if (!n)
    throw new Error(e || "luma.gl: assertion failed.");
}
const uM = "Invalid WebGLRenderingContext", hM = "Requires WebGL2";
function Bm(n) {
  return typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext || typeof WebGL2RenderingContext < "u" && n instanceof WebGL2RenderingContext ? !0 : !!(n && Number.isFinite(n._version));
}
function ei(n) {
  return typeof WebGL2RenderingContext < "u" && n instanceof WebGL2RenderingContext ? !0 : !!(n && n._version === 2);
}
function dM(n) {
  return ei(n) ? n : null;
}
function Rm(n) {
  return go(Bm(n), uM), n;
}
function mo(n) {
  return go(ei(n), hM), n;
}
const Zf = {};
function fM(n) {
  globalThis.console && globalThis.console.error && globalThis.console.error(n);
}
function pM(n) {
  globalThis.console && globalThis.console.log && globalThis.console.log(n);
}
function gM(n, e) {
  Zf[n] = !0, fM(e);
}
function mM(n) {
  const e = n.getError;
  n.getError = function() {
    let i;
    do
      i = e.apply(n), i !== 0 && (Zf[i] = !0);
    while (i !== 0);
    for (i in Zf)
      if (Zf[i])
        return delete Zf[i], parseInt(i, 10);
    return 0;
  };
}
const Mp = function n(e) {
  const t = e.gl;
  this.ext = e, this.isAlive = !0, this.hasBeenBound = !1, this.elementArrayBuffer = null, this.attribs = new Array(e.maxVertexAttribs);
  for (let i = 0; i < this.attribs.length; i++) {
    const r = new n.VertexAttrib(t);
    this.attribs[i] = r;
  }
  this.maxAttrib = 0;
};
Mp.VertexAttrib = function(e) {
  this.enabled = !1, this.buffer = null, this.size = 4, this.type = 5126, this.normalized = !1, this.stride = 16, this.offset = 0, this.cached = "", this.recache();
};
Mp.VertexAttrib.prototype.recache = function() {
  this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":");
};
const Vh = function(e) {
  const t = this;
  this.gl = e, mM(e);
  const i = this.original = {
    getParameter: e.getParameter,
    enableVertexAttribArray: e.enableVertexAttribArray,
    disableVertexAttribArray: e.disableVertexAttribArray,
    bindBuffer: e.bindBuffer,
    getVertexAttrib: e.getVertexAttrib,
    vertexAttribPointer: e.vertexAttribPointer
  };
  e.getParameter = function(s) {
    return s === t.VERTEX_ARRAY_BINDING_OES ? t.currentVertexArrayObject === t.defaultVertexArrayObject ? null : t.currentVertexArrayObject : i.getParameter.apply(this, arguments);
  }, e.enableVertexAttribArray = function(s) {
    const c = t.currentVertexArrayObject;
    c.maxAttrib = Math.max(c.maxAttrib, s);
    const l = c.attribs[s];
    return l.enabled = !0, i.enableVertexAttribArray.apply(this, arguments);
  }, e.disableVertexAttribArray = function(s) {
    const c = t.currentVertexArrayObject;
    c.maxAttrib = Math.max(c.maxAttrib, s);
    const l = c.attribs[s];
    return l.enabled = !1, i.disableVertexAttribArray.apply(this, arguments);
  }, e.bindBuffer = function(s, c) {
    switch (s) {
      case 34962:
        t.currentArrayBuffer = c;
        break;
      case 34963:
        t.currentVertexArrayObject.elementArrayBuffer = c;
        break;
    }
    return i.bindBuffer.apply(this, arguments);
  }, e.getVertexAttrib = function(s, c) {
    const m = t.currentVertexArrayObject.attribs[s];
    switch (c) {
      case 34975:
        return m.buffer;
      case 34338:
        return m.enabled;
      case 34339:
        return m.size;
      case 34340:
        return m.stride;
      case 34341:
        return m.type;
      case 34922:
        return m.normalized;
      default:
        return i.getVertexAttrib.apply(this, arguments);
    }
  }, e.vertexAttribPointer = function(s, c, l, m, y, A) {
    const T = t.currentVertexArrayObject;
    T.maxAttrib = Math.max(T.maxAttrib, s);
    const I = T.attribs[s];
    return I.buffer = t.currentArrayBuffer, I.size = c, I.type = l, I.normalized = m, I.stride = y, I.offset = A, I.recache(), i.vertexAttribPointer.apply(this, arguments);
  }, e.instrumentExtension && e.instrumentExtension(this, "OES_vertex_array_object"), e.canvas && e.canvas.addEventListener("webglcontextrestored", () => {
    pM("OESVertexArrayObject emulation library context restored"), t.reset_();
  }, !0), this.reset_();
};
Vh.prototype.VERTEX_ARRAY_BINDING_OES = 34229;
Vh.prototype.reset_ = function() {
  if (this.vertexArrayObjects !== void 0)
    for (let i = 0; i < this.vertexArrayObjects.length; ++i)
      this.vertexArrayObjects.isAlive = !1;
  const t = this.gl;
  this.maxVertexAttribs = t.getParameter(34921), this.defaultVertexArrayObject = new Mp(this), this.currentVertexArrayObject = null, this.currentArrayBuffer = null, this.vertexArrayObjects = [this.defaultVertexArrayObject], this.bindVertexArrayOES(null);
};
Vh.prototype.createVertexArrayOES = function() {
  const e = new Mp(this);
  return this.vertexArrayObjects.push(e), e;
};
Vh.prototype.deleteVertexArrayOES = function(e) {
  e.isAlive = !1, this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(e), 1), this.currentVertexArrayObject === e && this.bindVertexArrayOES(null);
};
Vh.prototype.isVertexArrayOES = function(e) {
  return !!(e && e instanceof Mp && e.hasBeenBound && e.ext === this);
};
Vh.prototype.bindVertexArrayOES = function(e) {
  const t = this.gl;
  if (e && !e.isAlive) {
    gM(1282, "bindVertexArrayOES: attempt to bind deleted arrayObject");
    return;
  }
  const i = this.original, r = this.currentVertexArrayObject;
  this.currentVertexArrayObject = e || this.defaultVertexArrayObject, this.currentVertexArrayObject.hasBeenBound = !0;
  const s = this.currentVertexArrayObject;
  if (r === s)
    return;
  (!r || s.elementArrayBuffer !== r.elementArrayBuffer) && i.bindBuffer.call(t, 34963, s.elementArrayBuffer);
  let c = this.currentArrayBuffer;
  const l = Math.max(r ? r.maxAttrib : 0, s.maxAttrib);
  for (let m = 0; m <= l; m++) {
    const y = s.attribs[m], A = r ? r.attribs[m] : null;
    if ((!r || y.enabled !== A.enabled) && (y.enabled ? i.enableVertexAttribArray.call(t, m) : i.disableVertexAttribArray.call(t, m)), y.enabled) {
      let T = !1;
      (!r || y.buffer !== A.buffer) && (c !== y.buffer && (i.bindBuffer.call(t, 34962, y.buffer), c = y.buffer), T = !0), (T || y.cached !== A.cached) && i.vertexAttribPointer.call(t, m, y.size, y.type, y.normalized, y.stride, y.offset);
    }
  }
  this.currentArrayBuffer !== c && i.bindBuffer.call(t, 34962, this.currentArrayBuffer);
};
function _M(n) {
  if (typeof n.createVertexArray == "function")
    return;
  const e = n.getSupportedExtensions;
  n.getSupportedExtensions = function() {
    const r = e.call(this) || [];
    return r.indexOf("OES_vertex_array_object") < 0 && r.push("OES_vertex_array_object"), r;
  };
  const t = n.getExtension;
  n.getExtension = function(r) {
    const s = t.call(this, r);
    return s || (r !== "OES_vertex_array_object" ? null : (n.__OESVertexArrayObject || (this.__OESVertexArrayObject = new Vh(this)), this.__OESVertexArrayObject));
  };
}
const N2 = "OES_element_index", z2 = "WEBGL_draw_buffers", yM = "EXT_disjoint_timer_query", vM = "EXT_disjoint_timer_query_webgl2", bM = "EXT_texture_filter_anisotropic", U2 = "WEBGL_debug_renderer_info", xM = 35723, wM = 4352, AM = 36795, EM = 34047, SM = 37445, TM = 37446, ir = (n) => ei(n) ? void 0 : 0, CM = {
  3074: (n) => ei(n) ? void 0 : 36064,
  [xM]: (n) => ei(n) ? void 0 : wM,
  35977: ir,
  32937: ir,
  [AM]: (n, e) => {
    const t = ei(n) ? n.getExtension(vM) : n.getExtension(yM);
    return t && t.GPU_DISJOINT_EXT ? e(t.GPU_DISJOINT_EXT) : 0;
  },
  [SM]: (n, e) => {
    const t = n.getExtension(U2);
    return e(t && t.UNMASKED_VENDOR_WEBGL || 7936);
  },
  [TM]: (n, e) => {
    const t = n.getExtension(U2);
    return e(t && t.UNMASKED_RENDERER_WEBGL || 7937);
  },
  [EM]: (n, e) => {
    const t = n.luma.extensions[bM];
    return t ? e(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
  },
  32883: ir,
  35071: ir,
  37447: ir,
  36063: (n, e) => {
    if (!ei(n)) {
      const t = n.getExtension(z2);
      return t ? e(t.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;
    }
  },
  35379: ir,
  35374: ir,
  35377: ir,
  34852: (n) => {
    if (!ei(n)) {
      const e = n.getExtension(z2);
      return e ? e.MAX_DRAW_BUFFERS_WEBGL : 0;
    }
  },
  36203: (n) => n.getExtension(N2) ? 2147483647 : 65535,
  33001: (n) => n.getExtension(N2) ? 16777216 : 65535,
  33e3: (n) => 16777216,
  37157: ir,
  35373: ir,
  35657: ir,
  36183: ir,
  37137: ir,
  34045: ir,
  35978: ir,
  35979: ir,
  35968: ir,
  35376: ir,
  35375: ir,
  35659: ir,
  37154: ir,
  35371: ir,
  35658: ir,
  35076: ir,
  35077: ir,
  35380: ir
};
function IM(n, e, t) {
  const i = CM[t], r = typeof i == "function" ? i(n, e, t) : i;
  return r !== void 0 ? r : e(t);
}
const PM = "OES_vertex_array_object", z5 = "ANGLE_instanced_arrays", LM = "WEBGL_draw_buffers", MM = "EXT_disjoint_timer_query", BM = "EXT_texture_filter_anisotropic", RM = "VertexArray requires WebGL2 or OES_vertex_array_object extension";
function OM(n, e) {
  return {
    webgl2: ei(n),
    ext: n.getExtension(e)
  };
}
const U5 = {
  [PM]: {
    meta: {
      suffix: "OES"
    },
    createVertexArray: () => {
      go(!1, RM);
    },
    deleteVertexArray: () => {
    },
    bindVertexArray: () => {
    },
    isVertexArray: () => !1
  },
  [z5]: {
    meta: {
      suffix: "ANGLE"
    },
    vertexAttribDivisor(n, e) {
      go(e === 0, "WebGL instanced rendering not supported");
    },
    drawElementsInstanced: () => {
    },
    drawArraysInstanced: () => {
    }
  },
  [LM]: {
    meta: {
      suffix: "WEBGL"
    },
    drawBuffers: () => {
      go(!1);
    }
  },
  [MM]: {
    meta: {
      suffix: "EXT"
    },
    createQuery: () => {
      go(!1);
    },
    deleteQuery: () => {
      go(!1);
    },
    beginQuery: () => {
      go(!1);
    },
    endQuery: () => {
    },
    getQuery(n, e) {
      return this.getQueryObject(n, e);
    },
    getQueryParameter(n, e) {
      return this.getQueryObject(n, e);
    },
    getQueryObject: () => {
    }
  }
}, X0 = {
  readBuffer: (n, e, t) => {
    ei(n) && e(t);
  },
  getVertexAttrib: (n, e, t, i) => {
    const {
      webgl2: r,
      ext: s
    } = OM(n, z5);
    let c;
    switch (i) {
      case 35069:
        c = r ? void 0 : !1;
        break;
      case 35070:
        c = !r && !s ? 0 : void 0;
        break;
    }
    return c !== void 0 ? c : e(t, i);
  },
  getProgramParameter: (n, e, t, i) => {
    if (!ei(n))
      switch (i) {
        case 35967:
          return 35981;
        case 35971:
          return 0;
        case 35382:
          return 0;
      }
    return e(t, i);
  },
  getInternalformatParameter: (n, e, t, i, r) => {
    if (!ei(n))
      switch (r) {
        case 32937:
          return new Int32Array([0]);
      }
    return n.getInternalformatParameter(t, i, r);
  },
  getTexParameter(n, e, t, i) {
    switch (i) {
      case 34046:
        const {
          extensions: r
        } = n.luma, s = r[BM];
        i = s && s.TEXTURE_MAX_ANISOTROPY_EXT || 34046;
        break;
    }
    return e(t, i);
  },
  getParameter: IM,
  hint(n, e, t, i) {
    return e(t, i);
  }
};
function FM(n) {
  n.luma = n.luma || {};
  const {
    luma: e
  } = n;
  return e.polyfilled || (_M(n), DM(n), NM(n, U5), kM(n, {
    target: e,
    target2: n
  }), e.polyfilled = !0), n;
}
globalThis.polyfillContext = FM;
function DM(n) {
  n.luma.extensions = {};
  const e = n.getSupportedExtensions() || [];
  for (const t of e)
    n.luma[t] = n.getExtension(t);
}
function kM(n, e) {
  let {
    target: t,
    target2: i
  } = e;
  Object.keys(X0).forEach((r) => {
    if (typeof X0[r] == "function") {
      const s = n[r] ? n[r].bind(n) : () => {
      }, c = X0[r].bind(null, n, s);
      t[r] = c, i[r] = c;
    }
  });
}
function NM(n, e) {
  for (const t of Object.getOwnPropertyNames(e))
    t !== "overrides" && zM(n, {
      extension: t,
      target: n.luma,
      target2: n
    });
}
function zM(n, e) {
  let {
    extension: t,
    target: i,
    target2: r
  } = e;
  const s = U5[t];
  go(s);
  const {
    meta: c = {}
  } = s, {
    suffix: l = ""
  } = c, m = n.getExtension(t);
  for (const y of Object.keys(s)) {
    const A = "".concat(y).concat(l);
    let T = null;
    y === "meta" || typeof n[y] == "function" || (m && typeof m[A] == "function" ? T = function() {
      return m[A](...arguments);
    } : typeof s[y] == "function" && (T = s[y].bind(i))), T && (i[y] = T, r[y] = T);
  }
}
const A1 = {
  3042: !1,
  32773: new Float32Array([0, 0, 0, 0]),
  32777: 32774,
  34877: 32774,
  32969: 1,
  32968: 0,
  32971: 1,
  32970: 0,
  3106: new Float32Array([0, 0, 0, 0]),
  3107: [!0, !0, !0, !0],
  2884: !1,
  2885: 1029,
  2929: !1,
  2931: 1,
  2932: 513,
  2928: new Float32Array([0, 1]),
  2930: !0,
  3024: !0,
  36006: null,
  2886: 2305,
  33170: 4352,
  2849: 1,
  32823: !1,
  32824: 0,
  10752: 0,
  32938: 1,
  32939: !1,
  3089: !1,
  3088: new Int32Array([0, 0, 1024, 1024]),
  2960: !1,
  2961: 0,
  2968: 4294967295,
  36005: 4294967295,
  2962: 519,
  2967: 0,
  2963: 4294967295,
  34816: 519,
  36003: 0,
  36004: 4294967295,
  2964: 7680,
  2965: 7680,
  2966: 7680,
  34817: 7680,
  34818: 7680,
  34819: 7680,
  2978: [0, 0, 1024, 1024],
  3333: 4,
  3317: 4,
  37440: !1,
  37441: !1,
  37443: 37444,
  35723: 4352,
  36010: null,
  35977: !1,
  3330: 0,
  3332: 0,
  3331: 0,
  3314: 0,
  32878: 0,
  3316: 0,
  3315: 0,
  32877: 0
}, Mu = (n, e, t) => e ? n.enable(t) : n.disable(t), j2 = (n, e, t) => n.hint(t, e), oa = (n, e, t) => n.pixelStorei(t, e), UM = (n, e) => {
  const t = ei(n) ? 36009 : 36160;
  return n.bindFramebuffer(t, e);
}, jM = (n, e) => n.bindFramebuffer(36008, e);
function Ff(n) {
  return Array.isArray(n) || ArrayBuffer.isView(n);
}
const GM = {
  3042: Mu,
  32773: (n, e) => n.blendColor(...e),
  32777: "blendEquation",
  34877: "blendEquation",
  32969: "blendFunc",
  32968: "blendFunc",
  32971: "blendFunc",
  32970: "blendFunc",
  3106: (n, e) => n.clearColor(...e),
  3107: (n, e) => n.colorMask(...e),
  2884: Mu,
  2885: (n, e) => n.cullFace(e),
  2929: Mu,
  2931: (n, e) => n.clearDepth(e),
  2932: (n, e) => n.depthFunc(e),
  2928: (n, e) => n.depthRange(...e),
  2930: (n, e) => n.depthMask(e),
  3024: Mu,
  35723: j2,
  36006: UM,
  2886: (n, e) => n.frontFace(e),
  33170: j2,
  2849: (n, e) => n.lineWidth(e),
  32823: Mu,
  32824: "polygonOffset",
  10752: "polygonOffset",
  35977: Mu,
  32938: "sampleCoverage",
  32939: "sampleCoverage",
  3089: Mu,
  3088: (n, e) => n.scissor(...e),
  2960: Mu,
  2961: (n, e) => n.clearStencil(e),
  2968: (n, e) => n.stencilMaskSeparate(1028, e),
  36005: (n, e) => n.stencilMaskSeparate(1029, e),
  2962: "stencilFuncFront",
  2967: "stencilFuncFront",
  2963: "stencilFuncFront",
  34816: "stencilFuncBack",
  36003: "stencilFuncBack",
  36004: "stencilFuncBack",
  2964: "stencilOpFront",
  2965: "stencilOpFront",
  2966: "stencilOpFront",
  34817: "stencilOpBack",
  34818: "stencilOpBack",
  34819: "stencilOpBack",
  2978: (n, e) => n.viewport(...e),
  3333: oa,
  3317: oa,
  37440: oa,
  37441: oa,
  37443: oa,
  3330: oa,
  3332: oa,
  3331: oa,
  36010: jM,
  3314: oa,
  32878: oa,
  3316: oa,
  3315: oa,
  32877: oa,
  framebuffer: (n, e) => {
    const t = e && "handle" in e ? e.handle : e;
    return n.bindFramebuffer(36160, t);
  },
  blend: (n, e) => e ? n.enable(3042) : n.disable(3042),
  blendColor: (n, e) => n.blendColor(...e),
  blendEquation: (n, e) => {
    e = Ff(e) ? e : [e, e], n.blendEquationSeparate(...e);
  },
  blendFunc: (n, e) => {
    e = Ff(e) && e.length === 2 ? [...e, ...e] : e, n.blendFuncSeparate(...e);
  },
  clearColor: (n, e) => n.clearColor(...e),
  clearDepth: (n, e) => n.clearDepth(e),
  clearStencil: (n, e) => n.clearStencil(e),
  colorMask: (n, e) => n.colorMask(...e),
  cull: (n, e) => e ? n.enable(2884) : n.disable(2884),
  cullFace: (n, e) => n.cullFace(e),
  depthTest: (n, e) => e ? n.enable(2929) : n.disable(2929),
  depthFunc: (n, e) => n.depthFunc(e),
  depthMask: (n, e) => n.depthMask(e),
  depthRange: (n, e) => n.depthRange(...e),
  dither: (n, e) => e ? n.enable(3024) : n.disable(3024),
  derivativeHint: (n, e) => {
    n.hint(35723, e);
  },
  frontFace: (n, e) => n.frontFace(e),
  mipmapHint: (n, e) => n.hint(33170, e),
  lineWidth: (n, e) => n.lineWidth(e),
  polygonOffsetFill: (n, e) => e ? n.enable(32823) : n.disable(32823),
  polygonOffset: (n, e) => n.polygonOffset(...e),
  sampleCoverage: (n, e) => n.sampleCoverage(...e),
  scissorTest: (n, e) => e ? n.enable(3089) : n.disable(3089),
  scissor: (n, e) => n.scissor(...e),
  stencilTest: (n, e) => e ? n.enable(2960) : n.disable(2960),
  stencilMask: (n, e) => {
    e = Ff(e) ? e : [e, e];
    const [t, i] = e;
    n.stencilMaskSeparate(1028, t), n.stencilMaskSeparate(1029, i);
  },
  stencilFunc: (n, e) => {
    e = Ff(e) && e.length === 3 ? [...e, ...e] : e;
    const [t, i, r, s, c, l] = e;
    n.stencilFuncSeparate(1028, t, i, r), n.stencilFuncSeparate(1029, s, c, l);
  },
  stencilOp: (n, e) => {
    e = Ff(e) && e.length === 3 ? [...e, ...e] : e;
    const [t, i, r, s, c, l] = e;
    n.stencilOpSeparate(1028, t, i, r), n.stencilOpSeparate(1029, s, c, l);
  },
  viewport: (n, e) => n.viewport(...e)
};
function Er(n, e, t) {
  return e[n] !== void 0 ? e[n] : t[n];
}
const VM = {
  blendEquation: (n, e, t) => n.blendEquationSeparate(Er(32777, e, t), Er(34877, e, t)),
  blendFunc: (n, e, t) => n.blendFuncSeparate(Er(32969, e, t), Er(32968, e, t), Er(32971, e, t), Er(32970, e, t)),
  polygonOffset: (n, e, t) => n.polygonOffset(Er(32824, e, t), Er(10752, e, t)),
  sampleCoverage: (n, e, t) => n.sampleCoverage(Er(32938, e, t), Er(32939, e, t)),
  stencilFuncFront: (n, e, t) => n.stencilFuncSeparate(1028, Er(2962, e, t), Er(2967, e, t), Er(2963, e, t)),
  stencilFuncBack: (n, e, t) => n.stencilFuncSeparate(1029, Er(34816, e, t), Er(36003, e, t), Er(36004, e, t)),
  stencilOpFront: (n, e, t) => n.stencilOpSeparate(1028, Er(2964, e, t), Er(2965, e, t), Er(2966, e, t)),
  stencilOpBack: (n, e, t) => n.stencilOpSeparate(1029, Er(34817, e, t), Er(34818, e, t), Er(34819, e, t))
}, G2 = {
  enable: (n, e) => n({
    [e]: !0
  }),
  disable: (n, e) => n({
    [e]: !1
  }),
  pixelStorei: (n, e, t) => n({
    [e]: t
  }),
  hint: (n, e, t) => n({
    [e]: t
  }),
  bindFramebuffer: (n, e, t) => {
    switch (e) {
      case 36160:
        return n({
          36006: t,
          36010: t
        });
      case 36009:
        return n({
          36006: t
        });
      case 36008:
        return n({
          36010: t
        });
      default:
        return null;
    }
  },
  blendColor: (n, e, t, i, r) => n({
    32773: new Float32Array([e, t, i, r])
  }),
  blendEquation: (n, e) => n({
    32777: e,
    34877: e
  }),
  blendEquationSeparate: (n, e, t) => n({
    32777: e,
    34877: t
  }),
  blendFunc: (n, e, t) => n({
    32969: e,
    32968: t,
    32971: e,
    32970: t
  }),
  blendFuncSeparate: (n, e, t, i, r) => n({
    32969: e,
    32968: t,
    32971: i,
    32970: r
  }),
  clearColor: (n, e, t, i, r) => n({
    3106: new Float32Array([e, t, i, r])
  }),
  clearDepth: (n, e) => n({
    2931: e
  }),
  clearStencil: (n, e) => n({
    2961: e
  }),
  colorMask: (n, e, t, i, r) => n({
    3107: [e, t, i, r]
  }),
  cullFace: (n, e) => n({
    2885: e
  }),
  depthFunc: (n, e) => n({
    2932: e
  }),
  depthRange: (n, e, t) => n({
    2928: new Float32Array([e, t])
  }),
  depthMask: (n, e) => n({
    2930: e
  }),
  frontFace: (n, e) => n({
    2886: e
  }),
  lineWidth: (n, e) => n({
    2849: e
  }),
  polygonOffset: (n, e, t) => n({
    32824: e,
    10752: t
  }),
  sampleCoverage: (n, e, t) => n({
    32938: e,
    32939: t
  }),
  scissor: (n, e, t, i, r) => n({
    3088: new Int32Array([e, t, i, r])
  }),
  stencilMask: (n, e) => n({
    2968: e,
    36005: e
  }),
  stencilMaskSeparate: (n, e, t) => n({
    [e === 1028 ? 2968 : 36005]: t
  }),
  stencilFunc: (n, e, t, i) => n({
    2962: e,
    2967: t,
    2963: i,
    34816: e,
    36003: t,
    36004: i
  }),
  stencilFuncSeparate: (n, e, t, i, r) => n({
    [e === 1028 ? 2962 : 34816]: t,
    [e === 1028 ? 2967 : 36003]: i,
    [e === 1028 ? 2963 : 36004]: r
  }),
  stencilOp: (n, e, t, i) => n({
    2964: e,
    2965: t,
    2966: i,
    34817: e,
    34818: t,
    34819: i
  }),
  stencilOpSeparate: (n, e, t, i, r) => n({
    [e === 1028 ? 2964 : 34817]: t,
    [e === 1028 ? 2965 : 34818]: i,
    [e === 1028 ? 2966 : 34819]: r
  }),
  viewport: (n, e, t, i, r) => n({
    2978: [e, t, i, r]
  })
}, ic = (n, e) => n.isEnabled(e), V2 = {
  3042: ic,
  2884: ic,
  2929: ic,
  3024: ic,
  32823: ic,
  32926: ic,
  32928: ic,
  3089: ic,
  2960: ic,
  35977: ic
};
function j5(n) {
  for (const e in n)
    return !1;
  return !0;
}
function qM(n, e) {
  if (n === e)
    return !0;
  const t = Array.isArray(n) || ArrayBuffer.isView(n), i = Array.isArray(e) || ArrayBuffer.isView(e);
  if (t && i && n.length === e.length) {
    for (let r = 0; r < n.length; ++r)
      if (n[r] !== e[r])
        return !1;
    return !0;
  }
  return !1;
}
function q2(n, e) {
  const t = n[e].bind(n);
  n[e] = function() {
    const r = arguments.length <= 0 ? void 0 : arguments[0];
    return r in n.state.cache ? n.state.enable ? n.state.cache[r] : t(...arguments) : t(...arguments);
  }, Object.defineProperty(n[e], "name", {
    value: "".concat(e, "-from-cache"),
    configurable: !1
  });
}
function HM(n, e, t) {
  const i = n[e].bind(n);
  n[e] = function() {
    for (var s = arguments.length, c = new Array(s), l = 0; l < s; l++)
      c[l] = arguments[l];
    const {
      valueChanged: m,
      oldValue: y
    } = t(n.state._updateCache, ...c);
    return m && i(...c), y;
  }, Object.defineProperty(n[e], "name", {
    value: "".concat(e, "-to-cache"),
    configurable: !1
  });
}
function WM(n) {
  const e = n.useProgram.bind(n);
  n.useProgram = function(i) {
    n.state.program !== i && (e(i), n.state.program = i);
  };
}
class XM {
  constructor(e) {
    let {
      copyState: t = !1,
      log: i = () => {
      }
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.gl = e, this.program = null, this.stateStack = [], this.enable = !0, this.cache = t ? $M(e) : Object.assign({}, A1), this.log = i, this._updateCache = this._updateCache.bind(this), Object.seal(this);
  }
  push() {
    this.stateStack.push({});
  }
  pop() {
    go(this.stateStack.length > 0);
    const e = this.stateStack[this.stateStack.length - 1];
    eu(this.gl, e), this.stateStack.pop();
  }
  _updateCache(e) {
    let t = !1, i;
    const r = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];
    for (const s in e) {
      go(s !== void 0);
      const c = e[s], l = this.cache[s];
      qM(c, l) || (t = !0, i = l, r && !(s in r) && (r[s] = l), this.cache[s] = c);
    }
    return {
      valueChanged: t,
      oldValue: i
    };
  }
}
function G5(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    enable: t = !0,
    copyState: i
  } = e;
  if (go(i !== void 0), !n.state) {
    const {
      polyfillContext: r
    } = globalThis;
    r && r(n), n.state = new XM(n, {
      copyState: i
    }), WM(n);
    for (const s in G2) {
      const c = G2[s];
      HM(n, s, c);
    }
    q2(n, "getParameter"), q2(n, "isEnabled");
  }
  return n.state.enable = t, n;
}
function JM(n) {
  n.state || G5(n, {
    copyState: !1
  }), n.state.push();
}
function H2(n) {
  go(n.state), n.state.pop();
}
function eu(n, e) {
  if (go(Bm(n), "setParameters requires a WebGL context"), j5(e))
    return;
  const t = {};
  for (const r in e) {
    const s = Number(r), c = GM[r];
    c && (typeof c == "string" ? t[c] = !0 : c(n, e[r], s));
  }
  const i = n.state && n.state.cache;
  if (i)
    for (const r in t) {
      const s = VM[r];
      s(n, e, i);
    }
}
function $M(n, e) {
  if (e = e || A1, typeof e == "number") {
    const r = e, s = V2[r];
    return s ? s(n, r) : n.getParameter(r);
  }
  const t = Array.isArray(e) ? e : Object.keys(e), i = {};
  for (const r of t) {
    const s = V2[r];
    i[r] = s ? s(n, Number(r)) : n.getParameter(Number(r));
  }
  return i;
}
function ZM(n) {
  eu(n, A1);
}
function Cl(n, e, t) {
  if (j5(e))
    return t(n);
  const {
    nocatch: i = !0
  } = e;
  JM(n), eu(n, e);
  let r;
  if (i)
    r = t(n), H2(n);
  else
    try {
      r = t(n);
    } finally {
      H2(n);
    }
  return r;
}
function jd(n) {
  const {
    luma: e
  } = n;
  if (n.canvas && e) {
    const t = e.canvasSizeInfo, i = "clientWidth" in t ? t.clientWidth : n.canvas.clientWidth;
    return i ? n.drawingBufferWidth / i : 1;
  }
  return 1;
}
function J0(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  const i = jd(n), r = n.drawingBufferWidth, s = n.drawingBufferHeight;
  return KM(e, i, r, s, t);
}
function YM(n) {
  const e = typeof window > "u" ? 1 : window.devicePixelRatio || 1;
  return Number.isFinite(n) ? n <= 0 ? 1 : n : n ? e : 1;
}
function KM(n, e, t, i, r) {
  const s = W2(n[0], e, t);
  let c = X2(n[1], e, i, r), l = W2(n[0] + 1, e, t);
  const m = l === t - 1 ? l : l - 1;
  l = X2(n[1] + 1, e, i, r);
  let y;
  return r ? (l = l === 0 ? l : l + 1, y = c, c = l) : y = l === i - 1 ? l : l - 1, {
    x: s,
    y: c,
    width: Math.max(m - s + 1, 1),
    height: Math.max(y - c + 1, 1)
  };
}
function W2(n, e, t) {
  return Math.min(Math.round(n * e), t - 1);
}
function X2(n, e, t, i) {
  return i ? Math.max(0, t - 1 - Math.round(n * e)) : Math.min(Math.round(n * e), t - 1);
}
const E1 = iu(), QM = E1 && typeof document < "u", V5 = {
  webgl2: !0,
  webgl1: !0,
  throwOnError: !0,
  manageState: !0,
  canvas: null,
  debug: !1,
  width: 800,
  height: 600
};
function q5() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  go(E1, `createGLContext only available in the browser.
Create your own headless context or use 'createHeadlessContext' from @luma.gl/test-utils`), n = Object.assign({}, V5, n);
  const {
    width: e,
    height: t
  } = n;
  function i(l) {
    if (n.throwOnError)
      throw new Error(l);
    return console.error(l), null;
  }
  n.onError = i;
  let r;
  const {
    canvas: s
  } = n, c = i4({
    canvas: s,
    width: e,
    height: t,
    onError: i
  });
  return r = n4(c, n), r ? (r = S1(r, n), r4(r), r) : null;
}
function S1(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!n || n._instrumented)
    return n;
  n._version = n._version || s4(n), n.luma = n.luma || {}, n.luma.canvasSizeInfo = n.luma.canvasSizeInfo || {}, e = Object.assign({}, V5, e);
  const {
    manageState: t,
    debug: i
  } = e;
  return t && G5(n, {
    copyState: !1,
    log: function() {
      for (var r = arguments.length, s = new Array(r), c = 0; c < r; c++)
        s[c] = arguments[c];
      return cn.log(1, ...s)();
    }
  }), E1 && i && (globalThis.makeDebugContext ? (n = globalThis.makeDebugContext(n, e), cn.level = Math.max(cn.level, 1)) : cn.warn('WebGL debug mode not activated. import "@luma.gl/debug" to enable.')()), n._instrumented = !0, n;
}
function e4(n) {
  const e = n.getParameter(7936), t = n.getParameter(7937), i = n.getExtension("WEBGL_debug_renderer_info"), r = i && n.getParameter(i.UNMASKED_VENDOR_WEBGL || 7936), s = i && n.getParameter(i.UNMASKED_RENDERER_WEBGL || 7937);
  return {
    vendor: r || e,
    renderer: s || t,
    vendorMasked: e,
    rendererMasked: t,
    version: n.getParameter(7938),
    shadingLanguageVersion: n.getParameter(35724)
  };
}
function t4(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (n.canvas) {
    const i = YM(e.useDevicePixels);
    o4(n, i, e);
    return;
  }
  const t = n.getExtension("STACKGL_resize_drawingbuffer");
  t && "width" in e && "height" in e && t.resize(e.width, e.height);
}
function n4(n, e) {
  const {
    onError: t
  } = e;
  let i = null;
  const r = (m) => i = m.statusMessage || i;
  n.addEventListener("webglcontextcreationerror", r, !1);
  const {
    webgl1: s = !0,
    webgl2: c = !0
  } = e;
  let l = null;
  return c && (l = l || n.getContext("webgl2", e), l = l || n.getContext("experimental-webgl2", e)), s && (l = l || n.getContext("webgl", e), l = l || n.getContext("experimental-webgl", e)), n.removeEventListener("webglcontextcreationerror", r, !1), l ? (e.onContextLost && n.addEventListener("webglcontextlost", e.onContextLost, !1), e.onContextRestored && n.addEventListener("webglcontextrestored", e.onContextRestored, !1), l) : t("Failed to create ".concat(c && !s ? "WebGL2" : "WebGL", " context: ").concat(i || "Unknown error"));
}
function i4(n) {
  let {
    canvas: e,
    width: t = 800,
    height: i = 600,
    onError: r
  } = n, s;
  return typeof e == "string" ? (QM && document.readyState === "complete" || r("createGLContext called on canvas '".concat(e, "' before page was loaded")), s = document.getElementById(e)) : e ? s = e : (s = document.createElement("canvas"), s.id = "lumagl-canvas", s.style.width = Number.isFinite(t) ? "".concat(t, "px") : "100%", s.style.height = Number.isFinite(i) ? "".concat(i, "px") : "100%", document.body.insertBefore(s, document.body.firstChild)), s;
}
function r4(n) {
  const e = ei(n) ? "WebGL2" : "WebGL1", t = e4(n), i = t ? "(".concat(t.vendor, ",").concat(t.renderer, ")") : "", r = n.debug ? " debug" : "";
  cn.info(1, "".concat(e).concat(r, " context ").concat(i))();
}
function s4(n) {
  return typeof WebGL2RenderingContext < "u" && n instanceof WebGL2RenderingContext ? 2 : 1;
}
function o4(n, e, t) {
  let i = "width" in t ? t.width : n.canvas.clientWidth, r = "height" in t ? t.height : n.canvas.clientHeight;
  (!i || !r) && (cn.log(1, "Canvas clientWidth/clientHeight is 0")(), e = 1, i = n.canvas.width || 1, r = n.canvas.height || 1), n.luma = n.luma || {}, n.luma.canvasSizeInfo = n.luma.canvasSizeInfo || {};
  const s = n.luma.canvasSizeInfo;
  if (s.clientWidth !== i || s.clientHeight !== r || s.devicePixelRatio !== e) {
    let c = e;
    const l = Math.floor(i * c), m = Math.floor(r * c);
    n.canvas.width = l, n.canvas.height = m, (n.drawingBufferWidth !== l || n.drawingBufferHeight !== m) && (cn.warn("Device pixel ratio clamped")(), c = Math.min(n.drawingBufferWidth / i, n.drawingBufferHeight / r), n.canvas.width = Math.floor(i * c), n.canvas.height = Math.floor(r * c)), Object.assign(n.luma.canvasSizeInfo, {
      clientWidth: i,
      clientHeight: r,
      devicePixelRatio: e
    });
  }
}
const ip = "8.5.21", a4 = "set luma.log.level=1 (or higher) to trace rendering";
class l4 {
  constructor() {
    this.stats = /* @__PURE__ */ new Map();
  }
  get(e) {
    return this.stats.has(e) || this.stats.set(e, new Cp({
      id: e
    })), this.stats.get(e);
  }
}
const Ph = new l4();
if (globalThis.luma && globalThis.luma.VERSION !== ip)
  throw new Error("luma.gl - multiple VERSIONs detected: ".concat(globalThis.luma.VERSION, " vs ").concat(ip));
globalThis.luma || (iu() && cn.log(1, "luma.gl ".concat(ip, " - ").concat(a4))(), globalThis.luma = globalThis.luma || {
  VERSION: ip,
  version: ip,
  log: cn,
  stats: Ph,
  globals: {
    modules: {},
    nodeIO: {}
  }
});
function c4(n) {
  return typeof window < "u" && window.requestAnimationFrame ? window.requestAnimationFrame(n) : setTimeout(n, 1e3 / 60);
}
function u4(n) {
  return typeof window < "u" && window.cancelAnimationFrame ? window.cancelAnimationFrame(n) : clearTimeout(n);
}
function Yt(n, e) {
  if (!n)
    throw new Error(e || "luma.gl: assertion failed.");
}
function $0(n, e) {
  if (typeof e != "string")
    return e;
  const t = Number(e);
  if (!isNaN(t))
    return t;
  e = e.replace(/^.*\./, "");
  const i = n[e];
  return Yt(i !== void 0, "Accessing undefined constant GL.".concat(e)), i;
}
function Hu(n, e) {
  e = Number(e);
  for (const t in n)
    if (n[t] === e)
      return "GL.".concat(t);
  return String(e);
}
const Z0 = {};
function tu() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "id";
  Z0[n] = Z0[n] || 1;
  const e = Z0[n]++;
  return "".concat(n, "-").concat(e);
}
function J2(n) {
  return Yt(typeof n == "number", "Input must be a number"), n && (n & n - 1) === 0;
}
function Gd(n) {
  let e = !0;
  for (const t in n) {
    e = !1;
    break;
  }
  return e;
}
function H5(n, e, t, i) {
  const r = "See luma.gl ".concat(t, " Upgrade Guide at https://luma.gl/docs/upgrade-guide"), s = Object.getPrototypeOf(n);
  i.forEach((c) => {
    s.methodName || (s[c] = () => {
      throw cn.removed("Calling removed method ".concat(e, ".").concat(c, ": "), r)(), new Error(c);
    });
  });
}
const hd = "Resource subclass must define virtual methods";
let ru = class {
  get [Symbol.toStringTag]() {
    return "Resource";
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Rm(e);
    const {
      id: i,
      userData: r = {}
    } = t;
    this.gl = e, this.gl2 = e, this.id = i || tu(this[Symbol.toStringTag]), this.userData = r, this._bound = !1, this._handle = t.handle, this._handle === void 0 && (this._handle = this._createHandle()), this.byteLength = 0, this._addStats();
  }
  toString() {
    return "".concat(this[Symbol.toStringTag] || this.constructor.name, "(").concat(this.id, ")");
  }
  get handle() {
    return this._handle;
  }
  delete() {
    let {
      deleteChildren: e = !1
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = this._handle && this._deleteHandle(this._handle);
    return this._handle && this._removeStats(), this._handle = null, t && e && t.filter(Boolean).forEach((i) => i.delete()), this;
  }
  bind() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.handle;
    if (typeof e != "function")
      return this._bindHandle(e), this;
    let t;
    return this._bound ? t = e() : (this._bindHandle(this.handle), this._bound = !0, t = e(), this._bound = !1, this._bindHandle(null)), t;
  }
  unbind() {
    this.bind(null);
  }
  getParameter(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    e = $0(this.gl, e), Yt(e);
    const r = (this.constructor.PARAMETERS || {})[e];
    if (r) {
      const s = ei(this.gl);
      if (!((!("webgl2" in r) || s) && (!("extension" in r) || this.gl.getExtension(r.extension)))) {
        const l = r.webgl1, m = "webgl2" in r ? r.webgl2 : r.webgl1;
        return s ? m : l;
      }
    }
    return this._getParameter(e, t);
  }
  getParameters() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      parameters: t,
      keys: i
    } = e, r = this.constructor.PARAMETERS || {}, s = ei(this.gl), c = {}, l = t || Object.keys(r);
    for (const m of l) {
      const y = r[m];
      if (y && (!("webgl2" in y) || s) && (!("extension" in y) || this.gl.getExtension(y.extension))) {
        const T = i ? Hu(this.gl, m) : m;
        c[T] = this.getParameter(m, e), i && y.type === "GLenum" && (c[T] = Hu(this.gl, c[T]));
      }
    }
    return c;
  }
  setParameter(e, t) {
    e = $0(this.gl, e), Yt(e);
    const r = (this.constructor.PARAMETERS || {})[e];
    if (r) {
      const s = ei(this.gl);
      if (!((!("webgl2" in r) || s) && (!("extension" in r) || this.gl.getExtension(r.extension))))
        throw new Error("Parameter not available on this platform");
      r.type === "GLenum" && (t = $0(t));
    }
    return this._setParameter(e, t), this;
  }
  setParameters(e) {
    for (const t in e)
      this.setParameter(t, e[t]);
    return this;
  }
  stubRemovedMethods(e, t, i) {
    return H5(this, e, t, i);
  }
  initialize(e) {
  }
  _createHandle() {
    throw new Error(hd);
  }
  _deleteHandle() {
    throw new Error(hd);
  }
  _bindHandle(e) {
    throw new Error(hd);
  }
  _getOptsFromHandle() {
    throw new Error(hd);
  }
  _getParameter(e, t) {
    throw new Error(hd);
  }
  _setParameter(e, t) {
    throw new Error(hd);
  }
  _context() {
    return this.gl.luma = this.gl.luma || {}, this.gl.luma;
  }
  _addStats() {
    const e = this[Symbol.toStringTag], t = Ph.get("Resource Counts");
    t.get("Resources Created").incrementCount(), t.get("".concat(e, "s Created")).incrementCount(), t.get("".concat(e, "s Active")).incrementCount();
  }
  _removeStats() {
    const e = this[Symbol.toStringTag];
    Ph.get("Resource Counts").get("".concat(e, "s Active")).decrementCount();
  }
  _trackAllocatedMemory(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this[Symbol.toStringTag];
    this._trackAllocatedMemoryForContext(e, t), this._trackAllocatedMemoryForContext(e, t, this.gl.canvas && this.gl.canvas.id), this.byteLength = e;
  }
  _trackAllocatedMemoryForContext(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this[Symbol.toStringTag], i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
    const r = Ph.get("Memory Usage".concat(i));
    r.get("GPU Memory").addCount(e), r.get("".concat(t, " Memory")).addCount(e);
  }
  _trackDeallocatedMemory() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this[Symbol.toStringTag];
    this._trackDeallocatedMemoryForContext(e), this._trackDeallocatedMemoryForContext(e, this.gl.canvas && this.gl.canvas.id), this.byteLength = 0;
  }
  _trackDeallocatedMemoryForContext() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this[Symbol.toStringTag], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const i = Ph.get("Memory Usage".concat(t));
    i.get("GPU Memory").subtractCount(this.byteLength), i.get("".concat(e, " Memory")).subtractCount(this.byteLength);
  }
};
const h4 = "Failed to deduce GL constant from typed array";
function ly(n) {
  switch (ArrayBuffer.isView(n) ? n.constructor : n) {
    case Float32Array:
      return 5126;
    case Uint16Array:
      return 5123;
    case Uint32Array:
      return 5125;
    case Uint8Array:
      return 5121;
    case Uint8ClampedArray:
      return 5121;
    case Int8Array:
      return 5120;
    case Int16Array:
      return 5122;
    case Int32Array:
      return 5124;
    default:
      throw new Error(h4);
  }
}
function hp(n) {
  let {
    clamped: e = !0
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  switch (n) {
    case 5126:
      return Float32Array;
    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;
    case 5125:
      return Uint32Array;
    case 5121:
      return e ? Uint8ClampedArray : Uint8Array;
    case 5120:
      return Int8Array;
    case 5122:
      return Int16Array;
    case 5124:
      return Int32Array;
    default:
      throw new Error("Failed to deduce typed array type from GL constant");
  }
}
function d4(n) {
  let {
    data: e,
    width: t,
    height: i,
    bytesPerPixel: r = 4,
    temp: s
  } = n;
  const c = t * r;
  s = s || new Uint8Array(c);
  for (let l = 0; l < i / 2; ++l) {
    const m = l * c, y = (i - l - 1) * c;
    s.set(e.subarray(m, m + c)), e.copyWithin(m, y, y + c), e.set(s, y);
  }
}
function f4(n) {
  let {
    data: e,
    width: t,
    height: i
  } = n;
  const r = Math.round(t / 2), s = Math.round(i / 2), c = new Uint8Array(r * s * 4);
  for (let l = 0; l < s; l++)
    for (let m = 0; m < r; m++)
      for (let y = 0; y < 4; y++)
        c[(l * r + m) * 4 + y] = e[(l * 2 * t + m * 2) * 4 + y];
  return {
    data: c,
    width: r,
    height: s
  };
}
function cy(n, e, t) {
  const {
    removedProps: i = {},
    deprecatedProps: r = {},
    replacedProps: s = {}
  } = t;
  for (const l in i)
    if (l in e) {
      const y = i[l] ? "".concat(n, ".").concat(i[l]) : "N/A";
      cn.removed("".concat(n, ".").concat(l), y)();
    }
  for (const l in r)
    if (l in e) {
      const m = r[l];
      cn.deprecated("".concat(n, ".").concat(l), "".concat(n, ".").concat(m))();
    }
  let c = null;
  for (const l in s)
    if (l in e) {
      const m = s[l];
      cn.deprecated("".concat(n, ".").concat(l), "".concat(n, ".").concat(m))(), c = c || Object.assign({}, e), c[m] = e[l], delete c[l];
    }
  return c || e;
}
const p4 = {
  offset: 0,
  stride: 0,
  type: 5126,
  size: 1,
  divisor: 0,
  normalized: !1,
  integer: !1
}, g4 = {
  deprecatedProps: {
    instanced: "divisor",
    isInstanced: "divisor"
  }
};
class Ro {
  static getBytesPerElement(e) {
    return hp(e.type || 5126).BYTES_PER_ELEMENT;
  }
  static getBytesPerVertex(e) {
    return Yt(e.size), hp(e.type || 5126).BYTES_PER_ELEMENT * e.size;
  }
  static resolve() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return new Ro(p4, ...t);
  }
  constructor() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    t.forEach((r) => this._assign(r)), Object.freeze(this);
  }
  toString() {
    return JSON.stringify(this);
  }
  get BYTES_PER_ELEMENT() {
    return Ro.getBytesPerElement(this);
  }
  get BYTES_PER_VERTEX() {
    return Ro.getBytesPerVertex(this);
  }
  _assign() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return e = cy("Accessor", e, g4), e.type !== void 0 && (this.type = e.type, (e.type === 5124 || e.type === 5125) && (this.integer = !0)), e.size !== void 0 && (this.size = e.size), e.offset !== void 0 && (this.offset = e.offset), e.stride !== void 0 && (this.stride = e.stride), e.normalized !== void 0 && (this.normalized = e.normalized), e.integer !== void 0 && (this.integer = e.integer), e.divisor !== void 0 && (this.divisor = e.divisor), e.buffer !== void 0 && (this.buffer = e.buffer), e.index !== void 0 && (typeof e.index == "boolean" ? this.index = e.index ? 1 : 0 : this.index = e.index), e.instanced !== void 0 && (this.divisor = e.instanced ? 1 : 0), e.isInstanced !== void 0 && (this.divisor = e.isInstanced ? 1 : 0), this;
  }
}
const $2 = 10, W5 = {
  offset: "accessor.offset",
  stride: "accessor.stride",
  type: "accessor.type",
  size: "accessor.size",
  divisor: "accessor.divisor",
  normalized: "accessor.normalized",
  integer: "accessor.integer",
  instanced: "accessor.divisor",
  isInstanced: "accessor.divisor"
}, m4 = {
  removedProps: {},
  replacedProps: {
    bytes: "byteLength"
  },
  deprecatedProps: W5
}, _4 = {
  removedProps: W5
};
let Hi = class extends ru {
  get [Symbol.toStringTag]() {
    return "Buffer";
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(e, t), this.stubRemovedMethods("Buffer", "v6.0", ["layout", "setLayout", "getIndexedParameter"]), this.target = t.target || (this.gl.webgl2 ? 36662 : 34962), this.initialize(t), Object.seal(this);
  }
  getElementCount() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.accessor;
    return Math.round(this.byteLength / Ro.getBytesPerElement(e));
  }
  getVertexCount() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.accessor;
    return Math.round(this.byteLength / Ro.getBytesPerVertex(e));
  }
  initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return ArrayBuffer.isView(e) && (e = {
      data: e
    }), Number.isFinite(e) && (e = {
      byteLength: e
    }), e = cy("Buffer", e, m4), this.usage = e.usage || 35044, this.debugData = null, this.setAccessor(Object.assign({}, e, e.accessor)), e.data ? this._setData(e.data, e.offset, e.byteLength) : this._setByteLength(e.byteLength || 0), this;
  }
  setProps(e) {
    return e = cy("Buffer", e, _4), "accessor" in e && this.setAccessor(e.accessor), this;
  }
  setAccessor(e) {
    return e = Object.assign({}, e), delete e.buffer, this.accessor = new Ro(e), this;
  }
  reallocate(e) {
    return e > this.byteLength ? (this._setByteLength(e), !0) : (this.bytesUsed = e, !1);
  }
  setData(e) {
    return this.initialize(e);
  }
  subData(e) {
    ArrayBuffer.isView(e) && (e = {
      data: e
    });
    const {
      data: t,
      offset: i = 0,
      srcOffset: r = 0
    } = e, s = e.byteLength || e.length;
    Yt(t);
    const c = this.gl.webgl2 ? 36663 : this.target;
    return this.gl.bindBuffer(c, this.handle), r !== 0 || s !== void 0 ? (mo(this.gl), this.gl.bufferSubData(this.target, i, t, r, s)) : this.gl.bufferSubData(c, i, t), this.gl.bindBuffer(c, null), this.debugData = null, this._inferType(t), this;
  }
  copyData(e) {
    let {
      sourceBuffer: t,
      readOffset: i = 0,
      writeOffset: r = 0,
      size: s
    } = e;
    const {
      gl: c
    } = this;
    return mo(c), c.bindBuffer(36662, t.handle), c.bindBuffer(36663, this.handle), c.copyBufferSubData(36662, 36663, i, r, s), c.bindBuffer(36662, null), c.bindBuffer(36663, null), this.debugData = null, this;
  }
  getData() {
    let {
      dstData: e = null,
      srcByteOffset: t = 0,
      dstOffset: i = 0,
      length: r = 0
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    mo(this.gl);
    const s = hp(this.accessor.type || 5126, {
      clamped: !1
    }), c = this._getAvailableElementCount(t), l = i;
    let m, y;
    e ? (y = e.length, m = y - l) : (m = Math.min(c, r || c), y = l + m);
    const A = Math.min(c, m);
    return r = r || A, Yt(r <= A), e = e || new s(y), this.gl.bindBuffer(36662, this.handle), this.gl.getBufferSubData(36662, t, e, i, r), this.gl.bindBuffer(36662, null), e;
  }
  bind() {
    let {
      target: e = this.target,
      index: t = this.accessor && this.accessor.index,
      offset: i = 0,
      size: r
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return e === 35345 || e === 35982 ? r !== void 0 ? this.gl.bindBufferRange(e, t, this.handle, i, r) : (Yt(i === 0), this.gl.bindBufferBase(e, t, this.handle)) : this.gl.bindBuffer(e, this.handle), this;
  }
  unbind() {
    let {
      target: e = this.target,
      index: t = this.accessor && this.accessor.index
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return e === 35345 || e === 35982 ? this.gl.bindBufferBase(e, t, null) : this.gl.bindBuffer(e, null), this;
  }
  getDebugData() {
    return this.debugData ? {
      data: this.debugData,
      changed: !1
    } : (this.debugData = this.getData({
      length: Math.min($2, this.byteLength)
    }), {
      data: this.debugData,
      changed: !0
    });
  }
  invalidateDebugData() {
    this.debugData = null;
  }
  _setData(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : e.byteLength + t;
    Yt(ArrayBuffer.isView(e)), this._trackDeallocatedMemory();
    const r = this._getTarget();
    this.gl.bindBuffer(r, this.handle), this.gl.bufferData(r, i, this.usage), this.gl.bufferSubData(r, t, e), this.gl.bindBuffer(r, null), this.debugData = e.slice(0, $2), this.bytesUsed = i, this._trackAllocatedMemory(i);
    const s = ly(e);
    return Yt(s), this.setAccessor(new Ro(this.accessor, {
      type: s
    })), this;
  }
  _setByteLength(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.usage;
    Yt(e >= 0), this._trackDeallocatedMemory();
    let i = e;
    e === 0 && (i = new Float32Array(0));
    const r = this._getTarget();
    return this.gl.bindBuffer(r, this.handle), this.gl.bufferData(r, i, t), this.gl.bindBuffer(r, null), this.usage = t, this.debugData = null, this.bytesUsed = e, this._trackAllocatedMemory(e), this;
  }
  _getTarget() {
    return this.gl.webgl2 ? 36663 : this.target;
  }
  _getAvailableElementCount(e) {
    const t = hp(this.accessor.type || 5126, {
      clamped: !1
    }), i = e / t.BYTES_PER_ELEMENT;
    return this.getElementCount() - i;
  }
  _inferType(e) {
    this.accessor.type || this.setAccessor(new Ro(this.accessor, {
      type: ly(e)
    }));
  }
  _createHandle() {
    return this.gl.createBuffer();
  }
  _deleteHandle() {
    this.gl.deleteBuffer(this.handle), this._trackDeallocatedMemory();
  }
  _getParameter(e) {
    this.gl.bindBuffer(this.target, this.handle);
    const t = this.gl.getBufferParameter(this.target, e);
    return this.gl.bindBuffer(this.target, null), t;
  }
  get type() {
    return cn.deprecated("Buffer.type", "Buffer.accessor.type")(), this.accessor.type;
  }
  get bytes() {
    return cn.deprecated("Buffer.bytes", "Buffer.byteLength")(), this.byteLength;
  }
  setByteLength(e) {
    return cn.deprecated("setByteLength", "reallocate")(), this.reallocate(e);
  }
  updateAccessor(e) {
    return cn.deprecated("updateAccessor(...)", "setAccessor(new Accessor(buffer.accessor, ...)")(), this.accessor = new Ro(this.accessor, e), this;
  }
};
const T1 = {
  6407: {
    dataFormat: 6407,
    types: [5121, 33635]
  },
  6408: {
    dataFormat: 6408,
    types: [5121, 32819, 32820]
  },
  6406: {
    dataFormat: 6406,
    types: [5121]
  },
  6409: {
    dataFormat: 6409,
    types: [5121]
  },
  6410: {
    dataFormat: 6410,
    types: [5121]
  },
  33326: {
    dataFormat: 6403,
    types: [5126],
    gl2: !0
  },
  33328: {
    dataFormat: 33319,
    types: [5126],
    gl2: !0
  },
  34837: {
    dataFormat: 6407,
    types: [5126],
    gl2: !0
  },
  34836: {
    dataFormat: 6408,
    types: [5126],
    gl2: !0
  }
}, X5 = {
  6403: 1,
  36244: 1,
  33319: 2,
  33320: 2,
  6407: 3,
  36248: 3,
  6408: 4,
  36249: 4,
  6402: 1,
  34041: 1,
  6406: 1,
  6409: 1,
  6410: 2
}, J5 = {
  5126: 4,
  5125: 4,
  5124: 4,
  5123: 2,
  5122: 2,
  5131: 2,
  5120: 1,
  5121: 1
};
function y4(n, e) {
  const t = T1[e];
  if (!t)
    return !1;
  if (t.gl1 === void 0 && t.gl2 === void 0)
    return !0;
  const i = ei(n) && t.gl2 || t.gl1;
  return typeof i == "string" ? n.getExtension(i) : i;
}
function v4(n, e) {
  const t = T1[e];
  switch (t && t.types[0]) {
    case 5126:
      return n.getExtension("OES_texture_float_linear");
    case 5131:
      return n.getExtension("OES_texture_half_float_linear");
    default:
      return !0;
  }
}
const b4 = [9729, 9728], Z2 = globalThis.WebGLBuffer || function() {
};
class Vd extends ru {
  get [Symbol.toStringTag]() {
    return "Texture";
  }
  static isSupported(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      format: i,
      linearFiltering: r
    } = t;
    let s = !0;
    return i && (s = s && y4(e, i), s = s && (!r || v4(e, i))), s;
  }
  constructor(e, t) {
    const {
      id: i = tu("texture"),
      handle: r,
      target: s
    } = t;
    super(e, {
      id: i,
      handle: r
    }), this.target = s, this.textureUnit = void 0, this.loaded = !1, this.width = void 0, this.height = void 0, this.depth = void 0, this.format = void 0, this.type = void 0, this.dataFormat = void 0, this.border = void 0, this.textureUnit = void 0, this.mipmaps = void 0;
  }
  toString() {
    return "Texture(".concat(this.id, ",").concat(this.width, "x").concat(this.height, ")");
  }
  initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = e.data;
    if (t instanceof Promise)
      return t.then((J) => this.initialize(Object.assign({}, e, {
        pixels: J,
        data: J
      }))), this;
    const i = typeof HTMLVideoElement < "u" && t instanceof HTMLVideoElement;
    if (i && t.readyState < HTMLVideoElement.HAVE_METADATA)
      return this._video = null, t.addEventListener("loadeddata", () => this.initialize(e)), this;
    const {
      pixels: r = null,
      format: s = 6408,
      border: c = 0,
      recreate: l = !1,
      parameters: m = {},
      pixelStore: y = {},
      textureUnit: A = void 0
    } = e;
    t || (t = r);
    let {
      width: T,
      height: I,
      dataFormat: L,
      type: N,
      compressed: z = !1,
      mipmaps: V = !0
    } = e;
    const {
      depth: H = 0
    } = e;
    return {
      width: T,
      height: I,
      compressed: z,
      dataFormat: L,
      type: N
    } = this._deduceParameters({
      format: s,
      type: N,
      dataFormat: L,
      compressed: z,
      data: t,
      width: T,
      height: I
    }), this.width = T, this.height = I, this.depth = H, this.format = s, this.type = N, this.dataFormat = L, this.border = c, this.textureUnit = A, Number.isFinite(this.textureUnit) && (this.gl.activeTexture(33984 + this.textureUnit), this.gl.bindTexture(this.target, this.handle)), V && this._isNPOT() && (cn.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))(), V = !1, this._updateForNPOT(m)), this.mipmaps = V, this.setImageData({
      data: t,
      width: T,
      height: I,
      depth: H,
      format: s,
      type: N,
      dataFormat: L,
      border: c,
      mipmaps: V,
      parameters: y,
      compressed: z
    }), V && this.generateMipmap(), this.setParameters(m), l && (this.data = t), i && (this._video = {
      video: t,
      parameters: m,
      lastTime: t.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? t.currentTime : -1
    }), this;
  }
  update() {
    if (this._video) {
      const {
        video: e,
        parameters: t,
        lastTime: i
      } = this._video;
      if (i === e.currentTime || e.readyState < HTMLVideoElement.HAVE_CURRENT_DATA)
        return;
      this.setSubImageData({
        data: e,
        parameters: t
      }), this.mipmaps && this.generateMipmap(), this._video.lastTime = e.currentTime;
    }
  }
  resize(e) {
    let {
      height: t,
      width: i,
      mipmaps: r = !1
    } = e;
    return i !== this.width || t !== this.height ? this.initialize({
      width: i,
      height: t,
      format: this.format,
      type: this.type,
      dataFormat: this.dataFormat,
      border: this.border,
      mipmaps: r
    }) : this;
  }
  generateMipmap() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this._isNPOT() ? (cn.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))(), this) : (this.mipmaps = !0, this.gl.bindTexture(this.target, this.handle), Cl(this.gl, e, () => {
      this.gl.generateMipmap(this.target);
    }), this.gl.bindTexture(this.target, null), this);
  }
  setImageData(e) {
    this._trackDeallocatedMemory("Texture");
    const {
      target: t = this.target,
      pixels: i = null,
      level: r = 0,
      format: s = this.format,
      border: c = this.border,
      offset: l = 0,
      parameters: m = {}
    } = e;
    let {
      data: y = null,
      type: A = this.type,
      width: T = this.width,
      height: I = this.height,
      dataFormat: L = this.dataFormat,
      compressed: N = !1
    } = e;
    y || (y = i), {
      type: A,
      dataFormat: L,
      compressed: N,
      width: T,
      height: I
    } = this._deduceParameters({
      format: s,
      type: A,
      dataFormat: L,
      compressed: N,
      data: y,
      width: T,
      height: I
    });
    const {
      gl: z
    } = this;
    z.bindTexture(this.target, this.handle);
    let V = null;
    ({
      data: y,
      dataType: V
    } = this._getDataType({
      data: y,
      compressed: N
    }));
    let H, J = 0;
    if (Cl(this.gl, m, () => {
      switch (V) {
        case "null":
          z.texImage2D(t, r, s, T, I, c, L, A, y);
          break;
        case "typed-array":
          z.texImage2D(t, r, s, T, I, c, L, A, y, l);
          break;
        case "buffer":
          H = mo(z), H.bindBuffer(35052, y.handle || y), H.texImage2D(t, r, s, T, I, c, L, A, l), H.bindBuffer(35052, null);
          break;
        case "browser-object":
          ei(z) ? z.texImage2D(t, r, s, T, I, c, L, A, y) : z.texImage2D(t, r, s, L, A, y);
          break;
        case "compressed":
          for (const [ce, me] of y.entries())
            z.compressedTexImage2D(t, ce, me.format, me.width, me.height, c, me.data), J += me.levelSize;
          break;
        default:
          Yt(!1, "Unknown image data type");
      }
    }), V === "compressed")
      this._trackAllocatedMemory(J, "Texture");
    else if (y && y.byteLength)
      this._trackAllocatedMemory(y.byteLength, "Texture");
    else {
      const ce = X5[this.dataFormat] || 4, me = J5[this.type] || 1;
      this._trackAllocatedMemory(this.width * this.height * ce * me, "Texture");
    }
    return this.loaded = !0, this;
  }
  setSubImageData(e) {
    let {
      target: t = this.target,
      pixels: i = null,
      data: r = null,
      x: s = 0,
      y: c = 0,
      width: l = this.width,
      height: m = this.height,
      level: y = 0,
      format: A = this.format,
      type: T = this.type,
      dataFormat: I = this.dataFormat,
      compressed: L = !1,
      offset: N = 0,
      border: z = this.border,
      parameters: V = {}
    } = e;
    if ({
      type: T,
      dataFormat: I,
      compressed: L,
      width: l,
      height: m
    } = this._deduceParameters({
      format: A,
      type: T,
      dataFormat: I,
      compressed: L,
      data: r,
      width: l,
      height: m
    }), Yt(this.depth === 0, "texSubImage not supported for 3D textures"), r || (r = i), r && r.data) {
      const H = r;
      r = H.data, l = H.shape[0], m = H.shape[1];
    }
    r instanceof Hi && (r = r.handle), this.gl.bindTexture(this.target, this.handle), Cl(this.gl, V, () => {
      if (L)
        this.gl.compressedTexSubImage2D(t, y, s, c, l, m, A, r);
      else if (r === null)
        this.gl.texSubImage2D(t, y, s, c, l, m, I, T, null);
      else if (ArrayBuffer.isView(r))
        this.gl.texSubImage2D(t, y, s, c, l, m, I, T, r, N);
      else if (r instanceof Z2) {
        const H = mo(this.gl);
        H.bindBuffer(35052, r), H.texSubImage2D(t, y, s, c, l, m, I, T, N), H.bindBuffer(35052, null);
      } else
        ei(this.gl) ? mo(this.gl).texSubImage2D(t, y, s, c, l, m, I, T, r) : this.gl.texSubImage2D(t, y, s, c, I, T, r);
    }), this.gl.bindTexture(this.target, null);
  }
  copyFramebuffer() {
    return cn.error("Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})")(), null;
  }
  getActiveUnit() {
    return this.gl.getParameter(34016) - 33984;
  }
  bind() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.textureUnit;
    const {
      gl: t
    } = this;
    return e !== void 0 && (this.textureUnit = e, t.activeTexture(33984 + e)), t.bindTexture(this.target, this.handle), e;
  }
  unbind() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.textureUnit;
    const {
      gl: t
    } = this;
    return e !== void 0 && (this.textureUnit = e, t.activeTexture(33984 + e)), t.bindTexture(this.target, null), e;
  }
  _getDataType(e) {
    let {
      data: t,
      compressed: i = !1
    } = e;
    return i ? {
      data: t,
      dataType: "compressed"
    } : t === null ? {
      data: t,
      dataType: "null"
    } : ArrayBuffer.isView(t) ? {
      data: t,
      dataType: "typed-array"
    } : t instanceof Hi ? {
      data: t.handle,
      dataType: "buffer"
    } : t instanceof Z2 ? {
      data: t,
      dataType: "buffer"
    } : {
      data: t,
      dataType: "browser-object"
    };
  }
  _deduceParameters(e) {
    const {
      format: t,
      data: i
    } = e;
    let {
      width: r,
      height: s,
      dataFormat: c,
      type: l,
      compressed: m
    } = e;
    const y = T1[t];
    return c = c || y && y.dataFormat, l = l || y && y.types[0], m = m || y && y.compressed, {
      width: r,
      height: s
    } = this._deduceImageSize(i, r, s), {
      dataFormat: c,
      type: l,
      compressed: m,
      width: r,
      height: s,
      format: t,
      data: i
    };
  }
  _deduceImageSize(e, t, i) {
    let r;
    return typeof ImageData < "u" && e instanceof ImageData ? r = {
      width: e.width,
      height: e.height
    } : typeof HTMLImageElement < "u" && e instanceof HTMLImageElement ? r = {
      width: e.naturalWidth,
      height: e.naturalHeight
    } : typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement ? r = {
      width: e.width,
      height: e.height
    } : typeof ImageBitmap < "u" && e instanceof ImageBitmap ? r = {
      width: e.width,
      height: e.height
    } : typeof HTMLVideoElement < "u" && e instanceof HTMLVideoElement ? r = {
      width: e.videoWidth,
      height: e.videoHeight
    } : e ? r = {
      width: t,
      height: i
    } : r = {
      width: t >= 0 ? t : 1,
      height: i >= 0 ? i : 1
    }, Yt(r, "Could not deduced texture size"), Yt(t === void 0 || r.width === t, "Deduced texture width does not match supplied width"), Yt(i === void 0 || r.height === i, "Deduced texture height does not match supplied height"), r;
  }
  _createHandle() {
    return this.gl.createTexture();
  }
  _deleteHandle() {
    this.gl.deleteTexture(this.handle), this._trackDeallocatedMemory("Texture");
  }
  _getParameter(e) {
    switch (e) {
      case 4096:
        return this.width;
      case 4097:
        return this.height;
      default:
        this.gl.bindTexture(this.target, this.handle);
        const t = this.gl.getTexParameter(this.target, e);
        return this.gl.bindTexture(this.target, null), t;
    }
  }
  _setParameter(e, t) {
    switch (this.gl.bindTexture(this.target, this.handle), t = this._getNPOTParam(e, t), e) {
      case 33082:
      case 33083:
        this.gl.texParameterf(this.handle, e, t);
        break;
      case 4096:
      case 4097:
        Yt(!1);
        break;
      default:
        this.gl.texParameteri(this.target, e, t);
        break;
    }
    return this.gl.bindTexture(this.target, null), this;
  }
  _isNPOT() {
    return ei(this.gl) || !this.width || !this.height ? !1 : !J2(this.width) || !J2(this.height);
  }
  _updateForNPOT(e) {
    e[this.gl.TEXTURE_MIN_FILTER] === void 0 && (e[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR), e[this.gl.TEXTURE_WRAP_S] === void 0 && (e[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE), e[this.gl.TEXTURE_WRAP_T] === void 0 && (e[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE);
  }
  _getNPOTParam(e, t) {
    if (this._isNPOT())
      switch (e) {
        case 10241:
          b4.indexOf(t) === -1 && (t = 9729);
          break;
        case 10242:
        case 10243:
          t !== 33071 && (t = 33071);
          break;
      }
    return t;
  }
}
let x4 = "";
function w4(n, e) {
  return Yt(typeof n == "string"), n = x4 + n, new Promise((t, i) => {
    try {
      const r = new Image();
      r.onload = () => t(r), r.onerror = () => i(new Error("Could not load image ".concat(n, "."))), r.crossOrigin = e && e.crossOrigin || "anonymous", r.src = n;
    } catch (r) {
      i(r);
    }
  });
}
class ga extends Vd {
  get [Symbol.toStringTag]() {
    return "Texture2D";
  }
  static isSupported(e, t) {
    return Vd.isSupported(e, t);
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Rm(e), (t instanceof Promise || typeof t == "string") && (t = {
      data: t
    }), typeof t.data == "string" && (t = Object.assign({}, t, {
      data: w4(t.data)
    })), super(e, Object.assign({}, t, {
      target: 3553
    })), this.initialize(t), Object.seal(this);
  }
}
const uy = [34069, 34070, 34071, 34072, 34073, 34074];
class $5 extends Vd {
  get [Symbol.toStringTag]() {
    return "TextureCube";
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Rm(e), super(e, Object.assign({}, t, {
      target: 34067
    })), this.initialize(t), Object.seal(this);
  }
  initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      mipmaps: t = !0,
      parameters: i = {}
    } = e;
    return this.opts = e, this.setCubeMapImageData(e).then(() => {
      this.loaded = !0, t && this.generateMipmap(e), this.setParameters(i);
    }), this;
  }
  subImage(e) {
    let {
      face: t,
      data: i,
      x: r = 0,
      y: s = 0,
      mipmapLevel: c = 0
    } = e;
    return this._subImage({
      target: t,
      data: i,
      x: r,
      y: s,
      mipmapLevel: c
    });
  }
  async setCubeMapImageData(e) {
    let {
      width: t,
      height: i,
      pixels: r,
      data: s,
      border: c = 0,
      format: l = 6408,
      type: m = 5121
    } = e;
    const {
      gl: y
    } = this, A = r || s, T = await Promise.all(uy.map((I) => {
      const L = A[I];
      return Promise.all(Array.isArray(L) ? L : [L]);
    }));
    this.bind(), uy.forEach((I, L) => {
      T[L].length > 1 && this.opts.mipmaps !== !1 && cn.warn("".concat(this.id, " has mipmap and multiple LODs."))(), T[L].forEach((N, z) => {
        t && i ? y.texImage2D(I, z, l, t, i, c, l, m, N) : y.texImage2D(I, z, l, l, m, N);
      });
    }), this.unbind();
  }
  setImageDataForFace(e) {
    const {
      face: t,
      width: i,
      height: r,
      pixels: s,
      data: c,
      border: l = 0,
      format: m = 6408,
      type: y = 5121
    } = e, {
      gl: A
    } = this, T = s || c;
    return this.bind(), T instanceof Promise ? T.then((I) => this.setImageDataForFace(Object.assign({}, e, {
      face: t,
      data: I,
      pixels: I
    }))) : this.width || this.height ? A.texImage2D(t, 0, m, i, r, l, m, y, T) : A.texImage2D(t, 0, m, m, y, T), this;
  }
}
$5.FACES = uy;
class A4 extends Vd {
  get [Symbol.toStringTag]() {
    return "Texture3D";
  }
  static isSupported(e) {
    return ei(e);
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    mo(e), t = Object.assign({
      depth: 1
    }, t, {
      target: 32879,
      unpackFlipY: !1
    }), super(e, t), this.initialize(t), Object.seal(this);
  }
  setImageData(e) {
    let {
      level: t = 0,
      dataFormat: i = 6408,
      width: r,
      height: s,
      depth: c = 1,
      border: l = 0,
      format: m,
      type: y = 5121,
      offset: A = 0,
      data: T,
      parameters: I = {}
    } = e;
    if (this._trackDeallocatedMemory("Texture"), this.gl.bindTexture(this.target, this.handle), Cl(this.gl, I, () => {
      ArrayBuffer.isView(T) && this.gl.texImage3D(this.target, t, i, r, s, c, l, m, y, T), T instanceof Hi && (this.gl.bindBuffer(35052, T.handle), this.gl.texImage3D(this.target, t, i, r, s, c, l, m, y, A));
    }), T && T.byteLength)
      this._trackAllocatedMemory(T.byteLength, "Texture");
    else {
      const L = X5[this.dataFormat] || 4, N = J5[this.type] || 1;
      this._trackAllocatedMemory(this.width * this.height * this.depth * L * N, "Texture");
    }
    return this.loaded = !0, this;
  }
}
const vh = "EXT_color_buffer_float", Y2 = {
  33189: {
    bpp: 2
  },
  33190: {
    gl2: !0,
    bpp: 3
  },
  36012: {
    gl2: !0,
    bpp: 4
  },
  36168: {
    bpp: 1
  },
  34041: {
    bpp: 4
  },
  35056: {
    gl2: !0,
    bpp: 4
  },
  36013: {
    gl2: !0,
    bpp: 5
  },
  32854: {
    bpp: 2
  },
  36194: {
    bpp: 2
  },
  32855: {
    bpp: 2
  },
  33321: {
    gl2: !0,
    bpp: 1
  },
  33330: {
    gl2: !0,
    bpp: 1
  },
  33329: {
    gl2: !0,
    bpp: 1
  },
  33332: {
    gl2: !0,
    bpp: 2
  },
  33331: {
    gl2: !0,
    bpp: 2
  },
  33334: {
    gl2: !0,
    bpp: 4
  },
  33333: {
    gl2: !0,
    bpp: 4
  },
  33323: {
    gl2: !0,
    bpp: 2
  },
  33336: {
    gl2: !0,
    bpp: 2
  },
  33335: {
    gl2: !0,
    bpp: 2
  },
  33338: {
    gl2: !0,
    bpp: 4
  },
  33337: {
    gl2: !0,
    bpp: 4
  },
  33340: {
    gl2: !0,
    bpp: 8
  },
  33339: {
    gl2: !0,
    bpp: 8
  },
  32849: {
    gl2: !0,
    bpp: 3
  },
  32856: {
    gl2: !0,
    bpp: 4
  },
  32857: {
    gl2: !0,
    bpp: 4
  },
  36220: {
    gl2: !0,
    bpp: 4
  },
  36238: {
    gl2: !0,
    bpp: 4
  },
  36975: {
    gl2: !0,
    bpp: 4
  },
  36214: {
    gl2: !0,
    bpp: 8
  },
  36232: {
    gl2: !0,
    bpp: 8
  },
  36226: {
    gl2: !0,
    bpp: 16
  },
  36208: {
    gl2: !0,
    bpp: 16
  },
  33325: {
    gl2: vh,
    bpp: 2
  },
  33327: {
    gl2: vh,
    bpp: 4
  },
  34842: {
    gl2: vh,
    bpp: 8
  },
  33326: {
    gl2: vh,
    bpp: 4
  },
  33328: {
    gl2: vh,
    bpp: 8
  },
  34836: {
    gl2: vh,
    bpp: 16
  },
  35898: {
    gl2: vh,
    bpp: 4
  }
};
function E4(n, e, t) {
  const i = t[e];
  if (!i)
    return !1;
  const r = ei(n) && i.gl2 || i.gl1;
  return typeof r == "string" ? n.getExtension(r) : r;
}
class Sd extends ru {
  get [Symbol.toStringTag]() {
    return "Renderbuffer";
  }
  static isSupported(e) {
    let {
      format: t
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      format: null
    };
    return !t || E4(e, t, Y2);
  }
  static getSamplesForFormat(e, t) {
    let {
      format: i
    } = t;
    return e.getInternalformatParameter(36161, i, 32937);
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(e, t), this.initialize(t), Object.seal(this);
  }
  initialize(e) {
    let {
      format: t,
      width: i = 1,
      height: r = 1,
      samples: s = 0
    } = e;
    return Yt(t, "Needs format"), this._trackDeallocatedMemory(), this.gl.bindRenderbuffer(36161, this.handle), s !== 0 && ei(this.gl) ? this.gl.renderbufferStorageMultisample(36161, s, t, i, r) : this.gl.renderbufferStorage(36161, t, i, r), this.format = t, this.width = i, this.height = r, this.samples = s, this._trackAllocatedMemory(this.width * this.height * (this.samples || 1) * Y2[this.format].bpp), this;
  }
  resize(e) {
    let {
      width: t,
      height: i
    } = e;
    return t !== this.width || i !== this.height ? this.initialize({
      width: t,
      height: i,
      format: this.format,
      samples: this.samples
    }) : this;
  }
  _createHandle() {
    return this.gl.createRenderbuffer();
  }
  _deleteHandle() {
    this.gl.deleteRenderbuffer(this.handle), this._trackDeallocatedMemory();
  }
  _bindHandle(e) {
    this.gl.bindRenderbuffer(36161, e);
  }
  _syncHandle(e) {
    this.format = this.getParameter(36164), this.width = this.getParameter(36162), this.height = this.getParameter(36163), this.samples = this.getParameter(36011);
  }
  _getParameter(e) {
    return this.gl.bindRenderbuffer(36161, this.handle), this.gl.getRenderbufferParameter(36161, e);
  }
}
const S4 = 256, T4 = 1024, C4 = 16384, K2 = 6144, Q2 = 6145, ex = 6146, tx = 34041, Z5 = "clear: bad arguments";
function C1(n) {
  let {
    framebuffer: e = null,
    color: t = null,
    depth: i = null,
    stencil: r = null
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const s = {};
  e && (s.framebuffer = e);
  let c = 0;
  t && (c |= C4, t !== !0 && (s.clearColor = t)), i && (c |= S4, i !== !0 && (s.clearDepth = i)), r && (c |= T4, i !== !0 && (s.clearStencil = i)), Yt(c !== 0, Z5), Cl(n, s, () => {
    n.clear(c);
  });
}
function I4(n) {
  let {
    framebuffer: e = null,
    buffer: t = K2,
    drawBuffer: i = 0,
    value: r = [0, 0, 0, 0]
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  mo(n), Cl(n, {
    framebuffer: e
  }, () => {
    switch (t) {
      case K2:
        switch (r.constructor) {
          case Int32Array:
            n.clearBufferiv(t, i, r);
            break;
          case Uint32Array:
            n.clearBufferuiv(t, i, r);
            break;
          case Float32Array:
          default:
            n.clearBufferfv(t, i, r);
        }
        break;
      case Q2:
        n.clearBufferfv(Q2, 0, [r]);
        break;
      case ex:
        n.clearBufferiv(ex, 0, [r]);
        break;
      case tx:
        const [s, c] = r;
        n.clearBufferfi(tx, 0, s, c);
        break;
      default:
        Yt(!1, Z5);
    }
  });
}
function P4(n) {
  switch (n) {
    case 6406:
    case 33326:
    case 6403:
      return 1;
    case 33328:
    case 33319:
      return 2;
    case 6407:
    case 34837:
      return 3;
    case 6408:
    case 34836:
      return 4;
    default:
      return Yt(!1), 0;
  }
}
function Om(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    sourceX: t = 0,
    sourceY: i = 0,
    sourceFormat: r = 6408
  } = e;
  let {
    sourceAttachment: s = 36064,
    target: c = null,
    sourceWidth: l,
    sourceHeight: m,
    sourceType: y
  } = e;
  const {
    framebuffer: A,
    deleteFramebuffer: T
  } = L4(n);
  Yt(A);
  const {
    gl: I,
    handle: L,
    attachments: N
  } = A;
  l = l || A.width, m = m || A.height, s === 36064 && L === null && (s = 1028), Yt(N[s]), y = y || N[s].type, c = M4(c, y, r, l, m), y = y || ly(c);
  const z = I.bindFramebuffer(36160, L);
  return I.readPixels(t, i, l, m, r, y, c), I.bindFramebuffer(36160, z || null), T && A.delete(), c;
}
function nx(n) {
  let {
    sourceAttachment: e = 36064,
    targetMaxHeight: t = Number.MAX_SAFE_INTEGER
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = Om(n, {
    sourceAttachment: e
  }), {
    width: r,
    height: s
  } = n;
  for (; s > t; )
    ({
      data: i,
      width: r,
      height: s
    } = f4({
      data: i,
      width: r,
      height: s
    }));
  d4({
    data: i,
    width: r,
    height: s
  });
  const c = document.createElement("canvas");
  c.width = r, c.height = s;
  const l = c.getContext("2d"), m = l.createImageData(r, s);
  return m.data.set(i), l.putImageData(m, 0, 0), c.toDataURL();
}
function L4(n) {
  return n instanceof ss ? {
    framebuffer: n,
    deleteFramebuffer: !1
  } : {
    framebuffer: U4(n),
    deleteFramebuffer: !0
  };
}
function M4(n, e, t, i, r) {
  if (n)
    return n;
  e = e || 5121;
  const s = hp(e, {
    clamped: !1
  }), c = P4(t);
  return new s(i * r * c);
}
const rr = {
  WEBGL2: "WEBGL2",
  VERTEX_ARRAY_OBJECT: "VERTEX_ARRAY_OBJECT",
  TIMER_QUERY: "TIMER_QUERY",
  INSTANCED_RENDERING: "INSTANCED_RENDERING",
  MULTIPLE_RENDER_TARGETS: "MULTIPLE_RENDER_TARGETS",
  ELEMENT_INDEX_UINT32: "ELEMENT_INDEX_UINT32",
  BLEND_EQUATION_MINMAX: "BLEND_EQUATION_MINMAX",
  FLOAT_BLEND: "FLOAT_BLEND",
  COLOR_ENCODING_SRGB: "COLOR_ENCODING_SRGB",
  TEXTURE_DEPTH: "TEXTURE_DEPTH",
  TEXTURE_FLOAT: "TEXTURE_FLOAT",
  TEXTURE_HALF_FLOAT: "TEXTURE_HALF_FLOAT",
  TEXTURE_FILTER_LINEAR_FLOAT: "TEXTURE_FILTER_LINEAR_FLOAT",
  TEXTURE_FILTER_LINEAR_HALF_FLOAT: "TEXTURE_FILTER_LINEAR_HALF_FLOAT",
  TEXTURE_FILTER_ANISOTROPIC: "TEXTURE_FILTER_ANISOTROPIC",
  COLOR_ATTACHMENT_RGBA32F: "COLOR_ATTACHMENT_RGBA32F",
  COLOR_ATTACHMENT_FLOAT: "COLOR_ATTACHMENT_FLOAT",
  COLOR_ATTACHMENT_HALF_FLOAT: "COLOR_ATTACHMENT_HALF_FLOAT",
  GLSL_FRAG_DATA: "GLSL_FRAG_DATA",
  GLSL_FRAG_DEPTH: "GLSL_FRAG_DEPTH",
  GLSL_DERIVATIVES: "GLSL_DERIVATIVES",
  GLSL_TEXTURE_LOD: "GLSL_TEXTURE_LOD"
};
function B4(n) {
  const e = new ga(n, {
    format: 6408,
    type: 5126,
    dataFormat: 6408
  }), t = new ss(n, {
    id: "test-framebuffer",
    check: !1,
    attachments: {
      36064: e
    }
  }), i = t.getStatus();
  return e.delete(), t.delete(), i === 36053;
}
const Y5 = {
  [rr.WEBGL2]: [!1, !0],
  [rr.VERTEX_ARRAY_OBJECT]: ["OES_vertex_array_object", !0],
  [rr.TIMER_QUERY]: ["EXT_disjoint_timer_query", "EXT_disjoint_timer_query_webgl2"],
  [rr.INSTANCED_RENDERING]: ["ANGLE_instanced_arrays", !0],
  [rr.MULTIPLE_RENDER_TARGETS]: ["WEBGL_draw_buffers", !0],
  [rr.ELEMENT_INDEX_UINT32]: ["OES_element_index_uint", !0],
  [rr.BLEND_EQUATION_MINMAX]: ["EXT_blend_minmax", !0],
  [rr.FLOAT_BLEND]: ["EXT_float_blend"],
  [rr.COLOR_ENCODING_SRGB]: ["EXT_sRGB", !0],
  [rr.TEXTURE_DEPTH]: ["WEBGL_depth_texture", !0],
  [rr.TEXTURE_FLOAT]: ["OES_texture_float", !0],
  [rr.TEXTURE_HALF_FLOAT]: ["OES_texture_half_float", !0],
  [rr.TEXTURE_FILTER_LINEAR_FLOAT]: ["OES_texture_float_linear"],
  [rr.TEXTURE_FILTER_LINEAR_HALF_FLOAT]: ["OES_texture_half_float_linear"],
  [rr.TEXTURE_FILTER_ANISOTROPIC]: ["EXT_texture_filter_anisotropic"],
  [rr.COLOR_ATTACHMENT_RGBA32F]: [B4, "EXT_color_buffer_float"],
  [rr.COLOR_ATTACHMENT_FLOAT]: [!1, "EXT_color_buffer_float"],
  [rr.COLOR_ATTACHMENT_HALF_FLOAT]: ["EXT_color_buffer_half_float"],
  [rr.GLSL_FRAG_DATA]: ["WEBGL_draw_buffers", !0],
  [rr.GLSL_FRAG_DEPTH]: ["EXT_frag_depth", !0],
  [rr.GLSL_DERIVATIVES]: ["OES_standard_derivatives", !0],
  [rr.GLSL_TEXTURE_LOD]: ["EXT_shader_texture_lod", !0]
}, R4 = 2;
function I1(n, e) {
  return K5(n, e);
}
function K5(n, e) {
  return e = Array.isArray(e) ? e : [e], e.every((t) => Q5(n, t));
}
function O4(n) {
  n.luma = n.luma || {}, n.luma.caps = n.luma.caps || {};
  for (const e in Y5)
    n.luma.caps[e] === void 0 && (n.luma.caps[e] = Q5(n, e));
  return n.luma.caps;
}
function Q5(n, e) {
  return n.luma = n.luma || {}, n.luma.caps = n.luma.caps || {}, n.luma.caps[e] === void 0 && (n.luma.caps[e] = F4(n, e)), n.luma.caps[e] || cn.log(R4, "Feature: ".concat(e, " not supported"))(), n.luma.caps[e];
}
function F4(n, e) {
  const t = Y5[e];
  Yt(t, e);
  let i;
  const r = ei(n) && t[1] || t[0];
  if (typeof r == "function")
    i = r(n);
  else if (Array.isArray(r)) {
    i = !0;
    for (const s of r)
      i = i && !!n.getExtension(s);
  } else
    typeof r == "string" ? i = !!n.getExtension(r) : typeof r == "boolean" ? i = r : Yt(!1);
  return i;
}
const ix = "Multiple render targets not supported";
class ss extends ru {
  get [Symbol.toStringTag]() {
    return "Framebuffer";
  }
  static isSupported(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      colorBufferFloat: i,
      colorBufferHalfFloat: r
    } = t;
    let s = !0;
    return i && (s = !!(e.getExtension("EXT_color_buffer_float") || e.getExtension("WEBGL_color_buffer_float") || e.getExtension("OES_texture_float"))), r && (s = s && !!(e.getExtension("EXT_color_buffer_float") || e.getExtension("EXT_color_buffer_half_float"))), s;
  }
  static getDefaultFramebuffer(e) {
    return e.luma = e.luma || {}, e.luma.defaultFramebuffer = e.luma.defaultFramebuffer || new ss(e, {
      id: "default-framebuffer",
      handle: null,
      attachments: {}
    }), e.luma.defaultFramebuffer;
  }
  get MAX_COLOR_ATTACHMENTS() {
    const e = mo(this.gl);
    return e.getParameter(e.MAX_COLOR_ATTACHMENTS);
  }
  get MAX_DRAW_BUFFERS() {
    const e = mo(this.gl);
    return e.getParameter(e.MAX_DRAW_BUFFERS);
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(e, t), this.width = null, this.height = null, this.attachments = {}, this.readBuffer = 36064, this.drawBuffers = [36064], this.ownResources = [], this.initialize(t), Object.seal(this);
  }
  get color() {
    return this.attachments[36064] || null;
  }
  get texture() {
    return this.attachments[36064] || null;
  }
  get depth() {
    return this.attachments[36096] || this.attachments[33306] || null;
  }
  get stencil() {
    return this.attachments[36128] || this.attachments[33306] || null;
  }
  initialize(e) {
    let {
      width: t = 1,
      height: i = 1,
      attachments: r = null,
      color: s = !0,
      depth: c = !0,
      stencil: l = !1,
      check: m = !0,
      readBuffer: y = void 0,
      drawBuffers: A = void 0
    } = e;
    if (Yt(t >= 0 && i >= 0, "Width and height need to be integers"), this.width = t, this.height = i, r)
      for (const T in r) {
        const I = r[T];
        (Array.isArray(I) ? I[0] : I).resize({
          width: t,
          height: i
        });
      }
    else
      r = this._createDefaultAttachments(s, c, l, t, i);
    this.update({
      clearAttachments: !0,
      attachments: r,
      readBuffer: y,
      drawBuffers: A
    }), r && m && this.checkStatus();
  }
  delete() {
    for (const e of this.ownResources)
      e.delete();
    return super.delete(), this;
  }
  update(e) {
    let {
      attachments: t = {},
      readBuffer: i,
      drawBuffers: r,
      clearAttachments: s = !1,
      resizeAttachments: c = !0
    } = e;
    this.attach(t, {
      clearAttachments: s,
      resizeAttachments: c
    });
    const {
      gl: l
    } = this, m = l.bindFramebuffer(36160, this.handle);
    return i && this._setReadBuffer(i), r && this._setDrawBuffers(r), l.bindFramebuffer(36160, m || null), this;
  }
  resize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, {
      width: t,
      height: i
    } = e;
    if (this.handle === null)
      return Yt(t === void 0 && i === void 0), this.width = this.gl.drawingBufferWidth, this.height = this.gl.drawingBufferHeight, this;
    t === void 0 && (t = this.gl.drawingBufferWidth), i === void 0 && (i = this.gl.drawingBufferHeight), t !== this.width && i !== this.height && cn.log(2, "Resizing framebuffer ".concat(this.id, " to ").concat(t, "x").concat(i))();
    for (const r in this.attachments)
      this.attachments[r].resize({
        width: t,
        height: i
      });
    return this.width = t, this.height = i, this;
  }
  attach(e) {
    let {
      clearAttachments: t = !1,
      resizeAttachments: i = !0
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const r = {};
    t && Object.keys(this.attachments).forEach((c) => {
      r[c] = null;
    }), Object.assign(r, e);
    const s = this.gl.bindFramebuffer(36160, this.handle);
    for (const c in r) {
      Yt(c !== void 0, "Misspelled framebuffer binding point?");
      const l = Number(c), m = r[l];
      let y = m;
      if (!y)
        this._unattach(l);
      else if (y instanceof Sd)
        this._attachRenderbuffer({
          attachment: l,
          renderbuffer: y
        });
      else if (Array.isArray(m)) {
        const [A, T = 0, I = 0] = m;
        y = A, this._attachTexture({
          attachment: l,
          texture: A,
          layer: T,
          level: I
        });
      } else
        this._attachTexture({
          attachment: l,
          texture: y,
          layer: 0,
          level: 0
        });
      i && y && y.resize({
        width: this.width,
        height: this.height
      });
    }
    this.gl.bindFramebuffer(36160, s || null), Object.assign(this.attachments, e), Object.keys(this.attachments).filter((c) => !this.attachments[c]).forEach((c) => {
      delete this.attachments[c];
    });
  }
  checkStatus() {
    const e = this.getStatus();
    if (e !== 36053)
      throw new Error(k4(e));
    return this;
  }
  getStatus() {
    const {
      gl: e
    } = this, t = e.bindFramebuffer(36160, this.handle), i = e.checkFramebufferStatus(36160);
    return e.bindFramebuffer(36160, t || null), i;
  }
  clear() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      color: t,
      depth: i,
      stencil: r,
      drawBuffers: s = []
    } = e, c = this.gl.bindFramebuffer(36160, this.handle);
    return (t || i || r) && C1(this.gl, {
      color: t,
      depth: i,
      stencil: r
    }), s.forEach((l, m) => {
      I4(this.gl, {
        drawBuffer: m,
        value: l
      });
    }), this.gl.bindFramebuffer(36160, c || null), this;
  }
  readPixels() {
    return cn.error("Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)")(), null;
  }
  readPixelsToBuffer() {
    return cn.error("Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)")(), null;
  }
  copyToDataUrl() {
    return cn.error("Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)")(), null;
  }
  copyToImage() {
    return cn.error("Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)")(), null;
  }
  copyToTexture() {
    return cn.error("Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})")(), null;
  }
  blit() {
    return cn.error("Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)")(), null;
  }
  invalidate(e) {
    let {
      attachments: t = [],
      x: i = 0,
      y: r = 0,
      width: s,
      height: c
    } = e;
    const l = mo(this.gl), m = l.bindFramebuffer(36008, this.handle);
    return i === 0 && r === 0 && s === void 0 && c === void 0 ? l.invalidateFramebuffer(36008, t) : l.invalidateFramebuffer(36008, t, i, r, s, c), l.bindFramebuffer(36008, m), this;
  }
  getAttachmentParameter(e, t, i) {
    let r = this._getAttachmentParameterFallback(t);
    return r === null && (this.gl.bindFramebuffer(36160, this.handle), r = this.gl.getFramebufferAttachmentParameter(36160, e, t), this.gl.bindFramebuffer(36160, null)), i && r > 1e3 && (r = Hu(this.gl, r)), r;
  }
  getAttachmentParameters() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 36064, t = arguments.length > 1 ? arguments[1] : void 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.constructor.ATTACHMENT_PARAMETERS || [];
    const r = {};
    for (const s of i) {
      const c = t ? Hu(this.gl, s) : s;
      r[c] = this.getAttachmentParameter(e, s, t);
    }
    return r;
  }
  getParameters() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    const t = Object.keys(this.attachments), i = {};
    for (const r of t) {
      const s = Number(r), c = e ? Hu(this.gl, s) : s;
      i[c] = this.getAttachmentParameters(s, e);
    }
    return i;
  }
  show() {
    return typeof window < "u" && window.open(nx(this), "luma-debug-texture"), this;
  }
  log() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    if (e > cn.level || typeof window > "u")
      return this;
    t = t || "Framebuffer ".concat(this.id);
    const i = nx(this, {
      targetMaxHeight: 100
    });
    return cn.image({
      logLevel: e,
      message: t,
      image: i
    }, t)(), this;
  }
  bind() {
    let {
      target: e = 36160
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.gl.bindFramebuffer(e, this.handle), this;
  }
  unbind() {
    let {
      target: e = 36160
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.gl.bindFramebuffer(e, null), this;
  }
  _createDefaultAttachments(e, t, i, r, s) {
    let c = null;
    return e && (c = c || {}, c[36064] = new ga(this.gl, {
      id: "".concat(this.id, "-color0"),
      pixels: null,
      format: 6408,
      type: 5121,
      width: r,
      height: s,
      mipmaps: !1,
      parameters: {
        10241: 9729,
        10240: 9729,
        10242: 33071,
        10243: 33071
      }
    }), this.ownResources.push(c[36064])), t && i ? (c = c || {}, c[33306] = new Sd(this.gl, {
      id: "".concat(this.id, "-depth-stencil"),
      format: 35056,
      width: r,
      height: 111
    }), this.ownResources.push(c[33306])) : t ? (c = c || {}, c[36096] = new Sd(this.gl, {
      id: "".concat(this.id, "-depth"),
      format: 33189,
      width: r,
      height: s
    }), this.ownResources.push(c[36096])) : i && Yt(!1), c;
  }
  _unattach(e) {
    const t = this.attachments[e];
    t && (t instanceof Sd ? this.gl.framebufferRenderbuffer(36160, e, 36161, null) : this.gl.framebufferTexture2D(36160, e, 3553, null, 0), delete this.attachments[e]);
  }
  _attachRenderbuffer(e) {
    let {
      attachment: t = 36064,
      renderbuffer: i
    } = e;
    const {
      gl: r
    } = this;
    r.framebufferRenderbuffer(36160, t, 36161, i.handle), this.attachments[t] = i;
  }
  _attachTexture(e) {
    let {
      attachment: t = 36064,
      texture: i,
      layer: r,
      level: s
    } = e;
    const {
      gl: c
    } = this;
    switch (c.bindTexture(i.target, i.handle), i.target) {
      case 35866:
      case 32879:
        mo(c).framebufferTextureLayer(36160, t, i.target, s, r);
        break;
      case 34067:
        const m = D4(r);
        c.framebufferTexture2D(36160, t, m, i.handle, s);
        break;
      case 3553:
        c.framebufferTexture2D(36160, t, 3553, i.handle, s);
        break;
      default:
        Yt(!1, "Illegal texture type");
    }
    c.bindTexture(i.target, null), this.attachments[t] = i;
  }
  _setReadBuffer(e) {
    const t = dM(this.gl);
    t ? t.readBuffer(e) : Yt(e === 36064 || e === 1029, ix), this.readBuffer = e;
  }
  _setDrawBuffers(e) {
    const {
      gl: t
    } = this, i = mo(t);
    if (i)
      i.drawBuffers(e);
    else {
      const r = t.getExtension("WEBGL_draw_buffers");
      r ? r.drawBuffersWEBGL(e) : Yt(e.length === 1 && (e[0] === 36064 || e[0] === 1029), ix);
    }
    this.drawBuffers = e;
  }
  _getAttachmentParameterFallback(e) {
    const t = O4(this.gl);
    switch (e) {
      case 36052:
        return t.WEBGL2 ? null : 0;
      case 33298:
      case 33299:
      case 33300:
      case 33301:
      case 33302:
      case 33303:
        return t.WEBGL2 ? null : 8;
      case 33297:
        return t.WEBGL2 ? null : 5125;
      case 33296:
        return !t.WEBGL2 && !t.EXT_sRGB ? 9729 : null;
      default:
        return null;
    }
  }
  _createHandle() {
    return this.gl.createFramebuffer();
  }
  _deleteHandle() {
    this.gl.deleteFramebuffer(this.handle);
  }
  _bindHandle(e) {
    return this.gl.bindFramebuffer(36160, e);
  }
}
function D4(n) {
  return n < 34069 ? n + 34069 : n;
}
function k4(n) {
  return (ss.STATUS || {})[n] || "Framebuffer error ".concat(n);
}
const N4 = [36049, 36048, 33296, 33298, 33299, 33300, 33301, 33302, 33303];
ss.ATTACHMENT_PARAMETERS = N4;
function z4(n, e) {
  Yt(n instanceof ga || n instanceof $5 || n instanceof A4);
  const t = n.constructor, {
    gl: i,
    width: r,
    height: s,
    format: c,
    type: l,
    dataFormat: m,
    border: y,
    mipmaps: A
  } = n, T = Object.assign({
    width: r,
    height: s,
    format: c,
    type: l,
    dataFormat: m,
    border: y,
    mipmaps: A
  }, e);
  return new t(i, T);
}
function U4(n, e) {
  const {
    gl: t,
    width: i,
    height: r,
    id: s
  } = n;
  return new ss(t, Object.assign({}, e, {
    id: "framebuffer-for-".concat(s),
    width: i,
    height: r,
    attachments: {
      36064: n
    }
  }));
}
function Gg(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "unnamed";
  const t = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/, i = n.match(t);
  return i ? i[1] : e;
}
const j4 = 35632, G4 = 35633;
function V4(n) {
  switch (n) {
    case j4:
      return "fragment";
    case G4:
      return "vertex";
    default:
      return "unknown type";
  }
}
function q4(n, e, t, i) {
  const r = n.split(/\r?\n/), s = {}, c = {}, l = i || Gg(e) || "(unnamed)", m = "".concat(V4(t), " shader ").concat(l);
  for (let A = 0; A < r.length; A++) {
    const T = r[A];
    if (T.length <= 1)
      continue;
    const I = T.split(":"), L = I[0], N = parseInt(I[2], 10);
    if (isNaN(N))
      throw new Error("GLSL compilation error in ".concat(m, ": ").concat(n));
    L !== "WARNING" ? s[N] = T : c[N] = T;
  }
  const y = H4(e);
  return {
    shaderName: m,
    errors: rx(s, y),
    warnings: rx(c, y)
  };
}
function rx(n, e) {
  let t = "";
  for (let i = 0; i < e.length; i++) {
    const r = e[i];
    if (!(!n[i + 3] && !n[i + 2] && !n[i + 1]) && (t += "".concat(r, `
`), n[i + 1])) {
      const s = n[i + 1], c = s.split(":", 3), l = c[0], m = parseInt(c[1], 10) || 0, y = s.substring(c.join(":").length + 1).trim();
      t += eE("^^^ ".concat(l, ": ").concat(y, `

`), m);
    }
  }
  return t;
}
function H4(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ": ";
  const i = n.split(/\r?\n/), r = String(i.length + e - 1).length;
  return i.map((s, c) => {
    const l = String(c + e), m = l.length;
    return eE(l, r - m) + t + s;
  });
}
function eE(n, e) {
  let t = "";
  for (let i = 0; i < e; ++i)
    t += " ";
  return "".concat(t).concat(n);
}
function tE(n) {
  let e = 100;
  const t = n.match(/[^\s]+/g);
  if (t.length >= 2 && t[0] === "#version") {
    const i = parseInt(t[1], 10);
    Number.isFinite(i) && (e = i);
  }
  return e;
}
const W4 = "Shader: GLSL source code must be a JavaScript string";
class dp extends ru {
  get [Symbol.toStringTag]() {
    return "Shader";
  }
  static getTypeName(e) {
    switch (e) {
      case 35633:
        return "vertex-shader";
      case 35632:
        return "fragment-shader";
      default:
        return Yt(!1), "unknown";
    }
  }
  constructor(e, t) {
    Rm(e), Yt(typeof t.source == "string", W4);
    const i = Gg(t.source, null) || t.id || tu("unnamed ".concat(dp.getTypeName(t.shaderType)));
    super(e, {
      id: i
    }), this.shaderType = t.shaderType, this.source = t.source, this.initialize(t);
  }
  initialize(e) {
    let {
      source: t
    } = e;
    const i = Gg(t, null);
    i && (this.id = tu(i)), this._compile(t);
  }
  getParameter(e) {
    return this.gl.getShaderParameter(this.handle, e);
  }
  toString() {
    return "".concat(dp.getTypeName(this.shaderType), ":").concat(this.id);
  }
  getName() {
    return Gg(this.source) || "unnamed-shader";
  }
  getSource() {
    return this.gl.getShaderSource(this.handle);
  }
  getTranslatedSource() {
    const e = this.gl.getExtension("WEBGL_debug_shaders");
    return e ? e.getTranslatedShaderSource(this.handle) : "No translated source available. WEBGL_debug_shaders not implemented";
  }
  _compile() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.source;
    if (e.startsWith("#version ") || (e = `#version 100
`.concat(e)), this.source = e, this.gl.shaderSource(this.handle, this.source), this.gl.compileShader(this.handle), !this.getParameter(35713)) {
      const i = this.gl.getShaderInfoLog(this.handle), {
        shaderName: r,
        errors: s,
        warnings: c
      } = q4(i, this.source, this.shaderType, this.id);
      throw cn.error("GLSL compilation errors in ".concat(r, `
`).concat(s))(), cn.warn("GLSL compilation warnings in ".concat(r, `
`).concat(c))(), new Error("GLSL compilation errors in ".concat(r));
    }
  }
  _deleteHandle() {
    this.gl.deleteShader(this.handle);
  }
  _getOptsFromHandle() {
    return {
      type: this.getParameter(35663),
      source: this.getSource()
    };
  }
}
class Y0 extends dp {
  get [Symbol.toStringTag]() {
    return "VertexShader";
  }
  constructor(e, t) {
    typeof t == "string" && (t = {
      source: t
    }), super(e, Object.assign({}, t, {
      shaderType: 35633
    }));
  }
  _createHandle() {
    return this.gl.createShader(35633);
  }
}
class K0 extends dp {
  get [Symbol.toStringTag]() {
    return "FragmentShader";
  }
  constructor(e, t) {
    typeof t == "string" && (t = {
      source: t
    }), super(e, Object.assign({}, t, {
      shaderType: 35632
    }));
  }
  _createHandle() {
    return this.gl.createShader(35632);
  }
}
const X4 = {
  5126: cr.bind(null, "uniform1fv", aa, 1, Gs),
  35664: cr.bind(null, "uniform2fv", aa, 2, Gs),
  35665: cr.bind(null, "uniform3fv", aa, 3, Gs),
  35666: cr.bind(null, "uniform4fv", aa, 4, Gs),
  5124: cr.bind(null, "uniform1iv", Bu, 1, Gs),
  35667: cr.bind(null, "uniform2iv", Bu, 2, Gs),
  35668: cr.bind(null, "uniform3iv", Bu, 3, Gs),
  35669: cr.bind(null, "uniform4iv", Bu, 4, Gs),
  35670: cr.bind(null, "uniform1iv", Bu, 1, Gs),
  35671: cr.bind(null, "uniform2iv", Bu, 2, Gs),
  35672: cr.bind(null, "uniform3iv", Bu, 3, Gs),
  35673: cr.bind(null, "uniform4iv", Bu, 4, Gs),
  35674: cr.bind(null, "uniformMatrix2fv", aa, 4, Gc),
  35675: cr.bind(null, "uniformMatrix3fv", aa, 9, Gc),
  35676: cr.bind(null, "uniformMatrix4fv", aa, 16, Gc),
  35678: Cs,
  35680: Cs,
  5125: cr.bind(null, "uniform1uiv", dg, 1, Gs),
  36294: cr.bind(null, "uniform2uiv", dg, 2, Gs),
  36295: cr.bind(null, "uniform3uiv", dg, 3, Gs),
  36296: cr.bind(null, "uniform4uiv", dg, 4, Gs),
  35685: cr.bind(null, "uniformMatrix2x3fv", aa, 6, Gc),
  35686: cr.bind(null, "uniformMatrix2x4fv", aa, 8, Gc),
  35687: cr.bind(null, "uniformMatrix3x2fv", aa, 6, Gc),
  35688: cr.bind(null, "uniformMatrix3x4fv", aa, 12, Gc),
  35689: cr.bind(null, "uniformMatrix4x2fv", aa, 8, Gc),
  35690: cr.bind(null, "uniformMatrix4x3fv", aa, 12, Gc),
  35678: Cs,
  35680: Cs,
  35679: Cs,
  35682: Cs,
  36289: Cs,
  36292: Cs,
  36293: Cs,
  36298: Cs,
  36299: Cs,
  36300: Cs,
  36303: Cs,
  36306: Cs,
  36307: Cs,
  36308: Cs,
  36311: Cs
}, J4 = {}, $4 = {}, Z4 = {}, sx = [0];
function P1(n, e, t, i) {
  e === 1 && typeof n == "boolean" && (n = n ? 1 : 0), Number.isFinite(n) && (sx[0] = n, n = sx);
  const r = n.length;
  if (r % e && cn.warn("Uniform size should be multiples of ".concat(e), n)(), n instanceof t)
    return n;
  let s = i[r];
  s || (s = new t(r), i[r] = s);
  for (let c = 0; c < r; c++)
    s[c] = n[c];
  return s;
}
function aa(n, e) {
  return P1(n, e, Float32Array, J4);
}
function Bu(n, e) {
  return P1(n, e, Int32Array, $4);
}
function dg(n, e) {
  return P1(n, e, Uint32Array, Z4);
}
function ox(n, e, t) {
  const i = X4[t.type];
  if (!i)
    throw new Error("Unknown GLSL uniform type ".concat(t.type));
  return i().bind(null, n, e);
}
function Y4(n) {
  if (n[n.length - 1] !== "]")
    return {
      name: n,
      length: 1,
      isArray: !1
    };
  const e = /([^[]*)(\[[0-9]+\])?/, t = n.match(e);
  if (!t || t.length < 2)
    throw new Error("Failed to parse GLSL uniform name ".concat(n));
  return {
    name: t[1],
    length: t[2] || 1,
    isArray: !!t[2]
  };
}
function K4(n, e, t) {
  for (const i in n) {
    const r = n[i];
    if ((!t || !!t[i]) && !Q4(r))
      throw e = e ? "".concat(e, " ") : "", console.error("".concat(e, " Bad uniform ").concat(i), r), new Error("".concat(e, " Bad uniform ").concat(i));
  }
  return !0;
}
function Q4(n) {
  return Array.isArray(n) || ArrayBuffer.isView(n) ? tB(n) : isFinite(n) || n === !0 || n === !1 || n instanceof Vd || n instanceof Sd ? !0 : n instanceof ss ? !!n.texture : !1;
}
function eB(n, e, t) {
  if (Array.isArray(t) || ArrayBuffer.isView(t))
    if (n[e]) {
      const i = n[e];
      for (let r = 0, s = t.length; r < s; ++r)
        i[r] = t[r];
    } else
      n[e] = t.slice();
  else
    n[e] = t;
}
function tB(n) {
  if (n.length === 0)
    return !1;
  const e = Math.min(n.length, 16);
  for (let t = 0; t < e; ++t)
    if (!Number.isFinite(n[t]))
      return !1;
  return !0;
}
function Cs() {
  let n = null;
  return (e, t, i) => {
    const r = n !== i;
    return r && (e.uniform1i(t, i), n = i), r;
  };
}
function cr(n, e, t, i) {
  let r = null, s = null;
  return (c, l, m) => {
    const y = e(m, t), A = y.length;
    let T = !1;
    if (r === null)
      r = new Float32Array(A), s = A, T = !0;
    else {
      Yt(s === A, "Uniform length cannot change.");
      for (let I = 0; I < A; ++I)
        if (y[I] !== r[I]) {
          T = !0;
          break;
        }
    }
    return T && (i(c, n, l, y), r.set(y)), T;
  };
}
function Gs(n, e, t, i) {
  n[e](t, i);
}
function Gc(n, e, t, i) {
  n[e](t, !1, i);
}
const nB = 5120, iB = 5121, rB = 5122, sB = 5123, ax = 0, fg = 1, oB = 2, aB = 3, pg = 4, lB = 5, cB = 6, is = 5126, uB = 35664, hB = 35665, dB = 35666, Df = 5124, fB = 35667, pB = 35668, gB = 35669, kf = 5125, mB = 36294, _B = 36295, yB = 36296, vB = 35670, bB = 35671, xB = 35672, wB = 35673, AB = 35674, EB = 35675, SB = 35676, TB = 35685, CB = 35686, IB = 35687, PB = 35688, LB = 35689, MB = 35690, hy = {
  [is]: [is, 1, "float"],
  [uB]: [is, 2, "vec2"],
  [hB]: [is, 3, "vec3"],
  [dB]: [is, 4, "vec4"],
  [Df]: [Df, 1, "int"],
  [fB]: [Df, 2, "ivec2"],
  [pB]: [Df, 3, "ivec3"],
  [gB]: [Df, 4, "ivec4"],
  [kf]: [kf, 1, "uint"],
  [mB]: [kf, 2, "uvec2"],
  [_B]: [kf, 3, "uvec3"],
  [yB]: [kf, 4, "uvec4"],
  [vB]: [is, 1, "bool"],
  [bB]: [is, 2, "bvec2"],
  [xB]: [is, 3, "bvec3"],
  [wB]: [is, 4, "bvec4"],
  [AB]: [is, 8, "mat2"],
  [TB]: [is, 8, "mat2x3"],
  [CB]: [is, 8, "mat2x4"],
  [EB]: [is, 12, "mat3"],
  [IB]: [is, 12, "mat3x2"],
  [PB]: [is, 12, "mat3x4"],
  [SB]: [is, 16, "mat4"],
  [LB]: [is, 16, "mat4x2"],
  [MB]: [is, 16, "mat4x3"]
};
function BB(n) {
  switch (n) {
    case ax:
      return ax;
    case fg:
      return fg;
    case aB:
      return fg;
    case oB:
      return fg;
    case pg:
      return pg;
    case lB:
      return pg;
    case cB:
      return pg;
    default:
      return Yt(!1), 0;
  }
}
function lx(n) {
  const e = hy[n];
  if (!e)
    return null;
  const [t, i] = e;
  return {
    type: t,
    components: i
  };
}
function nE(n, e) {
  switch (n) {
    case nB:
    case iB:
    case rB:
    case sB:
      n = is;
      break;
  }
  for (const t in hy) {
    const [i, r, s] = hy[t];
    if (i === n && r === e)
      return {
        glType: t,
        name: s
      };
  }
  return null;
}
class RB {
  constructor(e) {
    this.id = e.id, this.attributeInfos = [], this.attributeInfosByName = {}, this.attributeInfosByLocation = [], this.varyingInfos = [], this.varyingInfosByName = {}, Object.seal(this), this._readAttributesFromProgram(e), this._readVaryingsFromProgram(e);
  }
  getAttributeInfo(e) {
    const t = Number(e);
    return Number.isFinite(t) ? this.attributeInfosByLocation[t] : this.attributeInfosByName[e] || null;
  }
  getAttributeLocation(e) {
    const t = this.getAttributeInfo(e);
    return t ? t.location : -1;
  }
  getAttributeAccessor(e) {
    const t = this.getAttributeInfo(e);
    return t ? t.accessor : null;
  }
  getVaryingInfo(e) {
    const t = Number(e);
    return Number.isFinite(t) ? this.varyingInfos[t] : this.varyingInfosByName[e] || null;
  }
  getVaryingIndex(e) {
    const t = this.getVaryingInfo();
    return t ? t.location : -1;
  }
  getVaryingAccessor(e) {
    const t = this.getVaryingInfo();
    return t ? t.accessor : null;
  }
  _readAttributesFromProgram(e) {
    const {
      gl: t
    } = e, i = t.getProgramParameter(e.handle, 35721);
    for (let r = 0; r < i; r++) {
      const {
        name: s,
        type: c,
        size: l
      } = t.getActiveAttrib(e.handle, r), m = t.getAttribLocation(e.handle, s);
      m >= 0 && this._addAttribute(m, s, c, l);
    }
    this.attributeInfos.sort((r, s) => r.location - s.location);
  }
  _readVaryingsFromProgram(e) {
    const {
      gl: t
    } = e;
    if (!ei(t))
      return;
    const i = t.getProgramParameter(e.handle, 35971);
    for (let r = 0; r < i; r++) {
      const {
        name: s,
        type: c,
        size: l
      } = t.getTransformFeedbackVarying(e.handle, r);
      this._addVarying(r, s, c, l);
    }
    this.varyingInfos.sort((r, s) => r.location - s.location);
  }
  _addAttribute(e, t, i, r) {
    const {
      type: s,
      components: c
    } = lx(i), l = {
      type: s,
      size: r * c
    };
    this._inferProperties(e, t, l);
    const m = {
      location: e,
      name: t,
      accessor: new Ro(l)
    };
    this.attributeInfos.push(m), this.attributeInfosByLocation[e] = m, this.attributeInfosByName[m.name] = m;
  }
  _inferProperties(e, t, i) {
    /instance/i.test(t) && (i.divisor = 1);
  }
  _addVarying(e, t, i, r) {
    const {
      type: s,
      components: c
    } = lx(i), l = new Ro({
      type: s,
      size: r * c
    }), m = {
      location: e,
      name: t,
      accessor: l
    };
    this.varyingInfos.push(m), this.varyingInfosByName[m.name] = m;
  }
}
const cx = 4, OB = 35981, FB = ["setVertexArray", "setAttributes", "setBuffers", "unsetBuffers", "use", "getUniformCount", "getUniformInfo", "getUniformLocation", "getUniformValue", "getVarying", "getFragDataLocation", "getAttachedShaders", "getAttributeCount", "getAttributeLocation", "getAttributeInfo"];
class iE extends ru {
  get [Symbol.toStringTag]() {
    return "Program";
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(e, t), this.stubRemovedMethods("Program", "v6.0", FB), this._isCached = !1, this.initialize(t), Object.seal(this), this._setId(t.id);
  }
  initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      hash: t,
      vs: i,
      fs: r,
      varyings: s,
      bufferMode: c = OB
    } = e;
    return this.hash = t || "", this.vs = typeof i == "string" ? new Y0(this.gl, {
      id: "".concat(e.id, "-vs"),
      source: i
    }) : i, this.fs = typeof r == "string" ? new K0(this.gl, {
      id: "".concat(e.id, "-fs"),
      source: r
    }) : r, Yt(this.vs instanceof Y0), Yt(this.fs instanceof K0), this.uniforms = {}, this._textureUniforms = {}, s && s.length > 0 && (mo(this.gl), this.varyings = s, this.gl2.transformFeedbackVaryings(this.handle, s, c)), this._compileAndLink(), this._readUniformLocationsFromLinkedProgram(), this.configuration = new RB(this), this.setProps(e);
  }
  delete() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this._isCached ? this : super.delete(e);
  }
  setProps(e) {
    return "uniforms" in e && this.setUniforms(e.uniforms), this;
  }
  draw(e) {
    let {
      logPriority: t,
      drawMode: i = 4,
      vertexCount: r,
      offset: s = 0,
      start: c,
      end: l,
      isIndexed: m = !1,
      indexType: y = 5123,
      instanceCount: A = 0,
      isInstanced: T = A > 0,
      vertexArray: I = null,
      transformFeedback: L,
      framebuffer: N,
      parameters: z = {},
      uniforms: V,
      samplers: H
    } = e;
    if ((V || H) && (cn.deprecated("Program.draw({uniforms})", "Program.setUniforms(uniforms)")(), this.setUniforms(V || {})), cn.priority >= t) {
      const J = N ? N.id : "default", ce = "mode=".concat(Hu(this.gl, i), " verts=").concat(r, " ") + "instances=".concat(A, " indexType=").concat(Hu(this.gl, y), " ") + "isInstanced=".concat(T, " isIndexed=").concat(m, " ") + "Framebuffer=".concat(J);
      cn.log(t, ce)();
    }
    return Yt(I), this.gl.useProgram(this.handle), !this._areTexturesRenderable() || r === 0 || T && A === 0 ? !1 : (I.bindForDraw(r, A, () => {
      if (N !== void 0 && (z = Object.assign({}, z, {
        framebuffer: N
      })), L) {
        const J = BB(i);
        L.begin(J);
      }
      this._bindTextures(), Cl(this.gl, z, () => {
        m && T ? this.gl2.drawElementsInstanced(i, r, y, s, A) : m && ei(this.gl) && !isNaN(c) && !isNaN(l) ? this.gl2.drawRangeElements(i, c, l, r, y, s) : m ? this.gl.drawElements(i, r, y, s) : T ? this.gl2.drawArraysInstanced(i, s, r, A) : this.gl.drawArrays(i, s, r);
      }), L && L.end();
    }), !0);
  }
  setUniforms() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    cn.priority >= 2 && K4(e, this.id, this._uniformSetters), this.gl.useProgram(this.handle);
    for (const t in e) {
      const i = e[t], r = this._uniformSetters[t];
      if (r) {
        let s = i, c = !1;
        if (s instanceof ss && (s = s.texture), s instanceof Vd)
          if (c = this.uniforms[t] !== i, c) {
            r.textureIndex === void 0 && (r.textureIndex = this._textureIndexCounter++);
            const l = s, {
              textureIndex: m
            } = r;
            l.bind(m), s = m, this._textureUniforms[t] = l;
          } else
            s = r.textureIndex;
        else
          this._textureUniforms[t] && delete this._textureUniforms[t];
        (r(s) || c) && eB(this.uniforms, t, i);
      }
    }
    return this;
  }
  _areTexturesRenderable() {
    let e = !0;
    for (const t in this._textureUniforms) {
      const i = this._textureUniforms[t];
      i.update(), e = e && i.loaded;
    }
    return e;
  }
  _bindTextures() {
    for (const e in this._textureUniforms) {
      const t = this._uniformSetters[e].textureIndex;
      this._textureUniforms[e].bind(t);
    }
  }
  _createHandle() {
    return this.gl.createProgram();
  }
  _deleteHandle() {
    this.gl.deleteProgram(this.handle);
  }
  _getOptionsFromHandle(e) {
    const t = this.gl.getAttachedShaders(e), i = {};
    for (const r of t)
      switch (this.gl.getShaderParameter(this.handle, 35663)) {
        case 35633:
          i.vs = new Y0({
            handle: r
          });
          break;
        case 35632:
          i.fs = new K0({
            handle: r
          });
          break;
      }
    return i;
  }
  _getParameter(e) {
    return this.gl.getProgramParameter(this.handle, e);
  }
  _setId(e) {
    if (!e) {
      const t = this._getName();
      this.id = tu(t);
    }
  }
  _getName() {
    let e = this.vs.getName() || this.fs.getName();
    return e = e.replace(/shader/i, ""), e = e ? "".concat(e, "-program") : "program", e;
  }
  _compileAndLink() {
    const {
      gl: e
    } = this;
    if (e.attachShader(this.handle, this.vs.handle), e.attachShader(this.handle, this.fs.handle), cn.time(cx, "linkProgram for ".concat(this._getName()))(), e.linkProgram(this.handle), cn.timeEnd(cx, "linkProgram for ".concat(this._getName()))(), e.debug || cn.level > 0) {
      if (!e.getProgramParameter(this.handle, 35714))
        throw new Error("Error linking: ".concat(e.getProgramInfoLog(this.handle)));
      if (e.validateProgram(this.handle), !e.getProgramParameter(this.handle, 35715))
        throw new Error("Error validating: ".concat(e.getProgramInfoLog(this.handle)));
    }
  }
  _readUniformLocationsFromLinkedProgram() {
    const {
      gl: e
    } = this;
    this._uniformSetters = {}, this._uniformCount = this._getParameter(35718);
    for (let t = 0; t < this._uniformCount; t++) {
      const i = this.gl.getActiveUniform(this.handle, t), {
        name: r
      } = Y4(i.name);
      let s = e.getUniformLocation(this.handle, r);
      if (this._uniformSetters[r] = ox(e, s, i), i.size > 1)
        for (let c = 0; c < i.size; c++)
          s = e.getUniformLocation(this.handle, "".concat(r, "[").concat(c, "]")), this._uniformSetters["".concat(r, "[").concat(c, "]")] = ox(e, s, i);
    }
    this._textureIndexCounter = 0;
  }
  getActiveUniforms(e, t) {
    return this.gl2.getActiveUniforms(this.handle, e, t);
  }
  getUniformBlockIndex(e) {
    return this.gl2.getUniformBlockIndex(this.handle, e);
  }
  getActiveUniformBlockParameter(e, t) {
    return this.gl2.getActiveUniformBlockParameter(this.handle, e, t);
  }
  uniformBlockBinding(e, t) {
    this.gl2.uniformBlockBinding(this.handle, e, t);
  }
}
const DB = 34918, kB = 34919, NB = 35007, zB = 36795, UB = 35976, jB = 35887, GB = 36202;
class fm extends ru {
  get [Symbol.toStringTag]() {
    return "Query";
  }
  static isSupported(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    const i = ei(e), r = K5(e, rr.TIMER_QUERY);
    let s = i || r;
    for (const c of t)
      switch (c) {
        case "queries":
          s = s && i;
          break;
        case "timers":
          s = s && r;
          break;
        default:
          Yt(!1);
      }
    return s;
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(e, t), this.target = null, this._queryPending = !1, this._pollingPromise = null, Object.seal(this);
  }
  beginTimeElapsedQuery() {
    return this.begin(NB);
  }
  beginOcclusionQuery() {
    let {
      conservative: e = !1
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.begin(e ? GB : jB);
  }
  beginTransformFeedbackQuery() {
    return this.begin(UB);
  }
  begin(e) {
    return this._queryPending ? this : (this.target = e, this.gl2.beginQuery(this.target, this.handle), this);
  }
  end() {
    return this._queryPending ? this : (this.target && (this.gl2.endQuery(this.target), this.target = null, this._queryPending = !0), this);
  }
  isResultAvailable() {
    if (!this._queryPending)
      return !1;
    const e = this.gl2.getQueryParameter(this.handle, kB);
    return e && (this._queryPending = !1), e;
  }
  isTimerDisjoint() {
    return this.gl2.getParameter(zB);
  }
  getResult() {
    return this.gl2.getQueryParameter(this.handle, DB);
  }
  getTimerMilliseconds() {
    return this.getResult() / 1e6;
  }
  createPoll() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Number.POSITIVE_INFINITY;
    if (this._pollingPromise)
      return this._pollingPromise;
    let t = 0;
    return this._pollingPromise = new Promise((i, r) => {
      const s = () => {
        this.isResultAvailable() ? (i(this.getResult()), this._pollingPromise = null) : t++ > e ? (r("Timed out"), this._pollingPromise = null) : requestAnimationFrame(s);
      };
      requestAnimationFrame(s);
    }), this._pollingPromise;
  }
  _createHandle() {
    return fm.isSupported(this.gl) ? this.gl2.createQuery() : null;
  }
  _deleteHandle() {
    this.gl2.deleteQuery(this.handle);
  }
}
class rE extends ru {
  get [Symbol.toStringTag]() {
    return "TransformFeedback";
  }
  static isSupported(e) {
    return ei(e);
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    mo(e), super(e, t), this.initialize(t), this.stubRemovedMethods("TransformFeedback", "v6.0", ["pause", "resume"]), Object.seal(this);
  }
  initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.buffers = {}, this.unused = {}, this.configuration = null, this.bindOnUse = !0, Gd(this.buffers) || this.bind(() => this._unbindBuffers()), this.setProps(e), this;
  }
  setProps(e) {
    "program" in e && (this.configuration = e.program && e.program.configuration), "configuration" in e && (this.configuration = e.configuration), "bindOnUse" in e && (e = e.bindOnUse), "buffers" in e && this.setBuffers(e.buffers);
  }
  setBuffers() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.bind(() => {
      for (const t in e)
        this.setBuffer(t, e[t]);
    }), this;
  }
  setBuffer(e, t) {
    const i = this._getVaryingIndex(e), {
      buffer: r,
      byteSize: s,
      byteOffset: c
    } = this._getBufferParams(t);
    return i < 0 ? (this.unused[e] = r, cn.warn("".concat(this.id, " unused varying buffer ").concat(e))(), this) : (this.buffers[i] = t, this.bindOnUse || this._bindBuffer(i, r, c, s), this);
  }
  begin() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return this.gl.bindTransformFeedback(36386, this.handle), this._bindBuffers(), this.gl.beginTransformFeedback(e), this;
  }
  end() {
    return this.gl.endTransformFeedback(), this._unbindBuffers(), this.gl.bindTransformFeedback(36386, null), this;
  }
  _getBufferParams(e) {
    let t, i, r;
    return e instanceof Hi ? r = e : (r = e.buffer, i = e.byteSize, t = e.byteOffset), (t !== void 0 || i !== void 0) && (t = t || 0, i = i || r.byteLength - t), {
      buffer: r,
      byteOffset: t,
      byteSize: i
    };
  }
  _getVaryingInfo(e) {
    return this.configuration && this.configuration.getVaryingInfo(e);
  }
  _getVaryingIndex(e) {
    if (this.configuration)
      return this.configuration.getVaryingInfo(e).location;
    const t = Number(e);
    return Number.isFinite(t) ? t : -1;
  }
  _bindBuffers() {
    if (this.bindOnUse)
      for (const e in this.buffers) {
        const {
          buffer: t,
          byteSize: i,
          byteOffset: r
        } = this._getBufferParams(this.buffers[e]);
        this._bindBuffer(e, t, r, i);
      }
  }
  _unbindBuffers() {
    if (this.bindOnUse)
      for (const e in this.buffers)
        this._bindBuffer(e, null);
  }
  _bindBuffer(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, r = arguments.length > 3 ? arguments[3] : void 0;
    const s = t && t.handle;
    return !s || r === void 0 ? this.gl.bindBufferBase(35982, e, s) : this.gl.bindBufferRange(35982, e, s, i, r), this;
  }
  _createHandle() {
    return this.gl.createTransformFeedback();
  }
  _deleteHandle() {
    this.gl.deleteTransformFeedback(this.handle);
  }
  _bindHandle(e) {
    this.gl.bindTransformFeedback(36386, this.handle);
  }
}
let gg = null;
function VB(n) {
  return (!gg || gg.byteLength < n) && (gg = new ArrayBuffer(n)), gg;
}
function qB(n, e) {
  const t = VB(n.BYTES_PER_ELEMENT * e);
  return new n(t, 0, e);
}
function HB(n) {
  let {
    target: e,
    source: t,
    start: i = 0,
    count: r = 1
  } = n;
  const s = t.length, c = r * s;
  let l = 0;
  for (let m = i; l < s; l++)
    e[m++] = t[l];
  for (; l < c; )
    l < c - l ? (e.copyWithin(i + l, i, i + l), l *= 2) : (e.copyWithin(i + l, i, i + c - l), l = c);
  return e;
}
const WB = "elements must be GL.ELEMENT_ARRAY_BUFFER";
class ha extends ru {
  get [Symbol.toStringTag]() {
    return "VertexArrayObject";
  }
  static isSupported(e) {
    return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}).constantAttributeZero ? ei(e) || S5() === "Chrome" : !0;
  }
  static getDefaultArray(e) {
    return e.luma = e.luma || {}, e.luma.defaultVertexArray || (e.luma.defaultVertexArray = new ha(e, {
      handle: null,
      isDefaultArray: !0
    })), e.luma.defaultVertexArray;
  }
  static getMaxAttributes(e) {
    return ha.MAX_ATTRIBUTES = ha.MAX_ATTRIBUTES || e.getParameter(34921), ha.MAX_ATTRIBUTES;
  }
  static setConstant(e, t, i) {
    switch (i.constructor) {
      case Float32Array:
        ha._setConstantFloatArray(e, t, i);
        break;
      case Int32Array:
        ha._setConstantIntArray(e, t, i);
        break;
      case Uint32Array:
        ha._setConstantUintArray(e, t, i);
        break;
      default:
        Yt(!1);
    }
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const i = t.id || t.program && t.program.id;
    super(e, Object.assign({}, t, {
      id: i
    })), this.buffer = null, this.bufferValue = null, this.isDefaultArray = t.isDefaultArray || !1, this.gl2 = e, this.initialize(t), Object.seal(this);
  }
  delete() {
    return super.delete(), this.buffer && this.buffer.delete(), this;
  }
  get MAX_ATTRIBUTES() {
    return ha.getMaxAttributes(this.gl);
  }
  initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.setProps(e);
  }
  setProps(e) {
    return this;
  }
  setElementBuffer() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    return Yt(!e || e.target === 34963, WB), this.bind(() => {
      this.gl.bindBuffer(34963, e ? e.handle : null);
    }), this;
  }
  setBuffer(e, t, i) {
    if (t.target === 34963)
      return this.setElementBuffer(t, i);
    const {
      size: r,
      type: s,
      stride: c,
      offset: l,
      normalized: m,
      integer: y,
      divisor: A
    } = i, {
      gl: T,
      gl2: I
    } = this;
    return e = Number(e), this.bind(() => {
      T.bindBuffer(34962, t.handle), y ? (Yt(ei(T)), I.vertexAttribIPointer(e, r, s, c, l)) : T.vertexAttribPointer(e, r, s, m, c, l), T.enableVertexAttribArray(e), I.vertexAttribDivisor(e, A || 0);
    }), this;
  }
  enable(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return !t && e === 0 && !ha.isSupported(this.gl, {
      constantAttributeZero: !0
    }) || (e = Number(e), this.bind(() => t ? this.gl.enableVertexAttribArray(e) : this.gl.disableVertexAttribArray(e))), this;
  }
  getConstantBuffer(e, t) {
    const i = this._normalizeConstantArrayValue(t), r = i.byteLength * e, s = i.length * e;
    let c = !this.buffer;
    if (this.buffer = this.buffer || new Hi(this.gl, r), c = c || this.buffer.reallocate(r), c = c || !this._compareConstantArrayValues(i, this.bufferValue), c) {
      const l = qB(t.constructor, s);
      HB({
        target: l,
        source: i,
        start: 0,
        count: s
      }), this.buffer.subData(l), this.bufferValue = t;
    }
    return this.buffer;
  }
  _normalizeConstantArrayValue(e) {
    return Array.isArray(e) ? new Float32Array(e) : e;
  }
  _compareConstantArrayValues(e, t) {
    if (!e || !t || e.length !== t.length || e.constructor !== t.constructor)
      return !1;
    for (let i = 0; i < e.length; ++i)
      if (e[i] !== t[i])
        return !1;
    return !0;
  }
  static _setConstantFloatArray(e, t, i) {
    switch (i.length) {
      case 1:
        e.vertexAttrib1fv(t, i);
        break;
      case 2:
        e.vertexAttrib2fv(t, i);
        break;
      case 3:
        e.vertexAttrib3fv(t, i);
        break;
      case 4:
        e.vertexAttrib4fv(t, i);
        break;
      default:
        Yt(!1);
    }
  }
  static _setConstantIntArray(e, t, i) {
    switch (Yt(ei(e)), i.length) {
      case 1:
        e.vertexAttribI1iv(t, i);
        break;
      case 2:
        e.vertexAttribI2iv(t, i);
        break;
      case 3:
        e.vertexAttribI3iv(t, i);
        break;
      case 4:
        e.vertexAttribI4iv(t, i);
        break;
      default:
        Yt(!1);
    }
  }
  static _setConstantUintArray(e, t, i) {
    switch (Yt(ei(e)), i.length) {
      case 1:
        e.vertexAttribI1uiv(t, i);
        break;
      case 2:
        e.vertexAttribI2uiv(t, i);
        break;
      case 3:
        e.vertexAttribI3uiv(t, i);
        break;
      case 4:
        e.vertexAttribI4uiv(t, i);
        break;
      default:
        Yt(!1);
    }
  }
  _createHandle() {
    return this.gl.createVertexArray();
  }
  _deleteHandle(e) {
    return this.gl2.deleteVertexArray(e), [this.elements];
  }
  _bindHandle(e) {
    this.gl2.bindVertexArray(e);
  }
  _getParameter(e, t) {
    let {
      location: i
    } = t;
    return Yt(Number.isFinite(i)), this.bind(() => {
      switch (e) {
        case 34373:
          return this.gl.getVertexAttribOffset(i, e);
        default:
          return this.gl.getVertexAttrib(i, e);
      }
    });
  }
}
const XB = "VertexArray: attributes must be Buffers or constants (i.e. typed array)", JB = /^(.+)__LOCATION_([0-9]+)$/, $B = ["setBuffers", "setGeneric", "clearBindings", "setLocations", "setGenericValues", "setDivisor", "enable", "disable"];
class ZB {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const i = t.id || t.program && t.program.id;
    this.id = i, this.gl = e, this.configuration = null, this.elements = null, this.elementsAccessor = null, this.values = null, this.accessors = null, this.unused = null, this.drawParams = null, this.buffer = null, this.attributes = {}, this.vertexArrayObject = new ha(e), H5(this, "VertexArray", "v6.0", $B), this.initialize(t), Object.seal(this);
  }
  delete() {
    this.buffer && this.buffer.delete(), this.vertexArrayObject.delete();
  }
  initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.reset(), this.configuration = null, this.bindOnUse = !1, this.setProps(e);
  }
  reset() {
    this.elements = null, this.elementsAccessor = null;
    const {
      MAX_ATTRIBUTES: e
    } = this.vertexArrayObject;
    return this.values = new Array(e).fill(null), this.accessors = new Array(e).fill(null), this.unused = {}, this.drawParams = null, this;
  }
  setProps(e) {
    return "program" in e && (this.configuration = e.program && e.program.configuration), "configuration" in e && (this.configuration = e.configuration), "attributes" in e && this.setAttributes(e.attributes), "elements" in e && this.setElementBuffer(e.elements), "bindOnUse" in e && (e = e.bindOnUse), this;
  }
  clearDrawParams() {
    this.drawParams = null;
  }
  getDrawParams() {
    return this.drawParams = this.drawParams || this._updateDrawParams(), this.drawParams;
  }
  setAttributes(e) {
    return Object.assign(this.attributes, e), this.vertexArrayObject.bind(() => {
      for (const t in e) {
        const i = e[t];
        this._setAttribute(t, i);
      }
      this.gl.bindBuffer(34962, null);
    }), this;
  }
  setElementBuffer() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return this.elements = e, this.elementsAccessor = t, this.clearDrawParams(), this.vertexArrayObject.setElementBuffer(e, t), this;
  }
  setBuffer(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (t.target === 34963)
      return this.setElementBuffer(t, i);
    const {
      location: r,
      accessor: s
    } = this._resolveLocationAndAccessor(e, t, t.accessor, i);
    return r >= 0 && (this.values[r] = t, this.accessors[r] = s, this.clearDrawParams(), this.vertexArrayObject.setBuffer(r, t, s)), this;
  }
  setConstant(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const {
      location: r,
      accessor: s
    } = this._resolveLocationAndAccessor(e, t, Object.assign({
      size: t.length
    }, i));
    return r >= 0 && (t = this.vertexArrayObject._normalizeConstantArrayValue(t), this.values[r] = t, this.accessors[r] = s, this.clearDrawParams(), this.vertexArrayObject.enable(r, !1)), this;
  }
  unbindBuffers() {
    return this.vertexArrayObject.bind(() => {
      this.elements && this.vertexArrayObject.setElementBuffer(null), this.buffer = this.buffer || new Hi(this.gl, {
        accessor: {
          size: 4
        }
      });
      for (let e = 0; e < this.vertexArrayObject.MAX_ATTRIBUTES; e++)
        this.values[e] instanceof Hi && (this.gl.disableVertexAttribArray(e), this.gl.bindBuffer(34962, this.buffer.handle), this.gl.vertexAttribPointer(e, 1, 5126, !1, 0, 0));
    }), this;
  }
  bindBuffers() {
    return this.vertexArrayObject.bind(() => {
      this.elements && this.setElementBuffer(this.elements);
      for (let e = 0; e < this.vertexArrayObject.MAX_ATTRIBUTES; e++) {
        const t = this.values[e];
        t instanceof Hi && this.setBuffer(e, t);
      }
    }), this;
  }
  bindForDraw(e, t, i) {
    let r;
    return this.vertexArrayObject.bind(() => {
      this._setConstantAttributes(e, t), r = i();
    }), r;
  }
  _resolveLocationAndAccessor(e, t, i, r) {
    const s = {
      location: -1,
      accessor: null
    }, {
      location: c,
      name: l
    } = this._getAttributeIndex(e);
    if (!Number.isFinite(c) || c < 0)
      return this.unused[e] = t, cn.once(3, () => "unused value ".concat(e, " in ").concat(this.id))(), s;
    const m = this._getAttributeInfo(l || c);
    if (!m)
      return s;
    const y = this.accessors[c] || {}, A = Ro.resolve(m.accessor, y, i, r), {
      size: T,
      type: I
    } = A;
    return Yt(Number.isFinite(T) && Number.isFinite(I)), {
      location: c,
      accessor: A
    };
  }
  _getAttributeInfo(e) {
    return this.configuration && this.configuration.getAttributeInfo(e);
  }
  _getAttributeIndex(e) {
    const t = Number(e);
    if (Number.isFinite(t))
      return {
        location: t
      };
    const i = JB.exec(e), r = i ? i[1] : e, s = i ? Number(i[2]) : 0;
    return this.configuration ? {
      location: this.configuration.getAttributeLocation(r) + s,
      name: r
    } : {
      location: -1
    };
  }
  _setAttribute(e, t) {
    if (t instanceof Hi)
      this.setBuffer(e, t);
    else if (Array.isArray(t) && t.length && t[0] instanceof Hi) {
      const i = t[0], r = t[1];
      this.setBuffer(e, i, r);
    } else if (ArrayBuffer.isView(t) || Array.isArray(t)) {
      const i = t;
      this.setConstant(e, i);
    } else if (t.buffer instanceof Hi) {
      const i = t;
      this.setBuffer(e, i.buffer, i);
    } else
      throw new Error(XB);
  }
  _setConstantAttributes(e, t) {
    const i = Math.max(e | 0, t | 0);
    let r = this.values[0];
    ArrayBuffer.isView(r) && this._setConstantAttributeZero(r, i);
    for (let s = 1; s < this.vertexArrayObject.MAX_ATTRIBUTES; s++)
      r = this.values[s], ArrayBuffer.isView(r) && this._setConstantAttribute(s, r);
  }
  _setConstantAttributeZero(e, t) {
    if (ha.isSupported(this.gl, {
      constantAttributeZero: !0
    })) {
      this._setConstantAttribute(0, e);
      return;
    }
    const i = this.vertexArrayObject.getConstantBuffer(t, e);
    this.vertexArrayObject.setBuffer(0, i, this.accessors[0]);
  }
  _setConstantAttribute(e, t) {
    ha.setConstant(this.gl, e, t);
  }
  _updateDrawParams() {
    const e = {
      isIndexed: !1,
      isInstanced: !1,
      indexCount: 1 / 0,
      vertexCount: 1 / 0,
      instanceCount: 1 / 0
    };
    for (let t = 0; t < this.vertexArrayObject.MAX_ATTRIBUTES; t++)
      this._updateDrawParamsForLocation(e, t);
    return this.elements && (e.elementCount = this.elements.getElementCount(this.elements.accessor), e.isIndexed = !0, e.indexType = this.elementsAccessor.type || this.elements.accessor.type, e.indexOffset = this.elementsAccessor.offset || 0), e.indexCount === 1 / 0 && (e.indexCount = 0), e.vertexCount === 1 / 0 && (e.vertexCount = 0), e.instanceCount === 1 / 0 && (e.instanceCount = 0), e;
  }
  _updateDrawParamsForLocation(e, t) {
    const i = this.values[t], r = this.accessors[t];
    if (!i)
      return;
    const {
      divisor: s
    } = r, c = s > 0;
    if (e.isInstanced = e.isInstanced || c, i instanceof Hi) {
      const l = i;
      if (c) {
        const m = l.getVertexCount(r);
        e.instanceCount = Math.min(e.instanceCount, m);
      } else {
        const m = l.getVertexCount(r);
        e.vertexCount = Math.min(e.vertexCount, m);
      }
    }
  }
  setElements() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return cn.deprecated("setElements", "setElementBuffer")(), this.setElementBuffer(e, t);
  }
}
function YB(n, e) {
  const {
    maxElts: t = 16,
    size: i = 1
  } = e;
  let r = "[";
  for (let c = 0; c < n.length && c < t; ++c)
    c > 0 && (r += ",".concat(c % i === 0 ? " " : "")), r += fp(n[c], e);
  const s = n.length > t ? "..." : "]";
  return "".concat(r).concat(s);
}
function fp(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = 1e-16, {
    isInteger: i = !1
  } = e;
  if (Array.isArray(n) || ArrayBuffer.isView(n))
    return YB(n, e);
  if (!Number.isFinite(n))
    return String(n);
  if (Math.abs(n) < t)
    return i ? "0" : "0.";
  if (i || Math.abs(n) > 100 && Math.abs(n) < 1e4)
    return n.toFixed(0);
  const r = n.toPrecision(2);
  return r.indexOf(".0") === r.length - 2 ? r.slice(0, -1) : r;
}
function ux(n) {
  let {
    header: e = "Uniforms",
    program: t,
    uniforms: i,
    undefinedOnly: r = !1
  } = n;
  Yt(t);
  const s = ".*_.*", c = ".*Matrix", l = t._uniformSetters, m = {}, y = Object.keys(l).sort();
  let A = 0;
  for (const L of y)
    !L.match(s) && !L.match(c) && Q0({
      table: m,
      header: e,
      uniforms: i,
      uniformName: L,
      undefinedOnly: r
    }) && A++;
  for (const L of y)
    L.match(c) && Q0({
      table: m,
      header: e,
      uniforms: i,
      uniformName: L,
      undefinedOnly: r
    }) && A++;
  for (const L of y)
    m[L] || Q0({
      table: m,
      header: e,
      uniforms: i,
      uniformName: L,
      undefinedOnly: r
    }) && A++;
  let T = 0;
  const I = {};
  if (!r)
    for (const L in i) {
      const N = i[L];
      m[L] || (T++, I[L] = {
        Type: "NOT USED: ".concat(N),
        [e]: fp(N)
      });
    }
  return {
    table: m,
    count: A,
    unusedTable: I,
    unusedCount: T
  };
}
function Q0(n) {
  let {
    table: e,
    header: t,
    uniforms: i,
    uniformName: r,
    undefinedOnly: s
  } = n;
  const c = i[r], l = KB(c);
  return !s || !l ? (e[r] = {
    [t]: l ? fp(c) : "N/A",
    "Uniform Type": l ? c : "NOT PROVIDED"
  }, !0) : !1;
}
function KB(n) {
  return n != null;
}
function QB(n) {
  let {
    vertexArray: e,
    header: t = "Attributes"
  } = n;
  if (!e.configuration)
    return {};
  const i = {};
  e.elements && (i.ELEMENT_ARRAY_BUFFER = hx(e, e.elements, null, t));
  const r = e.values;
  for (const s in r) {
    const c = e._getAttributeInfo(s);
    if (c) {
      let l = "".concat(s, ": ").concat(c.name);
      const m = e.accessors[c.location];
      m && (l = "".concat(s, ": ").concat(eR(c.name, m))), i[l] = hx(e, r[s], m, t);
    }
  }
  return i;
}
function hx(n, e, t, i) {
  const {
    gl: r
  } = n;
  if (!e)
    return {
      [i]: "null",
      "Format ": "N/A"
    };
  let s = "NOT PROVIDED", c = 1, l = 0, m = 0, y, A, T;
  if (t && (s = t.type, c = t.size, s = String(s).replace("Array", ""), y = s.indexOf("nt") !== -1), e instanceof Hi) {
    const I = e, {
      data: L,
      changed: N
    } = I.getDebugData();
    A = N ? "*" : "", T = L, m = I.byteLength, l = m / L.BYTES_PER_ELEMENT / c;
    let z;
    if (t) {
      const V = t.divisor > 0;
      z = "".concat(V ? "I " : "P ", " ").concat(l, " (x").concat(c, "=").concat(m, " bytes ").concat(Hu(r, s), ")");
    } else
      y = !0, z = "".concat(m, " bytes");
    return {
      [i]: "".concat(A).concat(fp(T, {
        size: c,
        isInteger: y
      })),
      "Format ": z
    };
  }
  return T = e, c = e.length, s = String(e.constructor.name).replace("Array", ""), y = s.indexOf("nt") !== -1, {
    [i]: "".concat(fp(T, {
      size: c,
      isInteger: y
    }), " (constant)"),
    "Format ": "".concat(c, "x").concat(s, " (constant)")
  };
}
function eR(n, e) {
  const {
    type: t,
    size: i
  } = e, r = nE(t, i);
  return r ? "".concat(n, " (").concat(r.name, ")") : n;
}
function tR(n) {
  const e = {}, t = "Accessors for ".concat(n.id);
  for (const i of n.attributeInfos)
    if (i) {
      const r = dx(i);
      e["in ".concat(r)] = {
        [t]: JSON.stringify(i.accessor)
      };
    }
  for (const i of n.varyingInfos)
    if (i) {
      const r = dx(i);
      e["out ".concat(r)] = {
        [t]: JSON.stringify(i.accessor)
      };
    }
  return e;
}
function dx(n) {
  const {
    type: e,
    size: t
  } = n.accessor, i = nE(e, t);
  return i ? "".concat(i.name, " ").concat(n.name) : n.name;
}
const fx = iu() && typeof document < "u";
let nR = 0;
class iR {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      onCreateContext: t = (V) => q5(V),
      onAddHTML: i = null,
      onInitialize: r = () => {
      },
      onRender: s = () => {
      },
      onFinalize: c = () => {
      },
      onError: l,
      gl: m = null,
      glOptions: y = {},
      debug: A = !1,
      createFramebuffer: T = !1,
      autoResizeViewport: I = !0,
      autoResizeDrawingBuffer: L = !0,
      stats: N = Ph.get("animation-loop-".concat(nR++))
    } = e;
    let {
      useDevicePixels: z = !0
    } = e;
    "useDevicePixelRatio" in e && (cn.deprecated("useDevicePixelRatio", "useDevicePixels")(), z = e.useDevicePixelRatio), this.props = {
      onCreateContext: t,
      onAddHTML: i,
      onInitialize: r,
      onRender: s,
      onFinalize: c,
      onError: l,
      gl: m,
      glOptions: y,
      debug: A,
      createFramebuffer: T
    }, this.gl = m, this.needsRedraw = null, this.timeline = null, this.stats = N, this.cpuTime = this.stats.get("CPU Time"), this.gpuTime = this.stats.get("GPU Time"), this.frameRate = this.stats.get("Frame Rate"), this._initialized = !1, this._running = !1, this._animationFrameId = null, this._nextFramePromise = null, this._resolveNextFrame = null, this._cpuStartTime = 0, this.setProps({
      autoResizeViewport: I,
      autoResizeDrawingBuffer: L,
      useDevicePixels: z
    }), this.start = this.start.bind(this), this.stop = this.stop.bind(this), this._pageLoadPromise = null, this._onMousemove = this._onMousemove.bind(this), this._onMouseleave = this._onMouseleave.bind(this);
  }
  delete() {
    this.stop(), this._setDisplay(null);
  }
  setNeedsRedraw(e) {
    return Yt(typeof e == "string"), this.needsRedraw = this.needsRedraw || e, this;
  }
  setProps(e) {
    return "autoResizeViewport" in e && (this.autoResizeViewport = e.autoResizeViewport), "autoResizeDrawingBuffer" in e && (this.autoResizeDrawingBuffer = e.autoResizeDrawingBuffer), "useDevicePixels" in e && (this.useDevicePixels = e.useDevicePixels), this;
  }
  start() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (this._running)
      return this;
    this._running = !0;
    const t = this._getPageLoadPromise().then(() => !this._running || this._initialized ? null : (this._createWebGLContext(e), this._createFramebuffer(), this._startEventHandling(), this._initializeCallbackData(), this._updateCallbackData(), this._resizeCanvasDrawingBuffer(), this._resizeViewport(), this._gpuTimeQuery = fm.isSupported(this.gl, ["timers"]) ? new fm(this.gl) : null, this._initialized = !0, this.onInitialize(this.animationProps))).then((i) => {
      this._running && (this._addCallbackData(i || {}), i !== !1 && this._startLoop());
    });
    return this.props.onError && t.catch(this.props.onError), this;
  }
  redraw() {
    return this.isContextLost() ? this : (this._beginTimers(), this._setupFrame(), this._updateCallbackData(), this._renderFrame(this.animationProps), this._clearNeedsRedraw(), this.offScreen && this.gl.commit && this.gl.commit(), this._resolveNextFrame && (this._resolveNextFrame(this), this._nextFramePromise = null, this._resolveNextFrame = null), this._endTimers(), this);
  }
  stop() {
    return this._running && (this._finalizeCallbackData(), this._cancelAnimationFrame(this._animationFrameId), this._nextFramePromise = null, this._resolveNextFrame = null, this._animationFrameId = null, this._running = !1), this;
  }
  attachTimeline(e) {
    return this.timeline = e, this.timeline;
  }
  detachTimeline() {
    this.timeline = null;
  }
  waitForRender() {
    return this.setNeedsRedraw("waitForRender"), this._nextFramePromise || (this._nextFramePromise = new Promise((e) => {
      this._resolveNextFrame = e;
    })), this._nextFramePromise;
  }
  async toDataURL() {
    return this.setNeedsRedraw("toDataURL"), await this.waitForRender(), this.gl.canvas.toDataURL();
  }
  isContextLost() {
    return this.gl.isContextLost();
  }
  onCreateContext() {
    return this.props.onCreateContext(...arguments);
  }
  onInitialize() {
    return this.props.onInitialize(...arguments);
  }
  onRender() {
    return this.props.onRender(...arguments);
  }
  onFinalize() {
    return this.props.onFinalize(...arguments);
  }
  getHTMLControlValue(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    const i = document.getElementById(e);
    return i ? Number(i.value) : t;
  }
  setViewParameters() {
    return cn.removed("AnimationLoop.setViewParameters", "AnimationLoop.setProps")(), this;
  }
  _startLoop() {
    const e = () => {
      this._running && (this.redraw(), this._animationFrameId = this._requestAnimationFrame(e));
    };
    this._cancelAnimationFrame(this._animationFrameId), this._animationFrameId = this._requestAnimationFrame(e);
  }
  _getPageLoadPromise() {
    return this._pageLoadPromise || (this._pageLoadPromise = fx ? new Promise((e, t) => {
      if (fx && document.readyState === "complete") {
        e(document);
        return;
      }
      window.addEventListener("load", () => {
        e(document);
      });
    }) : Promise.resolve({})), this._pageLoadPromise;
  }
  _setDisplay(e) {
    this.display && (this.display.delete(), this.display.animationLoop = null), e && (e.animationLoop = this), this.display = e;
  }
  _cancelAnimationFrame(e) {
    return this.display && this.display.cancelAnimationFrame ? this.display.cancelAnimationFrame(e) : u4(e);
  }
  _requestAnimationFrame(e) {
    if (this._running)
      return this.display && this.display.requestAnimationFrame ? this.display.requestAnimationFrame(e) : c4(e);
  }
  _renderFrame() {
    if (this.display) {
      this.display._renderFrame(...arguments);
      return;
    }
    this.onRender(...arguments);
  }
  _clearNeedsRedraw() {
    this.needsRedraw = null;
  }
  _setupFrame() {
    this._resizeCanvasDrawingBuffer(), this._resizeViewport(), this._resizeFramebuffer();
  }
  _initializeCallbackData() {
    this.animationProps = {
      gl: this.gl,
      stop: this.stop,
      canvas: this.gl.canvas,
      framebuffer: this.framebuffer,
      useDevicePixels: this.useDevicePixels,
      needsRedraw: null,
      startTime: Date.now(),
      engineTime: 0,
      tick: 0,
      tock: 0,
      time: 0,
      _timeline: this.timeline,
      _loop: this,
      _animationLoop: this,
      _mousePosition: null
    };
  }
  _updateCallbackData() {
    const {
      width: e,
      height: t,
      aspect: i
    } = this._getSizeAndAspect();
    (e !== this.animationProps.width || t !== this.animationProps.height) && this.setNeedsRedraw("drawing buffer resized"), i !== this.animationProps.aspect && this.setNeedsRedraw("drawing buffer aspect changed"), this.animationProps.width = e, this.animationProps.height = t, this.animationProps.aspect = i, this.animationProps.needsRedraw = this.needsRedraw, this.animationProps.engineTime = Date.now() - this.animationProps.startTime, this.timeline && this.timeline.update(this.animationProps.engineTime), this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60), this.animationProps.tock++, this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime, this.animationProps._offScreen = this.offScreen;
  }
  _finalizeCallbackData() {
    this.onFinalize(this.animationProps);
  }
  _addCallbackData(e) {
    typeof e == "object" && e !== null && (this.animationProps = Object.assign({}, this.animationProps, e));
  }
  _createWebGLContext(e) {
    if (this.offScreen = e.canvas && typeof OffscreenCanvas < "u" && e.canvas instanceof OffscreenCanvas, e = Object.assign({}, e, this.props.glOptions), this.gl = this.props.gl ? S1(this.props.gl, e) : this.onCreateContext(e), !Bm(this.gl))
      throw new Error("AnimationLoop.onCreateContext - illegal context returned");
    ZM(this.gl), this._createInfoDiv();
  }
  _createInfoDiv() {
    if (this.gl.canvas && this.props.onAddHTML) {
      const e = document.createElement("div");
      document.body.appendChild(e), e.style.position = "relative";
      const t = document.createElement("div");
      t.style.position = "absolute", t.style.left = "10px", t.style.bottom = "10px", t.style.width = "300px", t.style.background = "white", e.appendChild(this.gl.canvas), e.appendChild(t);
      const i = this.props.onAddHTML(t);
      i && (t.innerHTML = i);
    }
  }
  _getSizeAndAspect() {
    const e = this.gl.drawingBufferWidth, t = this.gl.drawingBufferHeight;
    let i = 1;
    const {
      canvas: r
    } = this.gl;
    return r && r.clientHeight ? i = r.clientWidth / r.clientHeight : e > 0 && t > 0 && (i = e / t), {
      width: e,
      height: t,
      aspect: i
    };
  }
  _resizeViewport() {
    this.autoResizeViewport && this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
  }
  _resizeCanvasDrawingBuffer() {
    this.autoResizeDrawingBuffer && t4(this.gl, {
      useDevicePixels: this.useDevicePixels
    });
  }
  _createFramebuffer() {
    this.props.createFramebuffer && (this.framebuffer = new ss(this.gl));
  }
  _resizeFramebuffer() {
    this.framebuffer && this.framebuffer.resize({
      width: this.gl.drawingBufferWidth,
      height: this.gl.drawingBufferHeight
    });
  }
  _beginTimers() {
    this.frameRate.timeEnd(), this.frameRate.timeStart(), this._gpuTimeQuery && this._gpuTimeQuery.isResultAvailable() && !this._gpuTimeQuery.isTimerDisjoint() && this.stats.get("GPU Time").addTime(this._gpuTimeQuery.getTimerMilliseconds()), this._gpuTimeQuery && this._gpuTimeQuery.beginTimeElapsedQuery(), this.cpuTime.timeStart();
  }
  _endTimers() {
    this.cpuTime.timeEnd(), this._gpuTimeQuery && this._gpuTimeQuery.end();
  }
  _startEventHandling() {
    const {
      canvas: e
    } = this.gl;
    e && (e.addEventListener("mousemove", this._onMousemove), e.addEventListener("mouseleave", this._onMouseleave));
  }
  _onMousemove(e) {
    this.animationProps._mousePosition = [e.offsetX, e.offsetY];
  }
  _onMouseleave(e) {
    this.animationProps._mousePosition = null;
  }
}
const Bp = "vs", L1 = "fs";
function pa(n, e) {
  if (!n)
    throw new Error(e || "shadertools: assertion failed.");
}
const e_ = {
  number: {
    validate(n, e) {
      return Number.isFinite(n) && (!("max" in e) || n <= e.max) && (!("min" in e) || n >= e.min);
    }
  },
  array: {
    validate(n, e) {
      return Array.isArray(n) || ArrayBuffer.isView(n);
    }
  }
};
function rR(n) {
  const e = {};
  for (const t in n) {
    const i = n[t], r = sR(i);
    e[t] = r;
  }
  return e;
}
function sR(n) {
  let e = px(n);
  return e === "object" ? n ? "type" in n ? Object.assign({}, n, e_[n.type]) : "value" in n ? (e = px(n.value), Object.assign({
    type: e
  }, n, e_[e])) : {
    type: "object",
    value: n
  } : {
    type: "object",
    value: null
  } : Object.assign({
    type: e,
    value: n
  }, e_[e]);
}
function px(n) {
  return Array.isArray(n) || ArrayBuffer.isView(n) ? "array" : typeof n;
}
const oR = "vs", aR = "fs";
class gx {
  constructor(e) {
    let {
      name: t,
      vs: i,
      fs: r,
      dependencies: s = [],
      uniforms: c,
      getUniforms: l,
      deprecations: m = [],
      defines: y = {},
      inject: A = {},
      vertexShader: T,
      fragmentShader: I
    } = e;
    pa(typeof t == "string"), this.name = t, this.vs = i || T, this.fs = r || I, this.getModuleUniforms = l, this.dependencies = s, this.deprecations = this._parseDeprecationDefinitions(m), this.defines = y, this.injections = lR(A), c && (this.uniforms = rR(c));
  }
  getModuleSource(e) {
    let t;
    switch (e) {
      case oR:
        t = this.vs || "";
        break;
      case aR:
        t = this.fs || "";
        break;
      default:
        pa(!1);
    }
    return "#define MODULE_".concat(this.name.toUpperCase().replace(/[^0-9a-z]/gi, "_"), `
`).concat(t, "// END MODULE_").concat(this.name, `

`);
  }
  getUniforms(e, t) {
    return this.getModuleUniforms ? this.getModuleUniforms(e, t) : this.uniforms ? this._defaultGetUniforms(e) : {};
  }
  getDefines() {
    return this.defines;
  }
  checkDeprecations(e, t) {
    this.deprecations.forEach((i) => {
      i.regex.test(e) && (i.deprecated ? t.deprecated(i.old, i.new)() : t.removed(i.old, i.new)());
    });
  }
  _parseDeprecationDefinitions(e) {
    return e.forEach((t) => {
      switch (t.type) {
        case "function":
          t.regex = new RegExp("\\b".concat(t.old, "\\("));
          break;
        default:
          t.regex = new RegExp("".concat(t.type, " ").concat(t.old, ";"));
      }
    }), e;
  }
  _defaultGetUniforms() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = {}, i = this.uniforms;
    for (const r in i) {
      const s = i[r];
      r in e && !s.private ? (s.validate && pa(s.validate(e[r], s), "".concat(this.name, ": invalid ").concat(r)), t[r] = e[r]) : t[r] = s.value;
    }
    return t;
  }
}
function lR(n) {
  const e = {
    vs: {},
    fs: {}
  };
  for (const t in n) {
    let i = n[t];
    const r = t.slice(0, 2);
    typeof i == "string" && (i = {
      order: 0,
      injection: i
    }), e[r][t] = i;
  }
  return e;
}
function cR(n) {
  return uR(oE(n));
}
function uR(n) {
  const e = {}, t = {};
  return sE({
    modules: n,
    level: 0,
    moduleMap: e,
    moduleDepth: t
  }), Object.keys(t).sort((i, r) => t[r] - t[i]).map((i) => e[i]);
}
function sE(n) {
  let {
    modules: e,
    level: t,
    moduleMap: i,
    moduleDepth: r
  } = n;
  if (t >= 5)
    throw new Error("Possible loop in shader dependency graph");
  for (const s of e)
    i[s.name] = s, (r[s.name] === void 0 || r[s.name] < t) && (r[s.name] = t);
  for (const s of e)
    s.dependencies && sE({
      modules: s.dependencies,
      level: t + 1,
      moduleMap: i,
      moduleDepth: r
    });
}
function oE(n, e) {
  return n.map((t) => (t instanceof gx || (pa(typeof t != "string", "Shader module use by name is deprecated. Import shader module '".concat(t, "' and use it directly.")), pa(t.name, "shader module has no name"), t = new gx(t), t.dependencies = oE(t.dependencies)), t));
}
function hR() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const e = typeof window < "u" ? window.navigator || {} : {}, t = n.userAgent || e.userAgent || "", i = t.indexOf("MSIE ") !== -1, r = t.indexOf("Trident/") !== -1;
  return i || r;
}
const dR = 7936, fR = 7937, pR = 7938, gR = 35724, M1 = {
  GLSL_FRAG_DATA: ["WEBGL_draw_buffers", !0],
  GLSL_FRAG_DEPTH: ["EXT_frag_depth", !0],
  GLSL_DERIVATIVES: ["OES_standard_derivatives", !0],
  GLSL_TEXTURE_LOD: ["EXT_shader_texture_lod", !0]
}, Eh = {};
Object.keys(M1).forEach((n) => {
  Eh[n] = n;
});
function mR(n) {
  return typeof WebGL2RenderingContext < "u" && n instanceof WebGL2RenderingContext ? !0 : !!(n && n._version === 2);
}
function _R(n) {
  const e = n.getExtension("WEBGL_debug_renderer_info"), t = n.getParameter(e && e.UNMASKED_VENDOR_WEBGL || dR), i = n.getParameter(e && e.UNMASKED_RENDERER_WEBGL || fR);
  return {
    gpuVendor: yR(t, i),
    vendor: t,
    renderer: i,
    version: n.getParameter(pR),
    shadingLanguageVersion: n.getParameter(gR)
  };
}
function yR(n, e) {
  return n.match(/NVIDIA/i) || e.match(/NVIDIA/i) ? "NVIDIA" : n.match(/INTEL/i) || e.match(/INTEL/i) ? "INTEL" : n.match(/AMD/i) || e.match(/AMD/i) || n.match(/ATI/i) || e.match(/ATI/i) ? "AMD" : "UNKNOWN GPU";
}
const t_ = {};
function mx(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const i = M1[e];
  if (pa(i, e), !hR(t))
    return !0;
  if (e in t_)
    return t_[e];
  const r = i[0], s = t.behavior || "enable", c = "#extension GL_".concat(r, " : ").concat(s, `
void main(void) {}`), l = n.createShader(35633);
  n.shaderSource(l, c), n.compileShader(l);
  const m = n.getShaderParameter(l, 35713);
  return n.deleteShader(l), t_[e] = m, m;
}
function vR(n, e) {
  const t = M1[e];
  pa(t, e);
  const i = mR(n) && t[1] || t[0], r = typeof i == "string" ? !!n.getExtension(i) : i;
  return pa(r === !1 || r === !0), r;
}
function mg(n, e) {
  return e = Array.isArray(e) ? e : [e], e.every((t) => vR(n, t));
}
function bR(n) {
  switch (_R(n).gpuVendor.toLowerCase()) {
    case "nvidia":
      return `#define NVIDIA_GPU
// Nvidia optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
`;
    case "intel":
      return `#define INTEL_GPU
// Intel optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Intel's built-in 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
    case "amd":
      return `#define AMD_GPU
`;
    default:
      return `#define DEFAULT_GPU
// Prevent driver from optimizing away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Intel's built-in 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
  }
}
function xR(n, e, t) {
  let i = `#if (__VERSION__ > 120)

# define FEATURE_GLSL_DERIVATIVES
# define FEATURE_GLSL_DRAW_BUFFERS
# define FEATURE_GLSL_FRAG_DEPTH
# define FEATURE_GLSL_TEXTURE_LOD

// DEPRECATED FLAGS, remove in v9
# define FRAG_DEPTH
# define DERIVATIVES
# define DRAW_BUFFERS
# define TEXTURE_LOD

#endif // __VERSION
`;
  return mg(n, Eh.GLSL_FRAG_DEPTH) && (i += `
// FRAG_DEPTH => gl_FragDepth is available
#ifdef GL_EXT_frag_depth
#extension GL_EXT_frag_depth : enable
# define FEATURE_GLSL_FRAG_DEPTH
# define FRAG_DEPTH
# define gl_FragDepth gl_FragDepthEXT
#endif
`), mg(n, Eh.GLSL_DERIVATIVES) && mx(n, Eh.GLSL_DERIVATIVES) && (i += `
// DERIVATIVES => dxdF, dxdY and fwidth are available
#ifdef GL_OES_standard_derivatives
#extension GL_OES_standard_derivatives : enable
# define FEATURE_GLSL_DERIVATIVES
# define DERIVATIVES
#endif
`), mg(n, Eh.GLSL_FRAG_DATA) && mx(n, Eh.GLSL_FRAG_DATA, {
    behavior: "require"
  }) && (i += `
// DRAW_BUFFERS => gl_FragData[] is available
#ifdef GL_EXT_draw_buffers
#extension GL_EXT_draw_buffers : require
#define FEATURE_GLSL_DRAW_BUFFERS
#define DRAW_BUFFERS
#endif
`), mg(n, Eh.GLSL_TEXTURE_LOD) && (i += `// TEXTURE_LOD => texture2DLod etc are available
#ifdef GL_EXT_shader_texture_lod
#extension GL_EXT_shader_texture_lod : enable

# define FEATURE_GLSL_TEXTURE_LOD
# define TEXTURE_LOD

#endif
`), i;
}
const wR = `#ifdef MODULE_LOGDEPTH
  logdepth_adjustPosition(gl_Position);
#endif
`, AR = `#ifdef MODULE_MATERIAL
  gl_FragColor = material_filterColor(gl_FragColor);
#endif

#ifdef MODULE_LIGHTING
  gl_FragColor = lighting_filterColor(gl_FragColor);
#endif

#ifdef MODULE_FOG
  gl_FragColor = fog_filterColor(gl_FragColor);
#endif

#ifdef MODULE_PICKING
  gl_FragColor = picking_filterHighlightColor(gl_FragColor);
  gl_FragColor = picking_filterPickingColor(gl_FragColor);
#endif

#ifdef MODULE_LOGDEPTH
  logdepth_setFragDepth();
#endif
`, ER = {
  [Bp]: wR,
  [L1]: AR
}, Vg = "__LUMA_INJECT_DECLARATIONS__", _x = /void\s+main\s*\([^)]*\)\s*\{\n?/, yx = /}\n?[^{}]*$/, n_ = [];
function vx(n, e, t) {
  let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  const r = e === Bp;
  for (const s in t) {
    const c = t[s];
    c.sort((m, y) => m.order - y.order), n_.length = c.length;
    for (let m = 0, y = c.length; m < y; ++m)
      n_[m] = c[m].injection;
    const l = "".concat(n_.join(`
`), `
`);
    switch (s) {
      case "vs:#decl":
        r && (n = n.replace(Vg, l));
        break;
      case "vs:#main-start":
        r && (n = n.replace(_x, (m) => m + l));
        break;
      case "vs:#main-end":
        r && (n = n.replace(yx, (m) => l + m));
        break;
      case "fs:#decl":
        r || (n = n.replace(Vg, l));
        break;
      case "fs:#main-start":
        r || (n = n.replace(_x, (m) => m + l));
        break;
      case "fs:#main-end":
        r || (n = n.replace(yx, (m) => l + m));
        break;
      default:
        n = n.replace(s, (m) => m + l);
    }
  }
  return n = n.replace(Vg, ""), i && (n = n.replace(/\}\s*$/, (s) => s + ER[e])), n;
}
function dy(n) {
  const e = {};
  return pa(Array.isArray(n) && n.length > 1), n.forEach((t) => {
    for (const i in t)
      e[i] = e[i] ? "".concat(e[i], `
`).concat(t[i]) : t[i];
  }), e;
}
function qd(n) {
  return new RegExp("\\b".concat(n, "[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)"), "g");
}
const aE = [[/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, `#version 300 es
`], [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("], [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]], SR = [...aE, [qd("attribute"), "in $1"], [qd("varying"), "out $1"]], TR = [...aE, [qd("varying"), "in $1"]], lE = [[/^#version[ \t]+300[ \t]+es/, "#version 100"], [/\btexture(2D|2DProj|Cube)Lod\(/g, "texture$1LodEXT("], [/\btexture\(/g, "texture2D("], [/\btextureLod\(/g, "texture2DLodEXT("]], CR = [...lE, [qd("in"), "attribute $1"], [qd("out"), "varying $1"]], IR = [...lE, [qd("in"), "varying $1"]], fy = "gl_FragColor", py = /\bout[ \t]+vec4[ \t]+(\w+)[ \t]*;\n?/, PR = /void\s+main\s*\([^)]*\)\s*\{\n?/;
function LR(n, e, t) {
  switch (e) {
    case 300:
      return t ? pm(n, SR) : MR(n);
    case 100:
      return t ? pm(n, CR) : BR(n);
    default:
      throw new Error("unknown GLSL version ".concat(e));
  }
}
function pm(n, e) {
  for (const [t, i] of e)
    n = n.replace(t, i);
  return n;
}
function MR(n) {
  n = pm(n, TR);
  const e = n.match(py);
  if (e) {
    const t = e[1];
    n = n.replace(new RegExp("\\b".concat(fy, "\\b"), "g"), t);
  } else {
    const t = "fragmentColor";
    n = n.replace(PR, (i) => "out vec4 ".concat(t, `;
`).concat(i)).replace(new RegExp("\\b".concat(fy, "\\b"), "g"), t);
  }
  return n;
}
function BR(n) {
  n = pm(n, IR);
  const e = n.match(py);
  if (e) {
    const t = e[1];
    n = n.replace(py, "").replace(new RegExp("\\b".concat(t, "\\b"), "g"), fy);
  }
  return n;
}
const RR = `

`.concat(Vg, `

`), cE = {
  [Bp]: "vertex",
  [L1]: "fragment"
}, OR = `precision highp float;

`;
function FR(n, e) {
  const {
    vs: t,
    fs: i
  } = e, r = cR(e.modules || []);
  return {
    gl: n,
    vs: bx(n, Object.assign({}, e, {
      source: t,
      type: Bp,
      modules: r
    })),
    fs: bx(n, Object.assign({}, e, {
      source: i,
      type: L1,
      modules: r
    })),
    getUniforms: DR(r)
  };
}
function bx(n, e) {
  let {
    id: t,
    source: i,
    type: r,
    modules: s,
    defines: c = {},
    hookFunctions: l = [],
    inject: m = {},
    transpileToGLSL100: y = !1,
    prologue: A = !0,
    log: T
  } = e;
  pa(typeof i == "string", "shader source must be a string");
  const I = r === Bp, L = i.split(`
`);
  let N = 100, z = "", V = i;
  L[0].indexOf("#version ") === 0 ? (N = 300, z = L[0], V = L.slice(1).join(`
`)) : z = "#version ".concat(N);
  const H = {};
  s.forEach((Le) => {
    Object.assign(H, Le.getDefines());
  }), Object.assign(H, c);
  let J = A ? "".concat(z, `
`).concat(NR({
    id: t,
    source: i,
    type: r
  }), `
`).concat(kR({
    type: r
  }), `
`).concat(bR(n), `
`).concat(xR(n), `
`).concat(zR(H), `
`).concat(I ? "" : OR, `
`) : "".concat(z, `
`);
  const ce = jR(l), me = {}, Se = {}, De = {};
  for (const Le in m) {
    const ye = typeof m[Le] == "string" ? {
      injection: m[Le],
      order: 0
    } : m[Le], Ve = Le.match(/^(v|f)s:(#)?([\w-]+)$/);
    if (Ve) {
      const Fe = Ve[2], ae = Ve[3];
      Fe ? ae === "decl" ? Se[Le] = [ye] : De[Le] = [ye] : me[Le] = [ye];
    } else
      De[Le] = [ye];
  }
  for (const Le of s) {
    T && Le.checkDeprecations(V, T);
    const ye = Le.getModuleSource(r, N);
    J += ye;
    const Ve = Le.injections[r];
    for (const Fe in Ve) {
      const ae = Fe.match(/^(v|f)s:#([\w-]+)$/);
      if (ae) {
        const Te = ae[2] === "decl" ? Se : De;
        Te[Fe] = Te[Fe] || [], Te[Fe].push(Ve[Fe]);
      } else
        me[Fe] = me[Fe] || [], me[Fe].push(Ve[Fe]);
    }
  }
  return J += RR, J = vx(J, r, Se), J += UR(ce[r], me), J += V, J = vx(J, r, De), J = LR(J, y ? 100 : N, I), J;
}
function DR(n) {
  return function(t) {
    const i = {};
    for (const r of n) {
      const s = r.getUniforms(t, i);
      Object.assign(i, s);
    }
    return i;
  };
}
function kR(n) {
  let {
    type: e
  } = n;
  return `
#define SHADER_TYPE_`.concat(cE[e].toUpperCase(), `
`);
}
function NR(n) {
  let {
    id: e,
    source: t,
    type: i
  } = n;
  return e && typeof e == "string" && t.indexOf("SHADER_NAME") === -1 ? `
#define SHADER_NAME `.concat(e, "_").concat(cE[i], `

`) : "";
}
function zR() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = 0, t = "";
  for (const i in n) {
    e === 0 && (t += `
// APPLICATION DEFINES
`), e++;
    const r = n[i];
    (r || Number.isFinite(r)) && (t += "#define ".concat(i.toUpperCase(), " ").concat(n[i], `
`));
  }
  return e === 0 && (t += `
`), t;
}
function UR(n, e) {
  let t = "";
  for (const i in n) {
    const r = n[i];
    if (t += "void ".concat(r.signature, ` {
`), r.header && (t += "  ".concat(r.header)), e[i]) {
      const s = e[i];
      s.sort((c, l) => c.order - l.order);
      for (const c of s)
        t += "  ".concat(c.injection, `
`);
    }
    r.footer && (t += "  ".concat(r.footer)), t += `}
`;
  }
  return t;
}
function jR(n) {
  const e = {
    vs: {},
    fs: {}
  };
  return n.forEach((t) => {
    let i;
    typeof t != "string" ? (i = t, t = i.hook) : i = {}, t = t.trim();
    const [r, s] = t.split(":"), c = t.replace(/\(.+/, "");
    e[r][c] = Object.assign(i, {
      signature: s
    });
  }), e;
}
const GR = "void main() {gl_FragColor = vec4(0);}", uE = `out vec4 transform_output;
void main() {
  transform_output = vec4(0);
}`, VR = `#version 300 es
`.concat(uE);
function hE(n, e) {
  e = Array.isArray(e) ? e : [e];
  const t = n.replace(/^\s+/, "").split(/\s+/), [i, r, s] = t;
  if (!e.includes(i) || !r || !s)
    return null;
  const c = s.split(";")[0];
  return {
    qualifier: i,
    type: r,
    name: c
  };
}
function dE() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    version: e = 100,
    input: t,
    inputType: i,
    output: r
  } = n;
  if (!t)
    return e === 300 ? VR : e > 300 ? "#version ".concat(e, `
`).concat(uE) : GR;
  const s = WR(t, i);
  return e >= 300 ? "#version ".concat(e, " ").concat(e === 300 ? "es" : "", `
in `).concat(i, " ").concat(t, `;
out vec4 `).concat(r, `;
void main() {
  `).concat(r, " = ").concat(s, `;
}`) : "varying ".concat(i, " ").concat(t, `;
void main() {
  gl_FragColor = `).concat(s, `;
}`);
}
function qR(n) {
  switch (n) {
    case "float":
      return "x";
    case "vec2":
      return "xy";
    case "vec3":
      return "xyz";
    case "vec4":
      return "xyzw";
    default:
      return pa(!1), null;
  }
}
function HR(n) {
  switch (n) {
    case "float":
      return 1;
    case "vec2":
      return 2;
    case "vec3":
      return 3;
    case "vec4":
      return 4;
    default:
      return pa(!1), null;
  }
}
function WR(n, e) {
  switch (e) {
    case "float":
      return "vec4(".concat(n, ", 0.0, 0.0, 1.0)");
    case "vec2":
      return "vec4(".concat(n, ", 0.0, 1.0)");
    case "vec3":
      return "vec4(".concat(n, ", 1.0)");
    case "vec4":
      return n;
    default:
      return pa(!1), null;
  }
}
const XR = `#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
const float TWO_PI = 6.2831854820251465;
const float PI_2 = 1.5707963705062866;
const float PI_16 = 0.1963495463132858;

const float SIN_TABLE_0 = 0.19509032368659973;
const float SIN_TABLE_1 = 0.3826834261417389;
const float SIN_TABLE_2 = 0.5555702447891235;
const float SIN_TABLE_3 = 0.7071067690849304;

const float COS_TABLE_0 = 0.9807852506637573;
const float COS_TABLE_1 = 0.9238795042037964;
const float COS_TABLE_2 = 0.8314695954322815;
const float COS_TABLE_3 = 0.7071067690849304;

const float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;
const float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;
const float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;
const float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;

float sin_taylor_fp32(float a) {
  float r, s, t, x;

  if (a == 0.0) {
    return 0.0;
  }

  x = -a * a;
  s = a;
  r = a;

  r = r * x;
  t = r * INVERSE_FACTORIAL_3;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_5;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_7;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_9;
  s = s + t;

  return s;
}

void sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {
  if (a == 0.0) {
    sin_t = 0.0;
    cos_t = 1.0;
  }
  sin_t = sin_taylor_fp32(a);
  cos_t = sqrt(1.0 - sin_t * sin_t);
}

float tan_taylor_fp32(float a) {
    float sin_a;
    float cos_a;

    if (a == 0.0) {
        return 0.0;
    }
    float z = floor(a / TWO_PI);
    float r = a - TWO_PI * z;

    float t;
    float q = floor(r / PI_2 + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return 1.0 / 0.0;
    }

    t = r - PI_2 * q;

    q = floor(t / PI_16 + 0.5);
    int k = int(q);
    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return 1.0 / 0.0;
    } else {
        t = t - PI_16 * q;
    }

    float u = 0.0;
    float v = 0.0;

    float sin_t, cos_t;
    float s, c;
    sincos_taylor_fp32(t, sin_t, cos_t);

    if (k == 0) {
        s = sin_t;
        c = cos_t;
    } else {
        if (abs(float(abs_k) - 1.0) < 0.5) {
            u = COS_TABLE_0;
            v = SIN_TABLE_0;
        } else if (abs(float(abs_k) - 2.0) < 0.5) {
            u = COS_TABLE_1;
            v = SIN_TABLE_1;
        } else if (abs(float(abs_k) - 3.0) < 0.5) {
            u = COS_TABLE_2;
            v = SIN_TABLE_2;
        } else if (abs(float(abs_k) - 4.0) < 0.5) {
            u = COS_TABLE_3;
            v = SIN_TABLE_3;
        }
        if (k > 0) {
            s = u * sin_t + v * cos_t;
            c = u * cos_t - v * sin_t;
        } else {
            s = u * sin_t - v * cos_t;
            c = u * cos_t + v * sin_t;
        }
    }

    if (j == 0) {
        sin_a = s;
        cos_a = c;
    } else if (j == 1) {
        sin_a = c;
        cos_a = -s;
    } else if (j == -1) {
        sin_a = -c;
        cos_a = s;
    } else {
        sin_a = -s;
        cos_a = -c;
    }
    return sin_a / cos_a;
}
#endif

float tan_fp32(float a) {
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
  return tan_taylor_fp32(a);
#else
  return tan(a);
#endif
}
`, JR = {
  name: "fp32",
  vs: XR,
  fs: null
};
function El(n, e) {
  if (!n)
    throw new Error("math.gl assertion ".concat(e));
}
const $R = 1 / Math.PI * 180, ZR = 1 / 180 * Math.PI, rs = {
  EPSILON: 1e-12,
  debug: !1,
  precision: 4,
  printTypes: !1,
  printDegrees: !1,
  printRowMajor: !0
};
function YR(n) {
  let {
    precision: e = rs.precision
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return n = t6(n), "".concat(parseFloat(n.toPrecision(e)));
}
function $u(n) {
  return Array.isArray(n) || ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function KR(n) {
  return e6(n);
}
function QR(n) {
  return Jc(n);
}
function e6(n, e) {
  return B1(n, (t) => t * ZR, e);
}
function Jc(n, e) {
  return B1(n, (t) => t * $R, e);
}
function $c(n, e, t) {
  return B1(n, (i) => Math.max(e, Math.min(t, i)));
}
function gm(n, e, t) {
  return $u(n) ? n.map((i, r) => gm(i, e[r], t)) : t * e + (1 - t) * n;
}
function Il(n, e, t) {
  const i = rs.EPSILON;
  t && (rs.EPSILON = t);
  try {
    if (n === e)
      return !0;
    if ($u(n) && $u(e)) {
      if (n.length !== e.length)
        return !1;
      for (let r = 0; r < n.length; ++r)
        if (!Il(n[r], e[r]))
          return !1;
      return !0;
    }
    return n && n.equals ? n.equals(e) : e && e.equals ? e.equals(n) : typeof n == "number" && typeof e == "number" ? Math.abs(n - e) <= rs.EPSILON * Math.max(1, Math.abs(n), Math.abs(e)) : !1;
  } finally {
    rs.EPSILON = i;
  }
}
function t6(n) {
  return Math.round(n / rs.EPSILON) * rs.EPSILON;
}
function n6(n) {
  return n.clone ? n.clone() : new Array(n.length);
}
function B1(n, e, t) {
  if ($u(n)) {
    const i = n;
    t = t || n6(i);
    for (let r = 0; r < t.length && r < i.length; ++r)
      t[r] = e(n[r], r, t);
    return t;
  }
  return e(n);
}
function i6(n) {
  function e() {
    var t = Reflect.construct(n, Array.from(arguments));
    return Object.setPrototypeOf(t, Object.getPrototypeOf(this)), t;
  }
  return e.prototype = Object.create(n.prototype, {
    constructor: {
      value: n,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }), Object.setPrototypeOf ? Object.setPrototypeOf(e, n) : e.__proto__ = n, e;
}
class R1 extends i6(Array) {
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    for (let i = 0; i < this.ELEMENTS; ++i)
      this[i] = e[i + t];
    return this.check();
  }
  toArray() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    for (let i = 0; i < this.ELEMENTS; ++i)
      e[t + i] = this[i];
    return e;
  }
  from(e) {
    return Array.isArray(e) ? this.copy(e) : this.fromObject(e);
  }
  to(e) {
    return e === this ? this : $u(e) ? this.toArray(e) : this.toObject(e);
  }
  toTarget(e) {
    return e ? this.to(e) : this;
  }
  toFloat32Array() {
    return new Float32Array(this);
  }
  toString() {
    return this.formatString(rs);
  }
  formatString(e) {
    let t = "";
    for (let i = 0; i < this.ELEMENTS; ++i)
      t += (i > 0 ? ", " : "") + YR(this[i], e);
    return "".concat(e.printTypes ? this.constructor.name : "", "[").concat(t, "]");
  }
  equals(e) {
    if (!e || this.length !== e.length)
      return !1;
    for (let t = 0; t < this.ELEMENTS; ++t)
      if (!Il(this[t], e[t]))
        return !1;
    return !0;
  }
  exactEquals(e) {
    if (!e || this.length !== e.length)
      return !1;
    for (let t = 0; t < this.ELEMENTS; ++t)
      if (this[t] !== e[t])
        return !1;
    return !0;
  }
  negate() {
    for (let e = 0; e < this.ELEMENTS; ++e)
      this[e] = -this[e];
    return this.check();
  }
  lerp(e, t, i) {
    if (i === void 0)
      return this.lerp(this, e, t);
    for (let r = 0; r < this.ELEMENTS; ++r) {
      const s = e[r];
      this[r] = s + i * (t[r] - s);
    }
    return this.check();
  }
  min(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] = Math.min(e[t], this[t]);
    return this.check();
  }
  max(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] = Math.max(e[t], this[t]);
    return this.check();
  }
  clamp(e, t) {
    for (let i = 0; i < this.ELEMENTS; ++i)
      this[i] = Math.min(Math.max(this[i], e[i]), t[i]);
    return this.check();
  }
  add() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    for (const r of t)
      for (let s = 0; s < this.ELEMENTS; ++s)
        this[s] += r[s];
    return this.check();
  }
  subtract() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    for (const r of t)
      for (let s = 0; s < this.ELEMENTS; ++s)
        this[s] -= r[s];
    return this.check();
  }
  scale(e) {
    if (typeof e == "number")
      for (let t = 0; t < this.ELEMENTS; ++t)
        this[t] *= e;
    else
      for (let t = 0; t < this.ELEMENTS && t < e.length; ++t)
        this[t] *= e[t];
    return this.check();
  }
  multiplyByScalar(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] *= e;
    return this.check();
  }
  check() {
    if (rs.debug && !this.validate())
      throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
    return this;
  }
  validate() {
    let e = this.length === this.ELEMENTS;
    for (let t = 0; t < this.ELEMENTS; ++t)
      e = e && Number.isFinite(this[t]);
    return e;
  }
  sub(e) {
    return this.subtract(e);
  }
  setScalar(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] = e;
    return this.check();
  }
  addScalar(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] += e;
    return this.check();
  }
  subScalar(e) {
    return this.addScalar(-e);
  }
  multiplyScalar(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] *= e;
    return this.check();
  }
  divideScalar(e) {
    return this.multiplyByScalar(1 / e);
  }
  clampScalar(e, t) {
    for (let i = 0; i < this.ELEMENTS; ++i)
      this[i] = Math.min(Math.max(this[i], e), t);
    return this.check();
  }
  get elements() {
    return this;
  }
}
function r6(n, e) {
  if (n.length !== e)
    return !1;
  for (let t = 0; t < n.length; ++t)
    if (!Number.isFinite(n[t]))
      return !1;
  return !0;
}
function Ci(n) {
  if (!Number.isFinite(n))
    throw new Error("Invalid number ".concat(n));
  return n;
}
function rp(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
  if (rs.debug && !r6(n, e))
    throw new Error("math.gl: ".concat(t, " some fields set to invalid numbers'"));
  return n;
}
class O1 extends R1 {
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = Ci(e);
  }
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = Ci(e);
  }
  len() {
    return Math.sqrt(this.lengthSquared());
  }
  magnitude() {
    return this.len();
  }
  lengthSquared() {
    let e = 0;
    for (let t = 0; t < this.ELEMENTS; ++t)
      e += this[t] * this[t];
    return e;
  }
  magnitudeSquared() {
    return this.lengthSquared();
  }
  distance(e) {
    return Math.sqrt(this.distanceSquared(e));
  }
  distanceSquared(e) {
    let t = 0;
    for (let i = 0; i < this.ELEMENTS; ++i) {
      const r = this[i] - e[i];
      t += r * r;
    }
    return Ci(t);
  }
  dot(e) {
    let t = 0;
    for (let i = 0; i < this.ELEMENTS; ++i)
      t += this[i] * e[i];
    return Ci(t);
  }
  normalize() {
    const e = this.magnitude();
    if (e !== 0)
      for (let t = 0; t < this.ELEMENTS; ++t)
        this[t] /= e;
    return this.check();
  }
  multiply() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    for (const r of t)
      for (let s = 0; s < this.ELEMENTS; ++s)
        this[s] *= r[s];
    return this.check();
  }
  divide() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    for (const r of t)
      for (let s = 0; s < this.ELEMENTS; ++s)
        this[s] /= r[s];
    return this.check();
  }
  lengthSq() {
    return this.lengthSquared();
  }
  distanceTo(e) {
    return this.distance(e);
  }
  distanceToSquared(e) {
    return this.distanceSquared(e);
  }
  getComponent(e) {
    return El(e >= 0 && e < this.ELEMENTS, "index is out of range"), Ci(this[e]);
  }
  setComponent(e, t) {
    return El(e >= 0 && e < this.ELEMENTS, "index is out of range"), this[e] = t, this.check();
  }
  addVectors(e, t) {
    return this.copy(e).add(t);
  }
  subVectors(e, t) {
    return this.copy(e).subtract(t);
  }
  multiplyVectors(e, t) {
    return this.copy(e).multiply(t);
  }
  addScaledVector(e, t) {
    return this.add(new this.constructor(e).multiplyScalar(t));
  }
}
var sp = 1e-6, Pl = typeof Float32Array < "u" ? Float32Array : Array;
Math.hypot || (Math.hypot = function() {
  for (var n = 0, e = arguments.length; e--; )
    n += arguments[e] * arguments[e];
  return Math.sqrt(n);
});
function s6() {
  var n = new Pl(2);
  return Pl != Float32Array && (n[0] = 0, n[1] = 0), n;
}
function xx(n, e, t) {
  return n[0] = e[0] + t[0], n[1] = e[1] + t[1], n;
}
function o6(n, e) {
  return n[0] = -e[0], n[1] = -e[1], n;
}
function fE(n, e, t, i) {
  var r = e[0], s = e[1];
  return n[0] = r + i * (t[0] - r), n[1] = s + i * (t[1] - s), n;
}
function a6(n, e, t) {
  var i = e[0], r = e[1];
  return n[0] = t[0] * i + t[2] * r, n[1] = t[1] * i + t[3] * r, n;
}
function l6(n, e, t) {
  var i = e[0], r = e[1];
  return n[0] = t[0] * i + t[2] * r + t[4], n[1] = t[1] * i + t[3] * r + t[5], n;
}
function pE(n, e, t) {
  var i = e[0], r = e[1];
  return n[0] = t[0] * i + t[3] * r + t[6], n[1] = t[1] * i + t[4] * r + t[7], n;
}
function gE(n, e, t) {
  var i = e[0], r = e[1];
  return n[0] = t[0] * i + t[4] * r + t[12], n[1] = t[1] * i + t[5] * r + t[13], n;
}
(function() {
  var n = s6();
  return function(e, t, i, r, s, c) {
    var l, m;
    for (t || (t = 2), i || (i = 0), r ? m = Math.min(r * t + i, e.length) : m = e.length, l = i; l < m; l += t)
      n[0] = e[l], n[1] = e[l + 1], s(n, n, c), e[l] = n[0], e[l + 1] = n[1];
    return e;
  };
})();
function mE(n, e, t) {
  const i = e[0], r = e[1], s = t[3] * i + t[7] * r || 1;
  return n[0] = (t[0] * i + t[4] * r) / s, n[1] = (t[1] * i + t[5] * r) / s, n;
}
function _E(n, e, t) {
  const i = e[0], r = e[1], s = e[2], c = t[3] * i + t[7] * r + t[11] * s || 1;
  return n[0] = (t[0] * i + t[4] * r + t[8] * s) / c, n[1] = (t[1] * i + t[5] * r + t[9] * s) / c, n[2] = (t[2] * i + t[6] * r + t[10] * s) / c, n;
}
function c6(n, e, t) {
  const i = e[0], r = e[1];
  return n[0] = t[0] * i + t[2] * r, n[1] = t[1] * i + t[3] * r, n[2] = e[2], n;
}
function u6(n, e, t) {
  const i = e[0], r = e[1];
  return n[0] = t[0] * i + t[2] * r, n[1] = t[1] * i + t[3] * r, n[2] = e[2], n[3] = e[3], n;
}
function yE(n, e, t) {
  const i = e[0], r = e[1], s = e[2];
  return n[0] = t[0] * i + t[3] * r + t[6] * s, n[1] = t[1] * i + t[4] * r + t[7] * s, n[2] = t[2] * i + t[5] * r + t[8] * s, n[3] = e[3], n;
}
class F1 extends O1 {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    super(2), $u(e) && arguments.length === 1 ? this.copy(e) : (rs.debug && (Ci(e), Ci(t)), this[0] = e, this[1] = t);
  }
  set(e, t) {
    return this[0] = e, this[1] = t, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this.check();
  }
  fromObject(e) {
    return rs.debug && (Ci(e.x), Ci(e.y)), this[0] = e.x, this[1] = e.y, this.check();
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e;
  }
  get ELEMENTS() {
    return 2;
  }
  horizontalAngle() {
    return Math.atan2(this.y, this.x);
  }
  verticalAngle() {
    return Math.atan2(this.x, this.y);
  }
  transform(e) {
    return this.transformAsPoint(e);
  }
  transformAsPoint(e) {
    return gE(this, this, e), this.check();
  }
  transformAsVector(e) {
    return mE(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return pE(this, this, e), this.check();
  }
  transformByMatrix2x3(e) {
    return l6(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return a6(this, this, e), this.check();
  }
}
function vE() {
  var n = new Pl(3);
  return Pl != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0), n;
}
function bE(n) {
  var e = n[0], t = n[1], i = n[2];
  return Math.hypot(e, t, i);
}
function wx(n, e, t) {
  var i = new Pl(3);
  return i[0] = n, i[1] = e, i[2] = t, i;
}
function h6(n, e, t) {
  return n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[2] = e[2] - t[2], n;
}
function d6(n, e) {
  return n[0] = -e[0], n[1] = -e[1], n[2] = -e[2], n;
}
function f6(n, e) {
  var t = e[0], i = e[1], r = e[2], s = t * t + i * i + r * r;
  return s > 0 && (s = 1 / Math.sqrt(s)), n[0] = e[0] * s, n[1] = e[1] * s, n[2] = e[2] * s, n;
}
function D1(n, e) {
  return n[0] * e[0] + n[1] * e[1] + n[2] * e[2];
}
function qg(n, e, t) {
  var i = e[0], r = e[1], s = e[2], c = t[0], l = t[1], m = t[2];
  return n[0] = r * m - s * l, n[1] = s * c - i * m, n[2] = i * l - r * c, n;
}
function k1(n, e, t) {
  var i = e[0], r = e[1], s = e[2], c = t[3] * i + t[7] * r + t[11] * s + t[15];
  return c = c || 1, n[0] = (t[0] * i + t[4] * r + t[8] * s + t[12]) / c, n[1] = (t[1] * i + t[5] * r + t[9] * s + t[13]) / c, n[2] = (t[2] * i + t[6] * r + t[10] * s + t[14]) / c, n;
}
function xE(n, e, t) {
  var i = e[0], r = e[1], s = e[2];
  return n[0] = i * t[0] + r * t[3] + s * t[6], n[1] = i * t[1] + r * t[4] + s * t[7], n[2] = i * t[2] + r * t[5] + s * t[8], n;
}
function wE(n, e, t) {
  var i = t[0], r = t[1], s = t[2], c = t[3], l = e[0], m = e[1], y = e[2], A = r * y - s * m, T = s * l - i * y, I = i * m - r * l, L = r * I - s * T, N = s * A - i * I, z = i * T - r * A, V = c * 2;
  return A *= V, T *= V, I *= V, L *= 2, N *= 2, z *= 2, n[0] = l + A + L, n[1] = m + T + N, n[2] = y + I + z, n;
}
function p6(n, e, t, i) {
  var r = [], s = [];
  return r[0] = e[0] - t[0], r[1] = e[1] - t[1], r[2] = e[2] - t[2], s[0] = r[0], s[1] = r[1] * Math.cos(i) - r[2] * Math.sin(i), s[2] = r[1] * Math.sin(i) + r[2] * Math.cos(i), n[0] = s[0] + t[0], n[1] = s[1] + t[1], n[2] = s[2] + t[2], n;
}
function g6(n, e, t, i) {
  var r = [], s = [];
  return r[0] = e[0] - t[0], r[1] = e[1] - t[1], r[2] = e[2] - t[2], s[0] = r[2] * Math.sin(i) + r[0] * Math.cos(i), s[1] = r[1], s[2] = r[2] * Math.cos(i) - r[0] * Math.sin(i), n[0] = s[0] + t[0], n[1] = s[1] + t[1], n[2] = s[2] + t[2], n;
}
function m6(n, e, t, i) {
  var r = [], s = [];
  return r[0] = e[0] - t[0], r[1] = e[1] - t[1], r[2] = e[2] - t[2], s[0] = r[0] * Math.cos(i) - r[1] * Math.sin(i), s[1] = r[0] * Math.sin(i) + r[1] * Math.cos(i), s[2] = r[2], n[0] = s[0] + t[0], n[1] = s[1] + t[1], n[2] = s[2] + t[2], n;
}
function _6(n, e) {
  var t = n[0], i = n[1], r = n[2], s = e[0], c = e[1], l = e[2], m = Math.sqrt(t * t + i * i + r * r), y = Math.sqrt(s * s + c * c + l * l), A = m * y, T = A && D1(n, e) / A;
  return Math.acos(Math.min(Math.max(T, -1), 1));
}
var y6 = h6, v6 = bE;
(function() {
  var n = vE();
  return function(e, t, i, r, s, c) {
    var l, m;
    for (t || (t = 3), i || (i = 0), r ? m = Math.min(r * t + i, e.length) : m = e.length, l = i; l < m; l += t)
      n[0] = e[l], n[1] = e[l + 1], n[2] = e[l + 2], s(n, n, c), e[l] = n[0], e[l + 1] = n[1], e[l + 2] = n[2];
    return e;
  };
})();
const i_ = [0, 0, 0];
let _g;
class Qe extends O1 {
  static get ZERO() {
    return _g || (_g = new Qe(0, 0, 0), Object.freeze(_g)), _g;
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    super(-0, -0, -0), arguments.length === 1 && $u(e) ? this.copy(e) : (rs.debug && (Ci(e), Ci(t), Ci(i)), this[0] = e, this[1] = t, this[2] = i);
  }
  set(e, t, i) {
    return this[0] = e, this[1] = t, this[2] = i, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this.check();
  }
  fromObject(e) {
    return rs.debug && (Ci(e.x), Ci(e.y), Ci(e.z)), this[0] = e.x, this[1] = e.y, this[2] = e.z, this.check();
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e.z = this[2], e;
  }
  get ELEMENTS() {
    return 3;
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = Ci(e);
  }
  angle(e) {
    return _6(this, e);
  }
  cross(e) {
    return qg(this, this, e), this.check();
  }
  rotateX(e) {
    let {
      radians: t,
      origin: i = i_
    } = e;
    return p6(this, this, i, t), this.check();
  }
  rotateY(e) {
    let {
      radians: t,
      origin: i = i_
    } = e;
    return g6(this, this, i, t), this.check();
  }
  rotateZ(e) {
    let {
      radians: t,
      origin: i = i_
    } = e;
    return m6(this, this, i, t), this.check();
  }
  transform(e) {
    return this.transformAsPoint(e);
  }
  transformAsPoint(e) {
    return k1(this, this, e), this.check();
  }
  transformAsVector(e) {
    return _E(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return xE(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return c6(this, this, e), this.check();
  }
  transformByQuaternion(e) {
    return wE(this, this, e), this.check();
  }
}
let yg;
class N1 extends O1 {
  static get ZERO() {
    return yg || (yg = new N1(0, 0, 0, 0), Object.freeze(yg)), yg;
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    super(-0, -0, -0, -0), $u(e) && arguments.length === 1 ? this.copy(e) : (rs.debug && (Ci(e), Ci(t), Ci(i), Ci(r)), this[0] = e, this[1] = t, this[2] = i, this[3] = r);
  }
  set(e, t, i, r) {
    return this[0] = e, this[1] = t, this[2] = i, this[3] = r, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this.check();
  }
  fromObject(e) {
    return rs.debug && (Ci(e.x), Ci(e.y), Ci(e.z), Ci(e.w)), this[0] = e.x, this[1] = e.y, this[2] = e.z, this[3] = e.w, this;
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e.z = this[2], e.w = this[3], e;
  }
  get ELEMENTS() {
    return 4;
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = Ci(e);
  }
  get w() {
    return this[3];
  }
  set w(e) {
    this[3] = Ci(e);
  }
  transform(e) {
    return k1(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return yE(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return u6(this, this, e), this.check();
  }
  transformByQuaternion(e) {
    return wE(this, this, e), this.check();
  }
  applyMatrix4(e) {
    return e.transform(this, this), this;
  }
}
class AE extends R1 {
  toString() {
    let e = "[";
    if (rs.printRowMajor) {
      e += "row-major:";
      for (let t = 0; t < this.RANK; ++t)
        for (let i = 0; i < this.RANK; ++i)
          e += " ".concat(this[i * this.RANK + t]);
    } else {
      e += "column-major:";
      for (let t = 0; t < this.ELEMENTS; ++t)
        e += " ".concat(this[t]);
    }
    return e += "]", e;
  }
  getElementIndex(e, t) {
    return t * this.RANK + e;
  }
  getElement(e, t) {
    return this[t * this.RANK + e];
  }
  setElement(e, t, i) {
    return this[t * this.RANK + e] = Ci(i), this;
  }
  getColumn(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Array(this.RANK).fill(-0);
    const i = e * this.RANK;
    for (let r = 0; r < this.RANK; ++r)
      t[r] = this[i + r];
    return t;
  }
  setColumn(e, t) {
    const i = e * this.RANK;
    for (let r = 0; r < this.RANK; ++r)
      this[i + r] = t[r];
    return this;
  }
}
function b6() {
  var n = new Pl(9);
  return Pl != Float32Array && (n[1] = 0, n[2] = 0, n[3] = 0, n[5] = 0, n[6] = 0, n[7] = 0), n[0] = 1, n[4] = 1, n[8] = 1, n;
}
function x6(n, e) {
  if (n === e) {
    var t = e[1], i = e[2], r = e[5];
    n[1] = e[3], n[2] = e[6], n[3] = t, n[5] = e[7], n[6] = i, n[7] = r;
  } else
    n[0] = e[0], n[1] = e[3], n[2] = e[6], n[3] = e[1], n[4] = e[4], n[5] = e[7], n[6] = e[2], n[7] = e[5], n[8] = e[8];
  return n;
}
function w6(n, e) {
  var t = e[0], i = e[1], r = e[2], s = e[3], c = e[4], l = e[5], m = e[6], y = e[7], A = e[8], T = A * c - l * y, I = -A * s + l * m, L = y * s - c * m, N = t * T + i * I + r * L;
  return N ? (N = 1 / N, n[0] = T * N, n[1] = (-A * i + r * y) * N, n[2] = (l * i - r * c) * N, n[3] = I * N, n[4] = (A * t - r * m) * N, n[5] = (-l * t + r * s) * N, n[6] = L * N, n[7] = (-y * t + i * m) * N, n[8] = (c * t - i * s) * N, n) : null;
}
function A6(n) {
  var e = n[0], t = n[1], i = n[2], r = n[3], s = n[4], c = n[5], l = n[6], m = n[7], y = n[8];
  return e * (y * s - c * m) + t * (-y * r + c * l) + i * (m * r - s * l);
}
function Ax(n, e, t) {
  var i = e[0], r = e[1], s = e[2], c = e[3], l = e[4], m = e[5], y = e[6], A = e[7], T = e[8], I = t[0], L = t[1], N = t[2], z = t[3], V = t[4], H = t[5], J = t[6], ce = t[7], me = t[8];
  return n[0] = I * i + L * c + N * y, n[1] = I * r + L * l + N * A, n[2] = I * s + L * m + N * T, n[3] = z * i + V * c + H * y, n[4] = z * r + V * l + H * A, n[5] = z * s + V * m + H * T, n[6] = J * i + ce * c + me * y, n[7] = J * r + ce * l + me * A, n[8] = J * s + ce * m + me * T, n;
}
function E6(n, e, t) {
  var i = e[0], r = e[1], s = e[2], c = e[3], l = e[4], m = e[5], y = e[6], A = e[7], T = e[8], I = t[0], L = t[1];
  return n[0] = i, n[1] = r, n[2] = s, n[3] = c, n[4] = l, n[5] = m, n[6] = I * i + L * c + y, n[7] = I * r + L * l + A, n[8] = I * s + L * m + T, n;
}
function S6(n, e, t) {
  var i = e[0], r = e[1], s = e[2], c = e[3], l = e[4], m = e[5], y = e[6], A = e[7], T = e[8], I = Math.sin(t), L = Math.cos(t);
  return n[0] = L * i + I * c, n[1] = L * r + I * l, n[2] = L * s + I * m, n[3] = L * c - I * i, n[4] = L * l - I * r, n[5] = L * m - I * s, n[6] = y, n[7] = A, n[8] = T, n;
}
function Ex(n, e, t) {
  var i = t[0], r = t[1];
  return n[0] = i * e[0], n[1] = i * e[1], n[2] = i * e[2], n[3] = r * e[3], n[4] = r * e[4], n[5] = r * e[5], n[6] = e[6], n[7] = e[7], n[8] = e[8], n;
}
function T6(n, e) {
  var t = e[0], i = e[1], r = e[2], s = e[3], c = t + t, l = i + i, m = r + r, y = t * c, A = i * c, T = i * l, I = r * c, L = r * l, N = r * m, z = s * c, V = s * l, H = s * m;
  return n[0] = 1 - T - N, n[3] = A - H, n[6] = I + V, n[1] = A + H, n[4] = 1 - y - N, n[7] = L - z, n[2] = I - V, n[5] = L + z, n[8] = 1 - y - T, n;
}
var gy;
(function(n) {
  n[n.COL0ROW0 = 0] = "COL0ROW0", n[n.COL0ROW1 = 1] = "COL0ROW1", n[n.COL0ROW2 = 2] = "COL0ROW2", n[n.COL1ROW0 = 3] = "COL1ROW0", n[n.COL1ROW1 = 4] = "COL1ROW1", n[n.COL1ROW2 = 5] = "COL1ROW2", n[n.COL2ROW0 = 6] = "COL2ROW0", n[n.COL2ROW1 = 7] = "COL2ROW1", n[n.COL2ROW2 = 8] = "COL2ROW2";
})(gy || (gy = {}));
const C6 = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
class Ir extends AE {
  static get IDENTITY() {
    return P6();
  }
  static get ZERO() {
    return I6();
  }
  get ELEMENTS() {
    return 9;
  }
  get RANK() {
    return 3;
  }
  get INDICES() {
    return gy;
  }
  constructor(e) {
    for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
      i[r - 1] = arguments[r];
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(e) ? this.copy(e) : i.length > 0 ? this.copy([e, ...i]) : this.identity();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this[4] = e[4], this[5] = e[5], this[6] = e[6], this[7] = e[7], this[8] = e[8], this.check();
  }
  identity() {
    return this.copy(C6);
  }
  fromObject(e) {
    return this.check();
  }
  fromQuaternion(e) {
    return T6(this, e), this.check();
  }
  set(e, t, i, r, s, c, l, m, y) {
    return this[0] = e, this[1] = t, this[2] = i, this[3] = r, this[4] = s, this[5] = c, this[6] = l, this[7] = m, this[8] = y, this.check();
  }
  setRowMajor(e, t, i, r, s, c, l, m, y) {
    return this[0] = e, this[1] = r, this[2] = l, this[3] = t, this[4] = s, this[5] = m, this[6] = i, this[7] = c, this[8] = y, this.check();
  }
  determinant() {
    return A6(this);
  }
  transpose() {
    return x6(this, this), this.check();
  }
  invert() {
    return w6(this, this), this.check();
  }
  multiplyLeft(e) {
    return Ax(this, e, this), this.check();
  }
  multiplyRight(e) {
    return Ax(this, this, e), this.check();
  }
  rotate(e) {
    return S6(this, this, e), this.check();
  }
  scale(e) {
    return Array.isArray(e) ? Ex(this, this, e) : Ex(this, this, [e, e]), this.check();
  }
  translate(e) {
    return E6(this, this, e), this.check();
  }
  transform(e, t) {
    let i;
    switch (e.length) {
      case 2:
        i = pE(t || [-0, -0], e, this);
        break;
      case 3:
        i = xE(t || [-0, -0, -0], e, this);
        break;
      case 4:
        i = yE(t || [-0, -0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return rp(i, e.length), i;
  }
  transformVector(e, t) {
    return this.transform(e, t);
  }
  transformVector2(e, t) {
    return this.transform(e, t);
  }
  transformVector3(e, t) {
    return this.transform(e, t);
  }
}
let vg, bg;
function I6() {
  return vg || (vg = new Ir([0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(vg)), vg;
}
function P6() {
  return bg || (bg = new Ir(), Object.freeze(bg)), bg;
}
function L6(n) {
  return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = 1, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 1, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n;
}
function M6(n, e) {
  if (n === e) {
    var t = e[1], i = e[2], r = e[3], s = e[6], c = e[7], l = e[11];
    n[1] = e[4], n[2] = e[8], n[3] = e[12], n[4] = t, n[6] = e[9], n[7] = e[13], n[8] = i, n[9] = s, n[11] = e[14], n[12] = r, n[13] = c, n[14] = l;
  } else
    n[0] = e[0], n[1] = e[4], n[2] = e[8], n[3] = e[12], n[4] = e[1], n[5] = e[5], n[6] = e[9], n[7] = e[13], n[8] = e[2], n[9] = e[6], n[10] = e[10], n[11] = e[14], n[12] = e[3], n[13] = e[7], n[14] = e[11], n[15] = e[15];
  return n;
}
function my(n, e) {
  var t = e[0], i = e[1], r = e[2], s = e[3], c = e[4], l = e[5], m = e[6], y = e[7], A = e[8], T = e[9], I = e[10], L = e[11], N = e[12], z = e[13], V = e[14], H = e[15], J = t * l - i * c, ce = t * m - r * c, me = t * y - s * c, Se = i * m - r * l, De = i * y - s * l, Le = r * y - s * m, ye = A * z - T * N, Ve = A * V - I * N, Fe = A * H - L * N, ae = T * V - I * z, de = T * H - L * z, Te = I * H - L * V, be = J * Te - ce * de + me * ae + Se * Fe - De * Ve + Le * ye;
  return be ? (be = 1 / be, n[0] = (l * Te - m * de + y * ae) * be, n[1] = (r * de - i * Te - s * ae) * be, n[2] = (z * Le - V * De + H * Se) * be, n[3] = (I * De - T * Le - L * Se) * be, n[4] = (m * Fe - c * Te - y * Ve) * be, n[5] = (t * Te - r * Fe + s * Ve) * be, n[6] = (V * me - N * Le - H * ce) * be, n[7] = (A * Le - I * me + L * ce) * be, n[8] = (c * de - l * Fe + y * ye) * be, n[9] = (i * Fe - t * de - s * ye) * be, n[10] = (N * De - z * me + H * J) * be, n[11] = (T * me - A * De - L * J) * be, n[12] = (l * Ve - c * ae - m * ye) * be, n[13] = (t * ae - i * Ve + r * ye) * be, n[14] = (z * ce - N * Se - V * J) * be, n[15] = (A * Se - T * ce + I * J) * be, n) : null;
}
function B6(n) {
  var e = n[0], t = n[1], i = n[2], r = n[3], s = n[4], c = n[5], l = n[6], m = n[7], y = n[8], A = n[9], T = n[10], I = n[11], L = n[12], N = n[13], z = n[14], V = n[15], H = e * c - t * s, J = e * l - i * s, ce = e * m - r * s, me = t * l - i * c, Se = t * m - r * c, De = i * m - r * l, Le = y * N - A * L, ye = y * z - T * L, Ve = y * V - I * L, Fe = A * z - T * N, ae = A * V - I * N, de = T * V - I * z;
  return H * de - J * ae + ce * Fe + me * Ve - Se * ye + De * Le;
}
function Oh(n, e, t) {
  var i = e[0], r = e[1], s = e[2], c = e[3], l = e[4], m = e[5], y = e[6], A = e[7], T = e[8], I = e[9], L = e[10], N = e[11], z = e[12], V = e[13], H = e[14], J = e[15], ce = t[0], me = t[1], Se = t[2], De = t[3];
  return n[0] = ce * i + me * l + Se * T + De * z, n[1] = ce * r + me * m + Se * I + De * V, n[2] = ce * s + me * y + Se * L + De * H, n[3] = ce * c + me * A + Se * N + De * J, ce = t[4], me = t[5], Se = t[6], De = t[7], n[4] = ce * i + me * l + Se * T + De * z, n[5] = ce * r + me * m + Se * I + De * V, n[6] = ce * s + me * y + Se * L + De * H, n[7] = ce * c + me * A + Se * N + De * J, ce = t[8], me = t[9], Se = t[10], De = t[11], n[8] = ce * i + me * l + Se * T + De * z, n[9] = ce * r + me * m + Se * I + De * V, n[10] = ce * s + me * y + Se * L + De * H, n[11] = ce * c + me * A + Se * N + De * J, ce = t[12], me = t[13], Se = t[14], De = t[15], n[12] = ce * i + me * l + Se * T + De * z, n[13] = ce * r + me * m + Se * I + De * V, n[14] = ce * s + me * y + Se * L + De * H, n[15] = ce * c + me * A + Se * N + De * J, n;
}
function mm(n, e, t) {
  var i = t[0], r = t[1], s = t[2], c, l, m, y, A, T, I, L, N, z, V, H;
  return e === n ? (n[12] = e[0] * i + e[4] * r + e[8] * s + e[12], n[13] = e[1] * i + e[5] * r + e[9] * s + e[13], n[14] = e[2] * i + e[6] * r + e[10] * s + e[14], n[15] = e[3] * i + e[7] * r + e[11] * s + e[15]) : (c = e[0], l = e[1], m = e[2], y = e[3], A = e[4], T = e[5], I = e[6], L = e[7], N = e[8], z = e[9], V = e[10], H = e[11], n[0] = c, n[1] = l, n[2] = m, n[3] = y, n[4] = A, n[5] = T, n[6] = I, n[7] = L, n[8] = N, n[9] = z, n[10] = V, n[11] = H, n[12] = c * i + A * r + N * s + e[12], n[13] = l * i + T * r + z * s + e[13], n[14] = m * i + I * r + V * s + e[14], n[15] = y * i + L * r + H * s + e[15]), n;
}
function z1(n, e, t) {
  var i = t[0], r = t[1], s = t[2];
  return n[0] = e[0] * i, n[1] = e[1] * i, n[2] = e[2] * i, n[3] = e[3] * i, n[4] = e[4] * r, n[5] = e[5] * r, n[6] = e[6] * r, n[7] = e[7] * r, n[8] = e[8] * s, n[9] = e[9] * s, n[10] = e[10] * s, n[11] = e[11] * s, n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15], n;
}
function R6(n, e, t, i) {
  var r = i[0], s = i[1], c = i[2], l = Math.hypot(r, s, c), m, y, A, T, I, L, N, z, V, H, J, ce, me, Se, De, Le, ye, Ve, Fe, ae, de, Te, be, tt;
  return l < sp ? null : (l = 1 / l, r *= l, s *= l, c *= l, m = Math.sin(t), y = Math.cos(t), A = 1 - y, T = e[0], I = e[1], L = e[2], N = e[3], z = e[4], V = e[5], H = e[6], J = e[7], ce = e[8], me = e[9], Se = e[10], De = e[11], Le = r * r * A + y, ye = s * r * A + c * m, Ve = c * r * A - s * m, Fe = r * s * A - c * m, ae = s * s * A + y, de = c * s * A + r * m, Te = r * c * A + s * m, be = s * c * A - r * m, tt = c * c * A + y, n[0] = T * Le + z * ye + ce * Ve, n[1] = I * Le + V * ye + me * Ve, n[2] = L * Le + H * ye + Se * Ve, n[3] = N * Le + J * ye + De * Ve, n[4] = T * Fe + z * ae + ce * de, n[5] = I * Fe + V * ae + me * de, n[6] = L * Fe + H * ae + Se * de, n[7] = N * Fe + J * ae + De * de, n[8] = T * Te + z * be + ce * tt, n[9] = I * Te + V * be + me * tt, n[10] = L * Te + H * be + Se * tt, n[11] = N * Te + J * be + De * tt, e !== n && (n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15]), n);
}
function EE(n, e, t) {
  var i = Math.sin(t), r = Math.cos(t), s = e[4], c = e[5], l = e[6], m = e[7], y = e[8], A = e[9], T = e[10], I = e[11];
  return e !== n && (n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15]), n[4] = s * r + y * i, n[5] = c * r + A * i, n[6] = l * r + T * i, n[7] = m * r + I * i, n[8] = y * r - s * i, n[9] = A * r - c * i, n[10] = T * r - l * i, n[11] = I * r - m * i, n;
}
function O6(n, e, t) {
  var i = Math.sin(t), r = Math.cos(t), s = e[0], c = e[1], l = e[2], m = e[3], y = e[8], A = e[9], T = e[10], I = e[11];
  return e !== n && (n[4] = e[4], n[5] = e[5], n[6] = e[6], n[7] = e[7], n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15]), n[0] = s * r - y * i, n[1] = c * r - A * i, n[2] = l * r - T * i, n[3] = m * r - I * i, n[8] = s * i + y * r, n[9] = c * i + A * r, n[10] = l * i + T * r, n[11] = m * i + I * r, n;
}
function SE(n, e, t) {
  var i = Math.sin(t), r = Math.cos(t), s = e[0], c = e[1], l = e[2], m = e[3], y = e[4], A = e[5], T = e[6], I = e[7];
  return e !== n && (n[8] = e[8], n[9] = e[9], n[10] = e[10], n[11] = e[11], n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15]), n[0] = s * r + y * i, n[1] = c * r + A * i, n[2] = l * r + T * i, n[3] = m * r + I * i, n[4] = y * r - s * i, n[5] = A * r - c * i, n[6] = T * r - l * i, n[7] = I * r - m * i, n;
}
function F6(n, e) {
  var t = e[0], i = e[1], r = e[2], s = e[4], c = e[5], l = e[6], m = e[8], y = e[9], A = e[10];
  return n[0] = Math.hypot(t, i, r), n[1] = Math.hypot(s, c, l), n[2] = Math.hypot(m, y, A), n;
}
function D6(n, e) {
  var t = e[0], i = e[1], r = e[2], s = e[3], c = t + t, l = i + i, m = r + r, y = t * c, A = i * c, T = i * l, I = r * c, L = r * l, N = r * m, z = s * c, V = s * l, H = s * m;
  return n[0] = 1 - T - N, n[1] = A + H, n[2] = I - V, n[3] = 0, n[4] = A - H, n[5] = 1 - y - N, n[6] = L + z, n[7] = 0, n[8] = I + V, n[9] = L - z, n[10] = 1 - y - T, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n;
}
function k6(n, e, t, i, r, s, c) {
  var l = 1 / (t - e), m = 1 / (r - i), y = 1 / (s - c);
  return n[0] = s * 2 * l, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = s * 2 * m, n[6] = 0, n[7] = 0, n[8] = (t + e) * l, n[9] = (r + i) * m, n[10] = (c + s) * y, n[11] = -1, n[12] = 0, n[13] = 0, n[14] = c * s * 2 * y, n[15] = 0, n;
}
function N6(n, e, t, i, r) {
  var s = 1 / Math.tan(e / 2), c;
  return n[0] = s / t, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = s, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[11] = -1, n[12] = 0, n[13] = 0, n[15] = 0, r != null && r !== 1 / 0 ? (c = 1 / (i - r), n[10] = (r + i) * c, n[14] = 2 * r * i * c) : (n[10] = -1, n[14] = -2 * i), n;
}
var z6 = N6;
function U6(n, e, t, i, r, s, c) {
  var l = 1 / (e - t), m = 1 / (i - r), y = 1 / (s - c);
  return n[0] = -2 * l, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = -2 * m, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 2 * y, n[11] = 0, n[12] = (e + t) * l, n[13] = (r + i) * m, n[14] = (c + s) * y, n[15] = 1, n;
}
var j6 = U6;
function G6(n, e, t, i) {
  var r, s, c, l, m, y, A, T, I, L, N = e[0], z = e[1], V = e[2], H = i[0], J = i[1], ce = i[2], me = t[0], Se = t[1], De = t[2];
  return Math.abs(N - me) < sp && Math.abs(z - Se) < sp && Math.abs(V - De) < sp ? L6(n) : (A = N - me, T = z - Se, I = V - De, L = 1 / Math.hypot(A, T, I), A *= L, T *= L, I *= L, r = J * I - ce * T, s = ce * A - H * I, c = H * T - J * A, L = Math.hypot(r, s, c), L ? (L = 1 / L, r *= L, s *= L, c *= L) : (r = 0, s = 0, c = 0), l = T * c - I * s, m = I * r - A * c, y = A * s - T * r, L = Math.hypot(l, m, y), L ? (L = 1 / L, l *= L, m *= L, y *= L) : (l = 0, m = 0, y = 0), n[0] = r, n[1] = l, n[2] = A, n[3] = 0, n[4] = s, n[5] = m, n[6] = T, n[7] = 0, n[8] = c, n[9] = y, n[10] = I, n[11] = 0, n[12] = -(r * N + s * z + c * V), n[13] = -(l * N + m * z + y * V), n[14] = -(A * N + T * z + I * V), n[15] = 1, n);
}
function V6() {
  var n = new Pl(4);
  return Pl != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 0), n;
}
function q6(n, e, t) {
  return n[0] = e[0] + t[0], n[1] = e[1] + t[1], n[2] = e[2] + t[2], n[3] = e[3] + t[3], n;
}
function TE(n, e, t) {
  return n[0] = e[0] * t, n[1] = e[1] * t, n[2] = e[2] * t, n[3] = e[3] * t, n;
}
function H6(n) {
  var e = n[0], t = n[1], i = n[2], r = n[3];
  return Math.hypot(e, t, i, r);
}
function W6(n) {
  var e = n[0], t = n[1], i = n[2], r = n[3];
  return e * e + t * t + i * i + r * r;
}
function X6(n, e) {
  var t = e[0], i = e[1], r = e[2], s = e[3], c = t * t + i * i + r * r + s * s;
  return c > 0 && (c = 1 / Math.sqrt(c)), n[0] = t * c, n[1] = i * c, n[2] = r * c, n[3] = s * c, n;
}
function J6(n, e) {
  return n[0] * e[0] + n[1] * e[1] + n[2] * e[2] + n[3] * e[3];
}
function $6(n, e, t, i) {
  var r = e[0], s = e[1], c = e[2], l = e[3];
  return n[0] = r + i * (t[0] - r), n[1] = s + i * (t[1] - s), n[2] = c + i * (t[2] - c), n[3] = l + i * (t[3] - l), n;
}
function Rp(n, e, t) {
  var i = e[0], r = e[1], s = e[2], c = e[3];
  return n[0] = t[0] * i + t[4] * r + t[8] * s + t[12] * c, n[1] = t[1] * i + t[5] * r + t[9] * s + t[13] * c, n[2] = t[2] * i + t[6] * r + t[10] * s + t[14] * c, n[3] = t[3] * i + t[7] * r + t[11] * s + t[15] * c, n;
}
function Z6(n, e, t) {
  var i = e[0], r = e[1], s = e[2], c = t[0], l = t[1], m = t[2], y = t[3], A = y * i + l * s - m * r, T = y * r + m * i - c * s, I = y * s + c * r - l * i, L = -c * i - l * r - m * s;
  return n[0] = A * y + L * -c + T * -m - I * -l, n[1] = T * y + L * -l + I * -c - A * -m, n[2] = I * y + L * -m + A * -l - T * -c, n[3] = e[3], n;
}
(function() {
  var n = V6();
  return function(e, t, i, r, s, c) {
    var l, m;
    for (t || (t = 4), i || (i = 0), r ? m = Math.min(r * t + i, e.length) : m = e.length, l = i; l < m; l += t)
      n[0] = e[l], n[1] = e[l + 1], n[2] = e[l + 2], n[3] = e[l + 3], s(n, n, c), e[l] = n[0], e[l + 1] = n[1], e[l + 2] = n[2], e[l + 3] = n[3];
    return e;
  };
})();
var _y;
(function(n) {
  n[n.COL0ROW0 = 0] = "COL0ROW0", n[n.COL0ROW1 = 1] = "COL0ROW1", n[n.COL0ROW2 = 2] = "COL0ROW2", n[n.COL0ROW3 = 3] = "COL0ROW3", n[n.COL1ROW0 = 4] = "COL1ROW0", n[n.COL1ROW1 = 5] = "COL1ROW1", n[n.COL1ROW2 = 6] = "COL1ROW2", n[n.COL1ROW3 = 7] = "COL1ROW3", n[n.COL2ROW0 = 8] = "COL2ROW0", n[n.COL2ROW1 = 9] = "COL2ROW1", n[n.COL2ROW2 = 10] = "COL2ROW2", n[n.COL2ROW3 = 11] = "COL2ROW3", n[n.COL3ROW0 = 12] = "COL3ROW0", n[n.COL3ROW1 = 13] = "COL3ROW1", n[n.COL3ROW2 = 14] = "COL3ROW2", n[n.COL3ROW3 = 15] = "COL3ROW3";
})(_y || (_y = {}));
const Y6 = 45 * Math.PI / 180, K6 = 1, r_ = 0.1, s_ = 500, Q6 = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
class ai extends AE {
  static get IDENTITY() {
    return tO();
  }
  static get ZERO() {
    return eO();
  }
  get ELEMENTS() {
    return 16;
  }
  get RANK() {
    return 4;
  }
  get INDICES() {
    return _y;
  }
  constructor(e) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(e) ? this.copy(e) : this.identity();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this[4] = e[4], this[5] = e[5], this[6] = e[6], this[7] = e[7], this[8] = e[8], this[9] = e[9], this[10] = e[10], this[11] = e[11], this[12] = e[12], this[13] = e[13], this[14] = e[14], this[15] = e[15], this.check();
  }
  set(e, t, i, r, s, c, l, m, y, A, T, I, L, N, z, V) {
    return this[0] = e, this[1] = t, this[2] = i, this[3] = r, this[4] = s, this[5] = c, this[6] = l, this[7] = m, this[8] = y, this[9] = A, this[10] = T, this[11] = I, this[12] = L, this[13] = N, this[14] = z, this[15] = V, this.check();
  }
  setRowMajor(e, t, i, r, s, c, l, m, y, A, T, I, L, N, z, V) {
    return this[0] = e, this[1] = s, this[2] = y, this[3] = L, this[4] = t, this[5] = c, this[6] = A, this[7] = N, this[8] = i, this[9] = l, this[10] = T, this[11] = z, this[12] = r, this[13] = m, this[14] = I, this[15] = V, this.check();
  }
  toRowMajor(e) {
    return e[0] = this[0], e[1] = this[4], e[2] = this[8], e[3] = this[12], e[4] = this[1], e[5] = this[5], e[6] = this[9], e[7] = this[13], e[8] = this[2], e[9] = this[6], e[10] = this[10], e[11] = this[14], e[12] = this[3], e[13] = this[7], e[14] = this[11], e[15] = this[15], e;
  }
  identity() {
    return this.copy(Q6);
  }
  fromObject(e) {
    return this.check();
  }
  fromQuaternion(e) {
    return D6(this, e), this.check();
  }
  frustum(e) {
    const {
      left: t,
      right: i,
      bottom: r,
      top: s,
      near: c = r_,
      far: l = s_
    } = e;
    return l === 1 / 0 ? nO(this, t, i, r, s, c) : k6(this, t, i, r, s, c, l), this.check();
  }
  lookAt(e) {
    const {
      eye: t,
      center: i = [0, 0, 0],
      up: r = [0, 1, 0]
    } = e;
    return G6(this, t, i, r), this.check();
  }
  ortho(e) {
    const {
      left: t,
      right: i,
      bottom: r,
      top: s,
      near: c = r_,
      far: l = s_
    } = e;
    return j6(this, t, i, r, s, c, l), this.check();
  }
  orthographic(e) {
    const {
      fovy: t = Y6,
      aspect: i = K6,
      focalDistance: r = 1,
      near: s = r_,
      far: c = s_
    } = e;
    Sx(t);
    const l = t / 2, m = r * Math.tan(l), y = m * i;
    return this.ortho({
      left: -y,
      right: y,
      bottom: -m,
      top: m,
      near: s,
      far: c
    });
  }
  perspective(e) {
    const {
      fovy: t = 45 * Math.PI / 180,
      aspect: i = 1,
      near: r = 0.1,
      far: s = 500
    } = e;
    return Sx(t), z6(this, t, i, r, s), this.check();
  }
  determinant() {
    return B6(this);
  }
  getScale() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [-0, -0, -0];
    return e[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]), e[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]), e[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]), e;
  }
  getTranslation() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [-0, -0, -0];
    return e[0] = this[12], e[1] = this[13], e[2] = this[14], e;
  }
  getRotation(e, t) {
    e = e || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0], t = t || [-0, -0, -0];
    const i = this.getScale(t), r = 1 / i[0], s = 1 / i[1], c = 1 / i[2];
    return e[0] = this[0] * r, e[1] = this[1] * s, e[2] = this[2] * c, e[3] = 0, e[4] = this[4] * r, e[5] = this[5] * s, e[6] = this[6] * c, e[7] = 0, e[8] = this[8] * r, e[9] = this[9] * s, e[10] = this[10] * c, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  getRotationMatrix3(e, t) {
    e = e || [-0, -0, -0, -0, -0, -0, -0, -0, -0], t = t || [-0, -0, -0];
    const i = this.getScale(t), r = 1 / i[0], s = 1 / i[1], c = 1 / i[2];
    return e[0] = this[0] * r, e[1] = this[1] * s, e[2] = this[2] * c, e[3] = this[4] * r, e[4] = this[5] * s, e[5] = this[6] * c, e[6] = this[8] * r, e[7] = this[9] * s, e[8] = this[10] * c, e;
  }
  transpose() {
    return M6(this, this), this.check();
  }
  invert() {
    return my(this, this), this.check();
  }
  multiplyLeft(e) {
    return Oh(this, e, this), this.check();
  }
  multiplyRight(e) {
    return Oh(this, this, e), this.check();
  }
  rotateX(e) {
    return EE(this, this, e), this.check();
  }
  rotateY(e) {
    return O6(this, this, e), this.check();
  }
  rotateZ(e) {
    return SE(this, this, e), this.check();
  }
  rotateXYZ(e) {
    return this.rotateX(e[0]).rotateY(e[1]).rotateZ(e[2]);
  }
  rotateAxis(e, t) {
    return R6(this, this, e, t), this.check();
  }
  scale(e) {
    return z1(this, this, Array.isArray(e) ? e : [e, e, e]), this.check();
  }
  translate(e) {
    return mm(this, this, e), this.check();
  }
  transform(e, t) {
    return e.length === 4 ? (t = Rp(t || [-0, -0, -0, -0], e, this), rp(t, 4), t) : this.transformAsPoint(e, t);
  }
  transformAsPoint(e, t) {
    const {
      length: i
    } = e;
    let r;
    switch (i) {
      case 2:
        r = gE(t || [-0, -0], e, this);
        break;
      case 3:
        r = k1(t || [-0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return rp(r, e.length), r;
  }
  transformAsVector(e, t) {
    let i;
    switch (e.length) {
      case 2:
        i = mE(t || [-0, -0], e, this);
        break;
      case 3:
        i = _E(t || [-0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return rp(i, e.length), i;
  }
  transformPoint(e, t) {
    return this.transformAsPoint(e, t);
  }
  transformVector(e, t) {
    return this.transformAsPoint(e, t);
  }
  transformDirection(e, t) {
    return this.transformAsVector(e, t);
  }
  makeRotationX(e) {
    return this.identity().rotateX(e);
  }
  makeTranslation(e, t, i) {
    return this.identity().translate([e, t, i]);
  }
}
let xg, wg;
function eO() {
  return xg || (xg = new ai([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(xg)), xg;
}
function tO() {
  return wg || (wg = new ai(), Object.freeze(wg)), wg;
}
function Sx(n) {
  if (n > Math.PI * 2)
    throw Error("expected radians");
}
function nO(n, e, t, i, r, s) {
  const c = 2 * s / (t - e), l = 2 * s / (r - i), m = (t + e) / (t - e), y = (r + i) / (r - i), A = -1, T = -1, I = -2 * s;
  return n[0] = c, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = l, n[6] = 0, n[7] = 0, n[8] = m, n[9] = y, n[10] = A, n[11] = T, n[12] = 0, n[13] = 0, n[14] = I, n[15] = 0, n;
}
function Tx() {
  var n = new Pl(4);
  return Pl != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0), n[3] = 1, n;
}
function iO(n) {
  return n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 1, n;
}
function CE(n, e, t) {
  t = t * 0.5;
  var i = Math.sin(t);
  return n[0] = i * e[0], n[1] = i * e[1], n[2] = i * e[2], n[3] = Math.cos(t), n;
}
function Cx(n, e, t) {
  var i = e[0], r = e[1], s = e[2], c = e[3], l = t[0], m = t[1], y = t[2], A = t[3];
  return n[0] = i * A + c * l + r * y - s * m, n[1] = r * A + c * m + s * l - i * y, n[2] = s * A + c * y + i * m - r * l, n[3] = c * A - i * l - r * m - s * y, n;
}
function rO(n, e, t) {
  t *= 0.5;
  var i = e[0], r = e[1], s = e[2], c = e[3], l = Math.sin(t), m = Math.cos(t);
  return n[0] = i * m + c * l, n[1] = r * m + s * l, n[2] = s * m - r * l, n[3] = c * m - i * l, n;
}
function sO(n, e, t) {
  t *= 0.5;
  var i = e[0], r = e[1], s = e[2], c = e[3], l = Math.sin(t), m = Math.cos(t);
  return n[0] = i * m - s * l, n[1] = r * m + c * l, n[2] = s * m + i * l, n[3] = c * m - r * l, n;
}
function oO(n, e, t) {
  t *= 0.5;
  var i = e[0], r = e[1], s = e[2], c = e[3], l = Math.sin(t), m = Math.cos(t);
  return n[0] = i * m + r * l, n[1] = r * m - i * l, n[2] = s * m + c * l, n[3] = c * m - s * l, n;
}
function aO(n, e) {
  var t = e[0], i = e[1], r = e[2];
  return n[0] = t, n[1] = i, n[2] = r, n[3] = Math.sqrt(Math.abs(1 - t * t - i * i - r * r)), n;
}
function Hg(n, e, t, i) {
  var r = e[0], s = e[1], c = e[2], l = e[3], m = t[0], y = t[1], A = t[2], T = t[3], I, L, N, z, V;
  return L = r * m + s * y + c * A + l * T, L < 0 && (L = -L, m = -m, y = -y, A = -A, T = -T), 1 - L > sp ? (I = Math.acos(L), N = Math.sin(I), z = Math.sin((1 - i) * I) / N, V = Math.sin(i * I) / N) : (z = 1 - i, V = i), n[0] = z * r + V * m, n[1] = z * s + V * y, n[2] = z * c + V * A, n[3] = z * l + V * T, n;
}
function lO(n, e) {
  var t = e[0], i = e[1], r = e[2], s = e[3], c = t * t + i * i + r * r + s * s, l = c ? 1 / c : 0;
  return n[0] = -t * l, n[1] = -i * l, n[2] = -r * l, n[3] = s * l, n;
}
function cO(n, e) {
  return n[0] = -e[0], n[1] = -e[1], n[2] = -e[2], n[3] = e[3], n;
}
function IE(n, e) {
  var t = e[0] + e[4] + e[8], i;
  if (t > 0)
    i = Math.sqrt(t + 1), n[3] = 0.5 * i, i = 0.5 / i, n[0] = (e[5] - e[7]) * i, n[1] = (e[6] - e[2]) * i, n[2] = (e[1] - e[3]) * i;
  else {
    var r = 0;
    e[4] > e[0] && (r = 1), e[8] > e[r * 3 + r] && (r = 2);
    var s = (r + 1) % 3, c = (r + 2) % 3;
    i = Math.sqrt(e[r * 3 + r] - e[s * 3 + s] - e[c * 3 + c] + 1), n[r] = 0.5 * i, i = 0.5 / i, n[3] = (e[s * 3 + c] - e[c * 3 + s]) * i, n[s] = (e[s * 3 + r] + e[r * 3 + s]) * i, n[c] = (e[c * 3 + r] + e[r * 3 + c]) * i;
  }
  return n;
}
var uO = q6, hO = TE, dO = J6, fO = $6, pO = H6, gO = W6, PE = X6, mO = function() {
  var n = vE(), e = wx(1, 0, 0), t = wx(0, 1, 0);
  return function(i, r, s) {
    var c = D1(r, s);
    return c < -0.999999 ? (qg(n, e, r), v6(n) < 1e-6 && qg(n, t, r), f6(n, n), CE(i, n, Math.PI), i) : c > 0.999999 ? (i[0] = 0, i[1] = 0, i[2] = 0, i[3] = 1, i) : (qg(n, r, s), i[0] = n[0], i[1] = n[1], i[2] = n[2], i[3] = 1 + c, PE(i, i));
  };
}();
(function() {
  var n = Tx(), e = Tx();
  return function(t, i, r, s, c, l) {
    return Hg(n, i, c, l), Hg(e, r, s, l), Hg(t, n, e, 2 * l * (1 - l)), t;
  };
})();
(function() {
  var n = b6();
  return function(e, t, i, r) {
    return n[0] = i[0], n[3] = i[1], n[6] = i[2], n[1] = r[0], n[4] = r[1], n[7] = r[2], n[2] = -t[0], n[5] = -t[1], n[8] = -t[2], PE(e, IE(e, n));
  };
})();
const _O = [0, 0, 0, 1];
class pp extends R1 {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
    super(-0, -0, -0, -0), Array.isArray(e) && arguments.length === 1 ? this.copy(e) : this.set(e, t, i, r);
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this.check();
  }
  set(e, t, i, r) {
    return this[0] = e, this[1] = t, this[2] = i, this[3] = r, this.check();
  }
  fromObject(e) {
    return this[0] = e.x, this[1] = e.y, this[2] = e.z, this[3] = e.w, this.check();
  }
  fromMatrix3(e) {
    return IE(this, e), this.check();
  }
  fromAxisRotation(e, t) {
    return CE(this, e, t), this.check();
  }
  identity() {
    return iO(this), this.check();
  }
  setAxisAngle(e, t) {
    return this.fromAxisRotation(e, t);
  }
  get ELEMENTS() {
    return 4;
  }
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = Ci(e);
  }
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = Ci(e);
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = Ci(e);
  }
  get w() {
    return this[3];
  }
  set w(e) {
    this[3] = Ci(e);
  }
  len() {
    return pO(this);
  }
  lengthSquared() {
    return gO(this);
  }
  dot(e) {
    return dO(this, e);
  }
  rotationTo(e, t) {
    return mO(this, e, t), this.check();
  }
  add(e) {
    return uO(this, this, e), this.check();
  }
  calculateW() {
    return aO(this, this), this.check();
  }
  conjugate() {
    return cO(this, this), this.check();
  }
  invert() {
    return lO(this, this), this.check();
  }
  lerp(e, t, i) {
    return i === void 0 ? this.lerp(this, e, t) : (fO(this, e, t, i), this.check());
  }
  multiplyRight(e) {
    return Cx(this, this, e), this.check();
  }
  multiplyLeft(e) {
    return Cx(this, e, this), this.check();
  }
  normalize() {
    const e = this.len(), t = e > 0 ? 1 / e : 0;
    return this[0] = this[0] * t, this[1] = this[1] * t, this[2] = this[2] * t, this[3] = this[3] * t, e === 0 && (this[3] = 1), this.check();
  }
  rotateX(e) {
    return rO(this, this, e), this.check();
  }
  rotateY(e) {
    return sO(this, this, e), this.check();
  }
  rotateZ(e) {
    return oO(this, this, e), this.check();
  }
  scale(e) {
    return hO(this, this, e), this.check();
  }
  slerp(e, t, i) {
    let r, s, c;
    switch (arguments.length) {
      case 1:
        ({
          start: r = _O,
          target: s,
          ratio: c
        } = e);
        break;
      case 2:
        r = this, s = e, c = t;
        break;
      default:
        r = e, s = t, c = i;
    }
    return Hg(this, r, s, c), this.check();
  }
  transformVector4(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new N1();
    return Z6(t, e, this), rp(t, 4);
  }
  lengthSq() {
    return this.lengthSquared();
  }
  setFromAxisAngle(e, t) {
    return this.setAxisAngle(e, t);
  }
  premultiply(e) {
    return this.multiplyLeft(e);
  }
  multiply(e) {
    return this.multiplyRight(e);
  }
}
const gp = {
  EPSILON1: 0.1,
  EPSILON2: 0.01,
  EPSILON3: 1e-3,
  EPSILON4: 1e-4,
  EPSILON5: 1e-5,
  EPSILON6: 1e-6,
  EPSILON7: 1e-7,
  EPSILON8: 1e-8,
  EPSILON9: 1e-9,
  EPSILON10: 1e-10,
  EPSILON11: 1e-11,
  EPSILON12: 1e-12,
  EPSILON13: 1e-13,
  EPSILON14: 1e-14,
  EPSILON15: 1e-15,
  EPSILON16: 1e-16,
  EPSILON17: 1e-17,
  EPSILON18: 1e-18,
  EPSILON19: 1e-19,
  EPSILON20: 1e-20,
  PI_OVER_TWO: Math.PI / 2,
  PI_OVER_FOUR: Math.PI / 4,
  PI_OVER_SIX: Math.PI / 6,
  TWO_PI: Math.PI * 2
}, Ix = `#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))

struct AmbientLight {
 vec3 color;
};

struct PointLight {
 vec3 color;
 vec3 position;
 vec3 attenuation;
};

struct DirectionalLight {
  vec3 color;
  vec3 direction;
};

uniform AmbientLight lighting_uAmbientLight;
uniform PointLight lighting_uPointLight[MAX_LIGHTS];
uniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];
uniform int lighting_uPointLightCount;
uniform int lighting_uDirectionalLightCount;

uniform bool lighting_uEnabled;

float getPointLightAttenuation(PointLight pointLight, float distance) {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}

#endif
`, yO = {
  lightSources: {}
};
function o_() {
  let {
    color: n = [0, 0, 0],
    intensity: e = 1
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return n.map((t) => t * e / 255);
}
function vO(n) {
  let {
    ambientLight: e,
    pointLights: t = [],
    directionalLights: i = []
  } = n;
  const r = {};
  return e ? r["lighting_uAmbientLight.color"] = o_(e) : r["lighting_uAmbientLight.color"] = [0, 0, 0], t.forEach((s, c) => {
    r["lighting_uPointLight[".concat(c, "].color")] = o_(s), r["lighting_uPointLight[".concat(c, "].position")] = s.position, r["lighting_uPointLight[".concat(c, "].attenuation")] = s.attenuation || [1, 0, 0];
  }), r.lighting_uPointLightCount = t.length, i.forEach((s, c) => {
    r["lighting_uDirectionalLight[".concat(c, "].color")] = o_(s), r["lighting_uDirectionalLight[".concat(c, "].direction")] = s.direction;
  }), r.lighting_uDirectionalLightCount = i.length, r;
}
function LE() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : yO;
  if ("lightSources" in n) {
    const {
      ambientLight: e,
      pointLights: t,
      directionalLights: i
    } = n.lightSources || {};
    return e || t && t.length > 0 || i && i.length > 0 ? Object.assign({}, vO({
      ambientLight: e,
      pointLights: t,
      directionalLights: i
    }), {
      lighting_uEnabled: !0
    }) : {
      lighting_uEnabled: !1
    };
  }
  if ("lights" in n) {
    const e = {
      pointLights: [],
      directionalLights: []
    };
    for (const t of n.lights || [])
      switch (t.type) {
        case "ambient":
          e.ambientLight = t;
          break;
        case "directional":
          e.directionalLights.push(t);
          break;
        case "point":
          e.pointLights.push(t);
          break;
      }
    return LE({
      lightSources: e
    });
  }
  return {};
}
const U1 = {
  name: "lights",
  vs: Ix,
  fs: Ix,
  getUniforms: LE,
  defines: {
    MAX_LIGHTS: 3
  }
}, bO = new Uint8Array([0, 255, 255, 255]), xO = {
  pickingSelectedColor: null,
  pickingHighlightColor: bO,
  pickingActive: !1,
  pickingAttribute: !1
};
function wO() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : xO;
  const e = {};
  if (n.pickingSelectedColor !== void 0)
    if (!n.pickingSelectedColor)
      e.picking_uSelectedColorValid = 0;
    else {
      const t = n.pickingSelectedColor.slice(0, 3);
      e.picking_uSelectedColorValid = 1, e.picking_uSelectedColor = t;
    }
  if (n.pickingHighlightColor) {
    const t = Array.from(n.pickingHighlightColor, (i) => i / 255);
    Number.isFinite(t[3]) || (t[3] = 1), e.picking_uHighlightColor = t;
  }
  return n.pickingActive !== void 0 && (e.picking_uActive = !!n.pickingActive, e.picking_uAttribute = !!n.pickingAttribute), e;
}
const AO = `uniform bool picking_uActive;
uniform bool picking_uAttribute;
uniform vec3 picking_uSelectedColor;
uniform bool picking_uSelectedColorValid;

out vec4 picking_vRGBcolor_Avalid;

const float COLOR_SCALE = 1. / 255.;

bool picking_isColorValid(vec3 color) {
  return dot(color, vec3(1.0)) > 0.001;
}

bool isVertexPicked(vec3 vertexColor) {
  return
    picking_uSelectedColorValid &&
    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));
}

void picking_setPickingColor(vec3 pickingColor) {
  if (picking_uActive) {
    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));

    if (!picking_uAttribute) {
      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;
    }
  } else {
    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));
  }
}

void picking_setPickingAttribute(float value) {
  if (picking_uAttribute) {
    picking_vRGBcolor_Avalid.r = value;
  }
}
void picking_setPickingAttribute(vec2 value) {
  if (picking_uAttribute) {
    picking_vRGBcolor_Avalid.rg = value;
  }
}
void picking_setPickingAttribute(vec3 value) {
  if (picking_uAttribute) {
    picking_vRGBcolor_Avalid.rgb = value;
  }
}
`, EO = `uniform bool picking_uActive;
uniform vec3 picking_uSelectedColor;
uniform vec4 picking_uHighlightColor;

in vec4 picking_vRGBcolor_Avalid;
vec4 picking_filterHighlightColor(vec4 color) {
  if (picking_uActive) {
    return color;
  }
  bool selected = bool(picking_vRGBcolor_Avalid.a);

  if (selected) {
    float highLightAlpha = picking_uHighlightColor.a;
    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
    float highLightRatio = highLightAlpha / blendedAlpha;

    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);
    return vec4(blendedRGB, blendedAlpha);
  } else {
    return color;
  }
}
vec4 picking_filterPickingColor(vec4 color) {
  if (picking_uActive) {
    if (picking_vRGBcolor_Avalid.a == 0.0) {
      discard;
    }
    return picking_vRGBcolor_Avalid;
  }
  return color;
}
vec4 picking_filterColor(vec4 color) {
  vec4 highightColor = picking_filterHighlightColor(color);
  return picking_filterPickingColor(highightColor);
}

`, SO = {
  name: "picking",
  vs: AO,
  fs: EO,
  getUniforms: wO
}, ME = `
uniform float lighting_uAmbient;
uniform float lighting_uDiffuse;
uniform float lighting_uShininess;
uniform vec3  lighting_uSpecularColor;

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
    vec3 halfway_direction = normalize(light_direction + view_direction);
    float lambertian = dot(light_direction, normal_worldspace);
    float specular = 0.0;
    if (lambertian > 0.0) {
      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
      specular = pow(specular_angle, lighting_uShininess);
    }
    lambertian = max(lambertian, 0.0);
    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;
}

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = surfaceColor;

  if (lighting_uEnabled) {
    vec3 view_direction = normalize(cameraPosition - position_worldspace);
    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting_uPointLightCount) {
        break;
      }
      PointLight pointLight = lighting_uPointLight[i];
      vec3 light_position_worldspace = pointLight.position;
      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
    }

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting_uDirectionalLightCount) {
        break;
      }
      DirectionalLight directionalLight = lighting_uDirectionalLight[i];
      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
    }
  }
  return lightColor;
}

vec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = vec3(0, 0, 0);
  vec3 surfaceColor = vec3(0, 0, 0);

  if (lighting_uEnabled) {
    vec3 view_direction = normalize(cameraPosition - position_worldspace);

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting_uPointLightCount) {
        break;
      }
      PointLight pointLight = lighting_uPointLight[i];
      vec3 light_position_worldspace = pointLight.position;
      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
    }

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting_uDirectionalLightCount) {
        break;
      }
      DirectionalLight directionalLight = lighting_uDirectionalLight[i];
      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
    }
  }
  return lightColor;
}
`, TO = {};
function CO(n) {
  const {
    ambient: e = 0.35,
    diffuse: t = 0.6,
    shininess: i = 32,
    specularColor: r = [30, 30, 30]
  } = n;
  return {
    lighting_uAmbient: e,
    lighting_uDiffuse: t,
    lighting_uShininess: i,
    lighting_uSpecularColor: r.map((s) => s / 255)
  };
}
function BE() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : TO;
  if (!("material" in n))
    return {};
  const {
    material: e
  } = n;
  return e ? CO(e) : {
    lighting_uEnabled: !1
  };
}
const IO = {
  name: "gouraud-lighting",
  dependencies: [U1],
  vs: ME,
  defines: {
    LIGHTING_VERTEX: 1
  },
  getUniforms: BE
}, PO = {
  name: "phong-lighting",
  dependencies: [U1],
  fs: ME,
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  getUniforms: BE
}, LO = `uniform mat4 u_MVPMatrix;
uniform mat4 u_ModelMatrix;
uniform mat4 u_NormalMatrix;

varying vec3 pbr_vPosition;
varying vec2 pbr_vUV;

#ifdef HAS_NORMALS
# ifdef HAS_TANGENTS
varying mat3 pbr_vTBN;
# else
varying vec3 pbr_vNormal;
# endif
#endif

void pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)
{
  vec4 pos = u_ModelMatrix * position;
  pbr_vPosition = vec3(pos.xyz) / pos.w;

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
  vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));
  vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));
  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;
  pbr_vTBN = mat3(tangentW, bitangentW, normalW);
#else
  pbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));
#endif
#endif

#ifdef HAS_UV
  pbr_vUV = uv;
#else
  pbr_vUV = vec2(0.,0.);
#endif
}
`, MO = `#if defined(USE_TEX_LOD) && !defined(FEATURE_GLSL_TEXTURE_LOD)
# error PBR fragment shader: Texture LOD is not available
#endif

#if !defined(HAS_TANGENTS) && !defined(FEATURE_GLSL_DERIVATIVES)
# error PBR fragment shader: Derivatives are not available
#endif


#if (__VERSION__ < 300)
  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL1COND; INCR)
#else
  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL2COND; INCR)
#endif

precision highp float;

uniform bool pbr_uUnlit;

#ifdef USE_IBL
uniform samplerCube u_DiffuseEnvSampler;
uniform samplerCube u_SpecularEnvSampler;
uniform sampler2D u_brdfLUT;
uniform vec2 u_ScaleIBLAmbient;
#endif

#ifdef HAS_BASECOLORMAP
uniform sampler2D u_BaseColorSampler;
#endif
#ifdef HAS_NORMALMAP
uniform sampler2D u_NormalSampler;
uniform float u_NormalScale;
#endif
#ifdef HAS_EMISSIVEMAP
uniform sampler2D u_EmissiveSampler;
uniform vec3 u_EmissiveFactor;
#endif
#ifdef HAS_METALROUGHNESSMAP
uniform sampler2D u_MetallicRoughnessSampler;
#endif
#ifdef HAS_OCCLUSIONMAP
uniform sampler2D u_OcclusionSampler;
uniform float u_OcclusionStrength;
#endif

#ifdef ALPHA_CUTOFF
uniform float u_AlphaCutoff;
#endif

uniform vec2 u_MetallicRoughnessValues;
uniform vec4 u_BaseColorFactor;

uniform vec3 u_Camera;
#ifdef PBR_DEBUG
uniform vec4 u_ScaleDiffBaseMR;
uniform vec4 u_ScaleFGDSpec;
#endif

varying vec3 pbr_vPosition;

varying vec2 pbr_vUV;

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
varying mat3 pbr_vTBN;
#else
varying vec3 pbr_vNormal;
#endif
#endif


struct PBRInfo
{
  float NdotL;
  float NdotV;
  float NdotH;
  float LdotH;
  float VdotH;
  float perceptualRoughness;
  float metalness;
  vec3 reflectance0;
  vec3 reflectance90;
  float alphaRoughness;
  vec3 diffuseColor;
  vec3 specularColor;
  vec3 n;
  vec3 v;
};

const float M_PI = 3.141592653589793;
const float c_MinRoughness = 0.04;

vec4 SRGBtoLINEAR(vec4 srgbIn)
{
#ifdef MANUAL_SRGB
#ifdef SRGB_FAST_APPROXIMATION
  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));
#else
  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);
  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );
#endif
  return vec4(linOut,srgbIn.w);;
#else
  return srgbIn;
#endif
}

vec3 getNormal()
{
#ifndef HAS_TANGENTS
  vec3 pos_dx = dFdx(pbr_vPosition);
  vec3 pos_dy = dFdy(pbr_vPosition);
  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));
  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));
  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);

#ifdef HAS_NORMALS
  vec3 ng = normalize(pbr_vNormal);
#else
  vec3 ng = cross(pos_dx, pos_dy);
#endif

  t = normalize(t - ng * dot(ng, t));
  vec3 b = normalize(cross(ng, t));
  mat3 tbn = mat3(t, b, ng);
#else
  mat3 tbn = pbr_vTBN;
#endif

#ifdef HAS_NORMALMAP
  vec3 n = texture2D(u_NormalSampler, pbr_vUV).rgb;
  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));
#else
  vec3 n = normalize(tbn[2].xyz);
#endif

  return n;
}


#ifdef USE_IBL
vec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)
{
  float mipCount = 9.0;
  float lod = (pbrInputs.perceptualRoughness * mipCount);
  vec3 brdf = SRGBtoLINEAR(texture2D(u_brdfLUT,
    vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;
  vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;

#ifdef USE_TEX_LOD
  vec3 specularLight = SRGBtoLINEAR(textureCubeLod(u_SpecularEnvSampler, reflection, lod)).rgb;
#else
  vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;
#endif

  vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;
  vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);
  diffuse *= u_ScaleIBLAmbient.x;
  specular *= u_ScaleIBLAmbient.y;

  return diffuse + specular;
}
#endif


vec3 diffuse(PBRInfo pbrInputs)
{
  return pbrInputs.diffuseColor / M_PI;
}

vec3 specularReflection(PBRInfo pbrInputs)
{
  return pbrInputs.reflectance0 +
    (pbrInputs.reflectance90 - pbrInputs.reflectance0) *
    pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);
}



float geometricOcclusion(PBRInfo pbrInputs)
{
  float NdotL = pbrInputs.NdotL;
  float NdotV = pbrInputs.NdotV;
  float r = pbrInputs.alphaRoughness;

  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));
  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));
  return attenuationL * attenuationV;
}





float microfacetDistribution(PBRInfo pbrInputs)
{
  float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;
  float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;
  return roughnessSq / (M_PI * f * f);
}

void PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {
  pbrInputs.NdotL = 1.0;
  pbrInputs.NdotH = 0.0;
  pbrInputs.LdotH = 0.0;
  pbrInputs.VdotH = 1.0;
}

void PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {
  vec3 n = pbrInputs.n;
  vec3 v = pbrInputs.v;
  vec3 l = normalize(lightDirection);
  vec3 h = normalize(l+v);

  pbrInputs.NdotL = clamp(dot(n, l), 0.001, 1.0);
  pbrInputs.NdotH = clamp(dot(n, h), 0.0, 1.0);
  pbrInputs.LdotH = clamp(dot(l, h), 0.0, 1.0);
  pbrInputs.VdotH = clamp(dot(v, h), 0.0, 1.0);
}

void PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {
  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);
  PBRInfo_setDirectionalLight(pbrInputs, light_direction);
}

vec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {
  vec3 F = specularReflection(pbrInputs);
  float G = geometricOcclusion(pbrInputs);
  float D = microfacetDistribution(pbrInputs);
  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);
  vec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);
  return pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);
}

vec4 pbr_filterColor(vec4 colorUnused)
{
#ifdef HAS_BASECOLORMAP
  vec4 baseColor = SRGBtoLINEAR(texture2D(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;
#else
  vec4 baseColor = u_BaseColorFactor;
#endif

#ifdef ALPHA_CUTOFF
  if (baseColor.a < u_AlphaCutoff) {
    discard;
  }
#endif

  vec3 color = vec3(0, 0, 0);

  if(pbr_uUnlit){
    color.rgb = baseColor.rgb;
  }
  else{


    float perceptualRoughness = u_MetallicRoughnessValues.y;
    float metallic = u_MetallicRoughnessValues.x;
#ifdef HAS_METALROUGHNESSMAP

    vec4 mrSample = texture2D(u_MetallicRoughnessSampler, pbr_vUV);
    perceptualRoughness = mrSample.g * perceptualRoughness;
    metallic = mrSample.b * metallic;
#endif
    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);
    metallic = clamp(metallic, 0.0, 1.0);

    float alphaRoughness = perceptualRoughness * perceptualRoughness;

    vec3 f0 = vec3(0.04);
    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);
    diffuseColor *= 1.0 - metallic;
    vec3 specularColor = mix(f0, baseColor.rgb, metallic);
    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);



    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
    vec3 specularEnvironmentR0 = specularColor.rgb;
    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;

    vec3 n = getNormal();
    vec3 v = normalize(u_Camera - pbr_vPosition);

    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
    vec3 reflection = -normalize(reflect(v, n));

    PBRInfo pbrInputs = PBRInfo(
      0.0,
      NdotV,
      0.0,
      0.0,
      0.0,
      perceptualRoughness,
      metallic,
      specularEnvironmentR0,
      specularEnvironmentR90,
      alphaRoughness,
      diffuseColor,
      specularColor,
      n,
      v
    );

#ifdef USE_LIGHTS
    PBRInfo_setAmbientLight(pbrInputs);
    color += calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);
    SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uDirectionalLightCount, i++) {
      if (i < lighting_uDirectionalLightCount) {
        PBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);
        color += calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);
      }
    }
    SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uPointLightCount, i++) {
      if (i < lighting_uPointLightCount) {
        PBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);
        float attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));
        color += calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);
      }
    }
#endif
#ifdef USE_IBL
    color += getIBLContribution(pbrInputs, n, reflection);
#endif
#ifdef HAS_OCCLUSIONMAP
    float ao = texture2D(u_OcclusionSampler, pbr_vUV).r;
    color = mix(color, color * ao, u_OcclusionStrength);
#endif

#ifdef HAS_EMISSIVEMAP
    vec3 emissive = SRGBtoLINEAR(texture2D(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;
    color += emissive;
#endif

#ifdef PBR_DEBUG





    color = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);
    color = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);
    color = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);
#endif

  }

  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);
}
`, j1 = {
  name: "pbr",
  vs: LO,
  fs: MO,
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  dependencies: [U1]
}, BO = `attribute float transform_elementID;
vec2 transform_getPixelSizeHalf(vec2 size) {
  return vec2(1.) / (2. * size);
}

vec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {
  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);
  float xIndex = transform_elementID - (yIndex * texSize[0]);
  return vec2(xIndex, yIndex);
}
vec2 transform_getTexCoord(vec2 size) {
  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);
  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);
  vec2 coord = indices / size + pixelSizeHalf;
  return coord;
}
vec2 transform_getPos(vec2 size) {
  vec2 texCoord = transform_getTexCoord(size);
  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);
  return pos;
}
vec4 transform_getInput(sampler2D texSampler, vec2 size) {
  vec2 texCoord = transform_getTexCoord(size);
  vec4 textureColor = texture2D(texSampler, texCoord);
  return textureColor;
}
`, RO = {
  name: "transform",
  vs: BO,
  fs: null
};
class Op {
  static getDefaultProgramManager(e) {
    return e.luma = e.luma || {}, e.luma.defaultProgramManager = e.luma.defaultProgramManager || new Op(e), e.luma.defaultProgramManager;
  }
  constructor(e) {
    this.gl = e, this._programCache = {}, this._getUniforms = {}, this._registeredModules = {}, this._hookFunctions = [], this._defaultModules = [], this._hashes = {}, this._hashCounter = 0, this.stateHash = 0, this._useCounts = {};
  }
  addDefaultModule(e) {
    this._defaultModules.find((t) => t.name === e.name) || this._defaultModules.push(e), this.stateHash++;
  }
  removeDefaultModule(e) {
    const t = typeof e == "string" ? e : e.name;
    this._defaultModules = this._defaultModules.filter((i) => i.name !== t), this.stateHash++;
  }
  addShaderHook(e, t) {
    t && (e = Object.assign(t, {
      hook: e
    })), this._hookFunctions.push(e), this.stateHash++;
  }
  get() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      vs: t = "",
      fs: i = "",
      defines: r = {},
      inject: s = {},
      varyings: c = [],
      bufferMode: l = 35981,
      transpileToGLSL100: m = !1
    } = e, y = this._getModuleList(e.modules), A = this._getHash(t), T = this._getHash(i), I = y.map((ce) => this._getHash(ce.name)).sort(), L = c.map((ce) => this._getHash(ce)), N = Object.keys(r).sort(), z = Object.keys(s).sort(), V = [], H = [];
    for (const ce of N)
      V.push(this._getHash(ce)), V.push(this._getHash(r[ce]));
    for (const ce of z)
      H.push(this._getHash(ce)), H.push(this._getHash(s[ce]));
    const J = "".concat(A, "/").concat(T, "D").concat(V.join("/"), "M").concat(I.join("/"), "I").concat(H.join("/"), "V").concat(L.join("/"), "H").concat(this.stateHash, "B").concat(l).concat(m ? "T" : "");
    if (!this._programCache[J]) {
      const ce = FR(this.gl, {
        vs: t,
        fs: i,
        modules: y,
        inject: s,
        defines: r,
        hookFunctions: this._hookFunctions,
        transpileToGLSL100: m
      });
      this._programCache[J] = new iE(this.gl, {
        hash: J,
        vs: ce.vs,
        fs: ce.fs,
        varyings: c,
        bufferMode: l
      }), this._getUniforms[J] = ce.getUniforms || ((me) => {
      }), this._useCounts[J] = 0;
    }
    return this._useCounts[J]++, this._programCache[J];
  }
  getUniforms(e) {
    return this._getUniforms[e.hash] || null;
  }
  release(e) {
    const t = e.hash;
    this._useCounts[t]--, this._useCounts[t] === 0 && (this._programCache[t].delete(), delete this._programCache[t], delete this._getUniforms[t], delete this._useCounts[t]);
  }
  _getHash(e) {
    return this._hashes[e] === void 0 && (this._hashes[e] = this._hashCounter++), this._hashes[e];
  }
  _getModuleList() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const t = new Array(this._defaultModules.length + e.length), i = {};
    let r = 0;
    for (let s = 0, c = this._defaultModules.length; s < c; ++s) {
      const l = this._defaultModules[s], m = l.name;
      t[r++] = l, i[m] = !0;
    }
    for (let s = 0, c = e.length; s < c; ++s) {
      const l = e[s], m = l.name;
      i[m] || (t[r++] = l, i[m] = !0);
    }
    return t.length = r, t;
  }
}
const OO = {
  POSITION: "positions",
  NORMAL: "normals",
  COLOR_0: "colors",
  TEXCOORD_0: "texCoords",
  TEXCOORD_1: "texCoords1",
  TEXCOORD_2: "texCoords2"
};
function FO(n, e, t) {
  const i = {};
  let r = e.indices;
  for (const s in e.attributes) {
    const c = e.attributes[s], l = DO(s);
    if (s === "indices")
      r = c;
    else if (c.constant)
      i[l] = c.value;
    else {
      const m = c.value, y = {
        ...c
      };
      delete y.value, i[l] = [new Hi(n, m), y], kO(s, y);
    }
  }
  if (r) {
    const s = r.value || r;
    Yt(s instanceof Uint16Array || s instanceof Uint32Array, 'attribute array for "indices" must be of integer type');
    const c = {
      size: 1,
      isIndexed: r.isIndexed === void 0 ? !0 : r.isIndexed
    };
    i.indices = [new Hi(n, {
      data: s,
      target: 34963
    }), c];
  }
  return i;
}
function DO(n, e) {
  const {
    attributeMap: t = OO
  } = {};
  return t && t[n] || n;
}
function kO(n, e) {
  let t;
  switch (n) {
    case "texCoords":
    case "texCoord1":
    case "texCoord2":
    case "texCoord3":
      t = "uvs";
      break;
    case "vertices":
    case "positions":
    case "normals":
    case "pickingColors":
      t = "vectors";
      break;
  }
  switch (t) {
    case "vectors":
      e.size = e.size || 3;
      break;
    case "uvs":
      e.size = e.size || 2;
      break;
  }
  Yt(Number.isFinite(e.size), "attribute ".concat(n, " needs size"));
}
const dd = 2, NO = 1e4, zO = "Model needs drawMode and vertexCount", Px = () => {
}, UO = {};
class Hd {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      id: i = tu("model")
    } = t;
    Yt(Bm(e)), this.id = i, this.gl = e, this.id = t.id || tu("Model"), this.lastLogTime = 0, this.animated = !1, this.initialize(t);
  }
  initialize(e) {
    this.props = {}, this.programManager = e.programManager || Op.getDefaultProgramManager(this.gl), this._programManagerState = -1, this._managedProgram = !1;
    const {
      program: t = null,
      vs: i,
      fs: r,
      modules: s,
      defines: c,
      inject: l,
      varyings: m,
      bufferMode: y,
      transpileToGLSL100: A
    } = e;
    this.programProps = {
      program: t,
      vs: i,
      fs: r,
      modules: s,
      defines: c,
      inject: l,
      varyings: m,
      bufferMode: y,
      transpileToGLSL100: A
    }, this.program = null, this.vertexArray = null, this._programDirty = !0, this.userData = {}, this.needsRedraw = !0, this._attributes = {}, this.attributes = {}, this.uniforms = {}, this.pickable = !0, this._checkProgram(), this.setUniforms(Object.assign({}, this.getModuleUniforms(e.moduleSettings))), this.drawMode = e.drawMode !== void 0 ? e.drawMode : 4, this.vertexCount = e.vertexCount || 0, this.geometryBuffers = {}, this.isInstanced = e.isInstanced || e.instanced || e.instanceCount > 0, this._setModelProps(e), this.geometry = {}, Yt(this.drawMode !== void 0 && Number.isFinite(this.vertexCount), zO);
  }
  setProps(e) {
    this._setModelProps(e);
  }
  delete() {
    for (const e in this._attributes)
      this._attributes[e] !== this.attributes[e] && this._attributes[e].delete();
    this._managedProgram && (this.programManager.release(this.program), this._managedProgram = !1), this.vertexArray.delete(), this._deleteGeometryBuffers();
  }
  getDrawMode() {
    return this.drawMode;
  }
  getVertexCount() {
    return this.vertexCount;
  }
  getInstanceCount() {
    return this.instanceCount;
  }
  getAttributes() {
    return this.attributes;
  }
  getProgram() {
    return this.program;
  }
  setProgram(e) {
    const {
      program: t,
      vs: i,
      fs: r,
      modules: s,
      defines: c,
      inject: l,
      varyings: m,
      bufferMode: y,
      transpileToGLSL100: A
    } = e;
    this.programProps = {
      program: t,
      vs: i,
      fs: r,
      modules: s,
      defines: c,
      inject: l,
      varyings: m,
      bufferMode: y,
      transpileToGLSL100: A
    }, this._programDirty = !0;
  }
  getUniforms() {
    return this.uniforms;
  }
  setDrawMode(e) {
    return this.drawMode = e, this;
  }
  setVertexCount(e) {
    return Yt(Number.isFinite(e)), this.vertexCount = e, this;
  }
  setInstanceCount(e) {
    return Yt(Number.isFinite(e)), this.instanceCount = e, this;
  }
  setGeometry(e) {
    return this.drawMode = e.drawMode, this.vertexCount = e.getVertexCount(), this._deleteGeometryBuffers(), this.geometryBuffers = FO(this.gl, e), this.vertexArray.setAttributes(this.geometryBuffers), this;
  }
  setAttributes() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (Gd(e))
      return this;
    const t = {};
    for (const i in e) {
      const r = e[i];
      t[i] = r.getValue ? r.getValue() : r;
    }
    return this.vertexArray.setAttributes(t), this;
  }
  setUniforms() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Object.assign(this.uniforms, e), this;
  }
  getModuleUniforms(e) {
    this._checkProgram();
    const t = this.programManager.getUniforms(this.program);
    return t ? t(e) : {};
  }
  updateModuleSettings(e) {
    const t = this.getModuleUniforms(e || {});
    return this.setUniforms(t);
  }
  clear(e) {
    return C1(this.program.gl, e), this;
  }
  draw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._checkProgram();
    const {
      moduleSettings: t = null,
      framebuffer: i,
      uniforms: r = {},
      attributes: s = {},
      transformFeedback: c = this.transformFeedback,
      parameters: l = {},
      vertexArray: m = this.vertexArray
    } = e;
    this.setAttributes(s), this.updateModuleSettings(t), this.setUniforms(r);
    let y;
    cn.priority >= dd && (y = this._logDrawCallStart(dd));
    const A = this.vertexArray.getDrawParams(), {
      isIndexed: T = A.isIndexed,
      indexType: I = A.indexType,
      indexOffset: L = A.indexOffset,
      vertexArrayInstanced: N = A.isInstanced
    } = this.props;
    N && !this.isInstanced && cn.warn("Found instanced attributes on non-instanced model", this.id)();
    const {
      isInstanced: z,
      instanceCount: V
    } = this, {
      onBeforeRender: H = Px,
      onAfterRender: J = Px
    } = this.props;
    H(), this.program.setUniforms(this.uniforms);
    const ce = this.program.draw(Object.assign(UO, e, {
      logPriority: y,
      uniforms: null,
      framebuffer: i,
      parameters: l,
      drawMode: this.getDrawMode(),
      vertexCount: this.getVertexCount(),
      vertexArray: m,
      transformFeedback: c,
      isIndexed: T,
      indexType: I,
      isInstanced: z,
      instanceCount: V,
      offset: T ? L : 0
    }));
    return J(), cn.priority >= dd && this._logDrawCallEnd(y, m, i), ce;
  }
  transform() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      discard: t = !0,
      feedbackBuffers: i,
      unbindModels: r = []
    } = e;
    let {
      parameters: s
    } = e;
    i && this._setFeedbackBuffers(i), t && (s = Object.assign({}, s, {
      35977: t
    })), r.forEach((c) => c.vertexArray.unbindBuffers());
    try {
      this.draw(Object.assign({}, e, {
        parameters: s
      }));
    } finally {
      r.forEach((c) => c.vertexArray.bindBuffers());
    }
    return this;
  }
  render() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return cn.warn("Model.render() is deprecated. Use Model.setUniforms() and Model.draw()")(), this.setUniforms(e).draw();
  }
  _setModelProps(e) {
    Object.assign(this.props, e), "uniforms" in e && this.setUniforms(e.uniforms), "pickable" in e && (this.pickable = e.pickable), "instanceCount" in e && (this.instanceCount = e.instanceCount), "geometry" in e && this.setGeometry(e.geometry), "attributes" in e && this.setAttributes(e.attributes), "_feedbackBuffers" in e && this._setFeedbackBuffers(e._feedbackBuffers);
  }
  _checkProgram() {
    if (!(this._programDirty || this.programManager.stateHash !== this._programManagerState))
      return;
    let {
      program: t
    } = this.programProps;
    if (t)
      this._managedProgram = !1;
    else {
      const {
        vs: i,
        fs: r,
        modules: s,
        inject: c,
        defines: l,
        varyings: m,
        bufferMode: y,
        transpileToGLSL100: A
      } = this.programProps;
      t = this.programManager.get({
        vs: i,
        fs: r,
        modules: s,
        inject: c,
        defines: l,
        varyings: m,
        bufferMode: y,
        transpileToGLSL100: A
      }), this.program && this._managedProgram && this.programManager.release(this.program), this._programManagerState = this.programManager.stateHash, this._managedProgram = !0;
    }
    Yt(t instanceof iE, "Model needs a program"), this._programDirty = !1, t !== this.program && (this.program = t, this.vertexArray ? this.vertexArray.setProps({
      program: this.program,
      attributes: this.vertexArray.attributes
    }) : this.vertexArray = new ZB(this.gl, {
      program: this.program
    }), this.setUniforms(Object.assign({}, this.getModuleUniforms())));
  }
  _deleteGeometryBuffers() {
    for (const e in this.geometryBuffers) {
      const t = this.geometryBuffers[e][0] || this.geometryBuffers[e];
      t instanceof Hi && t.delete();
    }
  }
  _setAnimationProps(e) {
    this.animated && Yt(e, "Model.draw(): animated uniforms but no animationProps");
  }
  _setFeedbackBuffers() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (Gd(e))
      return this;
    const {
      gl: t
    } = this.program;
    return this.transformFeedback = this.transformFeedback || new rE(t, {
      program: this.program
    }), this.transformFeedback.setBuffers(e), this;
  }
  _logDrawCallStart(e) {
    const t = e > 3 ? 0 : NO;
    if (!(Date.now() - this.lastLogTime < t))
      return this.lastLogTime = Date.now(), cn.group(dd, ">>> DRAWING MODEL ".concat(this.id), {
        collapsed: cn.level <= 2
      })(), e;
  }
  _logDrawCallEnd(e, t, i, r) {
    if (e === void 0)
      return;
    const s = QB({
      vertexArray: t,
      header: "".concat(this.id, " attributes"),
      attributes: this._attributes
    }), {
      table: c,
      unusedTable: l,
      unusedCount: m
    } = ux({
      header: "".concat(this.id, " uniforms"),
      program: this.program,
      uniforms: Object.assign({}, this.program.uniforms, i)
    }), {
      table: y,
      count: A
    } = ux({
      header: "".concat(this.id, " uniforms"),
      program: this.program,
      uniforms: Object.assign({}, this.program.uniforms, i),
      undefinedOnly: !0
    });
    A > 0 && cn.log("MISSING UNIFORMS", Object.keys(y))(), m > 0 && cn.log("UNUSED UNIFORMS", Object.keys(l))();
    const T = tR(this.vertexArray.configuration);
    cn.table(e, s)(), cn.table(e, c)(), cn.table(e + 1, T)(), r && r.log({
      logLevel: dd,
      message: "Rendered to ".concat(r.id)
    }), cn.groupEnd(dd)();
  }
}
class jO {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.gl = e, this.currentIndex = 0, this.feedbackMap = {}, this.varyings = null, this.bindings = [], this.resources = {}, this._initialize(t), Object.seal(this);
  }
  setupResources(e) {
    for (const t of this.bindings)
      this._setupTransformFeedback(t, e);
  }
  updateModelProps() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      varyings: t
    } = this;
    return t.length > 0 && (e = Object.assign({}, e, {
      varyings: t
    })), e;
  }
  getDrawOptions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = this.bindings[this.currentIndex], {
      sourceBuffers: i,
      transformFeedback: r
    } = t;
    return {
      attributes: Object.assign({}, i, e.attributes),
      transformFeedback: r
    };
  }
  swap() {
    return this.feedbackMap ? (this.currentIndex = this._getNextIndex(), !0) : !1;
  }
  update() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._setupBuffers(e);
  }
  getBuffer(e) {
    const {
      feedbackBuffers: t
    } = this.bindings[this.currentIndex], i = e ? t[e] : null;
    return i ? i instanceof Hi ? i : i.buffer : null;
  }
  getData() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      varyingName: t
    } = e, i = this.getBuffer(t);
    return i ? i.getData() : null;
  }
  delete() {
    for (const e in this.resources)
      this.resources[e].delete();
  }
  _initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._setupBuffers(e), this.varyings = e.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers), this.varyings.length > 0 && Yt(ei(this.gl));
  }
  _getFeedbackBuffers(e) {
    const {
      sourceBuffers: t = {}
    } = e, i = {};
    if (this.bindings[this.currentIndex] && Object.assign(i, this.bindings[this.currentIndex].feedbackBuffers), this.feedbackMap)
      for (const r in this.feedbackMap) {
        const s = this.feedbackMap[r];
        r in t && (i[s] = r);
      }
    Object.assign(i, e.feedbackBuffers);
    for (const r in i) {
      const s = i[r];
      if (typeof s == "string") {
        const c = t[s], {
          byteLength: l,
          usage: m,
          accessor: y
        } = c;
        i[r] = this._createNewBuffer(r, {
          byteLength: l,
          usage: m,
          accessor: y
        });
      }
    }
    return i;
  }
  _setupBuffers() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      sourceBuffers: t = null
    } = e;
    Object.assign(this.feedbackMap, e.feedbackMap);
    const i = this._getFeedbackBuffers(e);
    this._updateBindings({
      sourceBuffers: t,
      feedbackBuffers: i
    });
  }
  _setupTransformFeedback(e, t) {
    let {
      model: i
    } = t;
    const {
      program: r
    } = i;
    e.transformFeedback = new rE(this.gl, {
      program: r,
      buffers: e.feedbackBuffers
    });
  }
  _updateBindings(e) {
    if (this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], e), this.feedbackMap) {
      const {
        sourceBuffers: t,
        feedbackBuffers: i
      } = this._swapBuffers(this.bindings[this.currentIndex]), r = this._getNextIndex();
      this.bindings[r] = this._updateBinding(this.bindings[r], {
        sourceBuffers: t,
        feedbackBuffers: i
      });
    }
  }
  _updateBinding(e, t) {
    return e ? (Object.assign(e.sourceBuffers, t.sourceBuffers), Object.assign(e.feedbackBuffers, t.feedbackBuffers), e.transformFeedback && e.transformFeedback.setBuffers(e.feedbackBuffers), e) : {
      sourceBuffers: Object.assign({}, t.sourceBuffers),
      feedbackBuffers: Object.assign({}, t.feedbackBuffers)
    };
  }
  _swapBuffers(e) {
    if (!this.feedbackMap)
      return null;
    const t = Object.assign({}, e.sourceBuffers), i = Object.assign({}, e.feedbackBuffers);
    for (const r in this.feedbackMap) {
      const s = this.feedbackMap[r];
      t[r] = e.feedbackBuffers[s], i[s] = e.sourceBuffers[r], Yt(i[s] instanceof Hi);
    }
    return {
      sourceBuffers: t,
      feedbackBuffers: i
    };
  }
  _createNewBuffer(e, t) {
    const i = new Hi(this.gl, t);
    return this.resources[e] && this.resources[e].delete(), this.resources[e] = i, i;
  }
  _getNextIndex() {
    return (this.currentIndex + 1) % 2;
  }
}
const GO = "transform_uSampler_", _m = "transform_uSize_", Lx = "transform_position";
function VO(n) {
  let {
    vs: e,
    sourceTextureMap: t,
    targetTextureVarying: i,
    targetTexture: r
  } = n, c = Object.keys(t).length, l = null;
  const m = {};
  let y = e, A = {};
  if (c > 0 || i) {
    const T = y.split(`
`), I = T.slice();
    if (T.forEach((L, N, z) => {
      if (c > 0) {
        const V = JO(L, t);
        if (V) {
          const {
            updatedLine: H,
            inject: J
          } = V;
          I[N] = H, A = dy([A, J]), Object.assign(m, V.samplerTextureMap), c--;
        }
      }
      i && !l && (l = XO(L, i));
    }), i) {
      Yt(r);
      const L = "".concat(_m).concat(i), N = "uniform vec2 ".concat(L, `;
`), z = "     vec2 ".concat(Lx, " = transform_getPos(").concat(L, `);
     gl_Position = vec4(`).concat(Lx, `, 0, 1.);
`);
      A = dy([A, {
        "vs:#decl": N,
        "vs:#main-start": z
      }]);
    }
    y = I.join(`
`);
  }
  return {
    vs: y,
    targetTextureType: l,
    inject: A,
    samplerTextureMap: m
  };
}
function qO(n) {
  let {
    sourceTextureMap: e,
    targetTextureVarying: t,
    targetTexture: i
  } = n;
  const r = {};
  let s, c;
  t && ({
    width: s,
    height: c
  } = i, r["".concat(_m).concat(t)] = [s, c]);
  for (const l in e)
    ({
      width: s,
      height: c
    } = e[l]), r["".concat(_m).concat(l)] = [s, c];
  return r;
}
function HO(n) {
  return hE(n, ["attribute", "in"]);
}
function WO(n) {
  const e = "".concat(GO).concat(n), t = "".concat(_m).concat(n), i = "  uniform sampler2D ".concat(e, `;
  uniform vec2 `).concat(t, ";");
  return {
    samplerName: e,
    sizeName: t,
    uniformDeclerations: i
  };
}
function XO(n, e) {
  const t = hE(n, ["varying", "out"]);
  return t && t.name === e ? t.type : null;
}
function JO(n, e) {
  const t = {}, i = HO(n);
  if (!i)
    return null;
  const {
    type: r,
    name: s
  } = i;
  if (s && e[s]) {
    const c = "// ".concat(n, " => Replaced by Transform with a sampler"), {
      samplerName: l,
      sizeName: m,
      uniformDeclerations: y
    } = WO(s), A = qR(r), T = "  ".concat(r, " ").concat(s, " = transform_getInput(").concat(l, ", ").concat(m, ").").concat(A, `;
`);
    return t[l] = s, {
      updatedLine: c,
      inject: {
        "vs:#decl": y,
        "vs:#main-start": T
      },
      samplerTextureMap: t
    };
  }
  return null;
}
const $O = {
  10241: 9728,
  10240: 9728,
  10242: 33071,
  10243: 33071
}, ZO = "transform_output";
class YO {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.gl = e, this.id = this.currentIndex = 0, this._swapTexture = null, this.targetTextureVarying = null, this.targetTextureType = null, this.samplerTextureMap = null, this.bindings = [], this.resources = {}, this._initialize(t), Object.seal(this);
  }
  updateModelProps() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = this._processVertexShader(e);
    return Object.assign({}, e, t);
  }
  getDrawOptions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      sourceBuffers: t,
      sourceTextures: i,
      framebuffer: r,
      targetTexture: s
    } = this.bindings[this.currentIndex], c = Object.assign({}, t, e.attributes), l = Object.assign({}, e.uniforms), m = Object.assign({}, e.parameters);
    let y = e.discard;
    if (this.hasSourceTextures || this.hasTargetTexture) {
      c.transform_elementID = this.elementIDBuffer;
      for (const T in this.samplerTextureMap) {
        const I = this.samplerTextureMap[T];
        l[T] = i[I];
      }
      this._setSourceTextureParameters();
      const A = qO({
        sourceTextureMap: i,
        targetTextureVarying: this.targetTextureVarying,
        targetTexture: s
      });
      Object.assign(l, A);
    }
    return this.hasTargetTexture && (y = !1, m.viewport = [0, 0, r.width, r.height]), {
      attributes: c,
      framebuffer: r,
      uniforms: l,
      discard: y,
      parameters: m
    };
  }
  swap() {
    return this._swapTexture ? (this.currentIndex = this._getNextIndex(), !0) : !1;
  }
  update() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._setupTextures(e);
  }
  getTargetTexture() {
    const {
      targetTexture: e
    } = this.bindings[this.currentIndex];
    return e;
  }
  getData() {
    let {
      packed: e = !1
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      framebuffer: t
    } = this.bindings[this.currentIndex], i = Om(t);
    if (!e)
      return i;
    const r = i.constructor, s = HR(this.targetTextureType), c = new r(i.length * s / 4);
    let l = 0;
    for (let m = 0; m < i.length; m += 4)
      for (let y = 0; y < s; y++)
        c[l++] = i[m + y];
    return c;
  }
  getFramebuffer() {
    return this.bindings[this.currentIndex].framebuffer;
  }
  delete() {
    this.ownTexture && this.ownTexture.delete(), this.elementIDBuffer && this.elementIDBuffer.delete();
  }
  _initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      _targetTextureVarying: t,
      _swapTexture: i
    } = e;
    this._swapTexture = i, this.targetTextureVarying = t, this.hasTargetTexture = t, this._setupTextures(e);
  }
  _createTargetTexture(e) {
    const {
      sourceTextures: t,
      textureOrReference: i
    } = e;
    if (i instanceof ga)
      return i;
    const r = t[i];
    return r ? (this._targetRefTexName = i, this._createNewTexture(r)) : null;
  }
  _setupTextures() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      sourceBuffers: t,
      _sourceTextures: i = {},
      _targetTexture: r
    } = e, s = this._createTargetTexture({
      sourceTextures: i,
      textureOrReference: r
    });
    this.hasSourceTextures = this.hasSourceTextures || i && Object.keys(i).length > 0, this._updateBindings({
      sourceBuffers: t,
      sourceTextures: i,
      targetTexture: s
    }), "elementCount" in e && this._updateElementIDBuffer(e.elementCount);
  }
  _updateElementIDBuffer(e) {
    if (typeof e != "number" || this.elementCount >= e)
      return;
    const t = new Float32Array(e);
    t.forEach((i, r, s) => {
      s[r] = r;
    }), this.elementIDBuffer ? this.elementIDBuffer.setData({
      data: t
    }) : this.elementIDBuffer = new Hi(this.gl, {
      data: t,
      accessor: {
        size: 1
      }
    }), this.elementCount = e;
  }
  _updateBindings(e) {
    if (this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], e), this._swapTexture) {
      const {
        sourceTextures: t,
        targetTexture: i
      } = this._swapTextures(this.bindings[this.currentIndex]), r = this._getNextIndex();
      this.bindings[r] = this._updateBinding(this.bindings[r], {
        sourceTextures: t,
        targetTexture: i
      });
    }
  }
  _updateBinding(e, t) {
    const {
      sourceBuffers: i,
      sourceTextures: r,
      targetTexture: s
    } = t;
    if (e || (e = {
      sourceBuffers: {},
      sourceTextures: {},
      targetTexture: null
    }), Object.assign(e.sourceTextures, r), Object.assign(e.sourceBuffers, i), s) {
      e.targetTexture = s;
      const {
        width: c,
        height: l
      } = s, {
        framebuffer: m
      } = e;
      m ? (m.update({
        attachments: {
          36064: s
        },
        resizeAttachments: !1
      }), m.resize({
        width: c,
        height: l
      })) : e.framebuffer = new ss(this.gl, {
        id: "transform-framebuffer",
        width: c,
        height: l,
        attachments: {
          36064: s
        }
      });
    }
    return e;
  }
  _setSourceTextureParameters() {
    const e = this.currentIndex, {
      sourceTextures: t
    } = this.bindings[e];
    for (const i in t)
      t[i].setParameters($O);
  }
  _swapTextures(e) {
    if (!this._swapTexture)
      return null;
    const t = Object.assign({}, e.sourceTextures);
    t[this._swapTexture] = e.targetTexture;
    const i = e.sourceTextures[this._swapTexture];
    return {
      sourceTextures: t,
      targetTexture: i
    };
  }
  _createNewTexture(e) {
    const t = z4(e, {
      parameters: {
        10241: 9728,
        10240: 9728,
        10242: 33071,
        10243: 33071
      },
      pixelStore: {
        37440: !1
      }
    });
    return this.ownTexture && this.ownTexture.delete(), this.ownTexture = t, t;
  }
  _getNextIndex() {
    return (this.currentIndex + 1) % 2;
  }
  _processVertexShader() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      sourceTextures: t,
      targetTexture: i
    } = this.bindings[this.currentIndex], {
      vs: r,
      uniforms: s,
      targetTextureType: c,
      inject: l,
      samplerTextureMap: m
    } = VO({
      vs: e.vs,
      sourceTextureMap: t,
      targetTextureVarying: this.targetTextureVarying,
      targetTexture: i
    }), y = dy([e.inject || {}, l]);
    this.targetTextureType = c, this.samplerTextureMap = m;
    const A = e._fs || dE({
      version: tE(r),
      input: this.targetTextureVarying,
      inputType: c,
      output: ZO
    }), T = this.hasSourceTextures || this.targetTextureVarying ? [RO].concat(e.modules || []) : e.modules;
    return {
      vs: r,
      fs: A,
      modules: T,
      uniforms: s,
      inject: y
    };
  }
}
class G1 {
  static isSupported(e) {
    return ei(e);
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.gl = e, this.model = null, this.elementCount = 0, this.bufferTransform = null, this.textureTransform = null, this.elementIDBuffer = null, this._initialize(t), Object.seal(this);
  }
  delete() {
    const {
      model: e,
      bufferTransform: t,
      textureTransform: i
    } = this;
    e && e.delete(), t && t.delete(), i && i.delete();
  }
  run() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      clearRenderTarget: t = !0
    } = e, i = this._updateDrawOptions(e);
    t && i.framebuffer && i.framebuffer.clear({
      color: !0
    }), this.model.transform(i);
  }
  swap() {
    let e = !1;
    const t = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const i of t)
      e = e || i.swap();
    Yt(e, "Nothing to swap");
  }
  getBuffer() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    return this.bufferTransform && this.bufferTransform.getBuffer(e);
  }
  getData() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const i of t) {
      const r = i.getData(e);
      if (r)
        return r;
    }
    return null;
  }
  getFramebuffer() {
    return this.textureTransform && this.textureTransform.getFramebuffer();
  }
  update() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    "elementCount" in e && this.model.setVertexCount(e.elementCount);
    const t = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const i of t)
      i.update(e);
  }
  _initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      gl: t
    } = this;
    this._buildResourceTransforms(t, e), e = this._updateModelProps(e), this.model = new Hd(t, Object.assign({}, e, {
      fs: e.fs || dE({
        version: tE(e.vs)
      }),
      id: e.id || "transform-model",
      drawMode: e.drawMode || 0,
      vertexCount: e.elementCount
    })), this.bufferTransform && this.bufferTransform.setupResources({
      model: this.model
    });
  }
  _updateModelProps(e) {
    let t = Object.assign({}, e);
    const i = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const r of i)
      t = r.updateModelProps(t);
    return t;
  }
  _buildResourceTransforms(e, t) {
    KO(t) && (this.bufferTransform = new jO(e, t)), QO(t) && (this.textureTransform = new YO(e, t)), Yt(this.bufferTransform || this.textureTransform, "must provide source/feedback buffers or source/target textures");
  }
  _updateDrawOptions(e) {
    let t = Object.assign({}, e);
    const i = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const r of i)
      t = Object.assign(t, r.getDrawOptions(t));
    return t;
  }
}
function KO(n) {
  return !!(!Gd(n.feedbackBuffers) || !Gd(n.feedbackMap) || n.varyings && n.varyings.length > 0);
}
function QO(n) {
  return !!(!Gd(n._sourceTextures) || n._targetTexture || n._targetTextureVarying);
}
const Mx = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6
};
class op {
  static get DRAW_MODE() {
    return Mx;
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      id: t = tu("geometry"),
      drawMode: i = Mx.TRIANGLES,
      attributes: r = {},
      indices: s = null,
      vertexCount: c = null
    } = e;
    this.id = t, this.drawMode = i | 0, this.attributes = {}, this.userData = {}, this._setAttributes(r, s), this.vertexCount = c || this._calculateVertexCount(this.attributes, this.indices);
  }
  get mode() {
    return this.drawMode;
  }
  getVertexCount() {
    return this.vertexCount;
  }
  getAttributes() {
    return this.indices ? {
      indices: this.indices,
      ...this.attributes
    } : this.attributes;
  }
  _print(e) {
    return "Geometry ".concat(this.id, " attribute ").concat(e);
  }
  _setAttributes(e, t) {
    t && (this.indices = ArrayBuffer.isView(t) ? {
      value: t,
      size: 1
    } : t);
    for (const i in e) {
      let r = e[i];
      r = ArrayBuffer.isView(r) ? {
        value: r
      } : r, Yt(ArrayBuffer.isView(r.value), "".concat(this._print(i), ": must be typed array or object with value as typed array")), (i === "POSITION" || i === "positions") && !r.size && (r.size = 3), i === "indices" ? (Yt(!this.indices), this.indices = r) : this.attributes[i] = r;
    }
    return this.indices && this.indices.isIndexed !== void 0 && (this.indices = Object.assign({}, this.indices), delete this.indices.isIndexed), this;
  }
  _calculateVertexCount(e, t) {
    if (t)
      return t.value.length;
    let i = 1 / 0;
    for (const r in e) {
      const s = e[r], {
        value: c,
        size: l,
        constant: m
      } = s;
      !m && c && l >= 1 && (i = Math.min(i, c.length / l));
    }
    return Yt(Number.isFinite(i)), i;
  }
}
let eF = 1, tF = 1;
class RE {
  constructor() {
    this.time = 0, this.channels = /* @__PURE__ */ new Map(), this.animations = /* @__PURE__ */ new Map(), this.playing = !1, this.lastEngineTime = -1;
  }
  addChannel(e) {
    const {
      delay: t = 0,
      duration: i = Number.POSITIVE_INFINITY,
      rate: r = 1,
      repeat: s = 1
    } = e, c = eF++, l = {
      time: 0,
      delay: t,
      duration: i,
      rate: r,
      repeat: s
    };
    return this._setChannelTime(l, this.time), this.channels.set(c, l), c;
  }
  removeChannel(e) {
    this.channels.delete(e);
    for (const [t, i] of this.animations)
      i.channel === e && this.detachAnimation(t);
  }
  isFinished(e) {
    const t = this.channels.get(e);
    return t === void 0 ? !1 : this.time >= t.delay + t.duration * t.repeat;
  }
  getTime(e) {
    if (e === void 0)
      return this.time;
    const t = this.channels.get(e);
    return t === void 0 ? -1 : t.time;
  }
  setTime(e) {
    this.time = Math.max(0, e);
    const t = this.channels.values();
    for (const r of t)
      this._setChannelTime(r, this.time);
    const i = this.animations.values();
    for (const r of i) {
      const {
        animation: s,
        channel: c
      } = r;
      s.setTime(this.getTime(c));
    }
  }
  play() {
    this.playing = !0;
  }
  pause() {
    this.playing = !1, this.lastEngineTime = -1;
  }
  reset() {
    this.setTime(0);
  }
  attachAnimation(e, t) {
    const i = tF++;
    return this.animations.set(i, {
      animation: e,
      channel: t
    }), e.setTime(this.getTime(t)), i;
  }
  detachAnimation(e) {
    this.animations.delete(e);
  }
  update(e) {
    this.playing && (this.lastEngineTime === -1 && (this.lastEngineTime = e), this.setTime(this.time + (e - this.lastEngineTime)), this.lastEngineTime = e);
  }
  _setChannelTime(e, t) {
    const i = t - e.delay, r = e.duration * e.repeat;
    i >= r ? e.time = e.duration * e.rate : (e.time = Math.max(0, i) % e.duration, e.time *= e.rate);
  }
}
const nF = [255, 255, 255], iF = 1;
let rF = 0;
class OE {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    G(this, "id", void 0), G(this, "color", void 0), G(this, "intensity", void 0), G(this, "type", "ambient");
    const {
      color: t = nF
    } = e, {
      intensity: i = iF
    } = e;
    this.id = e.id || "ambient-".concat(rF++), this.color = t, this.intensity = i;
  }
}
const sF = [255, 255, 255], oF = 1, aF = [0, 0, -1];
let lF = 0;
class Bx {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    G(this, "id", void 0), G(this, "color", void 0), G(this, "intensity", void 0), G(this, "type", "directional"), G(this, "direction", void 0), G(this, "shadow", void 0);
    const {
      color: t = sF
    } = e, {
      intensity: i = oF
    } = e, {
      direction: r = aF
    } = e, {
      _shadow: s = !1
    } = e;
    this.id = e.id || "directional-".concat(lF++), this.color = t, this.intensity = i, this.type = "directional", this.direction = new Qe(r).normalize().toArray(), this.shadow = s;
  }
  getProjectedLight(e) {
    return this;
  }
}
class cF {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      id: "pass"
    };
    G(this, "id", void 0), G(this, "gl", void 0), G(this, "props", void 0);
    const {
      id: i
    } = t;
    this.id = i, this.gl = e, this.props = {
      ...t
    };
  }
  setProps(e) {
    Object.assign(this.props, e);
  }
  render(e) {
  }
  cleanup() {
  }
}
class V1 extends cF {
  constructor() {
    super(...arguments), G(this, "_lastRenderIndex", -1);
  }
  render(e) {
    const t = this.gl;
    return eu(t, {
      framebuffer: e.target
    }), this._drawLayers(e);
  }
  _drawLayers(e) {
    const {
      target: t,
      moduleParameters: i,
      viewports: r,
      views: s,
      onViewportActive: c,
      clearStack: l = !0,
      clearCanvas: m = !0
    } = e;
    e.pass = e.pass || "unknown";
    const y = this.gl;
    m && hF(y, t), l && (this._lastRenderIndex = -1);
    const A = [];
    for (const T of r) {
      const I = s && s[T.id];
      c == null || c(T);
      const L = this._getDrawLayerParams(T, e), N = T.subViewports || [T];
      for (const z of N) {
        const V = this._drawLayersInViewport(y, {
          target: t,
          moduleParameters: i,
          viewport: z,
          view: I,
          pass: e.pass,
          layers: e.layers
        }, L);
        A.push(V);
      }
    }
    return A;
  }
  _getDrawLayerParams(e, t) {
    let {
      layers: i,
      pass: r,
      isPicking: s = !1,
      layerFilter: c,
      cullRect: l,
      effects: m,
      moduleParameters: y
    } = t, A = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    const T = [], I = FE(this._lastRenderIndex + 1), L = {
      layer: i[0],
      viewport: e,
      isPicking: s,
      renderPass: r,
      cullRect: l
    }, N = {};
    for (let z = 0; z < i.length; z++) {
      const V = i[z], H = this._shouldDrawLayer(V, L, c, N), J = {
        shouldDrawLayer: H
      };
      H && !A && (J.layerRenderIndex = I(V, H), J.moduleParameters = this._getModuleParameters(V, m, r, y), J.layerParameters = this.getLayerParameters(V, z, e)), T[z] = J;
    }
    return T;
  }
  _drawLayersInViewport(e, t, i) {
    let {
      layers: r,
      moduleParameters: s,
      pass: c,
      target: l,
      viewport: m,
      view: y
    } = t;
    const A = uF(e, {
      moduleParameters: s,
      target: l,
      viewport: m
    });
    if (y && y.props.clear) {
      const I = y.props.clear === !0 ? {
        color: !0,
        depth: !0
      } : y.props.clear;
      Cl(e, {
        scissorTest: !0,
        scissor: A
      }, () => C1(e, I));
    }
    const T = {
      totalCount: r.length,
      visibleCount: 0,
      compositeCount: 0,
      pickableCount: 0
    };
    eu(e, {
      viewport: A
    });
    for (let I = 0; I < r.length; I++) {
      const L = r[I], {
        shouldDrawLayer: N,
        layerRenderIndex: z,
        moduleParameters: V,
        layerParameters: H
      } = i[I];
      if (N && L.props.pickable && T.pickableCount++, L.isComposite)
        T.compositeCount++;
      else if (N) {
        T.visibleCount++, this._lastRenderIndex = Math.max(this._lastRenderIndex, z), V.viewport = m;
        try {
          L._drawLayer({
            moduleParameters: V,
            uniforms: {
              layerIndex: z
            },
            parameters: H
          });
        } catch (J) {
          L.raiseError(J, "drawing ".concat(L, " to ").concat(c));
        }
      }
    }
    return T;
  }
  shouldDrawLayer(e) {
    return !0;
  }
  getModuleParameters(e, t) {
    return null;
  }
  getLayerParameters(e, t, i) {
    return e.props.parameters;
  }
  _shouldDrawLayer(e, t, i, r) {
    if (!(e.props.visible && this.shouldDrawLayer(e)))
      return !1;
    t.layer = e;
    let c = e.parent;
    for (; c; ) {
      if (!c.props.visible || !c.filterSubLayer(t))
        return !1;
      t.layer = c, c = c.parent;
    }
    if (i) {
      const l = t.layer.id;
      if (l in r || (r[l] = i(t)), !r[l])
        return !1;
    }
    return e.activateViewport(t.viewport), !0;
  }
  _getModuleParameters(e, t, i, r) {
    var s;
    const c = Object.assign(Object.create(((s = e.internalState) === null || s === void 0 ? void 0 : s.propsInTransition) || e.props), {
      autoWrapLongitude: e.wrapLongitude,
      viewport: e.context.viewport,
      mousePosition: e.context.mousePosition,
      pickingActive: 0,
      devicePixelRatio: jd(this.gl)
    });
    if (t)
      for (const m of t) {
        var l;
        Object.assign(c, (l = m.getModuleParameters) === null || l === void 0 ? void 0 : l.call(m, e));
      }
    return Object.assign(c, this.getModuleParameters(e, t), r);
  }
}
function FE() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = {}, i = (r, s) => {
    const c = r.props._offset, l = r.id, m = r.parent && r.parent.id;
    let y;
    if (m && !(m in e) && i(r.parent, !1), m in t) {
      const A = t[m] = t[m] || FE(e[m], e);
      y = A(r, s), t[l] = A;
    } else
      Number.isFinite(c) ? (y = c + (e[m] || 0), t[l] = null) : y = n;
    return s && y >= n && (n = y + 1), e[l] = y, y;
  };
  return i;
}
function uF(n, e) {
  let {
    moduleParameters: t,
    target: i,
    viewport: r
  } = e;
  const s = i && i.id !== "default-framebuffer", c = t && t.devicePixelRatio || jd(n), l = s ? i.height : n.drawingBufferHeight, m = r;
  return [m.x * c, l - (m.y + m.height) * c, m.width * c, m.height * c];
}
function hF(n, e) {
  const t = e ? e.width : n.drawingBufferWidth, i = e ? e.height : n.drawingBufferHeight;
  eu(n, {
    viewport: [0, 0, t, i]
  }), n.clear(16640);
}
class dF extends V1 {
  constructor(e, t) {
    super(e, t), G(this, "shadowMap", void 0), G(this, "depthBuffer", void 0), G(this, "fbo", void 0), this.shadowMap = new ga(e, {
      width: 1,
      height: 1,
      parameters: {
        10241: 9729,
        10240: 9729,
        10242: 33071,
        10243: 33071
      }
    }), this.depthBuffer = new Sd(e, {
      format: 33189,
      width: 1,
      height: 1
    }), this.fbo = new ss(e, {
      id: "shadowmap",
      width: 1,
      height: 1,
      attachments: {
        36064: this.shadowMap,
        36096: this.depthBuffer
      }
    });
  }
  render(e) {
    const t = this.fbo;
    Cl(this.gl, {
      depthRange: [0, 1],
      depthTest: !0,
      blend: !1,
      clearColor: [1, 1, 1, 1]
    }, () => {
      const i = e.viewports[0], r = jd(this.gl), s = i.width * r, c = i.height * r;
      (s !== t.width || c !== t.height) && t.resize({
        width: s,
        height: c
      }), super.render({
        ...e,
        target: t,
        pass: "shadow"
      });
    });
  }
  shouldDrawLayer(e) {
    return e.props.shadowEnabled !== !1;
  }
  getModuleParameters() {
    return {
      drawToShadowMap: !0
    };
  }
  delete() {
    this.fbo && (this.fbo.delete(), this.fbo = null), this.shadowMap && (this.shadowMap.delete(), this.shadowMap = null), this.depthBuffer && (this.depthBuffer.delete(), this.depthBuffer = null);
  }
}
const DE = "#define SMOOTH_EDGE_RADIUS 0.5", fF = `
`.concat(DE, `

struct VertexGeometry {
  vec4 position;
  vec3 worldPosition;
  vec3 worldPositionAlt;
  vec3 normal;
  vec2 uv;
  vec3 pickingColor;
} geometry = VertexGeometry(
  vec4(0.0, 0.0, 1.0, 0.0),
  vec3(0.0),
  vec3(0.0),
  vec3(0.0),
  vec2(0.0),
  vec3(0.0)
);
`), pF = `
`.concat(DE, `

struct FragmentGeometry {
  vec2 uv;
} geometry;

float smoothedge(float edge, float x) {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`), gF = {
  name: "geometry",
  vs: fF,
  fs: pF
}, mF = Object.keys(li).map((n) => "const int COORDINATE_SYSTEM_".concat(n, " = ").concat(li[n], ";")).join(""), _F = Object.keys(uc).map((n) => "const int PROJECTION_MODE_".concat(n, " = ").concat(uc[n], ";")).join(""), yF = Object.keys(ay).map((n) => "const int UNIT_".concat(n.toUpperCase(), " = ").concat(ay[n], ";")).join(""), vF = "".concat(mF, `
`).concat(_F, `
`).concat(yF, `

uniform int project_uCoordinateSystem;
uniform int project_uProjectionMode;
uniform float project_uScale;
uniform bool project_uWrapLongitude;
uniform vec3 project_uCommonUnitsPerMeter;
uniform vec3 project_uCommonUnitsPerWorldUnit;
uniform vec3 project_uCommonUnitsPerWorldUnit2;
uniform vec4 project_uCenter;
uniform mat4 project_uModelMatrix;
uniform mat4 project_uViewProjectionMatrix;
uniform vec2 project_uViewportSize;
uniform float project_uDevicePixelRatio;
uniform float project_uFocalDistance;
uniform vec3 project_uCameraPosition;
uniform vec3 project_uCoordinateOrigin;
uniform vec3 project_uCommonOrigin;
uniform bool project_uPseudoMeters;

const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / (PI * 2.0);
const vec3 ZERO_64_LOW = vec3(0.0);
const float EARTH_RADIUS = 6370972.0;
const float GLOBE_RADIUS = 256.0;
float project_size_at_latitude(float lat) {
  float y = clamp(lat, -89.9, 89.9);
  return 1.0 / cos(radians(y));
}

float project_size() {
  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR &&
    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
    project_uPseudoMeters == false) {
    
    if (geometry.position.w == 0.0) {
      return project_size_at_latitude(geometry.worldPosition.y);
    }
  
    float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
    float y2 = y * y;
    float y4 = y2 * y2;
    float y6 = y4 * y2;
    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
  }
  return 1.0;
}

float project_size_at_latitude(float meters, float lat) {
  return meters * project_uCommonUnitsPerMeter.z * project_size_at_latitude(lat);
}
float project_size(float meters) {
  return meters * project_uCommonUnitsPerMeter.z * project_size();
}

vec2 project_size(vec2 meters) {
  return meters * project_uCommonUnitsPerMeter.xy * project_size();
}

vec3 project_size(vec3 meters) {
  return meters * project_uCommonUnitsPerMeter * project_size();
}

vec4 project_size(vec4 meters) {
  return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);
}
mat3 project_get_orientation_matrix(vec3 up) {
  vec3 uz = normalize(up);
  vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));
  vec3 uy = cross(uz, ux);
  return mat3(ux, uy, uz);
}

bool project_needs_rotation(vec3 commonPosition, out mat3 transform) {
  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {
    transform = project_get_orientation_matrix(commonPosition);
    return true;
  }
  return false;
}
vec3 project_normal(vec3 vector) {
  vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);
  vec3 n = normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);
  mat3 rotation;
  if (project_needs_rotation(geometry.position.xyz, rotation)) {
    n = rotation * n;
  }
  return n;
}

vec4 project_offset_(vec4 offset) {
  float dy = offset.y;
  vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;
  return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}
vec2 project_mercator_(vec2 lnglat) {
  float x = lnglat.x;
  if (project_uWrapLongitude) {
    x = mod(x + 180., 360.0) - 180.;
  }
  float y = clamp(lnglat.y, -89.9, 89.9);
  return vec2(
    radians(x) + PI,
    PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

vec3 project_globe_(vec3 lnglatz) {
  float lambda = radians(lnglatz.x);
  float phi = radians(lnglatz.y);
  float cosPhi = cos(phi);
  float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;

  return vec3(
    sin(lambda) * cosPhi,
    -cos(lambda) * cosPhi,
    sin(phi)
  ) * D;
}
vec4 project_position(vec4 position, vec3 position64Low) {
  vec4 position_world = project_uModelMatrix * position;
  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR) {
    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4(
        project_mercator_(position_world.xy),
        project_size_at_latitude(position_world.z, position_world.y),
        position_world.w
      );
    }
    if (project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
      position_world.xyz += project_uCoordinateOrigin;
    }
  }
  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {
    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4(
        project_globe_(position_world.xyz),
        position_world.w
      );
    }
  }
  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      if (abs(position_world.y - project_uCoordinateOrigin.y) > 0.25) {
        return vec4(
          project_mercator_(position_world.xy) - project_uCommonOrigin.xy,
          project_size(position_world.z),
          position_world.w
        );
      }
    }
  }
  if (project_uProjectionMode == PROJECTION_MODE_IDENTITY ||
    (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
    (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
     project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
    position_world.xyz -= project_uCoordinateOrigin;
  }
  return project_offset_(position_world) + project_offset_(project_uModelMatrix * vec4(position64Low, 0.0));
}

vec4 project_position(vec4 position) {
  return project_position(position, ZERO_64_LOW);
}

vec3 project_position(vec3 position, vec3 position64Low) {
  vec4 projected_position = project_position(vec4(position, 1.0), position64Low);
  return projected_position.xyz;
}

vec3 project_position(vec3 position) {
  vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);
  return projected_position.xyz;
}

vec2 project_position(vec2 position) {
  vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);
  return projected_position.xy;
}

vec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {
  return viewProjectionMatrix * position + center;
}
vec4 project_common_position_to_clipspace(vec4 position) {
  return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);
}
vec2 project_pixel_size_to_clipspace(vec2 pixels) {
  vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;
  return offset * project_uFocalDistance;
}

float project_size_to_pixel(float meters) {
  return project_size(meters) * project_uScale;
}
float project_size_to_pixel(float size, int unit) {
  if (unit == UNIT_METERS) return project_size_to_pixel(size);
  if (unit == UNIT_COMMON) return size * project_uScale;
  return size;
}
float project_pixel_size(float pixels) {
  return pixels / project_uScale;
}
vec2 project_pixel_size(vec2 pixels) {
  return pixels / project_uScale;
}
`);
function bF(n, e) {
  if (n === e)
    return !0;
  if (Array.isArray(n)) {
    const t = n.length;
    if (!e || e.length !== t)
      return !1;
    for (let i = 0; i < t; i++)
      if (n[i] !== e[i])
        return !1;
    return !0;
  }
  return !1;
}
function Fp(n) {
  let e = {}, t;
  return (i) => {
    for (const r in i)
      if (!bF(i[r], e[r])) {
        t = n(i), e = i;
        break;
      }
    return t;
  };
}
const Rx = [0, 0, 0, 0], xF = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], kE = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], wF = [0, 0, 0], NE = [0, 0, 0], AF = Fp(TF);
function zE(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NE;
  t.length < 3 && (t = [t[0], t[1], 0]);
  let i = t, r, s = !0;
  switch (e === li.LNGLAT_OFFSETS || e === li.METER_OFFSETS ? r = t : r = n.isGeospatial ? [Math.fround(n.longitude), Math.fround(n.latitude), 0] : null, n.projectionMode) {
    case uc.WEB_MERCATOR:
      (e === li.LNGLAT || e === li.CARTESIAN) && (r = [0, 0, 0], s = !1);
      break;
    case uc.WEB_MERCATOR_AUTO_OFFSET:
      e === li.LNGLAT ? i = r : e === li.CARTESIAN && (i = [Math.fround(n.center[0]), Math.fround(n.center[1]), 0], r = n.unprojectPosition(i), i[0] -= t[0], i[1] -= t[1], i[2] -= t[2]);
      break;
    case uc.IDENTITY:
      i = n.position.map(Math.fround), i[2] = i[2] || 0;
      break;
    case uc.GLOBE:
      s = !1, r = null;
      break;
    default:
      s = !1;
  }
  return {
    geospatialOrigin: r,
    shaderCoordinateOrigin: i,
    offsetMode: s
  };
}
function EF(n, e, t) {
  const {
    viewMatrixUncentered: i,
    projectionMatrix: r
  } = n;
  let {
    viewMatrix: s,
    viewProjectionMatrix: c
  } = n, l = Rx, m = Rx, y = n.cameraPosition;
  const {
    geospatialOrigin: A,
    shaderCoordinateOrigin: T,
    offsetMode: I
  } = zE(n, e, t);
  return I && (m = n.projectPosition(A || T), y = [y[0] - m[0], y[1] - m[1], y[2] - m[2]], m[3] = 1, l = Rp([], m, c), s = i || s, c = Oh([], r, s), c = Oh([], c, xF)), {
    viewMatrix: s,
    viewProjectionMatrix: c,
    projectionCenter: l,
    originCommon: m,
    cameraPosCommon: y,
    shaderCoordinateOrigin: T,
    geospatialOrigin: A
  };
}
function SF(n) {
  let {
    viewport: e,
    devicePixelRatio: t = 1,
    modelMatrix: i = null,
    coordinateSystem: r = li.DEFAULT,
    coordinateOrigin: s = NE,
    autoWrapLongitude: c = !1
  } = n;
  r === li.DEFAULT && (r = e.isGeospatial ? li.LNGLAT : li.CARTESIAN);
  const l = AF({
    viewport: e,
    devicePixelRatio: t,
    coordinateSystem: r,
    coordinateOrigin: s
  });
  return l.project_uWrapLongitude = c, l.project_uModelMatrix = i || kE, l;
}
function TF(n) {
  let {
    viewport: e,
    devicePixelRatio: t,
    coordinateSystem: i,
    coordinateOrigin: r
  } = n;
  const {
    projectionCenter: s,
    viewProjectionMatrix: c,
    originCommon: l,
    cameraPosCommon: m,
    shaderCoordinateOrigin: y,
    geospatialOrigin: A
  } = EF(e, i, r), T = e.getDistanceScales(), I = [e.width * t, e.height * t], L = Rp([], [0, 0, -e.focalDistance, 1], e.projectionMatrix)[3] || 1, N = {
    project_uCoordinateSystem: i,
    project_uProjectionMode: e.projectionMode,
    project_uCoordinateOrigin: y,
    project_uCommonOrigin: l.slice(0, 3),
    project_uCenter: s,
    project_uPseudoMeters: !!e._pseudoMeters,
    project_uViewportSize: I,
    project_uDevicePixelRatio: t,
    project_uFocalDistance: L,
    project_uCommonUnitsPerMeter: T.unitsPerMeter,
    project_uCommonUnitsPerWorldUnit: T.unitsPerMeter,
    project_uCommonUnitsPerWorldUnit2: wF,
    project_uScale: e.scale,
    project_uWrapLongitude: !1,
    project_uViewProjectionMatrix: c,
    project_uModelMatrix: kE,
    project_uCameraPosition: m
  };
  if (A) {
    const z = e.getDistanceScales(A);
    switch (i) {
      case li.METER_OFFSETS:
        N.project_uCommonUnitsPerWorldUnit = z.unitsPerMeter, N.project_uCommonUnitsPerWorldUnit2 = z.unitsPerMeter2;
        break;
      case li.LNGLAT:
      case li.LNGLAT_OFFSETS:
        e._pseudoMeters || (N.project_uCommonUnitsPerMeter = z.unitsPerMeter), N.project_uCommonUnitsPerWorldUnit = z.unitsPerDegree, N.project_uCommonUnitsPerWorldUnit2 = z.unitsPerDegree2;
        break;
      case li.CARTESIAN:
        N.project_uCommonUnitsPerWorldUnit = [1, 1, z.unitsPerMeter[2]], N.project_uCommonUnitsPerWorldUnit2 = [0, 0, z.unitsPerMeter2[2]];
        break;
    }
  }
  return N;
}
const CF = {};
function IF() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : CF;
  return "viewport" in n ? SF(n) : {};
}
const q1 = {
  name: "project",
  dependencies: [JR, gF],
  vs: vF,
  getUniforms: IF
};
function PF() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function Md(n, e) {
  const t = Rp([], e, n);
  return TE(t, t, 1 / t[3]), t;
}
function Ox(n, e) {
  const t = n % e;
  return t < 0 ? e + t : t;
}
function yy(n, e, t) {
  return n < e ? e : n > t ? t : n;
}
function LF(n) {
  return Math.log(n) * Math.LOG2E;
}
const H1 = Math.log2 || LF;
function nu(n, e) {
  if (!n)
    throw new Error(e || "@math.gl/web-mercator: assertion failed.");
}
const Sl = Math.PI, UE = Sl / 4, Za = Sl / 180, vy = 180 / Sl, Wd = 512, ym = 4003e4, Ag = 85.051129, MF = 1.5;
function BF(n) {
  return H1(n);
}
function mp(n) {
  const [e, t] = n;
  nu(Number.isFinite(e)), nu(Number.isFinite(t) && t >= -90 && t <= 90, "invalid latitude");
  const i = e * Za, r = t * Za, s = Wd * (i + Sl) / (2 * Sl), c = Wd * (Sl + Math.log(Math.tan(UE + r * 0.5))) / (2 * Sl);
  return [s, c];
}
function Xd(n) {
  const [e, t] = n, i = e / Wd * (2 * Sl) - Sl, r = 2 * (Math.atan(Math.exp(t / Wd * (2 * Sl) - Sl)) - UE);
  return [i * vy, r * vy];
}
function RF(n) {
  const {
    latitude: e
  } = n;
  nu(Number.isFinite(e));
  const t = Math.cos(e * Za);
  return BF(ym * t) - 9;
}
function Wg(n) {
  const e = Math.cos(n * Za);
  return Wd / ym / e;
}
function by(n) {
  const {
    latitude: e,
    longitude: t,
    highPrecision: i = !1
  } = n;
  nu(Number.isFinite(e) && Number.isFinite(t));
  const r = Wd, s = Math.cos(e * Za), c = r / 360, l = c / s, m = r / ym / s, y = {
    unitsPerMeter: [m, m, m],
    metersPerUnit: [1 / m, 1 / m, 1 / m],
    unitsPerDegree: [c, l, m],
    degreesPerUnit: [1 / c, 1 / l, 1 / m]
  };
  if (i) {
    const A = Za * Math.tan(e * Za) / s, T = c * A / 2, I = r / ym * A, L = I / l * m;
    y.unitsPerDegree2 = [0, T, I], y.unitsPerMeter2 = [L, 0, L];
  }
  return y;
}
function jE(n, e) {
  const [t, i, r] = n, [s, c, l] = e, {
    unitsPerMeter: m,
    unitsPerMeter2: y
  } = by({
    longitude: t,
    latitude: i,
    highPrecision: !0
  }), A = mp(n);
  A[0] += s * (m[0] + y[0] * c), A[1] += c * (m[1] + y[1] * c);
  const T = Xd(A), I = (r || 0) + (l || 0);
  return Number.isFinite(r) || Number.isFinite(l) ? [T[0], T[1], I] : T;
}
function OF(n) {
  const {
    height: e,
    pitch: t,
    bearing: i,
    altitude: r,
    scale: s,
    center: c
  } = n, l = PF();
  mm(l, l, [0, 0, -r]), EE(l, l, -t * Za), SE(l, l, i * Za);
  const m = s / e;
  return z1(l, l, [m, m, m]), c && mm(l, l, d6([], c)), l;
}
function FF(n) {
  const {
    width: e,
    height: t,
    altitude: i,
    pitch: r = 0,
    offset: s,
    center: c,
    scale: l,
    nearZMultiplier: m = 1,
    farZMultiplier: y = 1
  } = n;
  let {
    fovy: A = vm(MF)
  } = n;
  i !== void 0 && (A = vm(i));
  const T = A * Za, I = r * Za, L = GE(A);
  let N = L;
  c && (N += c[2] * l / Math.cos(I) / t);
  const z = T * (0.5 + (s ? s[1] : 0) / t), V = Math.sin(z) * N / Math.sin(yy(Math.PI / 2 - I - z, 0.01, Math.PI - 0.01)), H = Math.sin(I) * V + N, J = N * 10, ce = Math.min(H * y, J);
  return {
    fov: T,
    aspect: e / t,
    focalDistance: L,
    near: m,
    far: ce
  };
}
function vm(n) {
  return 2 * Math.atan(0.5 / n) * vy;
}
function GE(n) {
  return 0.5 / Math.tan(0.5 * n * Za);
}
function VE(n, e) {
  const [t, i, r = 0] = n;
  return nu(Number.isFinite(t) && Number.isFinite(i) && Number.isFinite(r)), Md(e, [t, i, r, 1]);
}
function W1(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const [i, r, s] = n;
  if (nu(Number.isFinite(i) && Number.isFinite(r), "invalid pixel coordinate"), Number.isFinite(s))
    return Md(e, [i, r, s, 1]);
  const c = Md(e, [i, r, 0, 1]), l = Md(e, [i, r, 1, 1]), m = c[2], y = l[2], A = m === y ? 0 : ((t || 0) - m) / (y - m);
  return fE([], c, l, A);
}
function DF(n) {
  const {
    width: e,
    height: t,
    bounds: i,
    minExtent: r = 0,
    maxZoom: s = 24,
    offset: c = [0, 0]
  } = n, [[l, m], [y, A]] = i, T = kF(n.padding), I = mp([l, yy(A, -Ag, Ag)]), L = mp([y, yy(m, -Ag, Ag)]), N = [Math.max(Math.abs(L[0] - I[0]), r), Math.max(Math.abs(L[1] - I[1]), r)], z = [e - T.left - T.right - Math.abs(c[0]) * 2, t - T.top - T.bottom - Math.abs(c[1]) * 2];
  nu(z[0] > 0 && z[1] > 0);
  const V = z[0] / N[0], H = z[1] / N[1], J = (T.right - T.left) / 2 / V, ce = (T.top - T.bottom) / 2 / H, me = [(L[0] + I[0]) / 2 + J, (L[1] + I[1]) / 2 + ce], Se = Xd(me), De = Math.min(s, H1(Math.abs(Math.min(V, H))));
  return nu(Number.isFinite(De)), {
    longitude: Se[0],
    latitude: Se[1],
    zoom: De
  };
}
function kF() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  return typeof n == "number" ? {
    top: n,
    bottom: n,
    left: n,
    right: n
  } : (nu(Number.isFinite(n.top) && Number.isFinite(n.bottom) && Number.isFinite(n.left) && Number.isFinite(n.right)), n);
}
const Fx = Math.PI / 180;
function NF(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  const {
    width: t,
    height: i,
    unproject: r
  } = n, s = {
    targetZ: e
  }, c = r([0, i], s), l = r([t, i], s);
  let m, y;
  const A = n.fovy ? 0.5 * n.fovy * Fx : Math.atan(0.5 / n.altitude), T = (90 - n.pitch) * Fx;
  return A > T - 0.01 ? (m = Dx(n, 0, e), y = Dx(n, t, e)) : (m = r([0, 0], s), y = r([t, 0], s)), [c, l, y, m];
}
function Dx(n, e, t) {
  const {
    pixelUnprojectionMatrix: i
  } = n, r = Md(i, [e, 0, 1, 1]), s = Md(i, [e, n.height, 1, 1]), l = (t * n.distanceScales.unitsPerMeter[2] - r[2]) / (s[2] - r[2]), m = fE([], r, s, l), y = Xd(m);
  return y.push(t), y;
}
const kx = 512;
function zF(n) {
  const {
    width: e,
    height: t,
    pitch: i = 0
  } = n;
  let {
    longitude: r,
    latitude: s,
    zoom: c,
    bearing: l = 0
  } = n;
  (r < -180 || r > 180) && (r = Ox(r + 180, 360) - 180), (l < -180 || l > 180) && (l = Ox(l + 180, 360) - 180);
  const m = H1(t / kx);
  if (c <= m)
    c = m, s = 0;
  else {
    const y = t / 2 / Math.pow(2, c), A = Xd([0, y])[1];
    if (s < A)
      s = A;
    else {
      const T = Xd([0, kx - y])[1];
      s > T && (s = T);
    }
  }
  return {
    width: e,
    height: t,
    longitude: r,
    latitude: s,
    zoom: c,
    pitch: i,
    bearing: l
  };
}
const UF = `
const int max_lights = 2;
uniform mat4 shadow_uViewProjectionMatrices[max_lights];
uniform vec4 shadow_uProjectCenters[max_lights];
uniform bool shadow_uDrawShadowMap;
uniform bool shadow_uUseShadowMap;
uniform int shadow_uLightId;
uniform float shadow_uLightCount;

varying vec3 shadow_vPosition[max_lights];

vec4 shadow_setVertexPosition(vec4 position_commonspace) {
  if (shadow_uDrawShadowMap) {
    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);
  }
  if (shadow_uUseShadowMap) {
    for (int i = 0; i < max_lights; i++) {
      if(i < int(shadow_uLightCount)) {
        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);
        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;
      }
    }
  }
  return gl_Position;
}
`, jF = `
const int max_lights = 2;
uniform bool shadow_uDrawShadowMap;
uniform bool shadow_uUseShadowMap;
uniform sampler2D shadow_uShadowMap0;
uniform sampler2D shadow_uShadowMap1;
uniform vec4 shadow_uColor;
uniform float shadow_uLightCount;

varying vec3 shadow_vPosition[max_lights];

const vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);
const vec4 bitUnpackShift = 1.0 / bitPackShift;
const vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);

float shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {
  vec4 rgbaDepth = texture2D(shadowMap, position.xy);

  float z = dot(rgbaDepth, bitUnpackShift);
  return smoothstep(0.001, 0.01, position.z - z);
}

vec4 shadow_filterShadowColor(vec4 color) {
  if (shadow_uDrawShadowMap) {
    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);
    rgbaDepth -= rgbaDepth.gbaa * bitMask;
    return rgbaDepth;
  }
  if (shadow_uUseShadowMap) {
    float shadowAlpha = 0.0;
    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);
    if(shadow_uLightCount > 1.0) {
      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);
    }
    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;
    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);

    return vec4(
      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),
      blendedAlpha
    );
  }
  return color;
}
`, GF = Fp(XF), VF = Fp(JF), qF = [0, 0, 0, 1], HF = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
function WF(n, e) {
  const [t, i, r] = n, s = W1([t, i, r], e);
  return Number.isFinite(r) ? s : [s[0], s[1], 0];
}
function XF(n) {
  let {
    viewport: e,
    center: t
  } = n;
  return new ai(e.viewProjectionMatrix).invert().transform(t);
}
function JF(n) {
  let {
    viewport: e,
    shadowMatrices: t
  } = n;
  const i = [], r = e.pixelUnprojectionMatrix, s = e.isGeospatial ? void 0 : 1, c = [[0, 0, s], [e.width, 0, s], [0, e.height, s], [e.width, e.height, s], [0, 0, -1], [e.width, 0, -1], [0, e.height, -1], [e.width, e.height, -1]].map((l) => WF(l, r));
  for (const l of t) {
    const m = l.clone().translate(new Qe(e.center).negate()), y = c.map((T) => m.transform(T)), A = new ai().ortho({
      left: Math.min(...y.map((T) => T[0])),
      right: Math.max(...y.map((T) => T[0])),
      bottom: Math.min(...y.map((T) => T[1])),
      top: Math.max(...y.map((T) => T[1])),
      near: Math.min(...y.map((T) => -T[2])),
      far: Math.max(...y.map((T) => -T[2]))
    });
    i.push(A.multiplyRight(l));
  }
  return i;
}
function $F(n, e) {
  const {
    shadowEnabled: t = !0
  } = n;
  if (!t || !n.shadowMatrices || !n.shadowMatrices.length)
    return {
      shadow_uDrawShadowMap: !1,
      shadow_uUseShadowMap: !1
    };
  const i = {
    shadow_uDrawShadowMap: !!n.drawToShadowMap,
    shadow_uUseShadowMap: n.shadowMaps ? n.shadowMaps.length > 0 : !1,
    shadow_uColor: n.shadowColor || qF,
    shadow_uLightId: n.shadowLightId || 0,
    shadow_uLightCount: n.shadowMatrices.length
  }, r = GF({
    viewport: n.viewport,
    center: e.project_uCenter
  }), s = [], c = VF({
    shadowMatrices: n.shadowMatrices,
    viewport: n.viewport
  }).slice();
  for (let l = 0; l < n.shadowMatrices.length; l++) {
    const m = c[l], y = m.clone().translate(new Qe(n.viewport.center).negate());
    e.project_uCoordinateSystem === li.LNGLAT && e.project_uProjectionMode === uc.WEB_MERCATOR ? (c[l] = y, s[l] = r) : (c[l] = m.clone().multiplyRight(HF), s[l] = y.transform(r));
  }
  for (let l = 0; l < c.length; l++)
    i["shadow_uViewProjectionMatrices[".concat(l, "]")] = c[l], i["shadow_uProjectCenters[".concat(l, "]")] = s[l], n.shadowMaps && n.shadowMaps.length > 0 ? i["shadow_uShadowMap".concat(l)] = n.shadowMaps[l] : i["shadow_uShadowMap".concat(l)] = n.dummyShadowMap;
  return i;
}
const a_ = {
  name: "shadow",
  dependencies: [q1],
  vs: UF,
  fs: jF,
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": `
    position = shadow_setVertexPosition(geometry.position);
    `,
    "fs:DECKGL_FILTER_COLOR": `
    color = shadow_filterShadowColor(color);
    `
  },
  getUniforms: function() {
    let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return "viewport" in n && (n.drawToShadowMap || n.shadowMaps && n.shadowMaps.length > 0) ? $F(n, e) : {};
  }
}, ZF = {
  color: [255, 255, 255],
  intensity: 1
}, Nx = [{
  color: [255, 255, 255],
  intensity: 1,
  direction: [-1, 3, -1]
}, {
  color: [255, 255, 255],
  intensity: 0.9,
  direction: [1, -8, -2.5]
}], YF = [0, 0, 0, 200 / 255];
class X1 {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    G(this, "id", "lighting-effect"), G(this, "props", void 0), G(this, "shadowColor", YF), G(this, "shadow", void 0), G(this, "ambientLight", void 0), G(this, "directionalLights", void 0), G(this, "pointLights", void 0), G(this, "shadowPasses", []), G(this, "shadowMaps", []), G(this, "dummyShadowMap", null), G(this, "programManager", void 0), G(this, "shadowMatrices", void 0), this.setProps(e);
  }
  setProps(e) {
    this.ambientLight = null, this.directionalLights = [], this.pointLights = [];
    for (const t in e) {
      const i = e[t];
      switch (i.type) {
        case "ambient":
          this.ambientLight = i;
          break;
        case "directional":
          this.directionalLights.push(i);
          break;
        case "point":
          this.pointLights.push(i);
          break;
      }
    }
    this._applyDefaultLights(), this.shadow = this.directionalLights.some((t) => t.shadow), this.props = e;
  }
  preRender(e, t) {
    let {
      layers: i,
      layerFilter: r,
      viewports: s,
      onViewportActive: c,
      views: l
    } = t;
    if (this.shadow) {
      this.shadowMatrices = this._calculateMatrices(), this.shadowPasses.length === 0 && this._createShadowPasses(e), this.programManager || (this.programManager = Op.getDefaultProgramManager(e), a_ && this.programManager.addDefaultModule(a_)), this.dummyShadowMap || (this.dummyShadowMap = new ga(e, {
        width: 1,
        height: 1
      }));
      for (let m = 0; m < this.shadowPasses.length; m++)
        this.shadowPasses[m].render({
          layers: i,
          layerFilter: r,
          viewports: s,
          onViewportActive: c,
          views: l,
          moduleParameters: {
            shadowLightId: m,
            dummyShadowMap: this.dummyShadowMap,
            shadowMatrices: this.shadowMatrices
          }
        });
    }
  }
  getModuleParameters(e) {
    const t = this.shadow ? {
      shadowMaps: this.shadowMaps,
      dummyShadowMap: this.dummyShadowMap,
      shadowColor: this.shadowColor,
      shadowMatrices: this.shadowMatrices
    } : {};
    return t.lightSources = {
      ambientLight: this.ambientLight,
      directionalLights: this.directionalLights.map((i) => i.getProjectedLight({
        layer: e
      })),
      pointLights: this.pointLights.map((i) => i.getProjectedLight({
        layer: e
      }))
    }, t;
  }
  cleanup() {
    for (const e of this.shadowPasses)
      e.delete();
    this.shadowPasses.length = 0, this.shadowMaps.length = 0, this.dummyShadowMap && (this.dummyShadowMap.delete(), this.dummyShadowMap = null), this.shadow && this.programManager && (this.programManager.removeDefaultModule(a_), this.programManager = null);
  }
  _calculateMatrices() {
    const e = [];
    for (const t of this.directionalLights) {
      const i = new ai().lookAt({
        eye: new Qe(t.direction).negate()
      });
      e.push(i);
    }
    return e;
  }
  _createShadowPasses(e) {
    for (let t = 0; t < this.directionalLights.length; t++) {
      const i = new dF(e);
      this.shadowPasses[t] = i, this.shadowMaps[t] = i.shadowMap;
    }
  }
  _applyDefaultLights() {
    const {
      ambientLight: e,
      pointLights: t,
      directionalLights: i
    } = this;
    !e && t.length === 0 && i.length === 0 && (this.ambientLight = new OE(ZF), this.directionalLights.push(new Bx(Nx[0]), new Bx(Nx[1])));
  }
}
class KF {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    G(this, "_pool", []), G(this, "opts", {
      overAlloc: 2,
      poolSize: 100
    }), this.setOptions(e);
  }
  setOptions(e) {
    Object.assign(this.opts, e);
  }
  allocate(e, t, i) {
    let {
      size: r = 1,
      type: s,
      padding: c = 0,
      copy: l = !1,
      initialize: m = !1,
      maxCount: y
    } = i;
    const A = s || e && e.constructor || Float32Array, T = t * r + c;
    if (ArrayBuffer.isView(e)) {
      if (T <= e.length)
        return e;
      if (T * e.BYTES_PER_ELEMENT <= e.buffer.byteLength)
        return new A(e.buffer, 0, T);
    }
    let I = 1 / 0;
    y && (I = y * r + c);
    const L = this._allocate(A, T, m, I);
    return e && l ? L.set(e) : m || L.fill(0, 0, 4), this._release(e), L;
  }
  release(e) {
    this._release(e);
  }
  _allocate(e, t, i, r) {
    let s = Math.max(Math.ceil(t * this.opts.overAlloc), 1);
    s > r && (s = r);
    const c = this._pool, l = e.BYTES_PER_ELEMENT * s, m = c.findIndex((y) => y.byteLength >= l);
    if (m >= 0) {
      const y = new e(c.splice(m, 1)[0], 0, s);
      return i && y.fill(0), y;
    }
    return new e(s);
  }
  _release(e) {
    if (!ArrayBuffer.isView(e))
      return;
    const t = this._pool, {
      buffer: i
    } = e, {
      byteLength: r
    } = i, s = t.findIndex((c) => c.byteLength >= r);
    s < 0 ? t.push(i) : (s > 0 || t.length < this.opts.poolSize) && t.splice(s, 0, i), t.length > this.opts.poolSize && t.shift();
  }
}
const _p = new KF();
function Yf() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function QF(n) {
  return [n[12], n[13], n[14]];
}
function eD(n) {
  return {
    left: fd(n[3] + n[0], n[7] + n[4], n[11] + n[8], n[15] + n[12]),
    right: fd(n[3] - n[0], n[7] - n[4], n[11] - n[8], n[15] - n[12]),
    bottom: fd(n[3] + n[1], n[7] + n[5], n[11] + n[9], n[15] + n[13]),
    top: fd(n[3] - n[1], n[7] - n[5], n[11] - n[9], n[15] - n[13]),
    near: fd(n[3] + n[2], n[7] + n[6], n[11] + n[10], n[15] + n[14]),
    far: fd(n[3] - n[2], n[7] - n[6], n[11] - n[10], n[15] - n[14])
  };
}
const zx = new Qe();
function fd(n, e, t, i) {
  zx.set(n, e, t);
  const r = zx.len();
  return {
    distance: i / r,
    normal: new Qe(-n / r, -e / r, -t / r)
  };
}
function tD(n) {
  return n - Math.fround(n);
}
let Nf;
function l_(n, e) {
  const {
    size: t = 1,
    startIndex: i = 0
  } = e, r = e.endIndex !== void 0 ? e.endIndex : n.length, s = (r - i) / t;
  Nf = _p.allocate(Nf, s, {
    type: Float32Array,
    size: t * 2
  });
  let c = i, l = 0;
  for (; c < r; ) {
    for (let m = 0; m < t; m++) {
      const y = n[c++];
      Nf[l + m] = y, Nf[l + m + t] = tD(y);
    }
    l += t * 2;
  }
  return Nf.subarray(0, s * t * 2);
}
function nD(n) {
  let e = null, t = !1;
  for (const i of n)
    i && (e ? (t || (e = [[e[0][0], e[0][1]], [e[1][0], e[1][1]]], t = !0), e[0][0] = Math.min(e[0][0], i[0][0]), e[0][1] = Math.min(e[0][1], i[0][1]), e[1][0] = Math.max(e[1][0], i[1][0]), e[1][1] = Math.max(e[1][1], i[1][1])) : e = i);
  return e;
}
const iD = Math.PI / 180, rD = Yf(), Ux = [0, 0, 0], sD = {
  unitsPerMeter: [1, 1, 1],
  metersPerUnit: [1, 1, 1]
};
function oD(n) {
  let {
    width: e,
    height: t,
    orthographic: i,
    fovyRadians: r,
    focalDistance: s,
    padding: c,
    near: l,
    far: m
  } = n;
  const y = e / t, A = i ? new ai().orthographic({
    fovy: r,
    aspect: y,
    focalDistance: s,
    near: l,
    far: m
  }) : new ai().perspective({
    fovy: r,
    aspect: y,
    near: l,
    far: m
  });
  if (c) {
    const {
      left: T = 0,
      right: I = 0,
      top: L = 0,
      bottom: N = 0
    } = c, z = $c((T + e - I) / 2, 0, e) - e / 2, V = $c((L + t - N) / 2, 0, t) - t / 2;
    A[8] -= z * 2 / e, A[9] += V * 2 / t;
  }
  return A;
}
class Qd {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    G(this, "id", void 0), G(this, "x", void 0), G(this, "y", void 0), G(this, "width", void 0), G(this, "height", void 0), G(this, "padding", void 0), G(this, "isGeospatial", void 0), G(this, "zoom", void 0), G(this, "focalDistance", void 0), G(this, "position", void 0), G(this, "modelMatrix", void 0), G(this, "distanceScales", void 0), G(this, "scale", void 0), G(this, "center", void 0), G(this, "cameraPosition", void 0), G(this, "projectionMatrix", void 0), G(this, "viewMatrix", void 0), G(this, "viewMatrixUncentered", void 0), G(this, "viewMatrixInverse", void 0), G(this, "viewProjectionMatrix", void 0), G(this, "pixelProjectionMatrix", void 0), G(this, "pixelUnprojectionMatrix", void 0), G(this, "resolution", void 0), G(this, "_frustumPlanes", {}), this.id = e.id || this.constructor.displayName || "viewport", this.x = e.x || 0, this.y = e.y || 0, this.width = e.width || 1, this.height = e.height || 1, this.zoom = e.zoom || 0, this.padding = e.padding, this.distanceScales = e.distanceScales || sD, this.focalDistance = e.focalDistance || 1, this.position = e.position || Ux, this.modelMatrix = e.modelMatrix || null;
    const {
      longitude: t,
      latitude: i
    } = e;
    this.isGeospatial = Number.isFinite(i) && Number.isFinite(t), this._initProps(e), this._initMatrices(e), this.equals = this.equals.bind(this), this.project = this.project.bind(this), this.unproject = this.unproject.bind(this), this.projectPosition = this.projectPosition.bind(this), this.unprojectPosition = this.unprojectPosition.bind(this), this.projectFlat = this.projectFlat.bind(this), this.unprojectFlat = this.unprojectFlat.bind(this);
  }
  get subViewports() {
    return null;
  }
  get metersPerPixel() {
    return this.distanceScales.metersPerUnit[2] / this.scale;
  }
  get projectionMode() {
    return this.isGeospatial ? this.zoom < 12 ? uc.WEB_MERCATOR : uc.WEB_MERCATOR_AUTO_OFFSET : uc.IDENTITY;
  }
  equals(e) {
    return e instanceof Qd ? this === e ? !0 : e.width === this.width && e.height === this.height && e.scale === this.scale && Il(e.projectionMatrix, this.projectionMatrix) && Il(e.viewMatrix, this.viewMatrix) : !1;
  }
  project(e) {
    let {
      topLeft: t = !0
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const i = this.projectPosition(e), r = VE(i, this.pixelProjectionMatrix), [s, c] = r, l = t ? c : this.height - c;
    return e.length === 2 ? [s, l] : [s, l, r[2]];
  }
  unproject(e) {
    let {
      topLeft: t = !0,
      targetZ: i
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const [r, s, c] = e, l = t ? s : this.height - s, m = i && i * this.distanceScales.unitsPerMeter[2], y = W1([r, l, c], this.pixelUnprojectionMatrix, m), [A, T, I] = this.unprojectPosition(y);
    return Number.isFinite(c) ? [A, T, I] : Number.isFinite(i) ? [A, T, i] : [A, T];
  }
  projectPosition(e) {
    const [t, i] = this.projectFlat(e), r = (e[2] || 0) * this.distanceScales.unitsPerMeter[2];
    return [t, i, r];
  }
  unprojectPosition(e) {
    const [t, i] = this.unprojectFlat(e), r = (e[2] || 0) * this.distanceScales.metersPerUnit[2];
    return [t, i, r];
  }
  projectFlat(e) {
    if (this.isGeospatial) {
      const t = mp(e);
      return t[1] = $c(t[1], -318, 830), t;
    }
    return e;
  }
  unprojectFlat(e) {
    return this.isGeospatial ? Xd(e) : e;
  }
  getBounds() {
    const t = {
      targetZ: (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}).z || 0
    }, i = this.unproject([0, 0], t), r = this.unproject([this.width, 0], t), s = this.unproject([0, this.height], t), c = this.unproject([this.width, this.height], t);
    return [Math.min(i[0], r[0], s[0], c[0]), Math.min(i[1], r[1], s[1], c[1]), Math.max(i[0], r[0], s[0], c[0]), Math.max(i[1], r[1], s[1], c[1])];
  }
  getDistanceScales(e) {
    return e ? by({
      longitude: e[0],
      latitude: e[1],
      highPrecision: !0
    }) : this.distanceScales;
  }
  containsPixel(e) {
    let {
      x: t,
      y: i,
      width: r = 1,
      height: s = 1
    } = e;
    return t < this.x + this.width && this.x < t + r && i < this.y + this.height && this.y < i + s;
  }
  getFrustumPlanes() {
    return this._frustumPlanes.near ? this._frustumPlanes : (Object.assign(this._frustumPlanes, eD(this.viewProjectionMatrix)), this._frustumPlanes);
  }
  panByPosition(e, t) {
    return null;
  }
  _initProps(e) {
    const t = e.longitude, i = e.latitude;
    this.isGeospatial && (Number.isFinite(e.zoom) || (this.zoom = RF({
      latitude: i
    }) + Math.log2(this.focalDistance)), this.distanceScales = e.distanceScales || by({
      latitude: i,
      longitude: t
    }));
    const r = Math.pow(2, this.zoom);
    this.scale = r;
    const {
      position: s,
      modelMatrix: c
    } = e;
    let l = Ux;
    if (s && (l = c ? new ai(c).transformAsVector(s, []) : s), this.isGeospatial) {
      const m = this.projectPosition([t, i, 0]);
      this.center = new Qe(l).scale(this.distanceScales.unitsPerMeter).add(m);
    } else
      this.center = this.projectPosition(l);
  }
  _initMatrices(e) {
    const {
      viewMatrix: t = rD,
      projectionMatrix: i = null,
      orthographic: r = !1,
      fovyRadians: s,
      fovy: c = 75,
      near: l = 0.1,
      far: m = 1e3,
      padding: y = null,
      focalDistance: A = 1
    } = e;
    this.viewMatrixUncentered = t, this.viewMatrix = new ai().multiplyRight(t).translate(new Qe(this.center).negate()), this.projectionMatrix = i || oD({
      width: this.width,
      height: this.height,
      orthographic: r,
      fovyRadians: s || c * iD,
      focalDistance: A,
      padding: y,
      near: l,
      far: m
    });
    const T = Yf();
    Oh(T, T, this.projectionMatrix), Oh(T, T, this.viewMatrix), this.viewProjectionMatrix = T, this.viewMatrixInverse = my([], this.viewMatrix) || this.viewMatrix, this.cameraPosition = QF(this.viewMatrixInverse);
    const I = Yf(), L = Yf();
    z1(I, I, [this.width / 2, -this.height / 2, 1]), mm(I, I, [1, -1, 0]), Oh(L, I, this.viewProjectionMatrix), this.pixelProjectionMatrix = L, this.pixelUnprojectionMatrix = my(Yf(), this.pixelProjectionMatrix), this.pixelUnprojectionMatrix || hi.warn("Pixel project matrix not invertible")();
  }
}
G(Qd, "displayName", "Viewport");
class Nh extends Qd {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      latitude: t = 0,
      longitude: i = 0,
      zoom: r = 0,
      pitch: s = 0,
      bearing: c = 0,
      nearZMultiplier: l = 0.1,
      farZMultiplier: m = 1.01,
      nearZ: y,
      farZ: A,
      orthographic: T = !1,
      projectionMatrix: I,
      repeat: L = !1,
      worldOffset: N = 0,
      position: z,
      padding: V,
      legacyMeterSizes: H = !1
    } = e;
    let {
      width: J,
      height: ce,
      altitude: me = 1.5
    } = e;
    const Se = Math.pow(2, r);
    J = J || 1, ce = ce || 1;
    let De, Le = null;
    if (I)
      me = I[5] / 2, De = vm(me);
    else {
      e.fovy ? (De = e.fovy, me = GE(De)) : De = vm(me);
      let Ve;
      if (V) {
        const {
          top: Fe = 0,
          bottom: ae = 0
        } = V;
        Ve = [0, $c((Fe + ce - ae) / 2, 0, ce) - ce / 2];
      }
      Le = FF({
        width: J,
        height: ce,
        scale: Se,
        center: z && [0, 0, z[2] * Wg(t)],
        offset: Ve,
        pitch: s,
        fovy: De,
        nearZMultiplier: l,
        farZMultiplier: m
      }), Number.isFinite(y) && (Le.near = y), Number.isFinite(A) && (Le.far = A);
    }
    let ye = OF({
      height: ce,
      pitch: s,
      bearing: c,
      scale: Se,
      altitude: me
    });
    N && (ye = new ai().translate([512 * N, 0, 0]).multiplyLeft(ye)), super({
      ...e,
      width: J,
      height: ce,
      viewMatrix: ye,
      longitude: i,
      latitude: t,
      zoom: r,
      ...Le,
      fovy: De,
      focalDistance: me
    }), G(this, "longitude", void 0), G(this, "latitude", void 0), G(this, "pitch", void 0), G(this, "bearing", void 0), G(this, "altitude", void 0), G(this, "fovy", void 0), G(this, "orthographic", void 0), G(this, "_subViewports", void 0), G(this, "_pseudoMeters", void 0), this.latitude = t, this.longitude = i, this.zoom = r, this.pitch = s, this.bearing = c, this.altitude = me, this.fovy = De, this.orthographic = T, this._subViewports = L ? [] : null, this._pseudoMeters = H, Object.freeze(this);
  }
  get subViewports() {
    if (this._subViewports && !this._subViewports.length) {
      const e = this.getBounds(), t = Math.floor((e[0] + 180) / 360), i = Math.ceil((e[2] - 180) / 360);
      for (let r = t; r <= i; r++) {
        const s = r ? new Nh({
          ...this,
          worldOffset: r
        }) : this;
        this._subViewports.push(s);
      }
    }
    return this._subViewports;
  }
  projectPosition(e) {
    if (this._pseudoMeters)
      return super.projectPosition(e);
    const [t, i] = this.projectFlat(e), r = (e[2] || 0) * Wg(e[1]);
    return [t, i, r];
  }
  unprojectPosition(e) {
    if (this._pseudoMeters)
      return super.unprojectPosition(e);
    const [t, i] = this.unprojectFlat(e), r = (e[2] || 0) / Wg(i);
    return [t, i, r];
  }
  addMetersToLngLat(e, t) {
    return jE(e, t);
  }
  panByPosition(e, t) {
    const i = W1(t, this.pixelUnprojectionMatrix), r = this.projectFlat(e), s = xx([], r, o6([], i)), c = xx([], this.center, s), [l, m] = this.unprojectFlat(c);
    return {
      longitude: l,
      latitude: m
    };
  }
  getBounds() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = NF(this, e.z || 0);
    return [Math.min(t[0][0], t[1][0], t[2][0], t[3][0]), Math.min(t[0][1], t[1][1], t[2][1], t[3][1]), Math.max(t[0][0], t[1][0], t[2][0], t[3][0]), Math.max(t[0][1], t[1][1], t[2][1], t[3][1])];
  }
  fitBounds(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      width: i,
      height: r
    } = this, {
      longitude: s,
      latitude: c,
      zoom: l
    } = DF({
      width: i,
      height: r,
      bounds: e,
      ...t
    });
    return new Nh({
      width: i,
      height: r,
      longitude: s,
      latitude: c,
      zoom: l
    });
  }
}
G(Nh, "displayName", "WebMercatorViewport");
const jx = [0, 0, 0];
function c_(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  const i = e.projectPosition(n);
  if (t && e instanceof Nh) {
    const [r, s, c = 0] = n, l = e.getDistanceScales([r, s]);
    i[2] = c * l.unitsPerMeter[2];
  }
  return i;
}
function aD(n) {
  const {
    viewport: e,
    modelMatrix: t,
    coordinateOrigin: i
  } = n;
  let {
    coordinateSystem: r,
    fromCoordinateSystem: s,
    fromCoordinateOrigin: c
  } = n;
  return r === li.DEFAULT && (r = e.isGeospatial ? li.LNGLAT : li.CARTESIAN), s === void 0 && (s = r), c === void 0 && (c = i), {
    viewport: e,
    coordinateSystem: r,
    coordinateOrigin: i,
    modelMatrix: t,
    fromCoordinateSystem: s,
    fromCoordinateOrigin: c
  };
}
function qE(n, e) {
  let {
    viewport: t,
    modelMatrix: i,
    coordinateSystem: r,
    coordinateOrigin: s,
    offsetMode: c
  } = e, [l, m, y = 0] = n;
  switch (i && ([l, m, y] = Rp([], [l, m, y, 1], i)), r) {
    case li.LNGLAT:
      return c_([l, m, y], t, c);
    case li.LNGLAT_OFFSETS:
      return c_([l + s[0], m + s[1], y + (s[2] || 0)], t, c);
    case li.METER_OFFSETS:
      return c_(jE(s, [l, m, y]), t, c);
    case li.CARTESIAN:
    default:
      return t.isGeospatial ? [l + s[0], m + s[1], y + s[2]] : t.projectPosition([l, m, y]);
  }
}
function lD(n, e) {
  const {
    viewport: t,
    coordinateSystem: i,
    coordinateOrigin: r,
    modelMatrix: s,
    fromCoordinateSystem: c,
    fromCoordinateOrigin: l
  } = aD(e), {
    autoOffset: m = !0
  } = e, {
    geospatialOrigin: y = jx,
    shaderCoordinateOrigin: A = jx,
    offsetMode: T = !1
  } = m ? zE(t, i, r) : {}, I = qE(n, {
    viewport: t,
    modelMatrix: s,
    coordinateSystem: c,
    coordinateOrigin: l,
    offsetMode: T
  });
  if (T) {
    const L = t.projectPosition(y || A);
    y6(I, I, L);
  }
  return I;
}
const Gx = {
  blendFunc: [1, 0, 32771, 0],
  blendEquation: 32774
};
class HE extends V1 {
  constructor() {
    super(...arguments), G(this, "pickZ", void 0), G(this, "_colorEncoderState", null);
  }
  render(e) {
    return "pickingFBO" in e ? this._drawPickingBuffer(e) : super.render(e);
  }
  _drawPickingBuffer(e) {
    let {
      layers: t,
      layerFilter: i,
      views: r,
      viewports: s,
      onViewportActive: c,
      pickingFBO: l,
      deviceRect: {
        x: m,
        y,
        width: A,
        height: T
      },
      cullRect: I,
      effects: L,
      pass: N = "picking",
      pickZ: z,
      moduleParameters: V
    } = e;
    const H = this.gl;
    this.pickZ = z;
    const J = this._resetColorEncoder(z), ce = Cl(H, {
      scissorTest: !0,
      scissor: [m, y, A, T],
      clearColor: [0, 0, 0, 0],
      depthMask: !0,
      depthTest: !0,
      depthRange: [0, 1],
      colorMask: [!0, !0, !0, !0],
      ...Gx,
      blend: !z
    }, () => super.render({
      target: l,
      layers: t,
      layerFilter: i,
      views: r,
      viewports: s,
      onViewportActive: c,
      cullRect: I,
      effects: L == null ? void 0 : L.filter((Se) => Se.useInPicking),
      pass: N,
      isPicking: !0,
      moduleParameters: V
    }));
    return this._colorEncoderState = null, {
      decodePickingColor: J && uD.bind(null, J),
      stats: ce
    };
  }
  shouldDrawLayer(e) {
    const {
      pickable: t,
      operation: i
    } = e.props;
    return t && i.includes("draw") || i.includes("terrain") || i.includes("mask");
  }
  getModuleParameters() {
    return {
      pickingActive: 1,
      pickingAttribute: this.pickZ,
      lightSources: {}
    };
  }
  getLayerParameters(e, t, i) {
    const r = {
      ...e.props.parameters
    }, {
      pickable: s,
      operation: c
    } = e.props;
    return this._colorEncoderState ? s && c.includes("draw") && (Object.assign(r, Gx), r.blend = !0, r.blendColor = cD(this._colorEncoderState, e, i)) : r.blend = !1, c.includes("terrain") && (r.blend = !1), r;
  }
  _resetColorEncoder(e) {
    return this._colorEncoderState = e ? null : {
      byLayer: /* @__PURE__ */ new Map(),
      byAlpha: []
    }, this._colorEncoderState;
  }
}
function cD(n, e, t) {
  const {
    byLayer: i,
    byAlpha: r
  } = n;
  let s, c = i.get(e);
  return c ? (c.viewports.push(t), s = c.a) : (s = i.size + 1, s <= 255 ? (c = {
    a: s,
    layer: e,
    viewports: [t]
  }, i.set(e, c), r[s] = c) : (hi.warn("Too many pickable layers, only picking the first 255")(), s = 0)), [0, 0, 0, s / 255];
}
function uD(n, e) {
  const t = n.byAlpha[e[3]];
  return t && {
    pickedLayer: t.layer,
    pickedViewports: t.viewports,
    pickedObjectIndex: t.layer.decodePickingColor(e)
  };
}
const bd = {
  NO_STATE: "Awaiting state",
  MATCHED: "Matched. State transferred from previous layer",
  INITIALIZED: "Initialized",
  AWAITING_GC: "Discarded. Awaiting garbage collection",
  AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
  FINALIZED: "Finalized! Awaiting garbage collection"
}, bm = Symbol.for("component"), Wu = Symbol.for("propTypes"), u_ = Symbol.for("deprecatedProps"), Bd = Symbol.for("asyncPropDefaults"), zh = Symbol.for("asyncPropOriginal"), Vu = Symbol.for("asyncPropResolved");
function Fm(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : () => !0;
  return Array.isArray(n) ? WE(n, e, []) : e(n) ? [n] : [];
}
function WE(n, e, t) {
  let i = -1;
  for (; ++i < n.length; ) {
    const r = n[i];
    Array.isArray(r) ? WE(r, e, t) : e(r) && t.push(r);
  }
  return t;
}
function hD(n) {
  let {
    target: e,
    source: t,
    start: i = 0,
    count: r = 1
  } = n;
  const s = t.length, c = r * s;
  let l = 0;
  for (let m = i; l < s; l++)
    e[m++] = t[l];
  for (; l < c; )
    l < c - l ? (e.copyWithin(i + l, i, i + l), l *= 2) : (e.copyWithin(i + l, i, i + c - l), l = c);
  return e;
}
class dD {
  constructor(e, t, i) {
    G(this, "id", void 0), G(this, "context", void 0), G(this, "isLoaded", void 0), G(this, "persistent", void 0), G(this, "_loadCount", 0), G(this, "_subscribers", /* @__PURE__ */ new Set()), G(this, "_data", void 0), G(this, "_loader", void 0), G(this, "_error", void 0), G(this, "_content", void 0), this.id = e, this.context = i, this.setData(t);
  }
  subscribe(e) {
    this._subscribers.add(e);
  }
  unsubscribe(e) {
    this._subscribers.delete(e);
  }
  inUse() {
    return this._subscribers.size > 0;
  }
  delete() {
  }
  getData() {
    return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData());
  }
  setData(e, t) {
    if (e === this._data && !t)
      return;
    this._data = e;
    const i = ++this._loadCount;
    let r = e;
    typeof e == "string" && (r = Ju(e)), r instanceof Promise ? (this.isLoaded = !1, this._loader = r.then((s) => {
      this._loadCount === i && (this.isLoaded = !0, this._error = void 0, this._content = s);
    }).catch((s) => {
      this._loadCount === i && (this.isLoaded = !0, this._error = s || !0);
    })) : (this.isLoaded = !0, this._error = void 0, this._content = e);
    for (const s of this._subscribers)
      s.onChange(this.getData());
  }
}
class fD {
  constructor(e) {
    let {
      gl: t,
      protocol: i
    } = e;
    G(this, "protocol", void 0), G(this, "_context", void 0), G(this, "_resources", void 0), G(this, "_consumers", void 0), G(this, "_pruneRequest", void 0), this.protocol = i || "resource://", this._context = {
      gl: t,
      resourceManager: this
    }, this._resources = {}, this._consumers = {}, this._pruneRequest = null;
  }
  contains(e) {
    return e.startsWith(this.protocol) ? !0 : e in this._resources;
  }
  add(e) {
    let {
      resourceId: t,
      data: i,
      forceUpdate: r = !1,
      persistent: s = !0
    } = e, c = this._resources[t];
    c ? c.setData(i, r) : (c = new dD(t, i, this._context), this._resources[t] = c), c.persistent = s;
  }
  remove(e) {
    const t = this._resources[e];
    t && (t.delete(), delete this._resources[e]);
  }
  unsubscribe(e) {
    let {
      consumerId: t
    } = e;
    const i = this._consumers[t];
    if (i) {
      for (const r in i) {
        const s = i[r], c = this._resources[s.resourceId];
        c && c.unsubscribe(s);
      }
      delete this._consumers[t], this.prune();
    }
  }
  subscribe(e) {
    let {
      resourceId: t,
      onChange: i,
      consumerId: r,
      requestId: s = "default"
    } = e;
    const {
      _resources: c,
      protocol: l
    } = this;
    t.startsWith(l) && (t = t.replace(l, ""), c[t] || this.add({
      resourceId: t,
      data: null,
      persistent: !1
    }));
    const m = c[t];
    if (this._track(r, s, m, i), m)
      return m.getData();
  }
  prune() {
    this._pruneRequest || (this._pruneRequest = setTimeout(() => this._prune(), 0));
  }
  finalize() {
    for (const e in this._resources)
      this._resources[e].delete();
  }
  _track(e, t, i, r) {
    const s = this._consumers, c = s[e] = s[e] || {}, l = c[t] || {}, m = l.resourceId && this._resources[l.resourceId];
    m && (m.unsubscribe(l), this.prune()), i && (c[t] = l, l.onChange = r, l.resourceId = i.id, i.subscribe(l));
  }
  _prune() {
    this._pruneRequest = null;
    for (const e of Object.keys(this._resources)) {
      const t = this._resources[e];
      !t.persistent && !t.inUse() && (t.delete(), delete this._resources[e]);
    }
  }
}
const pD = `
vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition
) {
  vec3 projectedPosition = project_position(position, position64Low);
  mat3 rotation;
  if (project_needs_rotation(projectedPosition, rotation)) {
    // offset is specified as ENU
    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe
    offset = rotation * offset;
  }
  commonPosition = vec4(projectedPosition + offset, 1.0);
  return project_common_position_to_clipspace(commonPosition);
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset
) {
  vec4 commonPosition;
  return project_position_to_clipspace(position, position64Low, offset, commonPosition);
}
`, J1 = {
  name: "project32",
  dependencies: [q1],
  vs: pD
}, $1 = {
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": `
    // for picking depth values
    picking_setPickingAttribute(position.z / position.w);
  `,
    "vs:DECKGL_FILTER_COLOR": `
  picking_setPickingColor(geometry.pickingColor);
  `,
    "fs:#decl": `
uniform bool picking_uAttribute;
  `,
    "fs:DECKGL_FILTER_COLOR": {
      order: 99,
      injection: `
  // use highlight color if this fragment belongs to the selected object.
  color = picking_filterHighlightColor(color);

  // use picking color if rendering to picking FBO.
  color = picking_filterPickingColor(color);
    `
    }
  },
  ...SO
}, gD = [q1], mD = ["vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)", "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)", "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)", "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"];
function _D(n) {
  const e = Op.getDefaultProgramManager(n);
  for (const t of gD)
    e.addDefaultModule(t);
  for (const t of mD)
    e.addShaderHook(t);
  return e;
}
const yD = "layerManager.setLayers", vD = "layerManager.activateViewport";
class bD {
  constructor(e) {
    let {
      deck: t,
      stats: i,
      viewport: r,
      timeline: s
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    G(this, "layers", void 0), G(this, "context", void 0), G(this, "resourceManager", void 0), G(this, "_lastRenderedLayers", []), G(this, "_needsRedraw", !1), G(this, "_needsUpdate", !1), G(this, "_nextLayers", null), G(this, "_debug", !1), G(this, "activateViewport", (c) => {
      Xs(vD, this, c), c && (this.context.viewport = c);
    }), this.layers = [], this.resourceManager = new fD({
      gl: e,
      protocol: "deck://"
    }), this.context = {
      mousePosition: null,
      userData: {},
      layerManager: this,
      gl: e,
      deck: t,
      programManager: e && _D(e),
      stats: i || new Cp({
        id: "deck.gl"
      }),
      viewport: r || new Qd({
        id: "DEFAULT-INITIAL-VIEWPORT"
      }),
      timeline: s || new RE(),
      resourceManager: this.resourceManager,
      onError: void 0
    }, Object.seal(this);
  }
  finalize() {
    this.resourceManager.finalize();
    for (const e of this.layers)
      this._finalizeLayer(e);
  }
  needsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    }, t = this._needsRedraw;
    e.clearRedrawFlags && (this._needsRedraw = !1);
    for (const i of this.layers) {
      const r = i.getNeedsRedraw(e);
      t = t || r;
    }
    return t;
  }
  needsUpdate() {
    return this._nextLayers && this._nextLayers !== this._lastRenderedLayers ? "layers changed" : this._needsUpdate;
  }
  setNeedsRedraw(e) {
    this._needsRedraw = this._needsRedraw || e;
  }
  setNeedsUpdate(e) {
    this._needsUpdate = this._needsUpdate || e;
  }
  getLayers() {
    let {
      layerIds: e
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return e ? this.layers.filter((t) => e.find((i) => t.id.indexOf(i) === 0)) : this.layers;
  }
  setProps(e) {
    "debug" in e && (this._debug = e.debug), "userData" in e && (this.context.userData = e.userData), "layers" in e && (this._nextLayers = e.layers), "onError" in e && (this.context.onError = e.onError);
  }
  setLayers(e, t) {
    Xs(yD, this, t, e), this._lastRenderedLayers = e;
    const i = Fm(e, Boolean);
    for (const r of i)
      r.context = this.context;
    this._updateLayers(this.layers, i);
  }
  updateLayers() {
    const e = this.needsUpdate();
    e && (this.setNeedsRedraw("updating layers: ".concat(e)), this.setLayers(this._nextLayers || this._lastRenderedLayers, e)), this._nextLayers = null;
  }
  _handleError(e, t, i) {
    i.raiseError(t, "".concat(e, " of ").concat(i));
  }
  _updateLayers(e, t) {
    const i = {};
    for (const c of e)
      i[c.id] ? hi.warn("Multiple old layers with same id ".concat(c.id))() : i[c.id] = c;
    const r = [];
    this._updateSublayersRecursively(t, i, r), this._finalizeOldLayers(i);
    let s = !1;
    for (const c of r)
      if (c.hasUniformTransition()) {
        s = "Uniform transition in ".concat(c);
        break;
      }
    this._needsUpdate = s, this.layers = r;
  }
  _updateSublayersRecursively(e, t, i) {
    for (const r of e) {
      r.context = this.context;
      const s = t[r.id];
      s === null && hi.warn("Multiple new layers with same id ".concat(r.id))(), t[r.id] = null;
      let c = null;
      try {
        this._debug && s !== r && r.validateProps(), s ? (this._transferLayerState(s, r), this._updateLayer(r)) : this._initializeLayer(r), i.push(r), c = r.isComposite ? r.getSubLayers() : null;
      } catch (l) {
        this._handleError("matching", l, r);
      }
      c && this._updateSublayersRecursively(c, t, i);
    }
  }
  _finalizeOldLayers(e) {
    for (const t in e) {
      const i = e[t];
      i && this._finalizeLayer(i);
    }
  }
  _initializeLayer(e) {
    try {
      e._initialize(), e.lifecycle = bd.INITIALIZED;
    } catch (t) {
      this._handleError("initialization", t, e);
    }
  }
  _transferLayerState(e, t) {
    t._transferState(e), t.lifecycle = bd.MATCHED, t !== e && (e.lifecycle = bd.AWAITING_GC);
  }
  _updateLayer(e) {
    try {
      e._update();
    } catch (t) {
      this._handleError("update", t, e);
    }
  }
  _finalizeLayer(e) {
    this._needsRedraw = this._needsRedraw || "finalized ".concat(e), e.lifecycle = bd.AWAITING_FINALIZATION;
    try {
      e._finalize(), e.lifecycle = bd.FINALIZED;
    } catch (t) {
      this._handleError("finalization", t, e);
    }
  }
}
function hc(n, e, t) {
  if (n === e)
    return !0;
  if (!t || !n || !e)
    return !1;
  if (Array.isArray(n)) {
    if (!Array.isArray(e) || n.length !== e.length)
      return !1;
    for (let i = 0; i < n.length; i++)
      if (!hc(n[i], e[i], t - 1))
        return !1;
    return !0;
  }
  if (Array.isArray(e))
    return !1;
  if (typeof n == "object" && typeof e == "object") {
    const i = Object.keys(n), r = Object.keys(e);
    if (i.length !== r.length)
      return !1;
    for (const s of i)
      if (!e.hasOwnProperty(s) || !hc(n[s], e[s], t - 1))
        return !1;
    return !0;
  }
  return !1;
}
class xD {
  constructor(e) {
    G(this, "width", void 0), G(this, "height", void 0), G(this, "views", void 0), G(this, "viewState", void 0), G(this, "controllers", void 0), G(this, "timeline", void 0), G(this, "_viewports", void 0), G(this, "_viewportMap", void 0), G(this, "_isUpdating", void 0), G(this, "_needsRedraw", void 0), G(this, "_needsUpdate", void 0), G(this, "_eventManager", void 0), G(this, "_eventCallbacks", void 0), this.views = [], this.width = 100, this.height = 100, this.viewState = {}, this.controllers = {}, this.timeline = e.timeline, this._viewports = [], this._viewportMap = {}, this._isUpdating = !1, this._needsRedraw = "First render", this._needsUpdate = "Initialize", this._eventManager = e.eventManager, this._eventCallbacks = {
      onViewStateChange: e.onViewStateChange,
      onInteractionStateChange: e.onInteractionStateChange
    }, Object.seal(this), this.setProps(e);
  }
  finalize() {
    for (const e in this.controllers) {
      const t = this.controllers[e];
      t && t.finalize();
    }
    this.controllers = {};
  }
  needsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    const t = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), t;
  }
  setNeedsUpdate(e) {
    this._needsUpdate = this._needsUpdate || e, this._needsRedraw = this._needsRedraw || e;
  }
  updateViewStates() {
    for (const e in this.controllers) {
      const t = this.controllers[e];
      t && t.updateTransition();
    }
  }
  getViewports(e) {
    return e ? this._viewports.filter((t) => t.containsPixel(e)) : this._viewports;
  }
  getViews() {
    const e = {};
    return this.views.forEach((t) => {
      e[t.id] = t;
    }), e;
  }
  getView(e) {
    return this.views.find((t) => t.id === e);
  }
  getViewState(e) {
    const t = typeof e == "string" ? this.getView(e) : e, i = t && this.viewState[t.getViewStateId()] || this.viewState;
    return t ? t.filterViewState(i) : i;
  }
  getViewport(e) {
    return this._viewportMap[e];
  }
  unproject(e, t) {
    const i = this.getViewports(), r = {
      x: e[0],
      y: e[1]
    };
    for (let s = i.length - 1; s >= 0; --s) {
      const c = i[s];
      if (c.containsPixel(r)) {
        const l = e.slice();
        return l[0] -= c.x, l[1] -= c.y, c.unproject(l, t);
      }
    }
    return null;
  }
  setProps(e) {
    e.views && this._setViews(e.views), e.viewState && this._setViewState(e.viewState), ("width" in e || "height" in e) && this._setSize(e.width, e.height), this._isUpdating || this._update();
  }
  _update() {
    this._isUpdating = !0, this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._isUpdating = !1;
  }
  _setSize(e, t) {
    (e !== this.width || t !== this.height) && (this.width = e, this.height = t, this.setNeedsUpdate("Size changed"));
  }
  _setViews(e) {
    e = Fm(e, Boolean), this._diffViews(e, this.views) && this.setNeedsUpdate("views changed"), this.views = e;
  }
  _setViewState(e) {
    e ? (!hc(e, this.viewState, 3) && this.setNeedsUpdate("viewState changed"), this.viewState = e) : hi.warn("missing `viewState` or `initialViewState`")();
  }
  _onViewStateChange(e, t) {
    this._eventCallbacks.onViewStateChange && this._eventCallbacks.onViewStateChange({
      ...t,
      viewId: e
    });
  }
  _createController(e, t) {
    const i = t.type;
    return new i({
      timeline: this.timeline,
      eventManager: this._eventManager,
      onViewStateChange: this._onViewStateChange.bind(this, t.id),
      onStateChange: this._eventCallbacks.onInteractionStateChange,
      makeViewport: (s) => {
        var c;
        return (c = this.getView(e.id)) === null || c === void 0 ? void 0 : c.makeViewport({
          viewState: s,
          width: this.width,
          height: this.height
        });
      }
    });
  }
  _updateController(e, t, i, r) {
    const s = e.controller;
    if (s && i) {
      const c = {
        ...t,
        ...s,
        id: e.id,
        x: i.x,
        y: i.y,
        width: i.width,
        height: i.height
      };
      return (!r || r.constructor !== s.type) && (r = this._createController(e, c)), r && r.setProps(c), r;
    }
    return null;
  }
  _rebuildViewports() {
    const {
      views: e
    } = this, t = this.controllers;
    this._viewports = [], this.controllers = {};
    let i = !1;
    for (let r = e.length; r--; ) {
      const s = e[r], c = this.getViewState(s), l = s.makeViewport({
        viewState: c,
        width: this.width,
        height: this.height
      });
      let m = t[s.id];
      const y = !!s.controller;
      y && !m && (i = !0), (i || !y) && m && (m.finalize(), m = null), this.controllers[s.id] = this._updateController(s, c, l, m), l && this._viewports.unshift(l);
    }
    for (const r in t) {
      const s = t[r];
      s && !this.controllers[r] && s.finalize();
    }
    this._buildViewportMap();
  }
  _buildViewportMap() {
    this._viewportMap = {}, this._viewports.forEach((e) => {
      e.id && (this._viewportMap[e.id] = this._viewportMap[e.id] || e);
    });
  }
  _diffViews(e, t) {
    return e.length !== t.length ? !0 : e.some((i, r) => !e[r].equals(t[r]));
  }
}
const wD = /([0-9]+\.?[0-9]*)(%|px)/;
function Ru(n) {
  switch (typeof n) {
    case "number":
      return {
        position: n,
        relative: !1
      };
    case "string":
      const e = wD.exec(n);
      if (e && e.length >= 3) {
        const t = e[2] === "%", i = parseFloat(e[1]);
        return {
          position: t ? i / 100 : i,
          relative: t
        };
      }
    default:
      throw new Error("Could not parse position string ".concat(n));
  }
}
function Ou(n, e) {
  return n.relative ? Math.round(n.position * e) : n.position;
}
function Is(n, e) {
  if (!n)
    throw new Error(e || "deck.gl: assertion failed.");
}
class AD {
  constructor(e) {
    G(this, "id", void 0), G(this, "viewportInstance", void 0), G(this, "_x", void 0), G(this, "_y", void 0), G(this, "_width", void 0), G(this, "_height", void 0), G(this, "_padding", void 0), G(this, "props", void 0);
    const {
      id: t,
      x: i = 0,
      y: r = 0,
      width: s = "100%",
      height: c = "100%",
      padding: l = null,
      viewportInstance: m
    } = e || {};
    Is(!m || m instanceof Qd), this.viewportInstance = m, this.id = t || this.constructor.displayName || "view", this.props = {
      ...e,
      id: this.id
    }, this._x = Ru(i), this._y = Ru(r), this._width = Ru(s), this._height = Ru(c), this._padding = l && {
      left: Ru(l.left || 0),
      right: Ru(l.right || 0),
      top: Ru(l.top || 0),
      bottom: Ru(l.bottom || 0)
    }, this.equals = this.equals.bind(this), Object.seal(this);
  }
  equals(e) {
    return this === e ? !0 : this.viewportInstance ? e.viewportInstance ? this.viewportInstance.equals(e.viewportInstance) : !1 : this.ViewportType === e.ViewportType && hc(this.props, e.props, 2);
  }
  makeViewport(e) {
    let {
      width: t,
      height: i,
      viewState: r
    } = e;
    if (this.viewportInstance)
      return this.viewportInstance;
    r = this.filterViewState(r);
    const s = this.getDimensions({
      width: t,
      height: i
    });
    return !s.height || !s.width ? null : new this.ViewportType({
      ...r,
      ...this.props,
      ...s
    });
  }
  getViewStateId() {
    const {
      viewState: e
    } = this.props;
    return typeof e == "string" ? e : (e == null ? void 0 : e.id) || this.id;
  }
  filterViewState(e) {
    if (this.props.viewState && typeof this.props.viewState == "object") {
      if (!this.props.viewState.id)
        return this.props.viewState;
      const t = {
        ...e
      };
      for (const i in this.props.viewState)
        i !== "id" && (t[i] = this.props.viewState[i]);
      return t;
    }
    return e;
  }
  getDimensions(e) {
    let {
      width: t,
      height: i
    } = e;
    const r = {
      x: Ou(this._x, t),
      y: Ou(this._y, i),
      width: Ou(this._width, t),
      height: Ou(this._height, i)
    };
    return this._padding && (r.padding = {
      left: Ou(this._padding.left, t),
      top: Ou(this._padding.top, i),
      right: Ou(this._padding.right, t),
      bottom: Ou(this._padding.bottom, i)
    }), r;
  }
  get controller() {
    const e = this.props.controller;
    return e ? e === !0 ? {
      type: this.ControllerType
    } : typeof e == "function" ? {
      type: e
    } : {
      type: this.ControllerType,
      ...e
    } : null;
  }
}
class Dp {
  constructor(e) {
    G(this, "_inProgress", void 0), G(this, "_handle", void 0), G(this, "_timeline", void 0), G(this, "time", void 0), G(this, "settings", void 0), this._inProgress = !1, this._handle = null, this._timeline = e, this.time = 0, this.settings = {
      duration: 0
    };
  }
  get inProgress() {
    return this._inProgress;
  }
  start(e) {
    var t, i;
    this.cancel(), this.settings = e, this._inProgress = !0, (t = (i = this.settings).onStart) === null || t === void 0 || t.call(i, this);
  }
  end() {
    if (this._inProgress) {
      var e, t;
      this._timeline.removeChannel(this._handle), this._handle = null, this._inProgress = !1, (e = (t = this.settings).onEnd) === null || e === void 0 || e.call(t, this);
    }
  }
  cancel() {
    if (this._inProgress) {
      var e, t;
      (e = (t = this.settings).onInterrupt) === null || e === void 0 || e.call(t, this), this._timeline.removeChannel(this._handle), this._handle = null, this._inProgress = !1;
    }
  }
  update() {
    var e, t;
    if (!this._inProgress)
      return !1;
    if (this._handle === null) {
      const {
        _timeline: i,
        settings: r
      } = this;
      this._handle = i.addChannel({
        delay: i.getTime(),
        duration: r.duration
      });
    }
    return this.time = this._timeline.getTime(this._handle), this._onUpdate(), (e = (t = this.settings).onUpdate) === null || e === void 0 || e.call(t, this), this._timeline.isFinished(this._handle) && this.end(), !0;
  }
  _onUpdate() {
  }
}
const Vx = () => {
}, xy = {
  BREAK: 1,
  SNAP_TO_END: 2,
  IGNORE: 3
}, ED = (n) => n, SD = xy.BREAK;
class TD {
  constructor(e) {
    G(this, "getControllerState", void 0), G(this, "props", void 0), G(this, "propsInTransition", void 0), G(this, "transition", void 0), G(this, "onViewStateChange", void 0), G(this, "onStateChange", void 0), G(this, "_onTransitionUpdate", (t) => {
      const {
        time: i,
        settings: {
          interpolator: r,
          startProps: s,
          endProps: c,
          duration: l,
          easing: m
        }
      } = t, y = m(i / l), A = r.interpolateProps(s, c, y);
      this.propsInTransition = this.getControllerState({
        ...this.props,
        ...A
      }).getViewportProps(), this.onViewStateChange({
        viewState: this.propsInTransition,
        oldViewState: this.props
      });
    }), this.getControllerState = e.getControllerState, this.propsInTransition = null, this.transition = new Dp(e.timeline), this.onViewStateChange = e.onViewStateChange || Vx, this.onStateChange = e.onStateChange || Vx;
  }
  finalize() {
    this.transition.cancel();
  }
  getViewportInTransition() {
    return this.propsInTransition;
  }
  processViewStateChange(e) {
    let t = !1;
    const i = this.props;
    if (this.props = e, !i || this._shouldIgnoreViewportChange(i, e))
      return !1;
    if (this._isTransitionEnabled(e)) {
      let r = i;
      if (this.transition.inProgress) {
        const {
          interruption: s,
          endProps: c
        } = this.transition.settings;
        r = {
          ...i,
          ...s === xy.SNAP_TO_END ? c : this.propsInTransition || i
        };
      }
      this._triggerTransition(r, e), t = !0;
    } else
      this.transition.cancel();
    return t;
  }
  updateTransition() {
    this.transition.update();
  }
  _isTransitionEnabled(e) {
    const {
      transitionDuration: t,
      transitionInterpolator: i
    } = e;
    return (t > 0 || t === "auto") && !!i;
  }
  _isUpdateDueToCurrentTransition(e) {
    return this.transition.inProgress && this.propsInTransition ? this.transition.settings.interpolator.arePropsEqual(e, this.propsInTransition) : !1;
  }
  _shouldIgnoreViewportChange(e, t) {
    return this.transition.inProgress ? this.transition.settings.interruption === xy.IGNORE || this._isUpdateDueToCurrentTransition(t) : this._isTransitionEnabled(t) ? t.transitionInterpolator.arePropsEqual(e, t) : !0;
  }
  _triggerTransition(e, t) {
    const i = this.getControllerState(e), r = this.getControllerState(t).shortestPathFrom(i), s = t.transitionInterpolator, c = s.getDuration ? s.getDuration(e, t) : t.transitionDuration;
    if (c === 0)
      return;
    const l = s.initializeProps(e, r);
    this.propsInTransition = {};
    const m = {
      duration: c,
      easing: t.transitionEasing || ED,
      interpolator: s,
      interruption: t.transitionInterruption || SD,
      startProps: l.start,
      endProps: l.end,
      onStart: t.onTransitionStart,
      onUpdate: this._onTransitionUpdate,
      onInterrupt: this._onTransitionEnd(t.onTransitionInterrupt),
      onEnd: this._onTransitionEnd(t.onTransitionEnd)
    };
    this.transition.start(m), this.onStateChange({
      inTransition: !0
    }), this.updateTransition();
  }
  _onTransitionEnd(e) {
    return (t) => {
      this.propsInTransition = null, this.onStateChange({
        inTransition: !1,
        isZooming: !1,
        isPanning: !1,
        isRotating: !1
      }), e == null || e(t);
    };
  }
}
class CD {
  constructor(e) {
    G(this, "_propsToCompare", void 0), G(this, "_propsToExtract", void 0), G(this, "_requiredProps", void 0);
    const {
      compare: t,
      extract: i,
      required: r
    } = e;
    this._propsToCompare = t, this._propsToExtract = i || t, this._requiredProps = r;
  }
  arePropsEqual(e, t) {
    for (const i of this._propsToCompare)
      if (!(i in e) || !(i in t) || !Il(e[i], t[i]))
        return !1;
    return !0;
  }
  initializeProps(e, t) {
    const i = {}, r = {};
    for (const s of this._propsToExtract)
      (s in e || s in t) && (i[s] = e[s], r[s] = t[s]);
    return this._checkRequiredProps(i), this._checkRequiredProps(r), {
      start: i,
      end: r
    };
  }
  getDuration(e, t) {
    return t.transitionDuration;
  }
  _checkRequiredProps(e) {
    this._requiredProps && this._requiredProps.forEach((t) => {
      const i = e[t];
      Is(Number.isFinite(i) || Array.isArray(i), "".concat(t, " is required for transition"));
    });
  }
}
const ID = ["longitude", "latitude", "zoom", "bearing", "pitch"], PD = ["longitude", "latitude", "zoom"];
class XE extends CD {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = Array.isArray(e) ? e : e.transitionProps, i = Array.isArray(e) ? {} : e;
    i.transitionProps = Array.isArray(t) ? {
      compare: t,
      required: t
    } : t || {
      compare: ID,
      required: PD
    }, super(i.transitionProps), G(this, "opts", void 0), this.opts = i;
  }
  initializeProps(e, t) {
    const i = super.initializeProps(e, t), {
      makeViewport: r,
      around: s
    } = this.opts;
    if (r && s) {
      const c = r(e), l = r(t), m = c.unproject(s);
      i.start.around = s, Object.assign(i.end, {
        around: l.project(m),
        aroundPosition: m,
        width: t.width,
        height: t.height
      });
    }
    return i;
  }
  interpolateProps(e, t, i) {
    const r = {};
    for (const s of this._propsToExtract)
      r[s] = gm(e[s] || 0, t[s] || 0, i);
    if (t.aroundPosition && this.opts.makeViewport) {
      const s = this.opts.makeViewport({
        ...t,
        ...r
      });
      Object.assign(r, s.panByPosition(t.aroundPosition, gm(e.around, t.around, i)));
    }
    return r;
  }
}
const Fu = {
  transitionDuration: 0
}, LD = 300, Eg = (n) => 1 - (1 - n) * (1 - n), pd = {
  WHEEL: ["wheel"],
  PAN: ["panstart", "panmove", "panend"],
  PINCH: ["pinchstart", "pinchmove", "pinchend"],
  TRIPLE_PAN: ["tripanstart", "tripanmove", "tripanend"],
  DOUBLE_TAP: ["doubletap"],
  KEYBOARD: ["keydown"]
}, bh = {};
class MD {
  constructor(e) {
    G(this, "props", void 0), G(this, "state", {}), G(this, "transitionManager", void 0), G(this, "eventManager", void 0), G(this, "onViewStateChange", void 0), G(this, "onStateChange", void 0), G(this, "makeViewport", void 0), G(this, "_controllerState", void 0), G(this, "_events", {}), G(this, "_interactionState", {
      isDragging: !1
    }), G(this, "_customEvents", []), G(this, "_eventStartBlocked", null), G(this, "_panMove", !1), G(this, "invertPan", !1), G(this, "dragMode", "rotate"), G(this, "inertia", 0), G(this, "scrollZoom", !0), G(this, "dragPan", !0), G(this, "dragRotate", !0), G(this, "doubleClickZoom", !0), G(this, "touchZoom", !0), G(this, "touchRotate", !1), G(this, "keyboard", !0), this.transitionManager = new TD({
      ...e,
      getControllerState: (t) => new this.ControllerState(t),
      onViewStateChange: this._onTransition.bind(this),
      onStateChange: this._setInteractionState.bind(this)
    }), this.handleEvent = this.handleEvent.bind(this), this.eventManager = e.eventManager, this.onViewStateChange = e.onViewStateChange || (() => {
    }), this.onStateChange = e.onStateChange || (() => {
    }), this.makeViewport = e.makeViewport;
  }
  set events(e) {
    this.toggleEvents(this._customEvents, !1), this.toggleEvents(e, !0), this._customEvents = e, this.props && this.setProps(this.props);
  }
  finalize() {
    for (const t in this._events)
      if (this._events[t]) {
        var e;
        (e = this.eventManager) === null || e === void 0 || e.off(t, this.handleEvent);
      }
    this.transitionManager.finalize();
  }
  handleEvent(e) {
    this._controllerState = void 0;
    const t = this._eventStartBlocked;
    switch (e.type) {
      case "panstart":
        return t ? !1 : this._onPanStart(e);
      case "panmove":
        return this._onPan(e);
      case "panend":
        return this._onPanEnd(e);
      case "pinchstart":
        return t ? !1 : this._onPinchStart(e);
      case "pinchmove":
        return this._onPinch(e);
      case "pinchend":
        return this._onPinchEnd(e);
      case "tripanstart":
        return t ? !1 : this._onTriplePanStart(e);
      case "tripanmove":
        return this._onTriplePan(e);
      case "tripanend":
        return this._onTriplePanEnd(e);
      case "doubletap":
        return this._onDoubleTap(e);
      case "wheel":
        return this._onWheel(e);
      case "keydown":
        return this._onKeyDown(e);
      default:
        return !1;
    }
  }
  get controllerState() {
    return this._controllerState = this._controllerState || new this.ControllerState({
      makeViewport: this.makeViewport,
      ...this.props,
      ...this.state
    }), this._controllerState;
  }
  getCenter(e) {
    const {
      x: t,
      y: i
    } = this.props, {
      offsetCenter: r
    } = e;
    return [r.x - t, r.y - i];
  }
  isPointInBounds(e, t) {
    const {
      width: i,
      height: r
    } = this.props;
    if (t && t.handled)
      return !1;
    const s = e[0] >= 0 && e[0] <= i && e[1] >= 0 && e[1] <= r;
    return s && t && t.stopPropagation(), s;
  }
  isFunctionKeyPressed(e) {
    const {
      srcEvent: t
    } = e;
    return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey);
  }
  isDragging() {
    return this._interactionState.isDragging || !1;
  }
  blockEvents(e) {
    const t = setTimeout(() => {
      this._eventStartBlocked === t && (this._eventStartBlocked = null);
    }, e);
    this._eventStartBlocked = t;
  }
  setProps(e) {
    e.dragMode && (this.dragMode = e.dragMode), this.props = e, "transitionInterpolator" in e || (e.transitionInterpolator = this._getTransitionProps().transitionInterpolator), this.transitionManager.processViewStateChange(e);
    const {
      inertia: t
    } = e;
    this.inertia = Number.isFinite(t) ? t : t === !0 ? LD : 0;
    const {
      scrollZoom: i = !0,
      dragPan: r = !0,
      dragRotate: s = !0,
      doubleClickZoom: c = !0,
      touchZoom: l = !0,
      touchRotate: m = !1,
      keyboard: y = !0
    } = e, A = !!this.onViewStateChange;
    this.toggleEvents(pd.WHEEL, A && i), this.toggleEvents(pd.PAN, A), this.toggleEvents(pd.PINCH, A && (l || m)), this.toggleEvents(pd.TRIPLE_PAN, A && m), this.toggleEvents(pd.DOUBLE_TAP, A && c), this.toggleEvents(pd.KEYBOARD, A && y), this.scrollZoom = i, this.dragPan = r, this.dragRotate = s, this.doubleClickZoom = c, this.touchZoom = l, this.touchRotate = m, this.keyboard = y;
  }
  updateTransition() {
    this.transitionManager.updateTransition();
  }
  toggleEvents(e, t) {
    this.eventManager && e.forEach((i) => {
      this._events[i] !== t && (this._events[i] = t, t ? this.eventManager.on(i, this.handleEvent) : this.eventManager.off(i, this.handleEvent));
    });
  }
  updateViewport(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const r = {
      ...e.getViewportProps(),
      ...t
    }, s = this.controllerState !== e;
    if (this.state = e.getState(), this._setInteractionState(i), s) {
      const c = this.controllerState && this.controllerState.getViewportProps();
      this.onViewStateChange && this.onViewStateChange({
        viewState: r,
        interactionState: this._interactionState,
        oldViewState: c
      });
    }
  }
  _onTransition(e) {
    this.onViewStateChange({
      ...e,
      interactionState: this._interactionState
    });
  }
  _setInteractionState(e) {
    Object.assign(this._interactionState, e), this.onStateChange(this._interactionState);
  }
  _onPanStart(e) {
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    let i = this.isFunctionKeyPressed(e) || e.rightButton || !1;
    (this.invertPan || this.dragMode === "pan") && (i = !i);
    const r = this.controllerState[i ? "panStart" : "rotateStart"]({
      pos: t
    });
    return this._panMove = i, this.updateViewport(r, Fu, {
      isDragging: !0
    }), !0;
  }
  _onPan(e) {
    return this.isDragging() ? this._panMove ? this._onPanMove(e) : this._onPanRotate(e) : !1;
  }
  _onPanEnd(e) {
    return this.isDragging() ? this._panMove ? this._onPanMoveEnd(e) : this._onPanRotateEnd(e) : !1;
  }
  _onPanMove(e) {
    if (!this.dragPan)
      return !1;
    const t = this.getCenter(e), i = this.controllerState.pan({
      pos: t
    });
    return this.updateViewport(i, Fu, {
      isDragging: !0,
      isPanning: !0
    }), !0;
  }
  _onPanMoveEnd(e) {
    const {
      inertia: t
    } = this;
    if (this.dragPan && t && e.velocity) {
      const i = this.getCenter(e), r = [i[0] + e.velocityX * t / 2, i[1] + e.velocityY * t / 2], s = this.controllerState.pan({
        pos: r
      }).panEnd();
      this.updateViewport(s, {
        ...this._getTransitionProps(),
        transitionDuration: t,
        transitionEasing: Eg
      }, {
        isDragging: !1,
        isPanning: !0
      });
    } else {
      const i = this.controllerState.panEnd();
      this.updateViewport(i, null, {
        isDragging: !1,
        isPanning: !1
      });
    }
    return !0;
  }
  _onPanRotate(e) {
    if (!this.dragRotate)
      return !1;
    const t = this.getCenter(e), i = this.controllerState.rotate({
      pos: t
    });
    return this.updateViewport(i, Fu, {
      isDragging: !0,
      isRotating: !0
    }), !0;
  }
  _onPanRotateEnd(e) {
    const {
      inertia: t
    } = this;
    if (this.dragRotate && t && e.velocity) {
      const i = this.getCenter(e), r = [i[0] + e.velocityX * t / 2, i[1] + e.velocityY * t / 2], s = this.controllerState.rotate({
        pos: r
      }).rotateEnd();
      this.updateViewport(s, {
        ...this._getTransitionProps(),
        transitionDuration: t,
        transitionEasing: Eg
      }, {
        isDragging: !1,
        isRotating: !0
      });
    } else {
      const i = this.controllerState.rotateEnd();
      this.updateViewport(i, null, {
        isDragging: !1,
        isRotating: !1
      });
    }
    return !0;
  }
  _onWheel(e) {
    if (!this.scrollZoom)
      return !1;
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    e.srcEvent.preventDefault();
    const {
      speed: i = 0.01,
      smooth: r = !1
    } = this.scrollZoom === !0 ? {} : this.scrollZoom, {
      delta: s
    } = e;
    let c = 2 / (1 + Math.exp(-Math.abs(s * i)));
    s < 0 && c !== 0 && (c = 1 / c);
    const l = this.controllerState.zoom({
      pos: t,
      scale: c
    });
    return this.updateViewport(l, {
      ...this._getTransitionProps({
        around: t
      }),
      transitionDuration: r ? 250 : 1
    }, {
      isZooming: !0,
      isPanning: !0
    }), !0;
  }
  _onTriplePanStart(e) {
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    const i = this.controllerState.rotateStart({
      pos: t
    });
    return this.updateViewport(i, Fu, {
      isDragging: !0
    }), !0;
  }
  _onTriplePan(e) {
    if (!this.touchRotate || !this.isDragging())
      return !1;
    const t = this.getCenter(e);
    t[0] -= e.deltaX;
    const i = this.controllerState.rotate({
      pos: t
    });
    return this.updateViewport(i, Fu, {
      isDragging: !0,
      isRotating: !0
    }), !0;
  }
  _onTriplePanEnd(e) {
    if (!this.isDragging())
      return !1;
    const {
      inertia: t
    } = this;
    if (this.touchRotate && t && e.velocityY) {
      const i = this.getCenter(e), r = [i[0], i[1] += e.velocityY * t / 2], s = this.controllerState.rotate({
        pos: r
      });
      this.updateViewport(s, {
        ...this._getTransitionProps(),
        transitionDuration: t,
        transitionEasing: Eg
      }, {
        isDragging: !1,
        isRotating: !0
      }), this.blockEvents(t);
    } else {
      const i = this.controllerState.rotateEnd();
      this.updateViewport(i, null, {
        isDragging: !1,
        isRotating: !1
      });
    }
    return !0;
  }
  _onPinchStart(e) {
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    const i = this.controllerState.zoomStart({
      pos: t
    }).rotateStart({
      pos: t
    });
    return bh._startPinchRotation = e.rotation, bh._lastPinchEvent = e, this.updateViewport(i, Fu, {
      isDragging: !0
    }), !0;
  }
  _onPinch(e) {
    if (!this.touchZoom && !this.touchRotate || !this.isDragging())
      return !1;
    let t = this.controllerState;
    if (this.touchZoom) {
      const {
        scale: i
      } = e, r = this.getCenter(e);
      t = t.zoom({
        pos: r,
        scale: i
      });
    }
    if (this.touchRotate) {
      const {
        rotation: i
      } = e;
      t = t.rotate({
        deltaAngleX: bh._startPinchRotation - i
      });
    }
    return this.updateViewport(t, Fu, {
      isDragging: !0,
      isPanning: this.touchZoom,
      isZooming: this.touchZoom,
      isRotating: this.touchRotate
    }), bh._lastPinchEvent = e, !0;
  }
  _onPinchEnd(e) {
    if (!this.isDragging())
      return !1;
    const {
      inertia: t
    } = this, {
      _lastPinchEvent: i
    } = bh;
    if (this.touchZoom && t && i && e.scale !== i.scale) {
      const r = this.getCenter(e);
      let s = this.controllerState.rotateEnd();
      const c = Math.log2(e.scale), l = (c - Math.log2(i.scale)) / (e.deltaTime - i.deltaTime), m = Math.pow(2, c + l * t / 2);
      s = s.zoom({
        pos: r,
        scale: m
      }).zoomEnd(), this.updateViewport(s, {
        ...this._getTransitionProps({
          around: r
        }),
        transitionDuration: t,
        transitionEasing: Eg
      }, {
        isDragging: !1,
        isPanning: this.touchZoom,
        isZooming: this.touchZoom,
        isRotating: !1
      }), this.blockEvents(t);
    } else {
      const r = this.controllerState.zoomEnd().rotateEnd();
      this.updateViewport(r, null, {
        isDragging: !1,
        isPanning: !1,
        isZooming: !1,
        isRotating: !1
      });
    }
    return bh._startPinchRotation = null, bh._lastPinchEvent = null, !0;
  }
  _onDoubleTap(e) {
    if (!this.doubleClickZoom)
      return !1;
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    const i = this.isFunctionKeyPressed(e), r = this.controllerState.zoom({
      pos: t,
      scale: i ? 0.5 : 2
    });
    return this.updateViewport(r, this._getTransitionProps({
      around: t
    }), {
      isZooming: !0,
      isPanning: !0
    }), this.blockEvents(100), !0;
  }
  _onKeyDown(e) {
    if (!this.keyboard)
      return !1;
    const t = this.isFunctionKeyPressed(e), {
      zoomSpeed: i,
      moveSpeed: r,
      rotateSpeedX: s,
      rotateSpeedY: c
    } = this.keyboard === !0 ? {} : this.keyboard, {
      controllerState: l
    } = this;
    let m;
    const y = {};
    switch (e.srcEvent.code) {
      case "Minus":
        m = t ? l.zoomOut(i).zoomOut(i) : l.zoomOut(i), y.isZooming = !0;
        break;
      case "Equal":
        m = t ? l.zoomIn(i).zoomIn(i) : l.zoomIn(i), y.isZooming = !0;
        break;
      case "ArrowLeft":
        t ? (m = l.rotateLeft(s), y.isRotating = !0) : (m = l.moveLeft(r), y.isPanning = !0);
        break;
      case "ArrowRight":
        t ? (m = l.rotateRight(s), y.isRotating = !0) : (m = l.moveRight(r), y.isPanning = !0);
        break;
      case "ArrowUp":
        t ? (m = l.rotateUp(c), y.isRotating = !0) : (m = l.moveUp(r), y.isPanning = !0);
        break;
      case "ArrowDown":
        t ? (m = l.rotateDown(c), y.isRotating = !0) : (m = l.moveDown(r), y.isPanning = !0);
        break;
      default:
        return !1;
    }
    return this.updateViewport(m, this._getTransitionProps(), y), !0;
  }
  _getTransitionProps(e) {
    const {
      transition: t
    } = this;
    return !t || !t.transitionInterpolator ? Fu : e ? {
      ...t,
      transitionInterpolator: new XE({
        ...e,
        ...t.transitionInterpolator.opts,
        makeViewport: this.controllerState.makeViewport
      })
    } : t;
  }
}
class BD {
  constructor(e, t) {
    G(this, "_viewportProps", void 0), G(this, "_state", void 0), this._viewportProps = this.applyConstraints(e), this._state = t;
  }
  getViewportProps() {
    return this._viewportProps;
  }
  getState() {
    return this._state;
  }
}
const qx = 5, RD = 1.2;
class OD extends BD {
  constructor(e) {
    const {
      width: t,
      height: i,
      latitude: r,
      longitude: s,
      zoom: c,
      bearing: l = 0,
      pitch: m = 0,
      altitude: y = 1.5,
      position: A = [0, 0, 0],
      maxZoom: T = 20,
      minZoom: I = 0,
      maxPitch: L = 60,
      minPitch: N = 0,
      startPanLngLat: z,
      startZoomLngLat: V,
      startRotatePos: H,
      startBearing: J,
      startPitch: ce,
      startZoom: me,
      normalize: Se = !0
    } = e;
    Is(Number.isFinite(s)), Is(Number.isFinite(r)), Is(Number.isFinite(c)), super({
      width: t,
      height: i,
      latitude: r,
      longitude: s,
      zoom: c,
      bearing: l,
      pitch: m,
      altitude: y,
      maxZoom: T,
      minZoom: I,
      maxPitch: L,
      minPitch: N,
      normalize: Se,
      position: A
    }, {
      startPanLngLat: z,
      startZoomLngLat: V,
      startRotatePos: H,
      startBearing: J,
      startPitch: ce,
      startZoom: me
    }), G(this, "makeViewport", void 0), this.makeViewport = e.makeViewport;
  }
  panStart(e) {
    let {
      pos: t
    } = e;
    return this._getUpdatedState({
      startPanLngLat: this._unproject(t)
    });
  }
  pan(e) {
    let {
      pos: t,
      startPos: i
    } = e;
    const r = this.getState().startPanLngLat || this._unproject(i);
    if (!r)
      return this;
    const c = this.makeViewport(this.getViewportProps()).panByPosition(r, t);
    return this._getUpdatedState(c);
  }
  panEnd() {
    return this._getUpdatedState({
      startPanLngLat: null
    });
  }
  rotateStart(e) {
    let {
      pos: t
    } = e;
    return this._getUpdatedState({
      startRotatePos: t,
      startBearing: this.getViewportProps().bearing,
      startPitch: this.getViewportProps().pitch
    });
  }
  rotate(e) {
    let {
      pos: t,
      deltaAngleX: i = 0,
      deltaAngleY: r = 0
    } = e;
    const {
      startRotatePos: s,
      startBearing: c,
      startPitch: l
    } = this.getState();
    if (!s || c === void 0 || l === void 0)
      return this;
    let m;
    return t ? m = this._getNewRotation(t, s, l, c) : m = {
      bearing: c + i,
      pitch: l + r
    }, this._getUpdatedState(m);
  }
  rotateEnd() {
    return this._getUpdatedState({
      startBearing: null,
      startPitch: null
    });
  }
  zoomStart(e) {
    let {
      pos: t
    } = e;
    return this._getUpdatedState({
      startZoomLngLat: this._unproject(t),
      startZoom: this.getViewportProps().zoom
    });
  }
  zoom(e) {
    let {
      pos: t,
      startPos: i,
      scale: r
    } = e, {
      startZoom: s,
      startZoomLngLat: c
    } = this.getState();
    if (c || (s = this.getViewportProps().zoom, c = this._unproject(i) || this._unproject(t)), !c)
      return this;
    const {
      maxZoom: l,
      minZoom: m
    } = this.getViewportProps();
    let y = s + Math.log2(r);
    y = $c(y, m, l);
    const A = this.makeViewport({
      ...this.getViewportProps(),
      zoom: y
    });
    return this._getUpdatedState({
      zoom: y,
      ...A.panByPosition(c, t)
    });
  }
  zoomEnd() {
    return this._getUpdatedState({
      startZoomLngLat: null,
      startZoom: null
    });
  }
  zoomIn() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 2;
    return this._zoomFromCenter(e);
  }
  zoomOut() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 2;
    return this._zoomFromCenter(1 / e);
  }
  moveLeft() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
    return this._panFromCenter([e, 0]);
  }
  moveRight() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
    return this._panFromCenter([-e, 0]);
  }
  moveUp() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
    return this._panFromCenter([0, e]);
  }
  moveDown() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
    return this._panFromCenter([0, -e]);
  }
  rotateLeft() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 15;
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing - e
    });
  }
  rotateRight() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 15;
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing + e
    });
  }
  rotateUp() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch + e
    });
  }
  rotateDown() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch - e
    });
  }
  shortestPathFrom(e) {
    const t = e.getViewportProps(), i = {
      ...this.getViewportProps()
    }, {
      bearing: r,
      longitude: s
    } = i;
    return Math.abs(r - t.bearing) > 180 && (i.bearing = r < 0 ? r + 360 : r - 360), Math.abs(s - t.longitude) > 180 && (i.longitude = s < 0 ? s + 360 : s - 360), i;
  }
  applyConstraints(e) {
    const {
      maxZoom: t,
      minZoom: i,
      zoom: r
    } = e;
    e.zoom = $c(r, i, t);
    const {
      maxPitch: s,
      minPitch: c,
      pitch: l
    } = e;
    e.pitch = $c(l, c, s);
    const {
      normalize: m = !0
    } = e;
    return m && Object.assign(e, zF(e)), e;
  }
  _zoomFromCenter(e) {
    const {
      width: t,
      height: i
    } = this.getViewportProps();
    return this.zoom({
      pos: [t / 2, i / 2],
      scale: e
    });
  }
  _panFromCenter(e) {
    const {
      width: t,
      height: i
    } = this.getViewportProps();
    return this.pan({
      startPos: [t / 2, i / 2],
      pos: [t / 2 + e[0], i / 2 + e[1]]
    });
  }
  _getUpdatedState(e) {
    return new this.constructor({
      makeViewport: this.makeViewport,
      ...this.getViewportProps(),
      ...this.getState(),
      ...e
    });
  }
  _unproject(e) {
    const t = this.makeViewport(this.getViewportProps());
    return e && t.unproject(e);
  }
  _getNewRotation(e, t, i, r) {
    const s = e[0] - t[0], c = e[1] - t[1], l = e[1], m = t[1], {
      width: y,
      height: A
    } = this.getViewportProps(), T = s / y;
    let I = 0;
    c > 0 ? Math.abs(A - m) > qx && (I = c / (m - A) * RD) : c < 0 && m > qx && (I = 1 - l / m), I = $c(I, -1, 1);
    const {
      minPitch: L,
      maxPitch: N
    } = this.getViewportProps(), z = r + 180 * T;
    let V = i;
    return I > 0 ? V = i + I * (N - i) : I < 0 && (V = i - I * (L - i)), {
      pitch: V,
      bearing: z
    };
  }
}
class FD extends MD {
  constructor() {
    super(...arguments), G(this, "ControllerState", OD), G(this, "transition", {
      transitionDuration: 300,
      transitionInterpolator: new XE({
        transitionProps: {
          compare: ["longitude", "latitude", "zoom", "bearing", "pitch", "position"],
          required: ["longitude", "latitude", "zoom"]
        }
      })
    }), G(this, "dragMode", "pan");
  }
  setProps(e) {
    e.position = e.position || [0, 0, 0];
    const t = this.props;
    super.setProps(e), (!t || t.height !== e.height) && this.updateViewport(new this.ControllerState({
      makeViewport: this.makeViewport,
      ...e,
      ...this.state
    }));
  }
}
class Z1 extends AD {
  get ViewportType() {
    return Nh;
  }
  get ControllerType() {
    return FD;
  }
}
G(Z1, "displayName", "MapView");
const DD = new X1();
function kD(n, e) {
  var t, i;
  const r = (t = n.order) !== null && t !== void 0 ? t : 1 / 0, s = (i = e.order) !== null && i !== void 0 ? i : 1 / 0;
  return r - s;
}
class ND {
  constructor() {
    G(this, "effects", void 0), G(this, "_resolvedEffects", []), G(this, "_defaultEffects", []), G(this, "_needsRedraw", void 0), this.effects = [], this._needsRedraw = "Initial render", this._setEffects([]);
  }
  addDefaultEffect(e) {
    const t = this._defaultEffects;
    if (!t.find((i) => i.id === e.id)) {
      const i = t.findIndex((r) => kD(r, e) > 0);
      i < 0 ? t.push(e) : t.splice(i, 0, e), this._setEffects(this.effects);
    }
  }
  setProps(e) {
    "effects" in e && (hc(e.effects, this.effects, 1) || this._setEffects(e.effects));
  }
  needsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    const t = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), t;
  }
  getEffects() {
    return this._resolvedEffects;
  }
  _setEffects(e) {
    const t = {};
    for (const r of this.effects)
      t[r.id] = r;
    const i = [];
    for (const r of e) {
      const s = t[r.id];
      s && s !== r ? s.setProps ? (s.setProps(r.props), i.push(s)) : (s.cleanup(), i.push(r)) : i.push(r), delete t[r.id];
    }
    for (const r in t)
      t[r].cleanup();
    this.effects = i, this._resolvedEffects = i.concat(this._defaultEffects), e.some((r) => r instanceof X1) || this._resolvedEffects.push(DD), this._needsRedraw = "effects changed";
  }
  finalize() {
    for (const e of this._resolvedEffects)
      e.cleanup();
    this.effects.length = 0, this._resolvedEffects.length = 0, this._defaultEffects.length = 0;
  }
}
class zD extends V1 {
  shouldDrawLayer(e) {
    const {
      operation: t
    } = e.props;
    return t.includes("draw") || t.includes("terrain");
  }
}
const UD = "deckRenderer.renderLayers";
class jD {
  constructor(e) {
    G(this, "gl", void 0), G(this, "layerFilter", void 0), G(this, "drawPickingColors", void 0), G(this, "drawLayersPass", void 0), G(this, "pickLayersPass", void 0), G(this, "renderCount", void 0), G(this, "_needsRedraw", void 0), G(this, "renderBuffers", void 0), G(this, "lastPostProcessEffect", void 0), this.gl = e, this.layerFilter = null, this.drawPickingColors = !1, this.drawLayersPass = new zD(e), this.pickLayersPass = new HE(e), this.renderCount = 0, this._needsRedraw = "Initial render", this.renderBuffers = [], this.lastPostProcessEffect = null;
  }
  setProps(e) {
    this.layerFilter !== e.layerFilter && (this.layerFilter = e.layerFilter, this._needsRedraw = "layerFilter changed"), this.drawPickingColors !== e.drawPickingColors && (this.drawPickingColors = e.drawPickingColors, this._needsRedraw = "drawPickingColors changed");
  }
  renderLayers(e) {
    if (!e.viewports.length)
      return;
    const t = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass, i = {
      layerFilter: this.layerFilter,
      isPicking: this.drawPickingColors,
      ...e,
      target: e.target || ss.getDefaultFramebuffer(this.gl)
    };
    i.effects && this._preRender(i.effects, i);
    const r = this.lastPostProcessEffect ? this.renderBuffers[0] : i.target, s = t.render({
      ...i,
      target: r
    });
    i.effects && this._postRender(i.effects, i), this.renderCount++, Xs(UD, this, s, e);
  }
  needsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    const t = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), t;
  }
  finalize() {
    const {
      renderBuffers: e
    } = this;
    for (const t of e)
      t.delete();
    e.length = 0;
  }
  _preRender(e, t) {
    this.lastPostProcessEffect = null, t.preRenderStats = t.preRenderStats || {};
    for (const i of e)
      t.preRenderStats[i.id] = i.preRender(this.gl, t), i.postRender && (this.lastPostProcessEffect = i.id);
    this.lastPostProcessEffect && this._resizeRenderBuffers();
  }
  _resizeRenderBuffers() {
    const {
      renderBuffers: e
    } = this;
    e.length === 0 && e.push(new ss(this.gl), new ss(this.gl));
    for (const t of e)
      t.resize();
  }
  _postRender(e, t) {
    const {
      renderBuffers: i
    } = this, r = {
      ...t,
      inputBuffer: i[0],
      swapBuffer: i[1],
      target: null
    };
    for (const s of e)
      if (s.postRender) {
        if (s.id === this.lastPostProcessEffect) {
          r.target = t.target, s.postRender(this.gl, r);
          break;
        }
        const c = s.postRender(this.gl, r);
        r.inputBuffer = c, r.swapBuffer = c === i[0] ? i[1] : i[0];
      }
  }
}
const GD = {
  pickedColor: null,
  pickedObjectIndex: -1
};
function VD(n) {
  let {
    pickedColors: e,
    decodePickingColor: t,
    deviceX: i,
    deviceY: r,
    deviceRadius: s,
    deviceRect: c
  } = n;
  const {
    x: l,
    y: m,
    width: y,
    height: A
  } = c;
  let T = s * s, I = -1, L = 0;
  for (let N = 0; N < A; N++) {
    const z = N + m - r, V = z * z;
    if (V > T)
      L += 4 * y;
    else
      for (let H = 0; H < y; H++) {
        if (e[L + 3] - 1 >= 0) {
          const ce = H + l - i, me = ce * ce + V;
          me <= T && (T = me, I = L);
        }
        L += 4;
      }
  }
  if (I >= 0) {
    const N = e.slice(I, I + 4), z = t(N);
    if (z) {
      const V = Math.floor(I / 4 / y), H = I / 4 - V * y;
      return {
        ...z,
        pickedColor: N,
        pickedX: l + H,
        pickedY: m + V
      };
    }
    hi.error("Picked non-existent layer. Is picking buffer corrupt?")();
  }
  return GD;
}
function qD(n) {
  let {
    pickedColors: e,
    decodePickingColor: t
  } = n;
  const i = /* @__PURE__ */ new Map();
  if (e) {
    for (let r = 0; r < e.length; r += 4)
      if (e[r + 3] - 1 >= 0) {
        const c = e.slice(r, r + 4), l = c.join(",");
        if (!i.has(l)) {
          const m = t(c);
          m ? i.set(l, {
            ...m,
            color: c
          }) : hi.error("Picked non-existent layer. Is picking buffer corrupt?")();
        }
      }
  }
  return Array.from(i.values());
}
function JE(n) {
  let {
    pickInfo: e,
    viewports: t,
    pixelRatio: i,
    x: r,
    y: s,
    z: c
  } = n, l = t[0];
  t.length > 1 && (l = WD((e == null ? void 0 : e.pickedViewports) || t, {
    x: r,
    y: s
  }));
  let m;
  if (l) {
    const y = [r - l.x, s - l.y];
    c !== void 0 && (y[2] = c), m = l.unproject(y);
  }
  return {
    color: null,
    layer: null,
    viewport: l,
    index: -1,
    picked: !1,
    x: r,
    y: s,
    pixel: [r, s],
    coordinate: m,
    devicePixel: e && "pickedX" in e ? [e.pickedX, e.pickedY] : void 0,
    pixelRatio: i
  };
}
function HD(n) {
  const {
    pickInfo: e,
    lastPickedInfo: t,
    mode: i,
    layers: r
  } = n, {
    pickedColor: s,
    pickedLayer: c,
    pickedObjectIndex: l
  } = e, m = c ? [c] : [];
  if (i === "hover") {
    const T = t.index, I = t.layerId, L = c ? c.props.id : null;
    if (L !== I || l !== T) {
      if (L !== I) {
        const N = r.find((z) => z.props.id === I);
        N && m.unshift(N);
      }
      t.layerId = L, t.index = l, t.info = null;
    }
  }
  const y = JE(n), A = /* @__PURE__ */ new Map();
  return A.set(null, y), m.forEach((T) => {
    let I = {
      ...y
    };
    T === c && (I.color = s, I.index = l, I.picked = !0), I = $E({
      layer: T,
      info: I,
      mode: i
    });
    const L = I.layer;
    T === c && i === "hover" && (t.info = I), A.set(L.id, I), i === "hover" && L.updateAutoHighlight(I);
  }), A;
}
function $E(n) {
  let {
    layer: e,
    info: t,
    mode: i
  } = n;
  for (; e && t; ) {
    const r = t.layer || null;
    t.sourceLayer = r, t.layer = e, t = e.getPickingInfo({
      info: t,
      mode: i,
      sourceLayer: r
    }), e = e.parent;
  }
  return t;
}
function WD(n, e) {
  for (let t = n.length - 1; t >= 0; t--) {
    const i = n[t];
    if (i.containsPixel(e))
      return i;
  }
  return n[0];
}
class XD {
  constructor(e) {
    G(this, "gl", void 0), G(this, "pickingFBO", void 0), G(this, "depthFBO", void 0), G(this, "pickLayersPass", void 0), G(this, "layerFilter", void 0), G(this, "lastPickedInfo", void 0), G(this, "_pickable", !0), this.gl = e, this.pickLayersPass = new HE(e), this.lastPickedInfo = {
      index: -1,
      layerId: null,
      info: null
    };
  }
  setProps(e) {
    "layerFilter" in e && (this.layerFilter = e.layerFilter), "_pickable" in e && (this._pickable = e._pickable);
  }
  finalize() {
    this.pickingFBO && this.pickingFBO.delete(), this.depthFBO && (this.depthFBO.color.delete(), this.depthFBO.delete());
  }
  pickObject(e) {
    return this._pickClosestObject(e);
  }
  pickObjects(e) {
    return this._pickVisibleObjects(e);
  }
  getLastPickedObject(e) {
    let {
      x: t,
      y: i,
      layers: r,
      viewports: s
    } = e, c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.lastPickedInfo.info;
    const l = c && c.layer && c.layer.id, m = c && c.viewport && c.viewport.id, y = l ? r.find((L) => L.id === l) : null, A = m && s.find((L) => L.id === m) || s[0], T = A && A.unproject([t - A.x, i - A.y]);
    return {
      ...c,
      ...{
        x: t,
        y: i,
        viewport: A,
        coordinate: T,
        layer: y
      }
    };
  }
  _resizeBuffer() {
    var e, t;
    const {
      gl: i
    } = this;
    if (!this.pickingFBO && (this.pickingFBO = new ss(i), ss.isSupported(i, {
      colorBufferFloat: !0
    }))) {
      const r = new ss(i);
      r.attach({
        36064: new ga(i, {
          format: ei(i) ? 34836 : 6408,
          type: 5126
        })
      }), this.depthFBO = r;
    }
    (e = this.pickingFBO) === null || e === void 0 || e.resize({
      width: i.canvas.width,
      height: i.canvas.height
    }), (t = this.depthFBO) === null || t === void 0 || t.resize({
      width: i.canvas.width,
      height: i.canvas.height
    });
  }
  _getPickable(e) {
    if (this._pickable === !1)
      return null;
    const t = e.filter((i) => this.pickLayersPass.shouldDrawLayer(i) && !i.isComposite);
    return t.length ? t : null;
  }
  _pickClosestObject(e) {
    let {
      layers: t,
      views: i,
      viewports: r,
      x: s,
      y: c,
      radius: l = 0,
      depth: m = 1,
      mode: y = "query",
      unproject3D: A,
      onViewportActive: T,
      effects: I
    } = e;
    const L = this._getPickable(t), N = jd(this.gl);
    if (!L)
      return {
        result: [],
        emptyInfo: JE({
          viewports: r,
          x: s,
          y: c,
          pixelRatio: N
        })
      };
    this._resizeBuffer();
    const z = J0(this.gl, [s, c], !0), V = [z.x + Math.floor(z.width / 2), z.y + Math.floor(z.height / 2)], H = Math.round(l * N), {
      width: J,
      height: ce
    } = this.pickingFBO, me = this._getPickingRect({
      deviceX: V[0],
      deviceY: V[1],
      deviceRadius: H,
      deviceWidth: J,
      deviceHeight: ce
    }), Se = {
      x: s - l,
      y: c - l,
      width: l * 2 + 1,
      height: l * 2 + 1
    };
    let De;
    const Le = [], ye = /* @__PURE__ */ new Set();
    for (let Ve = 0; Ve < m; Ve++) {
      let Fe;
      if (me) {
        const de = this._drawAndSample({
          layers: L,
          views: i,
          viewports: r,
          onViewportActive: T,
          deviceRect: me,
          cullRect: Se,
          effects: I,
          pass: "picking:".concat(y)
        });
        Fe = VD({
          ...de,
          deviceX: V[0],
          deviceY: V[1],
          deviceRadius: H,
          deviceRect: me
        });
      } else
        Fe = {
          pickedColor: null,
          pickedObjectIndex: -1
        };
      let ae;
      if (Fe.pickedLayer && A && this.depthFBO) {
        const {
          pickedColors: de
        } = this._drawAndSample({
          layers: [Fe.pickedLayer],
          views: i,
          viewports: r,
          onViewportActive: T,
          deviceRect: {
            x: Fe.pickedX,
            y: Fe.pickedY,
            width: 1,
            height: 1
          },
          cullRect: Se,
          effects: I,
          pass: "picking:".concat(y, ":z")
        }, !0);
        de[3] && (ae = de[0]);
      }
      Fe.pickedLayer && Ve + 1 < m && (ye.add(Fe.pickedLayer), Fe.pickedLayer.disablePickingIndex(Fe.pickedObjectIndex)), De = HD({
        pickInfo: Fe,
        lastPickedInfo: this.lastPickedInfo,
        mode: y,
        layers: L,
        viewports: r,
        x: s,
        y: c,
        z: ae,
        pixelRatio: N
      });
      for (const de of De.values())
        de.layer && Le.push(de);
      if (!Fe.pickedColor)
        break;
    }
    for (const Ve of ye)
      Ve.restorePickingColors();
    return {
      result: Le,
      emptyInfo: De.get(null)
    };
  }
  _pickVisibleObjects(e) {
    let {
      layers: t,
      views: i,
      viewports: r,
      x: s,
      y: c,
      width: l = 1,
      height: m = 1,
      mode: y = "query",
      maxObjects: A = null,
      onViewportActive: T,
      effects: I
    } = e;
    const L = this._getPickable(t);
    if (!L)
      return [];
    this._resizeBuffer();
    const N = jd(this.gl), z = J0(this.gl, [s, c], !0), V = z.x, H = z.y + z.height, J = J0(this.gl, [s + l, c + m], !0), ce = J.x + J.width, me = J.y, Se = {
      x: V,
      y: me,
      width: ce - V,
      height: H - me
    }, De = this._drawAndSample({
      layers: L,
      views: i,
      viewports: r,
      onViewportActive: T,
      deviceRect: Se,
      cullRect: {
        x: s,
        y: c,
        width: l,
        height: m
      },
      effects: I,
      pass: "picking:".concat(y)
    }), Le = qD(De), ye = /* @__PURE__ */ new Map(), Ve = Number.isFinite(A);
    for (let ae = 0; ae < Le.length; ae++) {
      var Fe;
      if (Ve && A && ye.size >= A)
        break;
      const de = Le[ae];
      let Te = {
        color: de.pickedColor,
        layer: null,
        index: de.pickedObjectIndex,
        picked: !0,
        x: s,
        y: c,
        pixelRatio: N
      };
      Te = $E({
        layer: de.pickedLayer,
        info: Te,
        mode: y
      });
      const be = (Fe = Te.object) !== null && Fe !== void 0 ? Fe : "".concat(Te.layer.id, "[").concat(Te.index, "]");
      ye.has(be) || ye.set(be, Te);
    }
    return Array.from(ye.values());
  }
  _drawAndSample(e) {
    let {
      layers: t,
      views: i,
      viewports: r,
      onViewportActive: s,
      deviceRect: c,
      cullRect: l,
      effects: m,
      pass: y
    } = e, A = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    const T = A ? this.depthFBO : this.pickingFBO, I = {
      layers: t,
      layerFilter: this.layerFilter,
      views: i,
      viewports: r,
      onViewportActive: s,
      pickingFBO: T,
      deviceRect: c,
      cullRect: l,
      effects: m,
      pass: y,
      pickZ: A,
      preRenderStats: {}
    };
    for (const ce of m)
      ce.useInPicking && (I.preRenderStats[ce.id] = ce.preRender(this.gl, I));
    const {
      decodePickingColor: L
    } = this.pickLayersPass.render(I), {
      x: N,
      y: z,
      width: V,
      height: H
    } = c, J = new (A ? Float32Array : Uint8Array)(V * H * 4);
    return Om(T, {
      sourceX: N,
      sourceY: z,
      sourceWidth: V,
      sourceHeight: H,
      target: J
    }), {
      pickedColors: J,
      decodePickingColor: L
    };
  }
  _getPickingRect(e) {
    let {
      deviceX: t,
      deviceY: i,
      deviceRadius: r,
      deviceWidth: s,
      deviceHeight: c
    } = e;
    const l = Math.max(0, t - r), m = Math.max(0, i - r), y = Math.min(s, t + r + 1) - l, A = Math.min(c, i + r + 1) - m;
    return y <= 0 || A <= 0 ? null : {
      x: l,
      y: m,
      width: y,
      height: A
    };
  }
}
const JD = {
  zIndex: "1",
  position: "absolute",
  pointerEvents: "none",
  color: "#a0a7b4",
  backgroundColor: "#29323c",
  padding: "10px",
  top: "0",
  left: "0",
  display: "none"
};
class $D {
  constructor(e) {
    G(this, "el", null), G(this, "isVisible", !1);
    const t = e.parentElement;
    t && (this.el = document.createElement("div"), this.el.className = "deck-tooltip", Object.assign(this.el.style, JD), t.appendChild(this.el));
  }
  setTooltip(e, t, i) {
    const r = this.el;
    if (r) {
      if (typeof e == "string")
        r.innerText = e;
      else if (e)
        e.text && (r.innerText = e.text), e.html && (r.innerHTML = e.html), e.className && (r.className = e.className);
      else {
        this.isVisible = !1, r.style.display = "none";
        return;
      }
      this.isVisible = !0, r.style.display = "block", r.style.transform = "translate(".concat(t, "px, ").concat(i, "px)"), e && typeof e == "object" && "style" in e && Object.assign(r.style, e.style);
    }
  }
  remove() {
    this.el && (this.el.remove(), this.el = null);
  }
}
var ZE = { exports: {} };
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(n) {
  (function(e, t, i, r) {
    var s = ["", "webkit", "Moz", "MS", "ms", "o"], c = t.createElement("div"), l = "function", m = Math.round, y = Math.abs, A = Date.now;
    function T(ue, ge, Re) {
      return setTimeout(ce(ue, Re), ge);
    }
    function I(ue, ge, Re) {
      return Array.isArray(ue) ? (L(ue, Re[ge], Re), !0) : !1;
    }
    function L(ue, ge, Re) {
      var it;
      if (ue)
        if (ue.forEach)
          ue.forEach(ge, Re);
        else if (ue.length !== r)
          for (it = 0; it < ue.length; )
            ge.call(Re, ue[it], it, ue), it++;
        else
          for (it in ue)
            ue.hasOwnProperty(it) && ge.call(Re, ue[it], it, ue);
    }
    function N(ue, ge, Re) {
      var it = "DEPRECATED METHOD: " + ge + `
` + Re + ` AT 
`;
      return function() {
        var St = new Error("get-stack-trace"), Wt = St && St.stack ? St.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace", Pn = e.console && (e.console.warn || e.console.log);
        return Pn && Pn.call(e.console, it, Wt), ue.apply(this, arguments);
      };
    }
    var z;
    typeof Object.assign != "function" ? z = function(ge) {
      if (ge === r || ge === null)
        throw new TypeError("Cannot convert undefined or null to object");
      for (var Re = Object(ge), it = 1; it < arguments.length; it++) {
        var St = arguments[it];
        if (St !== r && St !== null)
          for (var Wt in St)
            St.hasOwnProperty(Wt) && (Re[Wt] = St[Wt]);
      }
      return Re;
    } : z = Object.assign;
    var V = N(function(ge, Re, it) {
      for (var St = Object.keys(Re), Wt = 0; Wt < St.length; )
        (!it || it && ge[St[Wt]] === r) && (ge[St[Wt]] = Re[St[Wt]]), Wt++;
      return ge;
    }, "extend", "Use `assign`."), H = N(function(ge, Re) {
      return V(ge, Re, !0);
    }, "merge", "Use `assign`.");
    function J(ue, ge, Re) {
      var it = ge.prototype, St;
      St = ue.prototype = Object.create(it), St.constructor = ue, St._super = it, Re && z(St, Re);
    }
    function ce(ue, ge) {
      return function() {
        return ue.apply(ge, arguments);
      };
    }
    function me(ue, ge) {
      return typeof ue == l ? ue.apply(ge && ge[0] || r, ge) : ue;
    }
    function Se(ue, ge) {
      return ue === r ? ge : ue;
    }
    function De(ue, ge, Re) {
      L(Fe(ge), function(it) {
        ue.addEventListener(it, Re, !1);
      });
    }
    function Le(ue, ge, Re) {
      L(Fe(ge), function(it) {
        ue.removeEventListener(it, Re, !1);
      });
    }
    function ye(ue, ge) {
      for (; ue; ) {
        if (ue == ge)
          return !0;
        ue = ue.parentNode;
      }
      return !1;
    }
    function Ve(ue, ge) {
      return ue.indexOf(ge) > -1;
    }
    function Fe(ue) {
      return ue.trim().split(/\s+/g);
    }
    function ae(ue, ge, Re) {
      if (ue.indexOf && !Re)
        return ue.indexOf(ge);
      for (var it = 0; it < ue.length; ) {
        if (Re && ue[it][Re] == ge || !Re && ue[it] === ge)
          return it;
        it++;
      }
      return -1;
    }
    function de(ue) {
      return Array.prototype.slice.call(ue, 0);
    }
    function Te(ue, ge, Re) {
      for (var it = [], St = [], Wt = 0; Wt < ue.length; ) {
        var Pn = ue[Wt][ge];
        ae(St, Pn) < 0 && it.push(ue[Wt]), St[Wt] = Pn, Wt++;
      }
      return it = it.sort(function(Di, fr) {
        return Di[ge] > fr[ge];
      }), it;
    }
    function be(ue, ge) {
      for (var Re, it, St = ge[0].toUpperCase() + ge.slice(1), Wt = 0; Wt < s.length; ) {
        if (Re = s[Wt], it = Re ? Re + St : ge, it in ue)
          return it;
        Wt++;
      }
      return r;
    }
    var tt = 1;
    function st() {
      return tt++;
    }
    function lt(ue) {
      var ge = ue.ownerDocument || ue;
      return ge.defaultView || ge.parentWindow || e;
    }
    var Ye = /mobile|tablet|ip(ad|hone|od)|android/i, ht = "ontouchstart" in e, ct = be(e, "PointerEvent") !== r, Pt = ht && Ye.test(navigator.userAgent), se = "touch", Ae = "pen", Ce = "mouse", Ue = "kinect", qe = 25, We = 1, Ke = 2, Ze = 4, At = 8, It = 1, Rt = 2, kt = 4, on = 8, ut = 16, re = Rt | kt, mn = on | ut, Qt = re | mn, pt = ["x", "y"], Et = ["clientX", "clientY"];
    function Lt(ue, ge) {
      var Re = this;
      this.manager = ue, this.callback = ge, this.element = ue.element, this.target = ue.options.inputTarget, this.domHandler = function(it) {
        me(ue.options.enable, [ue]) && Re.handler(it);
      }, this.init();
    }
    Lt.prototype = {
      /**
       * should handle the inputEvent data and trigger the callback
       * @virtual
       */
      handler: function() {
      },
      /**
       * bind the events
       */
      init: function() {
        this.evEl && De(this.element, this.evEl, this.domHandler), this.evTarget && De(this.target, this.evTarget, this.domHandler), this.evWin && De(lt(this.element), this.evWin, this.domHandler);
      },
      /**
       * unbind the events
       */
      destroy: function() {
        this.evEl && Le(this.element, this.evEl, this.domHandler), this.evTarget && Le(this.target, this.evTarget, this.domHandler), this.evWin && Le(lt(this.element), this.evWin, this.domHandler);
      }
    };
    function Ft(ue) {
      var ge, Re = ue.options.inputClass;
      return Re ? ge = Re : ct ? ge = ve : Pt ? ge = Ie : ht ? ge = xt : ge = Nt, new ge(ue, nn);
    }
    function nn(ue, ge, Re) {
      var it = Re.pointers.length, St = Re.changedPointers.length, Wt = ge & We && it - St === 0, Pn = ge & (Ze | At) && it - St === 0;
      Re.isFirst = !!Wt, Re.isFinal = !!Pn, Wt && (ue.session = {}), Re.eventType = ge, Tn(ue, Re), ue.emit("hammer.input", Re), ue.recognize(Re), ue.session.prevInput = Re;
    }
    function Tn(ue, ge) {
      var Re = ue.session, it = ge.pointers, St = it.length;
      Re.firstInput || (Re.firstInput = Un(ge)), St > 1 && !Re.firstMultiple ? Re.firstMultiple = Un(ge) : St === 1 && (Re.firstMultiple = !1);
      var Wt = Re.firstInput, Pn = Re.firstMultiple, Fi = Pn ? Pn.center : Wt.center, Di = ge.center = mt(it);
      ge.timeStamp = A(), ge.deltaTime = ge.timeStamp - Wt.timeStamp, ge.angle = bi(Fi, Di), ge.distance = Bt(Fi, Di), xn(Re, ge), ge.offsetDirection = wn(ge.deltaX, ge.deltaY);
      var fr = hn(ge.deltaTime, ge.deltaX, ge.deltaY);
      ge.overallVelocityX = fr.x, ge.overallVelocityY = fr.y, ge.overallVelocity = y(fr.x) > y(fr.y) ? fr.x : fr.y, ge.scale = Pn ? bn(Pn.pointers, it) : 1, ge.rotation = Pn ? _t(Pn.pointers, it) : 0, ge.maxPointers = Re.prevInput ? ge.pointers.length > Re.prevInput.maxPointers ? ge.pointers.length : Re.prevInput.maxPointers : ge.pointers.length, On(Re, ge);
      var ti = ue.element;
      ye(ge.srcEvent.target, ti) && (ti = ge.srcEvent.target), ge.target = ti;
    }
    function xn(ue, ge) {
      var Re = ge.center, it = ue.offsetDelta || {}, St = ue.prevDelta || {}, Wt = ue.prevInput || {};
      (ge.eventType === We || Wt.eventType === Ze) && (St = ue.prevDelta = {
        x: Wt.deltaX || 0,
        y: Wt.deltaY || 0
      }, it = ue.offsetDelta = {
        x: Re.x,
        y: Re.y
      }), ge.deltaX = St.x + (Re.x - it.x), ge.deltaY = St.y + (Re.y - it.y);
    }
    function On(ue, ge) {
      var Re = ue.lastInterval || ge, it = ge.timeStamp - Re.timeStamp, St, Wt, Pn, Fi;
      if (ge.eventType != At && (it > qe || Re.velocity === r)) {
        var Di = ge.deltaX - Re.deltaX, fr = ge.deltaY - Re.deltaY, ti = hn(it, Di, fr);
        Wt = ti.x, Pn = ti.y, St = y(ti.x) > y(ti.y) ? ti.x : ti.y, Fi = wn(Di, fr), ue.lastInterval = ge;
      } else
        St = Re.velocity, Wt = Re.velocityX, Pn = Re.velocityY, Fi = Re.direction;
      ge.velocity = St, ge.velocityX = Wt, ge.velocityY = Pn, ge.direction = Fi;
    }
    function Un(ue) {
      for (var ge = [], Re = 0; Re < ue.pointers.length; )
        ge[Re] = {
          clientX: m(ue.pointers[Re].clientX),
          clientY: m(ue.pointers[Re].clientY)
        }, Re++;
      return {
        timeStamp: A(),
        pointers: ge,
        center: mt(ge),
        deltaX: ue.deltaX,
        deltaY: ue.deltaY
      };
    }
    function mt(ue) {
      var ge = ue.length;
      if (ge === 1)
        return {
          x: m(ue[0].clientX),
          y: m(ue[0].clientY)
        };
      for (var Re = 0, it = 0, St = 0; St < ge; )
        Re += ue[St].clientX, it += ue[St].clientY, St++;
      return {
        x: m(Re / ge),
        y: m(it / ge)
      };
    }
    function hn(ue, ge, Re) {
      return {
        x: ge / ue || 0,
        y: Re / ue || 0
      };
    }
    function wn(ue, ge) {
      return ue === ge ? It : y(ue) >= y(ge) ? ue < 0 ? Rt : kt : ge < 0 ? on : ut;
    }
    function Bt(ue, ge, Re) {
      Re || (Re = pt);
      var it = ge[Re[0]] - ue[Re[0]], St = ge[Re[1]] - ue[Re[1]];
      return Math.sqrt(it * it + St * St);
    }
    function bi(ue, ge, Re) {
      Re || (Re = pt);
      var it = ge[Re[0]] - ue[Re[0]], St = ge[Re[1]] - ue[Re[1]];
      return Math.atan2(St, it) * 180 / Math.PI;
    }
    function _t(ue, ge) {
      return bi(ge[1], ge[0], Et) + bi(ue[1], ue[0], Et);
    }
    function bn(ue, ge) {
      return Bt(ge[0], ge[1], Et) / Bt(ue[0], ue[1], Et);
    }
    var Gt = {
      mousedown: We,
      mousemove: Ke,
      mouseup: Ze
    }, qn = "mousedown", er = "mousemove mouseup";
    function Nt() {
      this.evEl = qn, this.evWin = er, this.pressed = !1, Lt.apply(this, arguments);
    }
    J(Nt, Lt, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function(ge) {
        var Re = Gt[ge.type];
        Re & We && ge.button === 0 && (this.pressed = !0), Re & Ke && ge.which !== 1 && (Re = Ze), this.pressed && (Re & Ze && (this.pressed = !1), this.callback(this.manager, Re, {
          pointers: [ge],
          changedPointers: [ge],
          pointerType: Ce,
          srcEvent: ge
        }));
      }
    });
    var vr = {
      pointerdown: We,
      pointermove: Ke,
      pointerup: Ze,
      pointercancel: At,
      pointerout: At
    }, ii = {
      2: se,
      3: Ae,
      4: Ce,
      5: Ue
      // see https://twitter.com/jacobrossi/status/480596438489890816
    }, sr = "pointerdown", or = "pointermove pointerup pointercancel";
    e.MSPointerEvent && !e.PointerEvent && (sr = "MSPointerDown", or = "MSPointerMove MSPointerUp MSPointerCancel");
    function ve() {
      this.evEl = sr, this.evWin = or, Lt.apply(this, arguments), this.store = this.manager.session.pointerEvents = [];
    }
    J(ve, Lt, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function(ge) {
        var Re = this.store, it = !1, St = ge.type.toLowerCase().replace("ms", ""), Wt = vr[St], Pn = ii[ge.pointerType] || ge.pointerType, Fi = Pn == se, Di = ae(Re, ge.pointerId, "pointerId");
        Wt & We && (ge.button === 0 || Fi) ? Di < 0 && (Re.push(ge), Di = Re.length - 1) : Wt & (Ze | At) && (it = !0), !(Di < 0) && (Re[Di] = ge, this.callback(this.manager, Wt, {
          pointers: Re,
          changedPointers: [ge],
          pointerType: Pn,
          srcEvent: ge
        }), it && Re.splice(Di, 1));
      }
    });
    var X = {
      touchstart: We,
      touchmove: Ke,
      touchend: Ze,
      touchcancel: At
    }, $ = "touchstart", he = "touchstart touchmove touchend touchcancel";
    function _e() {
      this.evTarget = $, this.evWin = he, this.started = !1, Lt.apply(this, arguments);
    }
    J(_e, Lt, {
      handler: function(ge) {
        var Re = X[ge.type];
        if (Re === We && (this.started = !0), !!this.started) {
          var it = Oe.call(this, ge, Re);
          Re & (Ze | At) && it[0].length - it[1].length === 0 && (this.started = !1), this.callback(this.manager, Re, {
            pointers: it[0],
            changedPointers: it[1],
            pointerType: se,
            srcEvent: ge
          });
        }
      }
    });
    function Oe(ue, ge) {
      var Re = de(ue.touches), it = de(ue.changedTouches);
      return ge & (Ze | At) && (Re = Te(Re.concat(it), "identifier")), [Re, it];
    }
    var je = {
      touchstart: We,
      touchmove: Ke,
      touchend: Ze,
      touchcancel: At
    }, Be = "touchstart touchmove touchend touchcancel";
    function Ie() {
      this.evTarget = Be, this.targetIds = {}, Lt.apply(this, arguments);
    }
    J(Ie, Lt, {
      handler: function(ge) {
        var Re = je[ge.type], it = nt.call(this, ge, Re);
        it && this.callback(this.manager, Re, {
          pointers: it[0],
          changedPointers: it[1],
          pointerType: se,
          srcEvent: ge
        });
      }
    });
    function nt(ue, ge) {
      var Re = de(ue.touches), it = this.targetIds;
      if (ge & (We | Ke) && Re.length === 1)
        return it[Re[0].identifier] = !0, [Re, Re];
      var St, Wt, Pn = de(ue.changedTouches), Fi = [], Di = this.target;
      if (Wt = Re.filter(function(fr) {
        return ye(fr.target, Di);
      }), ge === We)
        for (St = 0; St < Wt.length; )
          it[Wt[St].identifier] = !0, St++;
      for (St = 0; St < Pn.length; )
        it[Pn[St].identifier] && Fi.push(Pn[St]), ge & (Ze | At) && delete it[Pn[St].identifier], St++;
      if (Fi.length)
        return [
          // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
          Te(Wt.concat(Fi), "identifier"),
          Fi
        ];
    }
    var ft = 2500, Xe = 25;
    function xt() {
      Lt.apply(this, arguments);
      var ue = ce(this.handler, this);
      this.touch = new Ie(this.manager, ue), this.mouse = new Nt(this.manager, ue), this.primaryTouch = null, this.lastTouches = [];
    }
    J(xt, Lt, {
      /**
       * handle mouse and touch events
       * @param {Hammer} manager
       * @param {String} inputEvent
       * @param {Object} inputData
       */
      handler: function(ge, Re, it) {
        var St = it.pointerType == se, Wt = it.pointerType == Ce;
        if (!(Wt && it.sourceCapabilities && it.sourceCapabilities.firesTouchEvents)) {
          if (St)
            $t.call(this, Re, it);
          else if (Wt && _n.call(this, it))
            return;
          this.callback(ge, Re, it);
        }
      },
      /**
       * remove the event listeners
       */
      destroy: function() {
        this.touch.destroy(), this.mouse.destroy();
      }
    });
    function $t(ue, ge) {
      ue & We ? (this.primaryTouch = ge.changedPointers[0].identifier, Kt.call(this, ge)) : ue & (Ze | At) && Kt.call(this, ge);
    }
    function Kt(ue) {
      var ge = ue.changedPointers[0];
      if (ge.identifier === this.primaryTouch) {
        var Re = {
          x: ge.clientX,
          y: ge.clientY
        };
        this.lastTouches.push(Re);
        var it = this.lastTouches, St = function() {
          var Wt = it.indexOf(Re);
          Wt > -1 && it.splice(Wt, 1);
        };
        setTimeout(St, ft);
      }
    }
    function _n(ue) {
      for (var ge = ue.srcEvent.clientX, Re = ue.srcEvent.clientY, it = 0; it < this.lastTouches.length; it++) {
        var St = this.lastTouches[it], Wt = Math.abs(ge - St.x), Pn = Math.abs(Re - St.y);
        if (Wt <= Xe && Pn <= Xe)
          return !0;
      }
      return !1;
    }
    var An = be(c.style, "touchAction"), an = An !== r, Fn = "compute", Yn = "auto", Kn = "manipulation", dn = "none", Dn = "pan-x", Jn = "pan-y", di = yo();
    function Bi(ue, ge) {
      this.manager = ue, this.set(ge);
    }
    Bi.prototype = {
      /**
       * set the touchAction value on the element or enable the polyfill
       * @param {String} value
       */
      set: function(ue) {
        ue == Fn && (ue = this.compute()), an && this.manager.element.style && di[ue] && (this.manager.element.style[An] = ue), this.actions = ue.toLowerCase().trim();
      },
      /**
       * just re-set the touchAction value
       */
      update: function() {
        this.set(this.manager.options.touchAction);
      },
      /**
       * compute the value for the touchAction property based on the recognizer's settings
       * @returns {String} value
       */
      compute: function() {
        var ue = [];
        return L(this.manager.recognizers, function(ge) {
          me(ge.options.enable, [ge]) && (ue = ue.concat(ge.getTouchAction()));
        }), Xi(ue.join(" "));
      },
      /**
       * this method is called on each input cycle and provides the preventing of the browser behavior
       * @param {Object} input
       */
      preventDefaults: function(ue) {
        var ge = ue.srcEvent, Re = ue.offsetDirection;
        if (this.manager.session.prevented) {
          ge.preventDefault();
          return;
        }
        var it = this.actions, St = Ve(it, dn) && !di[dn], Wt = Ve(it, Jn) && !di[Jn], Pn = Ve(it, Dn) && !di[Dn];
        if (St) {
          var Fi = ue.pointers.length === 1, Di = ue.distance < 2, fr = ue.deltaTime < 250;
          if (Fi && Di && fr)
            return;
        }
        if (!(Pn && Wt) && (St || Wt && Re & re || Pn && Re & mn))
          return this.preventSrc(ge);
      },
      /**
       * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
       * @param {Object} srcEvent
       */
      preventSrc: function(ue) {
        this.manager.session.prevented = !0, ue.preventDefault();
      }
    };
    function Xi(ue) {
      if (Ve(ue, dn))
        return dn;
      var ge = Ve(ue, Dn), Re = Ve(ue, Jn);
      return ge && Re ? dn : ge || Re ? ge ? Dn : Jn : Ve(ue, Kn) ? Kn : Yn;
    }
    function yo() {
      if (!an)
        return !1;
      var ue = {}, ge = e.CSS && e.CSS.supports;
      return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(Re) {
        ue[Re] = ge ? e.CSS.supports("touch-action", Re) : !0;
      }), ue;
    }
    var Xn = 1, br = 2, Hr = 4, Ri = 8, Oi = Ri, Ys = 16, Ii = 32;
    function fi(ue) {
      this.options = z({}, this.defaults, ue || {}), this.id = st(), this.manager = null, this.options.enable = Se(this.options.enable, !0), this.state = Xn, this.simultaneous = {}, this.requireFail = [];
    }
    fi.prototype = {
      /**
       * @virtual
       * @type {Object}
       */
      defaults: {},
      /**
       * set options
       * @param {Object} options
       * @return {Recognizer}
       */
      set: function(ue) {
        return z(this.options, ue), this.manager && this.manager.touchAction.update(), this;
      },
      /**
       * recognize simultaneous with an other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      recognizeWith: function(ue) {
        if (I(ue, "recognizeWith", this))
          return this;
        var ge = this.simultaneous;
        return ue = xi(ue, this), ge[ue.id] || (ge[ue.id] = ue, ue.recognizeWith(this)), this;
      },
      /**
       * drop the simultaneous link. it doesnt remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRecognizeWith: function(ue) {
        return I(ue, "dropRecognizeWith", this) ? this : (ue = xi(ue, this), delete this.simultaneous[ue.id], this);
      },
      /**
       * recognizer can only run when an other is failing
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      requireFailure: function(ue) {
        if (I(ue, "requireFailure", this))
          return this;
        var ge = this.requireFail;
        return ue = xi(ue, this), ae(ge, ue) === -1 && (ge.push(ue), ue.requireFailure(this)), this;
      },
      /**
       * drop the requireFailure link. it does not remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRequireFailure: function(ue) {
        if (I(ue, "dropRequireFailure", this))
          return this;
        ue = xi(ue, this);
        var ge = ae(this.requireFail, ue);
        return ge > -1 && this.requireFail.splice(ge, 1), this;
      },
      /**
       * has require failures boolean
       * @returns {boolean}
       */
      hasRequireFailures: function() {
        return this.requireFail.length > 0;
      },
      /**
       * if the recognizer can recognize simultaneous with an other recognizer
       * @param {Recognizer} otherRecognizer
       * @returns {Boolean}
       */
      canRecognizeWith: function(ue) {
        return !!this.simultaneous[ue.id];
      },
      /**
       * You should use `tryEmit` instead of `emit` directly to check
       * that all the needed recognizers has failed before emitting.
       * @param {Object} input
       */
      emit: function(ue) {
        var ge = this, Re = this.state;
        function it(St) {
          ge.manager.emit(St, ue);
        }
        Re < Ri && it(ge.options.event + zo(Re)), it(ge.options.event), ue.additionalEvent && it(ue.additionalEvent), Re >= Ri && it(ge.options.event + zo(Re));
      },
      /**
       * Check that all the require failure recognizers has failed,
       * if true, it emits a gesture event,
       * otherwise, setup the state to FAILED.
       * @param {Object} input
       */
      tryEmit: function(ue) {
        if (this.canEmit())
          return this.emit(ue);
        this.state = Ii;
      },
      /**
       * can we emit?
       * @returns {boolean}
       */
      canEmit: function() {
        for (var ue = 0; ue < this.requireFail.length; ) {
          if (!(this.requireFail[ue].state & (Ii | Xn)))
            return !1;
          ue++;
        }
        return !0;
      },
      /**
       * update the recognizer
       * @param {Object} inputData
       */
      recognize: function(ue) {
        var ge = z({}, ue);
        if (!me(this.options.enable, [this, ge])) {
          this.reset(), this.state = Ii;
          return;
        }
        this.state & (Oi | Ys | Ii) && (this.state = Xn), this.state = this.process(ge), this.state & (br | Hr | Ri | Ys) && this.tryEmit(ge);
      },
      /**
       * return the state of the recognizer
       * the actual recognizing happens in this method
       * @virtual
       * @param {Object} inputData
       * @returns {Const} STATE
       */
      process: function(ue) {
      },
      // jshint ignore:line
      /**
       * return the preferred touch-action
       * @virtual
       * @returns {Array}
       */
      getTouchAction: function() {
      },
      /**
       * called when the gesture isn't allowed to recognize
       * like when another is being recognized or it is disabled
       * @virtual
       */
      reset: function() {
      }
    };
    function zo(ue) {
      return ue & Ys ? "cancel" : ue & Ri ? "end" : ue & Hr ? "move" : ue & br ? "start" : "";
    }
    function _s(ue) {
      return ue == ut ? "down" : ue == on ? "up" : ue == Rt ? "left" : ue == kt ? "right" : "";
    }
    function xi(ue, ge) {
      var Re = ge.manager;
      return Re ? Re.get(ue) : ue;
    }
    function Nn() {
      fi.apply(this, arguments);
    }
    J(Nn, fi, {
      /**
       * @namespace
       * @memberof AttrRecognizer
       */
      defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
      },
      /**
       * Used to check if it the recognizer receives valid input, like input.distance > 10.
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {Boolean} recognized
       */
      attrTest: function(ue) {
        var ge = this.options.pointers;
        return ge === 0 || ue.pointers.length === ge;
      },
      /**
       * Process the input and return the state for the recognizer
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {*} State
       */
      process: function(ue) {
        var ge = this.state, Re = ue.eventType, it = ge & (br | Hr), St = this.attrTest(ue);
        return it && (Re & At || !St) ? ge | Ys : it || St ? Re & Ze ? ge | Ri : ge & br ? ge | Hr : br : Ii;
      }
    });
    function Wr() {
      Nn.apply(this, arguments), this.pX = null, this.pY = null;
    }
    J(Wr, Nn, {
      /**
       * @namespace
       * @memberof PanRecognizer
       */
      defaults: {
        event: "pan",
        threshold: 10,
        pointers: 1,
        direction: Qt
      },
      getTouchAction: function() {
        var ue = this.options.direction, ge = [];
        return ue & re && ge.push(Jn), ue & mn && ge.push(Dn), ge;
      },
      directionTest: function(ue) {
        var ge = this.options, Re = !0, it = ue.distance, St = ue.direction, Wt = ue.deltaX, Pn = ue.deltaY;
        return St & ge.direction || (ge.direction & re ? (St = Wt === 0 ? It : Wt < 0 ? Rt : kt, Re = Wt != this.pX, it = Math.abs(ue.deltaX)) : (St = Pn === 0 ? It : Pn < 0 ? on : ut, Re = Pn != this.pY, it = Math.abs(ue.deltaY))), ue.direction = St, Re && it > ge.threshold && St & ge.direction;
      },
      attrTest: function(ue) {
        return Nn.prototype.attrTest.call(this, ue) && (this.state & br || !(this.state & br) && this.directionTest(ue));
      },
      emit: function(ue) {
        this.pX = ue.deltaX, this.pY = ue.deltaY;
        var ge = _s(ue.direction);
        ge && (ue.additionalEvent = this.options.event + ge), this._super.emit.call(this, ue);
      }
    });
    function _i() {
      Nn.apply(this, arguments);
    }
    J(_i, Nn, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
        event: "pinch",
        threshold: 0,
        pointers: 2
      },
      getTouchAction: function() {
        return [dn];
      },
      attrTest: function(ue) {
        return this._super.attrTest.call(this, ue) && (Math.abs(ue.scale - 1) > this.options.threshold || this.state & br);
      },
      emit: function(ue) {
        if (ue.scale !== 1) {
          var ge = ue.scale < 1 ? "in" : "out";
          ue.additionalEvent = this.options.event + ge;
        }
        this._super.emit.call(this, ue);
      }
    });
    function Ks() {
      fi.apply(this, arguments), this._timer = null, this._input = null;
    }
    J(Ks, fi, {
      /**
       * @namespace
       * @memberof PressRecognizer
       */
      defaults: {
        event: "press",
        pointers: 1,
        time: 251,
        // minimal time of the pointer to be pressed
        threshold: 9
        // a minimal movement is ok, but keep it low
      },
      getTouchAction: function() {
        return [Yn];
      },
      process: function(ue) {
        var ge = this.options, Re = ue.pointers.length === ge.pointers, it = ue.distance < ge.threshold, St = ue.deltaTime > ge.time;
        if (this._input = ue, !it || !Re || ue.eventType & (Ze | At) && !St)
          this.reset();
        else if (ue.eventType & We)
          this.reset(), this._timer = T(function() {
            this.state = Oi, this.tryEmit();
          }, ge.time, this);
        else if (ue.eventType & Ze)
          return Oi;
        return Ii;
      },
      reset: function() {
        clearTimeout(this._timer);
      },
      emit: function(ue) {
        this.state === Oi && (ue && ue.eventType & Ze ? this.manager.emit(this.options.event + "up", ue) : (this._input.timeStamp = A(), this.manager.emit(this.options.event, this._input)));
      }
    });
    function hr() {
      Nn.apply(this, arguments);
    }
    J(hr, Nn, {
      /**
       * @namespace
       * @memberof RotateRecognizer
       */
      defaults: {
        event: "rotate",
        threshold: 0,
        pointers: 2
      },
      getTouchAction: function() {
        return [dn];
      },
      attrTest: function(ue) {
        return this._super.attrTest.call(this, ue) && (Math.abs(ue.rotation) > this.options.threshold || this.state & br);
      }
    });
    function Qs() {
      Nn.apply(this, arguments);
    }
    J(Qs, Nn, {
      /**
       * @namespace
       * @memberof SwipeRecognizer
       */
      defaults: {
        event: "swipe",
        threshold: 10,
        velocity: 0.3,
        direction: re | mn,
        pointers: 1
      },
      getTouchAction: function() {
        return Wr.prototype.getTouchAction.call(this);
      },
      attrTest: function(ue) {
        var ge = this.options.direction, Re;
        return ge & (re | mn) ? Re = ue.overallVelocity : ge & re ? Re = ue.overallVelocityX : ge & mn && (Re = ue.overallVelocityY), this._super.attrTest.call(this, ue) && ge & ue.offsetDirection && ue.distance > this.options.threshold && ue.maxPointers == this.options.pointers && y(Re) > this.options.velocity && ue.eventType & Ze;
      },
      emit: function(ue) {
        var ge = _s(ue.offsetDirection);
        ge && this.manager.emit(this.options.event + ge, ue), this.manager.emit(this.options.event, ue);
      }
    });
    function Ji() {
      fi.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0;
    }
    J(Ji, fi, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
        event: "tap",
        pointers: 1,
        taps: 1,
        interval: 300,
        // max time between the multi-tap taps
        time: 250,
        // max time of the pointer to be down (like finger on the screen)
        threshold: 9,
        // a minimal movement is ok, but keep it low
        posThreshold: 10
        // a multi-tap can be a bit off the initial position
      },
      getTouchAction: function() {
        return [Kn];
      },
      process: function(ue) {
        var ge = this.options, Re = ue.pointers.length === ge.pointers, it = ue.distance < ge.threshold, St = ue.deltaTime < ge.time;
        if (this.reset(), ue.eventType & We && this.count === 0)
          return this.failTimeout();
        if (it && St && Re) {
          if (ue.eventType != Ze)
            return this.failTimeout();
          var Wt = this.pTime ? ue.timeStamp - this.pTime < ge.interval : !0, Pn = !this.pCenter || Bt(this.pCenter, ue.center) < ge.posThreshold;
          this.pTime = ue.timeStamp, this.pCenter = ue.center, !Pn || !Wt ? this.count = 1 : this.count += 1, this._input = ue;
          var Fi = this.count % ge.taps;
          if (Fi === 0)
            return this.hasRequireFailures() ? (this._timer = T(function() {
              this.state = Oi, this.tryEmit();
            }, ge.interval, this), br) : Oi;
        }
        return Ii;
      },
      failTimeout: function() {
        return this._timer = T(function() {
          this.state = Ii;
        }, this.options.interval, this), Ii;
      },
      reset: function() {
        clearTimeout(this._timer);
      },
      emit: function() {
        this.state == Oi && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input));
      }
    });
    function Pr(ue, ge) {
      return ge = ge || {}, ge.recognizers = Se(ge.recognizers, Pr.defaults.preset), new jn(ue, ge);
    }
    Pr.VERSION = "2.0.7", Pr.defaults = {
      /**
       * set if DOM events are being triggered.
       * But this is slower and unused by simple implementations, so disabled by default.
       * @type {Boolean}
       * @default false
       */
      domEvents: !1,
      /**
       * The value for the touchAction property/fallback.
       * When set to `compute` it will magically set the correct value based on the added recognizers.
       * @type {String}
       * @default compute
       */
      touchAction: Fn,
      /**
       * @type {Boolean}
       * @default true
       */
      enable: !0,
      /**
       * EXPERIMENTAL FEATURE -- can be removed/changed
       * Change the parent input target element.
       * If Null, then it is being set the to main element.
       * @type {Null|EventTarget}
       * @default null
       */
      inputTarget: null,
      /**
       * force an input class
       * @type {Null|Function}
       * @default null
       */
      inputClass: null,
      /**
       * Default recognizer setup when calling `Hammer()`
       * When creating a new Manager these will be skipped.
       * @type {Array}
       */
      preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [hr, {
          enable: !1
        }],
        [_i, {
          enable: !1
        }, ["rotate"]],
        [Qs, {
          direction: re
        }],
        [Wr, {
          direction: re
        }, ["swipe"]],
        [Ji],
        [Ji, {
          event: "doubletap",
          taps: 2
        }, ["tap"]],
        [Ks]
      ],
      /**
       * Some CSS properties can be used to improve the working of Hammer.
       * Add them to this method and they will be set when creating a new Manager.
       * @namespace
       */
      cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: "none",
        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: "none",
        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: "none",
        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: "none",
        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: "none",
        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: "rgba(0,0,0,0)"
      }
    };
    var dr = 1, Xr = 2;
    function jn(ue, ge) {
      this.options = z({}, Pr.defaults, ge || {}), this.options.inputTarget = this.options.inputTarget || ue, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = ue, this.input = Ft(this), this.touchAction = new Bi(this, this.options.touchAction), Uo(this, !0), L(this.options.recognizers, function(Re) {
        var it = this.add(new Re[0](Re[1]));
        Re[2] && it.recognizeWith(Re[2]), Re[3] && it.requireFailure(Re[3]);
      }, this);
    }
    jn.prototype = {
      /**
       * set options
       * @param {Object} options
       * @returns {Manager}
       */
      set: function(ue) {
        return z(this.options, ue), ue.touchAction && this.touchAction.update(), ue.inputTarget && (this.input.destroy(), this.input.target = ue.inputTarget, this.input.init()), this;
      },
      /**
       * stop recognizing for this session.
       * This session will be discarded, when a new [input]start event is fired.
       * When forced, the recognizer cycle is stopped immediately.
       * @param {Boolean} [force]
       */
      stop: function(ue) {
        this.session.stopped = ue ? Xr : dr;
      },
      /**
       * run the recognizers!
       * called by the inputHandler function on every movement of the pointers (touches)
       * it walks through all the recognizers and tries to detect the gesture that is being made
       * @param {Object} inputData
       */
      recognize: function(ue) {
        var ge = this.session;
        if (!ge.stopped) {
          this.touchAction.preventDefaults(ue);
          var Re, it = this.recognizers, St = ge.curRecognizer;
          (!St || St && St.state & Oi) && (St = ge.curRecognizer = null);
          for (var Wt = 0; Wt < it.length; )
            Re = it[Wt], ge.stopped !== Xr && // 1
            (!St || Re == St || // 2
            Re.canRecognizeWith(St)) ? Re.recognize(ue) : Re.reset(), !St && Re.state & (br | Hr | Ri) && (St = ge.curRecognizer = Re), Wt++;
        }
      },
      /**
       * get a recognizer by its event name.
       * @param {Recognizer|String} recognizer
       * @returns {Recognizer|Null}
       */
      get: function(ue) {
        if (ue instanceof fi)
          return ue;
        for (var ge = this.recognizers, Re = 0; Re < ge.length; Re++)
          if (ge[Re].options.event == ue)
            return ge[Re];
        return null;
      },
      /**
       * add a recognizer to the manager
       * existing recognizers with the same event name will be removed
       * @param {Recognizer} recognizer
       * @returns {Recognizer|Manager}
       */
      add: function(ue) {
        if (I(ue, "add", this))
          return this;
        var ge = this.get(ue.options.event);
        return ge && this.remove(ge), this.recognizers.push(ue), ue.manager = this, this.touchAction.update(), ue;
      },
      /**
       * remove a recognizer by name or instance
       * @param {Recognizer|String} recognizer
       * @returns {Manager}
       */
      remove: function(ue) {
        if (I(ue, "remove", this))
          return this;
        if (ue = this.get(ue), ue) {
          var ge = this.recognizers, Re = ae(ge, ue);
          Re !== -1 && (ge.splice(Re, 1), this.touchAction.update());
        }
        return this;
      },
      /**
       * bind event
       * @param {String} events
       * @param {Function} handler
       * @returns {EventEmitter} this
       */
      on: function(ue, ge) {
        if (ue !== r && ge !== r) {
          var Re = this.handlers;
          return L(Fe(ue), function(it) {
            Re[it] = Re[it] || [], Re[it].push(ge);
          }), this;
        }
      },
      /**
       * unbind event, leave emit blank to remove all handlers
       * @param {String} events
       * @param {Function} [handler]
       * @returns {EventEmitter} this
       */
      off: function(ue, ge) {
        if (ue !== r) {
          var Re = this.handlers;
          return L(Fe(ue), function(it) {
            ge ? Re[it] && Re[it].splice(ae(Re[it], ge), 1) : delete Re[it];
          }), this;
        }
      },
      /**
       * emit event to the listeners
       * @param {String} event
       * @param {Object} data
       */
      emit: function(ue, ge) {
        this.options.domEvents && ma(ue, ge);
        var Re = this.handlers[ue] && this.handlers[ue].slice();
        if (!(!Re || !Re.length)) {
          ge.type = ue, ge.preventDefault = function() {
            ge.srcEvent.preventDefault();
          };
          for (var it = 0; it < Re.length; )
            Re[it](ge), it++;
        }
      },
      /**
       * destroy the manager and unbinds all events
       * it doesn't unbind dom events, that is the user own responsibility
       */
      destroy: function() {
        this.element && Uo(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;
      }
    };
    function Uo(ue, ge) {
      var Re = ue.element;
      if (Re.style) {
        var it;
        L(ue.options.cssProps, function(St, Wt) {
          it = be(Re.style, Wt), ge ? (ue.oldCssProps[it] = Re.style[it], Re.style[it] = St) : Re.style[it] = ue.oldCssProps[it] || "";
        }), ge || (ue.oldCssProps = {});
      }
    }
    function ma(ue, ge) {
      var Re = t.createEvent("Event");
      Re.initEvent(ue, !0, !0), Re.gesture = ge, ge.target.dispatchEvent(Re);
    }
    z(Pr, {
      INPUT_START: We,
      INPUT_MOVE: Ke,
      INPUT_END: Ze,
      INPUT_CANCEL: At,
      STATE_POSSIBLE: Xn,
      STATE_BEGAN: br,
      STATE_CHANGED: Hr,
      STATE_ENDED: Ri,
      STATE_RECOGNIZED: Oi,
      STATE_CANCELLED: Ys,
      STATE_FAILED: Ii,
      DIRECTION_NONE: It,
      DIRECTION_LEFT: Rt,
      DIRECTION_RIGHT: kt,
      DIRECTION_UP: on,
      DIRECTION_DOWN: ut,
      DIRECTION_HORIZONTAL: re,
      DIRECTION_VERTICAL: mn,
      DIRECTION_ALL: Qt,
      Manager: jn,
      Input: Lt,
      TouchAction: Bi,
      TouchInput: Ie,
      MouseInput: Nt,
      PointerEventInput: ve,
      TouchMouseInput: xt,
      SingleTouchInput: _e,
      Recognizer: fi,
      AttrRecognizer: Nn,
      Tap: Ji,
      Pan: Wr,
      Swipe: Qs,
      Pinch: _i,
      Rotate: hr,
      Press: Ks,
      on: De,
      off: Le,
      each: L,
      merge: H,
      extend: V,
      assign: z,
      inherit: J,
      bindFn: ce,
      prefixed: be
    });
    var jo = typeof e < "u" ? e : typeof self < "u" ? self : {};
    jo.Hammer = Pr, n.exports ? n.exports = Pr : e[i] = Pr;
  })(window, document, "Hammer");
})(ZE);
var kp = ZE.exports;
const ZD = /* @__PURE__ */ Ap(kp), rc = /* @__PURE__ */ YC({
  __proto__: null,
  default: ZD
}, [kp]), YE = 1, KE = 2, wy = 4, YD = {
  mousedown: YE,
  mousemove: KE,
  mouseup: wy
};
function KD(n, e) {
  for (let t = 0; t < n.length; t++)
    if (e(n[t]))
      return !0;
  return !1;
}
function QD(n) {
  const e = n.prototype.handler;
  n.prototype.handler = function(i) {
    const r = this.store;
    i.button > 0 && i.type === "pointerdown" && (KD(r, (s) => s.pointerId === i.pointerId) || r.push(i)), e.call(this, i);
  };
}
function ek(n) {
  n.prototype.handler = function(t) {
    let i = YD[t.type];
    i & YE && t.button >= 0 && (this.pressed = !0), i & KE && t.which === 0 && (i = wy), this.pressed && (i & wy && (this.pressed = !1), this.callback(this.manager, i, {
      pointers: [t],
      changedPointers: [t],
      pointerType: "mouse",
      srcEvent: t
    }));
  };
}
QD(kp.PointerEventInput);
ek(kp.MouseInput);
const tk = kp.Manager;
class Dm {
  constructor(e, t, i) {
    this.element = e, this.callback = t, this.options = {
      enable: !0,
      ...i
    };
  }
}
const nk = rc ? [
  [rc.Pan, {
    event: "tripan",
    pointers: 3,
    threshold: 0,
    enable: !1
  }],
  [rc.Rotate, {
    enable: !1
  }],
  [rc.Pinch, {
    enable: !1
  }],
  [rc.Swipe, {
    enable: !1
  }],
  [rc.Pan, {
    threshold: 0,
    enable: !1
  }],
  [rc.Press, {
    enable: !1
  }],
  [rc.Tap, {
    event: "doubletap",
    taps: 2,
    enable: !1
  }],
  // TODO - rename to 'tap' and 'singletap' in the next major release
  [rc.Tap, {
    event: "anytap",
    enable: !1
  }],
  [rc.Tap, {
    enable: !1
  }]
] : null, Hx = {
  tripan: ["rotate", "pinch", "pan"],
  rotate: ["pinch"],
  pinch: ["pan"],
  pan: ["press", "doubletap", "anytap", "tap"],
  doubletap: ["anytap"],
  anytap: ["tap"]
}, ik = {
  doubletap: ["tap"]
}, rk = {
  pointerdown: "pointerdown",
  pointermove: "pointermove",
  pointerup: "pointerup",
  touchstart: "pointerdown",
  touchmove: "pointermove",
  touchend: "pointerup",
  mousedown: "pointerdown",
  mousemove: "pointermove",
  mouseup: "pointerup"
}, Y1 = {
  KEY_EVENTS: ["keydown", "keyup"],
  MOUSE_EVENTS: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout", "mouseleave"],
  WHEEL_EVENTS: [
    // Chrome, Safari
    "wheel",
    // IE
    "mousewheel"
  ]
}, sk = {
  tap: "tap",
  anytap: "anytap",
  doubletap: "doubletap",
  press: "press",
  pinch: "pinch",
  pinchin: "pinch",
  pinchout: "pinch",
  pinchstart: "pinch",
  pinchmove: "pinch",
  pinchend: "pinch",
  pinchcancel: "pinch",
  rotate: "rotate",
  rotatestart: "rotate",
  rotatemove: "rotate",
  rotateend: "rotate",
  rotatecancel: "rotate",
  tripan: "tripan",
  tripanstart: "tripan",
  tripanmove: "tripan",
  tripanup: "tripan",
  tripandown: "tripan",
  tripanleft: "tripan",
  tripanright: "tripan",
  tripanend: "tripan",
  tripancancel: "tripan",
  pan: "pan",
  panstart: "pan",
  panmove: "pan",
  panup: "pan",
  pandown: "pan",
  panleft: "pan",
  panright: "pan",
  panend: "pan",
  pancancel: "pan",
  swipe: "swipe",
  swipeleft: "swipe",
  swiperight: "swipe",
  swipeup: "swipe",
  swipedown: "swipe"
}, Wx = {
  click: "tap",
  anyclick: "anytap",
  dblclick: "doubletap",
  mousedown: "pointerdown",
  mousemove: "pointermove",
  mouseup: "pointerup",
  mouseover: "pointerover",
  mouseout: "pointerout",
  mouseleave: "pointerleave"
}, ok = typeof navigator < "u" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "", Td = typeof window < "u" ? window : global;
let Ay = !1;
try {
  const n = {
    // This function will be called when the browser
    // attempts to access the passive property.
    get passive() {
      return Ay = !0, !0;
    }
  };
  Td.addEventListener("test", null, n), Td.removeEventListener("test", null);
} catch {
  Ay = !1;
}
const ak = ok.indexOf("firefox") !== -1, {
  WHEEL_EVENTS: lk
} = Y1, Xx = "wheel", Jx = 4.000244140625, ck = 40, uk = 0.25;
class hk extends Dm {
  constructor(e, t, i) {
    super(e, t, i), this.handleEvent = (r) => {
      if (!this.options.enable)
        return;
      let s = r.deltaY;
      Td.WheelEvent && (ak && r.deltaMode === Td.WheelEvent.DOM_DELTA_PIXEL && (s /= Td.devicePixelRatio), r.deltaMode === Td.WheelEvent.DOM_DELTA_LINE && (s *= ck)), s !== 0 && s % Jx === 0 && (s = Math.floor(s / Jx)), r.shiftKey && s && (s = s * uk), this.callback({
        type: Xx,
        center: {
          x: r.clientX,
          y: r.clientY
        },
        delta: -s,
        srcEvent: r,
        pointerType: "mouse",
        target: r.target
      });
    }, this.events = (this.options.events || []).concat(lk), this.events.forEach((r) => e.addEventListener(r, this.handleEvent, Ay ? {
      passive: !1
    } : !1));
  }
  destroy() {
    this.events.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    e === Xx && (this.options.enable = t);
  }
}
const {
  MOUSE_EVENTS: dk
} = Y1, $x = "pointermove", Zx = "pointerover", Yx = "pointerout", Kx = "pointerenter", Qx = "pointerleave";
class fk extends Dm {
  constructor(e, t, i) {
    super(e, t, i), this.handleEvent = (s) => {
      this.handleOverEvent(s), this.handleOutEvent(s), this.handleEnterEvent(s), this.handleLeaveEvent(s), this.handleMoveEvent(s);
    }, this.pressed = !1;
    const {
      enable: r
    } = this.options;
    this.enableMoveEvent = r, this.enableLeaveEvent = r, this.enableEnterEvent = r, this.enableOutEvent = r, this.enableOverEvent = r, this.events = (this.options.events || []).concat(dk), this.events.forEach((s) => e.addEventListener(s, this.handleEvent));
  }
  destroy() {
    this.events.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    e === $x && (this.enableMoveEvent = t), e === Zx && (this.enableOverEvent = t), e === Yx && (this.enableOutEvent = t), e === Kx && (this.enableEnterEvent = t), e === Qx && (this.enableLeaveEvent = t);
  }
  handleOverEvent(e) {
    this.enableOverEvent && e.type === "mouseover" && this._emit(Zx, e);
  }
  handleOutEvent(e) {
    this.enableOutEvent && e.type === "mouseout" && this._emit(Yx, e);
  }
  handleEnterEvent(e) {
    this.enableEnterEvent && e.type === "mouseenter" && this._emit(Kx, e);
  }
  handleLeaveEvent(e) {
    this.enableLeaveEvent && e.type === "mouseleave" && this._emit(Qx, e);
  }
  handleMoveEvent(e) {
    if (this.enableMoveEvent)
      switch (e.type) {
        case "mousedown":
          e.button >= 0 && (this.pressed = !0);
          break;
        case "mousemove":
          e.which === 0 && (this.pressed = !1), this.pressed || this._emit($x, e);
          break;
        case "mouseup":
          this.pressed = !1;
          break;
      }
  }
  _emit(e, t) {
    this.callback({
      type: e,
      center: {
        x: t.clientX,
        y: t.clientY
      },
      srcEvent: t,
      pointerType: "mouse",
      target: t.target
    });
  }
}
const {
  KEY_EVENTS: pk
} = Y1, ew = "keydown", tw = "keyup";
class gk extends Dm {
  constructor(e, t, i) {
    super(e, t, i), this.handleEvent = (r) => {
      const s = r.target || r.srcElement;
      s.tagName === "INPUT" && s.type === "text" || s.tagName === "TEXTAREA" || (this.enableDownEvent && r.type === "keydown" && this.callback({
        type: ew,
        srcEvent: r,
        key: r.key,
        target: r.target
      }), this.enableUpEvent && r.type === "keyup" && this.callback({
        type: tw,
        srcEvent: r,
        key: r.key,
        target: r.target
      }));
    }, this.enableDownEvent = this.options.enable, this.enableUpEvent = this.options.enable, this.events = (this.options.events || []).concat(pk), e.tabIndex = this.options.tabIndex || 0, e.style.outline = "none", this.events.forEach((r) => e.addEventListener(r, this.handleEvent));
  }
  destroy() {
    this.events.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    e === ew && (this.enableDownEvent = t), e === tw && (this.enableUpEvent = t);
  }
}
const nw = "contextmenu";
class mk extends Dm {
  constructor(e, t, i) {
    super(e, t, i), this.handleEvent = (r) => {
      this.options.enable && this.callback({
        type: nw,
        center: {
          x: r.clientX,
          y: r.clientY
        },
        srcEvent: r,
        pointerType: "mouse",
        target: r.target
      });
    }, e.addEventListener("contextmenu", this.handleEvent);
  }
  destroy() {
    this.element.removeEventListener("contextmenu", this.handleEvent);
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    e === nw && (this.options.enable = t);
  }
}
const Ey = 1, xm = 2, Sy = 4, _k = {
  pointerdown: Ey,
  pointermove: xm,
  pointerup: Sy,
  mousedown: Ey,
  mousemove: xm,
  mouseup: Sy
}, yk = 1, vk = 2, bk = 3, xk = 0, wk = 1, Ak = 2, Ek = 1, Sk = 2, Tk = 4;
function Ck(n) {
  const e = _k[n.srcEvent.type];
  if (!e)
    return null;
  const {
    buttons: t,
    button: i,
    which: r
  } = n.srcEvent;
  let s = !1, c = !1, l = !1;
  return /* button is up, need to find out which one was pressed before */ e === Sy || // moving but does not support `buttons` API
  e === xm && !Number.isFinite(t) ? (s = r === yk, c = r === vk, l = r === bk) : e === xm ? (s = !!(t & Ek), c = !!(t & Tk), l = !!(t & Sk)) : e === Ey && (s = i === xk, c = i === wk, l = i === Ak), {
    leftButton: s,
    middleButton: c,
    rightButton: l
  };
}
function Ik(n, e) {
  const t = n.center;
  if (!t)
    return null;
  const i = e.getBoundingClientRect(), r = i.width / e.offsetWidth || 1, s = i.height / e.offsetHeight || 1, c = {
    x: (t.x - i.left - e.clientLeft) / r,
    y: (t.y - i.top - e.clientTop) / s
  };
  return {
    center: t,
    offsetCenter: c
  };
}
const h_ = {
  srcElement: "root",
  priority: 0
};
class Pk {
  constructor(e) {
    this.handleEvent = (t) => {
      if (this.isEmpty())
        return;
      const i = this._normalizeEvent(t);
      let r = t.srcEvent.target;
      for (; r && r !== i.rootElement; ) {
        if (this._emit(i, r), i.handled)
          return;
        r = r.parentNode;
      }
      this._emit(i, "root");
    }, this.eventManager = e, this.handlers = [], this.handlersByElement = /* @__PURE__ */ new Map(), this._active = !1;
  }
  // Returns true if there are no non-passive handlers
  isEmpty() {
    return !this._active;
  }
  add(e, t, i) {
    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
    const {
      handlers: c,
      handlersByElement: l
    } = this;
    let m = h_;
    typeof i == "string" || i && i.addEventListener ? m = {
      ...h_,
      srcElement: i
    } : i && (m = {
      ...h_,
      ...i
    });
    let y = l.get(m.srcElement);
    y || (y = [], l.set(m.srcElement, y));
    const A = {
      type: e,
      handler: t,
      srcElement: m.srcElement,
      priority: m.priority
    };
    r && (A.once = !0), s && (A.passive = !0), c.push(A), this._active = this._active || !A.passive;
    let T = y.length - 1;
    for (; T >= 0 && !(y[T].priority >= A.priority); )
      T--;
    y.splice(T + 1, 0, A);
  }
  remove(e, t) {
    const {
      handlers: i,
      handlersByElement: r
    } = this;
    for (let s = i.length - 1; s >= 0; s--) {
      const c = i[s];
      if (c.type === e && c.handler === t) {
        i.splice(s, 1);
        const l = r.get(c.srcElement);
        l.splice(l.indexOf(c), 1), l.length === 0 && r.delete(c.srcElement);
      }
    }
    this._active = i.some((s) => !s.passive);
  }
  /**
   * Invoke handlers on a particular element
   */
  _emit(e, t) {
    const i = this.handlersByElement.get(t);
    if (i) {
      let r = !1;
      const s = () => {
        e.handled = !0;
      }, c = () => {
        e.handled = !0, r = !0;
      }, l = [];
      for (let m = 0; m < i.length; m++) {
        const {
          type: y,
          handler: A,
          once: T
        } = i[m];
        if (A({
          ...e,
          // @ts-ignore
          type: y,
          stopPropagation: s,
          stopImmediatePropagation: c
        }), T && l.push(i[m]), r)
          break;
      }
      for (let m = 0; m < l.length; m++) {
        const {
          type: y,
          handler: A
        } = l[m];
        this.remove(y, A);
      }
    }
  }
  /**
   * Normalizes hammerjs and custom events to have predictable fields.
   */
  _normalizeEvent(e) {
    const t = this.eventManager.getElement();
    return {
      ...e,
      ...Ck(e),
      ...Ik(e, t),
      preventDefault: () => {
        e.srcEvent.preventDefault();
      },
      stopImmediatePropagation: null,
      stopPropagation: null,
      handled: !1,
      rootElement: t
    };
  }
}
const Lk = {
  // event handlers
  events: null,
  // custom recognizers
  recognizers: null,
  recognizerOptions: {},
  // Manager class
  Manager: tk,
  // allow browser default touch action
  // https://github.com/uber/react-map-gl/issues/506
  touchAction: "none",
  tabIndex: 0
};
class Mk {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 ? arguments[1] : void 0;
    this._onBasicInput = (r) => {
      const {
        srcEvent: s
      } = r, c = rk[s.type];
      c && this.manager.emit(c, r);
    }, this._onOtherEvent = (r) => {
      this.manager.emit(r.type, r);
    }, this.options = {
      ...Lk,
      ...t
    }, this.events = /* @__PURE__ */ new Map(), this.setElement(e);
    const {
      events: i
    } = this.options;
    i && this.on(i);
  }
  getElement() {
    return this.element;
  }
  setElement(e) {
    if (this.element && this.destroy(), this.element = e, !e)
      return;
    const {
      options: t
    } = this, i = t.Manager;
    this.manager = new i(e, {
      touchAction: t.touchAction,
      recognizers: t.recognizers || nk
    }).on("hammer.input", this._onBasicInput), t.recognizers || Object.keys(Hx).forEach((r) => {
      const s = this.manager.get(r);
      s && Hx[r].forEach((c) => {
        s.recognizeWith(c);
      });
    });
    for (const r in t.recognizerOptions) {
      const s = this.manager.get(r);
      if (s) {
        const c = t.recognizerOptions[r];
        delete c.enable, s.set(c);
      }
    }
    this.wheelInput = new hk(e, this._onOtherEvent, {
      enable: !1
    }), this.moveInput = new fk(e, this._onOtherEvent, {
      enable: !1
    }), this.keyInput = new gk(e, this._onOtherEvent, {
      enable: !1,
      tabIndex: t.tabIndex
    }), this.contextmenuInput = new mk(e, this._onOtherEvent, {
      enable: !1
    });
    for (const [r, s] of this.events)
      s.isEmpty() || (this._toggleRecognizer(s.recognizerName, !0), this.manager.on(r, s.handleEvent));
  }
  // Tear down internal event management implementations.
  destroy() {
    this.element && (this.wheelInput.destroy(), this.moveInput.destroy(), this.keyInput.destroy(), this.contextmenuInput.destroy(), this.manager.destroy(), this.wheelInput = null, this.moveInput = null, this.keyInput = null, this.contextmenuInput = null, this.manager = null, this.element = null);
  }
  /** Register an event handler function to be called on `event` */
  on(e, t, i) {
    this._addEventHandler(e, t, i, !1);
  }
  once(e, t, i) {
    this._addEventHandler(e, t, i, !0);
  }
  watch(e, t, i) {
    this._addEventHandler(e, t, i, !1, !0);
  }
  off(e, t) {
    this._removeEventHandler(e, t);
  }
  /*
   * Enable/disable recognizer for the given event
   */
  _toggleRecognizer(e, t) {
    const {
      manager: i
    } = this;
    if (!i)
      return;
    const r = i.get(e);
    if (r && r.options.enable !== t) {
      r.set({
        enable: t
      });
      const s = ik[e];
      s && !this.options.recognizers && s.forEach((c) => {
        const l = i.get(c);
        t ? (l.requireFailure(e), r.dropRequireFailure(c)) : l.dropRequireFailure(e);
      });
    }
    this.wheelInput.enableEventType(e, t), this.moveInput.enableEventType(e, t), this.keyInput.enableEventType(e, t), this.contextmenuInput.enableEventType(e, t);
  }
  /**
   * Process the event registration for a single event + handler.
   */
  _addEventHandler(e, t, i, r, s) {
    if (typeof e != "string") {
      i = t;
      for (const A in e)
        this._addEventHandler(A, e[A], i, r, s);
      return;
    }
    const {
      manager: c,
      events: l
    } = this, m = Wx[e] || e;
    let y = l.get(m);
    y || (y = new Pk(this), l.set(m, y), y.recognizerName = sk[m] || m, c && c.on(m, y.handleEvent)), y.add(e, t, i, r, s), y.isEmpty() || this._toggleRecognizer(y.recognizerName, !0);
  }
  /**
   * Process the event deregistration for a single event + handler.
   */
  _removeEventHandler(e, t) {
    if (typeof e != "string") {
      for (const c in e)
        this._removeEventHandler(c, e[c]);
      return;
    }
    const {
      events: i
    } = this, r = Wx[e] || e, s = i.get(r);
    if (s && (s.remove(e, t), s.isEmpty())) {
      const {
        recognizerName: c
      } = s;
      let l = !1;
      for (const m of i.values())
        if (m.recognizerName === c && !m.isEmpty()) {
          l = !0;
          break;
        }
      l || this._toggleRecognizer(c, !1);
    }
  }
}
function xh() {
}
const Bk = (n) => {
  let {
    isDragging: e
  } = n;
  return e ? "grabbing" : "grab";
}, QE = {
  id: "",
  width: "100%",
  height: "100%",
  style: null,
  viewState: null,
  initialViewState: null,
  pickingRadius: 0,
  layerFilter: null,
  glOptions: {},
  parameters: {},
  parent: null,
  gl: null,
  canvas: null,
  layers: [],
  effects: [],
  views: null,
  controller: null,
  useDevicePixels: !0,
  touchAction: "none",
  eventRecognizerOptions: {},
  _framebuffer: null,
  _animate: !1,
  _pickable: !0,
  _typedArrayManagerProps: {},
  _customRender: null,
  onWebGLInitialized: xh,
  onResize: xh,
  onViewStateChange: xh,
  onInteractionStateChange: xh,
  onBeforeRender: xh,
  onAfterRender: xh,
  onLoad: xh,
  onError: (n) => hi.error(n.message, n.cause)(),
  onHover: null,
  onClick: null,
  onDragStart: null,
  onDrag: null,
  onDragEnd: null,
  _onMetrics: null,
  getCursor: Bk,
  getTooltip: null,
  debug: !1,
  drawPickingColors: !1
};
class K1 {
  constructor(e) {
    G(this, "props", void 0), G(this, "width", 0), G(this, "height", 0), G(this, "userData", {}), G(this, "canvas", null), G(this, "viewManager", null), G(this, "layerManager", null), G(this, "effectManager", null), G(this, "deckRenderer", null), G(this, "deckPicker", null), G(this, "eventManager", null), G(this, "tooltip", null), G(this, "metrics", void 0), G(this, "animationLoop", void 0), G(this, "stats", void 0), G(this, "viewState", void 0), G(this, "cursorState", void 0), G(this, "_needsRedraw", void 0), G(this, "_pickRequest", void 0), G(this, "_lastPointerDownInfo", null), G(this, "_metricsCounter", void 0), G(this, "_onPointerMove", (t) => {
      const {
        _pickRequest: i
      } = this;
      if (t.type === "pointerleave")
        i.x = -1, i.y = -1, i.radius = 0;
      else {
        if (t.leftButton || t.rightButton)
          return;
        {
          const r = t.offsetCenter;
          if (!r)
            return;
          i.x = r.x, i.y = r.y, i.radius = this.props.pickingRadius;
        }
      }
      this.layerManager && (this.layerManager.context.mousePosition = {
        x: i.x,
        y: i.y
      }), i.event = t;
    }), G(this, "_onEvent", (t) => {
      const i = k2[t.type], r = t.offsetCenter;
      if (!i || !r || !this.layerManager)
        return;
      const s = this.layerManager.getLayers(), c = this.deckPicker.getLastPickedObject({
        x: r.x,
        y: r.y,
        layers: s,
        viewports: this.getViewports(r)
      }, this._lastPointerDownInfo), {
        layer: l
      } = c, m = l && (l[i.handler] || l.props[i.handler]), y = this.props[i.handler];
      let A = !1;
      m && (A = m.call(l, c, t)), !A && y && y(c, t);
    }), G(this, "_onPointerDown", (t) => {
      const i = t.offsetCenter, r = this._pick("pickObject", "pickObject Time", {
        x: i.x,
        y: i.y,
        radius: this.props.pickingRadius
      });
      this._lastPointerDownInfo = r.result[0] || r.emptyInfo;
    }), this.props = {
      ...QE,
      ...e
    }, e = this.props, this._needsRedraw = "Initial render", this._pickRequest = {
      mode: "hover",
      x: -1,
      y: -1,
      radius: 0,
      event: null
    }, this.cursorState = {
      isHovering: !1,
      isDragging: !1
    }, e.viewState && e.initialViewState && hi.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")(), S5() === "IE" && hi.warn("IE 11 is not supported")(), this.viewState = e.initialViewState, e.gl || typeof document < "u" && (this.canvas = this._createCanvas(e)), this.animationLoop = this._createAnimationLoop(e), this.stats = new Cp({
      id: "deck.gl"
    }), this.metrics = {
      fps: 0,
      setPropsTime: 0,
      updateAttributesTime: 0,
      framesRedrawn: 0,
      pickTime: 0,
      pickCount: 0,
      gpuTime: 0,
      gpuTimePerFrame: 0,
      cpuTime: 0,
      cpuTimePerFrame: 0,
      bufferMemory: 0,
      textureMemory: 0,
      renderbufferMemory: 0,
      gpuMemory: 0
    }, this._metricsCounter = 0, this.setProps(e), e._typedArrayManagerProps && _p.setOptions(e._typedArrayManagerProps), this.animationLoop.start();
  }
  finalize() {
    var e, t, i, r, s, c, l, m;
    if ((e = this.animationLoop) === null || e === void 0 || e.stop(), this.animationLoop = null, this._lastPointerDownInfo = null, (t = this.layerManager) === null || t === void 0 || t.finalize(), this.layerManager = null, (i = this.viewManager) === null || i === void 0 || i.finalize(), this.viewManager = null, (r = this.effectManager) === null || r === void 0 || r.finalize(), this.effectManager = null, (s = this.deckRenderer) === null || s === void 0 || s.finalize(), this.deckRenderer = null, (c = this.deckPicker) === null || c === void 0 || c.finalize(), this.deckPicker = null, (l = this.eventManager) === null || l === void 0 || l.destroy(), this.eventManager = null, (m = this.tooltip) === null || m === void 0 || m.remove(), this.tooltip = null, !this.props.canvas && !this.props.gl && this.canvas) {
      var y;
      (y = this.canvas.parentElement) === null || y === void 0 || y.removeChild(this.canvas), this.canvas = null;
    }
  }
  setProps(e) {
    this.stats.get("setProps Time").timeStart(), "onLayerHover" in e && hi.removed("onLayerHover", "onHover")(), "onLayerClick" in e && hi.removed("onLayerClick", "onClick")(), e.initialViewState && !hc(this.props.initialViewState, e.initialViewState, 3) && (this.viewState = e.initialViewState), Object.assign(this.props, e), this._setCanvasSize(this.props);
    const t = Object.create(this.props);
    Object.assign(t, {
      views: this._getViews(),
      width: this.width,
      height: this.height,
      viewState: this._getViewState()
    }), this.animationLoop.setProps(t), this.layerManager && (this.viewManager.setProps(t), this.layerManager.activateViewport(this.getViewports()[0]), this.layerManager.setProps(t), this.effectManager.setProps(t), this.deckRenderer.setProps(t), this.deckPicker.setProps(t)), this.stats.get("setProps Time").timeEnd();
  }
  needsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    if (!this.layerManager)
      return !1;
    if (this.props._animate)
      return "Deck._animate";
    let t = this._needsRedraw;
    e.clearRedrawFlags && (this._needsRedraw = !1);
    const i = this.viewManager.needsRedraw(e), r = this.layerManager.needsRedraw(e), s = this.effectManager.needsRedraw(e), c = this.deckRenderer.needsRedraw(e);
    return t = t || i || r || s || c, t;
  }
  redraw(e) {
    if (!this.layerManager)
      return;
    let t = this.needsRedraw({
      clearRedrawFlags: !0
    });
    t = e || t, t && (this.stats.get("Redraw Count").incrementCount(), this.props._customRender ? this.props._customRender(t) : this._drawLayers(t));
  }
  get isInitialized() {
    return this.viewManager !== null;
  }
  getViews() {
    return Is(this.viewManager), this.viewManager.views;
  }
  getViewports(e) {
    return Is(this.viewManager), this.viewManager.getViewports(e);
  }
  getCanvas() {
    return this.canvas;
  }
  pickObject(e) {
    const t = this._pick("pickObject", "pickObject Time", e).result;
    return t.length ? t[0] : null;
  }
  pickMultipleObjects(e) {
    return e.depth = e.depth || 10, this._pick("pickObject", "pickMultipleObjects Time", e).result;
  }
  pickObjects(e) {
    return this._pick("pickObjects", "pickObjects Time", e);
  }
  _addResources(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    for (const i in e)
      this.layerManager.resourceManager.add({
        resourceId: i,
        data: e[i],
        forceUpdate: t
      });
  }
  _removeResources(e) {
    for (const t of e)
      this.layerManager.resourceManager.remove(t);
  }
  _addDefaultEffect(e) {
    this.effectManager.addDefaultEffect(e);
  }
  _pick(e, t, i) {
    Is(this.deckPicker);
    const {
      stats: r
    } = this;
    r.get("Pick Count").incrementCount(), r.get(t).timeStart();
    const s = this.deckPicker[e]({
      layers: this.layerManager.getLayers(i),
      views: this.viewManager.getViews(),
      viewports: this.getViewports(i),
      onViewportActive: this.layerManager.activateViewport,
      effects: this.effectManager.getEffects(),
      ...i
    });
    return r.get(t).timeEnd(), s;
  }
  _createCanvas(e) {
    let t = e.canvas;
    return typeof t == "string" && (t = document.getElementById(t), Is(t)), t || (t = document.createElement("canvas"), t.id = e.id || "deckgl-overlay", (e.parent || document.body).appendChild(t)), Object.assign(t.style, e.style), t;
  }
  _setCanvasSize(e) {
    if (!this.canvas)
      return;
    const {
      width: t,
      height: i
    } = e;
    if (t || t === 0) {
      const s = Number.isFinite(t) ? "".concat(t, "px") : t;
      this.canvas.style.width = s;
    }
    if (i || i === 0) {
      var r;
      const s = Number.isFinite(i) ? "".concat(i, "px") : i;
      this.canvas.style.position = ((r = e.style) === null || r === void 0 ? void 0 : r.position) || "absolute", this.canvas.style.height = s;
    }
  }
  _updateCanvasSize() {
    var e, t;
    const {
      canvas: i
    } = this;
    if (!i)
      return;
    const r = (e = i.clientWidth) !== null && e !== void 0 ? e : i.width, s = (t = i.clientHeight) !== null && t !== void 0 ? t : i.height;
    if (r !== this.width || s !== this.height) {
      var c, l;
      this.width = r, this.height = s, (c = this.viewManager) === null || c === void 0 || c.setProps({
        width: r,
        height: s
      }), (l = this.layerManager) === null || l === void 0 || l.activateViewport(this.getViewports()[0]), this.props.onResize({
        width: r,
        height: s
      });
    }
  }
  _createAnimationLoop(e) {
    const {
      width: t,
      height: i,
      gl: r,
      glOptions: s,
      debug: c,
      onError: l,
      onBeforeRender: m,
      onAfterRender: y,
      useDevicePixels: A
    } = e;
    return new iR({
      width: t,
      height: i,
      useDevicePixels: A,
      autoResizeDrawingBuffer: !r,
      autoResizeViewport: !1,
      gl: r,
      onCreateContext: (T) => q5({
        ...s,
        ...T,
        canvas: this.canvas,
        debug: c,
        onContextLost: () => this._onContextLost()
      }),
      onInitialize: (T) => this._setGLContext(T.gl),
      onRender: this._onRenderFrame.bind(this),
      onBeforeRender: m,
      onAfterRender: y,
      onError: l
    });
  }
  _getViewState() {
    return this.props.viewState || this.viewState;
  }
  _getViews() {
    let e = this.props.views || [new Z1({
      id: "default-view"
    })];
    return e = Array.isArray(e) ? e : [e], e.length && this.props.controller && (e[0].props.controller = this.props.controller), e;
  }
  _onContextLost() {
    const {
      onError: e
    } = this.props;
    this.animationLoop && e && e(new Error("WebGL context is lost"));
  }
  _pickAndCallback() {
    const {
      _pickRequest: e
    } = this;
    if (e.event) {
      const {
        result: i,
        emptyInfo: r
      } = this._pick("pickObject", "pickObject Time", e);
      this.cursorState.isHovering = i.length > 0;
      let s = r, c = !1;
      for (const l of i) {
        var t;
        s = l, c = ((t = l.layer) === null || t === void 0 ? void 0 : t.onHover(l, e.event)) || c;
      }
      if (!c && this.props.onHover && this.props.onHover(s, e.event), this.props.getTooltip && this.tooltip) {
        const l = this.props.getTooltip(s);
        this.tooltip.setTooltip(l, s.x, s.y);
      }
      e.event = null;
    }
  }
  _updateCursor() {
    const e = this.props.parent || this.canvas;
    e && (e.style.cursor = this.props.getCursor(this.cursorState));
  }
  _setGLContext(e) {
    if (this.layerManager)
      return;
    this.canvas || (this.canvas = e.canvas, S1(e, {
      enable: !0,
      copyState: !0
    })), this.tooltip = new $D(this.canvas), eu(e, {
      blend: !0,
      blendFunc: [770, 771, 1, 771],
      polygonOffsetFill: !0,
      depthTest: !0,
      depthFunc: 515
    }), this.props.onWebGLInitialized(e);
    const t = new RE();
    t.play(), this.animationLoop.attachTimeline(t), this.eventManager = new Mk(this.props.parent || e.canvas, {
      touchAction: this.props.touchAction,
      recognizerOptions: this.props.eventRecognizerOptions,
      events: {
        pointerdown: this._onPointerDown,
        pointermove: this._onPointerMove,
        pointerleave: this._onPointerMove
      }
    });
    for (const r in k2)
      this.eventManager.on(r, this._onEvent);
    this.viewManager = new xD({
      timeline: t,
      eventManager: this.eventManager,
      onViewStateChange: this._onViewStateChange.bind(this),
      onInteractionStateChange: this._onInteractionStateChange.bind(this),
      views: this._getViews(),
      viewState: this._getViewState(),
      width: this.width,
      height: this.height
    });
    const i = this.viewManager.getViewports()[0];
    this.layerManager = new bD(e, {
      deck: this,
      stats: this.stats,
      viewport: i,
      timeline: t
    }), this.effectManager = new ND(), this.deckRenderer = new jD(e), this.deckPicker = new XD(e), this.setProps(this.props), this._updateCanvasSize(), this.props.onLoad();
  }
  _drawLayers(e, t) {
    const {
      gl: i
    } = this.layerManager.context;
    eu(i, this.props.parameters), this.props.onBeforeRender({
      gl: i
    }), this.deckRenderer.renderLayers({
      target: this.props._framebuffer,
      layers: this.layerManager.getLayers(),
      viewports: this.viewManager.getViewports(),
      onViewportActive: this.layerManager.activateViewport,
      views: this.viewManager.getViews(),
      pass: "screen",
      effects: this.effectManager.getEffects(),
      ...t
    }), this.props.onAfterRender({
      gl: i
    });
  }
  _onRenderFrame(e) {
    this._getFrameStats(), this._metricsCounter++ % 60 === 0 && (this._getMetrics(), this.stats.reset(), hi.table(4, this.metrics)(), this.props._onMetrics && this.props._onMetrics(this.metrics)), this._updateCanvasSize(), this._updateCursor(), this.tooltip.isVisible && this.viewManager.needsRedraw() && this.tooltip.setTooltip(null), this.layerManager.updateLayers(), this._pickAndCallback(), this.redraw(), this.viewManager && this.viewManager.updateViewStates();
  }
  _onViewStateChange(e) {
    const t = this.props.onViewStateChange(e) || e.viewState;
    this.viewState && (this.viewState = {
      ...this.viewState,
      [e.viewId]: t
    }, this.props.viewState || this.viewManager && this.viewManager.setProps({
      viewState: this.viewState
    }));
  }
  _onInteractionStateChange(e) {
    this.cursorState.isDragging = e.isDragging || !1, this.props.onInteractionStateChange(e);
  }
  _getFrameStats() {
    const {
      stats: e
    } = this;
    e.get("frameRate").timeEnd(), e.get("frameRate").timeStart();
    const t = this.animationLoop.stats;
    e.get("GPU Time").addTime(t.get("GPU Time").lastTiming), e.get("CPU Time").addTime(t.get("CPU Time").lastTiming);
  }
  _getMetrics() {
    const {
      metrics: e,
      stats: t
    } = this;
    e.fps = t.get("frameRate").getHz(), e.setPropsTime = t.get("setProps Time").time, e.updateAttributesTime = t.get("Update Attributes").time, e.framesRedrawn = t.get("Redraw Count").count, e.pickTime = t.get("pickObject Time").time + t.get("pickMultipleObjects Time").time + t.get("pickObjects Time").time, e.pickCount = t.get("Pick Count").count, e.gpuTime = t.get("GPU Time").time, e.cpuTime = t.get("CPU Time").time, e.gpuTimePerFrame = t.get("GPU Time").getAverageTime(), e.cpuTimePerFrame = t.get("CPU Time").getAverageTime();
    const i = Ph.get("Memory Usage");
    e.bufferMemory = i.get("Buffer Memory").count, e.textureMemory = i.get("Texture Memory").count, e.renderbufferMemory = i.get("Renderbuffer Memory").count, e.gpuMemory = i.get("GPU Memory").count;
  }
}
G(K1, "defaultProps", QE);
G(K1, "VERSION", cM);
class d_ {
  constructor(e, t) {
    G(this, "opts", void 0), G(this, "source", void 0), this.opts = t, this.source = e;
  }
  get value() {
    return this.source.value;
  }
  getValue() {
    const e = this.source.getBuffer(), t = this.getAccessor();
    if (e)
      return [e, t];
    const {
      value: i
    } = this.source, {
      size: r
    } = t;
    let s = i;
    if (i && i.length !== r) {
      s = new Float32Array(r);
      const c = t.elementOffset || 0;
      for (let l = 0; l < r; ++l)
        s[l] = i[c + l];
    }
    return s;
  }
  getAccessor() {
    return {
      ...this.source.getAccessor(),
      ...this.opts
    };
  }
}
function Rk(n) {
  switch (n) {
    case 5126:
      return Float32Array;
    case 5130:
      return Float64Array;
    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;
    case 5125:
      return Uint32Array;
    case 5121:
      return Uint8ClampedArray;
    case 5120:
      return Int8Array;
    case 5122:
      return Int16Array;
    case 5124:
      return Int32Array;
    default:
      throw new Error("Unknown GL type");
  }
}
function Xg(n) {
  return n.stride || n.size * n.bytesPerElement;
}
function eS(n, e) {
  e.offset && hi.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
  const t = Xg(n), i = e.vertexOffset !== void 0 ? e.vertexOffset : n.vertexOffset || 0, r = e.elementOffset || 0, s = i * t + r * n.bytesPerElement + (n.offset || 0);
  return {
    ...e,
    offset: s,
    stride: t
  };
}
function Ok(n, e) {
  const t = eS(n, e);
  return {
    high: t,
    low: {
      ...t,
      offset: t.offset + n.size * 4
    }
  };
}
class Fk {
  constructor(e, t, i) {
    G(this, "gl", void 0), G(this, "id", void 0), G(this, "size", void 0), G(this, "settings", void 0), G(this, "value", void 0), G(this, "doublePrecision", void 0), G(this, "_buffer", void 0), G(this, "state", void 0), this.gl = e, this.id = t.id || "", this.size = t.size || 1;
    const r = t.logicalType || t.type, s = r === 5130;
    let {
      defaultValue: c
    } = t;
    c = Number.isFinite(c) ? [c] : c || new Array(this.size).fill(0);
    let l;
    s ? l = 5126 : !r && t.isIndexed ? l = e && I1(e, rr.ELEMENT_INDEX_UINT32) ? 5125 : 5123 : l = r || 5126;
    let m = Rk(r || l || 5126);
    this.doublePrecision = s, s && t.fp64 === !1 && (m = Float32Array), this.value = null, this.settings = {
      ...t,
      defaultType: m,
      defaultValue: c,
      logicalType: r,
      type: l,
      size: this.size,
      bytesPerElement: m.BYTES_PER_ELEMENT
    }, this.state = {
      ...i,
      externalBuffer: null,
      bufferAccessor: this.settings,
      allocatedValue: null,
      numInstances: 0,
      bounds: null,
      constant: !1
    }, this._buffer = null;
  }
  get isConstant() {
    return this.state.constant;
  }
  get buffer() {
    if (!this._buffer) {
      const {
        isIndexed: e,
        type: t
      } = this.settings;
      this._buffer = new Hi(this.gl, {
        id: this.id,
        target: e ? 34963 : 34962,
        accessor: {
          type: t
        }
      });
    }
    return this._buffer;
  }
  get byteOffset() {
    const e = this.getAccessor();
    return e.vertexOffset ? e.vertexOffset * Xg(e) : 0;
  }
  get numInstances() {
    return this.state.numInstances;
  }
  set numInstances(e) {
    this.state.numInstances = e;
  }
  delete() {
    this._buffer && (this._buffer.delete(), this._buffer = null), _p.release(this.state.allocatedValue);
  }
  getShaderAttributes(e, t) {
    if (this.doublePrecision) {
      const i = {}, r = this.value instanceof Float64Array, s = Ok(this.getAccessor(), t || {});
      return i[e] = new d_(this, s.high), i["".concat(e, "64Low")] = r ? new d_(this, s.low) : new Float32Array(this.size), i;
    }
    if (t) {
      const i = eS(this.getAccessor(), t);
      return {
        [e]: new d_(this, i)
      };
    }
    return {
      [e]: this
    };
  }
  getBuffer() {
    return this.state.constant ? null : this.state.externalBuffer || this._buffer;
  }
  getValue() {
    return this.state.constant ? this.value : [this.getBuffer(), this.getAccessor()];
  }
  getAccessor() {
    return this.state.bufferAccessor;
  }
  getBounds() {
    if (this.state.bounds)
      return this.state.bounds;
    let e = null;
    if (this.state.constant && this.value) {
      const t = Array.from(this.value);
      e = [t, t];
    } else {
      const {
        value: t,
        numInstances: i,
        size: r
      } = this, s = i * r;
      if (t && s && t.length >= s) {
        const c = new Array(r).fill(1 / 0), l = new Array(r).fill(-1 / 0);
        for (let m = 0; m < s; )
          for (let y = 0; y < r; y++) {
            const A = t[m++];
            A < c[y] && (c[y] = A), A > l[y] && (l[y] = A);
          }
        e = [c, l];
      }
    }
    return this.state.bounds = e, e;
  }
  setData(e) {
    const {
      state: t
    } = this;
    let i;
    ArrayBuffer.isView(e) ? i = {
      value: e
    } : e instanceof Hi ? i = {
      buffer: e
    } : i = e;
    const r = {
      ...this.settings,
      ...i
    };
    if (t.bufferAccessor = r, t.bounds = null, i.constant) {
      let s = i.value;
      if (s = this._normalizeValue(s, [], 0), this.settings.normalized && (s = this.normalizeConstant(s)), !(!t.constant || !this._areValuesEqual(s, this.value)))
        return !1;
      t.externalBuffer = null, t.constant = !0, this.value = s;
    } else if (i.buffer) {
      const s = i.buffer;
      t.externalBuffer = s, t.constant = !1, this.value = i.value || null;
      const c = i.value instanceof Float64Array;
      r.type = i.type || s.accessor.type, r.bytesPerElement = s.accessor.BYTES_PER_ELEMENT * (c ? 2 : 1), r.stride = Xg(r);
    } else if (i.value) {
      this._checkExternalBuffer(i);
      let s = i.value;
      t.externalBuffer = null, t.constant = !1, this.value = s, r.bytesPerElement = s.BYTES_PER_ELEMENT, r.stride = Xg(r);
      const {
        buffer: c,
        byteOffset: l
      } = this;
      this.doublePrecision && s instanceof Float64Array && (s = l_(s, r));
      const m = s.byteLength + l + r.stride * 2;
      c.byteLength < m && c.reallocate(m), c.setAccessor(null), c.subData({
        data: s,
        offset: l
      }), r.type = i.type || c.accessor.type;
    }
    return !0;
  }
  updateSubBuffer() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.state.bounds = null;
    const t = this.value, {
      startOffset: i = 0,
      endOffset: r
    } = e;
    this.buffer.subData({
      data: this.doublePrecision && t instanceof Float64Array ? l_(t, {
        size: this.size,
        startIndex: i,
        endIndex: r
      }) : t.subarray(i, r),
      offset: i * t.BYTES_PER_ELEMENT + this.byteOffset
    });
  }
  allocate(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    const {
      state: i
    } = this, r = i.allocatedValue, s = _p.allocate(r, e + 1, {
      size: this.size,
      type: this.settings.defaultType,
      copy: t
    });
    this.value = s;
    const {
      buffer: c,
      byteOffset: l
    } = this;
    return c.byteLength < s.byteLength + l && (c.reallocate(s.byteLength + l), t && r && c.subData({
      data: r instanceof Float64Array ? l_(r, this) : r,
      offset: l
    })), i.allocatedValue = s, i.constant = !1, i.externalBuffer = null, i.bufferAccessor = this.settings, !0;
  }
  _checkExternalBuffer(e) {
    const {
      value: t
    } = e;
    if (!ArrayBuffer.isView(t))
      throw new Error("Attribute ".concat(this.id, " value is not TypedArray"));
    const i = this.settings.defaultType;
    let r = !1;
    if (this.doublePrecision && (r = t.BYTES_PER_ELEMENT < 4), r)
      throw new Error("Attribute ".concat(this.id, " does not support ").concat(t.constructor.name));
    !(t instanceof i) && this.settings.normalized && !("normalized" in e) && hi.warn("Attribute ".concat(this.id, " is normalized"))();
  }
  normalizeConstant(e) {
    switch (this.settings.type) {
      case 5120:
        return new Float32Array(e).map((t) => (t + 128) / 255 * 2 - 1);
      case 5122:
        return new Float32Array(e).map((t) => (t + 32768) / 65535 * 2 - 1);
      case 5121:
        return new Float32Array(e).map((t) => t / 255);
      case 5123:
        return new Float32Array(e).map((t) => t / 65535);
      default:
        return e;
    }
  }
  _normalizeValue(e, t, i) {
    const {
      defaultValue: r,
      size: s
    } = this.settings;
    if (Number.isFinite(e))
      return t[i] = e, t;
    if (!e) {
      let c = s;
      for (; --c >= 0; )
        t[i + c] = r[c];
      return t;
    }
    switch (s) {
      case 4:
        t[i + 3] = Number.isFinite(e[3]) ? e[3] : r[3];
      case 3:
        t[i + 2] = Number.isFinite(e[2]) ? e[2] : r[2];
      case 2:
        t[i + 1] = Number.isFinite(e[1]) ? e[1] : r[1];
      case 1:
        t[i + 0] = Number.isFinite(e[0]) ? e[0] : r[0];
        break;
      default:
        let c = s;
        for (; --c >= 0; )
          t[i + c] = Number.isFinite(e[c]) ? e[c] : r[c];
    }
    return t;
  }
  _areValuesEqual(e, t) {
    if (!e || !t)
      return !1;
    const {
      size: i
    } = this;
    for (let r = 0; r < i; r++)
      if (e[r] !== t[r])
        return !1;
    return !0;
  }
}
const iw = [], rw = [];
function tS(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1 / 0, i = iw;
  const r = {
    index: -1,
    data: n,
    target: []
  };
  return n ? typeof n[Symbol.iterator] == "function" ? i = n : n.length > 0 && (rw.length = n.length, i = rw) : i = iw, (e > 0 || Number.isFinite(t)) && (i = (Array.isArray(i) ? i : Array.from(i)).slice(e, t), r.index = e - 1), {
    iterable: i,
    objectInfo: r
  };
}
function nS(n) {
  return n && n[Symbol.asyncIterator];
}
function Dk(n, e) {
  const {
    size: t,
    stride: i,
    offset: r,
    startIndices: s,
    nested: c
  } = e, l = n.BYTES_PER_ELEMENT, m = i ? i / l : t, y = r ? r / l : 0, A = Math.floor((n.length - y) / m);
  return (T, I) => {
    let {
      index: L,
      target: N
    } = I;
    if (!s) {
      const J = L * m + y;
      for (let ce = 0; ce < t; ce++)
        N[ce] = n[J + ce];
      return N;
    }
    const z = s[L], V = s[L + 1] || A;
    let H;
    if (c) {
      H = new Array(V - z);
      for (let J = z; J < V; J++) {
        const ce = J * m + y;
        N = new Array(t);
        for (let me = 0; me < t; me++)
          N[me] = n[ce + me];
        H[J - z] = N;
      }
    } else if (m === t)
      H = n.subarray(z * t + y, V * t + y);
    else {
      H = new n.constructor((V - z) * t);
      let J = 0;
      for (let ce = z; ce < V; ce++) {
        const me = ce * m + y;
        for (let Se = 0; Se < t; Se++)
          H[J++] = n[me + Se];
      }
    }
    return H;
  };
}
const kk = [], Jg = [[0, 1 / 0]];
function Nk(n, e) {
  if (n === Jg || (e[0] < 0 && (e[0] = 0), e[0] >= e[1]))
    return n;
  const t = [], i = n.length;
  let r = 0;
  for (let s = 0; s < i; s++) {
    const c = n[s];
    c[1] < e[0] ? (t.push(c), r = s + 1) : c[0] > e[1] ? t.push(c) : e = [Math.min(c[0], e[0]), Math.max(c[1], e[1])];
  }
  return t.splice(r, 0, e), t;
}
function f_(n) {
  const {
    source: e,
    target: t,
    start: i = 0,
    size: r,
    getData: s
  } = n, c = n.end || t.length, l = e.length, m = c - i;
  if (l > m) {
    t.set(e.subarray(0, m), i);
    return;
  }
  if (t.set(e, i), !s)
    return;
  let y = l;
  for (; y < m; ) {
    const A = s(y, e);
    for (let T = 0; T < r; T++)
      t[i + y] = A[T] || 0, y++;
  }
}
function zk(n) {
  let {
    source: e,
    target: t,
    size: i,
    getData: r,
    sourceStartIndices: s,
    targetStartIndices: c
  } = n;
  if (!Array.isArray(c))
    return f_({
      source: e,
      target: t,
      size: i,
      getData: r
    }), t;
  let l = 0, m = 0;
  const y = r && ((T, I) => r(T + m, I)), A = Math.min(s.length, c.length);
  for (let T = 1; T < A; T++) {
    const I = s[T] * i, L = c[T] * i;
    f_({
      source: e.subarray(l, I),
      target: t,
      start: m,
      end: L,
      size: i,
      getData: y
    }), l = I, m = L;
  }
  return m < t.length && f_({
    source: [],
    target: t,
    start: m,
    size: i,
    getData: y
  }), t;
}
const Uk = {
  interpolation: {
    duration: 0,
    easing: (n) => n
  },
  spring: {
    stiffness: 0.05,
    damping: 0.5
  }
};
function iS(n, e) {
  if (!n)
    return null;
  Number.isFinite(n) && (n = {
    type: "interpolation",
    duration: n
  });
  const t = n.type || "interpolation";
  return {
    ...Uk[t],
    ...e,
    ...n,
    type: t
  };
}
function rS(n, e) {
  const t = e.getBuffer();
  return t ? [t, {
    divisor: 0,
    size: e.size,
    normalized: e.settings.normalized
  }] : e.value;
}
function sS(n) {
  switch (n) {
    case 1:
      return "float";
    case 2:
      return "vec2";
    case 3:
      return "vec3";
    case 4:
      return "vec4";
    default:
      throw new Error('No defined attribute type for size "'.concat(n, '"'));
  }
}
function oS(n) {
  n.push(n.shift());
}
function Q1(n, e) {
  const {
    doublePrecision: t,
    settings: i,
    value: r,
    size: s
  } = n, c = t && r instanceof Float64Array ? 2 : 1;
  return (i.noAlloc ? r.length : e * s) * c;
}
function aS(n) {
  let {
    buffer: e,
    numInstances: t,
    attribute: i,
    fromLength: r,
    fromStartIndices: s,
    getData: c = (J) => J
  } = n;
  const l = i.doublePrecision && i.value instanceof Float64Array ? 2 : 1, m = i.size * l, y = i.byteOffset, A = i.startIndices, T = s && A, I = Q1(i, t), L = i.isConstant;
  if (!T && r >= I)
    return;
  const N = L ? i.value : i.getBuffer().getData({
    srcByteOffset: y
  });
  if (i.settings.normalized && !L) {
    const J = c;
    c = (ce, me) => i.normalizeConstant(J(ce, me));
  }
  const z = L ? (J, ce) => c(N, ce) : (J, ce) => c(N.subarray(J, J + m), ce), V = e.getData({
    length: r
  }), H = new Float32Array(I);
  zk({
    source: V,
    target: H,
    sourceStartIndices: s,
    targetStartIndices: A,
    size: m,
    getData: z
  }), e.byteLength < H.byteLength + y && e.reallocate(H.byteLength + y), e.subData({
    data: H,
    offset: y
  });
}
class ev extends Fk {
  constructor(e, t) {
    super(e, t, {
      startIndices: null,
      lastExternalBuffer: null,
      binaryValue: null,
      binaryAccessor: null,
      needsUpdate: !0,
      needsRedraw: !1,
      updateRanges: Jg
    }), G(this, "constant", !1), this.settings.update = t.update || (t.accessor ? this._autoUpdater : void 0), Object.seal(this.settings), Object.seal(this.state), this._validateAttributeUpdaters();
  }
  get startIndices() {
    return this.state.startIndices;
  }
  set startIndices(e) {
    this.state.startIndices = e;
  }
  needsUpdate() {
    return this.state.needsUpdate;
  }
  needsRedraw() {
    let {
      clearChangedFlags: e = !1
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = this.state.needsRedraw;
    return this.state.needsRedraw = t && !e, t;
  }
  getUpdateTriggers() {
    const {
      accessor: e
    } = this.settings;
    return [this.id].concat(typeof e != "function" && e || []);
  }
  supportsTransition() {
    return !!this.settings.transition;
  }
  getTransitionSetting(e) {
    if (!e || !this.supportsTransition())
      return null;
    const {
      accessor: t
    } = this.settings, i = this.settings.transition, r = Array.isArray(t) ? e[t.find((s) => e[s])] : e[t];
    return iS(r, i);
  }
  setNeedsUpdate() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.id, t = arguments.length > 1 ? arguments[1] : void 0;
    if (this.state.needsUpdate = this.state.needsUpdate || e, this.setNeedsRedraw(e), t) {
      const {
        startRow: i = 0,
        endRow: r = 1 / 0
      } = t;
      this.state.updateRanges = Nk(this.state.updateRanges, [i, r]);
    } else
      this.state.updateRanges = Jg;
  }
  clearNeedsUpdate() {
    this.state.needsUpdate = !1, this.state.updateRanges = kk;
  }
  setNeedsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.id;
    this.state.needsRedraw = this.state.needsRedraw || e;
  }
  allocate(e) {
    const {
      state: t,
      settings: i
    } = this;
    return i.noAlloc ? !1 : i.update ? (super.allocate(e, t.updateRanges !== Jg), !0) : !1;
  }
  updateBuffer(e) {
    let {
      numInstances: t,
      data: i,
      props: r,
      context: s
    } = e;
    if (!this.needsUpdate())
      return !1;
    const {
      state: {
        updateRanges: c
      },
      settings: {
        update: l,
        noAlloc: m
      }
    } = this;
    let y = !0;
    if (l) {
      for (const [A, T] of c)
        l.call(s, this, {
          data: i,
          startRow: A,
          endRow: T,
          props: r,
          numInstances: t
        });
      if (this.value)
        if (this.constant || this.buffer.byteLength < this.value.byteLength + this.byteOffset)
          this.setData({
            value: this.value,
            constant: this.constant
          }), this.constant = !1;
        else
          for (const [A, T] of c) {
            const I = Number.isFinite(A) ? this.getVertexOffset(A) : 0, L = Number.isFinite(T) ? this.getVertexOffset(T) : m || !Number.isFinite(t) ? this.value.length : t * this.size;
            super.updateSubBuffer({
              startOffset: I,
              endOffset: L
            });
          }
      this._checkAttributeArray();
    } else
      y = !1;
    return this.clearNeedsUpdate(), this.setNeedsRedraw(), y;
  }
  setConstantValue(e) {
    return e === void 0 || typeof e == "function" ? !1 : (this.setData({
      constant: !0,
      value: e
    }) && this.setNeedsRedraw(), this.clearNeedsUpdate(), !0);
  }
  setExternalBuffer(e) {
    const {
      state: t
    } = this;
    return e ? (this.clearNeedsUpdate(), t.lastExternalBuffer === e || (t.lastExternalBuffer = e, this.setNeedsRedraw(), this.setData(e)), !0) : (t.lastExternalBuffer = null, !1);
  }
  setBinaryValue(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    const {
      state: i,
      settings: r
    } = this;
    if (!e)
      return i.binaryValue = null, i.binaryAccessor = null, !1;
    if (r.noAlloc)
      return !1;
    if (i.binaryValue === e)
      return this.clearNeedsUpdate(), !0;
    if (i.binaryValue = e, this.setNeedsRedraw(), r.transform || t !== this.startIndices) {
      ArrayBuffer.isView(e) && (e = {
        value: e
      });
      const c = e;
      Is(ArrayBuffer.isView(c.value), "invalid ".concat(r.accessor));
      const l = !!c.size && c.size !== this.size;
      return i.binaryAccessor = Dk(c.value, {
        size: c.size || this.size,
        stride: c.stride,
        offset: c.offset,
        startIndices: t,
        nested: l
      }), !1;
    }
    return this.clearNeedsUpdate(), this.setData(e), !0;
  }
  getVertexOffset(e) {
    const {
      startIndices: t
    } = this;
    return (t ? e < t.length ? t[e] : this.numInstances : e) * this.size;
  }
  getShaderAttributes() {
    const e = this.settings.shaderAttributes || {
      [this.id]: null
    }, t = {};
    for (const i in e)
      Object.assign(t, super.getShaderAttributes(i, e[i]));
    return t;
  }
  _autoUpdater(e, t) {
    let {
      data: i,
      startRow: r,
      endRow: s,
      props: c,
      numInstances: l
    } = t;
    if (e.constant)
      return;
    const {
      settings: m,
      state: y,
      value: A,
      size: T,
      startIndices: I
    } = e, {
      accessor: L,
      transform: N
    } = m, z = y.binaryAccessor || (typeof L == "function" ? L : c[L]);
    Is(typeof z == "function", 'accessor "'.concat(L, '" is not a function'));
    let V = e.getVertexOffset(r);
    const {
      iterable: H,
      objectInfo: J
    } = tS(i, r, s);
    for (const ce of H) {
      J.index++;
      let me = z(ce, J);
      if (N && (me = N.call(this, me)), I) {
        const Se = (J.index < I.length - 1 ? I[J.index + 1] : l) - I[J.index];
        if (me && Array.isArray(me[0])) {
          let De = V;
          for (const Le of me)
            e._normalizeValue(Le, A, De), De += T;
        } else
          me && me.length > T ? A.set(me, V) : (e._normalizeValue(me, J.target, 0), hD({
            target: A,
            source: J.target,
            start: V,
            count: Se
          }));
        V += Se * T;
      } else
        e._normalizeValue(me, A, V), V += T;
    }
  }
  _validateAttributeUpdaters() {
    const {
      settings: e
    } = this;
    if (!(e.noAlloc || typeof e.update == "function"))
      throw new Error("Attribute ".concat(this.id, " missing update or accessor"));
  }
  _checkAttributeArray() {
    const {
      value: e
    } = this, t = Math.min(4, this.size);
    if (e && e.length >= t) {
      let i = !0;
      switch (t) {
        case 4:
          i = i && Number.isFinite(e[3]);
        case 3:
          i = i && Number.isFinite(e[2]);
        case 2:
          i = i && Number.isFinite(e[1]);
        case 1:
          i = i && Number.isFinite(e[0]);
          break;
        default:
          i = !1;
      }
      if (!i)
        throw new Error("Illegal attribute generated for ".concat(this.id));
    }
  }
}
class jk {
  constructor(e) {
    let {
      gl: t,
      attribute: i,
      timeline: r
    } = e;
    G(this, "gl", void 0), G(this, "type", "interpolation"), G(this, "attributeInTransition", void 0), G(this, "settings", void 0), G(this, "attribute", void 0), G(this, "transition", void 0), G(this, "currentStartIndices", void 0), G(this, "currentLength", void 0), G(this, "transform", void 0), G(this, "buffers", void 0), this.gl = t, this.transition = new Dp(r), this.attribute = i, this.attributeInTransition = new ev(t, i.settings), this.currentStartIndices = i.startIndices, this.currentLength = 0, this.transform = Vk(t, i);
    const s = {
      byteLength: 0,
      usage: 35050
    };
    this.buffers = [new Hi(t, s), new Hi(t, s)];
  }
  get inProgress() {
    return this.transition.inProgress;
  }
  start(e, t) {
    if (e.duration <= 0) {
      this.transition.cancel();
      return;
    }
    this.settings = e;
    const {
      gl: i,
      buffers: r,
      attribute: s
    } = this;
    oS(r);
    const c = {
      numInstances: t,
      attribute: s,
      fromLength: this.currentLength,
      fromStartIndices: this.currentStartIndices,
      getData: e.enter
    };
    for (const l of r)
      aS({
        buffer: l,
        ...c
      });
    this.currentStartIndices = s.startIndices, this.currentLength = Q1(s, t), this.attributeInTransition.setData({
      buffer: r[1],
      value: s.value
    }), this.transition.start(e), this.transform.update({
      elementCount: Math.floor(this.currentLength / s.size),
      sourceBuffers: {
        aFrom: r[0],
        aTo: rS(i, s)
      },
      feedbackBuffers: {
        vCurrent: r[1]
      }
    });
  }
  update() {
    const e = this.transition.update();
    if (e) {
      const {
        duration: t,
        easing: i
      } = this.settings, {
        time: r
      } = this.transition;
      let s = r / t;
      i && (s = i(s)), this.transform.run({
        uniforms: {
          time: s
        }
      });
    }
    return e;
  }
  cancel() {
    this.transition.cancel(), this.transform.delete();
    for (const e of this.buffers)
      e.delete();
    this.buffers.length = 0;
  }
}
const Gk = `
#define SHADER_NAME interpolation-transition-vertex-shader

uniform float time;
attribute ATTRIBUTE_TYPE aFrom;
attribute ATTRIBUTE_TYPE aTo;
varying ATTRIBUTE_TYPE vCurrent;

void main(void) {
  vCurrent = mix(aFrom, aTo, time);
  gl_Position = vec4(0.0);
}
`;
function Vk(n, e) {
  const t = sS(e.size);
  return new G1(n, {
    vs: Gk,
    defines: {
      ATTRIBUTE_TYPE: t
    },
    varyings: ["vCurrent"]
  });
}
class qk {
  constructor(e) {
    let {
      gl: t,
      attribute: i,
      timeline: r
    } = e;
    G(this, "gl", void 0), G(this, "type", "spring"), G(this, "attributeInTransition", void 0), G(this, "settings", void 0), G(this, "attribute", void 0), G(this, "transition", void 0), G(this, "currentStartIndices", void 0), G(this, "currentLength", void 0), G(this, "texture", void 0), G(this, "framebuffer", void 0), G(this, "transform", void 0), G(this, "buffers", void 0), this.gl = t, this.type = "spring", this.transition = new Dp(r), this.attribute = i, this.attributeInTransition = new ev(t, {
      ...i.settings,
      normalized: !1
    }), this.currentStartIndices = i.startIndices, this.currentLength = 0, this.texture = Wk(t), this.framebuffer = Xk(t, this.texture), this.transform = Hk(t, i, this.framebuffer);
    const s = {
      byteLength: 0,
      usage: 35050
    };
    this.buffers = [new Hi(t, s), new Hi(t, s), new Hi(t, s)];
  }
  get inProgress() {
    return this.transition.inProgress;
  }
  start(e, t) {
    const {
      gl: i,
      buffers: r,
      attribute: s
    } = this, c = {
      numInstances: t,
      attribute: s,
      fromLength: this.currentLength,
      fromStartIndices: this.currentStartIndices,
      getData: e.enter
    };
    for (const l of r)
      aS({
        buffer: l,
        ...c
      });
    this.settings = e, this.currentStartIndices = s.startIndices, this.currentLength = Q1(s, t), this.attributeInTransition.setData({
      buffer: r[1],
      value: s.value
    }), this.transition.start({
      ...e,
      duration: 1 / 0
    }), this.transform.update({
      elementCount: Math.floor(this.currentLength / s.size),
      sourceBuffers: {
        aTo: rS(i, s)
      }
    });
  }
  update() {
    const {
      buffers: e,
      transform: t,
      framebuffer: i,
      transition: r
    } = this;
    if (!r.update())
      return !1;
    const c = this.settings;
    return t.update({
      sourceBuffers: {
        aPrev: e[0],
        aCur: e[1]
      },
      feedbackBuffers: {
        vNext: e[2]
      }
    }), t.run({
      framebuffer: i,
      discard: !1,
      clearRenderTarget: !0,
      uniforms: {
        stiffness: c.stiffness,
        damping: c.damping
      },
      parameters: {
        depthTest: !1,
        blend: !0,
        viewport: [0, 0, 1, 1],
        blendFunc: [1, 1],
        blendEquation: [32776, 32776]
      }
    }), oS(e), this.attributeInTransition.setData({
      buffer: e[1],
      value: this.attribute.value
    }), Om(i)[0] > 0 || r.end(), !0;
  }
  cancel() {
    this.transition.cancel(), this.transform.delete();
    for (const e of this.buffers)
      e.delete();
    this.buffers.length = 0, this.texture.delete(), this.framebuffer.delete();
  }
}
function Hk(n, e, t) {
  const i = sS(e.size);
  return new G1(n, {
    framebuffer: t,
    vs: `
#define SHADER_NAME spring-transition-vertex-shader

#define EPSILON 0.00001

uniform float stiffness;
uniform float damping;
attribute ATTRIBUTE_TYPE aPrev;
attribute ATTRIBUTE_TYPE aCur;
attribute ATTRIBUTE_TYPE aTo;
varying ATTRIBUTE_TYPE vNext;
varying float vIsTransitioningFlag;

ATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {
  ATTRIBUTE_TYPE velocity = cur - prev;
  ATTRIBUTE_TYPE delta = dest - cur;
  ATTRIBUTE_TYPE spring = delta * stiffness;
  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;
  return spring + damper + velocity + cur;
}

void main(void) {
  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;
  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;

  vNext = getNextValue(aCur, aPrev, aTo);
  gl_Position = vec4(0, 0, 0, 1);
  gl_PointSize = 100.0;
}
`,
    fs: `
#define SHADER_NAME spring-transition-is-transitioning-fragment-shader

varying float vIsTransitioningFlag;

void main(void) {
  if (vIsTransitioningFlag == 0.0) {
    discard;
  }
  gl_FragColor = vec4(1.0);
}`,
    defines: {
      ATTRIBUTE_TYPE: i
    },
    varyings: ["vNext"]
  });
}
function Wk(n) {
  return new ga(n, {
    data: new Uint8Array(4),
    format: 6408,
    type: 5121,
    border: 0,
    mipmaps: !1,
    dataFormat: 6408,
    width: 1,
    height: 1
  });
}
function Xk(n, e) {
  return new ss(n, {
    id: "spring-transition-is-transitioning-framebuffer",
    width: 1,
    height: 1,
    attachments: {
      36064: e
    }
  });
}
const Jk = {
  interpolation: jk,
  spring: qk
};
class $k {
  constructor(e, t) {
    let {
      id: i,
      timeline: r
    } = t;
    G(this, "id", void 0), G(this, "isSupported", void 0), G(this, "gl", void 0), G(this, "timeline", void 0), G(this, "transitions", void 0), G(this, "needsRedraw", void 0), G(this, "numInstances", void 0), this.id = i, this.gl = e, this.timeline = r, this.transitions = {}, this.needsRedraw = !1, this.numInstances = 1, this.isSupported = G1.isSupported(e);
  }
  finalize() {
    for (const e in this.transitions)
      this._removeTransition(e);
  }
  update(e) {
    let {
      attributes: t,
      transitions: i,
      numInstances: r
    } = e;
    this.numInstances = r || 1;
    for (const s in t) {
      const c = t[s], l = c.getTransitionSetting(i);
      l && this._updateAttribute(s, c, l);
    }
    for (const s in this.transitions) {
      const c = t[s];
      (!c || !c.getTransitionSetting(i)) && this._removeTransition(s);
    }
  }
  hasAttribute(e) {
    const t = this.transitions[e];
    return t && t.inProgress;
  }
  getAttributes() {
    const e = {};
    for (const t in this.transitions) {
      const i = this.transitions[t];
      i.inProgress && (e[t] = i.attributeInTransition);
    }
    return e;
  }
  run() {
    if (!this.isSupported || this.numInstances === 0)
      return !1;
    for (const t in this.transitions)
      this.transitions[t].update() && (this.needsRedraw = !0);
    const e = this.needsRedraw;
    return this.needsRedraw = !1, e;
  }
  _removeTransition(e) {
    this.transitions[e].cancel(), delete this.transitions[e];
  }
  _updateAttribute(e, t, i) {
    const r = this.transitions[e];
    let s = !r || r.type !== i.type;
    if (s) {
      if (!this.isSupported) {
        hi.warn("WebGL2 not supported by this browser. Transition for ".concat(e, " is disabled."))();
        return;
      }
      r && this._removeTransition(e);
      const c = Jk[i.type];
      c ? this.transitions[e] = new c({
        attribute: t,
        timeline: this.timeline,
        gl: this.gl
      }) : (hi.error("unsupported transition type '".concat(i.type, "'"))(), s = !1);
    }
    (s || t.needsRedraw()) && (this.needsRedraw = !0, this.transitions[e].start(i, this.numInstances));
  }
}
const sw = "attributeManager.invalidate", Zk = "attributeManager.updateStart", Yk = "attributeManager.updateEnd", Kk = "attribute.updateStart", Qk = "attribute.allocate", eN = "attribute.updateEnd";
class tN {
  constructor(e) {
    let {
      id: t = "attribute-manager",
      stats: i,
      timeline: r
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    G(this, "id", void 0), G(this, "gl", void 0), G(this, "attributes", void 0), G(this, "updateTriggers", void 0), G(this, "needsRedraw", void 0), G(this, "userData", void 0), G(this, "stats", void 0), G(this, "attributeTransitionManager", void 0), G(this, "mergeBoundsMemoized", Fp(nD)), this.id = t, this.gl = e, this.attributes = {}, this.updateTriggers = {}, this.needsRedraw = !0, this.userData = {}, this.stats = i, this.attributeTransitionManager = new $k(e, {
      id: "".concat(t, "-transitions"),
      timeline: r
    }), Object.seal(this);
  }
  finalize() {
    for (const e in this.attributes)
      this.attributes[e].delete();
    this.attributeTransitionManager.finalize();
  }
  getNeedsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    const t = this.needsRedraw;
    return this.needsRedraw = this.needsRedraw && !e.clearRedrawFlags, t && this.id;
  }
  setNeedsRedraw() {
    this.needsRedraw = !0;
  }
  add(e) {
    this._add(e);
  }
  addInstanced(e) {
    this._add(e, {
      instanced: 1
    });
  }
  remove(e) {
    for (const t of e)
      this.attributes[t] !== void 0 && (this.attributes[t].delete(), delete this.attributes[t]);
  }
  invalidate(e, t) {
    const i = this._invalidateTrigger(e, t);
    Xs(sw, this, e, i);
  }
  invalidateAll(e) {
    for (const t in this.attributes)
      this.attributes[t].setNeedsUpdate(t, e);
    Xs(sw, this, "all");
  }
  update(e) {
    let {
      data: t,
      numInstances: i,
      startIndices: r = null,
      transitions: s,
      props: c = {},
      buffers: l = {},
      context: m = {}
    } = e, y = !1;
    Xs(Zk, this), this.stats && this.stats.get("Update Attributes").timeStart();
    for (const A in this.attributes) {
      const T = this.attributes[A], I = T.settings.accessor;
      T.startIndices = r, T.numInstances = i, c[A] && hi.removed("props.".concat(A), "data.attributes.".concat(A))(), T.setExternalBuffer(l[A]) || T.setBinaryValue(typeof I == "string" ? l[I] : void 0, t.startIndices) || typeof I == "string" && !l[I] && T.setConstantValue(c[I]) || T.needsUpdate() && (y = !0, this._updateAttribute({
        attribute: T,
        numInstances: i,
        data: t,
        props: c,
        context: m
      })), this.needsRedraw = this.needsRedraw || T.needsRedraw();
    }
    y && Xs(Yk, this, i), this.stats && this.stats.get("Update Attributes").timeEnd(), this.attributeTransitionManager.update({
      attributes: this.attributes,
      numInstances: i,
      transitions: s
    });
  }
  updateTransition() {
    const {
      attributeTransitionManager: e
    } = this, t = e.run();
    return this.needsRedraw = this.needsRedraw || t, t;
  }
  getAttributes() {
    return this.attributes;
  }
  getBounds(e) {
    const t = e.map((i) => {
      var r;
      return (r = this.attributes[i]) === null || r === void 0 ? void 0 : r.getBounds();
    });
    return this.mergeBoundsMemoized(t);
  }
  getChangedAttributes() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearChangedFlags: !1
    };
    const {
      attributes: t,
      attributeTransitionManager: i
    } = this, r = {
      ...i.getAttributes()
    };
    for (const s in t) {
      const c = t[s];
      c.needsRedraw(e) && !i.hasAttribute(s) && (r[s] = c);
    }
    return r;
  }
  getShaderAttributes(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    e || (e = this.getAttributes());
    const i = {};
    for (const r in e)
      t[r] || Object.assign(i, e[r].getShaderAttributes());
    return i;
  }
  _add(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    for (const i in e) {
      const r = e[i];
      this.attributes[i] = this._createAttribute(i, r, t);
    }
    this._mapUpdateTriggersToAttributes();
  }
  _createAttribute(e, t, i) {
    const r = {
      ...t,
      id: e,
      size: t.isIndexed && 1 || t.size || 1,
      divisor: i.instanced ? 1 : t.divisor || 0
    };
    return new ev(this.gl, r);
  }
  _mapUpdateTriggersToAttributes() {
    const e = {};
    for (const t in this.attributes)
      this.attributes[t].getUpdateTriggers().forEach((r) => {
        e[r] || (e[r] = []), e[r].push(t);
      });
    this.updateTriggers = e;
  }
  _invalidateTrigger(e, t) {
    const {
      attributes: i,
      updateTriggers: r
    } = this, s = r[e];
    return s && s.forEach((c) => {
      const l = i[c];
      l && l.setNeedsUpdate(l.id, t);
    }), s;
  }
  _updateAttribute(e) {
    const {
      attribute: t,
      numInstances: i
    } = e;
    if (Xs(Kk, t), t.constant) {
      t.setConstantValue(t.value);
      return;
    }
    t.allocate(i) && Xs(Qk, t, i), t.updateBuffer(e) && (this.needsRedraw = !0, Xs(eN, t, i));
  }
}
class nN extends Dp {
  get value() {
    return this._value;
  }
  _onUpdate() {
    const {
      time: e,
      settings: {
        fromValue: t,
        toValue: i,
        duration: r,
        easing: s
      }
    } = this, c = s(e / r);
    this._value = gm(t, i, c);
  }
}
const ow = 1e-5;
function aw(n, e, t, i, r) {
  const s = e - n, l = (t - e) * r, m = -s * i;
  return l + m + s + e;
}
function iN(n, e, t, i, r) {
  if (Array.isArray(t)) {
    const s = [];
    for (let c = 0; c < t.length; c++)
      s[c] = aw(n[c], e[c], t[c], i, r);
    return s;
  }
  return aw(n, e, t, i, r);
}
function lw(n, e) {
  if (Array.isArray(n)) {
    let t = 0;
    for (let i = 0; i < n.length; i++) {
      const r = n[i] - e[i];
      t += r * r;
    }
    return Math.sqrt(t);
  }
  return Math.abs(n - e);
}
class rN extends Dp {
  get value() {
    return this._currValue;
  }
  _onUpdate() {
    const {
      fromValue: e,
      toValue: t,
      damping: i,
      stiffness: r
    } = this.settings, {
      _prevValue: s = e,
      _currValue: c = e
    } = this;
    let l = iN(s, c, t, i, r);
    const m = lw(l, t), y = lw(l, c);
    m < ow && y < ow && (l = t, this.end()), this._prevValue = c, this._currValue = l;
  }
}
const sN = {
  interpolation: nN,
  spring: rN
};
class oN {
  constructor(e) {
    this.transitions = /* @__PURE__ */ new Map(), this.timeline = e;
  }
  get active() {
    return this.transitions.size > 0;
  }
  add(e, t, i, r) {
    const {
      transitions: s
    } = this;
    if (s.has(e)) {
      const m = s.get(e), {
        value: y = m.settings.fromValue
      } = m;
      t = y, this.remove(e);
    }
    if (r = iS(r), !r)
      return;
    const c = sN[r.type];
    if (!c) {
      hi.error("unsupported transition type '".concat(r.type, "'"))();
      return;
    }
    const l = new c(this.timeline);
    l.start({
      ...r,
      fromValue: t,
      toValue: i
    }), s.set(e, l);
  }
  remove(e) {
    const {
      transitions: t
    } = this;
    t.has(e) && (t.get(e).cancel(), t.delete(e));
  }
  update() {
    const e = {};
    for (const [t, i] of this.transitions)
      i.update(), e[t] = i.value, i.inProgress || this.remove(t);
    return e;
  }
  clear() {
    for (const e of this.transitions.keys())
      this.remove(e);
  }
}
function aN(n) {
  const e = n[Wu];
  for (const t in e) {
    const i = e[t], {
      validate: r
    } = i;
    if (r && !r(n[t], i))
      throw new Error("Invalid prop ".concat(t, ": ").concat(n[t]));
  }
}
function lN(n, e) {
  const t = lS({
    newProps: n,
    oldProps: e,
    propTypes: n[Wu],
    ignoreProps: {
      data: null,
      updateTriggers: null,
      extensions: null,
      transitions: null
    }
  }), i = uN(n, e);
  let r = !1;
  return i || (r = hN(n, e)), {
    dataChanged: i,
    propsChanged: t,
    updateTriggersChanged: r,
    extensionsChanged: dN(n, e),
    transitionsChanged: cN(n, e)
  };
}
function cN(n, e) {
  if (!n.transitions)
    return !1;
  const t = {}, i = n[Wu];
  let r = !1;
  for (const s in n.transitions) {
    const c = i[s], l = c && c.type;
    (l === "number" || l === "color" || l === "array") && Ty(n[s], e[s], c) && (t[s] = !0, r = !0);
  }
  return r ? t : !1;
}
function lS(n) {
  let {
    newProps: e,
    oldProps: t,
    ignoreProps: i = {},
    propTypes: r = {},
    triggerName: s = "props"
  } = n;
  if (t === e)
    return !1;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return "".concat(s, " changed shallowly");
  for (const c of Object.keys(e))
    if (!(c in i)) {
      if (!(c in t))
        return "".concat(s, ".").concat(c, " added");
      const l = Ty(e[c], t[c], r[c]);
      if (l)
        return "".concat(s, ".").concat(c, " ").concat(l);
    }
  for (const c of Object.keys(t))
    if (!(c in i)) {
      if (!(c in e))
        return "".concat(s, ".").concat(c, " dropped");
      if (!Object.hasOwnProperty.call(e, c)) {
        const l = Ty(e[c], t[c], r[c]);
        if (l)
          return "".concat(s, ".").concat(c, " ").concat(l);
      }
    }
  return !1;
}
function Ty(n, e, t) {
  let i = t && t.equal;
  return i && !i(n, e, t) || !i && (i = n && e && n.equals, i && !i.call(n, e)) ? "changed deeply" : !i && e !== n ? "changed shallowly" : null;
}
function uN(n, e) {
  if (e === null)
    return "oldProps is null, initial diff";
  let t = !1;
  const {
    dataComparator: i,
    _dataDiff: r
  } = n;
  return i ? i(n.data, e.data) || (t = "Data comparator detected a change") : n.data !== e.data && (t = "A new data container was supplied"), t && r && (t = r(n.data, e.data) || t), t;
}
function hN(n, e) {
  if (e === null)
    return {
      all: !0
    };
  if ("all" in n.updateTriggers && cw(n, e, "all"))
    return {
      all: !0
    };
  const t = {};
  let i = !1;
  for (const r in n.updateTriggers)
    r !== "all" && cw(n, e, r) && (t[r] = !0, i = !0);
  return i ? t : !1;
}
function dN(n, e) {
  if (e === null)
    return !0;
  const t = e.extensions, {
    extensions: i
  } = n;
  if (i === t)
    return !1;
  if (!t || !i || i.length !== t.length)
    return !0;
  for (let r = 0; r < i.length; r++)
    if (!i[r].equals(t[r]))
      return !0;
  return !1;
}
function cw(n, e, t) {
  let i = n.updateTriggers[t];
  i = i ?? {};
  let r = e.updateTriggers[t];
  return r = r ?? {}, lS({
    oldProps: r,
    newProps: i,
    triggerName: t
  });
}
const fN = "count(): argument not an object", pN = "count(): argument not a container";
function gN(n) {
  if (!_N(n))
    throw new Error(fN);
  if (typeof n.count == "function")
    return n.count();
  if (Number.isFinite(n.size))
    return n.size;
  if (Number.isFinite(n.length))
    return n.length;
  if (mN(n))
    return Object.keys(n).length;
  throw new Error(pN);
}
function mN(n) {
  return n !== null && typeof n == "object" && n.constructor === Object;
}
function _N(n) {
  return n !== null && typeof n == "object";
}
function yN(n, e) {
  if (!e)
    return n;
  const t = {
    ...n,
    ...e
  };
  if ("defines" in e && (t.defines = {
    ...n.defines,
    ...e.defines
  }), "modules" in e && (t.modules = (n.modules || []).concat(e.modules), e.modules.some((i) => i.name === "project64"))) {
    const i = t.modules.findIndex((r) => r.name === "project32");
    i >= 0 && t.modules.splice(i, 1);
  }
  if ("inject" in e)
    if (!n.inject)
      t.inject = e.inject;
    else {
      const i = {
        ...n.inject
      };
      for (const r in e.inject)
        i[r] = (i[r] || "") + e.inject[r];
      t.inject = i;
    }
  return t;
}
const vN = {
  10241: 9987,
  10240: 9729,
  10242: 33071,
  10243: 33071
}, Cy = {};
function bN(n, e, t, i) {
  if (t instanceof ga)
    return t;
  t.constructor && t.constructor.name !== "Object" && (t = {
    data: t
  });
  let r = null;
  t.compressed && (r = {
    10241: t.data.length > 1 ? 9985 : 9729
  });
  const s = new ga(e, {
    ...t,
    parameters: {
      ...vN,
      ...r,
      ...i
    }
  });
  return Cy[s.id] = n, s;
}
function xN(n, e) {
  !e || !(e instanceof ga) || Cy[e.id] === n && (e.delete(), delete Cy[e.id]);
}
const wN = {
  boolean: {
    validate(n, e) {
      return !0;
    },
    equal(n, e, t) {
      return !!n == !!e;
    }
  },
  number: {
    validate(n, e) {
      return Number.isFinite(n) && (!("max" in e) || n <= e.max) && (!("min" in e) || n >= e.min);
    }
  },
  color: {
    validate(n, e) {
      return e.optional && !n || Iy(n) && (n.length === 3 || n.length === 4);
    },
    equal(n, e, t) {
      return hc(n, e, 1);
    }
  },
  accessor: {
    validate(n, e) {
      const t = wm(n);
      return t === "function" || t === wm(e.value);
    },
    equal(n, e, t) {
      return typeof e == "function" ? !0 : hc(n, e, 1);
    }
  },
  array: {
    validate(n, e) {
      return e.optional && !n || Iy(n);
    },
    equal(n, e, t) {
      const {
        compare: i
      } = t, r = Number.isInteger(i) ? i : i ? 1 : 0;
      return i ? hc(n, e, r) : n === e;
    }
  },
  object: {
    equal(n, e, t) {
      if (t.ignore)
        return !0;
      const {
        compare: i
      } = t, r = Number.isInteger(i) ? i : i ? 1 : 0;
      return i ? hc(n, e, r) : n === e;
    }
  },
  function: {
    validate(n, e) {
      return e.optional && !n || typeof n == "function";
    },
    equal(n, e, t) {
      return !t.compare && t.ignore !== !1 || n === e;
    }
  },
  data: {
    transform: (n, e, t) => {
      const {
        dataTransform: i
      } = t.props;
      return i && n ? i(n) : n;
    }
  },
  image: {
    transform: (n, e, t) => {
      const i = t.context;
      return !i || !i.gl ? null : bN(t.id, i.gl, n, {
        ...e.parameters,
        ...t.props.textureParameters
      });
    },
    release: (n, e, t) => {
      xN(t.id, n);
    }
  }
};
function AN(n) {
  const e = {}, t = {}, i = {};
  for (const [r, s] of Object.entries(n)) {
    const c = s == null ? void 0 : s.deprecatedFor;
    if (c)
      i[r] = Array.isArray(c) ? c : [c];
    else {
      const l = EN(r, s);
      e[r] = l, t[r] = l.value;
    }
  }
  return {
    propTypes: e,
    defaultProps: t,
    deprecatedProps: i
  };
}
function EN(n, e) {
  switch (wm(e)) {
    case "object":
      return zf(n, e);
    case "array":
      return zf(n, {
        type: "array",
        value: e,
        compare: !1
      });
    case "boolean":
      return zf(n, {
        type: "boolean",
        value: e
      });
    case "number":
      return zf(n, {
        type: "number",
        value: e
      });
    case "function":
      return zf(n, {
        type: "function",
        value: e,
        compare: !0
      });
    default:
      return {
        name: n,
        type: "unknown",
        value: e
      };
  }
}
function zf(n, e) {
  return "type" in e ? {
    name: n,
    ...wN[e.type],
    ...e
  } : "value" in e ? {
    name: n,
    type: wm(e.value),
    ...e
  } : {
    name: n,
    type: "object",
    value: e
  };
}
function Iy(n) {
  return Array.isArray(n) || ArrayBuffer.isView(n);
}
function wm(n) {
  return Iy(n) ? "array" : n === null ? "null" : typeof n;
}
function SN(n, e) {
  let t;
  for (let s = e.length - 1; s >= 0; s--) {
    const c = e[s];
    "extensions" in c && (t = c.extensions);
  }
  const i = Py(n.constructor, t), r = Object.create(i);
  r[bm] = n, r[zh] = {}, r[Vu] = {};
  for (let s = 0; s < e.length; ++s) {
    const c = e[s];
    for (const l in c)
      r[l] = c[l];
  }
  return Object.freeze(r), r;
}
const TN = "_mergedDefaultProps";
function Py(n, e) {
  let t = TN;
  if (e)
    for (const r of e) {
      const s = r.constructor;
      s && (t += ":".concat(s.extensionName || s.name));
    }
  const i = cS(n, t);
  return i || (n[t] = CN(n, e || []));
}
function CN(n, e) {
  if (!n.prototype)
    return null;
  const i = Object.getPrototypeOf(n), r = Py(i), s = cS(n, "defaultProps") || {}, c = AN(s), l = Object.assign(/* @__PURE__ */ Object.create(null), r, c.defaultProps), m = Object.assign(/* @__PURE__ */ Object.create(null), r == null ? void 0 : r[Wu], c.propTypes), y = Object.assign(/* @__PURE__ */ Object.create(null), r == null ? void 0 : r[u_], c.deprecatedProps);
  for (const A of e) {
    const T = Py(A.constructor);
    T && (Object.assign(l, T), Object.assign(m, T[Wu]), Object.assign(y, T[u_]));
  }
  return IN(l, n), LN(l, m), PN(l, y), l[Wu] = m, l[u_] = y, e.length === 0 && !tv(n, "_propTypes") && (n._propTypes = m), l;
}
function IN(n, e) {
  const t = BN(e);
  Object.defineProperties(n, {
    id: {
      writable: !0,
      value: t
    }
  });
}
function PN(n, e) {
  for (const t in e)
    Object.defineProperty(n, t, {
      enumerable: !1,
      set(i) {
        const r = "".concat(this.id, ": ").concat(t);
        for (const s of e[t])
          tv(this, s) || (this[s] = i);
        hi.deprecated(r, e[t].join("/"))();
      }
    });
}
function LN(n, e) {
  const t = {}, i = {};
  for (const r in e) {
    const s = e[r], {
      name: c,
      value: l
    } = s;
    s.async && (t[c] = l, i[c] = MN(c));
  }
  n[Bd] = t, n[zh] = {}, Object.defineProperties(n, i);
}
function MN(n) {
  return {
    enumerable: !0,
    set(e) {
      typeof e == "string" || e instanceof Promise || nS(e) ? this[zh][n] = e : this[Vu][n] = e;
    },
    get() {
      if (this[Vu]) {
        if (n in this[Vu])
          return this[Vu][n] || this[Bd][n];
        if (n in this[zh]) {
          const e = this[bm] && this[bm].internalState;
          if (e && e.hasAsyncProp(n))
            return e.getAsyncProp(n) || this[Bd][n];
        }
      }
      return this[Bd][n];
    }
  };
}
function tv(n, e) {
  return Object.prototype.hasOwnProperty.call(n, e);
}
function cS(n, e) {
  return tv(n, e) && n[e];
}
function BN(n) {
  const e = n.componentName;
  return e || hi.warn("".concat(n.name, ".componentName not specified"))(), e || n.name;
}
let RN = 0;
class nv {
  constructor() {
    G(this, "id", void 0), G(this, "props", void 0), G(this, "count", void 0);
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    this.props = SN(this, t), this.id = this.props.id, this.count = RN++;
  }
  clone(e) {
    const {
      props: t
    } = this, i = {};
    for (const r in t[Bd])
      r in t[Vu] ? i[r] = t[Vu][r] : r in t[zh] && (i[r] = t[zh][r]);
    return new this.constructor({
      ...t,
      ...i,
      ...e
    });
  }
}
G(nv, "componentName", "Component");
G(nv, "defaultProps", {});
const ON = Object.freeze({});
class FN {
  constructor(e) {
    G(this, "component", void 0), G(this, "onAsyncPropUpdated", void 0), G(this, "asyncProps", void 0), G(this, "oldProps", void 0), G(this, "oldAsyncProps", void 0), this.component = e, this.asyncProps = {}, this.onAsyncPropUpdated = () => {
    }, this.oldProps = null, this.oldAsyncProps = null;
  }
  finalize() {
    for (const e in this.asyncProps) {
      const t = this.asyncProps[e];
      t && t.type && t.type.release && t.type.release(t.resolvedValue, t.type, this.component);
    }
    this.asyncProps = {}, this.component = null, this.resetOldProps();
  }
  getOldProps() {
    return this.oldAsyncProps || this.oldProps || ON;
  }
  resetOldProps() {
    this.oldAsyncProps = null, this.oldProps = this.component ? this.component.props : null;
  }
  hasAsyncProp(e) {
    return e in this.asyncProps;
  }
  getAsyncProp(e) {
    const t = this.asyncProps[e];
    return t && t.resolvedValue;
  }
  isAsyncPropLoading(e) {
    if (e) {
      const t = this.asyncProps[e];
      return !!(t && t.pendingLoadCount > 0 && t.pendingLoadCount !== t.resolvedLoadCount);
    }
    for (const t in this.asyncProps)
      if (this.isAsyncPropLoading(t))
        return !0;
    return !1;
  }
  reloadAsyncProp(e, t) {
    this._watchPromise(e, Promise.resolve(t));
  }
  setAsyncProps(e) {
    this.component = e[bm] || this.component;
    const t = e[Vu] || {}, i = e[zh] || e, r = e[Bd] || {};
    for (const s in t) {
      const c = t[s];
      this._createAsyncPropData(s, r[s]), this._updateAsyncProp(s, c), t[s] = this.getAsyncProp(s);
    }
    for (const s in i) {
      const c = i[s];
      this._createAsyncPropData(s, r[s]), this._updateAsyncProp(s, c);
    }
  }
  _fetch(e, t) {
    return null;
  }
  _onResolve(e, t) {
  }
  _onError(e, t) {
  }
  _updateAsyncProp(e, t) {
    if (this._didAsyncInputValueChange(e, t)) {
      if (typeof t == "string" && (t = this._fetch(e, t)), t instanceof Promise) {
        this._watchPromise(e, t);
        return;
      }
      if (nS(t)) {
        this._resolveAsyncIterable(e, t);
        return;
      }
      this._setPropValue(e, t);
    }
  }
  _freezeAsyncOldProps() {
    if (!this.oldAsyncProps && this.oldProps) {
      this.oldAsyncProps = Object.create(this.oldProps);
      for (const e in this.asyncProps)
        Object.defineProperty(this.oldAsyncProps, e, {
          enumerable: !0,
          value: this.oldProps[e]
        });
    }
  }
  _didAsyncInputValueChange(e, t) {
    const i = this.asyncProps[e];
    return t === i.resolvedValue || t === i.lastValue ? !1 : (i.lastValue = t, !0);
  }
  _setPropValue(e, t) {
    this._freezeAsyncOldProps();
    const i = this.asyncProps[e];
    i && (t = this._postProcessValue(i, t), i.resolvedValue = t, i.pendingLoadCount++, i.resolvedLoadCount = i.pendingLoadCount);
  }
  _setAsyncPropValue(e, t, i) {
    const r = this.asyncProps[e];
    r && i >= r.resolvedLoadCount && t !== void 0 && (this._freezeAsyncOldProps(), r.resolvedValue = t, r.resolvedLoadCount = i, this.onAsyncPropUpdated(e, t));
  }
  _watchPromise(e, t) {
    const i = this.asyncProps[e];
    if (i) {
      i.pendingLoadCount++;
      const r = i.pendingLoadCount;
      t.then((s) => {
        this.component && (s = this._postProcessValue(i, s), this._setAsyncPropValue(e, s, r), this._onResolve(e, s));
      }).catch((s) => {
        this._onError(e, s);
      });
    }
  }
  async _resolveAsyncIterable(e, t) {
    if (e !== "data") {
      this._setPropValue(e, t);
      return;
    }
    const i = this.asyncProps[e];
    if (!i)
      return;
    i.pendingLoadCount++;
    const r = i.pendingLoadCount;
    let s = [], c = 0;
    for await (const l of t) {
      if (!this.component)
        return;
      const {
        dataTransform: m
      } = this.component.props;
      m ? s = m(l, s) : s = s.concat(l), Object.defineProperty(s, "__diff", {
        enumerable: !1,
        value: [{
          startRow: c,
          endRow: s.length
        }]
      }), c = s.length, this._setAsyncPropValue(e, s, r);
    }
    this._onResolve(e, s);
  }
  _postProcessValue(e, t) {
    const i = e.type;
    return i && this.component && (i.release && i.release(e.resolvedValue, i, this.component), i.transform) ? i.transform(t, i, this.component) : t;
  }
  _createAsyncPropData(e, t) {
    if (!this.asyncProps[e]) {
      const r = this.component && this.component.props[Wu];
      this.asyncProps[e] = {
        type: r && r[e],
        lastValue: null,
        resolvedValue: t,
        pendingLoadCount: 0,
        resolvedLoadCount: 0
      };
    }
  }
}
class DN extends FN {
  constructor(e) {
    let {
      attributeManager: t,
      layer: i
    } = e;
    super(i), G(this, "attributeManager", void 0), G(this, "needsRedraw", void 0), G(this, "needsUpdate", void 0), G(this, "subLayers", void 0), G(this, "usesPickingColorCache", void 0), G(this, "hasPickingBuffer", void 0), G(this, "changeFlags", void 0), G(this, "viewport", void 0), G(this, "uniformTransitions", void 0), G(this, "propsInTransition", void 0), this.attributeManager = t, this.needsRedraw = !0, this.needsUpdate = !0, this.subLayers = null, this.usesPickingColorCache = !1;
  }
  get layer() {
    return this.component;
  }
  _fetch(e, t) {
    const i = this.layer, r = i == null ? void 0 : i.props.fetch;
    return r ? r(t, {
      propName: e,
      layer: i
    }) : super._fetch(e, t);
  }
  _onResolve(e, t) {
    const i = this.layer;
    if (i) {
      const r = i.props.onDataLoad;
      e === "data" && r && r(t, {
        propName: e,
        layer: i
      });
    }
  }
  _onError(e, t) {
    const i = this.layer;
    i && i.raiseError(t, "loading ".concat(e, " of ").concat(this.layer));
  }
}
const kN = "layer.changeFlag", NN = "layer.initialize", zN = "layer.update", UN = "layer.finalize", jN = "layer.matched", uw = 2 ** 24 - 1, GN = Object.freeze([]), VN = Fp((n) => {
  let {
    oldViewport: e,
    viewport: t
  } = n;
  return e.equals(t);
});
let sc = new Uint8ClampedArray(0);
const qN = {
  data: {
    type: "data",
    value: GN,
    async: !0
  },
  dataComparator: {
    type: "function",
    value: null,
    optional: !0
  },
  _dataDiff: {
    type: "function",
    value: (n) => n && n.__diff,
    optional: !0
  },
  dataTransform: {
    type: "function",
    value: null,
    optional: !0
  },
  onDataLoad: {
    type: "function",
    value: null,
    optional: !0
  },
  onError: {
    type: "function",
    value: null,
    optional: !0
  },
  fetch: {
    type: "function",
    value: (n, e) => {
      let {
        propName: t,
        layer: i,
        loaders: r,
        loadOptions: s,
        signal: c
      } = e;
      const {
        resourceManager: l
      } = i.context;
      if (s = s || i.getLoadOptions(), r = r || i.props.loaders, c) {
        var m;
        s = {
          ...s,
          fetch: {
            ...(m = s) === null || m === void 0 ? void 0 : m.fetch,
            signal: c
          }
        };
      }
      let y = l.contains(n);
      return !y && !s && (l.add({
        resourceId: n,
        data: Ju(n, r),
        persistent: !1
      }), y = !0), y ? l.subscribe({
        resourceId: n,
        onChange: (A) => {
          var T;
          return (T = i.internalState) === null || T === void 0 ? void 0 : T.reloadAsyncProp(t, A);
        },
        consumerId: i.id,
        requestId: t
      }) : Ju(n, r, s);
    }
  },
  updateTriggers: {},
  visible: !0,
  pickable: !1,
  opacity: {
    type: "number",
    min: 0,
    max: 1,
    value: 1
  },
  operation: "draw",
  onHover: {
    type: "function",
    value: null,
    optional: !0
  },
  onClick: {
    type: "function",
    value: null,
    optional: !0
  },
  onDragStart: {
    type: "function",
    value: null,
    optional: !0
  },
  onDrag: {
    type: "function",
    value: null,
    optional: !0
  },
  onDragEnd: {
    type: "function",
    value: null,
    optional: !0
  },
  coordinateSystem: li.DEFAULT,
  coordinateOrigin: {
    type: "array",
    value: [0, 0, 0],
    compare: !0
  },
  modelMatrix: {
    type: "array",
    value: null,
    compare: !0,
    optional: !0
  },
  wrapLongitude: !1,
  positionFormat: "XYZ",
  colorFormat: "RGBA",
  parameters: {
    type: "object",
    value: {},
    optional: !0,
    compare: 2
  },
  loadOptions: {
    type: "object",
    value: null,
    optional: !0,
    ignore: !0
  },
  transitions: null,
  extensions: [],
  loaders: {
    type: "array",
    value: [],
    optional: !0,
    ignore: !0
  },
  getPolygonOffset: {
    type: "function",
    value: (n) => {
      let {
        layerIndex: e
      } = n;
      return [0, -e * 100];
    }
  },
  highlightedObjectIndex: null,
  autoHighlight: !1,
  highlightColor: {
    type: "accessor",
    value: [0, 0, 128, 128]
  }
};
class ef extends nv {
  constructor() {
    super(...arguments), G(this, "internalState", null), G(this, "lifecycle", bd.NO_STATE), G(this, "context", void 0), G(this, "state", void 0), G(this, "parent", null);
  }
  static get componentName() {
    return Object.prototype.hasOwnProperty.call(this, "layerName") ? this.layerName : "";
  }
  get root() {
    let e = this;
    for (; e.parent; )
      e = e.parent;
    return e;
  }
  toString() {
    const e = this.constructor.layerName || this.constructor.name;
    return "".concat(e, "({id: '").concat(this.props.id, "'})");
  }
  project(e) {
    Is(this.internalState);
    const t = this.internalState.viewport || this.context.viewport, i = qE(e, {
      viewport: t,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem
    }), [r, s, c] = VE(i, t.pixelProjectionMatrix);
    return e.length === 2 ? [r, s] : [r, s, c];
  }
  unproject(e) {
    return Is(this.internalState), (this.internalState.viewport || this.context.viewport).unproject(e);
  }
  projectPosition(e, t) {
    Is(this.internalState);
    const i = this.internalState.viewport || this.context.viewport;
    return lD(e, {
      viewport: i,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem,
      ...t
    });
  }
  get isComposite() {
    return !1;
  }
  setState(e) {
    this.setChangeFlags({
      stateChanged: !0
    }), Object.assign(this.state, e), this.setNeedsRedraw();
  }
  setNeedsRedraw() {
    this.internalState && (this.internalState.needsRedraw = !0);
  }
  setNeedsUpdate() {
    this.internalState && (this.context.layerManager.setNeedsUpdate(String(this)), this.internalState.needsUpdate = !0);
  }
  get isLoaded() {
    return this.internalState ? !this.internalState.isAsyncPropLoading() : !1;
  }
  get wrapLongitude() {
    return this.props.wrapLongitude;
  }
  isPickable() {
    return this.props.pickable && this.props.visible;
  }
  getModels() {
    return this.state && (this.state.models || this.state.model && [this.state.model]) || [];
  }
  setModuleParameters(e) {
    for (const t of this.getModels())
      t.updateModuleSettings(e);
  }
  getAttributeManager() {
    return this.internalState && this.internalState.attributeManager;
  }
  getCurrentLayer() {
    return this.internalState && this.internalState.layer;
  }
  getLoadOptions() {
    return this.props.loadOptions;
  }
  use64bitPositions() {
    const {
      coordinateSystem: e
    } = this.props;
    return e === li.DEFAULT || e === li.LNGLAT || e === li.CARTESIAN;
  }
  onHover(e, t) {
    return this.props.onHover && this.props.onHover(e, t) || !1;
  }
  onClick(e, t) {
    return this.props.onClick && this.props.onClick(e, t) || !1;
  }
  nullPickingColor() {
    return [0, 0, 0];
  }
  encodePickingColor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return t[0] = e + 1 & 255, t[1] = e + 1 >> 8 & 255, t[2] = e + 1 >> 8 >> 8 & 255, t;
  }
  decodePickingColor(e) {
    Is(e instanceof Uint8Array);
    const [t, i, r] = e;
    return t + i * 256 + r * 65536 - 1;
  }
  getNumInstances() {
    return Number.isFinite(this.props.numInstances) ? this.props.numInstances : this.state && this.state.numInstances !== void 0 ? this.state.numInstances : gN(this.props.data);
  }
  getStartIndices() {
    return this.props.startIndices ? this.props.startIndices : this.state && this.state.startIndices ? this.state.startIndices : null;
  }
  getBounds() {
    var e;
    return (e = this.getAttributeManager()) === null || e === void 0 ? void 0 : e.getBounds(["positions", "instancePositions"]);
  }
  getShaders(e) {
    for (const t of this.props.extensions)
      e = yN(e, t.getShaders.call(this, t));
    return e;
  }
  shouldUpdateState(e) {
    return e.changeFlags.propsOrDataChanged;
  }
  updateState(e) {
    const t = this.getAttributeManager(), {
      dataChanged: i
    } = e.changeFlags;
    if (i && t)
      if (Array.isArray(i))
        for (const r of i)
          t.invalidateAll(r);
      else
        t.invalidateAll();
    if (t) {
      const {
        props: r
      } = e, s = this.internalState.hasPickingBuffer, c = Number.isInteger(r.highlightedObjectIndex) || r.pickable || r.extensions.some((l) => l.getNeedsPickingBuffer.call(this, l));
      if (s !== c) {
        this.internalState.hasPickingBuffer = c;
        const {
          pickingColors: l,
          instancePickingColors: m
        } = t.attributes, y = l || m;
        y && (c && y.constant && (y.constant = !1, t.invalidate(y.id)), !y.value && !c && (y.constant = !0, y.value = [0, 0, 0]));
      }
    }
  }
  finalizeState(e) {
    for (const i of this.getModels())
      i.delete();
    const t = this.getAttributeManager();
    t && t.finalize(), this.context && this.context.resourceManager.unsubscribe({
      consumerId: this.id
    }), this.internalState && (this.internalState.uniformTransitions.clear(), this.internalState.finalize());
  }
  draw(e) {
    for (const t of this.getModels())
      t.draw(e);
  }
  getPickingInfo(e) {
    let {
      info: t,
      mode: i,
      sourceLayer: r
    } = e;
    const {
      index: s
    } = t;
    return s >= 0 && Array.isArray(this.props.data) && (t.object = this.props.data[s]), t;
  }
  raiseError(e, t) {
    var i, r;
    if (t && (e = new Error("".concat(t, ": ").concat(e.message), {
      cause: e
    })), !((i = (r = this.props).onError) !== null && i !== void 0 && i.call(r, e))) {
      var s, c;
      (s = this.context) === null || s === void 0 || (c = s.onError) === null || c === void 0 || c.call(s, e, this);
    }
  }
  getNeedsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    return this._getNeedsRedraw(e);
  }
  needsUpdate() {
    return this.internalState ? this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams()) : !1;
  }
  hasUniformTransition() {
    var e;
    return ((e = this.internalState) === null || e === void 0 ? void 0 : e.uniformTransitions.active) || !1;
  }
  activateViewport(e) {
    if (!this.internalState)
      return;
    const t = this.internalState.viewport;
    this.internalState.viewport = e, (!t || !VN({
      oldViewport: t,
      viewport: e
    })) && (this.setChangeFlags({
      viewportChanged: !0
    }), this.isComposite ? this.needsUpdate() && this.setNeedsUpdate() : this._update());
  }
  invalidateAttribute() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "all";
    const t = this.getAttributeManager();
    t && (e === "all" ? t.invalidateAll() : t.invalidate(e));
  }
  updateAttributes(e) {
    for (const t of this.getModels())
      this._setModelAttributes(t, e);
  }
  _updateAttributes() {
    const e = this.getAttributeManager();
    if (!e)
      return;
    const t = this.props, i = this.getNumInstances(), r = this.getStartIndices();
    e.update({
      data: t.data,
      numInstances: i,
      startIndices: r,
      props: t,
      transitions: t.transitions,
      buffers: t.data.attributes,
      context: this
    });
    const s = e.getChangedAttributes({
      clearChangedFlags: !0
    });
    this.updateAttributes(s);
  }
  _updateAttributeTransition() {
    const e = this.getAttributeManager();
    e && e.updateTransition();
  }
  _updateUniformTransition() {
    const {
      uniformTransitions: e
    } = this.internalState;
    if (e.active) {
      const t = e.update(), i = Object.create(this.props);
      for (const r in t)
        Object.defineProperty(i, r, {
          value: t[r]
        });
      return i;
    }
    return this.props;
  }
  calculateInstancePickingColors(e, t) {
    let {
      numInstances: i
    } = t;
    if (e.constant)
      return;
    const r = Math.floor(sc.length / 3);
    if (this.internalState.usesPickingColorCache = !0, r < i) {
      i > uw && hi.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")(), sc = _p.allocate(sc, i, {
        size: 3,
        copy: !0,
        maxCount: Math.max(i, uw)
      });
      const s = Math.floor(sc.length / 3), c = [];
      for (let l = r; l < s; l++)
        this.encodePickingColor(l, c), sc[l * 3 + 0] = c[0], sc[l * 3 + 1] = c[1], sc[l * 3 + 2] = c[2];
    }
    e.value = sc.subarray(0, i * 3);
  }
  _setModelAttributes(e, t) {
    const i = this.getAttributeManager(), r = e.userData.excludeAttributes || {}, s = i.getShaderAttributes(t, r);
    e.setAttributes(s);
  }
  disablePickingIndex(e) {
    const t = this.props.data;
    if (!("attributes" in t)) {
      this._disablePickingIndex(e);
      return;
    }
    const {
      pickingColors: i,
      instancePickingColors: r
    } = this.getAttributeManager().attributes, s = i || r, c = s && t.attributes && t.attributes[s.id];
    if (c && c.value) {
      const l = c.value, m = this.encodePickingColor(e);
      for (let y = 0; y < t.length; y++) {
        const A = s.getVertexOffset(y);
        l[A] === m[0] && l[A + 1] === m[1] && l[A + 2] === m[2] && this._disablePickingIndex(y);
      }
    } else
      this._disablePickingIndex(e);
  }
  _disablePickingIndex(e) {
    const {
      pickingColors: t,
      instancePickingColors: i
    } = this.getAttributeManager().attributes, r = t || i;
    if (!r)
      return;
    const s = r.getVertexOffset(e), c = r.getVertexOffset(e + 1);
    r.buffer.subData({
      data: new Uint8Array(c - s),
      offset: s
    });
  }
  restorePickingColors() {
    const {
      pickingColors: e,
      instancePickingColors: t
    } = this.getAttributeManager().attributes, i = e || t;
    i && (this.internalState.usesPickingColorCache && i.value.buffer !== sc.buffer && (i.value = sc.subarray(0, i.value.length)), i.updateSubBuffer({
      startOffset: 0
    }));
  }
  _initialize() {
    Is(!this.internalState), Is(Number.isFinite(this.props.coordinateSystem)), Xs(NN, this);
    const e = this._getAttributeManager();
    e && e.addInstanced({
      instancePickingColors: {
        type: 5121,
        size: 3,
        noAlloc: !0,
        update: this.calculateInstancePickingColors
      }
    }), this.internalState = new DN({
      attributeManager: e,
      layer: this
    }), this._clearChangeFlags(), this.state = {}, Object.defineProperty(this.state, "attributeManager", {
      get: () => (hi.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")(), e)
    }), this.internalState.uniformTransitions = new oN(this.context.timeline), this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this), this.internalState.setAsyncProps(this.props), this.initializeState(this.context);
    for (const t of this.props.extensions)
      t.initializeState.call(this, this.context, t);
    this.setChangeFlags({
      dataChanged: "init",
      propsChanged: "init",
      viewportChanged: !0,
      extensionsChanged: !0
    }), this._update();
  }
  _transferState(e) {
    Xs(jN, this, this === e);
    const {
      state: t,
      internalState: i
    } = e;
    this !== e && (this.internalState = i, this.state = t, this.internalState.setAsyncProps(this.props), this._diffProps(this.props, this.internalState.getOldProps()));
  }
  _update() {
    const e = this.needsUpdate();
    if (Xs(zN, this, e), !e)
      return;
    const t = this.props, i = this.context, r = this.internalState, s = i.viewport, c = this._updateUniformTransition();
    r.propsInTransition = c, i.viewport = r.viewport || s, this.props = c;
    try {
      const l = this._getUpdateParams(), m = this.getModels();
      if (i.gl)
        this.updateState(l);
      else
        try {
          this.updateState(l);
        } catch {
        }
      for (const A of this.props.extensions)
        A.updateState.call(this, l, A);
      const y = this.getModels()[0] !== m[0];
      this._postUpdate(l, y);
    } finally {
      i.viewport = s, this.props = t, this._clearChangeFlags(), r.needsUpdate = !1, r.resetOldProps();
    }
  }
  _finalize() {
    Xs(UN, this), this.finalizeState(this.context);
    for (const e of this.props.extensions)
      e.finalizeState.call(this, this.context, e);
  }
  _drawLayer(e) {
    let {
      moduleParameters: t = null,
      uniforms: i = {},
      parameters: r = {}
    } = e;
    this._updateAttributeTransition();
    const s = this.props, c = this.context;
    this.props = this.internalState.propsInTransition || s;
    const l = this.props.opacity;
    i.opacity = Math.pow(l, 1 / 2.2);
    try {
      t && this.setModuleParameters(t);
      const {
        getPolygonOffset: m
      } = this.props, y = m && m(i) || [0, 0];
      eu(c.gl, {
        polygonOffset: y
      }), Cl(c.gl, r, () => {
        const A = {
          moduleParameters: t,
          uniforms: i,
          parameters: r,
          context: c
        };
        for (const T of this.props.extensions)
          T.draw.call(this, A, T);
        this.draw(A);
      });
    } finally {
      this.props = s;
    }
  }
  getChangeFlags() {
    var e;
    return (e = this.internalState) === null || e === void 0 ? void 0 : e.changeFlags;
  }
  setChangeFlags(e) {
    if (!this.internalState)
      return;
    const {
      changeFlags: t
    } = this.internalState;
    for (const r in e)
      if (e[r]) {
        let s = !1;
        switch (r) {
          case "dataChanged":
            const c = e[r], l = t[r];
            c && Array.isArray(l) && (t.dataChanged = Array.isArray(c) ? l.concat(c) : c, s = !0);
          default:
            t[r] || (t[r] = e[r], s = !0);
        }
        s && Xs(kN, this, r, e);
      }
    const i = !!(t.dataChanged || t.updateTriggersChanged || t.propsChanged || t.extensionsChanged);
    t.propsOrDataChanged = i, t.somethingChanged = i || t.viewportChanged || t.stateChanged;
  }
  _clearChangeFlags() {
    this.internalState.changeFlags = {
      dataChanged: !1,
      propsChanged: !1,
      updateTriggersChanged: !1,
      viewportChanged: !1,
      stateChanged: !1,
      extensionsChanged: !1,
      propsOrDataChanged: !1,
      somethingChanged: !1
    };
  }
  _diffProps(e, t) {
    const i = lN(e, t);
    if (i.updateTriggersChanged)
      for (const s in i.updateTriggersChanged)
        i.updateTriggersChanged[s] && this.invalidateAttribute(s);
    if (i.transitionsChanged)
      for (const s in i.transitionsChanged) {
        var r;
        this.internalState.uniformTransitions.add(s, t[s], e[s], (r = e.transitions) === null || r === void 0 ? void 0 : r[s]);
      }
    return this.setChangeFlags(i);
  }
  validateProps() {
    aN(this.props);
  }
  updateAutoHighlight(e) {
    this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex) && this._updateAutoHighlight(e);
  }
  _updateAutoHighlight(e) {
    const t = {
      pickingSelectedColor: e.picked ? e.color : null
    }, {
      highlightColor: i
    } = this.props;
    e.picked && typeof i == "function" && (t.pickingHighlightColor = i(e)), this.setModuleParameters(t), this.setNeedsRedraw();
  }
  _getAttributeManager() {
    const e = this.context;
    return new tN(e.gl, {
      id: this.props.id,
      stats: e.stats,
      timeline: e.timeline
    });
  }
  _postUpdate(e, t) {
    const {
      props: i,
      oldProps: r
    } = e;
    this.setNeedsRedraw(), this._updateAttributes();
    const {
      model: s
    } = this.state;
    s == null || s.setInstanceCount(this.getNumInstances());
    const {
      autoHighlight: c,
      highlightedObjectIndex: l,
      highlightColor: m
    } = i;
    if (t || r.autoHighlight !== c || r.highlightedObjectIndex !== l || r.highlightColor !== m) {
      const y = {};
      c || (y.pickingSelectedColor = null), Array.isArray(m) && (y.pickingHighlightColor = m), (t || l !== r.highlightedObjectIndex) && (y.pickingSelectedColor = Number.isFinite(l) && l >= 0 ? this.encodePickingColor(l) : null), this.setModuleParameters(y);
    }
  }
  _getUpdateParams() {
    return {
      props: this.props,
      oldProps: this.internalState.getOldProps(),
      context: this.context,
      changeFlags: this.internalState.changeFlags
    };
  }
  _getNeedsRedraw(e) {
    if (!this.internalState)
      return !1;
    let t = !1;
    t = t || this.internalState.needsRedraw && this.id;
    const i = this.getAttributeManager(), r = i ? i.getNeedsRedraw(e) : !1;
    if (t = t || r, t)
      for (const s of this.props.extensions)
        s.onNeedsRedraw.call(this, s);
    return this.internalState.needsRedraw = this.internalState.needsRedraw && !e.clearRedrawFlags, t;
  }
  _onAsyncPropUpdated() {
    this._diffProps(this.props, this.internalState.getOldProps()), this.setNeedsUpdate();
  }
}
G(ef, "defaultProps", qN);
G(ef, "layerName", "Layer");
const HN = "compositeLayer.renderLayers";
class uS extends ef {
  get isComposite() {
    return !0;
  }
  get isLoaded() {
    return super.isLoaded && this.getSubLayers().every((e) => e.isLoaded);
  }
  getSubLayers() {
    return this.internalState && this.internalState.subLayers || [];
  }
  initializeState(e) {
  }
  setState(e) {
    super.setState(e), this.setNeedsUpdate();
  }
  getPickingInfo(e) {
    let {
      info: t
    } = e;
    const {
      object: i
    } = t;
    return i && i.__source && i.__source.parent && i.__source.parent.id === this.id && (t.object = i.__source.object, t.index = i.__source.index), t;
  }
  filterSubLayer(e) {
    return !0;
  }
  shouldRenderSubLayer(e, t) {
    return t && t.length;
  }
  getSubLayerClass(e, t) {
    const {
      _subLayerProps: i
    } = this.props;
    return i && i[e] && i[e].type || t;
  }
  getSubLayerRow(e, t, i) {
    return e.__source = {
      parent: this,
      object: t,
      index: i
    }, e;
  }
  getSubLayerAccessor(e) {
    if (typeof e == "function") {
      const t = {
        index: -1,
        data: this.props.data,
        target: []
      };
      return (i, r) => i && i.__source ? (t.index = i.__source.index, e(i.__source.object, t)) : e(i, r);
    }
    return e;
  }
  getSubLayerProps() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var t;
    const {
      opacity: i,
      pickable: r,
      visible: s,
      parameters: c,
      getPolygonOffset: l,
      highlightedObjectIndex: m,
      autoHighlight: y,
      highlightColor: A,
      coordinateSystem: T,
      coordinateOrigin: I,
      wrapLongitude: L,
      positionFormat: N,
      modelMatrix: z,
      extensions: V,
      fetch: H,
      operation: J,
      _subLayerProps: ce
    } = this.props, me = {
      id: "",
      updateTriggers: {},
      opacity: i,
      pickable: r,
      visible: s,
      parameters: c,
      getPolygonOffset: l,
      highlightedObjectIndex: m,
      autoHighlight: y,
      highlightColor: A,
      coordinateSystem: T,
      coordinateOrigin: I,
      wrapLongitude: L,
      positionFormat: N,
      modelMatrix: z,
      extensions: V,
      fetch: H,
      operation: J
    }, Se = ce && e.id && ce[e.id], De = Se && Se.updateTriggers, Le = e.id || "sublayer";
    if (Se) {
      const ye = this.props[Wu], Ve = e.type ? e.type._propTypes : {};
      for (const Fe in Se) {
        const ae = Ve[Fe] || ye[Fe];
        ae && ae.type === "accessor" && (Se[Fe] = this.getSubLayerAccessor(Se[Fe]));
      }
    }
    Object.assign(me, e, Se), me.id = "".concat(this.props.id, "-").concat(Le), me.updateTriggers = {
      all: (t = this.props.updateTriggers) === null || t === void 0 ? void 0 : t.all,
      ...e.updateTriggers,
      ...De
    };
    for (const ye of V) {
      const Ve = ye.getSubLayerProps.call(this, ye);
      Ve && Object.assign(me, Ve, {
        updateTriggers: Object.assign(me.updateTriggers, Ve.updateTriggers)
      });
    }
    return me;
  }
  _updateAutoHighlight(e) {
    for (const t of this.getSubLayers())
      t.updateAutoHighlight(e);
  }
  _getAttributeManager() {
    return null;
  }
  _postUpdate(e, t) {
    let i = this.internalState.subLayers;
    const r = !i || this.needsUpdate();
    if (r) {
      const s = this.renderLayers();
      i = Fm(s, Boolean), this.internalState.subLayers = i;
    }
    Xs(HN, this, r, i);
    for (const s of i)
      s.parent = this;
  }
}
G(uS, "layerName", "CompositeLayer");
const p_ = 512, WN = Math.PI / 180;
function XN(n) {
  let {
    map: e,
    gl: t,
    deck: i
  } = n;
  if (e.__deck)
    return e.__deck;
  const r = i == null ? void 0 : i.props._customRender, s = i == null ? void 0 : i.props.onLoad, c = $N({
    ...i == null ? void 0 : i.props,
    _customRender: () => {
      e.triggerRepaint(), r == null || r("");
    }
  });
  let l;
  return (!i || i.props.gl === t) && (Object.assign(c, {
    gl: t,
    width: null,
    height: null,
    touchAction: "unset",
    viewState: iv(e)
  }), i != null && i.isInitialized ? hw(i, e) : c.onLoad = () => {
    s == null || s(), hw(l, e);
  }), i ? (l = i, i.setProps(c), i.userData.isExternal = !0) : (l = new K1(c), e.on("remove", () => {
    JN(e);
  })), l.userData.mapboxLayers = /* @__PURE__ */ new Set(), e.__deck = l, e.on("render", () => {
    l.isInitialized && t8(l, e);
  }), l;
}
function hw(n, e) {
  const t = () => {
    n.isInitialized ? n8(n, e) : e.off("move", t);
  };
  e.on("move", t);
}
function JN(n) {
  var e;
  (e = n.__deck) === null || e === void 0 || e.finalize(), n.__deck = null;
}
function $N(n) {
  return {
    ...n,
    parameters: {
      depthMask: !0,
      depthTest: !0,
      blend: !0,
      blendFunc: [770, 771, 1, 771],
      polygonOffsetFill: !0,
      depthFunc: 515,
      blendEquation: 32774,
      ...n.parameters
    },
    views: n.views || [new Z1({
      id: "mapbox"
    })]
  };
}
function ZN(n, e) {
  n.userData.mapboxLayers.add(e), rv(n);
}
function YN(n, e) {
  n.userData.mapboxLayers.delete(e), rv(n);
}
function KN(n, e) {
  rv(n);
}
function QN(n, e, t) {
  let {
    currentViewport: i
  } = n.userData, r = !1;
  i || (i = hS(n, e, !0), n.userData.currentViewport = i, r = !0), n.isInitialized && n._drawLayers("mapbox-repaint", {
    viewports: [i],
    layerFilter: (s) => {
      let {
        layer: c
      } = s;
      return t.id === c.id || c.props.operation.includes("terrain");
    },
    clearStack: r,
    clearCanvas: !1
  });
}
function iv(n) {
  var e;
  const {
    lng: t,
    lat: i
  } = n.getCenter(), r = {
    longitude: (t + 540) % 360 - 180,
    latitude: i,
    zoom: n.getZoom(),
    bearing: n.getBearing(),
    pitch: n.getPitch(),
    padding: n.getPadding(),
    repeat: n.getRenderWorldCopies()
  };
  return (e = n.getTerrain) !== null && e !== void 0 && e.call(n) && e8(n, r), r;
}
function e8(n, e) {
  if (n.getFreeCameraOptions) {
    const {
      position: t
    } = n.getFreeCameraOptions();
    if (!t || t.z === void 0)
      return;
    const i = n.transform.height, {
      longitude: r,
      latitude: s,
      pitch: c
    } = e, l = t.x * p_, m = (1 - t.y) * p_, y = t.z * p_, A = mp([r, s]), T = l - A[0], I = m - A[1], L = Math.sqrt(T * T + I * I), N = c * WN, z = 1.5 * i, V = N < 1e-3 ? z * Math.cos(N) / y : z * Math.sin(N) / L;
    e.zoom = Math.log2(V);
    const H = z * Math.cos(N) / V, J = y - H;
    e.position = [0, 0, J / Wg(s)];
  } else
    typeof n.transform.elevation == "number" && (e.position = [0, 0, n.transform.elevation]);
}
function hS(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  return new Nh({
    id: "mapbox",
    x: 0,
    y: 0,
    width: n.width,
    height: n.height,
    ...iv(e),
    nearZMultiplier: t ? 0.02 : 0.1,
    nearZ: e.transform._nearZ / e.transform.height,
    farZ: e.transform._farZ / e.transform.height
  });
}
function t8(n, e) {
  const {
    mapboxLayers: t,
    isExternal: i
  } = n.userData;
  if (i) {
    const r = Array.from(t, (A) => A.id), c = Fm(n.props.layers, Boolean).some((A) => A && !r.includes(A.id));
    let l = n.getViewports();
    const m = l.findIndex((A) => A.id === "mapbox"), y = l.length > 1 || m < 0;
    (c || y) && (m >= 0 && (l = l.slice(), l[m] = hS(n, e, !1)), n._drawLayers("mapbox-repaint", {
      viewports: l,
      layerFilter: (A) => (!n.props.layerFilter || n.props.layerFilter(A)) && (A.viewport.id !== "mapbox" || !r.includes(A.layer.id)),
      clearCanvas: !1
    }));
  }
  n.userData.currentViewport = null;
}
function n8(n, e) {
  n.setProps({
    viewState: iv(e)
  }), n.needsRedraw({
    clearRedrawFlags: !0
  });
}
function rv(n) {
  if (n.userData.isExternal)
    return;
  const e = [];
  n.userData.mapboxLayers.forEach((t) => {
    const i = t.props.type, r = new i(t.props);
    e.push(r);
  }), n.setProps({
    layers: e
  });
}
class i8 {
  constructor(e) {
    if (G(this, "id", void 0), G(this, "type", void 0), G(this, "renderingMode", void 0), G(this, "map", void 0), G(this, "deck", void 0), G(this, "props", void 0), !e.id)
      throw new Error("Layer must have an unique id");
    this.id = e.id, this.type = "custom", this.renderingMode = e.renderingMode || "3d", this.map = null, this.deck = null, this.props = e;
  }
  onAdd(e, t) {
    this.map = e, this.deck = XN({
      map: e,
      gl: t,
      deck: this.props.deck
    }), ZN(this.deck, this);
  }
  onRemove() {
    this.deck && YN(this.deck, this);
  }
  setProps(e) {
    Object.assign(this.props, e, {
      id: this.id
    }), this.deck && KN(this.deck);
  }
  render() {
    QN(this.deck, this.map, this);
  }
}
const r8 = `#define SHADER_NAME point-cloud-layer-vertex-shader

attribute vec3 positions;
attribute vec3 instanceNormals;
attribute vec4 instanceColors;
attribute vec3 instancePositions;
attribute vec3 instancePositions64Low;
attribute vec3 instancePickingColors;

uniform float opacity;
uniform float radiusPixels;
uniform int sizeUnits;

varying vec4 vColor;
varying vec2 unitPosition;

void main(void) {
  geometry.worldPosition = instancePositions;
  geometry.normal = project_normal(instanceNormals);
  unitPosition = positions.xy;
  geometry.uv = unitPosition;
  geometry.pickingColor = instancePickingColors;
  vec3 offset = vec3(positions.xy * project_size_to_pixel(radiusPixels, sizeUnits), 0.0);
  DECKGL_FILTER_SIZE(offset, geometry);

  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
  vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);
  vColor = vec4(lightColor, instanceColors.a * opacity);
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`, s8 = `#define SHADER_NAME point-cloud-layer-fragment-shader

precision highp float;

varying vec4 vColor;
varying vec2 unitPosition;

void main(void) {
  geometry.uv = unitPosition;

  float distToCenter = length(unitPosition);

  if (distToCenter > 1.0) {
    discard;
  }

  gl_FragColor = vColor;
  DECKGL_FILTER_COLOR(gl_FragColor, geometry);
}
`, dS = [0, 0, 0, 255], fS = [0, 0, 1], o8 = {
  sizeUnits: "pixels",
  pointSize: {
    type: "number",
    min: 0,
    value: 10
  },
  getPosition: {
    type: "accessor",
    value: (n) => n.position
  },
  getNormal: {
    type: "accessor",
    value: fS
  },
  getColor: {
    type: "accessor",
    value: dS
  },
  material: !0,
  radiusPixels: {
    deprecatedFor: "pointSize"
  }
};
function a8(n) {
  const {
    header: e,
    attributes: t
  } = n;
  !e || !t || (n.length = e.vertexCount, t.POSITION && (t.instancePositions = t.POSITION), t.NORMAL && (t.instanceNormals = t.NORMAL), t.COLOR_0 && (t.instanceColors = t.COLOR_0));
}
class sv extends ef {
  getShaders() {
    return super.getShaders({
      vs: r8,
      fs: s8,
      modules: [J1, IO, $1]
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: !0,
        accessor: "getPosition"
      },
      instanceNormals: {
        size: 3,
        transition: !0,
        accessor: "getNormal",
        defaultValue: fS
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: !0,
        transition: !0,
        accessor: "getColor",
        defaultValue: dS
      }
    });
  }
  updateState(e) {
    const {
      changeFlags: t,
      props: i
    } = e;
    if (super.updateState(e), t.extensionsChanged) {
      var r;
      const {
        gl: s
      } = this.context;
      (r = this.state.model) === null || r === void 0 || r.delete(), this.state.model = this._getModel(s), this.getAttributeManager().invalidateAll();
    }
    t.dataChanged && a8(i.data);
  }
  draw(e) {
    let {
      uniforms: t
    } = e;
    const {
      pointSize: i,
      sizeUnits: r
    } = this.props;
    this.state.model.setUniforms(t).setUniforms({
      sizeUnits: ay[r],
      radiusPixels: i
    }).draw();
  }
  _getModel(e) {
    const t = [];
    for (let i = 0; i < 3; i++) {
      const r = i / 3 * Math.PI * 2;
      t.push(Math.cos(r) * 2, Math.sin(r) * 2, 0);
    }
    return new Hd(e, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: new op({
        drawMode: 4,
        attributes: {
          positions: new Float32Array(t)
        }
      }),
      isInstanced: !0
    });
  }
}
G(sv, "layerName", "PointCloudLayer");
G(sv, "defaultProps", o8);
const da = {
  OUTSIDE: -1,
  INTERSECTING: 0,
  INSIDE: 1
};
new Qe();
new Qe();
const Uf = new Qe(), dw = new Qe();
class Np {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [0, 0, 0], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    G(this, "center", void 0), G(this, "radius", void 0), this.radius = -0, this.center = new Qe(), this.fromCenterRadius(e, t);
  }
  fromCenterRadius(e, t) {
    return this.center.from(e), this.radius = t, this;
  }
  fromCornerPoints(e, t) {
    return t = Uf.from(t), this.center = new Qe().from(e).add(t).scale(0.5), this.radius = this.center.distance(t), this;
  }
  equals(e) {
    return this === e || !!e && this.center.equals(e.center) && this.radius === e.radius;
  }
  clone() {
    return new Np(this.center, this.radius);
  }
  union(e) {
    const t = this.center, i = this.radius, r = e.center, s = e.radius, c = Uf.copy(r).subtract(t), l = c.magnitude();
    if (i >= l + s)
      return this.clone();
    if (s >= l + i)
      return e.clone();
    const m = (i + l + s) * 0.5;
    return dw.copy(c).scale((-i + m) / l).add(t), this.center.copy(dw), this.radius = m, this;
  }
  expand(e) {
    const i = Uf.from(e).subtract(this.center).magnitude();
    return i > this.radius && (this.radius = i), this;
  }
  transform(e) {
    this.center.transform(e);
    const t = F6(Uf, e);
    return this.radius = Math.max(t[0], Math.max(t[1], t[2])) * this.radius, this;
  }
  distanceSquaredTo(e) {
    const t = this.distanceTo(e);
    return t * t;
  }
  distanceTo(e) {
    const i = Uf.from(e).subtract(this.center);
    return Math.max(0, i.len() - this.radius);
  }
  intersectPlane(e) {
    const t = this.center, i = this.radius, s = e.normal.dot(t) + e.distance;
    return s < -i ? da.OUTSIDE : s < i ? da.INTERSECTING : da.INSIDE;
  }
}
const l8 = new Qe(), c8 = new Qe(), Sg = new Qe(), Tg = new Qe(), Cg = new Qe(), u8 = new Qe(), h8 = new Qe(), Vc = {
  COLUMN0ROW0: 0,
  COLUMN0ROW1: 1,
  COLUMN0ROW2: 2,
  COLUMN1ROW0: 3,
  COLUMN1ROW1: 4,
  COLUMN1ROW2: 5,
  COLUMN2ROW0: 6,
  COLUMN2ROW1: 7,
  COLUMN2ROW2: 8
};
class zp {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [0, 0, 0], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0, 0, 0, 0, 0, 0, 0];
    G(this, "center", void 0), G(this, "halfAxes", void 0), this.center = new Qe().from(e), this.halfAxes = new Ir(t);
  }
  get halfSize() {
    const e = this.halfAxes.getColumn(0), t = this.halfAxes.getColumn(1), i = this.halfAxes.getColumn(2);
    return [new Qe(e).len(), new Qe(t).len(), new Qe(i).len()];
  }
  get quaternion() {
    const e = this.halfAxes.getColumn(0), t = this.halfAxes.getColumn(1), i = this.halfAxes.getColumn(2), r = new Qe(e).normalize(), s = new Qe(t).normalize(), c = new Qe(i).normalize();
    return new pp().fromMatrix3(new Ir([...r, ...s, ...c]));
  }
  fromCenterHalfSizeQuaternion(e, t, i) {
    const r = new pp(i), s = new Ir().fromQuaternion(r);
    return s[0] = s[0] * t[0], s[1] = s[1] * t[0], s[2] = s[2] * t[0], s[3] = s[3] * t[1], s[4] = s[4] * t[1], s[5] = s[5] * t[1], s[6] = s[6] * t[2], s[7] = s[7] * t[2], s[8] = s[8] * t[2], this.center = new Qe().from(e), this.halfAxes = s, this;
  }
  clone() {
    return new zp(this.center, this.halfAxes);
  }
  equals(e) {
    return this === e || !!e && this.center.equals(e.center) && this.halfAxes.equals(e.halfAxes);
  }
  getBoundingSphere() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new Np();
    const t = this.halfAxes, i = t.getColumn(0, Sg), r = t.getColumn(1, Tg), s = t.getColumn(2, Cg), c = l8.copy(i).add(r).add(s);
    return e.center.copy(this.center), e.radius = c.magnitude(), e;
  }
  intersectPlane(e) {
    const t = this.center, i = e.normal, r = this.halfAxes, s = i.x, c = i.y, l = i.z, m = Math.abs(s * r[Vc.COLUMN0ROW0] + c * r[Vc.COLUMN0ROW1] + l * r[Vc.COLUMN0ROW2]) + Math.abs(s * r[Vc.COLUMN1ROW0] + c * r[Vc.COLUMN1ROW1] + l * r[Vc.COLUMN1ROW2]) + Math.abs(s * r[Vc.COLUMN2ROW0] + c * r[Vc.COLUMN2ROW1] + l * r[Vc.COLUMN2ROW2]), y = i.dot(t) + e.distance;
    return y <= -m ? da.OUTSIDE : y >= m ? da.INSIDE : da.INTERSECTING;
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceSquaredTo(e));
  }
  distanceSquaredTo(e) {
    const t = c8.from(e).subtract(this.center), i = this.halfAxes, r = i.getColumn(0, Sg), s = i.getColumn(1, Tg), c = i.getColumn(2, Cg), l = r.magnitude(), m = s.magnitude(), y = c.magnitude();
    r.normalize(), s.normalize(), c.normalize();
    let A = 0, T;
    return T = Math.abs(t.dot(r)) - l, T > 0 && (A += T * T), T = Math.abs(t.dot(s)) - m, T > 0 && (A += T * T), T = Math.abs(t.dot(c)) - y, T > 0 && (A += T * T), A;
  }
  computePlaneDistances(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [-0, -0], r = Number.POSITIVE_INFINITY, s = Number.NEGATIVE_INFINITY;
    const c = this.center, l = this.halfAxes, m = l.getColumn(0, Sg), y = l.getColumn(1, Tg), A = l.getColumn(2, Cg), T = u8.copy(m).add(y).add(A).add(c), I = h8.copy(T).subtract(e);
    let L = t.dot(I);
    return r = Math.min(L, r), s = Math.max(L, s), T.copy(c).add(m).add(y).subtract(A), I.copy(T).subtract(e), L = t.dot(I), r = Math.min(L, r), s = Math.max(L, s), T.copy(c).add(m).subtract(y).add(A), I.copy(T).subtract(e), L = t.dot(I), r = Math.min(L, r), s = Math.max(L, s), T.copy(c).add(m).subtract(y).subtract(A), I.copy(T).subtract(e), L = t.dot(I), r = Math.min(L, r), s = Math.max(L, s), c.copy(T).subtract(m).add(y).add(A), I.copy(T).subtract(e), L = t.dot(I), r = Math.min(L, r), s = Math.max(L, s), c.copy(T).subtract(m).add(y).subtract(A), I.copy(T).subtract(e), L = t.dot(I), r = Math.min(L, r), s = Math.max(L, s), c.copy(T).subtract(m).subtract(y).add(A), I.copy(T).subtract(e), L = t.dot(I), r = Math.min(L, r), s = Math.max(L, s), c.copy(T).subtract(m).subtract(y).subtract(A), I.copy(T).subtract(e), L = t.dot(I), r = Math.min(L, r), s = Math.max(L, s), i[0] = r, i[1] = s, i;
  }
  transform(e) {
    this.center.transformAsPoint(e);
    const t = this.halfAxes.getColumn(0, Sg);
    t.transformAsPoint(e);
    const i = this.halfAxes.getColumn(1, Tg);
    i.transformAsPoint(e);
    const r = this.halfAxes.getColumn(2, Cg);
    return r.transformAsPoint(e), this.halfAxes = new Ir([...t, ...i, ...r]), this;
  }
  getTransform() {
    throw new Error("not implemented");
  }
}
const fw = new Qe(), pw = new Qe();
class Al {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [0, 0, 1], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    G(this, "normal", void 0), G(this, "distance", void 0), this.normal = new Qe(), this.distance = -0, this.fromNormalDistance(e, t);
  }
  fromNormalDistance(e, t) {
    return El(Number.isFinite(t)), this.normal.from(e).normalize(), this.distance = t, this;
  }
  fromPointNormal(e, t) {
    e = fw.from(e), this.normal.from(t).normalize();
    const i = -this.normal.dot(e);
    return this.distance = i, this;
  }
  fromCoefficients(e, t, i, r) {
    return this.normal.set(e, t, i), El(Il(this.normal.len(), 1)), this.distance = r, this;
  }
  clone() {
    return new Al(this.normal, this.distance);
  }
  equals(e) {
    return Il(this.distance, e.distance) && Il(this.normal, e.normal);
  }
  getPointDistance(e) {
    return this.normal.dot(e) + this.distance;
  }
  transform(e) {
    const t = pw.copy(this.normal).transformAsVector(e).normalize(), i = this.normal.scale(-this.distance).transform(e);
    return this.fromPointNormal(i, t);
  }
  projectPointOntoPlane(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    e = fw.from(e);
    const i = this.getPointDistance(e), r = pw.copy(this.normal).scale(i);
    return e.subtract(r).to(t);
  }
}
const gw = [new Qe([1, 0, 0]), new Qe([0, 1, 0]), new Qe([0, 0, 1])], mw = new Qe(), d8 = new Qe();
new Al(new Qe(1, 0, 0), 0);
class Xa {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    G(this, "planes", void 0), this.planes = e;
  }
  fromBoundingSphere(e) {
    this.planes.length = 2 * gw.length;
    const t = e.center, i = e.radius;
    let r = 0;
    for (const s of gw) {
      let c = this.planes[r], l = this.planes[r + 1];
      c || (c = this.planes[r] = new Al()), l || (l = this.planes[r + 1] = new Al());
      const m = mw.copy(s).scale(-i).add(t);
      -s.dot(m), c.fromPointNormal(m, s);
      const y = mw.copy(s).scale(i).add(t), A = d8.copy(s).negate();
      -A.dot(y), l.fromPointNormal(y, A), r += 2;
    }
    return this;
  }
  computeVisibility(e) {
    let t = da.INSIDE;
    for (const i of this.planes)
      switch (e.intersectPlane(i)) {
        case da.OUTSIDE:
          return da.OUTSIDE;
        case da.INTERSECTING:
          t = da.INTERSECTING;
          break;
      }
    return t;
  }
  computeVisibilityWithPlaneMask(e, t) {
    if (El(Number.isFinite(t), "parentPlaneMask is required."), t === Xa.MASK_OUTSIDE || t === Xa.MASK_INSIDE)
      return t;
    let i = Xa.MASK_INSIDE;
    const r = this.planes;
    for (let s = 0; s < this.planes.length; ++s) {
      const c = s < 31 ? 1 << s : 0;
      if (s < 31 && !(t & c))
        continue;
      const l = r[s], m = e.intersectPlane(l);
      if (m === da.OUTSIDE)
        return Xa.MASK_OUTSIDE;
      m === da.INTERSECTING && (i |= c);
    }
    return i;
  }
}
G(Xa, "MASK_OUTSIDE", 4294967295);
G(Xa, "MASK_INSIDE", 0);
G(Xa, "MASK_INDETERMINATE", 2147483647);
new Qe();
new Qe();
new Qe();
new Qe();
new Qe();
new Qe();
new Qe();
new Qe();
new Qe();
new Qe();
new Qe();
new Qe();
new Qe();
new Qe();
new Qe();
new Qe();
new Qe();
const oc = new Ir(), f8 = new Ir(), p8 = new Ir(), Ig = new Ir(), _w = new Ir();
function g8(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = gp.EPSILON20, i = 10;
  let r = 0, s = 0;
  const c = f8, l = p8;
  c.identity(), l.copy(n);
  const m = t * m8(l);
  for (; s < i && _8(l) > m; )
    y8(l, Ig), _w.copy(Ig).transpose(), l.multiplyRight(Ig), l.multiplyLeft(_w), c.multiplyRight(Ig), ++r > 2 && (++s, r = 0);
  return e.unitary = c.toTarget(e.unitary), e.diagonal = l.toTarget(e.diagonal), e;
}
function m8(n) {
  let e = 0;
  for (let t = 0; t < 9; ++t) {
    const i = n[t];
    e += i * i;
  }
  return Math.sqrt(e);
}
const Ly = [1, 0, 0], My = [2, 2, 1];
function _8(n) {
  let e = 0;
  for (let t = 0; t < 3; ++t) {
    const i = n[oc.getElementIndex(My[t], Ly[t])];
    e += 2 * i * i;
  }
  return Math.sqrt(e);
}
function y8(n, e) {
  const t = gp.EPSILON15;
  let i = 0, r = 1;
  for (let y = 0; y < 3; ++y) {
    const A = Math.abs(n[oc.getElementIndex(My[y], Ly[y])]);
    A > i && (r = y, i = A);
  }
  const s = Ly[r], c = My[r];
  let l = 1, m = 0;
  if (Math.abs(n[oc.getElementIndex(c, s)]) > t) {
    const y = n[oc.getElementIndex(c, c)], A = n[oc.getElementIndex(s, s)], T = n[oc.getElementIndex(c, s)], I = (y - A) / 2 / T;
    let L;
    I < 0 ? L = -1 / (-I + Math.sqrt(1 + I * I)) : L = 1 / (I + Math.sqrt(1 + I * I)), l = 1 / Math.sqrt(1 + L * L), m = L * l;
  }
  return Ir.IDENTITY.to(e), e[oc.getElementIndex(s, s)] = e[oc.getElementIndex(c, c)] = l, e[oc.getElementIndex(c, s)] = m, e[oc.getElementIndex(s, c)] = -m, e;
}
const Du = new Qe(), v8 = new Qe(), b8 = new Qe(), x8 = new Qe(), w8 = new Qe(), A8 = new Ir(), E8 = {
  diagonal: new Ir(),
  unitary: new Ir()
};
function S8(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new zp();
  if (!n || n.length === 0)
    return e.halfAxes = new Ir([0, 0, 0, 0, 0, 0, 0, 0, 0]), e.center = new Qe(), e;
  const t = n.length, i = new Qe(0, 0, 0);
  for (const Ve of n)
    i.add(Ve);
  const r = 1 / t;
  i.multiplyByScalar(r);
  let s = 0, c = 0, l = 0, m = 0, y = 0, A = 0;
  for (const Ve of n) {
    const Fe = Du.copy(Ve).subtract(i);
    s += Fe.x * Fe.x, c += Fe.x * Fe.y, l += Fe.x * Fe.z, m += Fe.y * Fe.y, y += Fe.y * Fe.z, A += Fe.z * Fe.z;
  }
  s *= r, c *= r, l *= r, m *= r, y *= r, A *= r;
  const T = A8;
  T[0] = s, T[1] = c, T[2] = l, T[3] = c, T[4] = m, T[5] = y, T[6] = l, T[7] = y, T[8] = A;
  const {
    unitary: I
  } = g8(T, E8), L = e.halfAxes.copy(I);
  let N = L.getColumn(0, b8), z = L.getColumn(1, x8), V = L.getColumn(2, w8), H = -Number.MAX_VALUE, J = -Number.MAX_VALUE, ce = -Number.MAX_VALUE, me = Number.MAX_VALUE, Se = Number.MAX_VALUE, De = Number.MAX_VALUE;
  for (const Ve of n)
    Du.copy(Ve), H = Math.max(Du.dot(N), H), J = Math.max(Du.dot(z), J), ce = Math.max(Du.dot(V), ce), me = Math.min(Du.dot(N), me), Se = Math.min(Du.dot(z), Se), De = Math.min(Du.dot(V), De);
  N = N.multiplyByScalar(0.5 * (me + H)), z = z.multiplyByScalar(0.5 * (Se + J)), V = V.multiplyByScalar(0.5 * (De + ce)), e.center.copy(N).add(z).add(V);
  const Le = v8.set(H - me, J - Se, ce - De).multiplyByScalar(0.5), ye = new Ir([Le[0], 0, 0, 0, Le[1], 0, 0, 0, Le[2]]);
  return e.halfAxes.multiplyRight(ye), e;
}
const g_ = Math.PI / 180, Pg = new Float32Array(16), yw = new Float32Array(12);
function vw(n, e, t) {
  const i = e[0] * g_, r = e[1] * g_, s = e[2] * g_, c = Math.sin(s), l = Math.sin(i), m = Math.sin(r), y = Math.cos(s), A = Math.cos(i), T = Math.cos(r), I = t[0], L = t[1], N = t[2];
  n[0] = I * T * A, n[1] = I * m * A, n[2] = I * -l, n[3] = L * (-m * y + T * l * c), n[4] = L * (T * y + m * l * c), n[5] = L * A * c, n[6] = N * (m * c + T * l * y), n[7] = N * (-T * c + m * l * y), n[8] = N * A * y;
}
function bw(n) {
  return n[0] = n[0], n[1] = n[1], n[2] = n[2], n[3] = n[4], n[4] = n[5], n[5] = n[6], n[6] = n[8], n[7] = n[9], n[8] = n[10], n[9] = n[12], n[10] = n[13], n[11] = n[14], n.subarray(0, 12);
}
const pS = {
  size: 12,
  accessor: ["getOrientation", "getScale", "getTranslation", "getTransformMatrix"],
  shaderAttributes: {
    instanceModelMatrix__LOCATION_0: {
      size: 3,
      elementOffset: 0
    },
    instanceModelMatrix__LOCATION_1: {
      size: 3,
      elementOffset: 3
    },
    instanceModelMatrix__LOCATION_2: {
      size: 3,
      elementOffset: 6
    },
    instanceTranslation: {
      size: 3,
      elementOffset: 9
    }
  },
  update(n, e) {
    let {
      startRow: t,
      endRow: i
    } = e;
    const {
      data: r,
      getOrientation: s,
      getScale: c,
      getTranslation: l,
      getTransformMatrix: m
    } = this.props, y = Array.isArray(m), A = y && m.length === 16, T = Array.isArray(c), I = Array.isArray(s), L = Array.isArray(l), N = A || !y && !!m(r[0]);
    N ? n.constant = A : n.constant = I && T && L;
    const z = n.value;
    if (n.constant) {
      let V;
      N ? (Pg.set(m), V = bw(Pg)) : (V = yw, vw(V, s, c), V.set(l, 9)), n.value = new Float32Array(V);
    } else {
      let V = t * n.size;
      const {
        iterable: H,
        objectInfo: J
      } = tS(r, t, i);
      for (const ce of H) {
        J.index++;
        let me;
        if (N)
          Pg.set(A ? m : m(ce, J)), me = bw(Pg);
        else {
          me = yw;
          const Se = I ? s : s(ce, J), De = T ? c : c(ce, J);
          vw(me, Se, De), me.set(L ? l : l(ce, J), 9);
        }
        z[V++] = me[0], z[V++] = me[1], z[V++] = me[2], z[V++] = me[3], z[V++] = me[4], z[V++] = me[5], z[V++] = me[6], z[V++] = me[7], z[V++] = me[8], z[V++] = me[9], z[V++] = me[10], z[V++] = me[11];
      }
    }
  }
};
function gS(n, e) {
  return e === li.CARTESIAN || e === li.METER_OFFSETS || e === li.DEFAULT && !n.isGeospatial;
}
const T8 = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs
uniform float sizeScale;
uniform bool composeModelMatrix;
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in mat3 instanceModelMatrix;
in vec3 instanceTranslation;
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;

void main(void) {
  geometry.worldPosition = instancePositions;
  geometry.uv = texCoords;
  geometry.pickingColor = instancePickingColors;

  vTexCoord = texCoords;
  cameraPosition = project_uCameraPosition;
  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);

  vec3 pos = (instanceModelMatrix * positions) * sizeScale + instanceTranslation;

  if (composeModelMatrix) {
    DECKGL_FILTER_SIZE(pos, geometry);
    normals_commonspace = project_normal(instanceModelMatrix * normals);
    geometry.worldPosition += pos;
    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);
    geometry.position = position_commonspace;
  }
  else {
    pos = project_size(pos);
    DECKGL_FILTER_SIZE(pos, geometry);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);
    geometry.position = position_commonspace;
    normals_commonspace = project_normal(instanceModelMatrix * normals);
  }

  geometry.normal = normals_commonspace;
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  DECKGL_FILTER_COLOR(vColor, geometry);
}
`, C8 = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs

precision highp float;

uniform bool hasTexture;
uniform sampler2D sampler;
uniform bool flatShading;
uniform float opacity;

in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;

out vec4 fragColor;

void main(void) {
  geometry.uv = vTexCoord;

  vec3 normal;
  if (flatShading) {
#ifdef DERIVATIVES_AVAILABLE
    normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
#else
    normal = vec3(0.0, 0.0, 1.0);
#endif
  } else {
    normal = normals_commonspace;
  }

  vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;
  DECKGL_FILTER_COLOR(color, geometry);

  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
  fragColor = vec4(lightColor, color.a * opacity);
}
`;
function mS(n) {
  let e = 1 / 0, t = 1 / 0, i = 1 / 0, r = -1 / 0, s = -1 / 0, c = -1 / 0;
  const l = n.POSITION ? n.POSITION.value : [], m = l && l.length;
  for (let y = 0; y < m; y += 3) {
    const A = l[y], T = l[y + 1], I = l[y + 2];
    e = A < e ? A : e, t = T < t ? T : t, i = I < i ? I : i, r = A > r ? A : r, s = T > s ? T : s, c = I > c ? I : c;
  }
  return [[e, t, i], [r, s, c]];
}
function I8(n, e) {
  if (!n)
    throw new Error("loader assertion failed.");
}
class Cd {
  constructor(e, t) {
    G(this, "fields", void 0), G(this, "metadata", void 0), I8(Array.isArray(e)), P8(e), this.fields = e, this.metadata = t || /* @__PURE__ */ new Map();
  }
  compareTo(e) {
    if (this.metadata !== e.metadata || this.fields.length !== e.fields.length)
      return !1;
    for (let t = 0; t < this.fields.length; ++t)
      if (!this.fields[t].compareTo(e.fields[t]))
        return !1;
    return !0;
  }
  select() {
    const e = /* @__PURE__ */ Object.create(null);
    for (var t = arguments.length, i = new Array(t), r = 0; r < t; r++)
      i[r] = arguments[r];
    for (const c of i)
      e[c] = !0;
    const s = this.fields.filter((c) => e[c.name]);
    return new Cd(s, this.metadata);
  }
  selectAt() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    const r = t.map((s) => this.fields[s]).filter(Boolean);
    return new Cd(r, this.metadata);
  }
  assign(e) {
    let t, i = this.metadata;
    if (e instanceof Cd) {
      const c = e;
      t = c.fields, i = xw(xw(/* @__PURE__ */ new Map(), this.metadata), c.metadata);
    } else
      t = e;
    const r = /* @__PURE__ */ Object.create(null);
    for (const c of this.fields)
      r[c.name] = c;
    for (const c of t)
      r[c.name] = c;
    const s = Object.values(r);
    return new Cd(s, i);
  }
}
function P8(n) {
  const e = {};
  for (const t of n)
    e[t.name] && console.warn("Schema: duplicated field name", t.name, t), e[t.name] = !0;
}
function xw(n, e) {
  return new Map([...n || /* @__PURE__ */ new Map(), ...e || /* @__PURE__ */ new Map()]);
}
class Am {
  constructor(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : /* @__PURE__ */ new Map();
    G(this, "name", void 0), G(this, "type", void 0), G(this, "nullable", void 0), G(this, "metadata", void 0), this.name = e, this.type = t, this.nullable = i, this.metadata = r;
  }
  get typeId() {
    return this.type && this.type.typeId;
  }
  clone() {
    return new Am(this.name, this.type, this.nullable, this.metadata);
  }
  compareTo(e) {
    return this.name === e.name && this.type === e.type && this.nullable === e.nullable && this.metadata === e.metadata;
  }
  toString() {
    return "".concat(this.type).concat(this.nullable ? ", nullable" : "").concat(this.metadata ? ", metadata: ".concat(this.metadata) : "");
  }
}
let Tr = function(n) {
  return n[n.NONE = 0] = "NONE", n[n.Null = 1] = "Null", n[n.Int = 2] = "Int", n[n.Float = 3] = "Float", n[n.Binary = 4] = "Binary", n[n.Utf8 = 5] = "Utf8", n[n.Bool = 6] = "Bool", n[n.Decimal = 7] = "Decimal", n[n.Date = 8] = "Date", n[n.Time = 9] = "Time", n[n.Timestamp = 10] = "Timestamp", n[n.Interval = 11] = "Interval", n[n.List = 12] = "List", n[n.Struct = 13] = "Struct", n[n.Union = 14] = "Union", n[n.FixedSizeBinary = 15] = "FixedSizeBinary", n[n.FixedSizeList = 16] = "FixedSizeList", n[n.Map = 17] = "Map", n[n.Dictionary = -1] = "Dictionary", n[n.Int8 = -2] = "Int8", n[n.Int16 = -3] = "Int16", n[n.Int32 = -4] = "Int32", n[n.Int64 = -5] = "Int64", n[n.Uint8 = -6] = "Uint8", n[n.Uint16 = -7] = "Uint16", n[n.Uint32 = -8] = "Uint32", n[n.Uint64 = -9] = "Uint64", n[n.Float16 = -10] = "Float16", n[n.Float32 = -11] = "Float32", n[n.Float64 = -12] = "Float64", n[n.DateDay = -13] = "DateDay", n[n.DateMillisecond = -14] = "DateMillisecond", n[n.TimestampSecond = -15] = "TimestampSecond", n[n.TimestampMillisecond = -16] = "TimestampMillisecond", n[n.TimestampMicrosecond = -17] = "TimestampMicrosecond", n[n.TimestampNanosecond = -18] = "TimestampNanosecond", n[n.TimeSecond = -19] = "TimeSecond", n[n.TimeMillisecond = -20] = "TimeMillisecond", n[n.TimeMicrosecond = -21] = "TimeMicrosecond", n[n.TimeNanosecond = -22] = "TimeNanosecond", n[n.DenseUnion = -23] = "DenseUnion", n[n.SparseUnion = -24] = "SparseUnion", n[n.IntervalDayTime = -25] = "IntervalDayTime", n[n.IntervalYearMonth = -26] = "IntervalYearMonth", n;
}({}), _S, yS, vS;
class ov {
  static isNull(e) {
    return e && e.typeId === Tr.Null;
  }
  static isInt(e) {
    return e && e.typeId === Tr.Int;
  }
  static isFloat(e) {
    return e && e.typeId === Tr.Float;
  }
  static isBinary(e) {
    return e && e.typeId === Tr.Binary;
  }
  static isUtf8(e) {
    return e && e.typeId === Tr.Utf8;
  }
  static isBool(e) {
    return e && e.typeId === Tr.Bool;
  }
  static isDecimal(e) {
    return e && e.typeId === Tr.Decimal;
  }
  static isDate(e) {
    return e && e.typeId === Tr.Date;
  }
  static isTime(e) {
    return e && e.typeId === Tr.Time;
  }
  static isTimestamp(e) {
    return e && e.typeId === Tr.Timestamp;
  }
  static isInterval(e) {
    return e && e.typeId === Tr.Interval;
  }
  static isList(e) {
    return e && e.typeId === Tr.List;
  }
  static isStruct(e) {
    return e && e.typeId === Tr.Struct;
  }
  static isUnion(e) {
    return e && e.typeId === Tr.Union;
  }
  static isFixedSizeBinary(e) {
    return e && e.typeId === Tr.FixedSizeBinary;
  }
  static isFixedSizeList(e) {
    return e && e.typeId === Tr.FixedSizeList;
  }
  static isMap(e) {
    return e && e.typeId === Tr.Map;
  }
  static isDictionary(e) {
    return e && e.typeId === Tr.Dictionary;
  }
  get typeId() {
    return Tr.NONE;
  }
  compareTo(e) {
    return this === e;
  }
}
_S = Symbol.toStringTag;
class tf extends ov {
  constructor(e, t) {
    super(), G(this, "isSigned", void 0), G(this, "bitWidth", void 0), this.isSigned = e, this.bitWidth = t;
  }
  get typeId() {
    return Tr.Int;
  }
  get [_S]() {
    return "Int";
  }
  toString() {
    return "".concat(this.isSigned ? "I" : "Ui", "nt").concat(this.bitWidth);
  }
}
class L8 extends tf {
  constructor() {
    super(!0, 8);
  }
}
class M8 extends tf {
  constructor() {
    super(!0, 16);
  }
}
class B8 extends tf {
  constructor() {
    super(!0, 32);
  }
}
class R8 extends tf {
  constructor() {
    super(!1, 8);
  }
}
class O8 extends tf {
  constructor() {
    super(!1, 16);
  }
}
class F8 extends tf {
  constructor() {
    super(!1, 32);
  }
}
const bS = {
  HALF: 16,
  SINGLE: 32,
  DOUBLE: 64
};
yS = Symbol.toStringTag;
class xS extends ov {
  constructor(e) {
    super(), G(this, "precision", void 0), this.precision = e;
  }
  get typeId() {
    return Tr.Float;
  }
  get [yS]() {
    return "Float";
  }
  toString() {
    return "Float".concat(this.precision);
  }
}
class D8 extends xS {
  constructor() {
    super(bS.SINGLE);
  }
}
class k8 extends xS {
  constructor() {
    super(bS.DOUBLE);
  }
}
vS = Symbol.toStringTag;
class N8 extends ov {
  constructor(e, t) {
    super(), G(this, "listSize", void 0), G(this, "children", void 0), this.listSize = e, this.children = [t];
  }
  get typeId() {
    return Tr.FixedSizeList;
  }
  get valueType() {
    return this.children[0].type;
  }
  get valueField() {
    return this.children[0];
  }
  get [vS]() {
    return "FixedSizeList";
  }
  toString() {
    return "FixedSizeList[".concat(this.listSize, "]<").concat(this.valueType, ">");
  }
}
function z8(n) {
  switch (n.constructor) {
    case Int8Array:
      return new L8();
    case Uint8Array:
      return new R8();
    case Int16Array:
      return new M8();
    case Uint16Array:
      return new O8();
    case Int32Array:
      return new B8();
    case Uint32Array:
      return new F8();
    case Float32Array:
      return new D8();
    case Float64Array:
      return new k8();
    default:
      throw new Error("array type not supported");
  }
}
function U8(n, e, t) {
  const i = z8(e.value), r = t || j8(e);
  return new Am(n, new N8(e.size, new Am("value", i)), !1, r);
}
function j8(n) {
  const e = /* @__PURE__ */ new Map();
  return "byteOffset" in n && e.set("byteOffset", n.byteOffset.toString(10)), "byteStride" in n && e.set("byteStride", n.byteStride.toString(10)), "normalized" in n && e.set("normalized", n.normalized.toString()), e;
}
function ww(n, e) {
  (n.COLOR_0 || n.colors) && e || (n.colors = {
    constant: !0,
    value: new Float32Array([1, 1, 1])
  }), hi.assert(n.positions || n.POSITION, 'no "postions" or "POSITION" attribute in mesh');
}
function Aw(n, e) {
  if (n.attributes)
    return ww(n.attributes, e), n instanceof op ? n : new op(n);
  if (n.positions || n.POSITION)
    return ww(n, e), new op({
      attributes: n
    });
  throw Error("Invalid mesh");
}
const G8 = [0, 0, 0, 255], V8 = {
  mesh: {
    type: "object",
    value: null,
    async: !0
  },
  texture: {
    type: "image",
    value: null,
    async: !0
  },
  sizeScale: {
    type: "number",
    value: 1,
    min: 0
  },
  _useMeshColors: {
    type: "boolean",
    value: !1
  },
  _instanced: !0,
  wireframe: !1,
  material: !0,
  getPosition: {
    type: "accessor",
    value: (n) => n.position
  },
  getColor: {
    type: "accessor",
    value: G8
  },
  getOrientation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  getScale: {
    type: "accessor",
    value: [1, 1, 1]
  },
  getTranslation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  getTransformMatrix: {
    type: "accessor",
    value: []
  },
  textureParameters: {
    type: "object",
    ignore: !0
  }
};
class av extends ef {
  constructor() {
    super(...arguments), G(this, "state", void 0);
  }
  getShaders() {
    const e = !ei(this.context.gl), t = {};
    return I1(this.context.gl, rr.GLSL_DERIVATIVES) && (t.DERIVATIVES_AVAILABLE = 1), super.getShaders({
      vs: T8,
      fs: C8,
      modules: [J1, PO, $1],
      transpileToGLSL100: e,
      defines: t
    });
  }
  getBounds() {
    var e;
    if (this.props._instanced)
      return super.getBounds();
    let t = this.state.positionBounds;
    if (t)
      return t;
    const {
      mesh: i
    } = this.props;
    if (!i)
      return null;
    if (t = (e = i.header) === null || e === void 0 ? void 0 : e.boundingBox, !t) {
      const {
        attributes: r
      } = Aw(i, this.props._useMeshColors);
      r.POSITION = r.POSITION || r.positions, t = mS(r);
    }
    return this.state.positionBounds = t, t;
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        transition: !0,
        type: 5130,
        fp64: this.use64bitPositions(),
        size: 3,
        accessor: "getPosition"
      },
      instanceColors: {
        type: 5121,
        transition: !0,
        size: this.props.colorFormat.length,
        normalized: !0,
        accessor: "getColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceModelMatrix: pS
    }), this.setState({
      emptyTexture: new ga(this.context.gl, {
        data: new Uint8Array(4),
        width: 1,
        height: 1
      })
    });
  }
  updateState(e) {
    super.updateState(e);
    const {
      props: t,
      oldProps: i,
      changeFlags: r
    } = e;
    if (t.mesh !== i.mesh || r.extensionsChanged) {
      var s;
      if (this.state.positionBounds = null, (s = this.state.model) === null || s === void 0 || s.delete(), t.mesh) {
        this.state.model = this.getModel(t.mesh);
        const c = t.mesh.attributes || t.mesh;
        this.setState({
          hasNormals: !!(c.NORMAL || c.normals)
        });
      }
      this.getAttributeManager().invalidateAll();
    }
    t.texture !== i.texture && this.setTexture(t.texture), this.state.model && this.state.model.setDrawMode(this.props.wireframe ? 3 : 4);
  }
  finalizeState(e) {
    super.finalizeState(e), this.state.emptyTexture.delete();
  }
  draw(e) {
    let {
      uniforms: t
    } = e;
    if (!this.state.model)
      return;
    const {
      viewport: i
    } = this.context, {
      sizeScale: r,
      coordinateSystem: s,
      _instanced: c
    } = this.props;
    this.state.model.setUniforms(t).setUniforms({
      sizeScale: r,
      composeModelMatrix: !c || gS(i, s),
      flatShading: !this.state.hasNormals
    }).draw();
  }
  get isLoaded() {
    var e;
    return ((e = this.state) === null || e === void 0 ? void 0 : e.model) && super.isLoaded;
  }
  getModel(e) {
    const t = new Hd(this.context.gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: Aw(e, this.props._useMeshColors),
      isInstanced: !0
    }), {
      texture: i
    } = this.props, {
      emptyTexture: r
    } = this.state;
    return t.setUniforms({
      sampler: i || r,
      hasTexture: !!i
    }), t;
  }
  setTexture(e) {
    const {
      emptyTexture: t,
      model: i
    } = this.state;
    i && i.setUniforms({
      sampler: e || t,
      hasTexture: !!e
    });
  }
}
G(av, "defaultProps", V8);
G(av, "layerName", "SimpleMeshLayer");
class Rd {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      id: t
    } = e;
    this.id = t || tu(this.constructor.name), this.display = !0, this.position = new Qe(), this.rotation = new Qe(), this.scale = new Qe(1, 1, 1), this.matrix = new ai(), this.userData = {}, this.props = {}, this._setScenegraphNodeProps(e);
  }
  delete() {
  }
  setProps(e) {
    return this._setScenegraphNodeProps(e), this;
  }
  toString() {
    return "{type: ScenegraphNode, id: ".concat(this.id, ")}");
  }
  getBounds() {
    return null;
  }
  setPosition(e) {
    return Yt(e.length === 3, "setPosition requires vector argument"), this.position = e, this;
  }
  setRotation(e) {
    return Yt(e.length === 3, "setRotation requires vector argument"), this.rotation = e, this;
  }
  setScale(e) {
    return Yt(e.length === 3, "setScale requires vector argument"), this.scale = e, this;
  }
  setMatrix(e) {
    (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0) ? this.matrix.copy(e) : this.matrix = e;
  }
  setMatrixComponents(e) {
    let {
      position: t,
      rotation: i,
      scale: r,
      update: s = !0
    } = e;
    return t && this.setPosition(t), i && this.setRotation(i), r && this.setScale(r), s && this.updateMatrix(), this;
  }
  updateMatrix() {
    const e = this.position, t = this.rotation, i = this.scale;
    return this.matrix.identity(), this.matrix.translate(e), this.matrix.rotateXYZ(t), this.matrix.scale(i), this;
  }
  update() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      position: t,
      rotation: i,
      scale: r
    } = e;
    return t && this.setPosition(t), i && this.setRotation(i), r && this.setScale(r), this.updateMatrix(), this;
  }
  getCoordinateUniforms(e, t) {
    Yt(e), t = t || this.matrix;
    const i = new ai(e).multiplyRight(t), r = i.invert(), s = r.transpose();
    return {
      viewMatrix: e,
      modelMatrix: t,
      objectMatrix: t,
      worldMatrix: i,
      worldInverseMatrix: r,
      worldInverseTransposeMatrix: s
    };
  }
  _setScenegraphNodeProps(e) {
    "display" in e && (this.display = e.display), "position" in e && this.setPosition(e.position), "rotation" in e && this.setRotation(e.rotation), "scale" in e && this.setScale(e.scale), "matrix" in e && this.setMatrix(e.matrix), Object.assign(this.props, e);
  }
}
class ap extends Rd {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    e = Array.isArray(e) ? {
      children: e
    } : e;
    const {
      children: t = []
    } = e;
    cn.assert(t.every((i) => i instanceof Rd), "every child must an instance of ScenegraphNode"), super(e), this.children = t;
  }
  add() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    for (const r of t)
      Array.isArray(r) ? this.add(...r) : this.children.push(r);
    return this;
  }
  remove(e) {
    const t = this.children, i = t.indexOf(e);
    return i > -1 && t.splice(i, 1), this;
  }
  removeAll() {
    return this.children = [], this;
  }
  delete() {
    this.children.forEach((e) => e.delete()), this.removeAll(), super.delete();
  }
  getBounds() {
    const e = [[1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]];
    return this.traverse((t, i) => {
      let {
        worldMatrix: r
      } = i;
      const s = t.getBounds();
      if (!s)
        return;
      const [c, l] = s, m = new Qe(c).add(l).divide([2, 2, 2]);
      r.transformAsPoint(m, m);
      const y = new Qe(l).subtract(c).divide([2, 2, 2]);
      r.transformAsVector(y, y);
      for (let A = 0; A < 8; A++) {
        const T = new Qe(A & 1 ? -1 : 1, A & 2 ? -1 : 1, A & 4 ? -1 : 1).multiply(y).add(m);
        for (let I = 0; I < 3; I++)
          e[0][I] = Math.min(e[0][I], T[I]), e[1][I] = Math.max(e[1][I], T[I]);
      }
    }), Number.isFinite(e[0][0]) ? e : null;
  }
  traverse(e) {
    let {
      worldMatrix: t = new ai()
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const i = new ai(t).multiplyRight(this.matrix);
    for (const r of this.children)
      r instanceof ap ? r.traverse(e, {
        worldMatrix: i
      }) : e(r, {
        worldMatrix: i
      });
  }
}
const q8 = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, H8 = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
function Ew(n) {
  if (!n._animation) {
    const e = H8[n.componentType], t = q8[n.type], i = t * n.count, {
      buffer: r,
      byteOffset: s
    } = n.bufferView.data, c = new e(r, s + (n.byteOffset || 0), i);
    if (t === 1)
      n._animation = Array.from(c);
    else {
      const l = [];
      for (let m = 0; m < c.length; m += t)
        l.push(Array.from(c.slice(m, m + t)));
      n._animation = l;
    }
  }
  return n._animation;
}
const W8 = new ai();
function X8(n, e) {
  if (e.matrix.identity(), n.translation && e.matrix.translate(n.translation), n.rotation) {
    const t = W8.fromQuaternion(n.rotation);
    e.matrix.multiplyRight(t);
  }
  n.scale && e.matrix.scale(n.scale);
}
const m_ = new pp();
function J8(n, e, t, i, r) {
  if (e === "rotation") {
    m_.slerp({
      start: t,
      target: i,
      ratio: r
    });
    for (let s = 0; s < m_.length; s++)
      n[e][s] = m_[s];
  } else
    for (let s = 0; s < t.length; s++)
      n[e][s] = r * i[s] + (1 - r) * t[s];
}
function $8(n, e, t) {
  let {
    p0: i,
    outTangent0: r,
    inTangent1: s,
    p1: c,
    tDiff: l,
    ratio: m
  } = t;
  for (let y = 0; y < n[e].length; y++) {
    const A = r[y] * l, T = s[y] * l;
    n[e][y] = (2 * Math.pow(m, 3) - 3 * Math.pow(m, 2) + 1) * i[y] + (Math.pow(m, 3) - 2 * Math.pow(m, 2) + m) * A + (-2 * Math.pow(m, 3) + 3 * Math.pow(m, 2)) * c[y] + (Math.pow(m, 3) - Math.pow(m, 2)) * T;
  }
}
function Z8(n, e, t) {
  for (let i = 0; i < t.length; i++)
    n[e][i] = t[i];
}
function Y8(n, e, t, i) {
  let {
    input: r,
    interpolation: s,
    output: c
  } = e;
  const l = r[r.length - 1], m = n % l, y = r.findIndex((L) => L >= m), A = Math.max(0, y - 1);
  if (!Array.isArray(t[i]))
    switch (i) {
      case "translation":
        t[i] = [0, 0, 0];
        break;
      case "rotation":
        t[i] = [0, 0, 0, 1];
        break;
      case "scale":
        t[i] = [1, 1, 1];
        break;
      default:
        cn.warn("Bad animation path ".concat(i))();
    }
  Yt(t[i].length === c[A].length);
  const T = r[A], I = r[y];
  switch (s) {
    case "STEP":
      Z8(t, i, c[A]);
      break;
    case "LINEAR":
      if (I > T) {
        const L = (m - T) / (I - T);
        J8(t, i, c[A], c[y], L);
      }
      break;
    case "CUBICSPLINE":
      if (I > T) {
        const L = (m - T) / (I - T), N = I - T, z = c[3 * A + 1], V = c[3 * A + 2], H = c[3 * y + 0], J = c[3 * y + 1];
        $8(t, i, {
          p0: z,
          outTangent0: V,
          inTangent1: H,
          p1: J,
          tDiff: N,
          ratio: L
        });
      }
      break;
    default:
      cn.warn("Interpolation ".concat(s, " not supported"))();
      break;
  }
}
class K8 {
  constructor(e) {
    this.startTime = 0, this.playing = !0, this.speed = 1, this.channels = [], Object.assign(this, e);
  }
  animate(e) {
    if (!this.playing)
      return;
    const i = (e / 1e3 - this.startTime) * this.speed;
    this.channels.forEach((r) => {
      let {
        sampler: s,
        target: c,
        path: l
      } = r;
      Y8(i, s, c, l), X8(c, c._node);
    });
  }
}
class Q8 {
  constructor(e) {
    this.animations = e.animations.map((t, i) => {
      const r = t.name || "Animation-".concat(i), s = t.samplers.map((l) => {
        let {
          input: m,
          interpolation: y = "LINEAR",
          output: A
        } = l;
        return {
          input: Ew(e.accessors[m]),
          interpolation: y,
          output: Ew(e.accessors[A])
        };
      }), c = t.channels.map((l) => {
        let {
          sampler: m,
          target: y
        } = l;
        return {
          sampler: s[m],
          target: e.nodes[y.node],
          path: y.path
        };
      });
      return new K8({
        name: r,
        channels: c
      });
    });
  }
  animate(e) {
    this.setTime(e);
  }
  setTime(e) {
    this.animations.forEach((t) => t.animate(e));
  }
  getAnimations() {
    return this.animations;
  }
}
class ez extends Rd {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(t), this.onBeforeRender = null, this.AfterRender = null, e instanceof Hd ? (this.model = e, this._setModelNodeProps(t)) : this.model = new Hd(e, t), this.bounds = null, this.managedResources = t.managedResources || [];
  }
  setProps(e) {
    return super.setProps(e), this._setModelNodeProps(e), this;
  }
  getBounds() {
    return this.bounds;
  }
  delete() {
    this.model && (this.model.delete(), this.model = null), this.managedResources.forEach((e) => e.delete()), this.managedResources = [];
  }
  draw() {
    return this.model.draw(...arguments);
  }
  setUniforms() {
    return this.model.setUniforms(...arguments), this;
  }
  setAttributes() {
    return this.model.setAttributes(...arguments), this;
  }
  updateModuleSettings() {
    return this.model.updateModuleSettings(...arguments), this;
  }
  _setModelNodeProps(e) {
    this.model.setProps(e);
  }
}
class wS {
  constructor(e, t) {
    let {
      attributes: i,
      material: r,
      pbrDebug: s,
      imageBasedLightingEnvironment: c,
      lights: l,
      useTangents: m
    } = t;
    this.gl = e, this.defines = {
      MANUAL_SRGB: 1,
      SRGB_FAST_APPROXIMATION: 1
    }, I1(e, rr.GLSL_TEXTURE_LOD) && (this.defines.USE_TEX_LOD = 1), this.uniforms = {
      u_Camera: [0, 0, 0],
      u_MetallicRoughnessValues: [1, 1]
    }, this.parameters = {}, this.generatedTextures = [], c && (this.uniforms.u_DiffuseEnvSampler = c.getDiffuseEnvSampler(), this.uniforms.u_SpecularEnvSampler = c.getSpecularEnvSampler(), this.uniforms.u_brdfLUT = c.getBrdfTexture(), this.uniforms.u_ScaleIBLAmbient = [1, 1]), s && (this.uniforms.u_ScaleDiffBaseMR = [0, 0, 0, 0], this.uniforms.u_ScaleFGDSpec = [0, 0, 0, 0]), this.defineIfPresent(i.NORMAL, "HAS_NORMALS"), this.defineIfPresent(i.TANGENT && m, "HAS_TANGENTS"), this.defineIfPresent(i.TEXCOORD_0, "HAS_UV"), this.defineIfPresent(c, "USE_IBL"), this.defineIfPresent(l, "USE_LIGHTS"), this.defineIfPresent(s, "PBR_DEBUG"), r && this.parseMaterial(r);
  }
  defineIfPresent(e, t) {
    e && (this.defines[t] = 1);
  }
  parseTexture(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    const r = e.texture && e.texture.sampler && e.texture.sampler.parameters || {}, s = e.texture.source.image;
    let c, l = {};
    s.compressed ? (c = s, l = {
      [this.gl.TEXTURE_MIN_FILTER]: s.data.length > 1 ? this.gl.LINEAR_MIPMAP_NEAREST : this.gl.LINEAR
    }) : c = {
      data: s
    };
    const m = new ga(this.gl, {
      id: e.name || e.id,
      parameters: {
        ...r,
        ...l
      },
      pixelStore: {
        [this.gl.UNPACK_FLIP_Y_WEBGL]: !1
      },
      ...c
    });
    this.uniforms[t] = m, this.defineIfPresent(i, i), this.generatedTextures.push(m);
  }
  parsePbrMetallicRoughness(e) {
    e.baseColorTexture && this.parseTexture(e.baseColorTexture, "u_BaseColorSampler", "HAS_BASECOLORMAP"), this.uniforms.u_BaseColorFactor = e.baseColorFactor || [1, 1, 1, 1], e.metallicRoughnessTexture && this.parseTexture(e.metallicRoughnessTexture, "u_MetallicRoughnessSampler", "HAS_METALROUGHNESSMAP");
    const {
      metallicFactor: t = 1,
      roughnessFactor: i = 1
    } = e;
    this.uniforms.u_MetallicRoughnessValues = [t, i];
  }
  parseMaterial(e) {
    if (this.uniforms.pbr_uUnlit = !!e.unlit, e.pbrMetallicRoughness && this.parsePbrMetallicRoughness(e.pbrMetallicRoughness), e.normalTexture) {
      this.parseTexture(e.normalTexture, "u_NormalSampler", "HAS_NORMALMAP");
      const {
        scale: t = 1
      } = e.normalTexture;
      this.uniforms.u_NormalScale = t;
    }
    if (e.occlusionTexture) {
      this.parseTexture(e.occlusionTexture, "u_OcclusionSampler", "HAS_OCCLUSIONMAP");
      const {
        strength: t = 1
      } = e.occlusionTexture;
      this.uniforms.u_OcclusionStrength = t;
    }
    if (e.emissiveTexture && (this.parseTexture(e.emissiveTexture, "u_EmissiveSampler", "HAS_EMISSIVEMAP"), this.uniforms.u_EmissiveFactor = e.emissiveFactor || [0, 0, 0]), e.alphaMode === "MASK") {
      const {
        alphaCutoff: t = 0.5
      } = e;
      this.defines.ALPHA_CUTOFF = 1, this.uniforms.u_AlphaCutoff = t;
    } else
      e.alphaMode === "BLEND" && (cn.warn("BLEND alphaMode might not work well because it requires mesh sorting")(), Object.assign(this.parameters, {
        blend: !0,
        blendEquation: this.gl.FUNC_ADD,
        blendFunc: [this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA, this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA]
      }));
  }
  delete() {
    this.generatedTextures.forEach((e) => e.delete());
  }
}
const tz = `
#if (__VERSION__ < 300)
  #define _attr attribute
#else
  #define _attr in
#endif

  _attr vec4 POSITION;

  #ifdef HAS_NORMALS
    _attr vec4 NORMAL;
  #endif

  #ifdef HAS_TANGENTS
    _attr vec4 TANGENT;
  #endif

  #ifdef HAS_UV
    _attr vec2 TEXCOORD_0;
  #endif

  void main(void) {
    vec4 _NORMAL = vec4(0.);
    vec4 _TANGENT = vec4(0.);
    vec2 _TEXCOORD_0 = vec2(0.);

    #ifdef HAS_NORMALS
      _NORMAL = NORMAL;
    #endif

    #ifdef HAS_TANGENTS
      _TANGENT = TANGENT;
    #endif

    #ifdef HAS_UV
      _TEXCOORD_0 = TEXCOORD_0;
    #endif

    pbr_setPositionNormalTangentUV(POSITION, _NORMAL, _TANGENT, _TEXCOORD_0);
    gl_Position = u_MVPMatrix * POSITION;
  }
`, nz = `
#if (__VERSION__ < 300)
  #define fragmentColor gl_FragColor
#else
  out vec4 fragmentColor;
#endif

  void main(void) {
    fragmentColor = pbr_filterColor(vec4(0));
  }
`;
function Sw(n, e) {
  return ei(n) ? `#version 300 es
`.concat(e) : e;
}
function iz(n, e) {
  const {
    id: t,
    drawMode: i,
    vertexCount: r,
    attributes: s,
    modelOptions: c
  } = e, l = new wS(n, e);
  cn.info(4, "createGLTFModel defines: ", l.defines)();
  const m = [];
  m.push(...l.generatedTextures), m.push(...Object.values(s).map((A) => A.buffer));
  const y = new ez(n, {
    id: t,
    drawMode: i,
    vertexCount: r,
    modules: [j1],
    parameters: l.parameters,
    vs: Sw(n, tz),
    fs: Sw(n, nz),
    managedResources: m,
    ...c,
    defines: {
      ...l.defines,
      ...c.defines
    }
  });
  return y.setProps({
    attributes: s
  }), y.setUniforms(l.uniforms), y;
}
const rz = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, sz = {
  modelOptions: {},
  pbrDebug: !1,
  imageBasedLightingEnvironment: null,
  lights: !0,
  useTangents: !1
};
class oz {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.gl = e, this.options = Object.assign({}, sz, t);
  }
  instantiate(e) {
    return this.gltf = e, (e.scenes || []).map((i) => this.createScene(i));
  }
  createAnimator() {
    return Array.isArray(this.gltf.animations) ? new Q8(this.gltf) : null;
  }
  createScene(e) {
    const i = (e.nodes || []).map((s) => this.createNode(s));
    return new ap({
      id: e.name || e.id,
      children: i
    });
  }
  createNode(e) {
    if (!e._node) {
      const i = (e.children || []).map((s) => this.createNode(s));
      e.mesh && i.push(this.createMesh(e.mesh));
      const r = new ap({
        id: e.name || e.id,
        children: i
      });
      if (e.matrix)
        r.setMatrix(e.matrix);
      else {
        if (r.matrix.identity(), e.translation && r.matrix.translate(e.translation), e.rotation) {
          const s = new ai().fromQuaternion(e.rotation);
          r.matrix.multiplyRight(s);
        }
        e.scale && r.matrix.scale(e.scale);
      }
      e._node = r;
    }
    return e._node;
  }
  createMesh(e) {
    if (!e._mesh) {
      const i = (e.primitives || []).map((s, c) => this.createPrimitive(s, c, e)), r = new ap({
        id: e.name || e.id,
        children: i
      });
      e._mesh = r;
    }
    return e._mesh;
  }
  getVertexCount(e) {
    cn.warn("getVertexCount() not found")();
  }
  createPrimitive(e, t, i) {
    const r = iz(this.gl, Object.assign({
      id: e.name || "".concat(i.name || i.id, "-primitive-").concat(t),
      drawMode: e.mode || 4,
      vertexCount: e.indices ? e.indices.count : this.getVertexCount(e.attributes),
      attributes: this.createAttributes(e.attributes, e.indices),
      material: e.material
    }, this.options));
    return r.bounds = [e.attributes.POSITION.min, e.attributes.POSITION.max], r;
  }
  createAttributes(e, t) {
    const i = {};
    return Object.keys(e).forEach((r) => {
      i[r] = this.createAccessor(e[r], this.createBuffer(e[r], this.gl.ARRAY_BUFFER));
    }), t && (i.indices = this.createAccessor(t, this.createBuffer(t, this.gl.ELEMENT_ARRAY_BUFFER))), cn.info(4, "glTF Attributes", {
      attributes: e,
      indices: t,
      generated: i
    })(), i;
  }
  createBuffer(e, t) {
    e.bufferView || (e.bufferView = {});
    const {
      bufferView: i
    } = e;
    return i.lumaBuffers || (i.lumaBuffers = {}), i.lumaBuffers[t] || (i.lumaBuffers[t] = new Hi(this.gl, {
      id: "from-".concat(i.id),
      data: i.data || e.value,
      target: t
    })), i.lumaBuffers[t];
  }
  createAccessor(e, t) {
    return new Ro({
      buffer: t,
      offset: e.byteOffset || 0,
      stride: e.bufferView.byteStride || 0,
      type: e.componentType,
      size: rz[e.type]
    });
  }
  createSampler(e) {
    return e;
  }
  needsPOT() {
    return !1;
  }
}
function az(n, e, t) {
  const i = new oz(n, t), r = i.instantiate(e), s = i.createAnimator();
  return {
    scenes: r,
    animator: s
  };
}
const lz = "3.4.15", cz = "3.4.15", AS = "3.4.15", uz = "https://unpkg.com/@loaders.gl/textures@".concat(AS, "/dist/libs/basis_encoder.wasm"), hz = "https://unpkg.com/@loaders.gl/textures@".concat(AS, "/dist/libs/basis_encoder.js");
let __;
async function Tw(n) {
  const e = n.modules || {};
  return e.basis ? e.basis : (__ = __ || dz(n), await __);
}
async function dz(n) {
  let e = null, t = null;
  return [e, t] = await Promise.all([await Rh("basis_transcoder.js", "textures", n), await Rh("basis_transcoder.wasm", "textures", n)]), e = e || globalThis.BASIS, await fz(e, t);
}
function fz(n, e) {
  const t = {};
  return e && (t.wasmBinary = e), new Promise((i) => {
    n(t).then((r) => {
      const {
        BasisFile: s,
        initializeBasis: c
      } = r;
      c(), i({
        BasisFile: s
      });
    });
  });
}
let y_;
async function Cw(n) {
  const e = n.modules || {};
  return e.basisEncoder ? e.basisEncoder : (y_ = y_ || pz(n), await y_);
}
async function pz(n) {
  let e = null, t = null;
  return [e, t] = await Promise.all([await Rh(hz, "textures", n), await Rh(uz, "textures", n)]), e = e || globalThis.BASIS, await gz(e, t);
}
function gz(n, e) {
  const t = {};
  return e && (t.wasmBinary = e), new Promise((i) => {
    n(t).then((r) => {
      const {
        BasisFile: s,
        KTX2File: c,
        initializeBasis: l,
        BasisEncoder: m
      } = r;
      l(), i({
        BasisFile: s,
        KTX2File: c,
        BasisEncoder: m
      });
    });
  });
}
const gd = {
  COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
  COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
  COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
  COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
  COMPRESSED_R11_EAC: 37488,
  COMPRESSED_SIGNED_R11_EAC: 37489,
  COMPRESSED_RG11_EAC: 37490,
  COMPRESSED_SIGNED_RG11_EAC: 37491,
  COMPRESSED_RGB8_ETC2: 37492,
  COMPRESSED_RGBA8_ETC2_EAC: 37493,
  COMPRESSED_SRGB8_ETC2: 37494,
  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495,
  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496,
  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497,
  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,
  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,
  COMPRESSED_RGB_ETC1_WEBGL: 36196,
  COMPRESSED_RGB_ATC_WEBGL: 35986,
  COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35987,
  COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798,
  COMPRESSED_RGBA_ASTC_4X4_KHR: 37808,
  COMPRESSED_RGBA_ASTC_5X4_KHR: 37809,
  COMPRESSED_RGBA_ASTC_5X5_KHR: 37810,
  COMPRESSED_RGBA_ASTC_6X5_KHR: 37811,
  COMPRESSED_RGBA_ASTC_6X6_KHR: 37812,
  COMPRESSED_RGBA_ASTC_8X5_KHR: 37813,
  COMPRESSED_RGBA_ASTC_8X6_KHR: 37814,
  COMPRESSED_RGBA_ASTC_8X8_KHR: 37815,
  COMPRESSED_RGBA_ASTC_10X5_KHR: 37816,
  COMPRESSED_RGBA_ASTC_10X6_KHR: 37817,
  COMPRESSED_RGBA_ASTC_10X8_KHR: 37818,
  COMPRESSED_RGBA_ASTC_10X10_KHR: 37819,
  COMPRESSED_RGBA_ASTC_12X10_KHR: 37820,
  COMPRESSED_RGBA_ASTC_12X12_KHR: 37821,
  COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: 37840,
  COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: 37841,
  COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: 37842,
  COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: 37843,
  COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: 37844,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: 37845,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: 37846,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: 37847,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: 37848,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: 37849,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: 37850,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: 37851,
  COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: 37852,
  COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: 37853,
  COMPRESSED_RED_RGTC1_EXT: 36283,
  COMPRESSED_SIGNED_RED_RGTC1_EXT: 36284,
  COMPRESSED_RED_GREEN_RGTC2_EXT: 36285,
  COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 36286,
  COMPRESSED_SRGB_S3TC_DXT1_EXT: 35916,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 35917,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 35918,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 35919
}, mz = ["", "WEBKIT_", "MOZ_"], Iw = {
  WEBGL_compressed_texture_s3tc: "dxt",
  WEBGL_compressed_texture_s3tc_srgb: "dxt-srgb",
  WEBGL_compressed_texture_etc1: "etc1",
  WEBGL_compressed_texture_etc: "etc2",
  WEBGL_compressed_texture_pvrtc: "pvrtc",
  WEBGL_compressed_texture_atc: "atc",
  WEBGL_compressed_texture_astc: "astc",
  EXT_texture_compression_rgtc: "rgtc"
};
let Lg = null;
function _z(n) {
  if (!Lg) {
    n = n || yz() || void 0, Lg = /* @__PURE__ */ new Set();
    for (const e of mz)
      for (const t in Iw)
        if (n && n.getExtension("".concat(e).concat(t))) {
          const i = Iw[t];
          Lg.add(i);
        }
  }
  return Lg;
}
function yz() {
  try {
    return document.createElement("canvas").getContext("webgl");
  } catch {
    return null;
  }
}
var Pw, Lw, Mw, Bw, Rw, Ow, Fw, Dw;
(function(n) {
  n[n.NONE = 0] = "NONE", n[n.BASISLZ = 1] = "BASISLZ", n[n.ZSTD = 2] = "ZSTD", n[n.ZLIB = 3] = "ZLIB";
})(Pw || (Pw = {})), function(n) {
  n[n.BASICFORMAT = 0] = "BASICFORMAT";
}(Lw || (Lw = {})), function(n) {
  n[n.UNSPECIFIED = 0] = "UNSPECIFIED", n[n.ETC1S = 163] = "ETC1S", n[n.UASTC = 166] = "UASTC";
}(Mw || (Mw = {})), function(n) {
  n[n.UNSPECIFIED = 0] = "UNSPECIFIED", n[n.SRGB = 1] = "SRGB";
}(Bw || (Bw = {})), function(n) {
  n[n.UNSPECIFIED = 0] = "UNSPECIFIED", n[n.LINEAR = 1] = "LINEAR", n[n.SRGB = 2] = "SRGB", n[n.ITU = 3] = "ITU", n[n.NTSC = 4] = "NTSC", n[n.SLOG = 5] = "SLOG", n[n.SLOG2 = 6] = "SLOG2";
}(Rw || (Rw = {})), function(n) {
  n[n.ALPHA_STRAIGHT = 0] = "ALPHA_STRAIGHT", n[n.ALPHA_PREMULTIPLIED = 1] = "ALPHA_PREMULTIPLIED";
}(Ow || (Ow = {})), function(n) {
  n[n.RGB = 0] = "RGB", n[n.RRR = 3] = "RRR", n[n.GGG = 4] = "GGG", n[n.AAA = 15] = "AAA";
}(Fw || (Fw = {})), function(n) {
  n[n.RGB = 0] = "RGB", n[n.RGBA = 3] = "RGBA", n[n.RRR = 4] = "RRR", n[n.RRRG = 5] = "RRRG";
}(Dw || (Dw = {}));
const la = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
function vz(n) {
  const e = new Uint8Array(n);
  return !(e.byteLength < la.length || e[0] !== la[0] || e[1] !== la[1] || e[2] !== la[2] || e[3] !== la[3] || e[4] !== la[4] || e[5] !== la[5] || e[6] !== la[6] || e[7] !== la[7] || e[8] !== la[8] || e[9] !== la[9] || e[10] !== la[10] || e[11] !== la[11]);
}
const bz = {
  etc1: {
    basisFormat: 0,
    compressed: !0,
    format: gd.COMPRESSED_RGB_ETC1_WEBGL
  },
  etc2: {
    basisFormat: 1,
    compressed: !0
  },
  bc1: {
    basisFormat: 2,
    compressed: !0,
    format: gd.COMPRESSED_RGB_S3TC_DXT1_EXT
  },
  bc3: {
    basisFormat: 3,
    compressed: !0,
    format: gd.COMPRESSED_RGBA_S3TC_DXT5_EXT
  },
  bc4: {
    basisFormat: 4,
    compressed: !0
  },
  bc5: {
    basisFormat: 5,
    compressed: !0
  },
  "bc7-m6-opaque-only": {
    basisFormat: 6,
    compressed: !0
  },
  "bc7-m5": {
    basisFormat: 7,
    compressed: !0
  },
  "pvrtc1-4-rgb": {
    basisFormat: 8,
    compressed: !0,
    format: gd.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
  },
  "pvrtc1-4-rgba": {
    basisFormat: 9,
    compressed: !0,
    format: gd.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
  },
  "astc-4x4": {
    basisFormat: 10,
    compressed: !0,
    format: gd.COMPRESSED_RGBA_ASTC_4X4_KHR
  },
  "atc-rgb": {
    basisFormat: 11,
    compressed: !0
  },
  "atc-rgba-interpolated-alpha": {
    basisFormat: 12,
    compressed: !0
  },
  rgba32: {
    basisFormat: 13,
    compressed: !1
  },
  rgb565: {
    basisFormat: 14,
    compressed: !1
  },
  bgr565: {
    basisFormat: 15,
    compressed: !1
  },
  rgba4444: {
    basisFormat: 16,
    compressed: !1
  }
};
async function xz(n, e) {
  if (e.basis.containerFormat === "auto") {
    if (vz(n)) {
      const i = await Cw(e);
      return kw(i.KTX2File, n, e);
    }
    const {
      BasisFile: t
    } = await Tw(e);
    return v_(t, n, e);
  }
  switch (e.basis.module) {
    case "encoder":
      const t = await Cw(e);
      switch (e.basis.containerFormat) {
        case "ktx2":
          return kw(t.KTX2File, n, e);
        case "basis":
        default:
          return v_(t.BasisFile, n, e);
      }
    case "transcoder":
    default:
      const {
        BasisFile: i
      } = await Tw(e);
      return v_(i, n, e);
  }
}
function v_(n, e, t) {
  const i = new n(new Uint8Array(e));
  try {
    if (!i.startTranscoding())
      throw new Error("Failed to start basis transcoding");
    const r = i.getNumImages(), s = [];
    for (let c = 0; c < r; c++) {
      const l = i.getNumLevels(c), m = [];
      for (let y = 0; y < l; y++)
        m.push(wz(i, c, y, t));
      s.push(m);
    }
    return s;
  } finally {
    i.close(), i.delete();
  }
}
function wz(n, e, t, i) {
  const r = n.getImageWidth(e, t), s = n.getImageHeight(e, t), c = n.getHasAlpha(), {
    compressed: l,
    format: m,
    basisFormat: y
  } = ES(i, c), A = n.getImageTranscodedSizeInBytes(e, t, y), T = new Uint8Array(A);
  if (!n.transcodeImage(T, e, t, y, 0, 0))
    throw new Error("failed to start Basis transcoding");
  return {
    width: r,
    height: s,
    data: T,
    compressed: l,
    format: m,
    hasAlpha: c
  };
}
function kw(n, e, t) {
  const i = new n(new Uint8Array(e));
  try {
    if (!i.startTranscoding())
      throw new Error("failed to start KTX2 transcoding");
    const r = i.getLevels(), s = [];
    for (let c = 0; c < r; c++) {
      s.push(Az(i, c, t));
      break;
    }
    return [s];
  } finally {
    i.close(), i.delete();
  }
}
function Az(n, e, t) {
  const {
    alphaFlag: i,
    height: r,
    width: s
  } = n.getImageLevelInfo(e, 0, 0), {
    compressed: c,
    format: l,
    basisFormat: m
  } = ES(t, i), y = n.getImageTranscodedSizeInBytes(e, 0, 0, m), A = new Uint8Array(y);
  if (!n.transcodeImage(A, e, 0, 0, m, 0, -1, -1))
    throw new Error("Failed to transcode KTX2 image");
  return {
    width: s,
    height: r,
    data: A,
    compressed: c,
    levelSize: y,
    hasAlpha: i,
    format: l
  };
}
function ES(n, e) {
  let t = n && n.basis && n.basis.format;
  return t === "auto" && (t = SS()), typeof t == "object" && (t = e ? t.alpha : t.noAlpha), t = t.toLowerCase(), bz[t];
}
function SS() {
  const n = _z();
  return n.has("astc") ? "astc-4x4" : n.has("dxt") ? {
    alpha: "bc3",
    noAlpha: "bc1"
  } : n.has("pvrtc") ? {
    alpha: "pvrtc1-4-rgba",
    noAlpha: "pvrtc1-4-rgb"
  } : n.has("etc1") ? "etc1" : n.has("etc2") ? "etc2" : "rgb565";
}
const Ez = {
  name: "Basis",
  id: Yc ? "basis" : "basis-nodejs",
  module: "textures",
  version: cz,
  worker: !0,
  extensions: ["basis", "ktx2"],
  mimeTypes: ["application/octet-stream", "image/ktx2"],
  tests: ["sB"],
  binary: !0,
  options: {
    basis: {
      format: "auto",
      libraryPath: "libs/",
      containerFormat: "auto",
      module: "transcoder"
    }
  }
}, Sz = {
  ...Ez,
  parse: xz
};
function fa(n, e) {
  if (!n)
    throw new Error(e || "assert failed: gltf");
}
function TS(n, e) {
  if (n.startsWith("data:") || n.startsWith("http:") || n.startsWith("https:"))
    return n;
  const i = e.baseUri || e.uri;
  if (!i)
    throw new Error("'baseUri' must be provided to resolve relative url ".concat(n));
  return i.substr(0, i.lastIndexOf("/") + 1) + n;
}
function Tz(n, e, t) {
  const i = n.bufferViews[t];
  fa(i);
  const r = i.buffer, s = e[r];
  fa(s);
  const c = (i.byteOffset || 0) + s.byteOffset;
  return new Uint8Array(s.arrayBuffer, c, i.byteLength);
}
const Nw = ["SCALAR", "VEC2", "VEC3", "VEC4"], Cz = [[Int8Array, 5120], [Uint8Array, 5121], [Int16Array, 5122], [Uint16Array, 5123], [Uint32Array, 5125], [Float32Array, 5126], [Float64Array, 5130]], Iz = new Map(Cz), Pz = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, Lz = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
}, Mz = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
function CS(n) {
  return Nw[n - 1] || Nw[0];
}
function IS(n) {
  const e = Iz.get(n.constructor);
  if (!e)
    throw new Error("Illegal typed array");
  return e;
}
function lv(n, e) {
  const t = Mz[n.componentType], i = Pz[n.type], r = Lz[n.componentType], s = n.count * i, c = n.count * i * r;
  return fa(c >= 0 && c <= e.byteLength), {
    ArrayType: t,
    length: s,
    byteLength: c
  };
}
function PS(n) {
  let {
    images: e,
    bufferViews: t
  } = n;
  e = e || [], t = t || [];
  const i = e.map((c) => c.bufferView);
  t = t.filter((c) => !i.includes(c));
  const r = t.reduce((c, l) => c + l.byteLength, 0), s = e.reduce((c, l) => {
    const {
      width: m,
      height: y
    } = l.image;
    return c + m * y;
  }, 0);
  return r + Math.ceil(4 * s * 1.33);
}
const Bz = {
  asset: {
    version: "2.0",
    generator: "loaders.gl"
  },
  buffers: []
};
class Do {
  constructor(e) {
    G(this, "gltf", void 0), G(this, "sourceBuffers", void 0), G(this, "byteLength", void 0), this.gltf = e || {
      json: {
        ...Bz
      },
      buffers: []
    }, this.sourceBuffers = [], this.byteLength = 0, this.gltf.buffers && this.gltf.buffers[0] && (this.byteLength = this.gltf.buffers[0].byteLength, this.sourceBuffers = [this.gltf.buffers[0]]);
  }
  get json() {
    return this.gltf.json;
  }
  getApplicationData(e) {
    return this.json[e];
  }
  getExtraData(e) {
    return (this.json.extras || {})[e];
  }
  getExtension(e) {
    const t = this.getUsedExtensions().find((r) => r === e), i = this.json.extensions || {};
    return t ? i[e] || !0 : null;
  }
  getRequiredExtension(e) {
    return this.getRequiredExtensions().find((i) => i === e) ? this.getExtension(e) : null;
  }
  getRequiredExtensions() {
    return this.json.extensionsRequired || [];
  }
  getUsedExtensions() {
    return this.json.extensionsUsed || [];
  }
  getRemovedExtensions() {
    return this.json.extensionsRemoved || [];
  }
  getObjectExtension(e, t) {
    return (e.extensions || {})[t];
  }
  getScene(e) {
    return this.getObject("scenes", e);
  }
  getNode(e) {
    return this.getObject("nodes", e);
  }
  getSkin(e) {
    return this.getObject("skins", e);
  }
  getMesh(e) {
    return this.getObject("meshes", e);
  }
  getMaterial(e) {
    return this.getObject("materials", e);
  }
  getAccessor(e) {
    return this.getObject("accessors", e);
  }
  getTexture(e) {
    return this.getObject("textures", e);
  }
  getSampler(e) {
    return this.getObject("samplers", e);
  }
  getImage(e) {
    return this.getObject("images", e);
  }
  getBufferView(e) {
    return this.getObject("bufferViews", e);
  }
  getBuffer(e) {
    return this.getObject("buffers", e);
  }
  getObject(e, t) {
    if (typeof t == "object")
      return t;
    const i = this.json[e] && this.json[e][t];
    if (!i)
      throw new Error("glTF file error: Could not find ".concat(e, "[").concat(t, "]"));
    return i;
  }
  getTypedArrayForBufferView(e) {
    e = this.getBufferView(e);
    const t = e.buffer, i = this.gltf.buffers[t];
    fa(i);
    const r = (e.byteOffset || 0) + i.byteOffset;
    return new Uint8Array(i.arrayBuffer, r, e.byteLength);
  }
  getTypedArrayForAccessor(e) {
    e = this.getAccessor(e);
    const t = this.getBufferView(e.bufferView), r = this.getBuffer(t.buffer).data, {
      ArrayType: s,
      length: c
    } = lv(e, t), l = t.byteOffset + e.byteOffset;
    return new s(r, l, c);
  }
  getTypedArrayForImageData(e) {
    e = this.getAccessor(e);
    const t = this.getBufferView(e.bufferView), r = this.getBuffer(t.buffer).data, s = t.byteOffset || 0;
    return new Uint8Array(r, s, t.byteLength);
  }
  addApplicationData(e, t) {
    return this.json[e] = t, this;
  }
  addExtraData(e, t) {
    return this.json.extras = this.json.extras || {}, this.json.extras[e] = t, this;
  }
  addObjectExtension(e, t, i) {
    return e.extensions = e.extensions || {}, e.extensions[t] = i, this.registerUsedExtension(t), this;
  }
  setObjectExtension(e, t, i) {
    const r = e.extensions || {};
    r[t] = i;
  }
  removeObjectExtension(e, t) {
    const i = e.extensions || {}, r = i[t];
    return delete i[t], r;
  }
  addExtension(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return fa(t), this.json.extensions = this.json.extensions || {}, this.json.extensions[e] = t, this.registerUsedExtension(e), t;
  }
  addRequiredExtension(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return fa(t), this.addExtension(e, t), this.registerRequiredExtension(e), t;
  }
  registerUsedExtension(e) {
    this.json.extensionsUsed = this.json.extensionsUsed || [], this.json.extensionsUsed.find((t) => t === e) || this.json.extensionsUsed.push(e);
  }
  registerRequiredExtension(e) {
    this.registerUsedExtension(e), this.json.extensionsRequired = this.json.extensionsRequired || [], this.json.extensionsRequired.find((t) => t === e) || this.json.extensionsRequired.push(e);
  }
  removeExtension(e) {
    if (!this.getExtension(e))
      return;
    this.json.extensionsRequired && this._removeStringFromArray(this.json.extensionsRequired, e), this.json.extensionsUsed && this._removeStringFromArray(this.json.extensionsUsed, e), this.json.extensions && delete this.json.extensions[e], Array.isArray(this.json.extensionsRemoved) || (this.json.extensionsRemoved = []);
    const t = this.json.extensionsRemoved;
    t.includes(e) || t.push(e);
  }
  setDefaultScene(e) {
    this.json.scene = e;
  }
  addScene(e) {
    const {
      nodeIndices: t
    } = e;
    return this.json.scenes = this.json.scenes || [], this.json.scenes.push({
      nodes: t
    }), this.json.scenes.length - 1;
  }
  addNode(e) {
    const {
      meshIndex: t,
      matrix: i
    } = e;
    this.json.nodes = this.json.nodes || [];
    const r = {
      mesh: t
    };
    return i && (r.matrix = i), this.json.nodes.push(r), this.json.nodes.length - 1;
  }
  addMesh(e) {
    const {
      attributes: t,
      indices: i,
      material: r,
      mode: s = 4
    } = e, l = {
      primitives: [{
        attributes: this._addAttributes(t),
        mode: s
      }]
    };
    if (i) {
      const m = this._addIndices(i);
      l.primitives[0].indices = m;
    }
    return Number.isFinite(r) && (l.primitives[0].material = r), this.json.meshes = this.json.meshes || [], this.json.meshes.push(l), this.json.meshes.length - 1;
  }
  addPointCloud(e) {
    const i = {
      primitives: [{
        attributes: this._addAttributes(e),
        mode: 0
      }]
    };
    return this.json.meshes = this.json.meshes || [], this.json.meshes.push(i), this.json.meshes.length - 1;
  }
  addImage(e, t) {
    const i = w1(e), r = t || (i == null ? void 0 : i.mimeType), c = {
      bufferView: this.addBufferView(e),
      mimeType: r
    };
    return this.json.images = this.json.images || [], this.json.images.push(c), this.json.images.length - 1;
  }
  addBufferView(e) {
    const t = e.byteLength;
    fa(Number.isFinite(t)), this.sourceBuffers = this.sourceBuffers || [], this.sourceBuffers.push(e);
    const i = {
      buffer: 0,
      byteOffset: this.byteLength,
      byteLength: t
    };
    return this.byteLength += Tp(t, 4), this.json.bufferViews = this.json.bufferViews || [], this.json.bufferViews.push(i), this.json.bufferViews.length - 1;
  }
  addAccessor(e, t) {
    const i = {
      bufferView: e,
      type: CS(t.size),
      componentType: t.componentType,
      count: t.count,
      max: t.max,
      min: t.min
    };
    return this.json.accessors = this.json.accessors || [], this.json.accessors.push(i), this.json.accessors.length - 1;
  }
  addBinaryBuffer(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      size: 3
    };
    const i = this.addBufferView(e);
    let r = {
      min: t.min,
      max: t.max
    };
    (!r.min || !r.max) && (r = this._getAccessorMinMax(e, t.size));
    const s = {
      size: t.size,
      componentType: IS(e),
      count: Math.round(e.length / t.size),
      min: r.min,
      max: r.max
    };
    return this.addAccessor(i, Object.assign(s, t));
  }
  addTexture(e) {
    const {
      imageIndex: t
    } = e, i = {
      source: t
    };
    return this.json.textures = this.json.textures || [], this.json.textures.push(i), this.json.textures.length - 1;
  }
  addMaterial(e) {
    return this.json.materials = this.json.materials || [], this.json.materials.push(e), this.json.materials.length - 1;
  }
  createBinaryChunk() {
    var e, t;
    this.gltf.buffers = [];
    const i = this.byteLength, r = new ArrayBuffer(i), s = new Uint8Array(r);
    let c = 0;
    for (const l of this.sourceBuffers || [])
      c = eP(l, s, c);
    (e = this.json) !== null && e !== void 0 && (t = e.buffers) !== null && t !== void 0 && t[0] ? this.json.buffers[0].byteLength = i : this.json.buffers = [{
      byteLength: i
    }], this.gltf.binary = r, this.sourceBuffers = [r];
  }
  _removeStringFromArray(e, t) {
    let i = !0;
    for (; i; ) {
      const r = e.indexOf(t);
      r > -1 ? e.splice(r, 1) : i = !1;
    }
  }
  _addAttributes() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = {};
    for (const i in e) {
      const r = e[i], s = this._getGltfAttributeName(i), c = this.addBinaryBuffer(r.value, r);
      t[s] = c;
    }
    return t;
  }
  _addIndices(e) {
    return this.addBinaryBuffer(e, {
      size: 1
    });
  }
  _getGltfAttributeName(e) {
    switch (e.toLowerCase()) {
      case "position":
      case "positions":
      case "vertices":
        return "POSITION";
      case "normal":
      case "normals":
        return "NORMAL";
      case "color":
      case "colors":
        return "COLOR_0";
      case "texcoord":
      case "texcoords":
        return "TEXCOORD_0";
      default:
        return e;
    }
  }
  _getAccessorMinMax(e, t) {
    const i = {
      min: null,
      max: null
    };
    if (e.length < t)
      return i;
    i.min = [], i.max = [];
    const r = e.subarray(0, t);
    for (const s of r)
      i.min.push(s), i.max.push(s);
    for (let s = t; s < e.length; s += t)
      for (let c = 0; c < t; c++)
        i.min[0 + c] = Math.min(i.min[0 + c], e[s + c]), i.max[0 + c] = Math.max(i.max[0 + c], e[s + c]);
    return i;
  }
}
const Rz = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB", Oz = "B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB", Fz = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]), Dz = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]), kz = {
  0: "",
  1: "meshopt_decodeFilterOct",
  2: "meshopt_decodeFilterQuat",
  3: "meshopt_decodeFilterExp",
  NONE: "",
  OCTAHEDRAL: "meshopt_decodeFilterOct",
  QUATERNION: "meshopt_decodeFilterQuat",
  EXPONENTIAL: "meshopt_decodeFilterExp"
}, Nz = {
  0: "meshopt_decodeVertexBuffer",
  1: "meshopt_decodeIndexBuffer",
  2: "meshopt_decodeIndexSequence",
  ATTRIBUTES: "meshopt_decodeVertexBuffer",
  TRIANGLES: "meshopt_decodeIndexBuffer",
  INDICES: "meshopt_decodeIndexSequence"
};
async function zz(n, e, t, i, r) {
  let s = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "NONE";
  const c = await Uz();
  Vz(c, c.exports[Nz[r]], n, e, t, i, c.exports[kz[s || "NONE"]]);
}
let b_;
async function Uz() {
  return b_ || (b_ = jz()), b_;
}
async function jz() {
  let n = Rz;
  WebAssembly.validate(Fz) && (n = Oz, console.log("Warning: meshopt_decoder is using experimental SIMD support"));
  const e = await WebAssembly.instantiate(Gz(n), {});
  return await e.instance.exports.__wasm_call_ctors(), e.instance;
}
function Gz(n) {
  const e = new Uint8Array(n.length);
  for (let i = 0; i < n.length; ++i) {
    const r = n.charCodeAt(i);
    e[i] = r > 96 ? r - 71 : r > 64 ? r - 65 : r > 47 ? r + 4 : r > 46 ? 63 : 62;
  }
  let t = 0;
  for (let i = 0; i < n.length; ++i)
    e[t++] = e[i] < 60 ? Dz[e[i]] : (e[i] - 60) * 64 + e[++i];
  return e.buffer.slice(0, t);
}
function Vz(n, e, t, i, r, s, c) {
  const l = n.exports.sbrk, m = i + 3 & -4, y = l(m * r), A = l(s.length), T = new Uint8Array(n.exports.memory.buffer);
  T.set(s, A);
  const I = e(y, i, r, A, s.length);
  if (I === 0 && c && c(y, m, r), t.set(T.subarray(y, y + i * r)), l(y - l(0)), I !== 0)
    throw new Error("Malformed buffer data: ".concat(I));
}
const cv = "EXT_meshopt_compression", qz = cv;
async function Hz(n, e) {
  var t;
  const i = new Do(n);
  if (!(e != null && (t = e.gltf) !== null && t !== void 0 && t.decompressMeshes))
    return;
  const r = [];
  for (const s of n.json.bufferViews || [])
    r.push(Wz(i, s));
  await Promise.all(r), i.removeExtension(cv);
}
async function Wz(n, e) {
  const t = n.getObjectExtension(e, cv);
  if (t) {
    const {
      byteOffset: i = 0,
      byteLength: r = 0,
      byteStride: s,
      count: c,
      mode: l,
      filter: m = "NONE",
      buffer: y
    } = t, A = n.gltf.buffers[y], T = new Uint8Array(A.arrayBuffer, A.byteOffset + i, r), I = new Uint8Array(n.gltf.buffers[e.buffer].arrayBuffer, e.byteOffset, e.byteLength);
    return await zz(I, c, s, T, l, m), I;
  }
  return null;
}
const Xz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: Hz,
  name: qz
}, Symbol.toStringTag, { value: "Module" })), xd = "EXT_texture_webp", Jz = xd;
function $z(n, e) {
  const t = new Do(n);
  if (!KL("image/webp")) {
    if (t.getRequiredExtensions().includes(xd))
      throw new Error("gltf: Required extension ".concat(xd, " not supported by browser"));
    return;
  }
  const {
    json: i
  } = t;
  for (const r of i.textures || []) {
    const s = t.getObjectExtension(r, xd);
    s && (r.source = s.source), t.removeObjectExtension(r, xd);
  }
  t.removeExtension(xd);
}
const Zz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: Jz,
  preprocess: $z
}, Symbol.toStringTag, { value: "Module" })), $g = "KHR_texture_basisu", Yz = $g;
function Kz(n, e) {
  const t = new Do(n), {
    json: i
  } = t;
  for (const r of i.textures || []) {
    const s = t.getObjectExtension(r, $g);
    s && (r.source = s.source), t.removeObjectExtension(r, $g);
  }
  t.removeExtension($g);
}
const Qz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: Yz,
  preprocess: Kz
}, Symbol.toStringTag, { value: "Module" })), e7 = "3.4.15", t7 = {
  draco: {
    decoderType: typeof WebAssembly == "object" ? "wasm" : "js",
    libraryPath: "libs/",
    extraAttributes: {},
    attributeNameEntry: void 0
  }
}, n7 = {
  name: "Draco",
  id: Yc ? "draco" : "draco-nodejs",
  module: "draco",
  shapes: ["mesh"],
  version: e7,
  worker: !0,
  extensions: ["drc"],
  mimeTypes: ["application/octet-stream"],
  binary: !0,
  tests: ["DRACO"],
  options: t7
};
function i7(n, e, t) {
  const i = LS(e.metadata), r = [], s = r7(e.attributes);
  for (const c in n) {
    const l = n[c], m = zw(c, l, s[c]);
    r.push(m);
  }
  if (t) {
    const c = zw("indices", t);
    r.push(c);
  }
  return new Cd(r, i);
}
function r7(n) {
  const e = {};
  for (const t in n) {
    const i = n[t];
    e[i.name || "undefined"] = i;
  }
  return e;
}
function zw(n, e, t) {
  const i = t ? LS(t.metadata) : void 0;
  return U8(n, e, i);
}
function LS(n) {
  const e = /* @__PURE__ */ new Map();
  for (const t in n)
    e.set("".concat(t, ".string"), JSON.stringify(n[t]));
  return e;
}
const Uw = {
  POSITION: "POSITION",
  NORMAL: "NORMAL",
  COLOR: "COLOR_0",
  TEX_COORD: "TEXCOORD_0"
}, s7 = {
  1: Int8Array,
  2: Uint8Array,
  3: Int16Array,
  4: Uint16Array,
  5: Int32Array,
  6: Uint32Array,
  9: Float32Array
}, o7 = 4;
class a7 {
  constructor(e) {
    G(this, "draco", void 0), G(this, "decoder", void 0), G(this, "metadataQuerier", void 0), this.draco = e, this.decoder = new this.draco.Decoder(), this.metadataQuerier = new this.draco.MetadataQuerier();
  }
  destroy() {
    this.draco.destroy(this.decoder), this.draco.destroy(this.metadataQuerier);
  }
  parseSync(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const i = new this.draco.DecoderBuffer();
    i.Init(new Int8Array(e), e.byteLength), this._disableAttributeTransforms(t);
    const r = this.decoder.GetEncodedGeometryType(i), s = r === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();
    try {
      let c;
      switch (r) {
        case this.draco.TRIANGULAR_MESH:
          c = this.decoder.DecodeBufferToMesh(i, s);
          break;
        case this.draco.POINT_CLOUD:
          c = this.decoder.DecodeBufferToPointCloud(i, s);
          break;
        default:
          throw new Error("DRACO: Unknown geometry type.");
      }
      if (!c.ok() || !s.ptr) {
        const I = "DRACO decompression failed: ".concat(c.error_msg());
        throw new Error(I);
      }
      const l = this._getDracoLoaderData(s, r, t), m = this._getMeshData(s, l, t), y = mS(m.attributes), A = i7(m.attributes, l, m.indices);
      return {
        loader: "draco",
        loaderData: l,
        header: {
          vertexCount: s.num_points(),
          boundingBox: y
        },
        ...m,
        schema: A
      };
    } finally {
      this.draco.destroy(i), s && this.draco.destroy(s);
    }
  }
  _getDracoLoaderData(e, t, i) {
    const r = this._getTopLevelMetadata(e), s = this._getDracoAttributes(e, i);
    return {
      geometry_type: t,
      num_attributes: e.num_attributes(),
      num_points: e.num_points(),
      num_faces: e instanceof this.draco.Mesh ? e.num_faces() : 0,
      metadata: r,
      attributes: s
    };
  }
  _getDracoAttributes(e, t) {
    const i = {};
    for (let r = 0; r < e.num_attributes(); r++) {
      const s = this.decoder.GetAttribute(e, r), c = this._getAttributeMetadata(e, r);
      i[s.unique_id()] = {
        unique_id: s.unique_id(),
        attribute_type: s.attribute_type(),
        data_type: s.data_type(),
        num_components: s.num_components(),
        byte_offset: s.byte_offset(),
        byte_stride: s.byte_stride(),
        normalized: s.normalized(),
        attribute_index: r,
        metadata: c
      };
      const l = this._getQuantizationTransform(s, t);
      l && (i[s.unique_id()].quantization_transform = l);
      const m = this._getOctahedronTransform(s, t);
      m && (i[s.unique_id()].octahedron_transform = m);
    }
    return i;
  }
  _getMeshData(e, t, i) {
    const r = this._getMeshAttributes(t, e, i);
    if (!r.POSITION)
      throw new Error("DRACO: No position attribute found.");
    if (e instanceof this.draco.Mesh)
      switch (i.topology) {
        case "triangle-strip":
          return {
            topology: "triangle-strip",
            mode: 4,
            attributes: r,
            indices: {
              value: this._getTriangleStripIndices(e),
              size: 1
            }
          };
        case "triangle-list":
        default:
          return {
            topology: "triangle-list",
            mode: 5,
            attributes: r,
            indices: {
              value: this._getTriangleListIndices(e),
              size: 1
            }
          };
      }
    return {
      topology: "point-list",
      mode: 0,
      attributes: r
    };
  }
  _getMeshAttributes(e, t, i) {
    const r = {};
    for (const s of Object.values(e.attributes)) {
      const c = this._deduceAttributeName(s, i);
      s.name = c;
      const {
        value: l,
        size: m
      } = this._getAttributeValues(t, s);
      r[c] = {
        value: l,
        size: m,
        byteOffset: s.byte_offset,
        byteStride: s.byte_stride,
        normalized: s.normalized
      };
    }
    return r;
  }
  _getTriangleListIndices(e) {
    const i = e.num_faces() * 3, r = i * o7, s = this.draco._malloc(r);
    try {
      return this.decoder.GetTrianglesUInt32Array(e, r, s), new Uint32Array(this.draco.HEAPF32.buffer, s, i).slice();
    } finally {
      this.draco._free(s);
    }
  }
  _getTriangleStripIndices(e) {
    const t = new this.draco.DracoInt32Array();
    try {
      return this.decoder.GetTriangleStripsFromMesh(e, t), u7(t);
    } finally {
      this.draco.destroy(t);
    }
  }
  _getAttributeValues(e, t) {
    const i = s7[t.data_type], r = t.num_components, c = e.num_points() * r, l = c * i.BYTES_PER_ELEMENT, m = l7(this.draco, i);
    let y;
    const A = this.draco._malloc(l);
    try {
      const T = this.decoder.GetAttribute(e, t.attribute_index);
      this.decoder.GetAttributeDataArrayForAllPoints(e, T, m, l, A), y = new i(this.draco.HEAPF32.buffer, A, c).slice();
    } finally {
      this.draco._free(A);
    }
    return {
      value: y,
      size: r
    };
  }
  _deduceAttributeName(e, t) {
    const i = e.unique_id;
    for (const [c, l] of Object.entries(t.extraAttributes || {}))
      if (l === i)
        return c;
    const r = e.attribute_type;
    for (const c in Uw)
      if (this.draco[c] === r)
        return Uw[c];
    const s = t.attributeNameEntry || "name";
    return e.metadata[s] ? e.metadata[s].string : "CUSTOM_ATTRIBUTE_".concat(i);
  }
  _getTopLevelMetadata(e) {
    const t = this.decoder.GetMetadata(e);
    return this._getDracoMetadata(t);
  }
  _getAttributeMetadata(e, t) {
    const i = this.decoder.GetAttributeMetadata(e, t);
    return this._getDracoMetadata(i);
  }
  _getDracoMetadata(e) {
    if (!e || !e.ptr)
      return {};
    const t = {}, i = this.metadataQuerier.NumEntries(e);
    for (let r = 0; r < i; r++) {
      const s = this.metadataQuerier.GetEntryName(e, r);
      t[s] = this._getDracoMetadataField(e, s);
    }
    return t;
  }
  _getDracoMetadataField(e, t) {
    const i = new this.draco.DracoInt32Array();
    try {
      this.metadataQuerier.GetIntEntryArray(e, t, i);
      const r = c7(i);
      return {
        int: this.metadataQuerier.GetIntEntry(e, t),
        string: this.metadataQuerier.GetStringEntry(e, t),
        double: this.metadataQuerier.GetDoubleEntry(e, t),
        intArray: r
      };
    } finally {
      this.draco.destroy(i);
    }
  }
  _disableAttributeTransforms(e) {
    const {
      quantizedAttributes: t = [],
      octahedronAttributes: i = []
    } = e, r = [...t, ...i];
    for (const s of r)
      this.decoder.SkipAttributeTransform(this.draco[s]);
  }
  _getQuantizationTransform(e, t) {
    const {
      quantizedAttributes: i = []
    } = t, r = e.attribute_type();
    if (i.map((c) => this.decoder[c]).includes(r)) {
      const c = new this.draco.AttributeQuantizationTransform();
      try {
        if (c.InitFromAttribute(e))
          return {
            quantization_bits: c.quantization_bits(),
            range: c.range(),
            min_values: new Float32Array([1, 2, 3]).map((l) => c.min_value(l))
          };
      } finally {
        this.draco.destroy(c);
      }
    }
    return null;
  }
  _getOctahedronTransform(e, t) {
    const {
      octahedronAttributes: i = []
    } = t, r = e.attribute_type();
    if (i.map((c) => this.decoder[c]).includes(r)) {
      const c = new this.draco.AttributeQuantizationTransform();
      try {
        if (c.InitFromAttribute(e))
          return {
            quantization_bits: c.quantization_bits()
          };
      } finally {
        this.draco.destroy(c);
      }
    }
    return null;
  }
}
function l7(n, e) {
  switch (e) {
    case Float32Array:
      return n.DT_FLOAT32;
    case Int8Array:
      return n.DT_INT8;
    case Int16Array:
      return n.DT_INT16;
    case Int32Array:
      return n.DT_INT32;
    case Uint8Array:
      return n.DT_UINT8;
    case Uint16Array:
      return n.DT_UINT16;
    case Uint32Array:
      return n.DT_UINT32;
    default:
      return n.DT_INVALID;
  }
}
function c7(n) {
  const e = n.size(), t = new Int32Array(e);
  for (let i = 0; i < e; i++)
    t[i] = n.GetValue(i);
  return t;
}
function u7(n) {
  const e = n.size(), t = new Int32Array(e);
  for (let i = 0; i < e; i++)
    t[i] = n.GetValue(i);
  return t;
}
const h7 = "1.5.5", uv = "https://www.gstatic.com/draco/versioned/decoders/".concat(h7), d7 = "".concat(uv, "/draco_decoder.js"), f7 = "".concat(uv, "/draco_wasm_wrapper.js"), p7 = "".concat(uv, "/draco_decoder.wasm");
let jf;
async function g7(n) {
  const e = n.modules || {};
  return e.draco3d ? jf = jf || e.draco3d.createDecoderModule({}).then((t) => ({
    draco: t
  })) : jf = jf || m7(n), await jf;
}
async function m7(n) {
  let e, t;
  switch (n.draco && n.draco.decoderType) {
    case "js":
      e = await Rh(d7, "draco", n);
      break;
    case "wasm":
    default:
      [e, t] = await Promise.all([await Rh(f7, "draco", n), await Rh(p7, "draco", n)]);
  }
  return e = e || globalThis.DracoDecoderModule, await _7(e, t);
}
function _7(n, e) {
  const t = {};
  return e && (t.wasmBinary = e), new Promise((i) => {
    n({
      ...t,
      onModuleLoaded: (r) => i({
        draco: r
      })
    });
  });
}
const MS = {
  ...n7,
  parse: y7
};
async function y7(n, e) {
  const {
    draco: t
  } = await g7(e), i = new a7(t);
  try {
    return i.parseSync(n, e == null ? void 0 : e.draco);
  } finally {
    i.destroy();
  }
}
function v7(n) {
  const e = {};
  for (const t in n) {
    const i = n[t];
    if (t !== "indices") {
      const r = BS(i);
      e[t] = r;
    }
  }
  return e;
}
function BS(n) {
  const {
    buffer: e,
    size: t,
    count: i
  } = b7(n);
  return {
    value: e,
    size: t,
    byteOffset: 0,
    count: i,
    type: CS(t),
    componentType: IS(e)
  };
}
function b7(n) {
  let e = n, t = 1, i = 0;
  return n && n.value && (e = n.value, t = n.size || 1), e && (ArrayBuffer.isView(e) || (e = x7(e, Float32Array)), i = e.length / t), {
    buffer: e,
    size: t,
    count: i
  };
}
function x7(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  return n ? Array.isArray(n) ? new e(n) : t && !(n instanceof e) ? new e(n) : n : null;
}
const Uh = "KHR_draco_mesh_compression", w7 = Uh;
function A7(n, e, t) {
  const i = new Do(n);
  for (const r of RS(i))
    i.getObjectExtension(r, Uh);
}
async function E7(n, e, t) {
  var i;
  if (!(e != null && (i = e.gltf) !== null && i !== void 0 && i.decompressMeshes))
    return;
  const r = new Do(n), s = [];
  for (const c of RS(r))
    r.getObjectExtension(c, Uh) && s.push(T7(r, c, e, t));
  await Promise.all(s), r.removeExtension(Uh);
}
function S7(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = new Do(n);
  for (const i of t.json.meshes || [])
    C7(i, e), t.addRequiredExtension(Uh);
}
async function T7(n, e, t, i) {
  const r = n.getObjectExtension(e, Uh);
  if (!r)
    return;
  const s = n.getTypedArrayForBufferView(r.bufferView), c = p1(s.buffer, s.byteOffset), {
    parse: l
  } = i, m = {
    ...t
  };
  delete m["3d-tiles"];
  const y = await l(c, MS, m, i), A = v7(y.attributes);
  for (const [T, I] of Object.entries(A))
    if (T in e.attributes) {
      const L = e.attributes[T], N = n.getAccessor(L);
      N != null && N.min && N !== null && N !== void 0 && N.max && (I.min = N.min, I.max = N.max);
    }
  e.attributes = A, y.indices && (e.indices = BS(y.indices)), I7(e);
}
function C7(n, e) {
  var t;
  let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 4, r = arguments.length > 3 ? arguments[3] : void 0, s = arguments.length > 4 ? arguments[4] : void 0;
  if (!r.DracoWriter)
    throw new Error("options.gltf.DracoWriter not provided");
  const c = r.DracoWriter.encodeSync({
    attributes: n
  }), l = s == null || (t = s.parseSync) === null || t === void 0 ? void 0 : t.call(s, {
    attributes: n
  }), m = r._addFauxAttributes(l.attributes), y = r.addBufferView(c);
  return {
    primitives: [{
      attributes: m,
      mode: i,
      extensions: {
        [Uh]: {
          bufferView: y,
          attributes: m
        }
      }
    }]
  };
}
function I7(n) {
  if (!n.attributes && Object.keys(n.attributes).length > 0)
    throw new Error("glTF: Empty primitive detected: Draco decompression failure?");
}
function* RS(n) {
  for (const e of n.json.meshes || [])
    for (const t of e.primitives)
      yield t;
}
const P7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: E7,
  encode: S7,
  name: w7,
  preprocess: A7
}, Symbol.toStringTag, { value: "Module" })), L7 = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, M7 = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
}, hv = "KHR_texture_transform", B7 = hv, Mg = new Qe(), R7 = new Ir(), O7 = new Ir();
async function F7(n, e) {
  if (!new Do(n).getExtension(hv))
    return;
  const r = n.json.materials || [];
  for (let s = 0; s < r.length; s++)
    D7(s, n);
}
function D7(n, e) {
  var t, i, r;
  const s = [], c = (t = e.json.materials) === null || t === void 0 ? void 0 : t[n], l = c == null || (i = c.pbrMetallicRoughness) === null || i === void 0 ? void 0 : i.baseColorTexture;
  l && Gf(e, n, l, s);
  const m = c == null ? void 0 : c.emissiveTexture;
  m && Gf(e, n, m, s);
  const y = c == null ? void 0 : c.normalTexture;
  y && Gf(e, n, y, s);
  const A = c == null ? void 0 : c.occlusionTexture;
  A && Gf(e, n, A, s);
  const T = c == null || (r = c.pbrMetallicRoughness) === null || r === void 0 ? void 0 : r.metallicRoughnessTexture;
  T && Gf(e, n, T, s);
}
function Gf(n, e, t, i) {
  const r = k7(t, i);
  if (!r)
    return;
  const s = n.json.meshes || [];
  for (const c of s)
    for (const l of c.primitives) {
      const m = l.material;
      Number.isFinite(m) && e === m && N7(n, l, r);
    }
}
function k7(n, e) {
  var t;
  const i = (t = n.extensions) === null || t === void 0 ? void 0 : t[hv], {
    texCoord: r = 0
  } = n, {
    texCoord: s = r
  } = i;
  if (!(e.findIndex((l) => {
    let [m, y] = l;
    return m === r && y === s;
  }) !== -1)) {
    const l = j7(i);
    return r !== s && (n.texCoord = s), e.push([r, s]), {
      originalTexCoord: r,
      texCoord: s,
      matrix: l
    };
  }
  return null;
}
function N7(n, e, t) {
  const {
    originalTexCoord: i,
    texCoord: r,
    matrix: s
  } = t, c = e.attributes["TEXCOORD_".concat(i)];
  if (Number.isFinite(c)) {
    var l;
    const y = (l = n.json.accessors) === null || l === void 0 ? void 0 : l[c];
    if (y && y.bufferView) {
      var m;
      const A = (m = n.json.bufferViews) === null || m === void 0 ? void 0 : m[y.bufferView];
      if (A) {
        const {
          arrayBuffer: T,
          byteOffset: I
        } = n.buffers[A.buffer], L = (I || 0) + (y.byteOffset || 0) + (A.byteOffset || 0), {
          ArrayType: N,
          length: z
        } = lv(y, A), V = M7[y.componentType], H = L7[y.type], J = A.byteStride || V * H, ce = new Float32Array(z);
        for (let me = 0; me < y.count; me++) {
          const Se = new N(T, L + me * J, 2);
          Mg.set(Se[0], Se[1], 1), Mg.transformByMatrix3(s), ce.set([Mg[0], Mg[1]], me * H);
        }
        i === r ? z7(y, A, n.buffers, ce) : U7(r, y, e, n, ce);
      }
    }
  }
}
function z7(n, e, t, i) {
  n.componentType = 5126, t.push({
    arrayBuffer: i.buffer,
    byteOffset: 0,
    byteLength: i.buffer.byteLength
  }), e.buffer = t.length - 1, e.byteLength = i.buffer.byteLength, e.byteOffset = 0, delete e.byteStride;
}
function U7(n, e, t, i, r) {
  i.buffers.push({
    arrayBuffer: r.buffer,
    byteOffset: 0,
    byteLength: r.buffer.byteLength
  });
  const s = i.json.bufferViews;
  if (!s)
    return;
  s.push({
    buffer: i.buffers.length - 1,
    byteLength: r.buffer.byteLength,
    byteOffset: 0
  });
  const c = i.json.accessors;
  c && (c.push({
    bufferView: (s == null ? void 0 : s.length) - 1,
    byteOffset: 0,
    componentType: 5126,
    count: e.count,
    type: "VEC2"
  }), t.attributes["TEXCOORD_".concat(n)] = c.length - 1);
}
function j7(n) {
  const {
    offset: e = [0, 0],
    rotation: t = 0,
    scale: i = [1, 1]
  } = n, r = new Ir().set(1, 0, 0, 0, 1, 0, e[0], e[1], 1), s = R7.set(Math.cos(t), Math.sin(t), 0, -Math.sin(t), Math.cos(t), 0, 0, 0, 1), c = O7.set(i[0], 0, 0, 0, i[1], 0, 0, 0, 1);
  return r.multiplyRight(s).multiplyRight(c);
}
const G7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: F7,
  name: B7
}, Symbol.toStringTag, { value: "Module" })), Lh = "KHR_lights_punctual", V7 = Lh;
async function q7(n) {
  const e = new Do(n), {
    json: t
  } = e, i = e.getExtension(Lh);
  i && (e.json.lights = i.lights, e.removeExtension(Lh));
  for (const r of t.nodes || []) {
    const s = e.getObjectExtension(r, Lh);
    s && (r.light = s.light), e.removeObjectExtension(r, Lh);
  }
}
async function H7(n) {
  const e = new Do(n), {
    json: t
  } = e;
  if (t.lights) {
    const i = e.addExtension(Lh);
    fa(!i.lights), i.lights = t.lights, delete t.lights;
  }
  if (e.json.lights) {
    for (const i of e.json.lights) {
      const r = i.node;
      e.addObjectExtension(r, Lh, i);
    }
    delete e.json.lights;
  }
}
const W7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: q7,
  encode: H7,
  name: V7
}, Symbol.toStringTag, { value: "Module" })), yp = "KHR_materials_unlit", X7 = yp;
async function J7(n) {
  const e = new Do(n), {
    json: t
  } = e;
  for (const i of t.materials || [])
    i.extensions && i.extensions.KHR_materials_unlit && (i.unlit = !0), e.removeObjectExtension(i, yp);
  e.removeExtension(yp);
}
function $7(n) {
  const e = new Do(n), {
    json: t
  } = e;
  if (e.materials)
    for (const i of t.materials || [])
      i.unlit && (delete i.unlit, e.addObjectExtension(i, yp, {}), e.addExtension(yp));
}
const Z7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: J7,
  encode: $7,
  name: X7
}, Symbol.toStringTag, { value: "Module" })), Kf = "KHR_techniques_webgl", Y7 = Kf;
async function K7(n) {
  const e = new Do(n), {
    json: t
  } = e, i = e.getExtension(Kf);
  if (i) {
    const r = e9(i, e);
    for (const s of t.materials || []) {
      const c = e.getObjectExtension(s, Kf);
      c && (s.technique = Object.assign({}, c, r[c.technique]), s.technique.values = t9(s.technique, e)), e.removeObjectExtension(s, Kf);
    }
    e.removeExtension(Kf);
  }
}
async function Q7(n, e) {
}
function e9(n, e) {
  const {
    programs: t = [],
    shaders: i = [],
    techniques: r = []
  } = n, s = new TextDecoder();
  return i.forEach((c) => {
    if (Number.isFinite(c.bufferView))
      c.code = s.decode(e.getTypedArrayForBufferView(c.bufferView));
    else
      throw new Error("KHR_techniques_webgl: no shader code");
  }), t.forEach((c) => {
    c.fragmentShader = i[c.fragmentShader], c.vertexShader = i[c.vertexShader];
  }), r.forEach((c) => {
    c.program = t[c.program];
  }), r;
}
function t9(n, e) {
  const t = Object.assign({}, n.values);
  return Object.keys(n.uniforms || {}).forEach((i) => {
    n.uniforms[i].value && !(i in t) && (t[i] = n.uniforms[i].value);
  }), Object.keys(t).forEach((i) => {
    typeof t[i] == "object" && t[i].index !== void 0 && (t[i].texture = e.getTexture(t[i].index));
  }), t;
}
const n9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: K7,
  encode: Q7,
  name: Y7
}, Symbol.toStringTag, { value: "Module" })), OS = "EXT_feature_metadata", i9 = OS;
async function r9(n) {
  const e = new Do(n);
  s9(e);
}
function s9(n) {
  var e;
  const t = n.getExtension(OS), i = t == null || (e = t.schema) === null || e === void 0 ? void 0 : e.classes, r = t == null ? void 0 : t.featureTables;
  if ((t == null ? void 0 : t.featureTextures) && console.warn('featureTextures is not yet supported in the "EXT_feature_metadata" extension.'), i && r)
    for (const c in i) {
      const l = i[c], m = l9(r, c);
      m && o9(n, m, l);
    }
}
function o9(n, e, t) {
  for (const r in t.properties) {
    var i;
    const s = t.properties[r], c = e == null || (i = e.properties) === null || i === void 0 ? void 0 : i[r], l = e.count;
    if (c) {
      const m = a9(n, s, l, c);
      c.data = m;
    }
  }
}
function a9(n, e, t, i) {
  const r = i.bufferView;
  let s = n.getTypedArrayForBufferView(r);
  switch (e.type) {
    case "STRING": {
      const c = i.stringOffsetBufferView, l = n.getTypedArrayForBufferView(c);
      s = c9(s, l, t);
      break;
    }
  }
  return s;
}
function l9(n, e) {
  for (const t in n) {
    const i = n[t];
    if (i.class === e)
      return i;
  }
  return null;
}
function c9(n, e, t) {
  const i = [], r = new TextDecoder("utf8");
  let s = 0;
  const c = 4;
  for (let l = 0; l < t; l++) {
    const m = e[(l + 1) * c] - e[l * c], y = n.subarray(s, m + s), A = r.decode(y);
    i.push(A), s += m;
  }
  return i;
}
const u9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: r9,
  name: i9
}, Symbol.toStringTag, { value: "Module" })), FS = [Xz, Zz, Qz, P7, W7, Z7, n9, G7, u9];
function h9(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = arguments.length > 2 ? arguments[2] : void 0;
  const i = FS.filter((s) => DS(s.name, e));
  for (const s of i) {
    var r;
    (r = s.preprocess) === null || r === void 0 || r.call(s, n, e, t);
  }
}
async function d9(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = arguments.length > 2 ? arguments[2] : void 0;
  const i = FS.filter((s) => DS(s.name, e));
  for (const s of i) {
    var r;
    await ((r = s.decode) === null || r === void 0 ? void 0 : r.call(s, n, e, t));
  }
}
function DS(n, e) {
  var t;
  const i = (e == null || (t = e.gltf) === null || t === void 0 ? void 0 : t.excludeExtensions) || {};
  return !(n in i && !i[n]);
}
const x_ = "KHR_binary_glTF";
function f9(n) {
  const e = new Do(n), {
    json: t
  } = e;
  for (const i of t.images || []) {
    const r = e.getObjectExtension(i, x_);
    r && Object.assign(i, r), e.removeObjectExtension(i, x_);
  }
  t.buffers && t.buffers[0] && delete t.buffers[0].uri, e.removeExtension(x_);
}
const jw = {
  accessors: "accessor",
  animations: "animation",
  buffers: "buffer",
  bufferViews: "bufferView",
  images: "image",
  materials: "material",
  meshes: "mesh",
  nodes: "node",
  samplers: "sampler",
  scenes: "scene",
  skins: "skin",
  textures: "texture"
}, p9 = {
  accessor: "accessors",
  animations: "animation",
  buffer: "buffers",
  bufferView: "bufferViews",
  image: "images",
  material: "materials",
  mesh: "meshes",
  node: "nodes",
  sampler: "samplers",
  scene: "scenes",
  skin: "skins",
  texture: "textures"
};
class g9 {
  constructor() {
    G(this, "idToIndexMap", {
      animations: {},
      accessors: {},
      buffers: {},
      bufferViews: {},
      images: {},
      materials: {},
      meshes: {},
      nodes: {},
      samplers: {},
      scenes: {},
      skins: {},
      textures: {}
    }), G(this, "json", void 0);
  }
  normalize(e, t) {
    this.json = e.json;
    const i = e.json;
    switch (i.asset && i.asset.version) {
      case "2.0":
        return;
      case void 0:
      case "1.0":
        break;
      default:
        console.warn("glTF: Unknown version ".concat(i.asset.version));
        return;
    }
    if (!t.normalize)
      throw new Error("glTF v1 is not supported.");
    console.warn("Converting glTF v1 to glTF v2 format. This is experimental and may fail."), this._addAsset(i), this._convertTopLevelObjectsToArrays(i), f9(e), this._convertObjectIdsToArrayIndices(i), this._updateObjects(i), this._updateMaterial(i);
  }
  _addAsset(e) {
    e.asset = e.asset || {}, e.asset.version = "2.0", e.asset.generator = e.asset.generator || "Normalized to glTF 2.0 by loaders.gl";
  }
  _convertTopLevelObjectsToArrays(e) {
    for (const t in jw)
      this._convertTopLevelObjectToArray(e, t);
  }
  _convertTopLevelObjectToArray(e, t) {
    const i = e[t];
    if (!(!i || Array.isArray(i))) {
      e[t] = [];
      for (const r in i) {
        const s = i[r];
        s.id = s.id || r;
        const c = e[t].length;
        e[t].push(s), this.idToIndexMap[t][r] = c;
      }
    }
  }
  _convertObjectIdsToArrayIndices(e) {
    for (const t in jw)
      this._convertIdsToIndices(e, t);
    "scene" in e && (e.scene = this._convertIdToIndex(e.scene, "scene"));
    for (const t of e.textures)
      this._convertTextureIds(t);
    for (const t of e.meshes)
      this._convertMeshIds(t);
    for (const t of e.nodes)
      this._convertNodeIds(t);
    for (const t of e.scenes)
      this._convertSceneIds(t);
  }
  _convertTextureIds(e) {
    e.source && (e.source = this._convertIdToIndex(e.source, "image"));
  }
  _convertMeshIds(e) {
    for (const t of e.primitives) {
      const {
        attributes: i,
        indices: r,
        material: s
      } = t;
      for (const c in i)
        i[c] = this._convertIdToIndex(i[c], "accessor");
      r && (t.indices = this._convertIdToIndex(r, "accessor")), s && (t.material = this._convertIdToIndex(s, "material"));
    }
  }
  _convertNodeIds(e) {
    e.children && (e.children = e.children.map((t) => this._convertIdToIndex(t, "node"))), e.meshes && (e.meshes = e.meshes.map((t) => this._convertIdToIndex(t, "mesh")));
  }
  _convertSceneIds(e) {
    e.nodes && (e.nodes = e.nodes.map((t) => this._convertIdToIndex(t, "node")));
  }
  _convertIdsToIndices(e, t) {
    e[t] || (console.warn("gltf v1: json doesn't contain attribute ".concat(t)), e[t] = []);
    for (const i of e[t])
      for (const r in i) {
        const s = i[r], c = this._convertIdToIndex(s, r);
        i[r] = c;
      }
  }
  _convertIdToIndex(e, t) {
    const i = p9[t];
    if (i in this.idToIndexMap) {
      const r = this.idToIndexMap[i][e];
      if (!Number.isFinite(r))
        throw new Error("gltf v1: failed to resolve ".concat(t, " with id ").concat(e));
      return r;
    }
    return e;
  }
  _updateObjects(e) {
    for (const t of this.json.buffers)
      delete t.type;
  }
  _updateMaterial(e) {
    for (const s of e.materials) {
      var t, i, r;
      s.pbrMetallicRoughness = {
        baseColorFactor: [1, 1, 1, 1],
        metallicFactor: 1,
        roughnessFactor: 1
      };
      const c = ((t = s.values) === null || t === void 0 ? void 0 : t.tex) || ((i = s.values) === null || i === void 0 ? void 0 : i.texture2d_0) || ((r = s.values) === null || r === void 0 ? void 0 : r.diffuseTex), l = e.textures.findIndex((m) => m.id === c);
      l !== -1 && (s.pbrMetallicRoughness.baseColorTexture = {
        index: l
      });
    }
  }
}
function m9(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new g9().normalize(n, e);
}
const _9 = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, y9 = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
}, Ha = {
  TEXTURE_MAG_FILTER: 10240,
  TEXTURE_MIN_FILTER: 10241,
  TEXTURE_WRAP_S: 10242,
  TEXTURE_WRAP_T: 10243,
  REPEAT: 10497,
  LINEAR: 9729,
  NEAREST_MIPMAP_LINEAR: 9986
}, v9 = {
  magFilter: Ha.TEXTURE_MAG_FILTER,
  minFilter: Ha.TEXTURE_MIN_FILTER,
  wrapS: Ha.TEXTURE_WRAP_S,
  wrapT: Ha.TEXTURE_WRAP_T
}, b9 = {
  [Ha.TEXTURE_MAG_FILTER]: Ha.LINEAR,
  [Ha.TEXTURE_MIN_FILTER]: Ha.NEAREST_MIPMAP_LINEAR,
  [Ha.TEXTURE_WRAP_S]: Ha.REPEAT,
  [Ha.TEXTURE_WRAP_T]: Ha.REPEAT
};
function x9(n) {
  return y9[n];
}
function w9(n) {
  return _9[n];
}
class A9 {
  constructor() {
    G(this, "baseUri", ""), G(this, "json", {}), G(this, "buffers", []), G(this, "images", []);
  }
  postProcess(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      json: i,
      buffers: r = [],
      images: s = [],
      baseUri: c = ""
    } = e;
    return fa(i), this.baseUri = c, this.json = i, this.buffers = r, this.images = s, this._resolveTree(this.json, t), this.json;
  }
  _resolveTree(e) {
    e.bufferViews && (e.bufferViews = e.bufferViews.map((t, i) => this._resolveBufferView(t, i))), e.images && (e.images = e.images.map((t, i) => this._resolveImage(t, i))), e.samplers && (e.samplers = e.samplers.map((t, i) => this._resolveSampler(t, i))), e.textures && (e.textures = e.textures.map((t, i) => this._resolveTexture(t, i))), e.accessors && (e.accessors = e.accessors.map((t, i) => this._resolveAccessor(t, i))), e.materials && (e.materials = e.materials.map((t, i) => this._resolveMaterial(t, i))), e.meshes && (e.meshes = e.meshes.map((t, i) => this._resolveMesh(t, i))), e.nodes && (e.nodes = e.nodes.map((t, i) => this._resolveNode(t, i))), e.skins && (e.skins = e.skins.map((t, i) => this._resolveSkin(t, i))), e.scenes && (e.scenes = e.scenes.map((t, i) => this._resolveScene(t, i))), e.scene !== void 0 && (e.scene = e.scenes[this.json.scene]);
  }
  getScene(e) {
    return this._get("scenes", e);
  }
  getNode(e) {
    return this._get("nodes", e);
  }
  getSkin(e) {
    return this._get("skins", e);
  }
  getMesh(e) {
    return this._get("meshes", e);
  }
  getMaterial(e) {
    return this._get("materials", e);
  }
  getAccessor(e) {
    return this._get("accessors", e);
  }
  getCamera(e) {
    return null;
  }
  getTexture(e) {
    return this._get("textures", e);
  }
  getSampler(e) {
    return this._get("samplers", e);
  }
  getImage(e) {
    return this._get("images", e);
  }
  getBufferView(e) {
    return this._get("bufferViews", e);
  }
  getBuffer(e) {
    return this._get("buffers", e);
  }
  _get(e, t) {
    if (typeof t == "object")
      return t;
    const i = this.json[e] && this.json[e][t];
    return i || console.warn("glTF file error: Could not find ".concat(e, "[").concat(t, "]")), i;
  }
  _resolveScene(e, t) {
    return e.id = e.id || "scene-".concat(t), e.nodes = (e.nodes || []).map((i) => this.getNode(i)), e;
  }
  _resolveNode(e, t) {
    return e.id = e.id || "node-".concat(t), e.children && (e.children = e.children.map((i) => this.getNode(i))), e.mesh !== void 0 ? e.mesh = this.getMesh(e.mesh) : e.meshes !== void 0 && e.meshes.length && (e.mesh = e.meshes.reduce((i, r) => {
      const s = this.getMesh(r);
      return i.id = s.id, i.primitives = i.primitives.concat(s.primitives), i;
    }, {
      primitives: []
    })), e.camera !== void 0 && (e.camera = this.getCamera(e.camera)), e.skin !== void 0 && (e.skin = this.getSkin(e.skin)), e;
  }
  _resolveSkin(e, t) {
    return e.id = e.id || "skin-".concat(t), e.inverseBindMatrices = this.getAccessor(e.inverseBindMatrices), e;
  }
  _resolveMesh(e, t) {
    return e.id = e.id || "mesh-".concat(t), e.primitives && (e.primitives = e.primitives.map((i) => {
      i = {
        ...i
      };
      const r = i.attributes;
      i.attributes = {};
      for (const s in r)
        i.attributes[s] = this.getAccessor(r[s]);
      return i.indices !== void 0 && (i.indices = this.getAccessor(i.indices)), i.material !== void 0 && (i.material = this.getMaterial(i.material)), i;
    })), e;
  }
  _resolveMaterial(e, t) {
    if (e.id = e.id || "material-".concat(t), e.normalTexture && (e.normalTexture = {
      ...e.normalTexture
    }, e.normalTexture.texture = this.getTexture(e.normalTexture.index)), e.occlusionTexture && (e.occlustionTexture = {
      ...e.occlustionTexture
    }, e.occlusionTexture.texture = this.getTexture(e.occlusionTexture.index)), e.emissiveTexture && (e.emmisiveTexture = {
      ...e.emmisiveTexture
    }, e.emissiveTexture.texture = this.getTexture(e.emissiveTexture.index)), e.emissiveFactor || (e.emissiveFactor = e.emmisiveTexture ? [1, 1, 1] : [0, 0, 0]), e.pbrMetallicRoughness) {
      e.pbrMetallicRoughness = {
        ...e.pbrMetallicRoughness
      };
      const i = e.pbrMetallicRoughness;
      i.baseColorTexture && (i.baseColorTexture = {
        ...i.baseColorTexture
      }, i.baseColorTexture.texture = this.getTexture(i.baseColorTexture.index)), i.metallicRoughnessTexture && (i.metallicRoughnessTexture = {
        ...i.metallicRoughnessTexture
      }, i.metallicRoughnessTexture.texture = this.getTexture(i.metallicRoughnessTexture.index));
    }
    return e;
  }
  _resolveAccessor(e, t) {
    if (e.id = e.id || "accessor-".concat(t), e.bufferView !== void 0 && (e.bufferView = this.getBufferView(e.bufferView)), e.bytesPerComponent = x9(e.componentType), e.components = w9(e.type), e.bytesPerElement = e.bytesPerComponent * e.components, e.bufferView) {
      const i = e.bufferView.buffer, {
        ArrayType: r,
        byteLength: s
      } = lv(e, e.bufferView), c = (e.bufferView.byteOffset || 0) + (e.byteOffset || 0) + i.byteOffset;
      let l = i.arrayBuffer.slice(c, c + s);
      e.bufferView.byteStride && (l = this._getValueFromInterleavedBuffer(i, c, e.bufferView.byteStride, e.bytesPerElement, e.count)), e.value = new r(l);
    }
    return e;
  }
  _getValueFromInterleavedBuffer(e, t, i, r, s) {
    const c = new Uint8Array(s * r);
    for (let l = 0; l < s; l++) {
      const m = t + l * i;
      c.set(new Uint8Array(e.arrayBuffer.slice(m, m + r)), l * r);
    }
    return c.buffer;
  }
  _resolveTexture(e, t) {
    return e.id = e.id || "texture-".concat(t), e.sampler = "sampler" in e ? this.getSampler(e.sampler) : b9, e.source = this.getImage(e.source), e;
  }
  _resolveSampler(e, t) {
    e.id = e.id || "sampler-".concat(t), e.parameters = {};
    for (const i in e) {
      const r = this._enumSamplerParameter(i);
      r !== void 0 && (e.parameters[r] = e[i]);
    }
    return e;
  }
  _enumSamplerParameter(e) {
    return v9[e];
  }
  _resolveImage(e, t) {
    e.id = e.id || "image-".concat(t), e.bufferView !== void 0 && (e.bufferView = this.getBufferView(e.bufferView));
    const i = this.images[t];
    return i && (e.image = i), e;
  }
  _resolveBufferView(e, t) {
    const i = e.buffer, r = {
      id: "bufferView-".concat(t),
      ...e,
      buffer: this.buffers[i]
    }, s = this.buffers[i].arrayBuffer;
    let c = this.buffers[i].byteOffset || 0;
    return "byteOffset" in e && (c += e.byteOffset), r.data = new Uint8Array(s, c, e.byteLength), r;
  }
  _resolveCamera(e, t) {
    return e.id = e.id || "camera-".concat(t), e.perspective, e.orthographic, e;
  }
}
function E9(n, e) {
  return new A9().postProcess(n, e);
}
const Gw = 1735152710, dv = 12, Em = 8, S9 = 1313821514, T9 = 5130562, C9 = 0, I9 = 1, P9 = 0, Jd = !0;
function L9(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return "".concat(String.fromCharCode(n.getUint8(e + 0))).concat(String.fromCharCode(n.getUint8(e + 1))).concat(String.fromCharCode(n.getUint8(e + 2))).concat(String.fromCharCode(n.getUint8(e + 3)));
}
function M9(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const i = new DataView(n), {
    magic: r = Gw
  } = t, s = i.getUint32(e, !1);
  return s === r || s === Gw;
}
function B9(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const i = new DataView(e), r = L9(i, t + 0), s = i.getUint32(t + 4, Jd), c = i.getUint32(t + 8, Jd);
  switch (Object.assign(n, {
    header: {
      byteOffset: t,
      byteLength: c,
      hasBinChunk: !1
    },
    type: r,
    version: s,
    json: {},
    binChunks: []
  }), t += dv, n.version) {
    case 1:
      return R9(n, i, t);
    case 2:
      return O9(n, i, t, {});
    default:
      throw new Error("Invalid GLB version ".concat(n.version, ". Only supports v1 and v2."));
  }
}
function R9(n, e, t) {
  Qi(n.header.byteLength > dv + Em);
  const i = e.getUint32(t + 0, Jd), r = e.getUint32(t + 4, Jd);
  return t += Em, Qi(r === P9), By(n, e, t, i), t += i, t += Ry(n, e, t, n.header.byteLength), t;
}
function O9(n, e, t, i) {
  return Qi(n.header.byteLength > dv + Em), F9(n, e, t, i), t + n.header.byteLength;
}
function F9(n, e, t, i) {
  for (; t + 8 <= n.header.byteLength; ) {
    const r = e.getUint32(t + 0, Jd), s = e.getUint32(t + 4, Jd);
    switch (t += Em, s) {
      case S9:
        By(n, e, t, r);
        break;
      case T9:
        Ry(n, e, t, r);
        break;
      case C9:
        i.strict || By(n, e, t, r);
        break;
      case I9:
        i.strict || Ry(n, e, t, r);
        break;
    }
    t += Tp(r, 4);
  }
  return t;
}
function By(n, e, t, i) {
  const r = new Uint8Array(e.buffer, t, i), c = new TextDecoder("utf8").decode(r);
  return n.json = JSON.parse(c), Tp(i, 4);
}
function Ry(n, e, t, i) {
  return n.header.hasBinChunk = !0, n.binChunks.push({
    byteOffset: t,
    byteLength: i,
    arrayBuffer: e.buffer
  }), Tp(i, 4);
}
async function D9(n, e) {
  var t, i, r, s;
  let c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, l = arguments.length > 3 ? arguments[3] : void 0, m = arguments.length > 4 ? arguments[4] : void 0;
  k9(n, e, c, l), m9(n, {
    normalize: l == null || (t = l.gltf) === null || t === void 0 ? void 0 : t.normalize
  }), h9(n, l, m);
  const y = [];
  if (l != null && (i = l.gltf) !== null && i !== void 0 && i.loadBuffers && n.json.buffers && await N9(n, l, m), l != null && (r = l.gltf) !== null && r !== void 0 && r.loadImages) {
    const T = z9(n, l, m);
    y.push(T);
  }
  const A = d9(n, l, m);
  return y.push(A), await Promise.all(y), l != null && (s = l.gltf) !== null && s !== void 0 && s.postProcess ? E9(n, l) : n;
}
function k9(n, e, t, i) {
  if (i.uri && (n.baseUri = i.uri), e instanceof ArrayBuffer && !M9(e, t, i) && (e = new TextDecoder().decode(e)), typeof e == "string")
    n.json = YI(e);
  else if (e instanceof ArrayBuffer) {
    const c = {};
    t = B9(c, e, t, i.glb), fa(c.type === "glTF", "Invalid GLB magic string ".concat(c.type)), n._glb = c, n.json = c.json;
  } else
    fa(!1, "GLTF: must be ArrayBuffer or string");
  const r = n.json.buffers || [];
  if (n.buffers = new Array(r.length).fill(null), n._glb && n._glb.header.hasBinChunk) {
    const {
      binChunks: c
    } = n._glb;
    n.buffers[0] = {
      arrayBuffer: c[0].arrayBuffer,
      byteOffset: c[0].byteOffset,
      byteLength: c[0].byteLength
    };
  }
  const s = n.json.images || [];
  n.images = new Array(s.length).fill({});
}
async function N9(n, e, t) {
  const i = n.json.buffers || [];
  for (let c = 0; c < i.length; ++c) {
    const l = i[c];
    if (l.uri) {
      var r, s;
      const {
        fetch: m
      } = t;
      fa(m);
      const y = TS(l.uri, e), A = await (t == null || (r = t.fetch) === null || r === void 0 ? void 0 : r.call(t, y)), T = await (A == null || (s = A.arrayBuffer) === null || s === void 0 ? void 0 : s.call(A));
      n.buffers[c] = {
        arrayBuffer: T,
        byteOffset: 0,
        byteLength: T.byteLength
      }, delete l.uri;
    } else
      n.buffers[c] === null && (n.buffers[c] = {
        arrayBuffer: new ArrayBuffer(l.byteLength),
        byteOffset: 0,
        byteLength: l.byteLength
      });
  }
}
async function z9(n, e, t) {
  const i = U9(n), r = n.json.images || [], s = [];
  for (const c of i)
    s.push(j9(n, r[c], c, e, t));
  return await Promise.all(s);
}
function U9(n) {
  const e = /* @__PURE__ */ new Set(), t = n.json.textures || [];
  for (const i of t)
    i.source !== void 0 && e.add(i.source);
  return Array.from(e).sort();
}
async function j9(n, e, t, i, r) {
  const {
    fetch: s,
    parse: c
  } = r;
  let l;
  if (e.uri && !e.hasOwnProperty("bufferView")) {
    const y = TS(e.uri, i);
    l = await (await s(y)).arrayBuffer(), e.bufferView = {
      data: l
    };
  }
  if (Number.isFinite(e.bufferView)) {
    const y = Tz(n.json, n.buffers, e.bufferView);
    l = p1(y.buffer, y.byteOffset, y.byteLength);
  }
  fa(l, "glTF image has no data");
  let m = await c(l, [N5, Sz], {
    mimeType: e.mimeType,
    basis: i.basis || {
      format: SS()
    }
  }, r);
  m && m[0] && (m = {
    compressed: !0,
    mipmaps: !1,
    width: m[0].width,
    height: m[0].height,
    data: m[0]
  }), n.images = n.images || [], n.images[t] = m;
}
const vp = {
  name: "glTF",
  id: "gltf",
  module: "gltf",
  version: lz,
  extensions: ["gltf", "glb"],
  mimeTypes: ["model/gltf+json", "model/gltf-binary"],
  text: !0,
  binary: !0,
  tests: ["glTF"],
  parse: G9,
  options: {
    gltf: {
      normalize: !0,
      loadBuffers: !0,
      loadImages: !0,
      decompressMeshes: !0,
      postProcess: !0
    },
    log: console
  },
  deprecatedOptions: {
    fetchImages: "gltf.loadImages",
    createImages: "gltf.loadImages",
    decompress: "gltf.decompressMeshes",
    postProcess: "gltf.postProcess",
    gltf: {
      decompress: "gltf.decompressMeshes"
    }
  }
};
async function G9(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = arguments.length > 2 ? arguments[2] : void 0;
  e = {
    ...vp.options,
    ...e
  }, e.gltf = {
    ...vp.options.gltf,
    ...e.gltf
  };
  const {
    byteOffset: i = 0
  } = e;
  return await D9({}, n, i, e, t);
}
async function V9(n) {
  const e = [];
  return n.scenes.forEach((t) => {
    t.traverse((i) => {
      Object.values(i.model.getUniforms()).forEach((r) => {
        r.loaded === !1 && e.push(r);
      });
    });
  }), await q9(() => e.some((t) => !t.loaded));
}
async function q9(n) {
  for (; n(); )
    await new Promise((e) => requestAnimationFrame(e));
}
const H9 = `#version 300 es
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in mat3 instanceModelMatrix;
in vec3 instanceTranslation;
uniform float sizeScale;
uniform float sizeMinPixels;
uniform float sizeMaxPixels;
uniform mat4 sceneModelMatrix;
uniform bool composeModelMatrix;
in vec4 POSITION;

#ifdef HAS_UV
  in vec2 TEXCOORD_0;
#endif

#ifdef MODULE_PBR
  #ifdef HAS_NORMALS
    in vec4 NORMAL;
  #endif
#endif
out vec4 vColor;
#ifndef MODULE_PBR
  #ifdef HAS_UV
    out vec2 vTEXCOORD_0;
  #endif
#endif
void main(void) {
  #if defined(HAS_UV) && !defined(MODULE_PBR)
    vTEXCOORD_0 = TEXCOORD_0;
    geometry.uv = vTEXCOORD_0;
  #endif

  geometry.worldPosition = instancePositions;
  geometry.pickingColor = instancePickingColors;

  vec3 normal = vec3(0.0, 0.0, 1.0);
  #ifdef MODULE_PBR
    #ifdef HAS_NORMALS
      normal = instanceModelMatrix * (sceneModelMatrix * vec4(NORMAL.xyz, 0.0)).xyz;
    #endif
  #endif

  float originalSize = project_size_to_pixel(sizeScale);
  float clampedSize = clamp(originalSize, sizeMinPixels, sizeMaxPixels);

  vec3 pos = (instanceModelMatrix * (sceneModelMatrix * POSITION).xyz) * sizeScale * (clampedSize / originalSize) + instanceTranslation;
  if(composeModelMatrix) {
    DECKGL_FILTER_SIZE(pos, geometry);
    geometry.normal = project_normal(normal);
    geometry.worldPosition += pos;
    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
  }
  else {
    pos = project_size(pos);
    DECKGL_FILTER_SIZE(pos, geometry);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);
    geometry.normal = project_normal(normal);
  }
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  #ifdef MODULE_PBR
    pbr_vPosition = geometry.position.xyz;
    #ifdef HAS_NORMALS
      pbr_vNormal = geometry.normal;
    #endif

    #ifdef HAS_UV
      pbr_vUV = TEXCOORD_0;
    #else
      pbr_vUV = vec2(0., 0.);
    #endif
    geometry.uv = pbr_vUV;
  #endif

  vColor = instanceColors;
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`, W9 = `#version 300 es
uniform float opacity;
in vec4 vColor;

out vec4 fragmentColor;
#ifndef MODULE_PBR
  #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
    in vec2 vTEXCOORD_0;
    uniform sampler2D u_BaseColorSampler;
  #endif
#endif

void main(void) {
  #ifdef MODULE_PBR
    fragmentColor = vColor * pbr_filterColor(vec4(0));
    geometry.uv = pbr_vUV;
  #else
    #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
      fragmentColor = vColor * texture2D(u_BaseColorSampler, vTEXCOORD_0);
      geometry.uv = vTEXCOORD_0;
    #else
      fragmentColor = vColor;
    #endif
  #endif

  fragmentColor.a *= opacity;
  DECKGL_FILTER_COLOR(fragmentColor, geometry);
}
`, kS = [255, 255, 255, 255], X9 = {
  scenegraph: {
    type: "object",
    value: null,
    async: !0
  },
  getScene: (n) => n && n.scenes ? typeof n.scene == "object" ? n.scene : n.scenes[n.scene || 0] : n,
  getAnimator: (n) => n && n.animator,
  _animations: null,
  sizeScale: {
    type: "number",
    value: 1,
    min: 0
  },
  sizeMinPixels: {
    type: "number",
    min: 0,
    value: 0
  },
  sizeMaxPixels: {
    type: "number",
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  getPosition: {
    type: "accessor",
    value: (n) => n.position
  },
  getColor: {
    type: "accessor",
    value: kS
  },
  _lighting: "flat",
  _imageBasedLightingEnvironment: null,
  getOrientation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  getScale: {
    type: "accessor",
    value: [1, 1, 1]
  },
  getTranslation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  getTransformMatrix: {
    type: "accessor",
    value: []
  },
  loaders: [vp]
};
class fv extends ef {
  constructor() {
    super(...arguments), G(this, "state", void 0);
  }
  getShaders() {
    const e = [J1, $1];
    return this.props._lighting === "pbr" && e.push(j1), super.getShaders({
      vs: H9,
      fs: W9,
      modules: e
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        accessor: "getPosition",
        transition: !0
      },
      instanceColors: {
        type: 5121,
        size: this.props.colorFormat.length,
        accessor: "getColor",
        normalized: !0,
        defaultValue: kS,
        transition: !0
      },
      instanceModelMatrix: pS
    });
  }
  updateState(e) {
    super.updateState(e);
    const {
      props: t,
      oldProps: i
    } = e;
    t.scenegraph !== i.scenegraph ? this._updateScenegraph() : t._animations !== i._animations && this._applyAnimationsProp(this.state.scenegraph, this.state.animator, t._animations);
  }
  finalizeState(e) {
    super.finalizeState(e), this._deleteScenegraph();
  }
  get isLoaded() {
    var e;
    return ((e = this.state) === null || e === void 0 ? void 0 : e.scenegraph) && super.isLoaded;
  }
  _updateScenegraph() {
    const e = this.props, {
      gl: t
    } = this.context;
    let i = null;
    if (e.scenegraph instanceof Rd)
      i = {
        scenes: [e.scenegraph]
      };
    else if (e.scenegraph && !e.scenegraph.gltf) {
      const l = e.scenegraph, m = az(t, l, this._getModelOptions());
      i = {
        gltf: l,
        ...m
      }, V9(m).then(() => this.setNeedsRedraw());
    } else
      e.scenegraph && (hi.deprecated("ScenegraphLayer.props.scenegraph", "Use GLTFLoader instead of GLTFScenegraphLoader")(), i = e.scenegraph);
    const r = {
      layer: this,
      gl: t
    }, s = e.getScene(i, r), c = e.getAnimator(i, r);
    s instanceof Rd ? (this._deleteScenegraph(), this._applyAllAttributes(s), this._applyAnimationsProp(s, c, e._animations), this.setState({
      scenegraph: s,
      animator: c
    })) : s !== null && hi.warn("invalid scenegraph:", s)();
  }
  _applyAllAttributes(e) {
    if (this.state.attributesAvailable) {
      const t = this.getAttributeManager().getAttributes();
      e.traverse((i) => {
        this._setModelAttributes(i.model, t);
      });
    }
  }
  _applyAnimationsProp(e, t, i) {
    if (!e || !t || !i)
      return;
    const r = t.getAnimations();
    Object.keys(i).sort().forEach((s) => {
      const c = i[s];
      if (s === "*")
        r.forEach((l) => {
          Object.assign(l, c);
        });
      else if (Number.isFinite(Number(s))) {
        const l = Number(s);
        l >= 0 && l < r.length ? Object.assign(r[l], c) : hi.warn("animation ".concat(s, " not found"))();
      } else {
        const l = r.find((m) => {
          let {
            name: y
          } = m;
          return y === s;
        });
        l ? Object.assign(l, c) : hi.warn("animation ".concat(s, " not found"))();
      }
    });
  }
  _deleteScenegraph() {
    const {
      scenegraph: e
    } = this.state;
    e instanceof Rd && e.delete();
  }
  _getModelOptions() {
    const {
      _imageBasedLightingEnvironment: e
    } = this.props;
    let t = null;
    return e && (typeof e == "function" ? t = e({
      gl: this.context.gl,
      layer: this
    }) : t = e), {
      gl: this.context.gl,
      waitForFullLoad: !0,
      imageBasedLightingEnvironment: t,
      modelOptions: {
        isInstanced: !0,
        transpileToGLSL100: !ei(this.context.gl),
        ...this.getShaders()
      },
      useTangents: !1
    };
  }
  updateAttributes(e) {
    this.setState({
      attributesAvailable: !0
    }), this.state.scenegraph && this.state.scenegraph.traverse((t) => {
      this._setModelAttributes(t.model, e);
    });
  }
  draw(e) {
    let {
      moduleParameters: t = null,
      parameters: i = {},
      context: r
    } = e;
    if (!this.state.scenegraph)
      return;
    this.props._animations && this.state.animator && (this.state.animator.animate(r.timeline.getTime()), this.setNeedsRedraw());
    const {
      viewport: s
    } = this.context, {
      sizeScale: c,
      sizeMinPixels: l,
      sizeMaxPixels: m,
      opacity: y,
      coordinateSystem: A
    } = this.props, T = this.getNumInstances();
    this.state.scenegraph.traverse((I, L) => {
      let {
        worldMatrix: N
      } = L;
      I.model.setInstanceCount(T), I.updateModuleSettings(t), I.draw({
        parameters: i,
        uniforms: {
          sizeScale: c,
          opacity: y,
          sizeMinPixels: l,
          sizeMaxPixels: m,
          composeModelMatrix: gS(s, A),
          sceneModelMatrix: N,
          u_Camera: I.model.getUniforms().project_uCameraPosition
        }
      });
    });
  }
}
G(fv, "defaultProps", X9);
G(fv, "layerName", "ScenegraphLayer");
const J9 = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs
uniform float sizeScale;
uniform bool composeModelMatrix;
uniform bool pickFeatureIds;
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec4 uvRegions;
in vec3 featureIdsPickingColors;
in vec4 instanceColors;
in vec3 instancePickingColors;
in mat3 instanceModelMatrix;
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;

vec2 applyUVRegion(vec2 uv) {
  #ifdef HAS_UV_REGIONS
    return fract(uv) * (uvRegions.zw - uvRegions.xy) + uvRegions.xy;
  #else
    return uv;
  #endif
}

void main(void) {
  vec2 uv = applyUVRegion(texCoords);
  geometry.uv = uv;

  if (pickFeatureIds) {
    geometry.pickingColor = featureIdsPickingColors;
  } else {
    geometry.pickingColor = instancePickingColors;
  }

  vTexCoord = uv;
  cameraPosition = project_uCameraPosition;
  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);

  vec3 pos = (instanceModelMatrix * positions) * sizeScale;
  vec3 projectedPosition = project_position(positions);
  position_commonspace = vec4(projectedPosition, 1.0);
  gl_Position = project_common_position_to_clipspace(position_commonspace);

  geometry.position = position_commonspace;
  normals_commonspace = project_normal(instanceModelMatrix * normals);
  geometry.normal = normals_commonspace;

  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  #ifdef MODULE_PBR
    pbr_vPosition = geometry.position.xyz;
    #ifdef HAS_NORMALS
      pbr_vNormal = geometry.normal;
    #endif

    #ifdef HAS_UV
      pbr_vUV = uv;
    #else
      pbr_vUV = vec2(0., 0.);
    #endif
    geometry.uv = pbr_vUV;
  #endif

  DECKGL_FILTER_COLOR(vColor, geometry);
}
`, $9 = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs

precision highp float;

uniform bool hasTexture;
uniform sampler2D sampler;
uniform bool flatShading;
uniform float opacity;

in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;

out vec4 fragColor;

void main(void) {
  
#ifdef MODULE_PBR

  fragColor = vColor * pbr_filterColor(vec4(0));
  geometry.uv = pbr_vUV;
  fragColor.a *= opacity;

#else

  geometry.uv = vTexCoord;

  vec3 normal;
  if (flatShading) {
#ifdef DERIVATIVES_AVAILABLE
    normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
#else
    normal = vec3(0.0, 0.0, 1.0);
#endif
  } else {
    normal = normals_commonspace;
  }

  vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;
  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
  fragColor = vec4(lightColor, color.a * opacity);

#endif

  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;
function Z9(n) {
  n.COLOR_0 || n.colors || (n.colors = {
    constant: !0,
    value: new Float32Array([1, 1, 1])
  });
}
const Y9 = {
  pbrMaterial: {
    type: "object",
    value: null
  },
  featureIds: {
    type: "array",
    value: null,
    optional: !0
  }
};
class pv extends av {
  getShaders() {
    const e = super.getShaders();
    return e.modules.push(j1), {
      ...e,
      vs: J9,
      fs: $9
    };
  }
  initializeState() {
    const {
      featureIds: e
    } = this.props;
    super.initializeState();
    const t = this.getAttributeManager();
    e && t.add({
      featureIdsPickingColors: {
        type: 5121,
        size: 3,
        noAlloc: !0,
        update: this.calculateFeatureIdsPickingColors
      }
    });
  }
  updateState(e) {
    super.updateState(e);
    const {
      props: t,
      oldProps: i
    } = e;
    t.pbrMaterial !== i.pbrMaterial && this.updatePbrMaterialUniforms(t.pbrMaterial);
  }
  draw(e) {
    const {
      featureIds: t
    } = this.props;
    this.state.model && (this.state.model.setUniforms({
      u_Camera: this.state.model.getUniforms().project_uCameraPosition,
      pickFeatureIds: !!t
    }), super.draw(e));
  }
  getModel(e) {
    const {
      id: t,
      pbrMaterial: i
    } = this.props, r = this.parseMaterial(i, e);
    this.setState({
      materialParser: r
    });
    const s = this.getShaders();
    return Z9(e.attributes), new Hd(this.context.gl, {
      ...this.getShaders(),
      id: t,
      geometry: e,
      defines: {
        ...s.defines,
        ...r == null ? void 0 : r.defines,
        HAS_UV_REGIONS: e.attributes.uvRegions
      },
      parameters: r == null ? void 0 : r.parameters,
      isInstanced: !0
    });
  }
  updatePbrMaterialUniforms(e) {
    const {
      model: t
    } = this.state;
    if (t) {
      const {
        mesh: i
      } = this.props, r = this.parseMaterial(e, i);
      this.setState({
        materialParser: r
      }), t.setUniforms(r.uniforms);
    }
  }
  parseMaterial(e, t) {
    var i;
    const r = !!(e.pbrMetallicRoughness && e.pbrMetallicRoughness.baseColorTexture);
    return (i = this.state.materialParser) === null || i === void 0 || i.delete(), new wS(this.context.gl, {
      attributes: {
        NORMAL: t.attributes.normals,
        TEXCOORD_0: t.attributes.texCoords
      },
      material: {
        unlit: r,
        ...e
      },
      pbrDebug: !1,
      imageBasedLightingEnvironment: null,
      lights: !0,
      useTangents: !1
    });
  }
  calculateFeatureIdsPickingColors(e) {
    const t = this.props.featureIds, i = new Uint8ClampedArray(t.length * e.size), r = [];
    for (let s = 0; s < t.length; s++)
      this.encodePickingColor(t[s], r), i[s * 3] = r[0], i[s * 3 + 1] = r[1], i[s * 3 + 2] = r[2];
    e.value = i;
  }
  finalizeState(e) {
    var t;
    super.finalizeState(e), (t = this.state.materialParser) === null || t === void 0 || t.delete(), this.setState({
      materialParser: null
    });
  }
}
G(pv, "layerName", "MeshLayer");
G(pv, "defaultProps", Y9);
const K9 = 6378137, Q9 = 6378137, eU = 6356752314245179e-9;
function km(n) {
  return n;
}
new Qe();
function tU(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : km;
  return "longitude" in n ? (e[0] = t(n.longitude), e[1] = t(n.latitude), e[2] = n.height) : "x" in n ? (e[0] = t(n.x), e[1] = t(n.y), e[2] = n.z) : (e[0] = t(n[0]), e[1] = t(n[1]), e[2] = n[2]), e;
}
function nU(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return tU(n, e, rs._cartographicRadians ? km : KR);
}
function iU(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : km;
  return "longitude" in e ? (e.longitude = t(n[0]), e.latitude = t(n[1]), e.height = n[2]) : "x" in e ? (e.x = t(n[0]), e.y = t(n[1]), e.z = n[2]) : (e[0] = t(n[0]), e[1] = t(n[1]), e[2] = n[2]), e;
}
function rU(n, e) {
  return iU(n, e, rs._cartographicRadians ? km : QR);
}
const md = new Qe(), sU = new Qe(), oU = new Qe();
function aU(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  const {
    oneOverRadii: i,
    oneOverRadiiSquared: r,
    centerToleranceSquared: s
  } = e;
  md.from(n);
  const c = md.x, l = md.y, m = md.z, y = i.x, A = i.y, T = i.z, I = c * c * y * y, L = l * l * A * A, N = m * m * T * T, z = I + L + N, V = Math.sqrt(1 / z);
  if (!Number.isFinite(V))
    return;
  const H = sU;
  if (H.copy(n).scale(V), z < s)
    return H.to(t);
  const J = r.x, ce = r.y, me = r.z, Se = oU;
  Se.set(H.x * J * 2, H.y * ce * 2, H.z * me * 2);
  let De = (1 - V) * md.len() / (0.5 * Se.len()), Le = 0, ye, Ve, Fe, ae;
  do {
    De -= Le, ye = 1 / (1 + De * J), Ve = 1 / (1 + De * ce), Fe = 1 / (1 + De * me);
    const de = ye * ye, Te = Ve * Ve, be = Fe * Fe, tt = de * ye, st = Te * Ve, lt = be * Fe;
    ae = I * de + L * Te + N * be - 1;
    const ht = -2 * (I * tt * J + L * st * ce + N * lt * me);
    Le = ae / ht;
  } while (Math.abs(ae) > gp.EPSILON12);
  return md.scale([ye, Ve, Fe]).to(t);
}
const Vw = 1e-14, lU = new Qe(), qw = {
  up: {
    south: "east",
    north: "west",
    west: "south",
    east: "north"
  },
  down: {
    south: "west",
    north: "east",
    west: "north",
    east: "south"
  },
  south: {
    up: "west",
    down: "east",
    west: "down",
    east: "up"
  },
  north: {
    up: "east",
    down: "west",
    west: "up",
    east: "down"
  },
  west: {
    up: "north",
    down: "south",
    north: "down",
    south: "up"
  },
  east: {
    up: "south",
    down: "north",
    north: "up",
    south: "down"
  }
}, w_ = {
  north: [-1, 0, 0],
  east: [0, 1, 0],
  up: [0, 0, 1],
  south: [1, 0, 0],
  west: [0, -1, 0],
  down: [0, 0, -1]
}, Vf = {
  east: new Qe(),
  north: new Qe(),
  up: new Qe(),
  west: new Qe(),
  south: new Qe(),
  down: new Qe()
}, cU = new Qe(), uU = new Qe(), hU = new Qe();
function Hw(n, e, t, i, r, s) {
  const c = qw[e] && qw[e][t];
  El(c && (!i || i === c));
  let l, m, y;
  const A = lU.copy(r);
  if (Il(A.x, 0, Vw) && Il(A.y, 0, Vw)) {
    const I = Math.sign(A.z);
    l = cU.fromArray(w_[e]), e !== "east" && e !== "west" && l.scale(I), m = uU.fromArray(w_[t]), t !== "east" && t !== "west" && m.scale(I), y = hU.fromArray(w_[i]), i !== "east" && i !== "west" && y.scale(I);
  } else {
    const {
      up: I,
      east: L,
      north: N
    } = Vf;
    L.set(-A.y, A.x, 0).normalize(), n.geodeticSurfaceNormal(A, I), N.copy(I).cross(L);
    const {
      down: z,
      west: V,
      south: H
    } = Vf;
    z.copy(I).scale(-1), V.copy(L).scale(-1), H.copy(N).scale(-1), l = Vf[e], m = Vf[t], y = Vf[i];
  }
  return s[0] = l.x, s[1] = l.y, s[2] = l.z, s[3] = 0, s[4] = m.x, s[5] = m.y, s[6] = m.z, s[7] = 0, s[8] = y.x, s[9] = y.y, s[10] = y.z, s[11] = 0, s[12] = A.x, s[13] = A.y, s[14] = A.z, s[15] = 1, s;
}
const Bg = new Qe(), Ww = new Qe(), dU = new Qe(), yl = new Qe(), fU = new Qe(), Rg = new Qe();
class yr {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    G(this, "radii", void 0), G(this, "radiiSquared", void 0), G(this, "radiiToTheFourth", void 0), G(this, "oneOverRadii", void 0), G(this, "oneOverRadiiSquared", void 0), G(this, "minimumRadius", void 0), G(this, "maximumRadius", void 0), G(this, "centerToleranceSquared", gp.EPSILON1), G(this, "squaredXOverSquaredZ", void 0), El(e >= 0), El(t >= 0), El(i >= 0), this.radii = new Qe(e, t, i), this.radiiSquared = new Qe(e * e, t * t, i * i), this.radiiToTheFourth = new Qe(e * e * e * e, t * t * t * t, i * i * i * i), this.oneOverRadii = new Qe(e === 0 ? 0 : 1 / e, t === 0 ? 0 : 1 / t, i === 0 ? 0 : 1 / i), this.oneOverRadiiSquared = new Qe(e === 0 ? 0 : 1 / (e * e), t === 0 ? 0 : 1 / (t * t), i === 0 ? 0 : 1 / (i * i)), this.minimumRadius = Math.min(e, t, i), this.maximumRadius = Math.max(e, t, i), this.radiiSquared.z !== 0 && (this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z), Object.freeze(this);
  }
  equals(e) {
    return this === e || !!(e && this.radii.equals(e.radii));
  }
  toString() {
    return this.radii.toString();
  }
  cartographicToCartesian(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    const i = Ww, r = dU, [, , s] = e;
    this.geodeticSurfaceNormalCartographic(e, i), r.copy(this.radiiSquared).scale(i);
    const c = Math.sqrt(i.dot(r));
    return r.scale(1 / c), i.scale(s), r.add(i), r.to(t);
  }
  cartesianToCartographic(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    Rg.from(e);
    const i = this.scaleToGeodeticSurface(Rg, yl);
    if (!i)
      return;
    const r = this.geodeticSurfaceNormal(i, Ww), s = fU;
    s.copy(Rg).subtract(i);
    const c = Math.atan2(r.y, r.x), l = Math.asin(r.z), m = Math.sign(D1(s, Rg)) * bE(s);
    return rU([c, l, m], t);
  }
  eastNorthUpToFixedFrame(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new ai();
    return Hw(this, "east", "north", "up", e, t);
  }
  localFrameToFixedFrame(e, t, i, r) {
    let s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : new ai();
    return Hw(this, e, t, i, r, s);
  }
  geocentricSurfaceNormal(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    return Bg.from(e).normalize().to(t);
  }
  geodeticSurfaceNormalCartographic(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    const i = nU(e), r = i[0], s = i[1], c = Math.cos(s);
    return Bg.set(c * Math.cos(r), c * Math.sin(r), Math.sin(s)).normalize(), Bg.to(t);
  }
  geodeticSurfaceNormal(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    return Bg.from(e).scale(this.oneOverRadiiSquared).normalize().to(t);
  }
  scaleToGeodeticSurface(e, t) {
    return aU(e, this, t);
  }
  scaleToGeocentricSurface(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    yl.from(e);
    const i = yl.x, r = yl.y, s = yl.z, c = this.oneOverRadiiSquared, l = 1 / Math.sqrt(i * i * c.x + r * r * c.y + s * s * c.z);
    return yl.multiplyScalar(l).to(t);
  }
  transformPositionToScaledSpace(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    return yl.from(e).scale(this.oneOverRadii).to(t);
  }
  transformPositionFromScaledSpace(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    return yl.from(e).scale(this.radii).to(t);
  }
  getSurfaceNormalIntersectionWithZAxis(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [0, 0, 0];
    El(Il(this.radii.x, this.radii.y, gp.EPSILON15)), El(this.radii.z > 0), yl.from(e);
    const r = yl.z * (1 - this.squaredXOverSquaredZ);
    if (!(Math.abs(r) >= this.radii.z - t))
      return yl.set(0, 0, r).to(i);
  }
}
G(yr, "WGS84", new yr(K9, Q9, eU));
class pU {
  constructor(e, t, i) {
    G(this, "item", void 0), G(this, "previous", void 0), G(this, "next", void 0), this.item = e, this.previous = t, this.next = i;
  }
}
class gU {
  constructor() {
    G(this, "head", null), G(this, "tail", null), G(this, "_length", 0);
  }
  get length() {
    return this._length;
  }
  add(e) {
    const t = new pU(e, this.tail, null);
    return this.tail ? (this.tail.next = t, this.tail = t) : (this.head = t, this.tail = t), ++this._length, t;
  }
  remove(e) {
    e && (e.previous && e.next ? (e.previous.next = e.next, e.next.previous = e.previous) : e.previous ? (e.previous.next = null, this.tail = e.previous) : e.next ? (e.next.previous = null, this.head = e.next) : (this.head = null, this.tail = null), e.next = null, e.previous = null, --this._length);
  }
  splice(e, t) {
    e !== t && (this.remove(t), this._insert(e, t));
  }
  _insert(e, t) {
    const i = e.next;
    e.next = t, this.tail === e ? this.tail = t : i.previous = t, t.next = i, t.previous = e, ++this._length;
  }
}
class mU {
  constructor() {
    G(this, "_list", void 0), G(this, "_sentinel", void 0), G(this, "_trimTiles", void 0), this._list = new gU(), this._sentinel = this._list.add("sentinel"), this._trimTiles = !1;
  }
  reset() {
    this._list.splice(this._list.tail, this._sentinel);
  }
  touch(e) {
    const t = e._cacheNode;
    t && this._list.splice(this._sentinel, t);
  }
  add(e, t, i) {
    t._cacheNode || (t._cacheNode = this._list.add(t), i && i(e, t));
  }
  unloadTile(e, t, i) {
    const r = t._cacheNode;
    r && (this._list.remove(r), t._cacheNode = null, i && i(e, t));
  }
  unloadTiles(e, t) {
    const i = this._trimTiles;
    this._trimTiles = !1;
    const r = this._list, s = e.maximumMemoryUsage * 1024 * 1024, c = this._sentinel;
    let l = r.head;
    for (; l !== c && (e.gpuMemoryUsageInBytes > s || i); ) {
      const m = l.item;
      l = l.next, this.unloadTile(e, m, t);
    }
  }
  trim() {
    this._trimTiles = !0;
  }
}
function _U(n, e) {
  Qi(n), Qi(e);
  const {
    rtcCenter: t,
    gltfUpAxis: i
  } = e, {
    computedTransform: r,
    boundingVolume: {
      center: s
    }
  } = n;
  let c = new ai(r);
  switch (t && c.translate(t), i) {
    case "Z":
      break;
    case "Y":
      const T = new ai().rotateX(Math.PI / 2);
      c = c.multiplyRight(T);
      break;
    case "X":
      const I = new ai().rotateY(-Math.PI / 2);
      c = c.multiplyRight(I);
      break;
  }
  e.isQuantized && c.translate(e.quantizedVolumeOffset).scale(e.quantizedVolumeScale);
  const l = new Qe(s);
  e.cartesianModelMatrix = c, e.cartesianOrigin = l;
  const m = yr.WGS84.cartesianToCartographic(l, new Qe()), A = yr.WGS84.eastNorthUpToFixedFrame(l).invert();
  e.cartographicModelMatrix = A.multiplyRight(c), e.cartographicOrigin = m, e.coordinateSystem || (e.modelMatrix = e.cartographicModelMatrix);
}
const Xw = new Qe(), A_ = new Qe(), Oy = new Xa([new Al(), new Al(), new Al(), new Al(), new Al(), new Al()]);
function yU(n, e) {
  const {
    cameraDirection: t,
    cameraUp: i,
    height: r
  } = n, {
    metersPerUnit: s
  } = n.distanceScales, c = Zg(n, n.center), l = yr.WGS84.eastNorthUpToFixedFrame(c), m = n.unprojectPosition(n.cameraPosition), y = yr.WGS84.cartographicToCartesian(m, new Qe()), A = new Qe(l.transformAsVector(new Qe(t).scale(s))).normalize(), T = new Qe(l.transformAsVector(new Qe(i).scale(s))).normalize();
  bU(n);
  const I = n.constructor, {
    longitude: L,
    latitude: N,
    width: z,
    bearing: V,
    zoom: H
  } = n, J = new I({
    longitude: L,
    latitude: N,
    height: r,
    width: z,
    bearing: V,
    zoom: H,
    pitch: 0
  });
  return {
    camera: {
      position: y,
      direction: A,
      up: T
    },
    viewport: n,
    topDownViewport: J,
    height: r,
    cullingVolume: Oy,
    frameNumber: e,
    sseDenominator: 1.15
  };
}
function vU(n, e, t) {
  if (t === 0 || n.length <= t)
    return [n, []];
  const i = [], {
    longitude: r,
    latitude: s
  } = e.viewport;
  for (const [y, A] of n.entries()) {
    const [T, I] = A.header.mbs, L = Math.abs(r - T), N = Math.abs(s - I), z = Math.sqrt(N * N + L * L);
    i.push([y, z]);
  }
  const c = i.sort((y, A) => y[1] - A[1]), l = [];
  for (let y = 0; y < t; y++)
    l.push(n[c[y][0]]);
  const m = [];
  for (let y = t; y < c.length; y++)
    m.push(n[c[y][0]]);
  return [l, m];
}
function bU(n) {
  const e = n.getFrustumPlanes(), t = Jw(e.near, n.cameraPosition), i = Zg(n, t), r = Zg(n, n.cameraPosition, A_);
  let s = 0;
  Oy.planes[s++].fromPointNormal(i, Xw.copy(i).subtract(r));
  for (const c in e) {
    if (c === "near")
      continue;
    const l = e[c], m = Jw(l, t, A_), y = Zg(n, m, A_);
    Oy.planes[s++].fromPointNormal(y, Xw.copy(i).subtract(y));
  }
}
function Jw(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Qe();
  const i = n.normal.dot(e);
  return t.copy(n.normal).scale(n.distance - i).add(e), t;
}
function Zg(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Qe();
  const i = n.unprojectPosition(e);
  return yr.WGS84.cartographicToCartesian(i, t);
}
const xU = 6378137, wU = 6378137, Fy = 6356752314245179e-9, $w = new Qe();
function AU(n, e) {
  if (n instanceof zp) {
    const {
      halfAxes: t
    } = n, i = SU(t);
    return Math.log2(Fy / (i + e[2]));
  } else if (n instanceof Np) {
    const {
      radius: t
    } = n;
    return Math.log2(Fy / (t + e[2]));
  } else if (n.width && n.height) {
    const {
      width: t,
      height: i
    } = n, r = Math.log2(xU / t), s = Math.log2(wU / i);
    return (r + s) / 2;
  }
  return 1;
}
function NS(n, e, t) {
  const i = yr.WGS84.cartographicToCartesian([n.xmax, n.ymax, n.zmax], new Qe()), r = Math.sqrt(Math.pow(i[0] - t[0], 2) + Math.pow(i[1] - t[1], 2) + Math.pow(i[2] - t[2], 2));
  return Math.log2(Fy / (r + e[2]));
}
function EU(n, e, t) {
  const [i, r, s, c] = n;
  return NS({
    xmin: i,
    xmax: s,
    ymin: r,
    ymax: c,
    zmin: 0,
    zmax: 0
  }, e, t);
}
function SU(n) {
  n.getColumn(0, $w);
  const e = n.getColumn(1), t = n.getColumn(2);
  return $w.add(e).add(t).len();
}
const ca = {
  UNLOADED: 0,
  LOADING: 1,
  PROCESSING: 2,
  READY: 3,
  EXPIRED: 4,
  FAILED: 5
}, Kc = {
  ADD: 1,
  REPLACE: 2
}, Od = {
  EMPTY: "empty",
  SCENEGRAPH: "scenegraph",
  POINTCLOUD: "pointcloud",
  MESH: "mesh"
}, qa = {
  I3S: "I3S",
  TILES3D: "TILES3D"
}, Nm = {
  GEOMETRIC_ERROR: "geometricError",
  MAX_SCREEN_THRESHOLD: "maxScreenThreshold"
}, TU = {
  NOT_COMPUTED: -1,
  USE_OPTIMIZATION: 1,
  SKIP_OPTIMIZATION: 0
};
function zS(n) {
  return n != null;
}
const Js = new Qe(), Yg = new Qe(), CU = new Qe(), IU = new Qe();
function E_(n, e, t) {
  if (Qi(n, "3D Tile: boundingVolume must be defined"), n.box)
    return LU(n.box, e, t);
  if (n.region) {
    const [i, r, s, c, l, m] = n.region, y = yr.WGS84.cartographicToCartesian([Jc(i), Jc(c), l], CU), A = yr.WGS84.cartographicToCartesian([Jc(s), Jc(r), m], IU), T = new Qe().addVectors(y, A).multiplyScalar(0.5), I = new Qe().subVectors(y, A).len() / 2;
    return Zw([T[0], T[1], T[2], I], new ai());
  }
  if (n.sphere)
    return Zw(n.sphere, e, t);
  throw new Error("3D Tile: boundingVolume must contain a sphere, region, or box");
}
function PU(n, e) {
  if (n.box)
    return MU(e);
  if (n.region) {
    const [t, i, r, s, c, l] = n.region;
    return [[Jc(t), Jc(i), c], [Jc(r), Jc(s), l]];
  }
  if (n.sphere)
    return BU(e);
  throw new Error("Unkown boundingVolume type");
}
function LU(n, e, t) {
  const i = new Qe(n[0], n[1], n[2]);
  e.transform(i, i);
  let r = [];
  if (n.length === 10) {
    const y = n.slice(3, 6), A = new pp();
    A.fromArray(n, 6);
    const T = new Qe([1, 0, 0]), I = new Qe([0, 1, 0]), L = new Qe([0, 0, 1]);
    T.transformByQuaternion(A), T.scale(y[0]), I.transformByQuaternion(A), I.scale(y[1]), L.transformByQuaternion(A), L.scale(y[2]), r = [...T.toArray(), ...I.toArray(), ...L.toArray()];
  } else
    r = [...n.slice(3, 6), ...n.slice(6, 9), ...n.slice(9, 12)];
  const s = e.transformAsVector(r.slice(0, 3)), c = e.transformAsVector(r.slice(3, 6)), l = e.transformAsVector(r.slice(6, 9)), m = new Ir([s[0], s[1], s[2], c[0], c[1], c[2], l[0], l[1], l[2]]);
  return zS(t) ? (t.center = i, t.halfAxes = m, t) : new zp(i, m);
}
function Zw(n, e, t) {
  const i = new Qe(n[0], n[1], n[2]);
  e.transform(i, i);
  const r = e.getScale(Yg), s = Math.max(Math.max(r[0], r[1]), r[2]), c = n[3] * s;
  return zS(t) ? (t.center = i, t.radius = c, t) : new Np(i, c);
}
function MU(n) {
  const e = US(), {
    halfAxes: t
  } = n, i = new Qe(t.getColumn(0)), r = new Qe(t.getColumn(1)), s = new Qe(t.getColumn(2));
  for (let c = 0; c < 2; c++) {
    for (let l = 0; l < 2; l++) {
      for (let m = 0; m < 2; m++)
        Js.copy(n.center), Js.add(i), Js.add(r), Js.add(s), jS(e, Js), s.negate();
      r.negate();
    }
    i.negate();
  }
  return e;
}
function BU(n) {
  const e = US(), {
    center: t,
    radius: i
  } = n, r = yr.WGS84.scaleToGeodeticSurface(t, Js);
  let s;
  r ? s = yr.WGS84.geodeticSurfaceNormal(r) : s = new Qe(0, 0, 1);
  let c = new Qe(s[2], -s[1], 0);
  c.len() > 0 ? c.normalize() : c = new Qe(0, 1, 0);
  const l = c.clone().cross(s);
  for (const m of [c, l, s]) {
    Yg.copy(m).scale(i);
    for (let y = 0; y < 2; y++)
      Js.copy(t), Js.add(Yg), jS(e, Js), Yg.negate();
  }
  return e;
}
function US() {
  return [[1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]];
}
function jS(n, e) {
  yr.WGS84.cartesianToCartographic(e, Js), n[0][0] = Math.min(n[0][0], Js[0]), n[0][1] = Math.min(n[0][1], Js[1]), n[0][2] = Math.min(n[0][2], Js[2]), n[1][0] = Math.max(n[1][0], Js[0]), n[1][1] = Math.max(n[1][1], Js[1]), n[1][2] = Math.max(n[1][2], Js[2]);
}
new Qe();
new Qe();
new ai();
new Qe();
new Qe();
new Qe();
function RU(n, e) {
  const t = n * e;
  return 1 - Math.exp(-(t * t));
}
function OU(n, e) {
  if (n.dynamicScreenSpaceError && n.dynamicScreenSpaceErrorComputedDensity) {
    const t = n.dynamicScreenSpaceErrorComputedDensity, i = n.dynamicScreenSpaceErrorFactor;
    return RU(e, t) * i;
  }
  return 0;
}
function FU(n, e, t) {
  const i = n.tileset, r = n.parent && n.parent.lodMetricValue || n.lodMetricValue, s = t ? r : n.lodMetricValue;
  if (s === 0)
    return 0;
  const c = Math.max(n._distanceToCamera, 1e-7), {
    height: l,
    sseDenominator: m
  } = e, {
    viewDistanceScale: y
  } = i.options;
  let A = s * l * (y || 1) / (c * m);
  return A -= OU(i, c), A;
}
const S_ = new Qe(), Yw = new Qe(), ku = new Qe(), Kw = new Qe(), DU = new Qe(), T_ = new ai(), Qw = new ai();
function kU(n, e) {
  if (n.lodMetricValue === 0 || isNaN(n.lodMetricValue))
    return "DIG";
  const t = 2 * GS(n, e);
  return t < 2 ? "OUT" : !n.header.children || t <= n.lodMetricValue ? "DRAW" : n.header.children ? "DIG" : "OUT";
}
function GS(n, e) {
  const {
    topDownViewport: t
  } = e, i = n.header.mbs[1], r = n.header.mbs[0], s = n.header.mbs[2], c = n.header.mbs[3], l = [...n.boundingVolume.center], m = t.unprojectPosition(t.cameraPosition);
  yr.WGS84.cartographicToCartesian(m, S_), Yw.copy(S_).subtract(l).normalize(), yr.WGS84.eastNorthUpToFixedFrame(l, T_), Qw.copy(T_).invert(), ku.copy(S_).transform(Qw);
  const y = Math.sqrt(ku[0] * ku[0] + ku[1] * ku[1]), A = y * y / ku[2];
  Kw.copy([ku[0], ku[1], A]);
  const I = Kw.transform(T_).subtract(l).normalize(), N = Yw.cross(I).normalize().scale(c).add(l), z = yr.WGS84.cartesianToCartographic(N), V = t.project([r, i, s]), H = t.project(z);
  return DU.copy(V).subtract(H).magnitude();
}
function NU(n) {
  return {
    assetGltfUpAxis: n.asset && n.asset.gltfUpAxis || "Y"
  };
}
class eA {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    G(this, "_map", /* @__PURE__ */ new Map()), G(this, "_array", void 0), G(this, "_length", void 0), this._array = new Array(e), this._length = e;
  }
  get length() {
    return this._length;
  }
  set length(e) {
    this._length = e, e > this._array.length && (this._array.length = e);
  }
  get values() {
    return this._array;
  }
  get(e) {
    return Qi(e < this._array.length), this._array[e];
  }
  set(e, t) {
    Qi(e >= 0), e >= this.length && (this.length = e + 1), this._map.has(this._array[e]) && this._map.delete(this._array[e]), this._array[e] = t, this._map.set(t, e);
  }
  delete(e) {
    const t = this._map.get(e);
    t >= 0 && (this._array.splice(t, 1), this._map.delete(e), this.length--);
  }
  peek() {
    return this._array[this._length - 1];
  }
  push(e) {
    if (!this._map.has(e)) {
      const t = this.length++;
      this._array[t] = e, this._map.set(e, t);
    }
  }
  pop() {
    const e = this._array[--this.length];
    return this._map.delete(e), e;
  }
  reserve(e) {
    Qi(e >= 0), e > this._array.length && (this._array.length = e);
  }
  resize(e) {
    Qi(e >= 0), this.length = e;
  }
  trim(e) {
    e == null && (e = this.length), this._array.length = e;
  }
  reset() {
    this._array = [], this._map = /* @__PURE__ */ new Map(), this._length = 0;
  }
  find(e) {
    return this._map.has(e);
  }
}
const zU = {
  loadSiblings: !1,
  skipLevelOfDetail: !1,
  maximumScreenSpaceError: 2,
  updateTransforms: !0,
  onTraversalEnd: () => {
  },
  viewportTraversersMap: {},
  basePath: ""
};
class zm {
  traversalFinished(e) {
    return !0;
  }
  constructor(e) {
    G(this, "options", void 0), G(this, "root", null), G(this, "selectedTiles", {}), G(this, "requestedTiles", {}), G(this, "emptyTiles", {}), G(this, "lastUpdate", (/* @__PURE__ */ new Date()).getTime()), G(this, "updateDebounceTime", 1e3), G(this, "_traversalStack", new eA()), G(this, "_emptyTraversalStack", new eA()), G(this, "_frameNumber", null), this.options = {
      ...zU,
      ...e
    };
  }
  traverse(e, t, i) {
    this.root = e, this.options = {
      ...this.options,
      ...i
    }, this.reset(), this.updateTile(e, t), this._frameNumber = t.frameNumber, this.executeTraversal(e, t);
  }
  reset() {
    this.requestedTiles = {}, this.selectedTiles = {}, this.emptyTiles = {}, this._traversalStack.reset(), this._emptyTraversalStack.reset();
  }
  executeTraversal(e, t) {
    const i = this._traversalStack;
    for (e._selectionDepth = 1, i.push(e); i.length > 0; ) {
      const s = i.pop();
      let c = !1;
      this.canTraverse(s, t) && (this.updateChildTiles(s, t), c = this.updateAndPushChildren(s, t, i, s.hasRenderContent ? s._selectionDepth + 1 : s._selectionDepth));
      const l = s.parent, m = !!(!l || l._shouldRefine), y = !c;
      s.hasRenderContent ? s.refine === Kc.ADD ? (this.loadTile(s, t), this.selectTile(s, t)) : s.refine === Kc.REPLACE && (this.loadTile(s, t), y && this.selectTile(s, t)) : (this.emptyTiles[s.id] = s, this.loadTile(s, t), y && this.selectTile(s, t)), this.touchTile(s, t), s._shouldRefine = c && m;
    }
    const r = (/* @__PURE__ */ new Date()).getTime();
    (this.traversalFinished(t) || r - this.lastUpdate > this.updateDebounceTime) && (this.lastUpdate = r, this.options.onTraversalEnd(t));
  }
  updateChildTiles(e, t) {
    const i = e.children;
    for (const r of i)
      this.updateTile(r, t);
  }
  updateAndPushChildren(e, t, i, r) {
    const {
      loadSiblings: s,
      skipLevelOfDetail: c
    } = this.options, l = e.children;
    l.sort(this.compareDistanceToCamera.bind(this));
    const m = e.refine === Kc.REPLACE && e.hasRenderContent && !c;
    let y = !1, A = !0;
    for (const T of l)
      if (T._selectionDepth = r, T.isVisibleAndInRequestVolume ? (i.find(T) && i.delete(T), i.push(T), y = !0) : (m || s) && (this.loadTile(T, t), this.touchTile(T, t)), m) {
        let I;
        if (T._inRequestVolume ? T.hasRenderContent ? I = T.contentAvailable : I = this.executeEmptyTraversal(T, t) : I = !1, A = A && I, !A)
          return !1;
      }
    return y || (A = !1), A;
  }
  updateTile(e, t) {
    this.updateTileVisibility(e, t);
  }
  selectTile(e, t) {
    this.shouldSelectTile(e) && (e._selectedFrame = t.frameNumber, this.selectedTiles[e.id] = e);
  }
  loadTile(e, t) {
    this.shouldLoadTile(e) && (e._requestedFrame = t.frameNumber, e._priority = e._getPriority(), this.requestedTiles[e.id] = e);
  }
  touchTile(e, t) {
    e.tileset._cache.touch(e), e._touchedFrame = t.frameNumber;
  }
  canTraverse(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
    return e.hasChildren ? e.hasTilesetContent ? !e.contentExpired : !r && !e.isVisibleAndInRequestVolume ? !1 : this.shouldRefine(e, t, i) : !1;
  }
  shouldLoadTile(e) {
    return e.hasUnloadedContent || e.contentExpired;
  }
  shouldSelectTile(e) {
    return e.contentAvailable && !this.options.skipLevelOfDetail;
  }
  shouldRefine(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, r = e._screenSpaceError;
    return i && (r = e.getScreenSpaceError(t, !0)), r > this.options.maximumScreenSpaceError;
  }
  updateTileVisibility(e, t) {
    const i = [];
    if (this.options.viewportTraversersMap)
      for (const r in this.options.viewportTraversersMap)
        this.options.viewportTraversersMap[r] === t.viewport.id && i.push(r);
    else
      i.push(t.viewport.id);
    e.updateVisibility(t, i);
  }
  compareDistanceToCamera(e, t) {
    return e._distanceToCamera - t._distanceToCamera;
  }
  anyChildrenVisible(e, t) {
    let i = !1;
    for (const r of e.children)
      r.updateVisibility(t), i = i || r.isVisibleAndInRequestVolume;
    return i;
  }
  executeEmptyTraversal(e, t) {
    let i = !0;
    const r = this._emptyTraversalStack;
    for (r.push(e); r.length > 0 && i; ) {
      const s = r.pop();
      if (this.updateTile(s, t), s.isVisibleAndInRequestVolume || this.loadTile(s, t), this.touchTile(s, t), !s.hasRenderContent && this.canTraverse(s, t, !1, !0)) {
        const l = s.children;
        for (const m of l)
          r.find(m) && r.delete(m), r.push(m);
      } else
        !s.contentAvailable && !s.hasEmptyContent && (i = !1);
    }
    return i;
  }
}
const tA = new Qe();
function UU(n) {
  return n != null;
}
class Dy {
  constructor(e, t, i) {
    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
    G(this, "tileset", void 0), G(this, "header", void 0), G(this, "id", void 0), G(this, "url", void 0), G(this, "parent", void 0), G(this, "refine", void 0), G(this, "type", void 0), G(this, "contentUrl", void 0), G(this, "lodMetricType", "geometricError"), G(this, "lodMetricValue", 0), G(this, "boundingVolume", null), G(this, "content", null), G(this, "contentState", ca.UNLOADED), G(this, "gpuMemoryUsageInBytes", 0), G(this, "children", []), G(this, "depth", 0), G(this, "viewportIds", []), G(this, "transform", new ai()), G(this, "extensions", null), G(this, "implicitTiling", null), G(this, "userData", {}), G(this, "computedTransform", void 0), G(this, "hasEmptyContent", !1), G(this, "hasTilesetContent", !1), G(this, "traverser", new zm({})), G(this, "_cacheNode", null), G(this, "_frameNumber", null), G(this, "_expireDate", null), G(this, "_expiredContent", null), G(this, "_boundingBox", void 0), G(this, "_distanceToCamera", 0), G(this, "_screenSpaceError", 0), G(this, "_visibilityPlaneMask", void 0), G(this, "_visible", void 0), G(this, "_contentBoundingVolume", void 0), G(this, "_viewerRequestVolume", void 0), G(this, "_initialTransform", new ai()), G(this, "_priority", 0), G(this, "_selectedFrame", 0), G(this, "_requestedFrame", 0), G(this, "_selectionDepth", 0), G(this, "_touchedFrame", 0), G(this, "_centerZDepth", 0), G(this, "_shouldRefine", !1), G(this, "_stackLength", 0), G(this, "_visitedFrame", 0), G(this, "_inRequestVolume", !1), G(this, "_lodJudge", null), this.header = t, this.tileset = e, this.id = r || t.id, this.url = t.url, this.parent = i, this.refine = this._getRefine(t.refine), this.type = t.type, this.contentUrl = t.contentUrl, this._initializeLodMetric(t), this._initializeTransforms(t), this._initializeBoundingVolumes(t), this._initializeContent(t), this._initializeRenderingState(t), Object.seal(this);
  }
  destroy() {
    this.header = null;
  }
  isDestroyed() {
    return this.header === null;
  }
  get selected() {
    return this._selectedFrame === this.tileset._frameNumber;
  }
  get isVisible() {
    return this._visible;
  }
  get isVisibleAndInRequestVolume() {
    return this._visible && this._inRequestVolume;
  }
  get hasRenderContent() {
    return !this.hasEmptyContent && !this.hasTilesetContent;
  }
  get hasChildren() {
    return this.children.length > 0 || this.header.children && this.header.children.length > 0;
  }
  get contentReady() {
    return this.contentState === ca.READY || this.hasEmptyContent;
  }
  get contentAvailable() {
    return !!(this.contentReady && this.hasRenderContent || this._expiredContent && !this.contentFailed);
  }
  get hasUnloadedContent() {
    return this.hasRenderContent && this.contentUnloaded;
  }
  get contentUnloaded() {
    return this.contentState === ca.UNLOADED;
  }
  get contentExpired() {
    return this.contentState === ca.EXPIRED;
  }
  get contentFailed() {
    return this.contentState === ca.FAILED;
  }
  get distanceToCamera() {
    return this._distanceToCamera;
  }
  get screenSpaceError() {
    return this._screenSpaceError;
  }
  get boundingBox() {
    return this._boundingBox || (this._boundingBox = PU(this.header.boundingVolume, this.boundingVolume)), this._boundingBox;
  }
  getScreenSpaceError(e, t) {
    switch (this.tileset.type) {
      case qa.I3S:
        return GS(this, e);
      case qa.TILES3D:
        return FU(this, e, t);
      default:
        throw new Error("Unsupported tileset type");
    }
  }
  unselect() {
    this._selectedFrame = 0;
  }
  _getGpuMemoryUsageInBytes() {
    return this.content.gpuMemoryUsageInBytes || this.content.byteLength || 0;
  }
  _getPriority() {
    const e = this.tileset._traverser, {
      skipLevelOfDetail: t
    } = e.options, i = this.refine === Kc.ADD || t;
    if (i && !this.isVisible && this._visible !== void 0 || this.tileset._frameNumber - this._touchedFrame >= 1 || this.contentState === ca.UNLOADED)
      return -1;
    const r = this.parent, c = r && (!i || this._screenSpaceError === 0 || r.hasTilesetContent) ? r._screenSpaceError : this._screenSpaceError, l = e.root ? e.root._screenSpaceError : 0;
    return Math.max(l - c, 0);
  }
  async loadContent() {
    if (this.hasEmptyContent)
      return !1;
    if (this.content)
      return !0;
    this.contentExpired && (this._expireDate = null), this.contentState = ca.LOADING;
    const t = await this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority.bind(this));
    if (!t)
      return this.contentState = ca.UNLOADED, !1;
    try {
      const i = this.tileset.getTileUrl(this.contentUrl), r = this.tileset.loader, s = {
        ...this.tileset.loadOptions,
        [r.id]: {
          ...this.tileset.loadOptions[r.id],
          isTileset: this.type === "json",
          ...this._getLoaderSpecificOptions(r.id)
        }
      };
      return this.content = await Ju(i, r, s), this.tileset.options.contentLoader && await this.tileset.options.contentLoader(this), this._isTileset() && this.tileset._initializeTileHeaders(this.content, this), this.contentState = ca.READY, this._onContentLoaded(), !0;
    } catch (i) {
      throw this.contentState = ca.FAILED, i;
    } finally {
      t.done();
    }
  }
  unloadContent() {
    return this.content && this.content.destroy && this.content.destroy(), this.content = null, this.header.content && this.header.content.destroy && this.header.content.destroy(), this.header.content = null, this.contentState = ca.UNLOADED, !0;
  }
  updateVisibility(e, t) {
    if (this._frameNumber === e.frameNumber)
      return;
    const i = this.parent, r = i ? i._visibilityPlaneMask : Xa.MASK_INDETERMINATE;
    if (this.tileset._traverser.options.updateTransforms) {
      const s = i ? i.computedTransform : this.tileset.modelMatrix;
      this._updateTransform(s);
    }
    this._distanceToCamera = this.distanceToTile(e), this._screenSpaceError = this.getScreenSpaceError(e, !1), this._visibilityPlaneMask = this.visibility(e, r), this._visible = this._visibilityPlaneMask !== Xa.MASK_OUTSIDE, this._inRequestVolume = this.insideViewerRequestVolume(e), this._frameNumber = e.frameNumber, this.viewportIds = t;
  }
  visibility(e, t) {
    const {
      cullingVolume: i
    } = e, {
      boundingVolume: r
    } = this;
    return i.computeVisibilityWithPlaneMask(r, t);
  }
  contentVisibility() {
    return !0;
  }
  distanceToTile(e) {
    const t = this.boundingVolume;
    return Math.sqrt(Math.max(t.distanceSquaredTo(e.camera.position), 0));
  }
  cameraSpaceZDepth(e) {
    let {
      camera: t
    } = e;
    const i = this.boundingVolume;
    return tA.subVectors(i.center, t.position), t.direction.dot(tA);
  }
  insideViewerRequestVolume(e) {
    const t = this._viewerRequestVolume;
    return !t || t.distanceSquaredTo(e.camera.position) <= 0;
  }
  updateExpiration() {
    if (UU(this._expireDate) && this.contentReady && !this.hasEmptyContent) {
      const e = Date.now();
      Date.lessThan(this._expireDate, e) && (this.contentState = ca.EXPIRED, this._expiredContent = this.content);
    }
  }
  get extras() {
    return this.header.extras;
  }
  _initializeLodMetric(e) {
    "lodMetricType" in e ? this.lodMetricType = e.lodMetricType : (this.lodMetricType = this.parent && this.parent.lodMetricType || this.tileset.lodMetricType, console.warn("3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType")), "lodMetricValue" in e ? this.lodMetricValue = e.lodMetricValue : (this.lodMetricValue = this.parent && this.parent.lodMetricValue || this.tileset.lodMetricValue, console.warn("3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue"));
  }
  _initializeTransforms(e) {
    this.transform = e.transform ? new ai(e.transform) : new ai();
    const t = this.parent, i = this.tileset, r = t && t.computedTransform ? t.computedTransform.clone() : i.modelMatrix.clone();
    this.computedTransform = new ai(r).multiplyRight(this.transform);
    const s = t && t._initialTransform ? t._initialTransform.clone() : new ai();
    this._initialTransform = new ai(s).multiplyRight(this.transform);
  }
  _initializeBoundingVolumes(e) {
    this._contentBoundingVolume = null, this._viewerRequestVolume = null, this._updateBoundingVolume(e);
  }
  _initializeContent(e) {
    this.content = {
      _tileset: this.tileset,
      _tile: this
    }, this.hasEmptyContent = !0, this.contentState = ca.UNLOADED, this.hasTilesetContent = !1, e.contentUrl && (this.content = null, this.hasEmptyContent = !1);
  }
  _initializeRenderingState(e) {
    this.depth = e.level || (this.parent ? this.parent.depth + 1 : 0), this._shouldRefine = !1, this._distanceToCamera = 0, this._centerZDepth = 0, this._screenSpaceError = 0, this._visibilityPlaneMask = Xa.MASK_INDETERMINATE, this._visible = void 0, this._inRequestVolume = !1, this._stackLength = 0, this._selectionDepth = 0, this._frameNumber = 0, this._touchedFrame = 0, this._visitedFrame = 0, this._selectedFrame = 0, this._requestedFrame = 0, this._priority = 0;
  }
  _getRefine(e) {
    return e || this.parent && this.parent.refine || Kc.REPLACE;
  }
  _isTileset() {
    return this.contentUrl.indexOf(".json") !== -1;
  }
  _onContentLoaded() {
    switch (this.content && this.content.type) {
      case "vctr":
      case "geom":
        this.tileset._traverser.disableSkipLevelOfDetail = !0;
        break;
    }
    this._isTileset() ? this.hasTilesetContent = !0 : this.gpuMemoryUsageInBytes = this._getGpuMemoryUsageInBytes();
  }
  _updateBoundingVolume(e) {
    this.boundingVolume = E_(e.boundingVolume, this.computedTransform, this.boundingVolume);
    const t = e.content;
    t && (t.boundingVolume && (this._contentBoundingVolume = E_(t.boundingVolume, this.computedTransform, this._contentBoundingVolume)), e.viewerRequestVolume && (this._viewerRequestVolume = E_(e.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume)));
  }
  _updateTransform() {
    const t = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new ai()).clone().multiplyRight(this.transform);
    t.equals(this.computedTransform) || (this.computedTransform = t, this._updateBoundingVolume(this.header));
  }
  _getLoaderSpecificOptions(e) {
    switch (e) {
      case "i3s":
        return {
          ...this.tileset.options.i3s,
          _tileOptions: {
            attributeUrls: this.header.attributeUrls,
            textureUrl: this.header.textureUrl,
            textureFormat: this.header.textureFormat,
            textureLoaderOptions: this.header.textureLoaderOptions,
            materialDefinition: this.header.materialDefinition,
            isDracoGeometry: this.header.isDracoGeometry,
            mbs: this.header.mbs
          },
          _tilesetOptions: {
            store: this.tileset.tileset.store,
            attributeStorageInfo: this.tileset.tileset.attributeStorageInfo,
            fields: this.tileset.tileset.fields
          },
          isTileHeader: !1
        };
      case "3d-tiles":
      case "cesium-ion":
      default:
        return NU(this.tileset.tileset);
    }
  }
}
class jU extends zm {
  compareDistanceToCamera(e, t) {
    return t._distanceToCamera === 0 && e._distanceToCamera === 0 ? t._centerZDepth - e._centerZDepth : t._distanceToCamera - e._distanceToCamera;
  }
  updateTileVisibility(e, t) {
    if (super.updateTileVisibility(e, t), !e.isVisibleAndInRequestVolume)
      return;
    const i = e.children.length > 0;
    if (e.hasTilesetContent && i) {
      const c = e.children[0];
      this.updateTileVisibility(c, t), e._visible = c._visible;
      return;
    }
    if (this.meetsScreenSpaceErrorEarly(e, t)) {
      e._visible = !1;
      return;
    }
    const r = e.refine === Kc.REPLACE, s = e._optimChildrenWithinParent === TU.USE_OPTIMIZATION;
    if (r && s && i && !this.anyChildrenVisible(e, t)) {
      e._visible = !1;
      return;
    }
  }
  meetsScreenSpaceErrorEarly(e, t) {
    const {
      parent: i
    } = e;
    return !i || i.hasTilesetContent || i.refine !== Kc.ADD ? !1 : !this.shouldRefine(e, t, !0);
  }
}
class GU {
  constructor() {
    G(this, "frameNumberMap", /* @__PURE__ */ new Map());
  }
  register(e, t) {
    const i = this.frameNumberMap.get(e) || /* @__PURE__ */ new Map(), r = i.get(t) || 0;
    i.set(t, r + 1), this.frameNumberMap.set(e, i);
  }
  deregister(e, t) {
    const i = this.frameNumberMap.get(e);
    if (!i)
      return;
    const r = i.get(t) || 1;
    i.set(t, r - 1);
  }
  isZero(e, t) {
    var i;
    return (((i = this.frameNumberMap.get(e)) === null || i === void 0 ? void 0 : i.get(t)) || 0) === 0;
  }
}
const C_ = {
  REQUESTED: "REQUESTED",
  COMPLETED: "COMPLETED",
  ERROR: "ERROR"
};
class VU {
  constructor() {
    G(this, "_statusMap", void 0), G(this, "pendingTilesRegister", new GU()), this._statusMap = {};
  }
  add(e, t, i, r) {
    if (!this._statusMap[t]) {
      const {
        frameNumber: s,
        viewport: {
          id: c
        }
      } = r;
      this._statusMap[t] = {
        request: e,
        callback: i,
        key: t,
        frameState: r,
        status: C_.REQUESTED
      }, this.pendingTilesRegister.register(c, s), e().then((l) => {
        this._statusMap[t].status = C_.COMPLETED;
        const {
          frameNumber: m,
          viewport: {
            id: y
          }
        } = this._statusMap[t].frameState;
        this.pendingTilesRegister.deregister(y, m), this._statusMap[t].callback(l, r);
      }).catch((l) => {
        this._statusMap[t].status = C_.ERROR;
        const {
          frameNumber: m,
          viewport: {
            id: y
          }
        } = this._statusMap[t].frameState;
        this.pendingTilesRegister.deregister(y, m), i(l);
      });
    }
  }
  update(e, t) {
    if (this._statusMap[e]) {
      const {
        frameNumber: i,
        viewport: {
          id: r
        }
      } = this._statusMap[e].frameState;
      this.pendingTilesRegister.deregister(r, i);
      const {
        frameNumber: s,
        viewport: {
          id: c
        }
      } = t;
      this.pendingTilesRegister.register(c, s), this._statusMap[e].frameState = t;
    }
  }
  find(e) {
    return this._statusMap[e];
  }
  hasPendingTiles(e, t) {
    return !this.pendingTilesRegister.isZero(e, t);
  }
}
class qU extends zm {
  constructor(e) {
    super(e), G(this, "_tileManager", void 0), this._tileManager = new VU();
  }
  traversalFinished(e) {
    return !this._tileManager.hasPendingTiles(e.viewport.id, this._frameNumber || 0);
  }
  shouldRefine(e, t) {
    return e._lodJudge = kU(e, t), e._lodJudge === "DIG";
  }
  updateChildTiles(e, t) {
    const i = e.header.children || [], r = e.children, s = e.tileset;
    for (const c of i) {
      const l = "".concat(c.id, "-").concat(t.viewport.id), m = r && r.find((y) => y.id === l);
      if (m)
        m && this.updateTile(m, t);
      else {
        let y = () => this._loadTile(c.id, s);
        this._tileManager.find(l) ? this._tileManager.update(l, t) : (s.tileset.nodePages && (y = () => s.tileset.nodePagesTile.formTileFromNodePages(c.id)), this._tileManager.add(y, l, (T) => this._onTileLoad(T, e, l), t));
      }
    }
    return !1;
  }
  async _loadTile(e, t) {
    const {
      loader: i
    } = t, r = t.getTileUrl("".concat(t.url, "/nodes/").concat(e)), s = {
      ...t.loadOptions,
      i3s: {
        ...t.loadOptions.i3s,
        isTileHeader: !0
      }
    };
    return await Ju(r, i, s);
  }
  _onTileLoad(e, t, i) {
    const r = new Dy(t.tileset, e, t, i);
    t.children.push(r);
    const s = this._tileManager.find(r.id).frameState;
    this.updateTile(r, s), this._frameNumber === s.frameNumber && (this.traversalFinished(s) || (/* @__PURE__ */ new Date()).getTime() - this.lastUpdate > this.updateDebounceTime) && this.executeTraversal(r, s);
  }
}
const HU = {
  description: "",
  ellipsoid: yr.WGS84,
  modelMatrix: new ai(),
  throttleRequests: !0,
  maxRequests: 64,
  maximumMemoryUsage: 32,
  maximumTilesSelected: 0,
  debounceTime: 0,
  onTileLoad: () => {
  },
  onTileUnload: () => {
  },
  onTileError: () => {
  },
  onTraversalComplete: (n) => n,
  contentLoader: void 0,
  viewDistanceScale: 1,
  maximumScreenSpaceError: 8,
  loadTiles: !0,
  updateTransforms: !0,
  viewportTraversersMap: null,
  loadOptions: {
    fetch: {}
  },
  attributions: [],
  basePath: "",
  i3s: {}
}, Og = "Tiles In Tileset(s)", I_ = "Tiles In Memory", nA = "Tiles In View", iA = "Tiles To Render", rA = "Tiles Loaded", P_ = "Tiles Loading", sA = "Tiles Unloaded", oA = "Failed Tile Loads", aA = "Points/Vertices", L_ = "Tile Memory Use";
class WU {
  constructor(e, t) {
    G(this, "options", void 0), G(this, "loadOptions", void 0), G(this, "type", void 0), G(this, "tileset", void 0), G(this, "loader", void 0), G(this, "url", void 0), G(this, "basePath", void 0), G(this, "modelMatrix", void 0), G(this, "ellipsoid", void 0), G(this, "lodMetricType", void 0), G(this, "lodMetricValue", void 0), G(this, "refine", void 0), G(this, "root", null), G(this, "roots", {}), G(this, "asset", {}), G(this, "description", ""), G(this, "properties", void 0), G(this, "extras", null), G(this, "attributions", {}), G(this, "credits", {}), G(this, "stats", void 0), G(this, "contentFormats", {
      draco: !1,
      meshopt: !1,
      dds: !1,
      ktx2: !1
    }), G(this, "cartographicCenter", null), G(this, "cartesianCenter", null), G(this, "zoom", 1), G(this, "boundingVolume", null), G(this, "dynamicScreenSpaceErrorComputedDensity", 0), G(this, "maximumMemoryUsage", 32), G(this, "gpuMemoryUsageInBytes", 0), G(this, "_frameNumber", 0), G(this, "_queryParams", {}), G(this, "_extensionsUsed", []), G(this, "_tiles", {}), G(this, "_pendingCount", 0), G(this, "selectedTiles", []), G(this, "traverseCounter", 0), G(this, "geometricError", 0), G(this, "lastUpdatedVieports", null), G(this, "_requestedTiles", []), G(this, "_emptyTiles", []), G(this, "frameStateData", {}), G(this, "_traverser", void 0), G(this, "_cache", new mU()), G(this, "_requestScheduler", void 0), G(this, "updatePromise", null), G(this, "tilesetInitializationPromise", void 0), this.options = {
      ...HU,
      ...t
    }, this.tileset = e, this.loader = e.loader, this.type = e.type, this.url = e.url, this.basePath = e.basePath || g1(this.url), this.modelMatrix = this.options.modelMatrix, this.ellipsoid = this.options.ellipsoid, this.lodMetricType = e.lodMetricType, this.lodMetricValue = e.lodMetricValue, this.refine = e.root.refine, this.loadOptions = this.options.loadOptions || {}, this._traverser = this._initializeTraverser(), this._requestScheduler = new lP({
      throttleRequests: this.options.throttleRequests,
      maxRequests: this.options.maxRequests
    }), this.stats = new Cp({
      id: this.url
    }), this._initializeStats(), this.tilesetInitializationPromise = this._initializeTileSet(e);
  }
  destroy() {
    this._destroy();
  }
  isLoaded() {
    return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;
  }
  get tiles() {
    return Object.values(this._tiles);
  }
  get frameNumber() {
    return this._frameNumber;
  }
  get queryParams() {
    return new URLSearchParams(this._queryParams).toString();
  }
  setProps(e) {
    this.options = {
      ...this.options,
      ...e
    };
  }
  setOptions(e) {
    this.options = {
      ...this.options,
      ...e
    };
  }
  getTileUrl(e) {
    return e.startsWith("data:") ? e : "".concat(e).concat(e.includes("?") ? "&" : "?").concat(this.queryParams);
  }
  hasExtension(e) {
    return this._extensionsUsed.indexOf(e) > -1;
  }
  update() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    this.tilesetInitializationPromise.then(() => {
      !e && this.lastUpdatedVieports ? e = this.lastUpdatedVieports : this.lastUpdatedVieports = e, e && this.doUpdate(e);
    });
  }
  async selectTiles() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    return await this.tilesetInitializationPromise, e && (this.lastUpdatedVieports = e), this.updatePromise || (this.updatePromise = new Promise((t) => {
      setTimeout(() => {
        this.lastUpdatedVieports && this.doUpdate(this.lastUpdatedVieports), t(this._frameNumber), this.updatePromise = null;
      }, this.options.debounceTime);
    })), this.updatePromise;
  }
  doUpdate(e) {
    if ("loadTiles" in this.options && !this.options.loadTiles || this.traverseCounter > 0)
      return;
    const t = e instanceof Array ? e : [e];
    this._cache.reset(), this._frameNumber++, this.traverseCounter = t.length;
    const i = [];
    for (const r of t) {
      const s = r.id;
      this._needTraverse(s) ? i.push(s) : this.traverseCounter--;
    }
    for (const r of t) {
      const s = r.id;
      if (this.roots[s] || (this.roots[s] = this._initializeTileHeaders(this.tileset, null)), !i.includes(s))
        continue;
      const c = yU(r, this._frameNumber);
      this._traverser.traverse(this.roots[s], c, this.options);
    }
  }
  _needTraverse(e) {
    let t = e;
    return this.options.viewportTraversersMap && (t = this.options.viewportTraversersMap[e]), t === e;
  }
  _onTraversalEnd(e) {
    const t = e.viewport.id;
    this.frameStateData[t] || (this.frameStateData[t] = {
      selectedTiles: [],
      _requestedTiles: [],
      _emptyTiles: []
    });
    const i = this.frameStateData[t], r = Object.values(this._traverser.selectedTiles), [s, c] = vU(r, e, this.options.maximumTilesSelected);
    i.selectedTiles = s;
    for (const l of c)
      l.unselect();
    i._requestedTiles = Object.values(this._traverser.requestedTiles), i._emptyTiles = Object.values(this._traverser.emptyTiles), this.traverseCounter--, !(this.traverseCounter > 0) && this._updateTiles();
  }
  _updateTiles() {
    this.selectedTiles = [], this._requestedTiles = [], this._emptyTiles = [];
    for (const e in this.frameStateData) {
      const t = this.frameStateData[e];
      this.selectedTiles = this.selectedTiles.concat(t.selectedTiles), this._requestedTiles = this._requestedTiles.concat(t._requestedTiles), this._emptyTiles = this._emptyTiles.concat(t._emptyTiles);
    }
    this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);
    for (const e of this.selectedTiles)
      this._tiles[e.id] = e;
    this._loadTiles(), this._unloadTiles(), this._updateStats();
  }
  _tilesChanged(e, t) {
    if (e.length !== t.length)
      return !0;
    const i = new Set(e.map((c) => c.id)), r = new Set(t.map((c) => c.id));
    let s = e.filter((c) => !r.has(c.id)).length > 0;
    return s = s || t.filter((c) => !i.has(c.id)).length > 0, s;
  }
  _loadTiles() {
    for (const e of this._requestedTiles)
      e.contentUnloaded && this._loadTile(e);
  }
  _unloadTiles() {
    this._cache.unloadTiles(this, (e, t) => e._unloadTile(t));
  }
  _updateStats() {
    let e = 0, t = 0;
    for (const i of this.selectedTiles)
      i.contentAvailable && i.content && (e++, i.content.pointCount ? t += i.content.pointCount : t += i.content.vertexCount);
    this.stats.get(nA).count = this.selectedTiles.length, this.stats.get(iA).count = e, this.stats.get(aA).count = t;
  }
  async _initializeTileSet(e) {
    this.type === qa.I3S && (this.calculateViewPropsI3S(), e.root = await e.root), this.root = this._initializeTileHeaders(e, null), this.type === qa.TILES3D && (this._initializeTiles3DTileset(e), this.calculateViewPropsTiles3D()), this.type === qa.I3S && this._initializeI3STileset();
  }
  calculateViewPropsI3S() {
    var e;
    const t = this.tileset.fullExtent;
    if (t) {
      const {
        xmin: r,
        xmax: s,
        ymin: c,
        ymax: l,
        zmin: m,
        zmax: y
      } = t;
      this.cartographicCenter = new Qe(r + (s - r) / 2, c + (l - c) / 2, m + (y - m) / 2), this.cartesianCenter = yr.WGS84.cartographicToCartesian(this.cartographicCenter, new Qe()), this.zoom = NS(t, this.cartographicCenter, this.cartesianCenter);
      return;
    }
    const i = (e = this.tileset.store) === null || e === void 0 ? void 0 : e.extent;
    if (i) {
      const [r, s, c, l] = i;
      this.cartographicCenter = new Qe(r + (c - r) / 2, s + (l - s) / 2, 0), this.cartesianCenter = yr.WGS84.cartographicToCartesian(this.cartographicCenter, new Qe()), this.zoom = EU(i, this.cartographicCenter, this.cartesianCenter);
      return;
    }
    console.warn("Extent is not defined in the tileset header"), this.cartographicCenter = new Qe(), this.zoom = 1;
  }
  calculateViewPropsTiles3D() {
    const e = this.root, {
      center: t
    } = e.boundingVolume;
    if (!t) {
      console.warn("center was not pre-calculated for the root tile"), this.cartographicCenter = new Qe(), this.zoom = 1;
      return;
    }
    t[0] !== 0 || t[1] !== 0 || t[2] !== 0 ? this.cartographicCenter = yr.WGS84.cartesianToCartographic(t, new Qe()) : this.cartographicCenter = new Qe(0, 0, -yr.WGS84.radii[0]), this.cartesianCenter = t, this.zoom = AU(e.boundingVolume, this.cartographicCenter);
  }
  _initializeStats() {
    this.stats.get(Og), this.stats.get(P_), this.stats.get(I_), this.stats.get(nA), this.stats.get(iA), this.stats.get(rA), this.stats.get(sA), this.stats.get(oA), this.stats.get(aA), this.stats.get(L_, "memory");
  }
  _initializeTileHeaders(e, t) {
    const i = new Dy(this, e.root, t);
    if (t && (t.children.push(i), i.depth = t.depth + 1), this.type === qa.TILES3D) {
      const s = [];
      for (s.push(i); s.length > 0; ) {
        const c = s.pop();
        this.stats.get(Og).incrementCount();
        const l = c.header.children || [];
        for (const m of l) {
          var r;
          const y = new Dy(this, m, c);
          if ((r = y.contentUrl) !== null && r !== void 0 && r.includes("?session=")) {
            const T = new URL(y.contentUrl).searchParams.get("session");
            T && (this._queryParams.session = T);
          }
          c.children.push(y), y.depth = c.depth + 1, s.push(y);
        }
      }
    }
    return i;
  }
  _initializeTraverser() {
    let e;
    switch (this.type) {
      case qa.TILES3D:
        e = jU;
        break;
      case qa.I3S:
        e = qU;
        break;
      default:
        e = zm;
    }
    return new e({
      basePath: this.basePath,
      onTraversalEnd: this._onTraversalEnd.bind(this)
    });
  }
  _destroyTileHeaders(e) {
    this._destroySubtree(e);
  }
  async _loadTile(e) {
    let t;
    try {
      this._onStartTileLoading(), t = await e.loadContent();
    } catch (i) {
      this._onTileLoadError(e, i instanceof Error ? i : new Error("load failed"));
    } finally {
      this._onEndTileLoading(), this._onTileLoad(e, t);
    }
  }
  _onTileLoadError(e, t) {
    this.stats.get(oA).incrementCount();
    const i = t.message || t.toString(), r = e.url;
    console.error("A 3D tile failed to load: ".concat(e.url, " ").concat(i)), this.options.onTileError(e, i, r);
  }
  _onTileLoad(e, t) {
    if (t) {
      if (this.type === qa.I3S) {
        var i, r;
        const s = ((i = this.tileset) === null || i === void 0 || (r = i.nodePagesTile) === null || r === void 0 ? void 0 : r.nodesInNodePages) || 0;
        this.stats.get(Og).reset(), this.stats.get(Og).addCount(s);
      }
      e && e.content && _U(e, e.content), this.updateContentTypes(e), this._addTileToCache(e), this.options.onTileLoad(e);
    }
  }
  updateContentTypes(e) {
    if (this.type === qa.I3S)
      switch (e.header.isDracoGeometry && (this.contentFormats.draco = !0), e.header.textureFormat) {
        case "dds":
          this.contentFormats.dds = !0;
          break;
        case "ktx2":
          this.contentFormats.ktx2 = !0;
          break;
      }
    else if (this.type === qa.TILES3D) {
      var t;
      const {
        extensionsRemoved: i = []
      } = ((t = e.content) === null || t === void 0 ? void 0 : t.gltf) || {};
      i.includes("KHR_draco_mesh_compression") && (this.contentFormats.draco = !0), i.includes("EXT_meshopt_compression") && (this.contentFormats.meshopt = !0), i.includes("KHR_texture_basisu") && (this.contentFormats.ktx2 = !0);
    }
  }
  _onStartTileLoading() {
    this._pendingCount++, this.stats.get(P_).incrementCount();
  }
  _onEndTileLoading() {
    this._pendingCount--, this.stats.get(P_).decrementCount();
  }
  _addTileToCache(e) {
    this._cache.add(this, e, (t) => t._updateCacheStats(e));
  }
  _updateCacheStats(e) {
    this.stats.get(rA).incrementCount(), this.stats.get(I_).incrementCount(), this.gpuMemoryUsageInBytes += e.gpuMemoryUsageInBytes || 0, this.stats.get(L_).count = this.gpuMemoryUsageInBytes;
  }
  _unloadTile(e) {
    this.gpuMemoryUsageInBytes -= e.gpuMemoryUsageInBytes || 0, this.stats.get(I_).decrementCount(), this.stats.get(sA).incrementCount(), this.stats.get(L_).count = this.gpuMemoryUsageInBytes, this.options.onTileUnload(e), e.unloadContent();
  }
  _destroy() {
    const e = [];
    for (this.root && e.push(this.root); e.length > 0; ) {
      const t = e.pop();
      for (const i of t.children)
        e.push(i);
      this._destroyTile(t);
    }
    this.root = null;
  }
  _destroySubtree(e) {
    const t = e, i = [];
    for (i.push(t); i.length > 0; ) {
      e = i.pop();
      for (const r of e.children)
        i.push(r);
      e !== t && this._destroyTile(e);
    }
    t.children = [];
  }
  _destroyTile(e) {
    this._cache.unloadTile(this, e), this._unloadTile(e), e.destroy();
  }
  _initializeTiles3DTileset(e) {
    if (e.queryString) {
      const t = new URLSearchParams(e.queryString), i = Object.fromEntries(t.entries());
      this._queryParams = {
        ...this._queryParams,
        ...i
      };
    }
    if (this.asset = e.asset, !this.asset)
      throw new Error("Tileset must have an asset property.");
    if (this.asset.version !== "0.0" && this.asset.version !== "1.0")
      throw new Error("The tileset must be 3D Tiles version 0.0 or 1.0.");
    "tilesetVersion" in this.asset && (this._queryParams.v = this.asset.tilesetVersion), this.credits = {
      attributions: this.options.attributions || []
    }, this.description = this.options.description || "", this.properties = e.properties, this.geometricError = e.geometricError, this._extensionsUsed = e.extensionsUsed || [], this.extras = e.extras;
  }
  _initializeI3STileset() {
    this.loadOptions.i3s && "token" in this.loadOptions.i3s && (this._queryParams.token = this.loadOptions.i3s.token);
  }
}
const VS = "3.4.15", qf = {
  COMPOSITE: "cmpt",
  POINT_CLOUD: "pnts",
  BATCHED_3D_MODEL: "b3dm",
  INSTANCED_3D_MODEL: "i3dm",
  GEOMETRY: "geom",
  VECTOR: "vect",
  GLTF: "glTF"
};
function qS(n, e, t) {
  Qi(n instanceof ArrayBuffer);
  const i = new TextDecoder("utf8"), r = new Uint8Array(n, e, t);
  return i.decode(r);
}
function XU(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  const t = new DataView(n);
  return "".concat(String.fromCharCode(t.getUint8(e + 0))).concat(String.fromCharCode(t.getUint8(e + 1))).concat(String.fromCharCode(t.getUint8(e + 2))).concat(String.fromCharCode(t.getUint8(e + 3)));
}
const JU = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6
}, Vr = {
  BYTE: 5120,
  UNSIGNED_BYTE: 5121,
  SHORT: 5122,
  UNSIGNED_SHORT: 5123,
  INT: 5124,
  UNSIGNED_INT: 5125,
  FLOAT: 5126,
  DOUBLE: 5130
}, mi = {
  ...JU,
  ...Vr
}, M_ = {
  [Vr.DOUBLE]: Float64Array,
  [Vr.FLOAT]: Float32Array,
  [Vr.UNSIGNED_SHORT]: Uint16Array,
  [Vr.UNSIGNED_INT]: Uint32Array,
  [Vr.UNSIGNED_BYTE]: Uint8Array,
  [Vr.BYTE]: Int8Array,
  [Vr.SHORT]: Int16Array,
  [Vr.INT]: Int32Array
}, $U = {
  DOUBLE: Vr.DOUBLE,
  FLOAT: Vr.FLOAT,
  UNSIGNED_SHORT: Vr.UNSIGNED_SHORT,
  UNSIGNED_INT: Vr.UNSIGNED_INT,
  UNSIGNED_BYTE: Vr.UNSIGNED_BYTE,
  BYTE: Vr.BYTE,
  SHORT: Vr.SHORT,
  INT: Vr.INT
}, B_ = "Failed to convert GL type";
class dc {
  static fromTypedArray(e) {
    e = ArrayBuffer.isView(e) ? e.constructor : e;
    for (const t in M_)
      if (M_[t] === e)
        return t;
    throw new Error(B_);
  }
  static fromName(e) {
    const t = $U[e];
    if (!t)
      throw new Error(B_);
    return t;
  }
  static getArrayType(e) {
    switch (e) {
      case Vr.UNSIGNED_SHORT_5_6_5:
      case Vr.UNSIGNED_SHORT_4_4_4_4:
      case Vr.UNSIGNED_SHORT_5_5_5_1:
        return Uint16Array;
      default:
        const t = M_[e];
        if (!t)
          throw new Error(B_);
        return t;
    }
  }
  static getByteSize(e) {
    return dc.getArrayType(e).BYTES_PER_ELEMENT;
  }
  static validate(e) {
    return !!dc.getArrayType(e);
  }
  static createTypedArray(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, r = arguments.length > 3 ? arguments[3] : void 0;
    r === void 0 && (r = (t.byteLength - i) / dc.getByteSize(e));
    const s = dc.getArrayType(e);
    return new s(t, i, r);
  }
}
function ZU(n, e) {
  if (!n)
    throw new Error("math.gl assertion failed. ".concat(e));
}
function YU(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
  const t = n >> 11 & 31, i = n >> 5 & 63, r = n & 31;
  return e[0] = t << 3, e[1] = i << 2, e[2] = r << 3, e;
}
new F1();
new Qe();
new F1();
new F1();
function lA(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 255;
  return $c(n, 0, e) / e * 2 - 1;
}
function cA(n) {
  return n < 0 ? -1 : 1;
}
function KU(n, e, t, i) {
  if (ZU(i), n < 0 || n > t || e < 0 || e > t)
    throw new Error("x and y must be unsigned normalized integers between 0 and ".concat(t));
  if (i.x = lA(n, t), i.y = lA(e, t), i.z = 1 - (Math.abs(i.x) + Math.abs(i.y)), i.z < 0) {
    const r = i.x;
    i.x = (1 - Math.abs(i.y)) * cA(r), i.y = (1 - Math.abs(r)) * cA(i.y);
  }
  return i.normalize();
}
function QU(n, e, t) {
  return KU(n, e, 255, t);
}
class gv {
  constructor(e, t) {
    G(this, "json", void 0), G(this, "buffer", void 0), G(this, "featuresLength", 0), G(this, "_cachedTypedArrays", {}), this.json = e, this.buffer = t;
  }
  getExtension(e) {
    return this.json.extensions && this.json.extensions[e];
  }
  hasProperty(e) {
    return !!this.json[e];
  }
  getGlobalProperty(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : mi.UNSIGNED_INT, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    const r = this.json[e];
    return r && Number.isFinite(r.byteOffset) ? this._getTypedArrayFromBinary(e, t, i, 1, r.byteOffset) : r;
  }
  getPropertyArray(e, t, i) {
    const r = this.json[e];
    return r && Number.isFinite(r.byteOffset) ? ("componentType" in r && (t = dc.fromName(r.componentType)), this._getTypedArrayFromBinary(e, t, i, this.featuresLength, r.byteOffset)) : this._getTypedArrayFromArray(e, t, r);
  }
  getProperty(e, t, i, r, s) {
    const c = this.json[e];
    if (!c)
      return c;
    const l = this.getPropertyArray(e, t, i);
    if (i === 1)
      return l[r];
    for (let m = 0; m < i; ++m)
      s[m] = l[i * r + m];
    return s;
  }
  _getTypedArrayFromBinary(e, t, i, r, s) {
    const c = this._cachedTypedArrays;
    let l = c[e];
    return l || (l = dc.createTypedArray(t, this.buffer.buffer, this.buffer.byteOffset + s, r * i), c[e] = l), l;
  }
  _getTypedArrayFromArray(e, t, i) {
    const r = this._cachedTypedArrays;
    let s = r[e];
    return s || (s = dc.createTypedArray(t, i), r[e] = s), s;
  }
}
const ej = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, tj = {
  SCALAR: (n, e) => n[e],
  VEC2: (n, e) => [n[2 * e + 0], n[2 * e + 1]],
  VEC3: (n, e) => [n[3 * e + 0], n[3 * e + 1], n[3 * e + 2]],
  VEC4: (n, e) => [n[4 * e + 0], n[4 * e + 1], n[4 * e + 2], n[4 * e + 3]],
  MAT2: (n, e) => [n[4 * e + 0], n[4 * e + 1], n[4 * e + 2], n[4 * e + 3]],
  MAT3: (n, e) => [n[9 * e + 0], n[9 * e + 1], n[9 * e + 2], n[9 * e + 3], n[9 * e + 4], n[9 * e + 5], n[9 * e + 6], n[9 * e + 7], n[9 * e + 8]],
  MAT4: (n, e) => [n[16 * e + 0], n[16 * e + 1], n[16 * e + 2], n[16 * e + 3], n[16 * e + 4], n[16 * e + 5], n[16 * e + 6], n[16 * e + 7], n[16 * e + 8], n[16 * e + 9], n[16 * e + 10], n[16 * e + 11], n[16 * e + 12], n[16 * e + 13], n[16 * e + 14], n[16 * e + 15]]
}, nj = {
  SCALAR: (n, e, t) => {
    e[t] = n;
  },
  VEC2: (n, e, t) => {
    e[2 * t + 0] = n[0], e[2 * t + 1] = n[1];
  },
  VEC3: (n, e, t) => {
    e[3 * t + 0] = n[0], e[3 * t + 1] = n[1], e[3 * t + 2] = n[2];
  },
  VEC4: (n, e, t) => {
    e[4 * t + 0] = n[0], e[4 * t + 1] = n[1], e[4 * t + 2] = n[2], e[4 * t + 3] = n[3];
  },
  MAT2: (n, e, t) => {
    e[4 * t + 0] = n[0], e[4 * t + 1] = n[1], e[4 * t + 2] = n[2], e[4 * t + 3] = n[3];
  },
  MAT3: (n, e, t) => {
    e[9 * t + 0] = n[0], e[9 * t + 1] = n[1], e[9 * t + 2] = n[2], e[9 * t + 3] = n[3], e[9 * t + 4] = n[4], e[9 * t + 5] = n[5], e[9 * t + 6] = n[6], e[9 * t + 7] = n[7], e[9 * t + 8] = n[8], e[9 * t + 9] = n[9];
  },
  MAT4: (n, e, t) => {
    e[16 * t + 0] = n[0], e[16 * t + 1] = n[1], e[16 * t + 2] = n[2], e[16 * t + 3] = n[3], e[16 * t + 4] = n[4], e[16 * t + 5] = n[5], e[16 * t + 6] = n[6], e[16 * t + 7] = n[7], e[16 * t + 8] = n[8], e[16 * t + 9] = n[9], e[16 * t + 10] = n[10], e[16 * t + 11] = n[11], e[16 * t + 12] = n[12], e[16 * t + 13] = n[13], e[16 * t + 14] = n[14], e[16 * t + 15] = n[15];
  }
};
function ij(n, e, t, i) {
  const {
    componentType: r
  } = n;
  Qi(n.componentType);
  const s = typeof r == "string" ? dc.fromName(r) : r, c = ej[n.type], l = tj[n.type], m = nj[n.type];
  return t += n.byteOffset, {
    values: dc.createTypedArray(s, e, t, c * i),
    type: s,
    size: c,
    unpacker: l,
    packer: m
  };
}
const cc = (n) => n !== void 0;
function rj(n, e, t) {
  if (!e)
    return null;
  let i = n.getExtension("3DTILES_batch_table_hierarchy");
  const r = e.HIERARCHY;
  return r && (console.warn("3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy."), e.extensions = e.extensions || {}, e.extensions["3DTILES_batch_table_hierarchy"] = r, i = r), i ? sj(i, t) : null;
}
function sj(n, e) {
  let t, i, r;
  const s = n.instancesLength, c = n.classes;
  let l = n.classIds, m = n.parentCounts, y = n.parentIds, A = s;
  cc(l.byteOffset) && (l.componentType = defaultValue(l.componentType, GL.UNSIGNED_SHORT), l.type = AttributeType.SCALAR, r = getBinaryAccessor(l), l = r.createArrayBufferView(e.buffer, e.byteOffset + l.byteOffset, s));
  let T;
  if (cc(m))
    for (cc(m.byteOffset) && (m.componentType = defaultValue(m.componentType, GL.UNSIGNED_SHORT), m.type = AttributeType.SCALAR, r = getBinaryAccessor(m), m = r.createArrayBufferView(e.buffer, e.byteOffset + m.byteOffset, s)), T = new Uint16Array(s), A = 0, t = 0; t < s; ++t)
      T[t] = A, A += m[t];
  cc(y) && cc(y.byteOffset) && (y.componentType = defaultValue(y.componentType, GL.UNSIGNED_SHORT), y.type = AttributeType.SCALAR, r = getBinaryAccessor(y), y = r.createArrayBufferView(e.buffer, e.byteOffset + y.byteOffset, A));
  const I = c.length;
  for (t = 0; t < I; ++t) {
    const V = c[t].length, H = c[t].instances, J = getBinaryProperties(V, H, e);
    c[t].instances = combine(J, H);
  }
  const L = new Array(I).fill(0), N = new Uint16Array(s);
  for (t = 0; t < s; ++t)
    i = l[t], N[t] = L[i], ++L[i];
  const z = {
    classes: c,
    classIds: l,
    classIndexes: N,
    parentCounts: m,
    parentIndexes: T,
    parentIds: y
  };
  return lj(z), z;
}
function Hf(n, e, t) {
  if (!n)
    return;
  const i = n.parentCounts;
  return n.parentIds ? t(n, e) : i > 0 ? oj(n, e, t) : aj(n, e, t);
}
function oj(n, e, t) {
  const i = n.classIds, r = n.parentCounts, s = n.parentIds, c = n.parentIndexes, l = i.length, m = scratchVisited;
  m.length = Math.max(m.length, l);
  const y = ++marker, A = scratchStack;
  for (A.length = 0, A.push(e); A.length > 0; ) {
    if (e = A.pop(), m[e] === y)
      continue;
    m[e] = y;
    const T = t(n, e);
    if (cc(T))
      return T;
    const I = r[e], L = c[e];
    for (let N = 0; N < I; ++N) {
      const z = s[L + N];
      z !== e && A.push(z);
    }
  }
  return null;
}
function aj(n, e, t) {
  let i = !0;
  for (; i; ) {
    const r = t(n, e);
    if (cc(r))
      return r;
    const s = n.parentIds[e];
    i = s !== e, e = s;
  }
  throw new Error("traverseHierarchySingleParent");
}
function lj(n) {
  const t = n.classIds.length;
  for (let i = 0; i < t; ++i)
    HS(n, i, stack);
}
function HS(n, e, t) {
  const i = n.parentCounts, r = n.parentIds, s = n.parentIndexes, l = n.classIds.length;
  if (!cc(r))
    return;
  assert(e < l, "Parent index ".concat(e, " exceeds the total number of instances: ").concat(l)), assert(t.indexOf(e) === -1, "Circular dependency detected in the batch table hierarchy."), t.push(e);
  const m = cc(i) ? i[e] : 1, y = cc(i) ? s[e] : e;
  for (let A = 0; A < m; ++A) {
    const T = r[y + A];
    T !== e && HS(n, T, t);
  }
  t.pop(e);
}
function Mo(n) {
  return n != null;
}
const Fg = (n, e) => n, cj = {
  HIERARCHY: !0,
  extensions: !0,
  extras: !0
};
class WS {
  constructor(e, t, i) {
    var r;
    let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    G(this, "json", void 0), G(this, "binary", void 0), G(this, "featureCount", void 0), G(this, "_extensions", void 0), G(this, "_properties", void 0), G(this, "_binaryProperties", void 0), G(this, "_hierarchy", void 0), Qi(i >= 0), this.json = e || {}, this.binary = t, this.featureCount = i, this._extensions = ((r = this.json) === null || r === void 0 ? void 0 : r.extensions) || {}, this._properties = {};
    for (const c in this.json)
      cj[c] || (this._properties[c] = this.json[c]);
    this._binaryProperties = this._initializeBinaryProperties(), s["3DTILES_batch_table_hierarchy"] && (this._hierarchy = rj(this, this.json, this.binary));
  }
  getExtension(e) {
    return this.json && this.json.extensions && this.json.extensions[e];
  }
  memorySizeInBytes() {
    return 0;
  }
  isClass(e, t) {
    if (this._checkBatchId(e), Qi(typeof t == "string", t), this._hierarchy) {
      const i = Hf(this._hierarchy, e, (r, s) => {
        const c = r.classIds[s];
        return r.classes[c].name === t;
      });
      return Mo(i);
    }
    return !1;
  }
  isExactClass(e, t) {
    return Qi(typeof t == "string", t), this.getExactClassName(e) === t;
  }
  getExactClassName(e) {
    if (this._checkBatchId(e), this._hierarchy) {
      const t = this._hierarchy.classIds[e];
      return this._hierarchy.classes[t].name;
    }
  }
  hasProperty(e, t) {
    return this._checkBatchId(e), Qi(typeof t == "string", t), Mo(this._properties[t]) || this._hasPropertyInHierarchy(e, t);
  }
  getPropertyNames(e, t) {
    this._checkBatchId(e), t = Mo(t) ? t : [], t.length = 0;
    const i = Object.keys(this._properties);
    return t.push(...i), this._hierarchy && this._getPropertyNamesInHierarchy(e, t), t;
  }
  getProperty(e, t) {
    if (this._checkBatchId(e), Qi(typeof t == "string", t), this._binaryProperties) {
      const r = this._binaryProperties[t];
      if (Mo(r))
        return this._getBinaryProperty(r, e);
    }
    const i = this._properties[t];
    if (Mo(i))
      return Fg(i[e]);
    if (this._hierarchy) {
      const r = this._getHierarchyProperty(e, t);
      if (Mo(r))
        return r;
    }
  }
  setProperty(e, t, i) {
    const r = this.featureCount;
    if (this._checkBatchId(e), Qi(typeof t == "string", t), this._binaryProperties) {
      const c = this._binaryProperties[t];
      if (c) {
        this._setBinaryProperty(c, e, i);
        return;
      }
    }
    if (this._hierarchy && this._setHierarchyProperty(this, e, t, i))
      return;
    let s = this._properties[t];
    Mo(s) || (this._properties[t] = new Array(r), s = this._properties[t]), s[e] = Fg(i);
  }
  _checkBatchId(e) {
    if (!(e >= 0 && e < this.featureCount))
      throw new Error("batchId not in range [0, featureCount - 1].");
  }
  _getBinaryProperty(e, t) {
    return e.unpack(e.typedArray, t);
  }
  _setBinaryProperty(e, t, i) {
    e.pack(i, e.typedArray, t);
  }
  _initializeBinaryProperties() {
    let e = null;
    for (const t in this._properties) {
      const i = this._properties[t], r = this._initializeBinaryProperty(t, i);
      r && (e = e || {}, e[t] = r);
    }
    return e;
  }
  _initializeBinaryProperty(e, t) {
    if ("byteOffset" in t) {
      const i = t;
      Qi(this.binary, "Property ".concat(e, " requires a batch table binary.")), Qi(i.type, "Property ".concat(e, " requires a type."));
      const r = ij(i, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);
      return {
        typedArray: r.values,
        componentCount: r.size,
        unpack: r.unpacker,
        pack: r.packer
      };
    }
    return null;
  }
  _hasPropertyInHierarchy(e, t) {
    if (!this._hierarchy)
      return !1;
    const i = Hf(this._hierarchy, e, (r, s) => {
      const c = r.classIds[s], l = r.classes[c].instances;
      return Mo(l[t]);
    });
    return Mo(i);
  }
  _getPropertyNamesInHierarchy(e, t) {
    Hf(this._hierarchy, e, (i, r) => {
      const s = i.classIds[r], c = i.classes[s].instances;
      for (const l in c)
        c.hasOwnProperty(l) && t.indexOf(l) === -1 && t.push(l);
    });
  }
  _getHierarchyProperty(e, t) {
    return Hf(this._hierarchy, e, (i, r) => {
      const s = i.classIds[r], c = i.classes[s], l = i.classIndexes[r], m = c.instances[t];
      return Mo(m) ? Mo(m.typedArray) ? this._getBinaryProperty(m, l) : Fg(m[l]) : null;
    });
  }
  _setHierarchyProperty(e, t, i, r) {
    const s = Hf(this._hierarchy, t, (c, l) => {
      const m = c.classIds[l], y = c.classes[m], A = c.classIndexes[l], T = y.instances[i];
      return Mo(T) ? (Qi(l === t, 'Inherited property "'.concat(i, '" is read-only.')), Mo(T.typedArray) ? this._setBinaryProperty(T, A, r) : T[A] = Fg(r), !0) : !1;
    });
    return Mo(s);
  }
}
const R_ = 4;
function Um(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const i = new DataView(e);
  if (n.magic = i.getUint32(t, !0), t += R_, n.version = i.getUint32(t, !0), t += R_, n.byteLength = i.getUint32(t, !0), t += R_, n.version !== 1)
    throw new Error("3D Tile Version ".concat(n.version, " not supported"));
  return t;
}
const _d = 4, uA = "b3dm tile in legacy format.";
function mv(n, e, t) {
  const i = new DataView(e);
  let r;
  n.header = n.header || {};
  let s = i.getUint32(t, !0);
  t += _d;
  let c = i.getUint32(t, !0);
  t += _d;
  let l = i.getUint32(t, !0);
  t += _d;
  let m = i.getUint32(t, !0);
  return t += _d, l >= 570425344 ? (t -= _d * 2, r = s, l = c, m = 0, s = 0, c = 0, console.warn(uA)) : m >= 570425344 && (t -= _d, r = l, l = s, m = c, s = 0, c = 0, console.warn(uA)), n.header.featureTableJsonByteLength = s, n.header.featureTableBinaryByteLength = c, n.header.batchTableJsonByteLength = l, n.header.batchTableBinaryByteLength = m, n.header.batchLength = r, t;
}
function _v(n, e, t, i) {
  return t = uj(n, e, t), t = hj(n, e, t), t;
}
function uj(n, e, t, i) {
  const {
    featureTableJsonByteLength: r,
    featureTableBinaryByteLength: s,
    batchLength: c
  } = n.header;
  if (n.featureTableJson = {
    BATCH_LENGTH: c || 0
  }, r > 0) {
    const l = qS(e, t, r);
    n.featureTableJson = JSON.parse(l);
  }
  return t += r, n.featureTableBinary = new Uint8Array(e, t, s), t += s, t;
}
function hj(n, e, t, i) {
  const {
    batchTableJsonByteLength: r,
    batchTableBinaryByteLength: s
  } = n.header;
  if (r > 0) {
    const c = qS(e, t, r);
    n.batchTableJson = JSON.parse(c), t += r, s > 0 && (n.batchTableBinary = new Uint8Array(e, t, s), n.batchTableBinary = new Uint8Array(n.batchTableBinary), t += s);
  }
  return t;
}
function XS(n, e, t) {
  if (!e && (!n || !n.batchIds || !t))
    return null;
  const {
    batchIds: i,
    isRGB565: r,
    pointCount: s
  } = n;
  if (i && t) {
    const c = new Uint8ClampedArray(s * 3);
    for (let l = 0; l < s; l++) {
      const m = i[l], A = t.getProperty(m, "dimensions").map((T) => T * 255);
      c[l * 3] = A[0], c[l * 3 + 1] = A[1], c[l * 3 + 2] = A[2];
    }
    return {
      type: mi.UNSIGNED_BYTE,
      value: c,
      size: 3,
      normalized: !0
    };
  }
  if (r) {
    const c = new Uint8ClampedArray(s * 3);
    for (let l = 0; l < s; l++) {
      const m = YU(e[l]);
      c[l * 3] = m[0], c[l * 3 + 1] = m[1], c[l * 3 + 2] = m[2];
    }
    return {
      type: mi.UNSIGNED_BYTE,
      value: c,
      size: 3,
      normalized: !0
    };
  }
  return e && e.length === s * 3 ? {
    type: mi.UNSIGNED_BYTE,
    value: e,
    size: 3,
    normalized: !0
  } : {
    type: mi.UNSIGNED_BYTE,
    value: e,
    size: 4,
    normalized: !0
  };
}
const hA = new Qe();
function dj(n, e) {
  if (!e)
    return null;
  if (n.isOctEncoded16P) {
    const t = new Float32Array(n.pointsLength * 3);
    for (let i = 0; i < n.pointsLength; i++)
      QU(e[i * 2], e[i * 2 + 1], hA), hA.toArray(t, i * 3);
    return {
      type: mi.FLOAT,
      size: 2,
      value: t
    };
  }
  return {
    type: mi.FLOAT,
    size: 2,
    value: e
  };
}
function fj(n, e, t) {
  return n.isQuantized ? t["3d-tiles"] && t["3d-tiles"].decodeQuantizedPositions ? (n.isQuantized = !1, pj(n, e)) : {
    type: mi.UNSIGNED_SHORT,
    value: e,
    size: 3,
    normalized: !0
  } : e;
}
function pj(n, e) {
  const t = new Qe(), i = new Float32Array(n.pointCount * 3);
  for (let r = 0; r < n.pointCount; r++)
    t.set(e[r * 3], e[r * 3 + 1], e[r * 3 + 2]).scale(1 / n.quantizedRange).multiply(n.quantizedVolumeScale).add(n.quantizedVolumeOffset).toArray(i, r * 3);
  return i;
}
async function gj(n, e, t, i, r) {
  t = Um(n, e, t), t = mv(n, e, t), t = _v(n, e, t), mj(n);
  const {
    featureTable: s,
    batchTable: c
  } = _j(n);
  return await wj(n, s, c, i, r), yj(n, s, i), vj(n, s, c), bj(n, s), t;
}
function mj(n) {
  n.attributes = {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, n.isQuantized = !1, n.isTranslucent = !1, n.isRGB565 = !1, n.isOctEncoded16P = !1;
}
function _j(n) {
  const e = new gv(n.featureTableJson, n.featureTableBinary), t = e.getGlobalProperty("POINTS_LENGTH");
  if (!Number.isFinite(t))
    throw new Error("POINTS_LENGTH must be defined");
  e.featuresLength = t, n.featuresLength = t, n.pointsLength = t, n.pointCount = t, n.rtcCenter = e.getGlobalProperty("RTC_CENTER", mi.FLOAT, 3);
  const i = xj(n, e);
  return {
    featureTable: e,
    batchTable: i
  };
}
function yj(n, e, t) {
  if (!n.attributes.positions) {
    if (e.hasProperty("POSITION"))
      n.attributes.positions = e.getPropertyArray("POSITION", mi.FLOAT, 3);
    else if (e.hasProperty("POSITION_QUANTIZED")) {
      const i = e.getPropertyArray("POSITION_QUANTIZED", mi.UNSIGNED_SHORT, 3);
      if (n.isQuantized = !0, n.quantizedRange = 65535, n.quantizedVolumeScale = e.getGlobalProperty("QUANTIZED_VOLUME_SCALE", mi.FLOAT, 3), !n.quantizedVolumeScale)
        throw new Error("QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      if (n.quantizedVolumeOffset = e.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", mi.FLOAT, 3), !n.quantizedVolumeOffset)
        throw new Error("QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      n.attributes.positions = fj(n, i, t);
    }
  }
  if (!n.attributes.positions)
    throw new Error("Either POSITION or POSITION_QUANTIZED must be defined.");
}
function vj(n, e, t) {
  if (!n.attributes.colors) {
    let i = null;
    e.hasProperty("RGBA") ? (i = e.getPropertyArray("RGBA", mi.UNSIGNED_BYTE, 4), n.isTranslucent = !0) : e.hasProperty("RGB") ? i = e.getPropertyArray("RGB", mi.UNSIGNED_BYTE, 3) : e.hasProperty("RGB565") && (i = e.getPropertyArray("RGB565", mi.UNSIGNED_SHORT, 1), n.isRGB565 = !0), n.attributes.colors = XS(n, i, t);
  }
  e.hasProperty("CONSTANT_RGBA") && (n.constantRGBA = e.getGlobalProperty("CONSTANT_RGBA", mi.UNSIGNED_BYTE, 4));
}
function bj(n, e) {
  if (!n.attributes.normals) {
    let t = null;
    e.hasProperty("NORMAL") ? t = e.getPropertyArray("NORMAL", mi.FLOAT, 3) : e.hasProperty("NORMAL_OCT16P") && (t = e.getPropertyArray("NORMAL_OCT16P", mi.UNSIGNED_BYTE, 2), n.isOctEncoded16P = !0), n.attributes.normals = dj(n, t);
  }
}
function xj(n, e) {
  let t = null;
  if (!n.batchIds && e.hasProperty("BATCH_ID") && (n.batchIds = e.getPropertyArray("BATCH_ID", mi.UNSIGNED_SHORT, 1), n.batchIds)) {
    const i = e.getGlobalProperty("BATCH_LENGTH");
    if (!i)
      throw new Error("Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.");
    const {
      batchTableJson: r,
      batchTableBinary: s
    } = n;
    t = new WS(r, s, i);
  }
  return t;
}
async function wj(n, e, t, i, r) {
  let s, c, l;
  const m = n.batchTableJson && n.batchTableJson.extensions && n.batchTableJson.extensions["3DTILES_draco_point_compression"];
  m && (l = m.properties);
  const y = e.getExtension("3DTILES_draco_point_compression");
  if (y) {
    c = y.properties;
    const T = y.byteOffset, I = y.byteLength;
    if (!c || !Number.isFinite(T) || !I)
      throw new Error("Draco properties, byteOffset, and byteLength must be defined");
    s = n.featureTableBinary.slice(T, T + I), n.hasPositions = Number.isFinite(c.POSITION), n.hasColors = Number.isFinite(c.RGB) || Number.isFinite(c.RGBA), n.hasNormals = Number.isFinite(c.NORMAL), n.hasBatchIds = Number.isFinite(c.BATCH_ID), n.isTranslucent = Number.isFinite(c.RGBA);
  }
  if (!s)
    return !0;
  const A = {
    buffer: s,
    properties: {
      ...c,
      ...l
    },
    featureTableProperties: c,
    batchTableProperties: l,
    dequantizeInShader: !1
  };
  return await Aj(n, A, i, r);
}
async function Aj(n, e, t, i) {
  const {
    parse: r
  } = i, s = {
    ...t,
    draco: {
      ...t.draco,
      extraAttributes: e.batchTableProperties || {}
    }
  };
  delete s["3d-tiles"];
  const c = await r(e.buffer, MS, s), l = c.attributes.POSITION && c.attributes.POSITION.value, m = c.attributes.COLOR_0 && c.attributes.COLOR_0.value, y = c.attributes.NORMAL && c.attributes.NORMAL.value, A = c.attributes.BATCH_ID && c.attributes.BATCH_ID.value, T = l && c.attributes.POSITION.value.quantization, I = y && c.attributes.NORMAL.value.quantization;
  if (T) {
    const N = c.POSITION.data.quantization, z = N.range;
    n.quantizedVolumeScale = new Qe(z, z, z), n.quantizedVolumeOffset = new Qe(N.minValues), n.quantizedRange = (1 << N.quantizationBits) - 1, n.isQuantizedDraco = !0;
  }
  I && (n.octEncodedRange = (1 << c.NORMAL.data.quantization.quantizationBits) - 1, n.isOctEncodedDraco = !0);
  const L = {};
  if (e.batchTableProperties)
    for (const N of Object.keys(e.batchTableProperties))
      c.attributes[N] && c.attributes[N].value && (L[N.toLowerCase()] = c.attributes[N].value);
  n.attributes = {
    positions: l,
    colors: XS(n, m, void 0),
    normals: y,
    batchIds: A,
    ...L
  };
}
const ky = {
  URI: 0,
  EMBEDDED: 1
};
function JS(n, e, t, i) {
  n.rotateYtoZ = !0;
  const r = n.byteOffset + n.byteLength - t;
  if (r === 0)
    throw new Error("glTF byte length must be greater than 0.");
  return n.gltfUpAxis = i["3d-tiles"] && i["3d-tiles"].assetGltfUpAxis ? i["3d-tiles"].assetGltfUpAxis : "Y", n.gltfArrayBuffer = p1(e, t, r), n.gltfByteOffset = 0, n.gltfByteLength = r, t % 4 === 0 || console.warn("".concat(n.type, ": embedded glb is not aligned to a 4-byte boundary.")), n.byteOffset + n.byteLength;
}
async function $S(n, e, t, i) {
  const r = t["3d-tiles"] || {};
  if (Ej(n, e), r.loadGLTF) {
    const {
      parse: s,
      fetch: c
    } = i;
    n.gltfUrl && (n.gltfArrayBuffer = await c(n.gltfUrl, t), n.gltfByteOffset = 0), n.gltfArrayBuffer && (n.gltf = await s(n.gltfArrayBuffer, vp, t, i), n.gpuMemoryUsageInBytes = PS(n.gltf), delete n.gltfArrayBuffer, delete n.gltfByteOffset, delete n.gltfByteLength);
  }
}
function Ej(n, e, t) {
  switch (e) {
    case ky.URI:
      const i = new Uint8Array(n.gltfArrayBuffer, n.gltfByteOffset), s = new TextDecoder().decode(i);
      n.gltfUrl = s.replace(/[\s\0]+$/, ""), delete n.gltfArrayBuffer, delete n.gltfByteOffset, delete n.gltfByteLength;
      break;
    case ky.EMBEDDED:
      break;
    default:
      throw new Error("b3dm: Illegal glTF format field");
  }
}
async function Sj(n, e, t, i, r) {
  var s;
  t = Tj(n, e, t, i), await $S(n, ky.EMBEDDED, i, r);
  const c = n == null || (s = n.gltf) === null || s === void 0 ? void 0 : s.extensions;
  return c && c.CESIUM_RTC && (n.rtcCenter = c.CESIUM_RTC.center), t;
}
function Tj(n, e, t, i, r) {
  t = Um(n, e, t), t = mv(n, e, t), t = _v(n, e, t), t = JS(n, e, t, i);
  const s = new gv(n.featureTableJson, n.featureTableBinary);
  return n.rtcCenter = s.getGlobalProperty("RTC_CENTER", mi.FLOAT, 3), t;
}
async function Cj(n, e, t, i, r) {
  return t = Ij(n, e, t, i), await $S(n, n.gltfFormat, i, r), t;
}
function Ij(n, e, t, i, r) {
  if (t = Um(n, e, t), n.version !== 1)
    throw new Error("Instanced 3D Model version ".concat(n.version, " is not supported"));
  t = mv(n, e, t);
  const s = new DataView(e);
  if (n.gltfFormat = s.getUint32(t, !0), t += 4, t = _v(n, e, t), t = JS(n, e, t, i), n.featureTableJsonByteLength === 0)
    throw new Error("i3dm parser: featureTableJsonByteLength is zero.");
  const c = new gv(n.featureTableJson, n.featureTableBinary), l = c.getGlobalProperty("INSTANCES_LENGTH");
  if (c.featuresLength = l, !Number.isFinite(l))
    throw new Error("i3dm parser: INSTANCES_LENGTH must be defined");
  n.eastNorthUp = c.getGlobalProperty("EAST_NORTH_UP"), n.rtcCenter = c.getGlobalProperty("RTC_CENTER", mi.FLOAT, 3);
  const m = new WS(n.batchTableJson, n.batchTableBinary, l);
  return Pj(n, c, m, l), t;
}
function Pj(n, e, t, i) {
  const s = {
    instances: new Array(i),
    batchTable: n._batchTable,
    cull: !1,
    url: void 0,
    gltf: void 0,
    basePath: void 0,
    incrementallyLoadTextures: !1,
    forwardAxis: [1, 0, 0]
  }.instances, c = new Qe();
  new Qe(), new Qe(), new Qe();
  const l = new Ir(), m = new pp(), y = new Qe(), A = {}, T = new ai(), I = [], L = [], N = new Qe(), z = new Qe();
  for (let V = 0; V < i; V++) {
    let H;
    if (e.hasProperty("POSITION"))
      H = e.getProperty("POSITION", mi.FLOAT, 3, V, c);
    else if (e.hasProperty("POSITION_QUANTIZED")) {
      H = e.getProperty("POSITION_QUANTIZED", mi.UNSIGNED_SHORT, 3, V, c);
      const Le = e.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", mi.FLOAT, 3, N);
      if (!Le)
        throw new Error("i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      const ye = e.getGlobalProperty("QUANTIZED_VOLUME_SCALE", mi.FLOAT, 3, z);
      if (!ye)
        throw new Error("i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      const Ve = 65535;
      for (let Fe = 0; Fe < 3; Fe++)
        H[Fe] = H[Fe] / Ve * ye[Fe] + Le[Fe];
    }
    if (!H)
      throw new Error("i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.");
    if (c.copy(H), A.translation = c, n.normalUp = e.getProperty("NORMAL_UP", mi.FLOAT, 3, V, I), n.normalRight = e.getProperty("NORMAL_RIGHT", mi.FLOAT, 3, V, L), n.normalUp) {
      if (!n.normalRight)
        throw new Error("i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.");
      n.hasCustomOrientation = !0;
    } else {
      if (n.octNormalUp = e.getProperty("NORMAL_UP_OCT32P", mi.UNSIGNED_SHORT, 2, I), n.octNormalRight = e.getProperty("NORMAL_RIGHT_OCT32P", mi.UNSIGNED_SHORT, 2, L), n.octNormalUp)
        throw n.octNormalRight ? new Error("i3dm: oct-encoded orientation not implemented") : new Error("i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P");
      n.eastNorthUp ? (yr.WGS84.eastNorthUpToFixedFrame(c, T), T.getRotationMatrix3(l)) : l.identity();
    }
    m.fromMatrix3(l), A.rotation = m, y.set(1, 1, 1);
    const J = e.getProperty("SCALE", mi.FLOAT, 1, V);
    Number.isFinite(J) && y.multiplyByScalar(J);
    const ce = e.getProperty("SCALE_NON_UNIFORM", mi.FLOAT, 3, V, I);
    ce && y.scale(ce), A.scale = y;
    let me = e.getProperty("BATCH_ID", mi.UNSIGNED_SHORT, 1, V);
    me === void 0 && (me = V);
    const Se = new ai().fromQuaternion(A.rotation);
    T.identity(), T.translate(A.translation), T.multiplyRight(Se), T.scale(A.scale);
    const De = T.clone();
    s[V] = {
      modelMatrix: De,
      batchId: me
    };
  }
  n.instances = s;
}
async function Lj(n, e, t, i, r, s) {
  t = Um(n, e, t);
  const c = new DataView(e);
  for (n.tilesLength = c.getUint32(t, !0), t += 4, n.tiles = []; n.tiles.length < n.tilesLength && n.byteLength - t > 12; ) {
    const l = {};
    n.tiles.push(l), t = await s(e, t, i, r, l);
  }
  return t;
}
async function Mj(n, e, t, i) {
  n.rotateYtoZ = !0, n.gltfUpAxis = t["3d-tiles"] && t["3d-tiles"].assetGltfUpAxis ? t["3d-tiles"].assetGltfUpAxis : "Y";
  const {
    parse: r
  } = i;
  n.gltf = await r(e, vp, t, i), n.gpuMemoryUsageInBytes = PS(n.gltf);
}
async function ZS(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = arguments.length > 2 ? arguments[2] : void 0, i = arguments.length > 3 ? arguments[3] : void 0, r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  switch (r.byteOffset = e, r.type = XU(n, e), r.type) {
    case qf.COMPOSITE:
      return await Lj(r, n, e, t, i, ZS);
    case qf.BATCHED_3D_MODEL:
      return await Sj(r, n, e, t, i);
    case qf.GLTF:
      return await Mj(r, n, t, i);
    case qf.INSTANCED_3D_MODEL:
      return await Cj(r, n, e, t, i);
    case qf.POINT_CLOUD:
      return await gj(r, n, e, t, i);
    default:
      throw new Error("3DTileLoader: unknown type ".concat(r.type));
  }
}
const Bj = 1952609651, Rj = 1;
async function Oj(n, e, t) {
  if (new Uint32Array(n.slice(0, 4))[0] !== Bj)
    throw new Error("Wrong subtree file magic number");
  if (new Uint32Array(n.slice(4, 8))[0] !== Rj)
    throw new Error("Wrong subtree file verson, must be 1");
  const s = dA(n.slice(8, 16)), c = new Uint8Array(n, 24, s), m = new TextDecoder("utf8").decode(c), y = JSON.parse(m), A = dA(n.slice(16, 24));
  let T = new ArrayBuffer(0);
  return A && (T = n.slice(24 + s)), "bufferView" in y.tileAvailability && (y.tileAvailability.explicitBitstream = await O_(y, "tileAvailability", T, t)), "bufferView" in y.contentAvailability && (y.contentAvailability.explicitBitstream = await O_(y, "contentAvailability", T, t)), "bufferView" in y.childSubtreeAvailability && (y.childSubtreeAvailability.explicitBitstream = await O_(y, "childSubtreeAvailability", T, t)), y;
}
function Fj(n, e) {
  if (e.startsWith("http")) {
    const s = new URL(n, e);
    return decodeURI(s.toString());
  }
  const i = "http://".concat(e), r = new URL(n, i);
  return "/".concat(r.host).concat(r.pathname);
}
async function O_(n, e, t, i) {
  const r = n[e].bufferView, s = n.bufferViews[r], c = n.buffers[s.buffer];
  if (!(i != null && i.url) || !i.fetch)
    throw new Error("Url is not provided");
  if (!i.fetch)
    throw new Error("fetch is not provided");
  if (c.uri) {
    const l = Fj(c.uri, i == null ? void 0 : i.url), y = await (await i.fetch(l)).arrayBuffer();
    return new Uint8Array(y, s.byteOffset, s.byteLength);
  }
  return new Uint8Array(t, s.byteOffset, s.byteLength);
}
function dA(n) {
  const e = new DataView(n), t = e.getUint32(0, !0), i = e.getUint32(4, !0);
  return t + 2 ** 32 * i;
}
const YS = {
  id: "3d-tiles-subtree",
  name: "3D Tiles Subtree",
  module: "3d-tiles",
  version: VS,
  extensions: ["subtree"],
  mimeTypes: ["application/octet-stream"],
  tests: ["subtree"],
  parse: Oj,
  options: {}
};
/**
 * @license
 * Copyright 2009 The Closure Library Authors
 * Copyright 2020 Daniel Wirtz / The long.js Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
var Ja = null;
try {
  Ja = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
} catch {
}
function Ui(n, e, t) {
  this.low = n | 0, this.high = e | 0, this.unsigned = !!t;
}
Ui.prototype.__isLong__;
Object.defineProperty(Ui.prototype, "__isLong__", {
  value: !0
});
function $s(n) {
  return (n && n.__isLong__) === !0;
}
function fA(n) {
  var e = Math.clz32(n & -n);
  return n ? 31 - e : e;
}
Ui.isLong = $s;
var pA = {}, gA = {};
function qh(n, e) {
  var t, i, r;
  return e ? (n >>>= 0, (r = 0 <= n && n < 256) && (i = gA[n], i) ? i : (t = vi(n, 0, !0), r && (gA[n] = t), t)) : (n |= 0, (r = -128 <= n && n < 128) && (i = pA[n], i) ? i : (t = vi(n, n < 0 ? -1 : 0, !1), r && (pA[n] = t), t));
}
Ui.fromInt = qh;
function $a(n, e) {
  if (isNaN(n))
    return e ? Zc : Tl;
  if (e) {
    if (n < 0)
      return Zc;
    if (n >= KS)
      return tT;
  } else {
    if (n <= -_A)
      return Oo;
    if (n + 1 >= _A)
      return eT;
  }
  return n < 0 ? $a(-n, e).neg() : vi(n % $d | 0, n / $d | 0, e);
}
Ui.fromNumber = $a;
function vi(n, e, t) {
  return new Ui(n, e, t);
}
Ui.fromBits = vi;
var Sm = Math.pow;
function yv(n, e, t) {
  if (n.length === 0)
    throw Error("empty string");
  if (typeof e == "number" ? (t = e, e = !1) : e = !!e, n === "NaN" || n === "Infinity" || n === "+Infinity" || n === "-Infinity")
    return e ? Zc : Tl;
  if (t = t || 10, t < 2 || 36 < t)
    throw RangeError("radix");
  var i;
  if ((i = n.indexOf("-")) > 0)
    throw Error("interior hyphen");
  if (i === 0)
    return yv(n.substring(1), e, t).neg();
  for (var r = $a(Sm(t, 8)), s = Tl, c = 0; c < n.length; c += 8) {
    var l = Math.min(8, n.length - c), m = parseInt(n.substring(c, c + l), t);
    if (l < 8) {
      var y = $a(Sm(t, l));
      s = s.mul(y).add($a(m));
    } else
      s = s.mul(r), s = s.add($a(m));
  }
  return s.unsigned = e, s;
}
Ui.fromString = yv;
function Ll(n, e) {
  return typeof n == "number" ? $a(n, e) : typeof n == "string" ? yv(n, e) : vi(n.low, n.high, typeof e == "boolean" ? e : n.unsigned);
}
Ui.fromValue = Ll;
var mA = 65536, Dj = 1 << 24, $d = mA * mA, KS = $d * $d, _A = KS / 2, yA = qh(Dj), Tl = qh(0);
Ui.ZERO = Tl;
var Zc = qh(0, !0);
Ui.UZERO = Zc;
var Id = qh(1);
Ui.ONE = Id;
var QS = qh(1, !0);
Ui.UONE = QS;
var Ny = qh(-1);
Ui.NEG_ONE = Ny;
var eT = vi(-1, 2147483647, !1);
Ui.MAX_VALUE = eT;
var tT = vi(-1, -1, !0);
Ui.MAX_UNSIGNED_VALUE = tT;
var Oo = vi(0, -2147483648, !1);
Ui.MIN_VALUE = Oo;
var Mt = Ui.prototype;
Mt.toInt = function() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
Mt.toNumber = function() {
  return this.unsigned ? (this.high >>> 0) * $d + (this.low >>> 0) : this.high * $d + (this.low >>> 0);
};
Mt.toString = function(e) {
  if (e = e || 10, e < 2 || 36 < e)
    throw RangeError("radix");
  if (this.isZero())
    return "0";
  if (this.isNegative())
    if (this.eq(Oo)) {
      var t = $a(e), i = this.div(t), r = i.mul(t).sub(this);
      return i.toString(e) + r.toInt().toString(e);
    } else
      return "-" + this.neg().toString(e);
  for (var s = $a(Sm(e, 6), this.unsigned), c = this, l = ""; ; ) {
    var m = c.div(s), y = c.sub(m.mul(s)).toInt() >>> 0, A = y.toString(e);
    if (c = m, c.isZero())
      return A + l;
    for (; A.length < 6; )
      A = "0" + A;
    l = "" + A + l;
  }
};
Mt.getHighBits = function() {
  return this.high;
};
Mt.getHighBitsUnsigned = function() {
  return this.high >>> 0;
};
Mt.getLowBits = function() {
  return this.low;
};
Mt.getLowBitsUnsigned = function() {
  return this.low >>> 0;
};
Mt.getNumBitsAbs = function() {
  if (this.isNegative())
    return this.eq(Oo) ? 64 : this.neg().getNumBitsAbs();
  for (var e = this.high != 0 ? this.high : this.low, t = 31; t > 0 && !(e & 1 << t); t--)
    ;
  return this.high != 0 ? t + 33 : t + 1;
};
Mt.isZero = function() {
  return this.high === 0 && this.low === 0;
};
Mt.eqz = Mt.isZero;
Mt.isNegative = function() {
  return !this.unsigned && this.high < 0;
};
Mt.isPositive = function() {
  return this.unsigned || this.high >= 0;
};
Mt.isOdd = function() {
  return (this.low & 1) === 1;
};
Mt.isEven = function() {
  return (this.low & 1) === 0;
};
Mt.equals = function(e) {
  return $s(e) || (e = Ll(e)), this.unsigned !== e.unsigned && this.high >>> 31 === 1 && e.high >>> 31 === 1 ? !1 : this.high === e.high && this.low === e.low;
};
Mt.eq = Mt.equals;
Mt.notEquals = function(e) {
  return !this.eq(
    /* validates */
    e
  );
};
Mt.neq = Mt.notEquals;
Mt.ne = Mt.notEquals;
Mt.lessThan = function(e) {
  return this.comp(
    /* validates */
    e
  ) < 0;
};
Mt.lt = Mt.lessThan;
Mt.lessThanOrEqual = function(e) {
  return this.comp(
    /* validates */
    e
  ) <= 0;
};
Mt.lte = Mt.lessThanOrEqual;
Mt.le = Mt.lessThanOrEqual;
Mt.greaterThan = function(e) {
  return this.comp(
    /* validates */
    e
  ) > 0;
};
Mt.gt = Mt.greaterThan;
Mt.greaterThanOrEqual = function(e) {
  return this.comp(
    /* validates */
    e
  ) >= 0;
};
Mt.gte = Mt.greaterThanOrEqual;
Mt.ge = Mt.greaterThanOrEqual;
Mt.compare = function(e) {
  if ($s(e) || (e = Ll(e)), this.eq(e))
    return 0;
  var t = this.isNegative(), i = e.isNegative();
  return t && !i ? -1 : !t && i ? 1 : this.unsigned ? e.high >>> 0 > this.high >>> 0 || e.high === this.high && e.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e).isNegative() ? -1 : 1;
};
Mt.comp = Mt.compare;
Mt.negate = function() {
  return !this.unsigned && this.eq(Oo) ? Oo : this.not().add(Id);
};
Mt.neg = Mt.negate;
Mt.add = function(e) {
  $s(e) || (e = Ll(e));
  var t = this.high >>> 16, i = this.high & 65535, r = this.low >>> 16, s = this.low & 65535, c = e.high >>> 16, l = e.high & 65535, m = e.low >>> 16, y = e.low & 65535, A = 0, T = 0, I = 0, L = 0;
  return L += s + y, I += L >>> 16, L &= 65535, I += r + m, T += I >>> 16, I &= 65535, T += i + l, A += T >>> 16, T &= 65535, A += t + c, A &= 65535, vi(I << 16 | L, A << 16 | T, this.unsigned);
};
Mt.subtract = function(e) {
  return $s(e) || (e = Ll(e)), this.add(e.neg());
};
Mt.sub = Mt.subtract;
Mt.multiply = function(e) {
  if (this.isZero())
    return this;
  if ($s(e) || (e = Ll(e)), Ja) {
    var t = Ja.mul(this.low, this.high, e.low, e.high);
    return vi(t, Ja.get_high(), this.unsigned);
  }
  if (e.isZero())
    return this.unsigned ? Zc : Tl;
  if (this.eq(Oo))
    return e.isOdd() ? Oo : Tl;
  if (e.eq(Oo))
    return this.isOdd() ? Oo : Tl;
  if (this.isNegative())
    return e.isNegative() ? this.neg().mul(e.neg()) : this.neg().mul(e).neg();
  if (e.isNegative())
    return this.mul(e.neg()).neg();
  if (this.lt(yA) && e.lt(yA))
    return $a(this.toNumber() * e.toNumber(), this.unsigned);
  var i = this.high >>> 16, r = this.high & 65535, s = this.low >>> 16, c = this.low & 65535, l = e.high >>> 16, m = e.high & 65535, y = e.low >>> 16, A = e.low & 65535, T = 0, I = 0, L = 0, N = 0;
  return N += c * A, L += N >>> 16, N &= 65535, L += s * A, I += L >>> 16, L &= 65535, L += c * y, I += L >>> 16, L &= 65535, I += r * A, T += I >>> 16, I &= 65535, I += s * y, T += I >>> 16, I &= 65535, I += c * m, T += I >>> 16, I &= 65535, T += i * A + r * y + s * m + c * l, T &= 65535, vi(L << 16 | N, T << 16 | I, this.unsigned);
};
Mt.mul = Mt.multiply;
Mt.divide = function(e) {
  if ($s(e) || (e = Ll(e)), e.isZero())
    throw Error("division by zero");
  if (Ja) {
    if (!this.unsigned && this.high === -2147483648 && e.low === -1 && e.high === -1)
      return this;
    var t = (this.unsigned ? Ja.div_u : Ja.div_s)(this.low, this.high, e.low, e.high);
    return vi(t, Ja.get_high(), this.unsigned);
  }
  if (this.isZero())
    return this.unsigned ? Zc : Tl;
  var i, r, s;
  if (this.unsigned) {
    if (e.unsigned || (e = e.toUnsigned()), e.gt(this))
      return Zc;
    if (e.gt(this.shru(1)))
      return QS;
    s = Zc;
  } else {
    if (this.eq(Oo)) {
      if (e.eq(Id) || e.eq(Ny))
        return Oo;
      if (e.eq(Oo))
        return Id;
      var c = this.shr(1);
      return i = c.div(e).shl(1), i.eq(Tl) ? e.isNegative() ? Id : Ny : (r = this.sub(e.mul(i)), s = i.add(r.div(e)), s);
    } else if (e.eq(Oo))
      return this.unsigned ? Zc : Tl;
    if (this.isNegative())
      return e.isNegative() ? this.neg().div(e.neg()) : this.neg().div(e).neg();
    if (e.isNegative())
      return this.div(e.neg()).neg();
    s = Tl;
  }
  for (r = this; r.gte(e); ) {
    i = Math.max(1, Math.floor(r.toNumber() / e.toNumber()));
    for (var l = Math.ceil(Math.log(i) / Math.LN2), m = l <= 48 ? 1 : Sm(2, l - 48), y = $a(i), A = y.mul(e); A.isNegative() || A.gt(r); )
      i -= m, y = $a(i, this.unsigned), A = y.mul(e);
    y.isZero() && (y = Id), s = s.add(y), r = r.sub(A);
  }
  return s;
};
Mt.div = Mt.divide;
Mt.modulo = function(e) {
  if ($s(e) || (e = Ll(e)), Ja) {
    var t = (this.unsigned ? Ja.rem_u : Ja.rem_s)(this.low, this.high, e.low, e.high);
    return vi(t, Ja.get_high(), this.unsigned);
  }
  return this.sub(this.div(e).mul(e));
};
Mt.mod = Mt.modulo;
Mt.rem = Mt.modulo;
Mt.not = function() {
  return vi(~this.low, ~this.high, this.unsigned);
};
Mt.countLeadingZeros = function() {
  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
};
Mt.clz = Mt.countLeadingZeros;
Mt.countTrailingZeros = function() {
  return this.low ? fA(this.low) : fA(this.high) + 32;
};
Mt.ctz = Mt.countTrailingZeros;
Mt.and = function(e) {
  return $s(e) || (e = Ll(e)), vi(this.low & e.low, this.high & e.high, this.unsigned);
};
Mt.or = function(e) {
  return $s(e) || (e = Ll(e)), vi(this.low | e.low, this.high | e.high, this.unsigned);
};
Mt.xor = function(e) {
  return $s(e) || (e = Ll(e)), vi(this.low ^ e.low, this.high ^ e.high, this.unsigned);
};
Mt.shiftLeft = function(e) {
  return $s(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? vi(this.low << e, this.high << e | this.low >>> 32 - e, this.unsigned) : vi(0, this.low << e - 32, this.unsigned);
};
Mt.shl = Mt.shiftLeft;
Mt.shiftRight = function(e) {
  return $s(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? vi(this.low >>> e | this.high << 32 - e, this.high >> e, this.unsigned) : vi(this.high >> e - 32, this.high >= 0 ? 0 : -1, this.unsigned);
};
Mt.shr = Mt.shiftRight;
Mt.shiftRightUnsigned = function(e) {
  return $s(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? vi(this.low >>> e | this.high << 32 - e, this.high >>> e, this.unsigned) : e === 32 ? vi(this.high, 0, this.unsigned) : vi(this.high >>> e - 32, 0, this.unsigned);
};
Mt.shru = Mt.shiftRightUnsigned;
Mt.shr_u = Mt.shiftRightUnsigned;
Mt.rotateLeft = function(e) {
  var t;
  return $s(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e === 32 ? vi(this.high, this.low, this.unsigned) : e < 32 ? (t = 32 - e, vi(this.low << e | this.high >>> t, this.high << e | this.low >>> t, this.unsigned)) : (e -= 32, t = 32 - e, vi(this.high << e | this.low >>> t, this.low << e | this.high >>> t, this.unsigned));
};
Mt.rotl = Mt.rotateLeft;
Mt.rotateRight = function(e) {
  var t;
  return $s(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e === 32 ? vi(this.high, this.low, this.unsigned) : e < 32 ? (t = 32 - e, vi(this.high << t | this.low >>> e, this.low << t | this.high >>> e, this.unsigned)) : (e -= 32, t = 32 - e, vi(this.low << t | this.high >>> e, this.high << t | this.low >>> e, this.unsigned));
};
Mt.rotr = Mt.rotateRight;
Mt.toSigned = function() {
  return this.unsigned ? vi(this.low, this.high, !1) : this;
};
Mt.toUnsigned = function() {
  return this.unsigned ? this : vi(this.low, this.high, !0);
};
Mt.toBytes = function(e) {
  return e ? this.toBytesLE() : this.toBytesBE();
};
Mt.toBytesLE = function() {
  var e = this.high, t = this.low;
  return [t & 255, t >>> 8 & 255, t >>> 16 & 255, t >>> 24, e & 255, e >>> 8 & 255, e >>> 16 & 255, e >>> 24];
};
Mt.toBytesBE = function() {
  var e = this.high, t = this.low;
  return [e >>> 24, e >>> 16 & 255, e >>> 8 & 255, e & 255, t >>> 24, t >>> 16 & 255, t >>> 8 & 255, t & 255];
};
Ui.fromBytes = function(e, t, i) {
  return i ? Ui.fromBytesLE(e, t) : Ui.fromBytesBE(e, t);
};
Ui.fromBytesLE = function(e, t) {
  return new Ui(e[0] | e[1] << 8 | e[2] << 16 | e[3] << 24, e[4] | e[5] << 8 | e[6] << 16 | e[7] << 24, t);
};
Ui.fromBytesBE = function(e, t) {
  return new Ui(e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7], e[0] << 24 | e[1] << 16 | e[2] << 8 | e[3], t);
};
const kj = 16;
function nT(n) {
  n === "X" && (n = "");
  const e = n.padEnd(kj, "0");
  return Ui.fromString(e, !0, 16);
}
function Nj(n) {
  if (n.isZero())
    return "X";
  let e = n.countTrailingZeros();
  const t = e % 4;
  e = (e - t) / 4;
  const i = e;
  e *= 4;
  const s = n.shiftRightUnsigned(e).toString(16).replace(/0+$/, "");
  return Array(17 - i - s.length).join("0") + s;
}
function zj(n, e) {
  const t = Uj(n).shiftRightUnsigned(2);
  return n.add(Ui.fromNumber(2 * e + 1 - 4).multiply(t));
}
function Uj(n) {
  return n.and(n.not().add(1));
}
const jj = 3, Gj = 30, Vj = 2 * Gj + 1, vA = 180 / Math.PI;
function qj(n) {
  if (n.length === 0)
    throw new Error("Invalid Hilbert quad key ".concat(n));
  const e = n.split("/"), t = parseInt(e[0], 10), i = e[1], r = i.length;
  let s = 0;
  const c = [0, 0];
  for (let l = r - 1; l >= 0; l--) {
    s = r - l;
    const m = i[l];
    let y = 0, A = 0;
    m === "1" ? A = 1 : m === "2" ? (y = 1, A = 1) : m === "3" && (y = 1);
    const T = Math.pow(2, s - 1);
    Wj(T, c, y, A), c[0] += T * y, c[1] += T * A;
  }
  if (t % 2 === 1) {
    const l = c[0];
    c[0] = c[1], c[1] = l;
  }
  return {
    face: t,
    ij: c,
    level: s
  };
}
function Hj(n) {
  if (n.isZero())
    return "";
  let e = n.toString(2);
  for (; e.length < jj + Vj; )
    e = "0" + e;
  const t = e.lastIndexOf("1"), i = e.substring(0, 3), r = e.substring(3, t), s = r.length / 2, c = Ui.fromString(i, !0, 2).toString(10);
  let l = "";
  if (s !== 0)
    for (l = Ui.fromString(r, !0, 2).toString(4); l.length < s; )
      l = "0" + l;
  return "".concat(c, "/").concat(l);
}
function iT(n, e, t) {
  const i = 1 << e;
  return [(n[0] + t[0]) / i, (n[1] + t[1]) / i];
}
function bA(n) {
  return n >= 0.5 ? 1 / 3 * (4 * n * n - 1) : 1 / 3 * (1 - 4 * (1 - n) * (1 - n));
}
function rT(n) {
  return [bA(n[0]), bA(n[1])];
}
function sT(n, e) {
  let [t, i] = e;
  switch (n) {
    case 0:
      return [1, t, i];
    case 1:
      return [-t, 1, i];
    case 2:
      return [-t, -i, 1];
    case 3:
      return [-1, -i, -t];
    case 4:
      return [i, -1, -t];
    case 5:
      return [i, t, -1];
    default:
      throw new Error("Invalid face");
  }
}
function oT(n) {
  let [e, t, i] = n;
  const r = Math.atan2(i, Math.sqrt(e * e + t * t));
  return [Math.atan2(t, e) * vA, r * vA];
}
function Wj(n, e, t, i) {
  if (i === 0) {
    t === 1 && (e[0] = n - 1 - e[0], e[1] = n - 1 - e[1]);
    const r = e[0];
    e[0] = e[1], e[1] = r;
  }
}
function Xj(n) {
  const e = iT(n.ij, n.level, [0.5, 0.5]), t = rT(e), i = sT(n.face, t);
  return oT(i);
}
const Jj = 100;
function xA(n) {
  const {
    face: e,
    ij: t,
    level: i
  } = n, r = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]], s = Math.max(1, Math.ceil(Jj * Math.pow(2, -i))), c = new Float64Array(4 * s * 2 + 2);
  let l = 0, m = 0;
  for (let y = 0; y < 4; y++) {
    const A = r[y].slice(0), T = r[y + 1], I = (T[0] - A[0]) / s, L = (T[1] - A[1]) / s;
    for (let N = 0; N < s; N++) {
      A[0] += I, A[1] += L;
      const z = iT(t, i, A), V = rT(z), H = sT(e, V), J = oT(H);
      Math.abs(J[1]) > 89.999 && (J[0] = m);
      const ce = J[0] - m;
      J[0] += ce > 180 ? -360 : ce < -180 ? 360 : 0, c[l++] = J[0], c[l++] = J[1], m = J[0];
    }
  }
  return c[l++] = c[0], c[l++] = c[1], c;
}
function vv(n) {
  const e = $j(n);
  return qj(e);
}
function $j(n) {
  if (n.indexOf("/") > 0)
    return n;
  const e = nT(n);
  return Hj(e);
}
function Zj(n) {
  const e = vv(n);
  return Xj(e);
}
function Yj(n) {
  let e;
  if (n.face === 2 || n.face === 5) {
    let t = null, i = 0;
    for (let r = 0; r < 4; r++) {
      const s = "".concat(n.face, "/").concat(r), c = vv(s), l = xA(c);
      (typeof t > "u" || t === null) && (t = new Float64Array(4 * l.length)), t.set(l, i), i += l.length;
    }
    e = wA(t);
  } else {
    const t = xA(n);
    e = wA(t);
  }
  return e;
}
function wA(n) {
  if (n.length % 2 !== 0)
    throw new Error("Invalid corners");
  const e = [], t = [];
  for (let i = 0; i < n.length; i += 2)
    e.push(n[i]), t.push(n[i + 1]);
  return e.sort((i, r) => i - r), t.sort((i, r) => i - r), {
    west: e[0],
    east: e[e.length - 1],
    north: t[t.length - 1],
    south: t[0]
  };
}
function Kj(n, e) {
  const t = (e == null ? void 0 : e.minimumHeight) || 0, i = (e == null ? void 0 : e.maximumHeight) || 0, r = vv(n), s = Yj(r), c = s.west, l = s.south, m = s.east, y = s.north, A = [];
  return A.push(new Qe(c, y, t)), A.push(new Qe(m, y, t)), A.push(new Qe(m, l, t)), A.push(new Qe(c, l, t)), A.push(new Qe(c, y, i)), A.push(new Qe(m, y, i)), A.push(new Qe(m, l, i)), A.push(new Qe(c, l, i)), A;
}
function aT(n) {
  const e = n.token, t = {
    minimumHeight: n.minimumHeight,
    maximumHeight: n.maximumHeight
  }, i = Kj(e, t), r = Zj(e), s = r[0], c = r[1], l = yr.WGS84.cartographicToCartesian([s, c, t.maximumHeight]), m = new Qe(l[0], l[1], l[2]);
  i.push(m);
  const y = S8(i);
  return [...y.center, ...y.halfAxes];
}
const Qj = 4, eG = 8, tG = {
  QUADTREE: Qj,
  OCTREE: eG
};
function nG(n, e, t) {
  if (n != null && n.box) {
    const i = nT(n.s2VolumeInfo.token), r = zj(i, e), s = Nj(r), c = {
      ...n.s2VolumeInfo
    };
    switch (c.token = s, t) {
      case "OCTREE":
        const y = n.s2VolumeInfo, A = y.maximumHeight - y.minimumHeight, T = A / 2, I = y.minimumHeight + A / 2;
        y.minimumHeight = I - T, y.maximumHeight = I + T;
        break;
    }
    return {
      box: aT(c),
      s2VolumeInfo: c
    };
  }
}
async function lT(n) {
  const {
    options: e,
    parentData: t = {
      mortonIndex: 0,
      x: 0,
      y: 0,
      z: 0
    },
    childIndex: i = 0,
    globalData: r = {
      level: 0,
      mortonIndex: 0,
      x: 0,
      y: 0,
      z: 0
    },
    s2VolumeBox: s
  } = n;
  let {
    subtree: c,
    level: l = 0
  } = n;
  const {
    subdivisionScheme: m,
    subtreeLevels: y,
    maximumLevel: A,
    contentUrlTemplate: T,
    subtreesUriTemplate: I,
    basePath: L
  } = e, N = {
    children: [],
    lodMetricValue: 0,
    contentUrl: ""
  }, z = tG[m], V = i & 1, H = i >> 1 & 1, J = i >> 2 & 1, ce = (z ** l - 1) / (z - 1);
  let me = wh(t.mortonIndex, i), Se = ce + me, De = wh(t.x, V), Le = wh(t.y, H), ye = wh(t.z, J), Ve = !1;
  l + 1 > y && (Ve = F_(c.childSubtreeAvailability, me));
  const Fe = wh(r.x, De), ae = wh(r.y, Le), de = wh(r.z, ye), Te = l + r.level;
  if (Ve) {
    const Ye = "".concat(L, "/").concat(I), ht = zy(Ye, Te, Fe, ae, de);
    c = await Ju(ht, YS), r.mortonIndex = me, r.x = De, r.y = Le, r.z = ye, r.level = l, me = 0, Se = 0, De = 0, Le = 0, ye = 0, l = 0;
  }
  if (!F_(c.tileAvailability, Se) || l > A)
    return N;
  F_(c.contentAvailability, Se) && (N.contentUrl = zy(T, Te, Fe, ae, de));
  const st = l + 1, lt = {
    mortonIndex: me,
    x: De,
    y: Le,
    z: ye
  };
  for (let Ye = 0; Ye < z; Ye++) {
    const ht = nG(s, Ye, m), ct = await lT({
      subtree: c,
      options: e,
      parentData: lt,
      childIndex: Ye,
      level: st,
      globalData: r,
      s2VolumeBox: ht
    });
    if (ct.contentUrl || ct.children.length) {
      const Pt = Te + 1, Ae = iG(ct, Pt, {
        childTileX: De,
        childTileY: Le,
        childTileZ: ye
      }, e, s);
      N.children.push(Ae);
    }
  }
  return N;
}
function F_(n, e) {
  return "constant" in n ? !!n.constant : n.explicitBitstream ? oG(e, n.explicitBitstream) : !1;
}
function iG(n, e, t, i, r) {
  const {
    basePath: s,
    refine: c,
    getRefine: l,
    lodMetricType: m,
    getTileType: y,
    rootLodMetricValue: A,
    rootBoundingVolume: T
  } = i, I = n.contentUrl && n.contentUrl.replace("".concat(s, "/"), ""), L = A / 2 ** e, N = r != null && r.box ? {
    box: r.box
  } : T, z = rG(e, N, t);
  return {
    children: n.children,
    contentUrl: n.contentUrl,
    content: {
      uri: I
    },
    id: n.contentUrl,
    refine: l(c),
    type: y(n),
    lodMetricType: m,
    lodMetricValue: L,
    geometricError: L,
    transform: n.transform,
    boundingVolume: z
  };
}
function rG(n, e, t) {
  if (e.region) {
    const {
      childTileX: i,
      childTileY: r,
      childTileZ: s
    } = t, [c, l, m, y, A, T] = e.region, I = 2 ** n, L = (m - c) / I, N = (y - l) / I, z = (T - A) / I, [V, H] = [c + L * i, c + L * (i + 1)], [J, ce] = [l + N * r, l + N * (r + 1)], [me, Se] = [A + z * s, A + z * (s + 1)];
    return {
      region: [V, J, H, ce, me, Se]
    };
  }
  if (e.box)
    return e;
  throw new Error("Unsupported bounding volume type ".concat(e));
}
function wh(n, e) {
  return parseInt(n.toString(2) + e.toString(2), 2);
}
function zy(n, e, t, i, r) {
  const s = sG({
    level: e,
    x: t,
    y: i,
    z: r
  });
  return n.replace(/{level}|{x}|{y}|{z}/gi, (c) => s[c]);
}
function sG(n) {
  const e = {};
  for (const t in n)
    e["{".concat(t, "}")] = n[t];
  return e;
}
function oG(n, e) {
  const t = Math.floor(n / 8), i = n % 8;
  return (e[t] >> i & 1) === 1;
}
function bv(n) {
  if (!n.contentUrl)
    return Od.EMPTY;
  const t = n.contentUrl.split("?")[0].split(".").pop();
  switch (t) {
    case "pnts":
      return Od.POINTCLOUD;
    case "i3dm":
    case "b3dm":
    case "glb":
    case "gltf":
      return Od.SCENEGRAPH;
    default:
      return t;
  }
}
function xv(n) {
  switch (n) {
    case "REPLACE":
    case "replace":
      return Kc.REPLACE;
    case "ADD":
    case "add":
      return Kc.ADD;
    default:
      return n;
  }
}
function Uy(n, e) {
  if (/^[a-z][0-9a-z+.-]*:/i.test(e)) {
    const i = new URL(n, "".concat(e, "/"));
    return decodeURI(i.toString());
  } else if (n.startsWith("/"))
    return n;
  return "".concat(e, "/").concat(n);
}
function AA(n, e) {
  if (!n)
    return null;
  if (n.content) {
    const t = n.content.uri || n.content.url;
    n.contentUrl = Uy(t, e.basePath);
  }
  return n.id = n.contentUrl, n.lodMetricType = Nm.GEOMETRIC_ERROR, n.lodMetricValue = n.geometricError, n.transformMatrix = n.transform, n.type = bv(n), n.refine = xv(n.refine), n;
}
async function aG(n, e) {
  const t = n.basePath;
  let i;
  const r = SA(n == null ? void 0 : n.root);
  r && n.root ? i = await EA(n.root, n, r, e) : i = AA(n.root, n);
  const s = [];
  for (s.push(i); s.length > 0; ) {
    const l = (s.pop() || {}).children || [];
    for (let m of l) {
      const y = SA(m);
      y ? m = await EA(m, n, y, e) : AA(m, {
        basePath: t
      }), s.push(m);
    }
  }
  return i;
}
async function EA(n, e, t, i) {
  var r, s;
  const c = e.basePath, {
    subdivisionScheme: l,
    maximumLevel: m,
    subtreeLevels: y,
    subtrees: {
      uri: A
    }
  } = t, T = zy(A, 0, 0, 0, 0), I = Uy(T, c), L = await Ju(I, YS, i), N = Uy(n.content.uri, c), z = e == null || (r = e.root) === null || r === void 0 ? void 0 : r.refine, V = n.geometricError, H = (s = n.boundingVolume.extensions) === null || s === void 0 ? void 0 : s["3DTILES_bounding_volume_S2"];
  if (H) {
    const Se = {
      box: aT(H),
      s2VolumeInfo: H
    };
    n.boundingVolume = Se;
  }
  const J = n.boundingVolume, ce = {
    contentUrlTemplate: N,
    subtreesUriTemplate: A,
    subdivisionScheme: l,
    subtreeLevels: y,
    maximumLevel: m,
    refine: z,
    basePath: c,
    lodMetricType: Nm.GEOMETRIC_ERROR,
    rootLodMetricValue: V,
    rootBoundingVolume: J,
    getTileType: bv,
    getRefine: xv
  };
  return await lG(n, L, ce);
}
async function lG(n, e, t) {
  if (!n)
    return null;
  n.lodMetricType = Nm.GEOMETRIC_ERROR, n.lodMetricValue = n.geometricError, n.transformMatrix = n.transform;
  const {
    children: i,
    contentUrl: r
  } = await lT({
    subtree: e,
    options: t,
    s2VolumeBox: n
  });
  return r && (n.contentUrl = r, n.content = {
    uri: r.replace("".concat(t.basePath, "/"), "")
  }), n.refine = xv(n.refine), n.type = bv(n), n.children = i, n.id = n.contentUrl, n;
}
function SA(n) {
  var e;
  return (n == null || (e = n.extensions) === null || e === void 0 ? void 0 : e["3DTILES_implicit_tiling"]) || (n == null ? void 0 : n.implicitTiling);
}
const wv = {
  id: "3d-tiles",
  name: "3D Tiles",
  module: "3d-tiles",
  version: VS,
  extensions: ["cmpt", "pnts", "b3dm", "i3dm"],
  mimeTypes: ["application/octet-stream"],
  tests: ["cmpt", "pnts", "b3dm", "i3dm"],
  parse: dG,
  options: {
    "3d-tiles": {
      loadGLTF: !0,
      decodeQuantizedPositions: !1,
      isTileset: "auto",
      assetGltfUpAxis: null
    }
  }
};
function cG(n) {
  return g1(n.url);
}
async function uG(n, e, t) {
  const i = {
    content: {
      featureIds: null
    }
  };
  return await ZS(n, 0, e, t, i.content), i.content;
}
async function hG(n, e, t) {
  var i;
  const r = JSON.parse(new TextDecoder().decode(n));
  return r.loader = e.loader || wv, r.url = t.url, r.queryString = t.queryString, r.basePath = cG(r), r.root = await aG(r, e), r.type = qa.TILES3D, r.lodMetricType = Nm.GEOMETRIC_ERROR, r.lodMetricValue = ((i = r.root) === null || i === void 0 ? void 0 : i.lodMetricValue) || 0, r;
}
async function dG(n, e, t) {
  const i = e["3d-tiles"] || {};
  let r;
  return i.isTileset === "auto" ? r = t.url && t.url.indexOf(".json") !== -1 : r = i.isTileset, r ? n = await hG(n, e, t) : n = await uG(n, e, t), n;
}
const TA = [0], fG = {
  getPointColor: {
    type: "accessor",
    value: [0, 0, 0, 255]
  },
  pointSize: 1,
  data: "",
  loader: wv,
  onTilesetLoad: {
    type: "function",
    value: (n) => {
    }
  },
  onTileLoad: {
    type: "function",
    value: (n) => {
    }
  },
  onTileUnload: {
    type: "function",
    value: (n) => {
    }
  },
  onTileError: {
    type: "function",
    value: (n, e, t) => {
    }
  },
  _getMeshColor: {
    type: "function",
    value: (n) => [255, 255, 255]
  }
};
class Av extends uS {
  constructor() {
    super(...arguments), G(this, "state", void 0);
  }
  initializeState() {
    "onTileLoadFail" in this.props && hi.removed("onTileLoadFail", "onTileError")(), this.state = {
      layerMap: {},
      tileset3d: null,
      activeViewports: {},
      lastUpdatedViewports: null
    };
  }
  get isLoaded() {
    var e, t;
    return !!(!((e = this.state) === null || e === void 0 || (t = e.tileset3d) === null || t === void 0) && t.isLoaded() && super.isLoaded);
  }
  shouldUpdateState(e) {
    let {
      changeFlags: t
    } = e;
    return t.somethingChanged;
  }
  updateState(e) {
    let {
      props: t,
      oldProps: i,
      changeFlags: r
    } = e;
    if (t.data && t.data !== i.data && this._loadTileset(t.data), r.viewportChanged) {
      const {
        activeViewports: s
      } = this.state;
      Object.keys(s).length && (this._updateTileset(s), this.state.lastUpdatedViewports = s, this.state.activeViewports = {});
    }
    if (r.propsChanged) {
      const {
        layerMap: s
      } = this.state;
      for (const c in s)
        s[c].needsUpdate = !0;
    }
  }
  activateViewport(e) {
    const {
      activeViewports: t,
      lastUpdatedViewports: i
    } = this.state;
    this.internalState.viewport = e, t[e.id] = e;
    const r = i == null ? void 0 : i[e.id];
    (!r || !e.equals(r)) && (this.setChangeFlags({
      viewportChanged: !0
    }), this.setNeedsUpdate());
  }
  getPickingInfo(e) {
    let {
      info: t,
      sourceLayer: i
    } = e;
    const r = i && i.props.tile;
    return t.picked && (t.object = r), t.sourceTile = r, t;
  }
  filterSubLayer(e) {
    let {
      layer: t,
      viewport: i
    } = e;
    const {
      tile: r
    } = t.props, {
      id: s
    } = i;
    return r.selected && r.viewportIds.includes(s);
  }
  _updateAutoHighlight(e) {
    const t = e.sourceTile, i = this.state.layerMap[t == null ? void 0 : t.id];
    i && i.layer && i.layer.updateAutoHighlight(e);
  }
  async _loadTileset(e) {
    const {
      loadOptions: t = {}
    } = this.props;
    let i = this.props.loader || this.props.loaders;
    Array.isArray(i) && (i = i[0]);
    const r = {
      loadOptions: {
        ...t
      }
    };
    let s = e;
    if (i.preload) {
      const m = await i.preload(e, t);
      m.url && (s = m.url), m.headers && (r.loadOptions.fetch = {
        ...r.loadOptions.fetch,
        headers: m.headers
      }), Object.assign(r, m);
    }
    const c = await Ju(s, i, r.loadOptions), l = new WU(c, {
      onTileLoad: this._onTileLoad.bind(this),
      onTileUnload: this._onTileUnload.bind(this),
      onTileError: this.props.onTileError,
      ...r
    });
    this.setState({
      tileset3d: l,
      layerMap: {}
    }), this._updateTileset(this.state.activeViewports), this.props.onTilesetLoad(l);
  }
  _onTileLoad(e) {
    const {
      lastUpdatedViewports: t
    } = this.state;
    this.props.onTileLoad(e), this._updateTileset(t), this.setNeedsUpdate();
  }
  _onTileUnload(e) {
    delete this.state.layerMap[e.id], this.props.onTileUnload(e);
  }
  _updateTileset(e) {
    if (!e)
      return;
    const {
      tileset3d: t
    } = this.state, {
      timeline: i
    } = this.context, r = Object.keys(e).length;
    !i || !r || !t || t.selectTiles(Object.values(e)).then((s) => {
      this.state.frameNumber !== s && this.setState({
        frameNumber: s
      });
    });
  }
  _getSubLayer(e, t) {
    if (!e.content)
      return null;
    switch (e.type) {
      case Od.POINTCLOUD:
        return this._makePointCloudLayer(e, t);
      case Od.SCENEGRAPH:
        return this._make3DModelLayer(e);
      case Od.MESH:
        return this._makeSimpleMeshLayer(e, t);
      default:
        throw new Error("Tile3DLayer: Failed to render layer of type ".concat(e.content.type));
    }
  }
  _makePointCloudLayer(e, t) {
    const {
      attributes: i,
      pointCount: r,
      constantRGBA: s,
      cartographicOrigin: c,
      modelMatrix: l
    } = e.content, {
      positions: m,
      normals: y,
      colors: A
    } = i;
    if (!m)
      return null;
    const T = t && t.props.data || {
      header: {
        vertexCount: r
      },
      attributes: {
        POSITION: m,
        NORMAL: y,
        COLOR_0: A
      }
    }, {
      pointSize: I,
      getPointColor: L
    } = this.props, N = this.getSubLayerClass("pointcloud", sv);
    return new N({
      pointSize: I
    }, this.getSubLayerProps({
      id: "pointcloud"
    }), {
      id: "".concat(this.id, "-pointcloud-").concat(e.id),
      tile: e,
      data: T,
      coordinateSystem: li.METER_OFFSETS,
      coordinateOrigin: c,
      modelMatrix: l,
      getColor: s || L,
      _offset: 0
    });
  }
  _make3DModelLayer(e) {
    const {
      gltf: t,
      instances: i,
      cartographicOrigin: r,
      modelMatrix: s
    } = e.content, c = this.getSubLayerClass("scenegraph", fv);
    return new c({
      _lighting: "pbr"
    }, this.getSubLayerProps({
      id: "scenegraph"
    }), {
      id: "".concat(this.id, "-scenegraph-").concat(e.id),
      tile: e,
      data: i || TA,
      scenegraph: t,
      coordinateSystem: li.METER_OFFSETS,
      coordinateOrigin: r,
      modelMatrix: s,
      getTransformMatrix: (l) => l.modelMatrix,
      getPosition: [0, 0, 0],
      _offset: 0
    });
  }
  _makeSimpleMeshLayer(e, t) {
    const i = e.content, {
      attributes: r,
      indices: s,
      modelMatrix: c,
      cartographicOrigin: l,
      coordinateSystem: m = li.METER_OFFSETS,
      material: y,
      featureIds: A
    } = i, {
      _getMeshColor: T
    } = this.props, I = t && t.props.mesh || new op({
      drawMode: 4,
      attributes: pG(r),
      indices: s
    }), L = this.getSubLayerClass("mesh", pv);
    return new L(this.getSubLayerProps({
      id: "mesh"
    }), {
      id: "".concat(this.id, "-mesh-").concat(e.id),
      tile: e,
      mesh: I,
      data: TA,
      getColor: T(e),
      pbrMaterial: y,
      modelMatrix: c,
      coordinateOrigin: l,
      coordinateSystem: m,
      featureIds: A,
      _offset: 0
    });
  }
  renderLayers() {
    const {
      tileset3d: e,
      layerMap: t
    } = this.state;
    return e ? e.tiles.map((i) => {
      const r = t[i.id] = t[i.id] || {
        tile: i
      };
      let {
        layer: s
      } = r;
      return i.selected && (s ? r.needsUpdate && (s = this._getSubLayer(i, s), r.needsUpdate = !1) : s = this._getSubLayer(i)), r.layer = s, s;
    }).filter(Boolean) : null;
  }
}
G(Av, "defaultProps", fG);
G(Av, "layerName", "Tile3DLayer");
function pG(n) {
  const e = {};
  return e.positions = {
    ...n.positions,
    value: new Float32Array(n.positions.value)
  }, n.normals && (e.normals = n.normals), n.texCoords && (e.texCoords = n.texCoords), n.colors && (e.colors = n.colors), n.uvRegions && (e.uvRegions = n.uvRegions), e;
}
var gG = Object.defineProperty, mG = (n, e, t) => e in n ? gG(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, yi = (n, e, t) => (mG(n, typeof e != "symbol" ? e + "" : e, t), t);
class _G {
  constructor(e) {
    yi(this, "map"), yi(this, "width"), yi(this, "height"), yi(this, "svgCanvas"), yi(this, "xLine"), yi(this, "yLine"), yi(this, "color", "#535353"), this.map = e, this.mapResize = this.mapResize.bind(this);
  }
  create() {
    this.updateValues(), this.map !== void 0 ? (this.map.on("resize", this.mapResize), this.createCanvas(this.map.getCanvasContainer())) : console.error("map object is null");
  }
  updateValues() {
    var e, t;
    this.width = (e = this.map) == null ? void 0 : e.getCanvas().clientWidth, this.height = (t = this.map) == null ? void 0 : t.getCanvas().clientHeight;
  }
  mapResize() {
    this.updateValues(), this.updateCanvas();
  }
  updateCanvas() {
    if (this.svgCanvas !== void 0 && this.yLine !== void 0 && this.xLine !== void 0 && this.width !== void 0 && this.height !== void 0) {
      this.svgCanvas.setAttribute("width", `${this.width}px`), this.svgCanvas.setAttribute("height", `${this.height}px`);
      const e = this.width / 2, t = this.height / 2;
      this.yLine.setAttribute("x1", `${e}px`), this.yLine.setAttribute("y1", "0px"), this.yLine.setAttribute("x2", `${e}px`), this.yLine.setAttribute("y2", `${this.height}px`), this.xLine.setAttribute("x1", "0px"), this.xLine.setAttribute("y1", `${t}px`), this.xLine.setAttribute("x2", `${this.width}px`), this.xLine.setAttribute("y2", `${t}px`);
    } else
      console.error("element value is null");
  }
  createCanvas(e) {
    if (this.width !== void 0 && this.height !== void 0) {
      const t = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      t.style.position = "relative", t.setAttribute("width", `${this.width}px`), t.setAttribute("height", `${this.height}px`);
      const i = this.width / 2, r = this.height / 2;
      this.yLine = t.appendChild(this.createLine(i, 0, i, this.height, this.color, "2px")), this.xLine = t.appendChild(this.createLine(0, r, this.width, r, this.color, "2px")), e == null || e.appendChild(t), this.svgCanvas = t;
    }
  }
  createLine(e, t, i, r, s, c) {
    const l = document.createElementNS("http://www.w3.org/2000/svg", "line");
    return l.setAttribute("x1", e), l.setAttribute("y1", t), l.setAttribute("x2", i), l.setAttribute("y2", r), l.setAttribute("stroke-dasharray", "5,5"), l.setAttribute("stroke", s), l.setAttribute("stroke-width", c), l;
  }
  destroy() {
    this.xLine !== void 0 && (this.xLine.remove(), this.xLine = void 0), this.yLine !== void 0 && (this.yLine.remove(), this.yLine = void 0), this.svgCanvas !== void 0 && (this.svgCanvas.remove(), this.svgCanvas = void 0), this.map !== void 0 && (this.map.off("resize", this.mapResize), this.map = void 0);
  }
}
const jy = { 72: 72, 96: 96, 200: 200, 300: 300, 400: 400 }, Wc = { JPEG: "jpg", PNG: "png", PDF: "pdf", SVG: "svg" }, Qf = { Landscape: "landscape", Portrait: "portrait" }, Mh = {
  // A0, A1, B0, B1 are not working well.
  // A0: [1189, 841],
  // A1: [841, 594],
  LETTER: [279, 216],
  // 8.5x11 - works
  //TABLOID: [432,279] // 11x17 - not working currently prints to 11.68x8.27 in landscape
  A2: [594, 420],
  A3: [420, 297],
  A4: [297, 210],
  A5: [210, 148],
  A6: [148, 105],
  // B0: [1414, 1000],
  // B1: [1000, 707],
  B2: [707, 500],
  B3: [500, 353],
  B4: [353, 250],
  B5: [250, 176],
  B6: [176, 125]
}, Zd = {
  // don't use inch unit. because page size setting is using mm unit.
  in: "in",
  mm: "mm"
};
class yG {
  constructor(e) {
    yi(this, "map"), yi(this, "width"), yi(this, "height"), yi(this, "unit"), yi(this, "svgCanvas"), yi(this, "svgPath");
    var t, i, r;
    if (this.map = e, this.map === void 0)
      return;
    this.mapResize = this.mapResize.bind(this), this.map.on("resize", this.mapResize);
    const s = (t = this.map) == null ? void 0 : t.getCanvas().clientWidth, c = (i = this.map) == null ? void 0 : i.getCanvas().clientHeight, l = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    l.style.position = "absolute", l.style.top = "0px", l.style.left = "0px", l.setAttribute("width", `${s}px`), l.setAttribute("height", `${c}px`);
    const m = document.createElementNS("http://www.w3.org/2000/svg", "path");
    m.setAttribute("style", "fill:#888888;stroke-width:0"), m.setAttribute("fill-opacity", "0.5"), l.append(m), (r = this.map) == null || r.getCanvasContainer().appendChild(l), this.svgCanvas = l, this.svgPath = m;
  }
  mapResize() {
    this.generateCutOut();
  }
  updateArea(e, t) {
    this.width = e, this.height = t, this.unit = Zd.mm, this.generateCutOut();
  }
  generateCutOut() {
    var e, t;
    if (this.map === void 0 || this.svgCanvas === void 0 || this.svgPath === void 0)
      return;
    const i = this.toPixels(this.width), r = this.toPixels(this.height), s = (e = this.map) == null ? void 0 : e.getCanvas().clientWidth, c = (t = this.map) == null ? void 0 : t.getCanvas().clientHeight, l = s / 2 - i / 2, m = l + i, y = c / 2 - r / 2, A = y + r;
    this.svgCanvas.setAttribute("width", `${s}px`), this.svgCanvas.setAttribute("height", `${c}px`), this.svgPath.setAttribute("d", `M 0 0 L ${s} 0 L ${s} ${c} L 0 ${c} M ${l} ${y} L ${l} ${A} L ${m} ${A} L ${m} ${y}`);
  }
  destroy() {
    this.svgCanvas !== void 0 && (this.svgCanvas.remove(), this.svgCanvas = void 0), this.map !== void 0 && (this.map = void 0);
  }
  /**
  * Convert mm/inch to pixel
  * @param length mm/inch length
  * @param conversionFactor DPI value. default is 96.
  */
  toPixels(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 96;
    return this.unit === Zd.mm && (t /= 25.4), t * e;
  }
}
const cT = { PageSize: "Page Size", PageOrientation: "Page Orientation", Format: "Format", DPI: "DPI", Generate: "Generate", LanguageName: "English", LanguageCode: "en" }, vG = { PageSize: "Taille de page", PageOrientation: "Orientation de la page", Format: "Format", DPI: "DPI", Generate: "Gnrer", LanguageName: "Franais", LanguageCode: "fr" }, bG = { PageSize: "Sivukoko", PageOrientation: "Sivun suunta", Format: "Muoto", DPI: "DPI", Generate: "Generoi", LanguageName: "Suomalainen", LanguageCode: "fi" }, xG = { PageSize: "Papierformat", PageOrientation: "Papierausrichtung", Format: "Dateiformat", DPI: "Druckauflsung", Generate: "Erstellen", LanguageName: "Deutsch", LanguageCode: "de" }, wG = { PageSize: "Sidstorlek", PageOrientation: "Sidorientering", Format: "Format", DPI: "DPI", Generate: "Generera", LanguageName: "Svenska", LanguageCode: "sv" }, AG = { PageSize: "Tamao de pgina", PageOrientation: "Orientacin de pgina", Format: "Formato", DPI: "DPI", Generate: "Generar", LanguageName: "Espaola", LanguageCode: "es" }, EG = { PageSize: "Mida", PageOrientation: "Orientaci", Format: "Format", DPI: "DPI", Generate: "Genera", LanguageName: "Catalan", LanguageCode: "ca" }, SG = { PageSize: "Kch thc trang", PageOrientation: "Loi trang", Format: "nh dng", DPI: "Mt  im nh (DPI)", Generate: "To", LanguageName: "Ting Vit", LanguageCode: "vi" }, TG = { PageSize: " ", PageOrientation: " ", Format: "", DPI: "DPI", Generate: "", LanguageName: "", LanguageCode: "uk" }, CG = { PageSize: "", PageOrientation: "", Format: "", DPI: "", Generate: "", LanguageName: "", LanguageCode: "zhHans" }, IG = { PageSize: "", PageOrientation: "", Format: "", DPI: "", Generate: "", LanguageName: "", LanguageCode: "zhHant" }, PG = { PageSize: "", PageOrientation: "", Format: "", DPI: "DPI", Generate: "", LanguageName: "", LanguageCode: "ja" }, LG = { PageSize: "Tamanho da pgina", PageOrientation: "Orientao da pgina", Format: "Formato", DPI: "DPI", Generate: "Gerar", LanguageName: "Portugus", LanguageCode: "pt" }, MG = [cT, vG, bG, xG, wG, AG, EG, SG, TG, CG, IG, PG, LG], BG = (n) => MG.find((e) => e.LanguageCode === n) ?? cT;
(function(n) {
  var e = {};
  function t(i) {
    if (e[i])
      return e[i].exports;
    var r = e[i] = { i, l: !1, exports: {} };
    return n[i].call(r.exports, r, r.exports, t), r.l = !0, r.exports;
  }
  t.m = n, t.c = e, t.d = function(i, r, s) {
    t.o(i, r) || Object.defineProperty(i, r, { enumerable: !0, get: s });
  }, t.r = function(i) {
    typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(i, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(i, "__esModule", { value: !0 });
  }, t.t = function(i, r) {
    if (1 & r && (i = t(i)), 8 & r || 4 & r && typeof i == "object" && i && i.__esModule)
      return i;
    var s = /* @__PURE__ */ Object.create(null);
    if (t.r(s), Object.defineProperty(s, "default", { enumerable: !0, value: i }), 2 & r && typeof i != "string")
      for (var c in i)
        t.d(s, c, (function(l) {
          return i[l];
        }).bind(null, c));
    return s;
  }, t.n = function(i) {
    var r = i && i.__esModule ? function() {
      return i.default;
    } : function() {
      return i;
    };
    return t.d(r, "a", r), r;
  }, t.o = function(i, r) {
    return Object.prototype.hasOwnProperty.call(i, r);
  }, t.p = "", t(t.s = 0);
})([function(n, e, t) {
  n.exports = t(1);
}, function(n, e) {
  function t(r, s) {
    for (var c = 0; c < s.length; c++) {
      var l = s[c];
      l.enumerable = l.enumerable || !1, l.configurable = !0, "value" in l && (l.writable = !0), Object.defineProperty(r, l.key, l);
    }
  }
  var i = function() {
    function r() {
      (function(l, m) {
        if (!(l instanceof m))
          throw new TypeError("Cannot call a class as a function");
      })(this, r), this.options = { overlayBackgroundColor: "#666666", overlayOpacity: 0.6, spinnerIcon: "ball-circus", spinnerColor: "#000", spinnerSize: "3x", overlayIDName: "overlay", spinnerIDName: "spinner", offsetY: 0, offsetX: 0, lockScroll: !1, containerID: null, spinnerZIndex: 99999, overlayZIndex: 99998 }, this.stylesheetBaseURL = "https://cdn.jsdelivr.net/npm/load-awesome@1.1.0/css/", this.spinner = null, this.spinnerStylesheetURL = null, this.numberOfEmptyDivForSpinner = { "ball-8bits": 16, "ball-atom": 4, "ball-beat": 3, "ball-circus": 5, "ball-climbing-dot": 1, "ball-clip-rotate": 1, "ball-clip-rotate-multiple": 2, "ball-clip-rotate-pulse": 2, "ball-elastic-dots": 5, "ball-fall": 3, "ball-fussion": 4, "ball-grid-beat": 9, "ball-grid-pulse": 9, "ball-newton-cradle": 4, "ball-pulse": 3, "ball-pulse-rise": 5, "ball-pulse-sync": 3, "ball-rotate": 1, "ball-running-dots": 5, "ball-scale": 1, "ball-scale-multiple": 3, "ball-scale-pulse": 2, "ball-scale-ripple": 1, "ball-scale-ripple-multiple": 3, "ball-spin": 8, "ball-spin-clockwise": 8, "ball-spin-clockwise-fade": 8, "ball-spin-clockwise-fade-rotating": 8, "ball-spin-fade": 8, "ball-spin-fade-rotating": 8, "ball-spin-rotate": 2, "ball-square-clockwise-spin": 8, "ball-square-spin": 8, "ball-triangle-path": 3, "ball-zig-zag": 2, "ball-zig-zag-deflect": 2, cog: 1, "cube-transition": 2, fire: 3, "line-scale": 5, "line-scale-party": 5, "line-scale-pulse-out": 5, "line-scale-pulse-out-rapid": 5, "line-spin-clockwise-fade": 8, "line-spin-clockwise-fade-rotating": 8, "line-spin-fade": 8, "line-spin-fade-rotating": 8, pacman: 6, "square-jelly-box": 2, "square-loader": 1, "square-spin": 1, timer: 1, "triangle-skew-spin": 1 };
    }
    var s, c;
    return s = r, (c = [{ key: "show", value: function(l) {
      this.setOptions(l), this.addSpinnerStylesheet(), this.generateSpinnerElement(), this.options.lockScroll && (document.body.style.overflow = "hidden", document.documentElement.style.overflow = "hidden"), this.generateAndAddOverlayElement();
    } }, { key: "hide", value: function() {
      this.options.lockScroll && (document.body.style.overflow = "", document.documentElement.style.overflow = "");
      var l = document.getElementById("loading-overlay-stylesheet");
      l && (l.disabled = !0, l.parentNode.removeChild(l), document.getElementById(this.options.overlayIDName).remove(), document.getElementById(this.options.spinnerIDName).remove());
    } }, { key: "setOptions", value: function(l) {
      if (l !== void 0)
        for (var m in l)
          this.options[m] = l[m];
    } }, { key: "generateAndAddOverlayElement", value: function() {
      var l = "50%";
      this.options.offsetX !== 0 && (l = "calc(50% + " + this.options.offsetX + ")");
      var m = "50%";
      if (this.options.offsetY !== 0 && (m = "calc(50% + " + this.options.offsetY + ")"), this.options.containerID && document.body.contains(document.getElementById(this.options.containerID))) {
        var y = '<div id="'.concat(this.options.overlayIDName, '" style="display: block !important; position: absolute; top: 0; left: 0; overflow: auto; opacity: ').concat(this.options.overlayOpacity, "; background: ").concat(this.options.overlayBackgroundColor, '; z-index: 50; width: 100%; height: 100%;"></div><div id="').concat(this.options.spinnerIDName, '" style="display: block !important; position: absolute; top: ').concat(m, "; left: ").concat(l, '; -webkit-transform: translate(-50%); -ms-transform: translate(-50%); transform: translate(-50%); z-index: 9999;">').concat(this.spinner, "</div>"), A = document.getElementById(this.options.containerID);
        return A.style.position = "relative", void A.insertAdjacentHTML("beforeend", y);
      }
      var T = '<div id="'.concat(this.options.overlayIDName, '" style="display: block !important; position: fixed; top: 0; left: 0; overflow: auto; opacity: ').concat(this.options.overlayOpacity, "; background: ").concat(this.options.overlayBackgroundColor, "; z-index: ").concat(this.options.overlayZIndex, '; width: 100%; height: 100%;"></div><div id="').concat(this.options.spinnerIDName, '" style="display: block !important; position: fixed; top: ').concat(m, "; left: ").concat(l, "; -webkit-transform: translate(-50%); -ms-transform: translate(-50%); transform: translate(-50%); z-index: ").concat(this.options.spinnerZIndex, ';">').concat(this.spinner, "</div>");
      document.body.insertAdjacentHTML("beforeend", T);
    } }, { key: "generateSpinnerElement", value: function() {
      var l = this, m = Object.keys(this.numberOfEmptyDivForSpinner).find(function(A) {
        return A === l.options.spinnerIcon;
      }), y = this.generateEmptyDivElement(this.numberOfEmptyDivForSpinner[m]);
      this.spinner = '<div style="color: '.concat(this.options.spinnerColor, '" class="la-').concat(this.options.spinnerIcon, " la-").concat(this.options.spinnerSize, '">').concat(y, "</div>");
    } }, { key: "addSpinnerStylesheet", value: function() {
      this.setSpinnerStylesheetURL();
      var l = document.createElement("link");
      l.setAttribute("id", "loading-overlay-stylesheet"), l.setAttribute("rel", "stylesheet"), l.setAttribute("type", "text/css"), l.setAttribute("href", this.spinnerStylesheetURL), document.getElementsByTagName("head")[0].appendChild(l);
    } }, { key: "setSpinnerStylesheetURL", value: function() {
      this.spinnerStylesheetURL = this.stylesheetBaseURL + this.options.spinnerIcon + ".min.css";
    } }, { key: "generateEmptyDivElement", value: function(l) {
      for (var m = "", y = 1; y <= l; y++)
        m += "<div></div>";
      return m;
    } }]) && t(s.prototype, c), r;
  }();
  window.JsLoadingOverlay = new i(), n.exports = JsLoadingOverlay;
}]);
function zi(n) {
  "@babel/helpers - typeof";
  return zi = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, zi(n);
}
var Fo = Uint8Array, _o = Uint16Array, bp = Uint32Array, jm = new Fo([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), Gm = new Fo([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), Gy = new Fo([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), uT = function(n, e) {
  for (var t = new _o(31), i = 0; i < 31; ++i)
    t[i] = e += 1 << n[i - 1];
  for (var r = new bp(t[30]), i = 1; i < 30; ++i)
    for (var s = t[i]; s < t[i + 1]; ++s)
      r[s] = s - t[i] << 5 | i;
  return [t, r];
}, hT = uT(jm, 2), dT = hT[0], Vy = hT[1];
dT[28] = 258, Vy[258] = 28;
var fT = uT(Gm, 0), RG = fT[0], CA = fT[1], qy = new _o(32768);
for (var ur = 0; ur < 32768; ++ur) {
  var Nu = (ur & 43690) >>> 1 | (ur & 21845) << 1;
  Nu = (Nu & 52428) >>> 2 | (Nu & 13107) << 2, Nu = (Nu & 61680) >>> 4 | (Nu & 3855) << 4, qy[ur] = ((Nu & 65280) >>> 8 | (Nu & 255) << 8) >>> 1;
}
var gc = function(n, e, t) {
  for (var i = n.length, r = 0, s = new _o(e); r < i; ++r)
    ++s[n[r] - 1];
  var c = new _o(e);
  for (r = 0; r < e; ++r)
    c[r] = c[r - 1] + s[r - 1] << 1;
  var l;
  if (t) {
    l = new _o(1 << e);
    var m = 15 - e;
    for (r = 0; r < i; ++r)
      if (n[r])
        for (var y = r << 4 | n[r], A = e - n[r], T = c[n[r] - 1]++ << A, I = T | (1 << A) - 1; T <= I; ++T)
          l[qy[T] >>> m] = y;
  } else
    for (l = new _o(i), r = 0; r < i; ++r)
      l[r] = qy[c[n[r] - 1]++] >>> 15 - n[r];
  return l;
}, Zu = new Fo(288);
for (var ur = 0; ur < 144; ++ur)
  Zu[ur] = 8;
for (var ur = 144; ur < 256; ++ur)
  Zu[ur] = 9;
for (var ur = 256; ur < 280; ++ur)
  Zu[ur] = 7;
for (var ur = 280; ur < 288; ++ur)
  Zu[ur] = 8;
var xp = new Fo(32);
for (var ur = 0; ur < 32; ++ur)
  xp[ur] = 5;
var OG = /* @__PURE__ */ gc(Zu, 9, 0), FG = /* @__PURE__ */ gc(Zu, 9, 1), DG = /* @__PURE__ */ gc(xp, 5, 0), kG = /* @__PURE__ */ gc(xp, 5, 1), D_ = function(n) {
  for (var e = n[0], t = 1; t < n.length; ++t)
    n[t] > e && (e = n[t]);
  return e;
}, vl = function(n, e, t) {
  var i = e / 8 >> 0;
  return (n[i] | n[i + 1] << 8) >>> (e & 7) & t;
}, k_ = function(n, e) {
  var t = e / 8 >> 0;
  return (n[t] | n[t + 1] << 8 | n[t + 2] << 16) >>> (e & 7);
}, Ev = function(n) {
  return (n / 8 >> 0) + (n & 7 && 1);
}, pT = function(n, e, t) {
  (t == null || t > n.length) && (t = n.length);
  var i = new (n instanceof _o ? _o : n instanceof bp ? bp : Fo)(t - e);
  return i.set(n.subarray(e, t)), i;
}, NG = function(n, e, t) {
  var i = n.length, r = !e || t, s = !t || t.i;
  t || (t = {}), e || (e = new Fo(i * 3));
  var c = function(qe) {
    var We = e.length;
    if (qe > We) {
      var Ke = new Fo(Math.max(We * 2, qe));
      Ke.set(e), e = Ke;
    }
  }, l = t.f || 0, m = t.p || 0, y = t.b || 0, A = t.l, T = t.d, I = t.m, L = t.n, N = i * 8;
  do {
    if (!A) {
      t.f = l = vl(n, m, 1);
      var z = vl(n, m + 1, 3);
      if (m += 3, z)
        if (z == 1)
          A = FG, T = kG, I = 9, L = 5;
        else if (z == 2) {
          var V = vl(n, m, 31) + 257, H = vl(n, m + 10, 15) + 4, J = V + vl(n, m + 5, 31) + 1;
          m += 14;
          for (var ce = new Fo(J), me = new Fo(19), Se = 0; Se < H; ++Se)
            me[Gy[Se]] = vl(n, m + Se * 3, 7);
          m += H * 3;
          var De = D_(me), Le = (1 << De) - 1;
          if (!s && m + J * (De + 7) > N)
            break;
          for (var ye = gc(me, De, 1), Se = 0; Se < J; ) {
            var Ve = ye[vl(n, m, Le)];
            m += Ve & 15;
            var Fe = Ve >>> 4;
            if (Fe < 16)
              ce[Se++] = Fe;
            else {
              var ae = 0, de = 0;
              for (Fe == 16 ? (de = 3 + vl(n, m, 3), m += 2, ae = ce[Se - 1]) : Fe == 17 ? (de = 3 + vl(n, m, 7), m += 3) : Fe == 18 && (de = 11 + vl(n, m, 127), m += 7); de--; )
                ce[Se++] = ae;
            }
          }
          var Te = ce.subarray(0, V), be = ce.subarray(V);
          I = D_(Te), L = D_(be), A = gc(Te, I, 1), T = gc(be, L, 1);
        } else
          throw "invalid block type";
      else {
        var Fe = Ev(m) + 4, tt = n[Fe - 4] | n[Fe - 3] << 8, st = Fe + tt;
        if (st > i) {
          if (s)
            throw "unexpected EOF";
          break;
        }
        r && c(y + tt), e.set(n.subarray(Fe, st), y), t.b = y += tt, t.p = m = st * 8;
        continue;
      }
      if (m > N)
        throw "unexpected EOF";
    }
    r && c(y + 131072);
    for (var lt = (1 << I) - 1, Ye = (1 << L) - 1, ht = I + L + 18; s || m + ht < N; ) {
      var ae = A[k_(n, m) & lt], ct = ae >>> 4;
      if (m += ae & 15, m > N)
        throw "unexpected EOF";
      if (!ae)
        throw "invalid length/literal";
      if (ct < 256)
        e[y++] = ct;
      else if (ct == 256) {
        A = null;
        break;
      } else {
        var Pt = ct - 254;
        if (ct > 264) {
          var Se = ct - 257, se = jm[Se];
          Pt = vl(n, m, (1 << se) - 1) + dT[Se], m += se;
        }
        var Ae = T[k_(n, m) & Ye], Ce = Ae >>> 4;
        if (!Ae)
          throw "invalid distance";
        m += Ae & 15;
        var be = RG[Ce];
        if (Ce > 3) {
          var se = Gm[Ce];
          be += k_(n, m) & (1 << se) - 1, m += se;
        }
        if (m > N)
          throw "unexpected EOF";
        r && c(y + 131072);
        for (var Ue = y + Pt; y < Ue; y += 4)
          e[y] = e[y - be], e[y + 1] = e[y + 1 - be], e[y + 2] = e[y + 2 - be], e[y + 3] = e[y + 3 - be];
        y = Ue;
      }
    }
    t.l = A, t.p = m, t.b = y, A && (l = 1, t.m = I, t.d = T, t.n = L);
  } while (!l);
  return y == e.length ? e : pT(e, 0, y);
}, qc = function(n, e, t) {
  t <<= e & 7;
  var i = e / 8 >> 0;
  n[i] |= t, n[i + 1] |= t >>> 8;
}, Wf = function(n, e, t) {
  t <<= e & 7;
  var i = e / 8 >> 0;
  n[i] |= t, n[i + 1] |= t >>> 8, n[i + 2] |= t >>> 16;
}, N_ = function(n, e) {
  for (var t = [], i = 0; i < n.length; ++i)
    n[i] && t.push({ s: i, f: n[i] });
  var r = t.length, s = t.slice();
  if (!r)
    return [new Fo(0), 0];
  if (r == 1) {
    var c = new Fo(t[0].s + 1);
    return c[t[0].s] = 1, [c, 1];
  }
  t.sort(function(Se, De) {
    return Se.f - De.f;
  }), t.push({ s: -1, f: 25001 });
  var l = t[0], m = t[1], y = 0, A = 1, T = 2;
  for (t[0] = { s: -1, f: l.f + m.f, l, r: m }; A != r - 1; )
    l = t[t[y].f < t[T].f ? y++ : T++], m = t[y != A && t[y].f < t[T].f ? y++ : T++], t[A++] = { s: -1, f: l.f + m.f, l, r: m };
  for (var I = s[0].s, i = 1; i < r; ++i)
    s[i].s > I && (I = s[i].s);
  var L = new _o(I + 1), N = Hy(t[A - 1], L, 0);
  if (N > e) {
    var i = 0, z = 0, V = N - e, H = 1 << V;
    for (s.sort(function(De, Le) {
      return L[Le.s] - L[De.s] || De.f - Le.f;
    }); i < r; ++i) {
      var J = s[i].s;
      if (L[J] > e)
        z += H - (1 << N - L[J]), L[J] = e;
      else
        break;
    }
    for (z >>>= V; z > 0; ) {
      var ce = s[i].s;
      L[ce] < e ? z -= 1 << e - L[ce]++ - 1 : ++i;
    }
    for (; i >= 0 && z; --i) {
      var me = s[i].s;
      L[me] == e && (--L[me], ++z);
    }
    N = e;
  }
  return [new Fo(L), N];
}, Hy = function(n, e, t) {
  return n.s == -1 ? Math.max(Hy(n.l, e, t + 1), Hy(n.r, e, t + 1)) : e[n.s] = t;
}, IA = function(n) {
  for (var e = n.length; e && !n[--e]; )
    ;
  for (var t = new _o(++e), i = 0, r = n[0], s = 1, c = function(m) {
    t[i++] = m;
  }, l = 1; l <= e; ++l)
    if (n[l] == r && l != e)
      ++s;
    else {
      if (!r && s > 2) {
        for (; s > 138; s -= 138)
          c(32754);
        s > 2 && (c(s > 10 ? s - 11 << 5 | 28690 : s - 3 << 5 | 12305), s = 0);
      } else if (s > 3) {
        for (c(r), --s; s > 6; s -= 6)
          c(8304);
        s > 2 && (c(s - 3 << 5 | 8208), s = 0);
      }
      for (; s--; )
        c(r);
      s = 1, r = n[l];
    }
  return [t.subarray(0, i), e];
}, Xf = function(n, e) {
  for (var t = 0, i = 0; i < e.length; ++i)
    t += n[i] * e[i];
  return t;
}, Wy = function(n, e, t) {
  var i = t.length, r = Ev(e + 2);
  n[r] = i & 255, n[r + 1] = i >>> 8, n[r + 2] = n[r] ^ 255, n[r + 3] = n[r + 1] ^ 255;
  for (var s = 0; s < i; ++s)
    n[r + s + 4] = t[s];
  return (r + 4 + i) * 8;
}, PA = function(n, e, t, i, r, s, c, l, m, y, A) {
  qc(e, A++, t), ++r[256];
  for (var T = N_(r, 15), I = T[0], L = T[1], N = N_(s, 15), z = N[0], V = N[1], H = IA(I), J = H[0], ce = H[1], me = IA(z), Se = me[0], De = me[1], Le = new _o(19), ye = 0; ye < J.length; ++ye)
    Le[J[ye] & 31]++;
  for (var ye = 0; ye < Se.length; ++ye)
    Le[Se[ye] & 31]++;
  for (var Ve = N_(Le, 7), Fe = Ve[0], ae = Ve[1], de = 19; de > 4 && !Fe[Gy[de - 1]]; --de)
    ;
  var Te = y + 5 << 3, be = Xf(r, Zu) + Xf(s, xp) + c, tt = Xf(r, I) + Xf(s, z) + c + 14 + 3 * de + Xf(Le, Fe) + (2 * Le[16] + 3 * Le[17] + 7 * Le[18]);
  if (Te <= be && Te <= tt)
    return Wy(e, A, n.subarray(m, m + y));
  var st, lt, Ye, ht;
  if (qc(e, A, 1 + (tt < be)), A += 2, tt < be) {
    st = gc(I, L, 0), lt = I, Ye = gc(z, V, 0), ht = z;
    var ct = gc(Fe, ae, 0);
    qc(e, A, ce - 257), qc(e, A + 5, De - 1), qc(e, A + 10, de - 4), A += 14;
    for (var ye = 0; ye < de; ++ye)
      qc(e, A + 3 * ye, Fe[Gy[ye]]);
    A += 3 * de;
    for (var Pt = [J, Se], se = 0; se < 2; ++se)
      for (var Ae = Pt[se], ye = 0; ye < Ae.length; ++ye) {
        var Ce = Ae[ye] & 31;
        qc(e, A, ct[Ce]), A += Fe[Ce], Ce > 15 && (qc(e, A, Ae[ye] >>> 5 & 127), A += Ae[ye] >>> 12);
      }
  } else
    st = OG, lt = Zu, Ye = DG, ht = xp;
  for (var ye = 0; ye < l; ++ye)
    if (i[ye] > 255) {
      var Ce = i[ye] >>> 18 & 31;
      Wf(e, A, st[Ce + 257]), A += lt[Ce + 257], Ce > 7 && (qc(e, A, i[ye] >>> 23 & 31), A += jm[Ce]);
      var Ue = i[ye] & 31;
      Wf(e, A, Ye[Ue]), A += ht[Ue], Ue > 3 && (Wf(e, A, i[ye] >>> 5 & 8191), A += Gm[Ue]);
    } else
      Wf(e, A, st[i[ye]]), A += lt[i[ye]];
  return Wf(e, A, st[256]), A + lt[256];
}, zG = /* @__PURE__ */ new bp([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), UG = function(n, e, t, i, r, s) {
  var c = n.length, l = new Fo(i + c + 5 * (1 + Math.floor(c / 7e3)) + r), m = l.subarray(i, l.length - r), y = 0;
  if (!e || c < 8)
    for (var A = 0; A <= c; A += 65535) {
      var T = A + 65535;
      T < c ? y = Wy(m, y, n.subarray(A, T)) : (m[A] = s, y = Wy(m, y, n.subarray(A, c)));
    }
  else {
    for (var I = zG[e - 1], L = I >>> 13, N = I & 8191, z = (1 << t) - 1, V = new _o(32768), H = new _o(z + 1), J = Math.ceil(t / 3), ce = 2 * J, me = function(on) {
      return (n[on] ^ n[on + 1] << J ^ n[on + 2] << ce) & z;
    }, Se = new bp(25e3), De = new _o(288), Le = new _o(32), ye = 0, Ve = 0, A = 0, Fe = 0, ae = 0, de = 0; A < c; ++A) {
      var Te = me(A), be = A & 32767, tt = H[Te];
      if (V[be] = tt, H[Te] = be, ae <= A) {
        var st = c - A;
        if ((ye > 7e3 || Fe > 24576) && st > 423) {
          y = PA(n, m, 0, Se, De, Le, Ve, Fe, de, A - de, y), Fe = ye = Ve = 0, de = A;
          for (var lt = 0; lt < 286; ++lt)
            De[lt] = 0;
          for (var lt = 0; lt < 30; ++lt)
            Le[lt] = 0;
        }
        var Ye = 2, ht = 0, ct = N, Pt = be - tt & 32767;
        if (st > 2 && Te == me(A - Pt))
          for (var se = Math.min(L, st) - 1, Ae = Math.min(32767, A), Ce = Math.min(258, st); Pt <= Ae && --ct && be != tt; ) {
            if (n[A + Ye] == n[A + Ye - Pt]) {
              for (var Ue = 0; Ue < Ce && n[A + Ue] == n[A + Ue - Pt]; ++Ue)
                ;
              if (Ue > Ye) {
                if (Ye = Ue, ht = Pt, Ue > se)
                  break;
                for (var qe = Math.min(Pt, Ue - 2), We = 0, lt = 0; lt < qe; ++lt) {
                  var Ke = A - Pt + lt + 32768 & 32767, Ze = V[Ke], At = Ke - Ze + 32768 & 32767;
                  At > We && (We = At, tt = Ke);
                }
              }
            }
            be = tt, tt = V[be], Pt += be - tt + 32768 & 32767;
          }
        if (ht) {
          Se[Fe++] = 268435456 | Vy[Ye] << 18 | CA[ht];
          var It = Vy[Ye] & 31, Rt = CA[ht] & 31;
          Ve += jm[It] + Gm[Rt], ++De[257 + It], ++Le[Rt], ae = A + Ye, ++ye;
        } else
          Se[Fe++] = n[A], ++De[n[A]];
      }
    }
    y = PA(n, m, s, Se, De, Le, Ve, Fe, de, A - de, y);
  }
  return pT(l, 0, i + Ev(y) + r);
}, jG = function() {
  var n = 1, e = 0;
  return { p: function(t) {
    for (var i = n, r = e, s = t.length, c = 0; c != s; ) {
      for (var l = Math.min(c + 5552, s); c < l; ++c)
        i += t[c], r += i;
      i %= 65521, r %= 65521;
    }
    n = i, e = r;
  }, d: function() {
    return (n >>> 8 << 16 | (e & 255) << 8 | e >>> 8) + ((n & 255) << 23) * 2;
  } };
}, GG = function(n, e, t, i, r) {
  return UG(n, e.level == null ? 6 : e.level, e.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(n.length))) * 1.5) : 12 + e.mem, t, i, !r);
}, VG = function(n, e, t) {
  for (; t; ++e)
    n[e] = t, t >>>= 8;
}, qG = function(n, e) {
  var t = e.level, i = t == 0 ? 0 : t < 6 ? 1 : t == 9 ? 3 : 2;
  n[0] = 120, n[1] = i << 6 | (i ? 32 - 2 * i : 1);
}, HG = function(n) {
  if ((n[0] & 15) != 8 || n[0] >>> 4 > 7 || (n[0] << 8 | n[1]) % 31)
    throw "invalid zlib data";
  if (n[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function Xy(n, e) {
  e === void 0 && (e = {});
  var t = jG();
  t.p(n);
  var i = GG(n, e, 2, 4);
  return qG(i, e), VG(i, i.length - 4, t.d()), i;
}
function WG(n, e) {
  return NG((HG(n), n.subarray(2, -4)), e);
}
/** @license
*
* jsPDF - PDF Document creation from JavaScript
* Version 2.5.1 Built on 2022-01-28T15:37:57.791Z
*                      CommitID 00000000
*
* Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
*               2015-2021 yWorks GmbH, http://www.yworks.com
*               2015-2021 Lukas Hollnder <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
*               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
*               2010 Aaron Spike, https://github.com/acspike
*               2012 Willow Systems Corporation, https://github.com/willowsystems
*               2012 Pablo Hess, https://github.com/pablohess
*               2012 Florian Jenett, https://github.com/fjenett
*               2013 Warren Weckesser, https://github.com/warrenweckesser
*               2013 Youssef Beddad, https://github.com/lifof
*               2013 Lee Driscoll, https://github.com/lsdriscoll
*               2013 Stefan Slonevskiy, https://github.com/stefslon
*               2013 Jeremy Morel, https://github.com/jmorel
*               2013 Christoph Hartmann, https://github.com/chris-rock
*               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
*               2014 James Makes, https://github.com/dollaruw
*               2014 Diego Casorran, https://github.com/diegocr
*               2014 Steven Spungin, https://github.com/Flamenco
*               2014 Kenneth Glassey, https://github.com/Gavvers
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*
* Contributor(s):
*    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
*    kim3er, mfo, alnorth, Flamenco
*/
var Rn = /* @__PURE__ */ function() {
  return typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : this;
}();
function z_() {
  Rn.console && typeof Rn.console.log == "function" && Rn.console.log.apply(Rn.console, arguments);
}
var Ki = { log: z_, warn: function(n) {
  Rn.console && (typeof Rn.console.warn == "function" ? Rn.console.warn.apply(Rn.console, arguments) : z_.call(null, arguments));
}, error: function(n) {
  Rn.console && (typeof Rn.console.error == "function" ? Rn.console.error.apply(Rn.console, arguments) : z_(n));
} };
function U_(n, e, t) {
  var i = new XMLHttpRequest();
  i.open("GET", n), i.responseType = "blob", i.onload = function() {
    Sh(i.response, e, t);
  }, i.onerror = function() {
    Ki.error("could not download file");
  }, i.send();
}
function LA(n) {
  var e = new XMLHttpRequest();
  e.open("HEAD", n, !1);
  try {
    e.send();
  } catch {
  }
  return e.status >= 200 && e.status <= 299;
}
function Dg(n) {
  try {
    n.dispatchEvent(new MouseEvent("click"));
  } catch {
    var e = document.createEvent("MouseEvents");
    e.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), n.dispatchEvent(e);
  }
}
var lp, Jy, Sh = Rn.saveAs || ((typeof window > "u" ? "undefined" : zi(window)) !== "object" || window !== Rn ? function() {
} : typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype ? function(n, e, t) {
  var i = Rn.URL || Rn.webkitURL, r = document.createElement("a");
  e = e || n.name || "download", r.download = e, r.rel = "noopener", typeof n == "string" ? (r.href = n, r.origin !== location.origin ? LA(r.href) ? U_(n, e, t) : Dg(r, r.target = "_blank") : Dg(r)) : (r.href = i.createObjectURL(n), setTimeout(function() {
    i.revokeObjectURL(r.href);
  }, 4e4), setTimeout(function() {
    Dg(r);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(n, e, t) {
  if (e = e || n.name || "download", typeof n == "string")
    if (LA(n))
      U_(n, e, t);
    else {
      var i = document.createElement("a");
      i.href = n, i.target = "_blank", setTimeout(function() {
        Dg(i);
      });
    }
  else
    navigator.msSaveOrOpenBlob(function(r, s) {
      return s === void 0 ? s = { autoBom: !1 } : zi(s) !== "object" && (Ki.warn("Deprecated: Expected third argument to be a object"), s = { autoBom: !s }), s.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(r.type) ? new Blob(["\uFEFF", r], { type: r.type }) : r;
    }(n, t), e);
} : function(n, e, t, i) {
  if ((i = i || open("", "_blank")) && (i.document.title = i.document.body.innerText = "downloading..."), typeof n == "string")
    return U_(n, e, t);
  var r = n.type === "application/octet-stream", s = /constructor/i.test(Rn.HTMLElement) || Rn.safari, c = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((c || r && s) && (typeof FileReader > "u" ? "undefined" : zi(FileReader)) === "object") {
    var l = new FileReader();
    l.onloadend = function() {
      var A = l.result;
      A = c ? A : A.replace(/^data:[^;]*;/, "data:attachment/file;"), i ? i.location.href = A : location = A, i = null;
    }, l.readAsDataURL(n);
  } else {
    var m = Rn.URL || Rn.webkitURL, y = m.createObjectURL(n);
    i ? i.location = y : location.href = y, i = null, setTimeout(function() {
      m.revokeObjectURL(y);
    }, 4e4);
  }
});
/**
* A class to parse color values
* @author Stoyan Stefanov <sstoo@gmail.com>
* {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
* @license Use it if you like it
*/
function gT(n) {
  var e;
  n = n || "", this.ok = !1, n.charAt(0) == "#" && (n = n.substr(1, 6)), n = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[n = (n = n.replace(/ /g, "")).toLowerCase()] || n;
  for (var t = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(l) {
    return [parseInt(l[1]), parseInt(l[2]), parseInt(l[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(l) {
    return [parseInt(l[1], 16), parseInt(l[2], 16), parseInt(l[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(l) {
    return [parseInt(l[1] + l[1], 16), parseInt(l[2] + l[2], 16), parseInt(l[3] + l[3], 16)];
  } }], i = 0; i < t.length; i++) {
    var r = t[i].re, s = t[i].process, c = r.exec(n);
    c && (e = s(c), this.r = e[0], this.g = e[1], this.b = e[2], this.ok = !0);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var l = this.r.toString(16), m = this.g.toString(16), y = this.b.toString(16);
    return l.length == 1 && (l = "0" + l), m.length == 1 && (m = "0" + m), y.length == 1 && (y = "0" + y), "#" + l + m + y;
  };
}
/**
* @license
* Joseph Myers does not specify a particular license for his work.
*
* Author: Joseph Myers
* Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
*
* Modified by: Owen Leong
*/
function j_(n, e) {
  var t = n[0], i = n[1], r = n[2], s = n[3];
  t = Vs(t, i, r, s, e[0], 7, -680876936), s = Vs(s, t, i, r, e[1], 12, -389564586), r = Vs(r, s, t, i, e[2], 17, 606105819), i = Vs(i, r, s, t, e[3], 22, -1044525330), t = Vs(t, i, r, s, e[4], 7, -176418897), s = Vs(s, t, i, r, e[5], 12, 1200080426), r = Vs(r, s, t, i, e[6], 17, -1473231341), i = Vs(i, r, s, t, e[7], 22, -45705983), t = Vs(t, i, r, s, e[8], 7, 1770035416), s = Vs(s, t, i, r, e[9], 12, -1958414417), r = Vs(r, s, t, i, e[10], 17, -42063), i = Vs(i, r, s, t, e[11], 22, -1990404162), t = Vs(t, i, r, s, e[12], 7, 1804603682), s = Vs(s, t, i, r, e[13], 12, -40341101), r = Vs(r, s, t, i, e[14], 17, -1502002290), t = qs(t, i = Vs(i, r, s, t, e[15], 22, 1236535329), r, s, e[1], 5, -165796510), s = qs(s, t, i, r, e[6], 9, -1069501632), r = qs(r, s, t, i, e[11], 14, 643717713), i = qs(i, r, s, t, e[0], 20, -373897302), t = qs(t, i, r, s, e[5], 5, -701558691), s = qs(s, t, i, r, e[10], 9, 38016083), r = qs(r, s, t, i, e[15], 14, -660478335), i = qs(i, r, s, t, e[4], 20, -405537848), t = qs(t, i, r, s, e[9], 5, 568446438), s = qs(s, t, i, r, e[14], 9, -1019803690), r = qs(r, s, t, i, e[3], 14, -187363961), i = qs(i, r, s, t, e[8], 20, 1163531501), t = qs(t, i, r, s, e[13], 5, -1444681467), s = qs(s, t, i, r, e[2], 9, -51403784), r = qs(r, s, t, i, e[7], 14, 1735328473), t = Hs(t, i = qs(i, r, s, t, e[12], 20, -1926607734), r, s, e[5], 4, -378558), s = Hs(s, t, i, r, e[8], 11, -2022574463), r = Hs(r, s, t, i, e[11], 16, 1839030562), i = Hs(i, r, s, t, e[14], 23, -35309556), t = Hs(t, i, r, s, e[1], 4, -1530992060), s = Hs(s, t, i, r, e[4], 11, 1272893353), r = Hs(r, s, t, i, e[7], 16, -155497632), i = Hs(i, r, s, t, e[10], 23, -1094730640), t = Hs(t, i, r, s, e[13], 4, 681279174), s = Hs(s, t, i, r, e[0], 11, -358537222), r = Hs(r, s, t, i, e[3], 16, -722521979), i = Hs(i, r, s, t, e[6], 23, 76029189), t = Hs(t, i, r, s, e[9], 4, -640364487), s = Hs(s, t, i, r, e[12], 11, -421815835), r = Hs(r, s, t, i, e[15], 16, 530742520), t = Ws(t, i = Hs(i, r, s, t, e[2], 23, -995338651), r, s, e[0], 6, -198630844), s = Ws(s, t, i, r, e[7], 10, 1126891415), r = Ws(r, s, t, i, e[14], 15, -1416354905), i = Ws(i, r, s, t, e[5], 21, -57434055), t = Ws(t, i, r, s, e[12], 6, 1700485571), s = Ws(s, t, i, r, e[3], 10, -1894986606), r = Ws(r, s, t, i, e[10], 15, -1051523), i = Ws(i, r, s, t, e[1], 21, -2054922799), t = Ws(t, i, r, s, e[8], 6, 1873313359), s = Ws(s, t, i, r, e[15], 10, -30611744), r = Ws(r, s, t, i, e[6], 15, -1560198380), i = Ws(i, r, s, t, e[13], 21, 1309151649), t = Ws(t, i, r, s, e[4], 6, -145523070), s = Ws(s, t, i, r, e[11], 10, -1120210379), r = Ws(r, s, t, i, e[2], 15, 718787259), i = Ws(i, r, s, t, e[9], 21, -343485551), n[0] = qu(t, n[0]), n[1] = qu(i, n[1]), n[2] = qu(r, n[2]), n[3] = qu(s, n[3]);
}
function Vm(n, e, t, i, r, s) {
  return e = qu(qu(e, n), qu(i, s)), qu(e << r | e >>> 32 - r, t);
}
function Vs(n, e, t, i, r, s, c) {
  return Vm(e & t | ~e & i, n, e, r, s, c);
}
function qs(n, e, t, i, r, s, c) {
  return Vm(e & i | t & ~i, n, e, r, s, c);
}
function Hs(n, e, t, i, r, s, c) {
  return Vm(e ^ t ^ i, n, e, r, s, c);
}
function Ws(n, e, t, i, r, s, c) {
  return Vm(t ^ (e | ~i), n, e, r, s, c);
}
function mT(n) {
  var e, t = n.length, i = [1732584193, -271733879, -1732584194, 271733878];
  for (e = 64; e <= n.length; e += 64)
    j_(i, XG(n.substring(e - 64, e)));
  n = n.substring(e - 64);
  var r = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (e = 0; e < n.length; e++)
    r[e >> 2] |= n.charCodeAt(e) << (e % 4 << 3);
  if (r[e >> 2] |= 128 << (e % 4 << 3), e > 55)
    for (j_(i, r), e = 0; e < 16; e++)
      r[e] = 0;
  return r[14] = 8 * t, j_(i, r), i;
}
function XG(n) {
  var e, t = [];
  for (e = 0; e < 64; e += 4)
    t[e >> 2] = n.charCodeAt(e) + (n.charCodeAt(e + 1) << 8) + (n.charCodeAt(e + 2) << 16) + (n.charCodeAt(e + 3) << 24);
  return t;
}
lp = Rn.atob.bind(Rn), Jy = Rn.btoa.bind(Rn);
var MA = "0123456789abcdef".split("");
function JG(n) {
  for (var e = "", t = 0; t < 4; t++)
    e += MA[n >> 8 * t + 4 & 15] + MA[n >> 8 * t & 15];
  return e;
}
function $G(n) {
  return String.fromCharCode((255 & n) >> 0, (65280 & n) >> 8, (16711680 & n) >> 16, (4278190080 & n) >> 24);
}
function $y(n) {
  return mT(n).map($G).join("");
}
var ZG = function(n) {
  for (var e = 0; e < n.length; e++)
    n[e] = JG(n[e]);
  return n.join("");
}(mT("hello")) != "5d41402abc4b2a76b9719d911017c592";
function qu(n, e) {
  if (ZG) {
    var t = (65535 & n) + (65535 & e);
    return (n >> 16) + (e >> 16) + (t >> 16) << 16 | 65535 & t;
  }
  return n + e & 4294967295;
}
/**
* @license
* FPDF is released under a permissive license: there is no usage restriction.
* You may embed it freely in your application (commercial or not), with or
* without modifications.
*
* Reference: http://www.fpdf.org/en/script/script37.php
*/
function Zy(n, e) {
  var t, i, r, s;
  if (n !== t) {
    for (var c = (r = n, s = 1 + (256 / n.length >> 0), new Array(s + 1).join(r)), l = [], m = 0; m < 256; m++)
      l[m] = m;
    var y = 0;
    for (m = 0; m < 256; m++) {
      var A = l[m];
      y = (y + A + c.charCodeAt(m)) % 256, l[m] = l[y], l[y] = A;
    }
    t = n, i = l;
  } else
    l = i;
  var T = e.length, I = 0, L = 0, N = "";
  for (m = 0; m < T; m++)
    L = (L + (A = l[I = (I + 1) % 256])) % 256, l[I] = l[L], l[L] = A, c = l[(l[I] + l[L]) % 256], N += String.fromCharCode(e.charCodeAt(m) ^ c);
  return N;
}
/**
* @license
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
* Author: Owen Leong (@owenl131)
* Date: 15 Oct 2020
* References:
* https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
* https://github.com/foliojs/pdfkit/blob/master/lib/security.js
* http://www.fpdf.org/en/script/script37.php
*/
var BA = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function wd(n, e, t, i) {
  this.v = 1, this.r = 2;
  var r = 192;
  n.forEach(function(l) {
    if (BA.perm !== void 0)
      throw new Error("Invalid permission: " + l);
    r += BA[l];
  }), this.padding = "(N^NuAd\0NV\b..\0h>/\fdSiz";
  var s = (e + this.padding).substr(0, 32), c = (t + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(s, c), this.P = -(1 + (255 ^ r)), this.encryptionKey = $y(s + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(i)).substr(0, 5), this.U = Zy(this.encryptionKey, this.padding);
}
function Ad(n) {
  if (/[^\u0000-\u00ff]/.test(n))
    throw new Error("Invalid PDF Name Object: " + n + ", Only accept ASCII characters.");
  for (var e = "", t = n.length, i = 0; i < t; i++) {
    var r = n.charCodeAt(i);
    r < 33 || r === 35 || r === 37 || r === 40 || r === 41 || r === 47 || r === 60 || r === 62 || r === 91 || r === 93 || r === 123 || r === 125 || r > 126 ? e += "#" + ("0" + r.toString(16)).slice(-2) : e += n[i];
  }
  return e;
}
function RA(n) {
  if (zi(n) !== "object")
    throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var e = {};
  this.subscribe = function(t, i, r) {
    if (r = r || !1, typeof t != "string" || typeof i != "function" || typeof r != "boolean")
      throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    e.hasOwnProperty(t) || (e[t] = {});
    var s = Math.random().toString(35);
    return e[t][s] = [i, !!r], s;
  }, this.unsubscribe = function(t) {
    for (var i in e)
      if (e[i][t])
        return delete e[i][t], Object.keys(e[i]).length === 0 && delete e[i], !0;
    return !1;
  }, this.publish = function(t) {
    if (e.hasOwnProperty(t)) {
      var i = Array.prototype.slice.call(arguments, 1), r = [];
      for (var s in e[t]) {
        var c = e[t][s];
        try {
          c[0].apply(n, i);
        } catch (l) {
          Rn.console && Ki.error("jsPDF PubSub Error", l.message, l);
        }
        c[1] && r.push(s);
      }
      r.length && r.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return e;
  };
}
function Tm(n) {
  if (!(this instanceof Tm))
    return new Tm(n);
  var e = "opacity,stroke-opacity".split(",");
  for (var t in n)
    n.hasOwnProperty(t) && e.indexOf(t) >= 0 && (this[t] = n[t]);
  this.id = "", this.objectNumber = -1;
}
function _T(n, e) {
  this.gState = n, this.matrix = e, this.id = "", this.objectNumber = -1;
}
function Ih(n, e, t, i, r) {
  if (!(this instanceof Ih))
    return new Ih(n, e, t, i, r);
  this.type = n === "axial" ? 2 : 3, this.coords = e, this.colors = t, _T.call(this, i, r);
}
function Pd(n, e, t, i, r) {
  if (!(this instanceof Pd))
    return new Pd(n, e, t, i, r);
  this.boundingBox = n, this.xStep = e, this.yStep = t, this.stream = "", this.cloneIndex = 0, _T.call(this, i, r);
}
function Bn(n) {
  var e, t = typeof arguments[0] == "string" ? arguments[0] : "p", i = arguments[1], r = arguments[2], s = arguments[3], c = [], l = 1, m = 16, y = "S", A = null;
  zi(n = n || {}) === "object" && (t = n.orientation, i = n.unit || i, r = n.format || r, s = n.compress || n.compressPdf || s, (A = n.encryption || null) !== null && (A.userPassword = A.userPassword || "", A.ownerPassword = A.ownerPassword || "", A.userPermissions = A.userPermissions || []), l = typeof n.userUnit == "number" ? Math.abs(n.userUnit) : 1, n.precision !== void 0 && (e = n.precision), n.floatPrecision !== void 0 && (m = n.floatPrecision), y = n.defaultPathOperation || "S"), c = n.filters || (s === !0 ? ["FlateEncode"] : c), i = i || "mm", t = ("" + (t || "P")).toLowerCase();
  var T = n.putOnlyUsedFonts || !1, I = {}, L = { internal: {}, __private__: {} };
  L.__private__.PubSub = RA;
  var N = "1.3", z = L.__private__.getPdfVersion = function() {
    return N;
  };
  L.__private__.setPdfVersion = function(F) {
    N = F;
  };
  var V = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  L.__private__.getPageFormats = function() {
    return V;
  };
  var H = L.__private__.getPageFormat = function(F) {
    return V[F];
  };
  r = r || "a4";
  var J = { COMPAT: "compat", ADVANCED: "advanced" }, ce = J.COMPAT;
  function me() {
    this.saveGraphicsState(), re(new Be(Bt, 0, 0, -Bt, 0, ba() * Bt).toString() + " cm"), this.setFontSize(this.getFontSize() / Bt), y = "n", ce = J.ADVANCED;
  }
  function Se() {
    this.restoreGraphicsState(), y = "S", ce = J.COMPAT;
  }
  var De = L.__private__.combineFontStyleAndFontWeight = function(F, te) {
    if (F == "bold" && te == "normal" || F == "bold" && te == 400 || F == "normal" && te == "italic" || F == "bold" && te == "italic")
      throw new Error("Invalid Combination of fontweight and fontstyle");
    return te && (F = te == 400 || te === "normal" ? F === "italic" ? "italic" : "normal" : te != 700 && te !== "bold" || F !== "normal" ? (te == 700 ? "bold" : te) + "" + F : "bold"), F;
  };
  L.advancedAPI = function(F) {
    var te = ce === J.COMPAT;
    return te && me.call(this), typeof F != "function" || (F(this), te && Se.call(this)), this;
  }, L.compatAPI = function(F) {
    var te = ce === J.ADVANCED;
    return te && Se.call(this), typeof F != "function" || (F(this), te && me.call(this)), this;
  }, L.isAdvancedAPI = function() {
    return ce === J.ADVANCED;
  };
  var Le, ye = function(F) {
    if (ce !== J.ADVANCED)
      throw new Error(F + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, Ve = L.roundToPrecision = L.__private__.roundToPrecision = function(F, te) {
    var Ee = e || te;
    if (isNaN(F) || isNaN(Ee))
      throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return F.toFixed(Ee).replace(/0+$/, "");
  };
  Le = L.hpf = L.__private__.hpf = typeof m == "number" ? function(F) {
    if (isNaN(F))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return Ve(F, m);
  } : m === "smart" ? function(F) {
    if (isNaN(F))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return Ve(F, F > -1 && F < 1 ? 16 : 5);
  } : function(F) {
    if (isNaN(F))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return Ve(F, 16);
  };
  var Fe = L.f2 = L.__private__.f2 = function(F) {
    if (isNaN(F))
      throw new Error("Invalid argument passed to jsPDF.f2");
    return Ve(F, 2);
  }, ae = L.__private__.f3 = function(F) {
    if (isNaN(F))
      throw new Error("Invalid argument passed to jsPDF.f3");
    return Ve(F, 3);
  }, de = L.scale = L.__private__.scale = function(F) {
    if (isNaN(F))
      throw new Error("Invalid argument passed to jsPDF.scale");
    return ce === J.COMPAT ? F * Bt : ce === J.ADVANCED ? F : void 0;
  }, Te = function(F) {
    return ce === J.COMPAT ? ba() - F : ce === J.ADVANCED ? F : void 0;
  }, be = function(F) {
    return de(Te(F));
  };
  L.__private__.setPrecision = L.setPrecision = function(F) {
    typeof parseInt(F, 10) == "number" && (e = parseInt(F, 10));
  };
  var tt, st = "00000000000000000000000000000000", lt = L.__private__.getFileId = function() {
    return st;
  }, Ye = L.__private__.setFileId = function(F) {
    return st = F !== void 0 && /^[a-fA-F0-9]{32}$/.test(F) ? F.toUpperCase() : st.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), A !== null && (ti = new wd(A.userPermissions, A.userPassword, A.ownerPassword, st)), st;
  };
  L.setFileId = function(F) {
    return Ye(F), this;
  }, L.getFileId = function() {
    return lt();
  };
  var ht = L.__private__.convertDateToPDFDate = function(F) {
    var te = F.getTimezoneOffset(), Ee = te < 0 ? "+" : "-", ze = Math.floor(Math.abs(te / 60)), Je = Math.abs(te % 60), dt = [Ee, Ce(ze), "'", Ce(Je), "'"].join("");
    return ["D:", F.getFullYear(), Ce(F.getMonth() + 1), Ce(F.getDate()), Ce(F.getHours()), Ce(F.getMinutes()), Ce(F.getSeconds()), dt].join("");
  }, ct = L.__private__.convertPDFDateToDate = function(F) {
    var te = parseInt(F.substr(2, 4), 10), Ee = parseInt(F.substr(6, 2), 10) - 1, ze = parseInt(F.substr(8, 2), 10), Je = parseInt(F.substr(10, 2), 10), dt = parseInt(F.substr(12, 2), 10), Tt = parseInt(F.substr(14, 2), 10);
    return new Date(te, Ee, ze, Je, dt, Tt, 0);
  }, Pt = L.__private__.setCreationDate = function(F) {
    var te;
    if (F === void 0 && (F = /* @__PURE__ */ new Date()), F instanceof Date)
      te = ht(F);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(F))
        throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      te = F;
    }
    return tt = te;
  }, se = L.__private__.getCreationDate = function(F) {
    var te = tt;
    return F === "jsDate" && (te = ct(tt)), te;
  };
  L.setCreationDate = function(F) {
    return Pt(F), this;
  }, L.getCreationDate = function(F) {
    return se(F);
  };
  var Ae, Ce = L.__private__.padd2 = function(F) {
    return ("0" + parseInt(F)).slice(-2);
  }, Ue = L.__private__.padd2Hex = function(F) {
    return ("00" + (F = F.toString())).substr(F.length);
  }, qe = 0, We = [], Ke = [], Ze = 0, At = [], It = [], Rt = !1, kt = Ke, on = function() {
    qe = 0, Ze = 0, Ke = [], We = [], At = [], _n = xt(), An = xt();
  };
  L.__private__.setCustomOutputDestination = function(F) {
    Rt = !0, kt = F;
  };
  var ut = function(F) {
    Rt || (kt = F);
  };
  L.__private__.resetCustomOutputDestination = function() {
    Rt = !1, kt = Ke;
  };
  var re = L.__private__.out = function(F) {
    return F = F.toString(), Ze += F.length + 1, kt.push(F), kt;
  }, mn = L.__private__.write = function(F) {
    return re(arguments.length === 1 ? F.toString() : Array.prototype.join.call(arguments, " "));
  }, Qt = L.__private__.getArrayBuffer = function(F) {
    for (var te = F.length, Ee = new ArrayBuffer(te), ze = new Uint8Array(Ee); te--; )
      ze[te] = F.charCodeAt(te);
    return Ee;
  }, pt = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  L.__private__.getStandardFonts = function() {
    return pt;
  };
  var Et = n.fontSize || 16;
  L.__private__.setFontSize = L.setFontSize = function(F) {
    return Et = ce === J.ADVANCED ? F / Bt : F, this;
  };
  var Lt, Ft = L.__private__.getFontSize = L.getFontSize = function() {
    return ce === J.COMPAT ? Et : Et * Bt;
  }, nn = n.R2L || !1;
  L.__private__.setR2L = L.setR2L = function(F) {
    return nn = F, this;
  }, L.__private__.getR2L = L.getR2L = function() {
    return nn;
  };
  var Tn, xn = L.__private__.setZoomMode = function(F) {
    var te = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(F))
      Lt = F;
    else if (isNaN(F)) {
      if (te.indexOf(F) === -1)
        throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + F + '" is not recognized.');
      Lt = F;
    } else
      Lt = parseInt(F, 10);
  };
  L.__private__.getZoomMode = function() {
    return Lt;
  };
  var On, Un = L.__private__.setPageMode = function(F) {
    if ([void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(F) == -1)
      throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + F + '" is not recognized.');
    Tn = F;
  };
  L.__private__.getPageMode = function() {
    return Tn;
  };
  var mt = L.__private__.setLayoutMode = function(F) {
    if ([void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(F) == -1)
      throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + F + '" is not recognized.');
    On = F;
  };
  L.__private__.getLayoutMode = function() {
    return On;
  }, L.__private__.setDisplayMode = L.setDisplayMode = function(F, te, Ee) {
    return xn(F), mt(te), Un(Ee), this;
  };
  var hn = { title: "", subject: "", author: "", keywords: "", creator: "" };
  L.__private__.getDocumentProperty = function(F) {
    if (Object.keys(hn).indexOf(F) === -1)
      throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return hn[F];
  }, L.__private__.getDocumentProperties = function() {
    return hn;
  }, L.__private__.setDocumentProperties = L.setProperties = L.setDocumentProperties = function(F) {
    for (var te in hn)
      hn.hasOwnProperty(te) && F[te] && (hn[te] = F[te]);
    return this;
  }, L.__private__.setDocumentProperty = function(F, te) {
    if (Object.keys(hn).indexOf(F) === -1)
      throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return hn[F] = te;
  };
  var wn, Bt, bi, _t, bn, Gt = {}, qn = {}, er = [], Nt = {}, vr = {}, ii = {}, sr = {}, or = null, ve = 0, X = [], $ = new RA(L), he = n.hotfixes || [], _e = {}, Oe = {}, je = [], Be = function F(te, Ee, ze, Je, dt, Tt) {
    if (!(this instanceof F))
      return new F(te, Ee, ze, Je, dt, Tt);
    isNaN(te) && (te = 1), isNaN(Ee) && (Ee = 0), isNaN(ze) && (ze = 0), isNaN(Je) && (Je = 1), isNaN(dt) && (dt = 0), isNaN(Tt) && (Tt = 0), this._matrix = [te, Ee, ze, Je, dt, Tt];
  };
  Object.defineProperty(Be.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(F) {
    this._matrix[0] = F;
  } }), Object.defineProperty(Be.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(F) {
    this._matrix[1] = F;
  } }), Object.defineProperty(Be.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(F) {
    this._matrix[2] = F;
  } }), Object.defineProperty(Be.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(F) {
    this._matrix[3] = F;
  } }), Object.defineProperty(Be.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(F) {
    this._matrix[4] = F;
  } }), Object.defineProperty(Be.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(F) {
    this._matrix[5] = F;
  } }), Object.defineProperty(Be.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(F) {
    this._matrix[0] = F;
  } }), Object.defineProperty(Be.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(F) {
    this._matrix[1] = F;
  } }), Object.defineProperty(Be.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(F) {
    this._matrix[2] = F;
  } }), Object.defineProperty(Be.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(F) {
    this._matrix[3] = F;
  } }), Object.defineProperty(Be.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(F) {
    this._matrix[4] = F;
  } }), Object.defineProperty(Be.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(F) {
    this._matrix[5] = F;
  } }), Object.defineProperty(Be.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(Be.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(Be.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(Be.prototype, "isIdentity", { get: function() {
    return this.sx === 1 && this.shy === 0 && this.shx === 0 && this.sy === 1 && this.tx === 0 && this.ty === 0;
  } }), Be.prototype.join = function(F) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(Le).join(F);
  }, Be.prototype.multiply = function(F) {
    var te = F.sx * this.sx + F.shy * this.shx, Ee = F.sx * this.shy + F.shy * this.sy, ze = F.shx * this.sx + F.sy * this.shx, Je = F.shx * this.shy + F.sy * this.sy, dt = F.tx * this.sx + F.ty * this.shx + this.tx, Tt = F.tx * this.shy + F.ty * this.sy + this.ty;
    return new Be(te, Ee, ze, Je, dt, Tt);
  }, Be.prototype.decompose = function() {
    var F = this.sx, te = this.shy, Ee = this.shx, ze = this.sy, Je = this.tx, dt = this.ty, Tt = Math.sqrt(F * F + te * te), Xt = (F /= Tt) * Ee + (te /= Tt) * ze;
    Ee -= F * Xt, ze -= te * Xt;
    var vn = Math.sqrt(Ee * Ee + ze * ze);
    return Xt /= vn, F * (ze /= vn) < te * (Ee /= vn) && (F = -F, te = -te, Xt = -Xt, Tt = -Tt), { scale: new Be(Tt, 0, 0, vn, 0, 0), translate: new Be(1, 0, 0, 1, Je, dt), rotate: new Be(F, te, -te, F, 0, 0), skew: new Be(1, 0, Xt, 1, 0, 0) };
  }, Be.prototype.toString = function(F) {
    return this.join(" ");
  }, Be.prototype.inversed = function() {
    var F = this.sx, te = this.shy, Ee = this.shx, ze = this.sy, Je = this.tx, dt = this.ty, Tt = 1 / (F * ze - te * Ee), Xt = ze * Tt, vn = -te * Tt, Ln = -Ee * Tt, zn = F * Tt;
    return new Be(Xt, vn, Ln, zn, -Xt * Je - Ln * dt, -vn * Je - zn * dt);
  }, Be.prototype.applyToPoint = function(F) {
    var te = F.x * this.sx + F.y * this.shx + this.tx, Ee = F.x * this.shy + F.y * this.sy + this.ty;
    return new Ps(te, Ee);
  }, Be.prototype.applyToRectangle = function(F) {
    var te = this.applyToPoint(F), Ee = this.applyToPoint(new Ps(F.x + F.w, F.y + F.h));
    return new zl(te.x, te.y, Ee.x - te.x, Ee.y - te.y);
  }, Be.prototype.clone = function() {
    var F = this.sx, te = this.shy, Ee = this.shx, ze = this.sy, Je = this.tx, dt = this.ty;
    return new Be(F, te, Ee, ze, Je, dt);
  }, L.Matrix = Be;
  var Ie = L.matrixMult = function(F, te) {
    return te.multiply(F);
  }, nt = new Be(1, 0, 0, 1, 0, 0);
  L.unitMatrix = L.identityMatrix = nt;
  var ft = function(F, te) {
    if (!vr[F]) {
      var Ee = (te instanceof Ih ? "Sh" : "P") + (Object.keys(Nt).length + 1).toString(10);
      te.id = Ee, vr[F] = Ee, Nt[Ee] = te, $.publish("addPattern", te);
    }
  };
  L.ShadingPattern = Ih, L.TilingPattern = Pd, L.addShadingPattern = function(F, te) {
    return ye("addShadingPattern()"), ft(F, te), this;
  }, L.beginTilingPattern = function(F) {
    ye("beginTilingPattern()"), cu(F.boundingBox[0], F.boundingBox[1], F.boundingBox[2] - F.boundingBox[0], F.boundingBox[3] - F.boundingBox[1], F.matrix);
  }, L.endTilingPattern = function(F, te) {
    ye("endTilingPattern()"), te.stream = It[Ae].join(`
`), ft(F, te), $.publish("endTilingPattern", te), je.pop().restore();
  };
  var Xe = L.__private__.newObject = function() {
    var F = xt();
    return $t(F, !0), F;
  }, xt = L.__private__.newObjectDeferred = function() {
    return qe++, We[qe] = function() {
      return Ze;
    }, qe;
  }, $t = function(F, te) {
    return te = typeof te == "boolean" && te, We[F] = Ze, te && re(F + " 0 obj"), F;
  }, Kt = L.__private__.newAdditionalObject = function() {
    var F = { objId: xt(), content: "" };
    return At.push(F), F;
  }, _n = xt(), An = xt(), an = L.__private__.decodeColorString = function(F) {
    var te = F.split(" ");
    if (te.length !== 2 || te[1] !== "g" && te[1] !== "G")
      te.length === 5 && (te[4] === "k" || te[4] === "K") && (te = [(1 - te[0]) * (1 - te[3]), (1 - te[1]) * (1 - te[3]), (1 - te[2]) * (1 - te[3]), "r"]);
    else {
      var Ee = parseFloat(te[0]);
      te = [Ee, Ee, Ee, "r"];
    }
    for (var ze = "#", Je = 0; Je < 3; Je++)
      ze += ("0" + Math.floor(255 * parseFloat(te[Je])).toString(16)).slice(-2);
    return ze;
  }, Fn = L.__private__.encodeColorString = function(F) {
    var te;
    typeof F == "string" && (F = { ch1: F });
    var Ee = F.ch1, ze = F.ch2, Je = F.ch3, dt = F.ch4, Tt = F.pdfColorType === "draw" ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if (typeof Ee == "string" && Ee.charAt(0) !== "#") {
      var Xt = new gT(Ee);
      if (Xt.ok)
        Ee = Xt.toHex();
      else if (!/^\d*\.?\d*$/.test(Ee))
        throw new Error('Invalid color "' + Ee + '" passed to jsPDF.encodeColorString.');
    }
    if (typeof Ee == "string" && /^#[0-9A-Fa-f]{3}$/.test(Ee) && (Ee = "#" + Ee[1] + Ee[1] + Ee[2] + Ee[2] + Ee[3] + Ee[3]), typeof Ee == "string" && /^#[0-9A-Fa-f]{6}$/.test(Ee)) {
      var vn = parseInt(Ee.substr(1), 16);
      Ee = vn >> 16 & 255, ze = vn >> 8 & 255, Je = 255 & vn;
    }
    if (ze === void 0 || dt === void 0 && Ee === ze && ze === Je)
      if (typeof Ee == "string")
        te = Ee + " " + Tt[0];
      else
        switch (F.precision) {
          case 2:
            te = Fe(Ee / 255) + " " + Tt[0];
            break;
          case 3:
          default:
            te = ae(Ee / 255) + " " + Tt[0];
        }
    else if (dt === void 0 || zi(dt) === "object") {
      if (dt && !isNaN(dt.a) && dt.a === 0)
        return te = ["1.", "1.", "1.", Tt[1]].join(" ");
      if (typeof Ee == "string")
        te = [Ee, ze, Je, Tt[1]].join(" ");
      else
        switch (F.precision) {
          case 2:
            te = [Fe(Ee / 255), Fe(ze / 255), Fe(Je / 255), Tt[1]].join(" ");
            break;
          default:
          case 3:
            te = [ae(Ee / 255), ae(ze / 255), ae(Je / 255), Tt[1]].join(" ");
        }
    } else if (typeof Ee == "string")
      te = [Ee, ze, Je, dt, Tt[2]].join(" ");
    else
      switch (F.precision) {
        case 2:
          te = [Fe(Ee), Fe(ze), Fe(Je), Fe(dt), Tt[2]].join(" ");
          break;
        case 3:
        default:
          te = [ae(Ee), ae(ze), ae(Je), ae(dt), Tt[2]].join(" ");
      }
    return te;
  }, Yn = L.__private__.getFilters = function() {
    return c;
  }, Kn = L.__private__.putStream = function(F) {
    var te = (F = F || {}).data || "", Ee = F.filters || Yn(), ze = F.alreadyAppliedFilters || [], Je = F.addLength1 || !1, dt = te.length, Tt = F.objectId, Xt = function(xr) {
      return xr;
    };
    if (A !== null && Tt === void 0)
      throw new Error("ObjectId must be passed to putStream for file encryption");
    A !== null && (Xt = ti.encryptor(Tt, 0));
    var vn = {};
    Ee === !0 && (Ee = ["FlateEncode"]);
    var Ln = F.additionalKeyValues || [], zn = (vn = Bn.API.processDataByFilters !== void 0 ? Bn.API.processDataByFilters(te, Ee) : { data: te, reverseChain: [] }).reverseChain + (Array.isArray(ze) ? ze.join(" ") : ze.toString());
    if (vn.data.length !== 0 && (Ln.push({ key: "Length", value: vn.data.length }), Je === !0 && Ln.push({ key: "Length1", value: dt })), zn.length != 0)
      if (zn.split("/").length - 1 == 1)
        Ln.push({ key: "Filter", value: zn });
      else {
        Ln.push({ key: "Filter", value: "[" + zn + "]" });
        for (var $n = 0; $n < Ln.length; $n += 1)
          if (Ln[$n].key === "DecodeParms") {
            for (var In = [], $i = 0; $i < vn.reverseChain.split("/").length - 1; $i += 1)
              In.push("null");
            In.push(Ln[$n].value), Ln[$n].value = "[" + In.join(" ") + "]";
          }
      }
    re("<<");
    for (var fn = 0; fn < Ln.length; fn++)
      re("/" + Ln[fn].key + " " + Ln[fn].value);
    re(">>"), vn.data.length !== 0 && (re("stream"), re(Xt(vn.data)), re("endstream"));
  }, dn = L.__private__.putPage = function(F) {
    var te = F.number, Ee = F.data, ze = F.objId, Je = F.contentsObjId;
    $t(ze, !0), re("<</Type /Page"), re("/Parent " + F.rootDictionaryObjId + " 0 R"), re("/Resources " + F.resourceDictionaryObjId + " 0 R"), re("/MediaBox [" + parseFloat(Le(F.mediaBox.bottomLeftX)) + " " + parseFloat(Le(F.mediaBox.bottomLeftY)) + " " + Le(F.mediaBox.topRightX) + " " + Le(F.mediaBox.topRightY) + "]"), F.cropBox !== null && re("/CropBox [" + Le(F.cropBox.bottomLeftX) + " " + Le(F.cropBox.bottomLeftY) + " " + Le(F.cropBox.topRightX) + " " + Le(F.cropBox.topRightY) + "]"), F.bleedBox !== null && re("/BleedBox [" + Le(F.bleedBox.bottomLeftX) + " " + Le(F.bleedBox.bottomLeftY) + " " + Le(F.bleedBox.topRightX) + " " + Le(F.bleedBox.topRightY) + "]"), F.trimBox !== null && re("/TrimBox [" + Le(F.trimBox.bottomLeftX) + " " + Le(F.trimBox.bottomLeftY) + " " + Le(F.trimBox.topRightX) + " " + Le(F.trimBox.topRightY) + "]"), F.artBox !== null && re("/ArtBox [" + Le(F.artBox.bottomLeftX) + " " + Le(F.artBox.bottomLeftY) + " " + Le(F.artBox.topRightX) + " " + Le(F.artBox.topRightY) + "]"), typeof F.userUnit == "number" && F.userUnit !== 1 && re("/UserUnit " + F.userUnit), $.publish("putPage", { objId: ze, pageContext: X[te], pageNumber: te, page: Ee }), re("/Contents " + Je + " 0 R"), re(">>"), re("endobj");
    var dt = Ee.join(`
`);
    return ce === J.ADVANCED && (dt += `
Q`), $t(Je, !0), Kn({ data: dt, filters: Yn(), objectId: Je }), re("endobj"), ze;
  }, Dn = L.__private__.putPages = function() {
    var F, te, Ee = [];
    for (F = 1; F <= ve; F++)
      X[F].objId = xt(), X[F].contentsObjId = xt();
    for (F = 1; F <= ve; F++)
      Ee.push(dn({ number: F, data: It[F], objId: X[F].objId, contentsObjId: X[F].contentsObjId, mediaBox: X[F].mediaBox, cropBox: X[F].cropBox, bleedBox: X[F].bleedBox, trimBox: X[F].trimBox, artBox: X[F].artBox, userUnit: X[F].userUnit, rootDictionaryObjId: _n, resourceDictionaryObjId: An }));
    $t(_n, !0), re("<</Type /Pages");
    var ze = "/Kids [";
    for (te = 0; te < ve; te++)
      ze += Ee[te] + " 0 R ";
    re(ze + "]"), re("/Count " + ve), re(">>"), re("endobj"), $.publish("postPutPages");
  }, Jn = function(F) {
    $.publish("putFont", { font: F, out: re, newObject: Xe, putStream: Kn }), F.isAlreadyPutted !== !0 && (F.objectNumber = Xe(), re("<<"), re("/Type /Font"), re("/BaseFont /" + Ad(F.postScriptName)), re("/Subtype /Type1"), typeof F.encoding == "string" && re("/Encoding /" + F.encoding), re("/FirstChar 32"), re("/LastChar 255"), re(">>"), re("endobj"));
  }, di = function() {
    for (var F in Gt)
      Gt.hasOwnProperty(F) && (T === !1 || T === !0 && I.hasOwnProperty(F)) && Jn(Gt[F]);
  }, Bi = function(F) {
    F.objectNumber = Xe();
    var te = [];
    te.push({ key: "Type", value: "/XObject" }), te.push({ key: "Subtype", value: "/Form" }), te.push({ key: "BBox", value: "[" + [Le(F.x), Le(F.y), Le(F.x + F.width), Le(F.y + F.height)].join(" ") + "]" }), te.push({ key: "Matrix", value: "[" + F.matrix.toString() + "]" });
    var Ee = F.pages[1].join(`
`);
    Kn({ data: Ee, additionalKeyValues: te, objectId: F.objectNumber }), re("endobj");
  }, Xi = function() {
    for (var F in _e)
      _e.hasOwnProperty(F) && Bi(_e[F]);
  }, yo = function(F, te) {
    var Ee, ze = [], Je = 1 / (te - 1);
    for (Ee = 0; Ee < 1; Ee += Je)
      ze.push(Ee);
    if (ze.push(1), F[0].offset != 0) {
      var dt = { offset: 0, color: F[0].color };
      F.unshift(dt);
    }
    if (F[F.length - 1].offset != 1) {
      var Tt = { offset: 1, color: F[F.length - 1].color };
      F.push(Tt);
    }
    for (var Xt = "", vn = 0, Ln = 0; Ln < ze.length; Ln++) {
      for (Ee = ze[Ln]; Ee > F[vn + 1].offset; )
        vn++;
      var zn = F[vn].offset, $n = (Ee - zn) / (F[vn + 1].offset - zn), In = F[vn].color, $i = F[vn + 1].color;
      Xt += Ue(Math.round((1 - $n) * In[0] + $n * $i[0]).toString(16)) + Ue(Math.round((1 - $n) * In[1] + $n * $i[1]).toString(16)) + Ue(Math.round((1 - $n) * In[2] + $n * $i[2]).toString(16));
    }
    return Xt.trim();
  }, Xn = function(F, te) {
    te || (te = 21);
    var Ee = Xe(), ze = yo(F.colors, te), Je = [];
    Je.push({ key: "FunctionType", value: "0" }), Je.push({ key: "Domain", value: "[0.0 1.0]" }), Je.push({ key: "Size", value: "[" + te + "]" }), Je.push({ key: "BitsPerSample", value: "8" }), Je.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), Je.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), Kn({ data: ze, additionalKeyValues: Je, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: Ee }), re("endobj"), F.objectNumber = Xe(), re("<< /ShadingType " + F.type), re("/ColorSpace /DeviceRGB");
    var dt = "/Coords [" + Le(parseFloat(F.coords[0])) + " " + Le(parseFloat(F.coords[1])) + " ";
    F.type === 2 ? dt += Le(parseFloat(F.coords[2])) + " " + Le(parseFloat(F.coords[3])) : dt += Le(parseFloat(F.coords[2])) + " " + Le(parseFloat(F.coords[3])) + " " + Le(parseFloat(F.coords[4])) + " " + Le(parseFloat(F.coords[5])), re(dt += "]"), F.matrix && re("/Matrix [" + F.matrix.toString() + "]"), re("/Function " + Ee + " 0 R"), re("/Extend [true true]"), re(">>"), re("endobj");
  }, br = function(F, te) {
    var Ee = xt(), ze = Xe();
    te.push({ resourcesOid: Ee, objectOid: ze }), F.objectNumber = ze;
    var Je = [];
    Je.push({ key: "Type", value: "/Pattern" }), Je.push({ key: "PatternType", value: "1" }), Je.push({ key: "PaintType", value: "1" }), Je.push({ key: "TilingType", value: "1" }), Je.push({ key: "BBox", value: "[" + F.boundingBox.map(Le).join(" ") + "]" }), Je.push({ key: "XStep", value: Le(F.xStep) }), Je.push({ key: "YStep", value: Le(F.yStep) }), Je.push({ key: "Resources", value: Ee + " 0 R" }), F.matrix && Je.push({ key: "Matrix", value: "[" + F.matrix.toString() + "]" }), Kn({ data: F.stream, additionalKeyValues: Je, objectId: F.objectNumber }), re("endobj");
  }, Hr = function(F) {
    var te;
    for (te in Nt)
      Nt.hasOwnProperty(te) && (Nt[te] instanceof Ih ? Xn(Nt[te]) : Nt[te] instanceof Pd && br(Nt[te], F));
  }, Ri = function(F) {
    for (var te in F.objectNumber = Xe(), re("<<"), F)
      switch (te) {
        case "opacity":
          re("/ca " + Fe(F[te]));
          break;
        case "stroke-opacity":
          re("/CA " + Fe(F[te]));
      }
    re(">>"), re("endobj");
  }, Oi = function() {
    var F;
    for (F in ii)
      ii.hasOwnProperty(F) && Ri(ii[F]);
  }, Ys = function() {
    for (var F in re("/XObject <<"), _e)
      _e.hasOwnProperty(F) && _e[F].objectNumber >= 0 && re("/" + F + " " + _e[F].objectNumber + " 0 R");
    $.publish("putXobjectDict"), re(">>");
  }, Ii = function() {
    ti.oid = Xe(), re("<<"), re("/Filter /Standard"), re("/V " + ti.v), re("/R " + ti.r), re("/U <" + ti.toHexString(ti.U) + ">"), re("/O <" + ti.toHexString(ti.O) + ">"), re("/P " + ti.P), re(">>"), re("endobj");
  }, fi = function() {
    for (var F in re("/Font <<"), Gt)
      Gt.hasOwnProperty(F) && (T === !1 || T === !0 && I.hasOwnProperty(F)) && re("/" + F + " " + Gt[F].objectNumber + " 0 R");
    re(">>");
  }, zo = function() {
    if (Object.keys(Nt).length > 0) {
      for (var F in re("/Shading <<"), Nt)
        Nt.hasOwnProperty(F) && Nt[F] instanceof Ih && Nt[F].objectNumber >= 0 && re("/" + F + " " + Nt[F].objectNumber + " 0 R");
      $.publish("putShadingPatternDict"), re(">>");
    }
  }, _s = function(F) {
    if (Object.keys(Nt).length > 0) {
      for (var te in re("/Pattern <<"), Nt)
        Nt.hasOwnProperty(te) && Nt[te] instanceof L.TilingPattern && Nt[te].objectNumber >= 0 && Nt[te].objectNumber < F && re("/" + te + " " + Nt[te].objectNumber + " 0 R");
      $.publish("putTilingPatternDict"), re(">>");
    }
  }, xi = function() {
    if (Object.keys(ii).length > 0) {
      var F;
      for (F in re("/ExtGState <<"), ii)
        ii.hasOwnProperty(F) && ii[F].objectNumber >= 0 && re("/" + F + " " + ii[F].objectNumber + " 0 R");
      $.publish("putGStateDict"), re(">>");
    }
  }, Nn = function(F) {
    $t(F.resourcesOid, !0), re("<<"), re("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), fi(), zo(), _s(F.objectOid), xi(), Ys(), re(">>"), re("endobj");
  }, Wr = function() {
    var F = [];
    di(), Oi(), Xi(), Hr(F), $.publish("putResources"), F.forEach(Nn), Nn({ resourcesOid: An, objectOid: Number.MAX_SAFE_INTEGER }), $.publish("postPutResources");
  }, _i = function() {
    $.publish("putAdditionalObjects");
    for (var F = 0; F < At.length; F++) {
      var te = At[F];
      $t(te.objId, !0), re(te.content), re("endobj");
    }
    $.publish("postPutAdditionalObjects");
  }, Ks = function(F) {
    qn[F.fontName] = qn[F.fontName] || {}, qn[F.fontName][F.fontStyle] = F.id;
  }, hr = function(F, te, Ee, ze, Je) {
    var dt = { id: "F" + (Object.keys(Gt).length + 1).toString(10), postScriptName: F, fontName: te, fontStyle: Ee, encoding: ze, isStandardFont: Je || !1, metadata: {} };
    return $.publish("addFont", { font: dt, instance: this }), Gt[dt.id] = dt, Ks(dt), dt.id;
  }, Qs = function(F) {
    for (var te = 0, Ee = pt.length; te < Ee; te++) {
      var ze = hr.call(this, F[te][0], F[te][1], F[te][2], pt[te][3], !0);
      T === !1 && (I[ze] = !0);
      var Je = F[te][0].split("-");
      Ks({ id: ze, fontName: Je[0], fontStyle: Je[1] || "" });
    }
    $.publish("addFonts", { fonts: Gt, dictionary: qn });
  }, Ji = function(F) {
    return F.foo = function() {
      try {
        return F.apply(this, arguments);
      } catch (ze) {
        var te = ze.stack || "";
        ~te.indexOf(" at ") && (te = te.split(" at ")[1]);
        var Ee = "Error in function " + te.split(`
`)[0].split("<")[0] + ": " + ze.message;
        if (!Rn.console)
          throw new Error(Ee);
        Rn.console.error(Ee, ze), Rn.alert && alert(Ee);
      }
    }, F.foo.bar = F, F.foo;
  }, Pr = function(F, te) {
    var Ee, ze, Je, dt, Tt, Xt, vn, Ln, zn;
    if (Je = (te = te || {}).sourceEncoding || "Unicode", Tt = te.outputEncoding, (te.autoencode || Tt) && Gt[wn].metadata && Gt[wn].metadata[Je] && Gt[wn].metadata[Je].encoding && (dt = Gt[wn].metadata[Je].encoding, !Tt && Gt[wn].encoding && (Tt = Gt[wn].encoding), !Tt && dt.codePages && (Tt = dt.codePages[0]), typeof Tt == "string" && (Tt = dt[Tt]), Tt)) {
      for (vn = !1, Xt = [], Ee = 0, ze = F.length; Ee < ze; Ee++)
        (Ln = Tt[F.charCodeAt(Ee)]) ? Xt.push(String.fromCharCode(Ln)) : Xt.push(F[Ee]), Xt[Ee].charCodeAt(0) >> 8 && (vn = !0);
      F = Xt.join("");
    }
    for (Ee = F.length; vn === void 0 && Ee !== 0; )
      F.charCodeAt(Ee - 1) >> 8 && (vn = !0), Ee--;
    if (!vn)
      return F;
    for (Xt = te.noBOM ? [] : [254, 255], Ee = 0, ze = F.length; Ee < ze; Ee++) {
      if ((zn = (Ln = F.charCodeAt(Ee)) >> 8) >> 8)
        throw new Error("Character at position " + Ee + " of string '" + F + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      Xt.push(zn), Xt.push(Ln - (zn << 8));
    }
    return String.fromCharCode.apply(void 0, Xt);
  }, dr = L.__private__.pdfEscape = L.pdfEscape = function(F, te) {
    return Pr(F, te).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, Xr = L.__private__.beginPage = function(F) {
    It[++ve] = [], X[ve] = { objId: 0, contentsObjId: 0, userUnit: Number(l), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(F[0]), topRightY: Number(F[1]) } }, ma(ve), ut(It[Ae]);
  }, jn = function(F, te) {
    var Ee, ze, Je;
    switch (t = te || t, typeof F == "string" && (Ee = H(F.toLowerCase()), Array.isArray(Ee) && (ze = Ee[0], Je = Ee[1])), Array.isArray(F) && (ze = F[0] * Bt, Je = F[1] * Bt), isNaN(ze) && (ze = r[0], Je = r[1]), (ze > 14400 || Je > 14400) && (Ki.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), ze = Math.min(14400, ze), Je = Math.min(14400, Je)), r = [ze, Je], t.substr(0, 1)) {
      case "l":
        Je > ze && (r = [Je, ze]);
        break;
      case "p":
        ze > Je && (r = [Je, ze]);
    }
    Xr(r), Fl(nl), re(no), kl !== 0 && re(kl + " J"), Nl !== 0 && re(Nl + " j"), $.publish("addPage", { pageNumber: ve });
  }, Uo = function(F) {
    F > 0 && F <= ve && (It.splice(F, 1), X.splice(F, 1), ve--, Ae > ve && (Ae = ve), this.setPage(Ae));
  }, ma = function(F) {
    F > 0 && F <= ve && (Ae = F);
  }, jo = L.__private__.getNumberOfPages = L.getNumberOfPages = function() {
    return It.length - 1;
  }, ue = function(F, te, Ee) {
    var ze, Je = void 0;
    return Ee = Ee || {}, F = F !== void 0 ? F : Gt[wn].fontName, te = te !== void 0 ? te : Gt[wn].fontStyle, ze = F.toLowerCase(), qn[ze] !== void 0 && qn[ze][te] !== void 0 ? Je = qn[ze][te] : qn[F] !== void 0 && qn[F][te] !== void 0 ? Je = qn[F][te] : Ee.disableWarning === !1 && Ki.warn("Unable to look up font label for font '" + F + "', '" + te + "'. Refer to getFontList() for available fonts."), Je || Ee.noFallback || (Je = qn.times[te]) == null && (Je = qn.times.normal), Je;
  }, ge = L.__private__.putInfo = function() {
    var F = Xe(), te = function(ze) {
      return ze;
    };
    for (var Ee in A !== null && (te = ti.encryptor(F, 0)), re("<<"), re("/Producer (" + dr(te("jsPDF " + Bn.version)) + ")"), hn)
      hn.hasOwnProperty(Ee) && hn[Ee] && re("/" + Ee.substr(0, 1).toUpperCase() + Ee.substr(1) + " (" + dr(te(hn[Ee])) + ")");
    re("/CreationDate (" + dr(te(tt)) + ")"), re(">>"), re("endobj");
  }, Re = L.__private__.putCatalog = function(F) {
    var te = (F = F || {}).rootDictionaryObjId || _n;
    switch (Xe(), re("<<"), re("/Type /Catalog"), re("/Pages " + te + " 0 R"), Lt || (Lt = "fullwidth"), Lt) {
      case "fullwidth":
        re("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        re("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        re("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        re("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var Ee = "" + Lt;
        Ee.substr(Ee.length - 1) === "%" && (Lt = parseInt(Lt) / 100), typeof Lt == "number" && re("/OpenAction [3 0 R /XYZ null null " + Fe(Lt) + "]");
    }
    switch (On || (On = "continuous"), On) {
      case "continuous":
        re("/PageLayout /OneColumn");
        break;
      case "single":
        re("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        re("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        re("/PageLayout /TwoColumnRight");
    }
    Tn && re("/PageMode /" + Tn), $.publish("putCatalog"), re(">>"), re("endobj");
  }, it = L.__private__.putTrailer = function() {
    re("trailer"), re("<<"), re("/Size " + (qe + 1)), re("/Root " + qe + " 0 R"), re("/Info " + (qe - 1) + " 0 R"), A !== null && re("/Encrypt " + ti.oid + " 0 R"), re("/ID [ <" + st + "> <" + st + "> ]"), re(">>");
  }, St = L.__private__.putHeader = function() {
    re("%PDF-" + N), re("%");
  }, Wt = L.__private__.putXRef = function() {
    var F = "0000000000";
    re("xref"), re("0 " + (qe + 1)), re("0000000000 65535 f ");
    for (var te = 1; te <= qe; te++)
      typeof We[te] == "function" ? re((F + We[te]()).slice(-10) + " 00000 n ") : We[te] !== void 0 ? re((F + We[te]).slice(-10) + " 00000 n ") : re("0000000000 00000 n ");
  }, Pn = L.__private__.buildDocument = function() {
    on(), ut(Ke), $.publish("buildDocument"), St(), Dn(), _i(), Wr(), A !== null && Ii(), ge(), Re();
    var F = Ze;
    return Wt(), it(), re("startxref"), re("" + F), re("%%EOF"), ut(It[Ae]), Ke.join(`
`);
  }, Fi = L.__private__.getBlob = function(F) {
    return new Blob([Qt(F)], { type: "application/pdf" });
  }, Di = L.output = L.__private__.output = Ji(function(F, te) {
    switch (typeof (te = te || {}) == "string" ? te = { filename: te } : te.filename = te.filename || "generated.pdf", F) {
      case void 0:
        return Pn();
      case "save":
        L.save(te.filename);
        break;
      case "arraybuffer":
        return Qt(Pn());
      case "blob":
        return Fi(Pn());
      case "bloburi":
      case "bloburl":
        if (Rn.URL !== void 0 && typeof Rn.URL.createObjectURL == "function")
          return Rn.URL && Rn.URL.createObjectURL(Fi(Pn())) || void 0;
        Ki.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var Ee = "", ze = Pn();
        try {
          Ee = Jy(ze);
        } catch {
          Ee = Jy(unescape(encodeURIComponent(ze)));
        }
        return "data:application/pdf;filename=" + te.filename + ";base64," + Ee;
      case "pdfobjectnewwindow":
        if (Object.prototype.toString.call(Rn) === "[object Window]") {
          var Je = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", dt = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          te.pdfObjectUrl && (Je = te.pdfObjectUrl, dt = "");
          var Tt = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + Je + '"' + dt + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(te) + ");<\/script></body></html>", Xt = Rn.open();
          return Xt !== null && Xt.document.write(Tt), Xt;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if (Object.prototype.toString.call(Rn) === "[object Window]") {
          var vn = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (te.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + te.filename + '" width="500px" height="400px" /></body></html>', Ln = Rn.open();
          if (Ln !== null) {
            Ln.document.write(vn);
            var zn = this;
            Ln.document.documentElement.querySelector("#pdfViewer").onload = function() {
              Ln.document.title = te.filename, Ln.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(zn.output("bloburl"));
            };
          }
          return Ln;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if (Object.prototype.toString.call(Rn) !== "[object Window]")
          throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var $n = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", te) + '"></iframe></body></html>', In = Rn.open();
        if (In !== null && (In.document.write($n), In.document.title = te.filename), In || typeof safari > "u")
          return In;
        break;
      case "datauri":
      case "dataurl":
        return Rn.document.location.href = this.output("datauristring", te);
      default:
        return null;
    }
  }), fr = function(F) {
    return Array.isArray(he) === !0 && he.indexOf(F) > -1;
  };
  switch (i) {
    case "pt":
      Bt = 1;
      break;
    case "mm":
      Bt = 72 / 25.4;
      break;
    case "cm":
      Bt = 72 / 2.54;
      break;
    case "in":
      Bt = 72;
      break;
    case "px":
      Bt = fr("px_scaling") == 1 ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      Bt = 12;
      break;
    case "ex":
      Bt = 6;
      break;
    default:
      if (typeof i != "number")
        throw new Error("Invalid unit: " + i);
      Bt = i;
  }
  var ti = null;
  Pt(), Ye();
  var Qa = function(F) {
    return A !== null ? ti.encryptor(F, 0) : function(te) {
      return te;
    };
  }, Nr = L.__private__.getPageInfo = L.getPageInfo = function(F) {
    if (isNaN(F) || F % 1 != 0)
      throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: X[F].objId, pageNumber: F, pageContext: X[F] };
  }, yn = L.__private__.getPageInfoByObjId = function(F) {
    if (isNaN(F) || F % 1 != 0)
      throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var te in X)
      if (X[te].objId === F)
        break;
    return Nr(te);
  }, el = L.__private__.getCurrentPageInfo = L.getCurrentPageInfo = function() {
    return { objId: X[Ae].objId, pageNumber: Ae, pageContext: X[Ae] };
  };
  L.addPage = function() {
    return jn.apply(this, arguments), this;
  }, L.setPage = function() {
    return ma.apply(this, arguments), ut.call(this, It[Ae]), this;
  }, L.insertPage = function(F) {
    return this.addPage(), this.movePage(Ae, F), this;
  }, L.movePage = function(F, te) {
    var Ee, ze;
    if (F > te) {
      Ee = It[F], ze = X[F];
      for (var Je = F; Je > te; Je--)
        It[Je] = It[Je - 1], X[Je] = X[Je - 1];
      It[te] = Ee, X[te] = ze, this.setPage(te);
    } else if (F < te) {
      Ee = It[F], ze = X[F];
      for (var dt = F; dt < te; dt++)
        It[dt] = It[dt + 1], X[dt] = X[dt + 1];
      It[te] = Ee, X[te] = ze, this.setPage(te);
    }
    return this;
  }, L.deletePage = function() {
    return Uo.apply(this, arguments), this;
  }, L.__private__.text = L.text = function(F, te, Ee, ze, Je) {
    var dt, Tt, Xt, vn, Ln, zn, $n, In, $i, fn = (ze = ze || {}).scope || this;
    if (typeof F == "number" && typeof te == "number" && (typeof Ee == "string" || Array.isArray(Ee))) {
      var xr = Ee;
      Ee = te, te = F, F = xr;
    }
    if (arguments[3] instanceof Be ? (ye("The transform parameter of text() with a Matrix value"), $i = Je) : (Xt = arguments[4], vn = arguments[5], zi($n = arguments[3]) === "object" && $n !== null || (typeof Xt == "string" && (vn = Xt, Xt = null), typeof $n == "string" && (vn = $n, $n = null), typeof $n == "number" && (Xt = $n, $n = null), ze = { flags: $n, angle: Xt, align: vn })), isNaN(te) || isNaN(Ee) || F == null)
      throw new Error("Invalid arguments passed to jsPDF.text");
    if (F.length === 0)
      return fn;
    var kn = "", Zn = !1, zr = typeof ze.lineHeightFactor == "number" ? ze.lineHeightFactor : Go, Ao = fn.internal.scaleFactor;
    function Ul(Gn) {
      return Gn = Gn.split("	").join(Array(ze.TabLen || 9).join(" ")), dr(Gn, $n);
    }
    function xa(Gn) {
      for (var ci, Zi = Gn.concat(), tr = [], ao = Zi.length; ao--; )
        typeof (ci = Zi.shift()) == "string" ? tr.push(ci) : Array.isArray(Gn) && (ci.length === 1 || ci[1] === void 0 && ci[2] === void 0) ? tr.push(ci[0]) : tr.push([ci[0], ci[1], ci[2]]);
      return tr;
    }
    function wa(Gn, ci) {
      var Zi;
      if (typeof Gn == "string")
        Zi = ci(Gn)[0];
      else if (Array.isArray(Gn)) {
        for (var tr, ao, bs = Gn.concat(), Pa = [], Ko = bs.length; Ko--; )
          typeof (tr = bs.shift()) == "string" ? Pa.push(ci(tr)[0]) : Array.isArray(tr) && typeof tr[0] == "string" && (ao = ci(tr[0], tr[1], tr[2]), Pa.push([ao[0], ao[1], ao[2]]));
        Zi = Pa;
      }
      return Zi;
    }
    var Ho = !1, sl = !0;
    if (typeof F == "string")
      Ho = !0;
    else if (Array.isArray(F)) {
      var Ls = F.concat();
      Tt = [];
      for (var Ms, Pi = Ls.length; Pi--; )
        (typeof (Ms = Ls.shift()) != "string" || Array.isArray(Ms) && typeof Ms[0] != "string") && (sl = !1);
      Ho = sl;
    }
    if (Ho === !1)
      throw new Error('Type of text must be string or Array. "' + F + '" is not recognized.');
    typeof F == "string" && (F = F.match(/[\r?\n]/) ? F.split(/\r\n|\r|\n/g) : [F]);
    var Aa = Et / fn.internal.scaleFactor, Wo = Aa * (zr - 1);
    switch (ze.baseline) {
      case "bottom":
        Ee -= Wo;
        break;
      case "top":
        Ee += Aa - Wo;
        break;
      case "hanging":
        Ee += Aa - 2 * Wo;
        break;
      case "middle":
        Ee += Aa / 2 - Wo;
    }
    if ((zn = ze.maxWidth || 0) > 0 && (typeof F == "string" ? F = fn.splitTextToSize(F, zn) : Object.prototype.toString.call(F) === "[object Array]" && (F = F.reduce(function(Gn, ci) {
      return Gn.concat(fn.splitTextToSize(ci, zn));
    }, []))), dt = { text: F, x: te, y: Ee, options: ze, mutex: { pdfEscape: dr, activeFontKey: wn, fonts: Gt, activeFontSize: Et } }, $.publish("preProcessText", dt), F = dt.text, Xt = (ze = dt.options).angle, !($i instanceof Be) && Xt && typeof Xt == "number") {
      Xt *= Math.PI / 180, ze.rotationDirection === 0 && (Xt = -Xt), ce === J.ADVANCED && (Xt = -Xt);
      var Ea = Math.cos(Xt), io = Math.sin(Xt);
      $i = new Be(Ea, io, -io, Ea, 0, 0);
    } else
      Xt && Xt instanceof Be && ($i = Xt);
    ce !== J.ADVANCED || $i || ($i = nt), (Ln = ze.charSpace || ya) !== void 0 && (kn += Le(de(Ln)) + ` Tc
`, this.setCharSpace(this.getCharSpace() || 0)), (In = ze.horizontalScale) !== void 0 && (kn += Le(100 * In) + ` Tz
`), ze.lang;
    var Lr = -1, jl = ze.renderingMode !== void 0 ? ze.renderingMode : ze.stroke, Xo = fn.internal.getCurrentPageInfo().pageContext;
    switch (jl) {
      case 0:
      case !1:
      case "fill":
        Lr = 0;
        break;
      case 1:
      case !0:
      case "stroke":
        Lr = 1;
        break;
      case 2:
      case "fillThenStroke":
        Lr = 2;
        break;
      case 3:
      case "invisible":
        Lr = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        Lr = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        Lr = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        Lr = 6;
        break;
      case 7:
      case "addToPathForClipping":
        Lr = 7;
    }
    var ol = Xo.usedRenderingMode !== void 0 ? Xo.usedRenderingMode : -1;
    Lr !== -1 ? kn += Lr + ` Tr
` : ol !== -1 && (kn += `0 Tr
`), Lr !== -1 && (Xo.usedRenderingMode = Lr), vn = ze.align || "left";
    var Bs, Eo = Et * zr, Jo = fn.internal.pageSize.getWidth(), Sc = Gt[wn];
    Ln = ze.charSpace || ya, zn = ze.maxWidth || 0, $n = Object.assign({ autoencode: !0, noBOM: !0 }, ze.flags);
    var vs = [];
    if (Object.prototype.toString.call(F) === "[object Array]") {
      var Mn;
      Tt = xa(F), vn !== "left" && (Bs = Tt.map(function(Gn) {
        return fn.getStringUnitWidth(Gn, { font: Sc, charSpace: Ln, fontSize: Et, doKerning: !1 }) * Et / Ao;
      }));
      var $r, $o = 0;
      if (vn === "right") {
        te -= Bs[0], F = [], Pi = Tt.length;
        for (var ro = 0; ro < Pi; ro++)
          ro === 0 ? ($r = qo(te), Mn = to(Ee)) : ($r = de($o - Bs[ro]), Mn = -Eo), F.push([Tt[ro], $r, Mn]), $o = Bs[ro];
      } else if (vn === "center") {
        te -= Bs[0] / 2, F = [], Pi = Tt.length;
        for (var Zr = 0; Zr < Pi; Zr++)
          Zr === 0 ? ($r = qo(te), Mn = to(Ee)) : ($r = de(($o - Bs[Zr]) / 2), Mn = -Eo), F.push([Tt[Zr], $r, Mn]), $o = Bs[Zr];
      } else if (vn === "left") {
        F = [], Pi = Tt.length;
        for (var Zo = 0; Zo < Pi; Zo++)
          F.push(Tt[Zo]);
      } else {
        if (vn !== "justify")
          throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        F = [], Pi = Tt.length, zn = zn !== 0 ? zn : Jo;
        for (var os = 0; os < Pi; os++)
          Mn = os === 0 ? to(Ee) : -Eo, $r = os === 0 ? qo(te) : 0, os < Pi - 1 ? vs.push(Le(de((zn - Bs[os]) / (Tt[os].split(" ").length - 1)))) : vs.push(0), F.push([Tt[os], $r, Mn]);
      }
    }
    var Sa = typeof ze.R2L == "boolean" ? ze.R2L : nn;
    Sa === !0 && (F = wa(F, function(Gn, ci, Zi) {
      return [Gn.split("").reverse().join(""), ci, Zi];
    })), dt = { text: F, x: te, y: Ee, options: ze, mutex: { pdfEscape: dr, activeFontKey: wn, fonts: Gt, activeFontSize: Et } }, $.publish("postProcessText", dt), F = dt.text, Zn = dt.mutex.isHex || !1;
    var al = Gt[wn].encoding;
    al !== "WinAnsiEncoding" && al !== "StandardEncoding" || (F = wa(F, function(Gn, ci, Zi) {
      return [Ul(Gn), ci, Zi];
    })), Tt = xa(F), F = [];
    for (var so, Yr, Kr, Yo = 0, Ta = 1, Ca = Array.isArray(Tt[0]) ? Ta : Yo, oo = "", Ia = function(Gn, ci, Zi) {
      var tr = "";
      return Zi instanceof Be ? (Zi = typeof ze.angle == "number" ? Ie(Zi, new Be(1, 0, 0, 1, Gn, ci)) : Ie(new Be(1, 0, 0, 1, Gn, ci), Zi), ce === J.ADVANCED && (Zi = Ie(new Be(1, 0, 0, -1, 0, 0), Zi)), tr = Zi.join(" ") + ` Tm
`) : tr = Le(Gn) + " " + Le(ci) + ` Td
`, tr;
    }, Mr = 0; Mr < Tt.length; Mr++) {
      switch (oo = "", Ca) {
        case Ta:
          Kr = (Zn ? "<" : "(") + Tt[Mr][0] + (Zn ? ">" : ")"), so = parseFloat(Tt[Mr][1]), Yr = parseFloat(Tt[Mr][2]);
          break;
        case Yo:
          Kr = (Zn ? "<" : "(") + Tt[Mr] + (Zn ? ">" : ")"), so = qo(te), Yr = to(Ee);
      }
      vs !== void 0 && vs[Mr] !== void 0 && (oo = vs[Mr] + ` Tw
`), Mr === 0 ? F.push(oo + Ia(so, Yr, $i) + Kr) : Ca === Yo ? F.push(oo + Kr) : Ca === Ta && F.push(oo + Ia(so, Yr, $i) + Kr);
    }
    F = Ca === Yo ? F.join(` Tj
T* `) : F.join(` Tj
`), F += ` Tj
`;
    var Rs = `BT
/`;
    return Rs += wn + " " + Et + ` Tf
`, Rs += Le(Et * zr) + ` TL
`, Rs += il + `
`, Rs += kn, Rs += F, re(Rs += "ET"), I[wn] = !0, fn;
  };
  var Rl = L.__private__.clip = L.clip = function(F) {
    return re(F === "evenodd" ? "W*" : "W"), this;
  };
  L.clipEvenOdd = function() {
    return Rl("evenodd");
  }, L.__private__.discardPath = L.discardPath = function() {
    return re("n"), this;
  };
  var eo = L.__private__.isValidStyle = function(F) {
    var te = !1;
    return [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(F) !== -1 && (te = !0), te;
  };
  L.__private__.setDefaultPathOperation = L.setDefaultPathOperation = function(F) {
    return eo(F) && (y = F), this;
  };
  var vc = L.__private__.getStyle = L.getStyle = function(F) {
    var te = y;
    switch (F) {
      case "D":
      case "S":
        te = "S";
        break;
      case "F":
        te = "f";
        break;
      case "FD":
      case "DF":
        te = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        te = F;
    }
    return te;
  }, vo = L.close = function() {
    return re("h"), this;
  };
  L.stroke = function() {
    return re("S"), this;
  }, L.fill = function(F) {
    return tl("f", F), this;
  }, L.fillEvenOdd = function(F) {
    return tl("f*", F), this;
  }, L.fillStroke = function(F) {
    return tl("B", F), this;
  }, L.fillStrokeEvenOdd = function(F) {
    return tl("B*", F), this;
  };
  var tl = function(F, te) {
    zi(te) === "object" ? su(te, F) : re(F);
  }, bc = function(F) {
    F === null || ce === J.ADVANCED && F === void 0 || (F = vc(F), re(F));
  };
  function Ku(F, te, Ee, ze, Je) {
    var dt = new Pd(te || this.boundingBox, Ee || this.xStep, ze || this.yStep, this.gState, Je || this.matrix);
    dt.stream = this.stream;
    var Tt = F + "$$" + this.cloneIndex++ + "$$";
    return ft(Tt, dt), dt;
  }
  var su = function(F, te) {
    var Ee = vr[F.key], ze = Nt[Ee];
    if (ze instanceof Ih)
      re("q"), re(ou(te)), ze.gState && L.setGState(ze.gState), re(F.matrix.toString() + " cm"), re("/" + Ee + " sh"), re("Q");
    else if (ze instanceof Pd) {
      var Je = new Be(1, 0, 0, -1, 0, ba());
      F.matrix && (Je = Je.multiply(F.matrix || nt), Ee = Ku.call(ze, F.key, F.boundingBox, F.xStep, F.yStep, Je).id), re("q"), re("/Pattern cs"), re("/" + Ee + " scn"), ze.gState && L.setGState(ze.gState), re(te), re("Q");
    }
  }, ou = function(F) {
    switch (F) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  }, xc = L.moveTo = function(F, te) {
    return re(Le(de(F)) + " " + Le(be(te)) + " m"), this;
  }, bo = L.lineTo = function(F, te) {
    return re(Le(de(F)) + " " + Le(be(te)) + " l"), this;
  }, xo = L.curveTo = function(F, te, Ee, ze, Je, dt) {
    return re([Le(de(F)), Le(be(te)), Le(de(Ee)), Le(be(ze)), Le(de(Je)), Le(be(dt)), "c"].join(" ")), this;
  };
  L.__private__.line = L.line = function(F, te, Ee, ze, Je) {
    if (isNaN(F) || isNaN(te) || isNaN(Ee) || isNaN(ze) || !eo(Je))
      throw new Error("Invalid arguments passed to jsPDF.line");
    return ce === J.COMPAT ? this.lines([[Ee - F, ze - te]], F, te, [1, 1], Je || "S") : this.lines([[Ee - F, ze - te]], F, te, [1, 1]).stroke();
  }, L.__private__.lines = L.lines = function(F, te, Ee, ze, Je, dt) {
    var Tt, Xt, vn, Ln, zn, $n, In, $i, fn, xr, kn, Zn;
    if (typeof F == "number" && (Zn = Ee, Ee = te, te = F, F = Zn), ze = ze || [1, 1], dt = dt || !1, isNaN(te) || isNaN(Ee) || !Array.isArray(F) || !Array.isArray(ze) || !eo(Je) || typeof dt != "boolean")
      throw new Error("Invalid arguments passed to jsPDF.lines");
    for (xc(te, Ee), Tt = ze[0], Xt = ze[1], Ln = F.length, xr = te, kn = Ee, vn = 0; vn < Ln; vn++)
      (zn = F[vn]).length === 2 ? (xr = zn[0] * Tt + xr, kn = zn[1] * Xt + kn, bo(xr, kn)) : ($n = zn[0] * Tt + xr, In = zn[1] * Xt + kn, $i = zn[2] * Tt + xr, fn = zn[3] * Xt + kn, xr = zn[4] * Tt + xr, kn = zn[5] * Xt + kn, xo($n, In, $i, fn, xr, kn));
    return dt && vo(), bc(Je), this;
  }, L.path = function(F) {
    for (var te = 0; te < F.length; te++) {
      var Ee = F[te], ze = Ee.c;
      switch (Ee.op) {
        case "m":
          xc(ze[0], ze[1]);
          break;
        case "l":
          bo(ze[0], ze[1]);
          break;
        case "c":
          xo.apply(this, ze);
          break;
        case "h":
          vo();
      }
    }
    return this;
  }, L.__private__.rect = L.rect = function(F, te, Ee, ze, Je) {
    if (isNaN(F) || isNaN(te) || isNaN(Ee) || isNaN(ze) || !eo(Je))
      throw new Error("Invalid arguments passed to jsPDF.rect");
    return ce === J.COMPAT && (ze = -ze), re([Le(de(F)), Le(be(te)), Le(de(Ee)), Le(de(ze)), "re"].join(" ")), bc(Je), this;
  }, L.__private__.triangle = L.triangle = function(F, te, Ee, ze, Je, dt, Tt) {
    if (isNaN(F) || isNaN(te) || isNaN(Ee) || isNaN(ze) || isNaN(Je) || isNaN(dt) || !eo(Tt))
      throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[Ee - F, ze - te], [Je - Ee, dt - ze], [F - Je, te - dt]], F, te, [1, 1], Tt, !0), this;
  }, L.__private__.roundedRect = L.roundedRect = function(F, te, Ee, ze, Je, dt, Tt) {
    if (isNaN(F) || isNaN(te) || isNaN(Ee) || isNaN(ze) || isNaN(Je) || isNaN(dt) || !eo(Tt))
      throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var Xt = 4 / 3 * (Math.SQRT2 - 1);
    return Je = Math.min(Je, 0.5 * Ee), dt = Math.min(dt, 0.5 * ze), this.lines([[Ee - 2 * Je, 0], [Je * Xt, 0, Je, dt - dt * Xt, Je, dt], [0, ze - 2 * dt], [0, dt * Xt, -Je * Xt, dt, -Je, dt], [2 * Je - Ee, 0], [-Je * Xt, 0, -Je, -dt * Xt, -Je, -dt], [0, 2 * dt - ze], [0, -dt * Xt, Je * Xt, -dt, Je, -dt]], F + Je, te, [1, 1], Tt, !0), this;
  }, L.__private__.ellipse = L.ellipse = function(F, te, Ee, ze, Je) {
    if (isNaN(F) || isNaN(te) || isNaN(Ee) || isNaN(ze) || !eo(Je))
      throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var dt = 4 / 3 * (Math.SQRT2 - 1) * Ee, Tt = 4 / 3 * (Math.SQRT2 - 1) * ze;
    return xc(F + Ee, te), xo(F + Ee, te - Tt, F + dt, te - ze, F, te - ze), xo(F - dt, te - ze, F - Ee, te - Tt, F - Ee, te), xo(F - Ee, te + Tt, F - dt, te + ze, F, te + ze), xo(F + dt, te + ze, F + Ee, te + Tt, F + Ee, te), bc(Je), this;
  }, L.__private__.circle = L.circle = function(F, te, Ee, ze) {
    if (isNaN(F) || isNaN(te) || isNaN(Ee) || !eo(ze))
      throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(F, te, Ee, Ee, ze);
  }, L.setFont = function(F, te, Ee) {
    return Ee && (te = De(te, Ee)), wn = ue(F, te, { disableWarning: !1 }), this;
  };
  var Ol = L.__private__.getFont = L.getFont = function() {
    return Gt[ue.apply(L, arguments)];
  };
  L.__private__.getFontList = L.getFontList = function() {
    var F, te, Ee = {};
    for (F in qn)
      if (qn.hasOwnProperty(F))
        for (te in Ee[F] = [], qn[F])
          qn[F].hasOwnProperty(te) && Ee[F].push(te);
    return Ee;
  }, L.addFont = function(F, te, Ee, ze, Je) {
    var dt = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && dt.indexOf(arguments[3]) !== -1 ? Je = arguments[3] : arguments[3] && dt.indexOf(arguments[3]) == -1 && (Ee = De(Ee, ze)), Je = Je || "Identity-H", hr.call(this, F, te, Ee, Je);
  };
  var Go, nl = n.lineWidth || 0.200025, Jr = L.__private__.getLineWidth = L.getLineWidth = function() {
    return nl;
  }, Fl = L.__private__.setLineWidth = L.setLineWidth = function(F) {
    return nl = F, re(Le(de(F)) + " w"), this;
  };
  L.__private__.setLineDash = Bn.API.setLineDash = Bn.API.setLineDashPattern = function(F, te) {
    if (F = F || [], te = te || 0, isNaN(te) || !Array.isArray(F))
      throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return F = F.map(function(Ee) {
      return Le(de(Ee));
    }).join(" "), te = Le(de(te)), re("[" + F + "] " + te + " d"), this;
  };
  var Vo = L.__private__.getLineHeight = L.getLineHeight = function() {
    return Et * Go;
  };
  L.__private__.getLineHeight = L.getLineHeight = function() {
    return Et * Go;
  };
  var Hn = L.__private__.setLineHeightFactor = L.setLineHeightFactor = function(F) {
    return typeof (F = F || 1.15) == "number" && (Go = F), this;
  }, _a = L.__private__.getLineHeightFactor = L.getLineHeightFactor = function() {
    return Go;
  };
  Hn(n.lineHeight);
  var qo = L.__private__.getHorizontalCoordinate = function(F) {
    return de(F);
  }, to = L.__private__.getVerticalCoordinate = function(F) {
    return ce === J.ADVANCED ? F : X[Ae].mediaBox.topRightY - X[Ae].mediaBox.bottomLeftY - de(F);
  }, Qu = L.__private__.getHorizontalCoordinateString = L.getHorizontalCoordinateString = function(F) {
    return Le(qo(F));
  }, ys = L.__private__.getVerticalCoordinateString = L.getVerticalCoordinateString = function(F) {
    return Le(to(F));
  }, no = n.strokeColor || "0 G";
  L.__private__.getStrokeColor = L.getDrawColor = function() {
    return an(no);
  }, L.__private__.setStrokeColor = L.setDrawColor = function(F, te, Ee, ze) {
    return no = Fn({ ch1: F, ch2: te, ch3: Ee, ch4: ze, pdfColorType: "draw", precision: 2 }), re(no), this;
  };
  var Dl = n.fillColor || "0 g";
  L.__private__.getFillColor = L.getFillColor = function() {
    return an(Dl);
  }, L.__private__.setFillColor = L.setFillColor = function(F, te, Ee, ze) {
    return Dl = Fn({ ch1: F, ch2: te, ch3: Ee, ch4: ze, pdfColorType: "fill", precision: 2 }), re(Dl), this;
  };
  var il = n.textColor || "0 g", au = L.__private__.getTextColor = L.getTextColor = function() {
    return an(il);
  };
  L.__private__.setTextColor = L.setTextColor = function(F, te, Ee, ze) {
    return il = Fn({ ch1: F, ch2: te, ch3: Ee, ch4: ze, pdfColorType: "text", precision: 3 }), this;
  };
  var ya = n.charSpace, lu = L.__private__.getCharSpace = L.getCharSpace = function() {
    return parseFloat(ya || 0);
  };
  L.__private__.setCharSpace = L.setCharSpace = function(F) {
    if (isNaN(F))
      throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return ya = F, this;
  };
  var kl = 0;
  L.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, L.__private__.setLineCap = L.setLineCap = function(F) {
    var te = L.CapJoinStyles[F];
    if (te === void 0)
      throw new Error("Line cap style of '" + F + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return kl = te, re(te + " J"), this;
  };
  var Nl = 0;
  L.__private__.setLineJoin = L.setLineJoin = function(F) {
    var te = L.CapJoinStyles[F];
    if (te === void 0)
      throw new Error("Line join style of '" + F + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return Nl = te, re(te + " j"), this;
  }, L.__private__.setLineMiterLimit = L.__private__.setMiterLimit = L.setLineMiterLimit = L.setMiterLimit = function(F) {
    if (F = F || 0, isNaN(F))
      throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return re(Le(de(F)) + " M"), this;
  }, L.GState = Tm, L.setGState = function(F) {
    (F = typeof F == "string" ? ii[sr[F]] : wc(null, F)).equals(or) || (re("/" + F.id + " gs"), or = F);
  };
  var wc = function(F, te) {
    if (!F || !sr[F]) {
      var Ee = !1;
      for (var ze in ii)
        if (ii.hasOwnProperty(ze) && ii[ze].equals(te)) {
          Ee = !0;
          break;
        }
      if (Ee)
        te = ii[ze];
      else {
        var Je = "GS" + (Object.keys(ii).length + 1).toString(10);
        ii[Je] = te, te.id = Je;
      }
      return F && (sr[F] = te.id), $.publish("addGState", te), te;
    }
  };
  L.addGState = function(F, te) {
    return wc(F, te), this;
  }, L.saveGraphicsState = function() {
    return re("q"), er.push({ key: wn, size: Et, color: il }), this;
  }, L.restoreGraphicsState = function() {
    re("Q");
    var F = er.pop();
    return wn = F.key, Et = F.size, il = F.color, or = null, this;
  }, L.setCurrentTransformationMatrix = function(F) {
    return re(F.toString() + " cm"), this;
  }, L.comment = function(F) {
    return re("#" + F), this;
  };
  var Ps = function(F, te) {
    var Ee = F || 0;
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return Ee;
    }, set: function(dt) {
      isNaN(dt) || (Ee = parseFloat(dt));
    } });
    var ze = te || 0;
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return ze;
    }, set: function(dt) {
      isNaN(dt) || (ze = parseFloat(dt));
    } });
    var Je = "pt";
    return Object.defineProperty(this, "type", { enumerable: !0, get: function() {
      return Je;
    }, set: function(dt) {
      Je = dt.toString();
    } }), this;
  }, zl = function(F, te, Ee, ze) {
    Ps.call(this, F, te), this.type = "rect";
    var Je = Ee || 0;
    Object.defineProperty(this, "w", { enumerable: !0, get: function() {
      return Je;
    }, set: function(Tt) {
      isNaN(Tt) || (Je = parseFloat(Tt));
    } });
    var dt = ze || 0;
    return Object.defineProperty(this, "h", { enumerable: !0, get: function() {
      return dt;
    }, set: function(Tt) {
      isNaN(Tt) || (dt = parseFloat(Tt));
    } }), this;
  }, Ac = function() {
    this.page = ve, this.currentPage = Ae, this.pages = It.slice(0), this.pagesContext = X.slice(0), this.x = bi, this.y = _t, this.matrix = bn, this.width = rl(Ae), this.height = ba(Ae), this.outputDestination = kt, this.id = "", this.objectNumber = -1;
  };
  Ac.prototype.restore = function() {
    ve = this.page, Ae = this.currentPage, X = this.pagesContext, It = this.pages, bi = this.x, _t = this.y, bn = this.matrix, va(Ae, this.width), Ec(Ae, this.height), kt = this.outputDestination;
  };
  var cu = function(F, te, Ee, ze, Je) {
    je.push(new Ac()), ve = Ae = 0, It = [], bi = F, _t = te, bn = Je, Xr([Ee, ze]);
  }, uu = function(F) {
    if (Oe[F])
      je.pop().restore();
    else {
      var te = new Ac(), Ee = "Xo" + (Object.keys(_e).length + 1).toString(10);
      te.id = Ee, Oe[F] = Ee, _e[Ee] = te, $.publish("addFormObject", te), je.pop().restore();
    }
  };
  for (var wo in L.beginFormObject = function(F, te, Ee, ze, Je) {
    return cu(F, te, Ee, ze, Je), this;
  }, L.endFormObject = function(F) {
    return uu(F), this;
  }, L.doFormObject = function(F, te) {
    var Ee = _e[Oe[F]];
    return re("q"), re(te.toString() + " cm"), re("/" + Ee.id + " Do"), re("Q"), this;
  }, L.getFormObject = function(F) {
    var te = _e[Oe[F]];
    return { x: te.x, y: te.y, width: te.width, height: te.height, matrix: te.matrix };
  }, L.save = function(F, te) {
    return F = F || "generated.pdf", (te = te || {}).returnPromise = te.returnPromise || !1, te.returnPromise === !1 ? (Sh(Fi(Pn()), F), typeof Sh.unload == "function" && Rn.setTimeout && setTimeout(Sh.unload, 911), this) : new Promise(function(Ee, ze) {
      try {
        var Je = Sh(Fi(Pn()), F);
        typeof Sh.unload == "function" && Rn.setTimeout && setTimeout(Sh.unload, 911), Ee(Je);
      } catch (dt) {
        ze(dt.message);
      }
    });
  }, Bn.API)
    Bn.API.hasOwnProperty(wo) && (wo === "events" && Bn.API.events.length ? function(F, te) {
      var Ee, ze, Je;
      for (Je = te.length - 1; Je !== -1; Je--)
        Ee = te[Je][0], ze = te[Je][1], F.subscribe.apply(F, [Ee].concat(typeof ze == "function" ? [ze] : ze));
    }($, Bn.API.events) : L[wo] = Bn.API[wo]);
  var rl = L.getPageWidth = function(F) {
    return (X[F = F || Ae].mediaBox.topRightX - X[F].mediaBox.bottomLeftX) / Bt;
  }, va = L.setPageWidth = function(F, te) {
    X[F].mediaBox.topRightX = te * Bt + X[F].mediaBox.bottomLeftX;
  }, ba = L.getPageHeight = function(F) {
    return (X[F = F || Ae].mediaBox.topRightY - X[F].mediaBox.bottomLeftY) / Bt;
  }, Ec = L.setPageHeight = function(F, te) {
    X[F].mediaBox.topRightY = te * Bt + X[F].mediaBox.bottomLeftY;
  };
  return L.internal = { pdfEscape: dr, getStyle: vc, getFont: Ol, getFontSize: Ft, getCharSpace: lu, getTextColor: au, getLineHeight: Vo, getLineHeightFactor: _a, getLineWidth: Jr, write: mn, getHorizontalCoordinate: qo, getVerticalCoordinate: to, getCoordinateString: Qu, getVerticalCoordinateString: ys, collections: {}, newObject: Xe, newAdditionalObject: Kt, newObjectDeferred: xt, newObjectDeferredBegin: $t, getFilters: Yn, putStream: Kn, events: $, scaleFactor: Bt, pageSize: { getWidth: function() {
    return rl(Ae);
  }, setWidth: function(F) {
    va(Ae, F);
  }, getHeight: function() {
    return ba(Ae);
  }, setHeight: function(F) {
    Ec(Ae, F);
  } }, encryptionOptions: A, encryption: ti, getEncryptor: Qa, output: Di, getNumberOfPages: jo, pages: It, out: re, f2: Fe, f3: ae, getPageInfo: Nr, getPageInfoByObjId: yn, getCurrentPageInfo: el, getPDFVersion: z, Point: Ps, Rectangle: zl, Matrix: Be, hasHotfix: fr }, Object.defineProperty(L.internal.pageSize, "width", { get: function() {
    return rl(Ae);
  }, set: function(F) {
    va(Ae, F);
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(L.internal.pageSize, "height", { get: function() {
    return ba(Ae);
  }, set: function(F) {
    Ec(Ae, F);
  }, enumerable: !0, configurable: !0 }), Qs.call(L, pt), wn = "F1", jn(r, t), $.publish("initialized"), L;
}
wd.prototype.lsbFirstWord = function(n) {
  return String.fromCharCode(n >> 0 & 255, n >> 8 & 255, n >> 16 & 255, n >> 24 & 255);
}, wd.prototype.toHexString = function(n) {
  return n.split("").map(function(e) {
    return ("0" + (255 & e.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, wd.prototype.hexToBytes = function(n) {
  for (var e = [], t = 0; t < n.length; t += 2)
    e.push(String.fromCharCode(parseInt(n.substr(t, 2), 16)));
  return e.join("");
}, wd.prototype.processOwnerPassword = function(n, e) {
  return Zy($y(e).substr(0, 5), n);
}, wd.prototype.encryptor = function(n, e) {
  var t = $y(this.encryptionKey + String.fromCharCode(255 & n, n >> 8 & 255, n >> 16 & 255, 255 & e, e >> 8 & 255)).substr(0, 10);
  return function(i) {
    return Zy(t, i);
  };
}, Tm.prototype.equals = function(n) {
  var e, t = "id,objectNumber,equals";
  if (!n || zi(n) !== zi(this))
    return !1;
  var i = 0;
  for (e in this)
    if (!(t.indexOf(e) >= 0)) {
      if (this.hasOwnProperty(e) && !n.hasOwnProperty(e) || this[e] !== n[e])
        return !1;
      i++;
    }
  for (e in n)
    n.hasOwnProperty(e) && t.indexOf(e) < 0 && i--;
  return i === 0;
}, Bn.API = { events: [] }, Bn.version = "2.5.1";
var Cr = Bn.API, Sv = 1, Hh = function(n) {
  return n.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
}, yd = function(n) {
  return n.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}, Vn = function(n) {
  return n.toFixed(2);
}, zu = function(n) {
  return n.toFixed(5);
};
Cr.__acroform__ = {};
var ko = function(n, e) {
  n.prototype = Object.create(e.prototype), n.prototype.constructor = n;
}, OA = function(n) {
  return n * Sv;
}, ac = function(n) {
  var e = new vT(), t = un.internal.getHeight(n) || 0, i = un.internal.getWidth(n) || 0;
  return e.BBox = [0, 0, Number(Vn(i)), Number(Vn(t))], e;
}, YG = Cr.__acroform__.setBit = function(n, e) {
  if (n = n || 0, e = e || 0, isNaN(n) || isNaN(e))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return n |= 1 << e;
}, KG = Cr.__acroform__.clearBit = function(n, e) {
  if (n = n || 0, e = e || 0, isNaN(n) || isNaN(e))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return n &= ~(1 << e);
}, QG = Cr.__acroform__.getBit = function(n, e) {
  if (isNaN(n) || isNaN(e))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return n & 1 << e ? 1 : 0;
}, Fr = Cr.__acroform__.getBitForPdf = function(n, e) {
  if (isNaN(n) || isNaN(e))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return QG(n, e - 1);
}, Dr = Cr.__acroform__.setBitForPdf = function(n, e) {
  if (isNaN(n) || isNaN(e))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return YG(n, e - 1);
}, kr = Cr.__acroform__.clearBitForPdf = function(n, e) {
  if (isNaN(n) || isNaN(e))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return KG(n, e - 1);
}, eV = Cr.__acroform__.calculateCoordinates = function(n, e) {
  var t = e.internal.getHorizontalCoordinate, i = e.internal.getVerticalCoordinate, r = n[0], s = n[1], c = n[2], l = n[3], m = {};
  return m.lowerLeft_X = t(r) || 0, m.lowerLeft_Y = i(s + l) || 0, m.upperRight_X = t(r + c) || 0, m.upperRight_Y = i(s) || 0, [Number(Vn(m.lowerLeft_X)), Number(Vn(m.lowerLeft_Y)), Number(Vn(m.upperRight_X)), Number(Vn(m.upperRight_Y))];
}, tV = function(n) {
  if (n.appearanceStreamContent)
    return n.appearanceStreamContent;
  if (n.V || n.DV) {
    var e = [], t = n._V || n.DV, i = Yy(n, t), r = n.scope.internal.getFont(n.fontName, n.fontStyle).id;
    e.push("/Tx BMC"), e.push("q"), e.push("BT"), e.push(n.scope.__private__.encodeColorString(n.color)), e.push("/" + r + " " + Vn(i.fontSize) + " Tf"), e.push("1 0 0 1 0 0 Tm"), e.push(i.text), e.push("ET"), e.push("Q"), e.push("EMC");
    var s = ac(n);
    return s.scope = n.scope, s.stream = e.join(`
`), s;
  }
}, Yy = function(n, e) {
  var t = n.fontSize === 0 ? n.maxFontSize : n.fontSize, i = { text: "", fontSize: "" }, r = (e = (e = e.substr(0, 1) == "(" ? e.substr(1) : e).substr(e.length - 1) == ")" ? e.substr(0, e.length - 1) : e).split(" ");
  r = n.multiline ? r.map(function(ae) {
    return ae.split(`
`);
  }) : r.map(function(ae) {
    return [ae];
  });
  var s = t, c = un.internal.getHeight(n) || 0;
  c = c < 0 ? -c : c;
  var l = un.internal.getWidth(n) || 0;
  l = l < 0 ? -l : l;
  var m = function(ae, de, Te) {
    if (ae + 1 < r.length) {
      var be = de + " " + r[ae + 1][0];
      return kg(be, n, Te).width <= l - 4;
    }
    return !1;
  };
  s++;
  e:
    for (; s > 0; ) {
      e = "", s--;
      var y, A, T = kg("3", n, s).height, I = n.multiline ? c - s : (c - T) / 2, L = I += 2, N = 0, z = 0, V = 0;
      if (s <= 0) {
        e = `(...) Tj
`, e += "% Width of Text: " + kg(e, n, s = 12).width + ", FieldWidth:" + l + `
`;
        break;
      }
      for (var H = "", J = 0, ce = 0; ce < r.length; ce++)
        if (r.hasOwnProperty(ce)) {
          var me = !1;
          if (r[ce].length !== 1 && V !== r[ce].length - 1) {
            if ((T + 2) * (J + 2) + 2 > c)
              continue e;
            H += r[ce][V], me = !0, z = ce, ce--;
          } else {
            H = (H += r[ce][V] + " ").substr(H.length - 1) == " " ? H.substr(0, H.length - 1) : H;
            var Se = parseInt(ce), De = m(Se, H, s), Le = ce >= r.length - 1;
            if (De && !Le) {
              H += " ", V = 0;
              continue;
            }
            if (De || Le) {
              if (Le)
                z = Se;
              else if (n.multiline && (T + 2) * (J + 2) + 2 > c)
                continue e;
            } else {
              if (!n.multiline || (T + 2) * (J + 2) + 2 > c)
                continue e;
              z = Se;
            }
          }
          for (var ye = "", Ve = N; Ve <= z; Ve++) {
            var Fe = r[Ve];
            if (n.multiline) {
              if (Ve === z) {
                ye += Fe[V] + " ", V = (V + 1) % Fe.length;
                continue;
              }
              if (Ve === N) {
                ye += Fe[Fe.length - 1] + " ";
                continue;
              }
            }
            ye += Fe[0] + " ";
          }
          switch (ye = ye.substr(ye.length - 1) == " " ? ye.substr(0, ye.length - 1) : ye, A = kg(ye, n, s).width, n.textAlign) {
            case "right":
              y = l - A - 2;
              break;
            case "center":
              y = (l - A) / 2;
              break;
            case "left":
            default:
              y = 2;
          }
          e += Vn(y) + " " + Vn(L) + ` Td
`, e += "(" + Hh(ye) + `) Tj
`, e += -Vn(y) + ` 0 Td
`, L = -(s + 2), A = 0, N = me ? z : z + 1, J++, H = "";
        }
      break;
    }
  return i.text = e, i.fontSize = s, i;
}, kg = function(n, e, t) {
  var i = e.scope.internal.getFont(e.fontName, e.fontStyle), r = e.scope.getStringUnitWidth(n, { font: i, fontSize: parseFloat(t), charSpace: 0 }) * parseFloat(t);
  return { height: e.scope.getStringUnitWidth("3", { font: i, fontSize: parseFloat(t), charSpace: 0 }) * parseFloat(t) * 1.5, width: r };
}, nV = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: !1, internal: null, isInitialized: !1 }, iV = function(n, e) {
  var t = { type: "reference", object: n };
  e.internal.getPageInfo(n.page).pageContext.annotations.find(function(i) {
    return i.type === t.type && i.object === t.object;
  }) === void 0 && e.internal.getPageInfo(n.page).pageContext.annotations.push(t);
}, rV = function(n, e) {
  for (var t in n)
    if (n.hasOwnProperty(t)) {
      var i = t, r = n[t];
      e.internal.newObjectDeferredBegin(r.objId, !0), zi(r) === "object" && typeof r.putStream == "function" && r.putStream(), delete n[i];
    }
}, sV = function(n, e) {
  if (e.scope = n, n.internal !== void 0 && (n.internal.acroformPlugin === void 0 || n.internal.acroformPlugin.isInitialized === !1)) {
    if (Ml.FieldNum = 0, n.internal.acroformPlugin = JSON.parse(JSON.stringify(nV)), n.internal.acroformPlugin.acroFormDictionaryRoot)
      throw new Error("Exception while creating AcroformDictionary");
    Sv = n.internal.scaleFactor, n.internal.acroformPlugin.acroFormDictionaryRoot = new bT(), n.internal.acroformPlugin.acroFormDictionaryRoot.scope = n, n.internal.acroformPlugin.acroFormDictionaryRoot._eventID = n.internal.events.subscribe("postPutResources", function() {
      (function(t) {
        t.internal.events.unsubscribe(t.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete t.internal.acroformPlugin.acroFormDictionaryRoot._eventID, t.internal.acroformPlugin.printedOut = !0;
      })(n);
    }), n.internal.events.subscribe("buildDocument", function() {
      (function(t) {
        t.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var i = t.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var r in i)
          if (i.hasOwnProperty(r)) {
            var s = i[r];
            s.objId = void 0, s.hasAnnotation && iV(s, t);
          }
      })(n);
    }), n.internal.events.subscribe("putCatalog", function() {
      (function(t) {
        if (t.internal.acroformPlugin.acroFormDictionaryRoot === void 0)
          throw new Error("putCatalogCallback: Root missing.");
        t.internal.write("/AcroForm " + t.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      })(n);
    }), n.internal.events.subscribe("postPutPages", function(t) {
      (function(i, r) {
        var s = !i;
        for (var c in i || (r.internal.newObjectDeferredBegin(r.internal.acroformPlugin.acroFormDictionaryRoot.objId, !0), r.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), i = i || r.internal.acroformPlugin.acroFormDictionaryRoot.Kids)
          if (i.hasOwnProperty(c)) {
            var l = i[c], m = [], y = l.Rect;
            if (l.Rect && (l.Rect = eV(l.Rect, r)), r.internal.newObjectDeferredBegin(l.objId, !0), l.DA = un.createDefaultAppearanceStream(l), zi(l) === "object" && typeof l.getKeyValueListForStream == "function" && (m = l.getKeyValueListForStream()), l.Rect = y, l.hasAppearanceStream && !l.appearanceStreamContent) {
              var A = tV(l);
              m.push({ key: "AP", value: "<</N " + A + ">>" }), r.internal.acroformPlugin.xForms.push(A);
            }
            if (l.appearanceStreamContent) {
              var T = "";
              for (var I in l.appearanceStreamContent)
                if (l.appearanceStreamContent.hasOwnProperty(I)) {
                  var L = l.appearanceStreamContent[I];
                  if (T += "/" + I + " ", T += "<<", Object.keys(L).length >= 1 || Array.isArray(L)) {
                    for (var c in L)
                      if (L.hasOwnProperty(c)) {
                        var N = L[c];
                        typeof N == "function" && (N = N.call(r, l)), T += "/" + c + " " + N + " ", r.internal.acroformPlugin.xForms.indexOf(N) >= 0 || r.internal.acroformPlugin.xForms.push(N);
                      }
                  } else
                    typeof (N = L) == "function" && (N = N.call(r, l)), T += "/" + c + " " + N, r.internal.acroformPlugin.xForms.indexOf(N) >= 0 || r.internal.acroformPlugin.xForms.push(N);
                  T += ">>";
                }
              m.push({ key: "AP", value: `<<
` + T + ">>" });
            }
            r.internal.putStream({ additionalKeyValues: m, objectId: l.objId }), r.internal.out("endobj");
          }
        s && rV(r.internal.acroformPlugin.xForms, r);
      })(t, n);
    }), n.internal.acroformPlugin.isInitialized = !0;
  }
}, yT = Cr.__acroform__.arrayToPdfArray = function(n, e, t) {
  var i = function(c) {
    return c;
  };
  if (Array.isArray(n)) {
    for (var r = "[", s = 0; s < n.length; s++)
      switch (s !== 0 && (r += " "), zi(n[s])) {
        case "boolean":
        case "number":
        case "object":
          r += n[s].toString();
          break;
        case "string":
          n[s].substr(0, 1) !== "/" ? (e !== void 0 && t && (i = t.internal.getEncryptor(e)), r += "(" + Hh(i(n[s].toString())) + ")") : r += n[s].toString();
      }
    return r += "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
}, G_ = function(n, e, t) {
  var i = function(r) {
    return r;
  };
  return e !== void 0 && t && (i = t.internal.getEncryptor(e)), (n = n || "").toString(), n = "(" + Hh(i(n)) + ")";
}, fc = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (this._objId === void 0) {
      if (this.scope === void 0)
        return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(n) {
    this._objId = n;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: !0 });
};
fc.prototype.toString = function() {
  return this.objId + " 0 R";
}, fc.prototype.putStream = function() {
  var n = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: n, objectId: this.objId }), this.scope.internal.out("endobj");
}, fc.prototype.getKeyValueListForStream = function() {
  var n = [], e = Object.getOwnPropertyNames(this).filter(function(s) {
    return s != "content" && s != "appearanceStreamContent" && s != "scope" && s != "objId" && s.substring(0, 1) != "_";
  });
  for (var t in e)
    if (Object.getOwnPropertyDescriptor(this, e[t]).configurable === !1) {
      var i = e[t], r = this[i];
      r && (Array.isArray(r) ? n.push({ key: i, value: yT(r, this.objId, this.scope) }) : r instanceof fc ? (r.scope = this.scope, n.push({ key: i, value: r.objId + " 0 R" })) : typeof r != "function" && n.push({ key: i, value: r }));
    }
  return n;
};
var vT = function() {
  fc.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: !1, writable: !0 }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: !1, writable: !0 }), Object.defineProperty(this, "FormType", { value: 1, configurable: !1, writable: !0 });
  var n, e = [];
  Object.defineProperty(this, "BBox", { configurable: !1, get: function() {
    return e;
  }, set: function(t) {
    e = t;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: !1, writable: !0 }), Object.defineProperty(this, "stream", { enumerable: !1, configurable: !0, set: function(t) {
    n = t.trim();
  }, get: function() {
    return n || null;
  } });
};
ko(vT, fc);
var bT = function() {
  fc.call(this);
  var n, e = [];
  Object.defineProperty(this, "Kids", { enumerable: !1, configurable: !0, get: function() {
    return e.length > 0 ? e : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: !1, configurable: !1, get: function() {
    return e;
  } }), Object.defineProperty(this, "DA", { enumerable: !1, configurable: !1, get: function() {
    if (n) {
      var t = function(i) {
        return i;
      };
      return this.scope && (t = this.scope.internal.getEncryptor(this.objId)), "(" + Hh(t(n)) + ")";
    }
  }, set: function(t) {
    n = t;
  } });
};
ko(bT, fc);
var Ml = function n() {
  fc.call(this);
  var e = 4;
  Object.defineProperty(this, "F", { enumerable: !1, configurable: !1, get: function() {
    return e;
  }, set: function(H) {
    if (isNaN(H))
      throw new Error('Invalid value "' + H + '" for attribute F supplied.');
    e = H;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: !0, configurable: !0, get: function() {
    return !!Fr(e, 3);
  }, set: function(H) {
    H ? this.F = Dr(e, 3) : this.F = kr(e, 3);
  } });
  var t = 0;
  Object.defineProperty(this, "Ff", { enumerable: !1, configurable: !1, get: function() {
    return t;
  }, set: function(H) {
    if (isNaN(H))
      throw new Error('Invalid value "' + H + '" for attribute Ff supplied.');
    t = H;
  } });
  var i = [];
  Object.defineProperty(this, "Rect", { enumerable: !1, configurable: !1, get: function() {
    if (i.length !== 0)
      return i;
  }, set: function(H) {
    i = H !== void 0 ? H : [];
  } }), Object.defineProperty(this, "x", { enumerable: !0, configurable: !0, get: function() {
    return !i || isNaN(i[0]) ? 0 : i[0];
  }, set: function(H) {
    i[0] = H;
  } }), Object.defineProperty(this, "y", { enumerable: !0, configurable: !0, get: function() {
    return !i || isNaN(i[1]) ? 0 : i[1];
  }, set: function(H) {
    i[1] = H;
  } }), Object.defineProperty(this, "width", { enumerable: !0, configurable: !0, get: function() {
    return !i || isNaN(i[2]) ? 0 : i[2];
  }, set: function(H) {
    i[2] = H;
  } }), Object.defineProperty(this, "height", { enumerable: !0, configurable: !0, get: function() {
    return !i || isNaN(i[3]) ? 0 : i[3];
  }, set: function(H) {
    i[3] = H;
  } });
  var r = "";
  Object.defineProperty(this, "FT", { enumerable: !0, configurable: !1, get: function() {
    return r;
  }, set: function(H) {
    switch (H) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        r = H;
        break;
      default:
        throw new Error('Invalid value "' + H + '" for attribute FT supplied.');
    }
  } });
  var s = null;
  Object.defineProperty(this, "T", { enumerable: !0, configurable: !1, get: function() {
    if (!s || s.length < 1) {
      if (this instanceof Cm)
        return;
      s = "FieldObject" + n.FieldNum++;
    }
    var H = function(J) {
      return J;
    };
    return this.scope && (H = this.scope.internal.getEncryptor(this.objId)), "(" + Hh(H(s)) + ")";
  }, set: function(H) {
    s = H.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: !0, enumerable: !0, get: function() {
    return s;
  }, set: function(H) {
    s = H;
  } });
  var c = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: !0, configurable: !0, get: function() {
    return c;
  }, set: function(H) {
    c = H;
  } });
  var l = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: !0, configurable: !0, get: function() {
    return l;
  }, set: function(H) {
    l = H;
  } });
  var m = 0;
  Object.defineProperty(this, "fontSize", { enumerable: !0, configurable: !0, get: function() {
    return m;
  }, set: function(H) {
    m = H;
  } });
  var y = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: !0, configurable: !0, get: function() {
    return y === void 0 ? 50 / Sv : y;
  }, set: function(H) {
    y = H;
  } });
  var A = "black";
  Object.defineProperty(this, "color", { enumerable: !0, configurable: !0, get: function() {
    return A;
  }, set: function(H) {
    A = H;
  } });
  var T = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: !0, configurable: !1, get: function() {
    if (!(!T || this instanceof Cm || this instanceof Fh))
      return G_(T, this.objId, this.scope);
  }, set: function(H) {
    H = H.toString(), T = H;
  } });
  var I = null;
  Object.defineProperty(this, "DV", { enumerable: !1, configurable: !1, get: function() {
    if (I)
      return this instanceof ps ? I : G_(I, this.objId, this.scope);
  }, set: function(H) {
    H = H.toString(), I = this instanceof ps ? H : H.substr(0, 1) === "(" ? yd(H.substr(1, H.length - 2)) : yd(H);
  } }), Object.defineProperty(this, "defaultValue", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof ps ? yd(I.substr(1, I.length - 1)) : I;
  }, set: function(H) {
    H = H.toString(), I = this instanceof ps ? "/" + H : H;
  } });
  var L = null;
  Object.defineProperty(this, "_V", { enumerable: !1, configurable: !1, get: function() {
    if (L)
      return L;
  }, set: function(H) {
    this.V = H;
  } }), Object.defineProperty(this, "V", { enumerable: !1, configurable: !1, get: function() {
    if (L)
      return this instanceof ps ? L : G_(L, this.objId, this.scope);
  }, set: function(H) {
    H = H.toString(), L = this instanceof ps ? H : H.substr(0, 1) === "(" ? yd(H.substr(1, H.length - 2)) : yd(H);
  } }), Object.defineProperty(this, "value", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof ps ? yd(L.substr(1, L.length - 1)) : L;
  }, set: function(H) {
    H = H.toString(), L = this instanceof ps ? "/" + H : H;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: !0, configurable: !0, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var N, z = !1;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return z;
  }, set: function(H) {
    H = !!H, z = H;
  } }), Object.defineProperty(this, "page", { enumerable: !0, configurable: !0, get: function() {
    if (N)
      return N;
  }, set: function(H) {
    N = H;
  } }), Object.defineProperty(this, "readOnly", { enumerable: !0, configurable: !0, get: function() {
    return !!Fr(this.Ff, 1);
  }, set: function(H) {
    H ? this.Ff = Dr(this.Ff, 1) : this.Ff = kr(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: !0, configurable: !0, get: function() {
    return !!Fr(this.Ff, 2);
  }, set: function(H) {
    H ? this.Ff = Dr(this.Ff, 2) : this.Ff = kr(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: !0, configurable: !0, get: function() {
    return !!Fr(this.Ff, 3);
  }, set: function(H) {
    H ? this.Ff = Dr(this.Ff, 3) : this.Ff = kr(this.Ff, 3);
  } });
  var V = null;
  Object.defineProperty(this, "Q", { enumerable: !0, configurable: !1, get: function() {
    if (V !== null)
      return V;
  }, set: function(H) {
    if ([0, 1, 2].indexOf(H) === -1)
      throw new Error('Invalid value "' + H + '" for attribute Q supplied.');
    V = H;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var H;
    switch (V) {
      case 0:
      default:
        H = "left";
        break;
      case 1:
        H = "center";
        break;
      case 2:
        H = "right";
    }
    return H;
  }, configurable: !0, enumerable: !0, set: function(H) {
    switch (H) {
      case "right":
      case 2:
        V = 2;
        break;
      case "center":
      case 1:
        V = 1;
        break;
      case "left":
      case 0:
      default:
        V = 0;
    }
  } });
};
ko(Ml, fc);
var Fd = function() {
  Ml.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var n = 0;
  Object.defineProperty(this, "TI", { enumerable: !0, configurable: !1, get: function() {
    return n;
  }, set: function(t) {
    n = t;
  } }), Object.defineProperty(this, "topIndex", { enumerable: !0, configurable: !0, get: function() {
    return n;
  }, set: function(t) {
    n = t;
  } });
  var e = [];
  Object.defineProperty(this, "Opt", { enumerable: !0, configurable: !1, get: function() {
    return yT(e, this.objId, this.scope);
  }, set: function(t) {
    var i, r;
    r = [], typeof (i = t) == "string" && (r = function(s, c, l) {
      l || (l = 1);
      for (var m, y = []; m = c.exec(s); )
        y.push(m[l]);
      return y;
    }(i, /\((.*?)\)/g)), e = r;
  } }), this.getOptions = function() {
    return e;
  }, this.setOptions = function(t) {
    e = t, this.sort && e.sort();
  }, this.addOption = function(t) {
    t = (t = t || "").toString(), e.push(t), this.sort && e.sort();
  }, this.removeOption = function(t, i) {
    for (i = i || !1, t = (t = t || "").toString(); e.indexOf(t) !== -1 && (e.splice(e.indexOf(t), 1), i !== !1); )
      ;
  }, Object.defineProperty(this, "combo", { enumerable: !0, configurable: !0, get: function() {
    return !!Fr(this.Ff, 18);
  }, set: function(t) {
    t ? this.Ff = Dr(this.Ff, 18) : this.Ff = kr(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: !0, configurable: !0, get: function() {
    return !!Fr(this.Ff, 19);
  }, set: function(t) {
    this.combo === !0 && (t ? this.Ff = Dr(this.Ff, 19) : this.Ff = kr(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: !0, configurable: !0, get: function() {
    return !!Fr(this.Ff, 20);
  }, set: function(t) {
    t ? (this.Ff = Dr(this.Ff, 20), e.sort()) : this.Ff = kr(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!Fr(this.Ff, 22);
  }, set: function(t) {
    t ? this.Ff = Dr(this.Ff, 22) : this.Ff = kr(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!Fr(this.Ff, 23);
  }, set: function(t) {
    t ? this.Ff = Dr(this.Ff, 23) : this.Ff = kr(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: !0, configurable: !0, get: function() {
    return !!Fr(this.Ff, 27);
  }, set: function(t) {
    t ? this.Ff = Dr(this.Ff, 27) : this.Ff = kr(this.Ff, 27);
  } }), this.hasAppearanceStream = !1;
};
ko(Fd, Ml);
var Dd = function() {
  Fd.call(this), this.fontName = "helvetica", this.combo = !1;
};
ko(Dd, Fd);
var kd = function() {
  Dd.call(this), this.combo = !0;
};
ko(kd, Dd);
var Kg = function() {
  kd.call(this), this.edit = !0;
};
ko(Kg, kd);
var ps = function() {
  Ml.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: !0, configurable: !0, get: function() {
    return !!Fr(this.Ff, 15);
  }, set: function(t) {
    t ? this.Ff = Dr(this.Ff, 15) : this.Ff = kr(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: !0, configurable: !0, get: function() {
    return !!Fr(this.Ff, 16);
  }, set: function(t) {
    t ? this.Ff = Dr(this.Ff, 16) : this.Ff = kr(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: !0, configurable: !0, get: function() {
    return !!Fr(this.Ff, 17);
  }, set: function(t) {
    t ? this.Ff = Dr(this.Ff, 17) : this.Ff = kr(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: !0, configurable: !0, get: function() {
    return !!Fr(this.Ff, 26);
  }, set: function(t) {
    t ? this.Ff = Dr(this.Ff, 26) : this.Ff = kr(this.Ff, 26);
  } });
  var n, e = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var t = function(s) {
      return s;
    };
    if (this.scope && (t = this.scope.internal.getEncryptor(this.objId)), Object.keys(e).length !== 0) {
      var i, r = [];
      for (i in r.push("<<"), e)
        r.push("/" + i + " (" + Hh(t(e[i])) + ")");
      return r.push(">>"), r.join(`
`);
    }
  }, set: function(t) {
    zi(t) === "object" && (e = t);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return e.CA || "";
  }, set: function(t) {
    typeof t == "string" && (e.CA = t);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return n;
  }, set: function(t) {
    n = t;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return n.substr(1, n.length - 1);
  }, set: function(t) {
    n = "/" + t;
  } });
};
ko(ps, Ml);
var Qg = function() {
  ps.call(this), this.pushButton = !0;
};
ko(Qg, ps);
var Nd = function() {
  ps.call(this), this.radio = !0, this.pushButton = !1;
  var n = [];
  Object.defineProperty(this, "Kids", { enumerable: !0, configurable: !1, get: function() {
    return n;
  }, set: function(e) {
    n = e !== void 0 ? e : [];
  } });
};
ko(Nd, ps);
var Cm = function() {
  var n, e;
  Ml.call(this), Object.defineProperty(this, "Parent", { enumerable: !1, configurable: !1, get: function() {
    return n;
  }, set: function(r) {
    n = r;
  } }), Object.defineProperty(this, "optionName", { enumerable: !1, configurable: !0, get: function() {
    return e;
  }, set: function(r) {
    e = r;
  } });
  var t, i = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var r = function(l) {
      return l;
    };
    this.scope && (r = this.scope.internal.getEncryptor(this.objId));
    var s, c = [];
    for (s in c.push("<<"), i)
      c.push("/" + s + " (" + Hh(r(i[s])) + ")");
    return c.push(">>"), c.join(`
`);
  }, set: function(r) {
    zi(r) === "object" && (i = r);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return i.CA || "";
  }, set: function(r) {
    typeof r == "string" && (i.CA = r);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return t;
  }, set: function(r) {
    t = r;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return t.substr(1, t.length - 1);
  }, set: function(r) {
    t = "/" + r;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = un.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
ko(Cm, Ml), Nd.prototype.setAppearance = function(n) {
  if (!("createAppearanceStream" in n) || !("getCA" in n))
    throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var e in this.Kids)
    if (this.Kids.hasOwnProperty(e)) {
      var t = this.Kids[e];
      t.appearanceStreamContent = n.createAppearanceStream(t.optionName), t.caption = n.getCA();
    }
}, Nd.prototype.createOption = function(n) {
  var e = new Cm();
  return e.Parent = this, e.optionName = n, this.Kids.push(e), oV.call(this.scope, e), e;
};
var em = function() {
  ps.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = un.CheckBox.createAppearanceStream();
};
ko(em, ps);
var Fh = function() {
  Ml.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: !0, configurable: !0, get: function() {
    return !!Fr(this.Ff, 13);
  }, set: function(e) {
    e ? this.Ff = Dr(this.Ff, 13) : this.Ff = kr(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!Fr(this.Ff, 21);
  }, set: function(e) {
    e ? this.Ff = Dr(this.Ff, 21) : this.Ff = kr(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!Fr(this.Ff, 23);
  }, set: function(e) {
    e ? this.Ff = Dr(this.Ff, 23) : this.Ff = kr(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: !0, configurable: !0, get: function() {
    return !!Fr(this.Ff, 24);
  }, set: function(e) {
    e ? this.Ff = Dr(this.Ff, 24) : this.Ff = kr(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: !0, configurable: !0, get: function() {
    return !!Fr(this.Ff, 25);
  }, set: function(e) {
    e ? this.Ff = Dr(this.Ff, 25) : this.Ff = kr(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: !0, configurable: !0, get: function() {
    return !!Fr(this.Ff, 26);
  }, set: function(e) {
    e ? this.Ff = Dr(this.Ff, 26) : this.Ff = kr(this.Ff, 26);
  } });
  var n = null;
  Object.defineProperty(this, "MaxLen", { enumerable: !0, configurable: !1, get: function() {
    return n;
  }, set: function(e) {
    n = e;
  } }), Object.defineProperty(this, "maxLength", { enumerable: !0, configurable: !0, get: function() {
    return n;
  }, set: function(e) {
    Number.isInteger(e) && (n = e);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return this.V || this.DV;
  } });
};
ko(Fh, Ml);
var tm = function() {
  Fh.call(this), Object.defineProperty(this, "password", { enumerable: !0, configurable: !0, get: function() {
    return !!Fr(this.Ff, 14);
  }, set: function(n) {
    n ? this.Ff = Dr(this.Ff, 14) : this.Ff = kr(this.Ff, 14);
  } }), this.password = !0;
};
ko(tm, Fh);
var un = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: un.CheckBox.YesNormal }, D: { On: un.CheckBox.YesPushDown, Off: un.CheckBox.OffPushDown } };
}, YesPushDown: function(n) {
  var e = ac(n);
  e.scope = n.scope;
  var t = [], i = n.scope.internal.getFont(n.fontName, n.fontStyle).id, r = n.scope.__private__.encodeColorString(n.color), s = Yy(n, n.caption);
  return t.push("0.749023 g"), t.push("0 0 " + Vn(un.internal.getWidth(n)) + " " + Vn(un.internal.getHeight(n)) + " re"), t.push("f"), t.push("BMC"), t.push("q"), t.push("0 0 1 rg"), t.push("/" + i + " " + Vn(s.fontSize) + " Tf " + r), t.push("BT"), t.push(s.text), t.push("ET"), t.push("Q"), t.push("EMC"), e.stream = t.join(`
`), e;
}, YesNormal: function(n) {
  var e = ac(n);
  e.scope = n.scope;
  var t = n.scope.internal.getFont(n.fontName, n.fontStyle).id, i = n.scope.__private__.encodeColorString(n.color), r = [], s = un.internal.getHeight(n), c = un.internal.getWidth(n), l = Yy(n, n.caption);
  return r.push("1 g"), r.push("0 0 " + Vn(c) + " " + Vn(s) + " re"), r.push("f"), r.push("q"), r.push("0 0 1 rg"), r.push("0 0 " + Vn(c - 1) + " " + Vn(s - 1) + " re"), r.push("W"), r.push("n"), r.push("0 g"), r.push("BT"), r.push("/" + t + " " + Vn(l.fontSize) + " Tf " + i), r.push(l.text), r.push("ET"), r.push("Q"), e.stream = r.join(`
`), e;
}, OffPushDown: function(n) {
  var e = ac(n);
  e.scope = n.scope;
  var t = [];
  return t.push("0.749023 g"), t.push("0 0 " + Vn(un.internal.getWidth(n)) + " " + Vn(un.internal.getHeight(n)) + " re"), t.push("f"), e.stream = t.join(`
`), e;
} }, RadioButton: { Circle: { createAppearanceStream: function(n) {
  var e = { D: { Off: un.RadioButton.Circle.OffPushDown }, N: {} };
  return e.N[n] = un.RadioButton.Circle.YesNormal, e.D[n] = un.RadioButton.Circle.YesPushDown, e;
}, getCA: function() {
  return "l";
}, YesNormal: function(n) {
  var e = ac(n);
  e.scope = n.scope;
  var t = [], i = un.internal.getWidth(n) <= un.internal.getHeight(n) ? un.internal.getWidth(n) / 4 : un.internal.getHeight(n) / 4;
  i = Number((0.9 * i).toFixed(5));
  var r = un.internal.Bezier_C, s = Number((i * r).toFixed(5));
  return t.push("q"), t.push("1 0 0 1 " + zu(un.internal.getWidth(n) / 2) + " " + zu(un.internal.getHeight(n) / 2) + " cm"), t.push(i + " 0 m"), t.push(i + " " + s + " " + s + " " + i + " 0 " + i + " c"), t.push("-" + s + " " + i + " -" + i + " " + s + " -" + i + " 0 c"), t.push("-" + i + " -" + s + " -" + s + " -" + i + " 0 -" + i + " c"), t.push(s + " -" + i + " " + i + " -" + s + " " + i + " 0 c"), t.push("f"), t.push("Q"), e.stream = t.join(`
`), e;
}, YesPushDown: function(n) {
  var e = ac(n);
  e.scope = n.scope;
  var t = [], i = un.internal.getWidth(n) <= un.internal.getHeight(n) ? un.internal.getWidth(n) / 4 : un.internal.getHeight(n) / 4;
  i = Number((0.9 * i).toFixed(5));
  var r = Number((2 * i).toFixed(5)), s = Number((r * un.internal.Bezier_C).toFixed(5)), c = Number((i * un.internal.Bezier_C).toFixed(5));
  return t.push("0.749023 g"), t.push("q"), t.push("1 0 0 1 " + zu(un.internal.getWidth(n) / 2) + " " + zu(un.internal.getHeight(n) / 2) + " cm"), t.push(r + " 0 m"), t.push(r + " " + s + " " + s + " " + r + " 0 " + r + " c"), t.push("-" + s + " " + r + " -" + r + " " + s + " -" + r + " 0 c"), t.push("-" + r + " -" + s + " -" + s + " -" + r + " 0 -" + r + " c"), t.push(s + " -" + r + " " + r + " -" + s + " " + r + " 0 c"), t.push("f"), t.push("Q"), t.push("0 g"), t.push("q"), t.push("1 0 0 1 " + zu(un.internal.getWidth(n) / 2) + " " + zu(un.internal.getHeight(n) / 2) + " cm"), t.push(i + " 0 m"), t.push(i + " " + c + " " + c + " " + i + " 0 " + i + " c"), t.push("-" + c + " " + i + " -" + i + " " + c + " -" + i + " 0 c"), t.push("-" + i + " -" + c + " -" + c + " -" + i + " 0 -" + i + " c"), t.push(c + " -" + i + " " + i + " -" + c + " " + i + " 0 c"), t.push("f"), t.push("Q"), e.stream = t.join(`
`), e;
}, OffPushDown: function(n) {
  var e = ac(n);
  e.scope = n.scope;
  var t = [], i = un.internal.getWidth(n) <= un.internal.getHeight(n) ? un.internal.getWidth(n) / 4 : un.internal.getHeight(n) / 4;
  i = Number((0.9 * i).toFixed(5));
  var r = Number((2 * i).toFixed(5)), s = Number((r * un.internal.Bezier_C).toFixed(5));
  return t.push("0.749023 g"), t.push("q"), t.push("1 0 0 1 " + zu(un.internal.getWidth(n) / 2) + " " + zu(un.internal.getHeight(n) / 2) + " cm"), t.push(r + " 0 m"), t.push(r + " " + s + " " + s + " " + r + " 0 " + r + " c"), t.push("-" + s + " " + r + " -" + r + " " + s + " -" + r + " 0 c"), t.push("-" + r + " -" + s + " -" + s + " -" + r + " 0 -" + r + " c"), t.push(s + " -" + r + " " + r + " -" + s + " " + r + " 0 c"), t.push("f"), t.push("Q"), e.stream = t.join(`
`), e;
} }, Cross: { createAppearanceStream: function(n) {
  var e = { D: { Off: un.RadioButton.Cross.OffPushDown }, N: {} };
  return e.N[n] = un.RadioButton.Cross.YesNormal, e.D[n] = un.RadioButton.Cross.YesPushDown, e;
}, getCA: function() {
  return "8";
}, YesNormal: function(n) {
  var e = ac(n);
  e.scope = n.scope;
  var t = [], i = un.internal.calculateCross(n);
  return t.push("q"), t.push("1 1 " + Vn(un.internal.getWidth(n) - 2) + " " + Vn(un.internal.getHeight(n) - 2) + " re"), t.push("W"), t.push("n"), t.push(Vn(i.x1.x) + " " + Vn(i.x1.y) + " m"), t.push(Vn(i.x2.x) + " " + Vn(i.x2.y) + " l"), t.push(Vn(i.x4.x) + " " + Vn(i.x4.y) + " m"), t.push(Vn(i.x3.x) + " " + Vn(i.x3.y) + " l"), t.push("s"), t.push("Q"), e.stream = t.join(`
`), e;
}, YesPushDown: function(n) {
  var e = ac(n);
  e.scope = n.scope;
  var t = un.internal.calculateCross(n), i = [];
  return i.push("0.749023 g"), i.push("0 0 " + Vn(un.internal.getWidth(n)) + " " + Vn(un.internal.getHeight(n)) + " re"), i.push("f"), i.push("q"), i.push("1 1 " + Vn(un.internal.getWidth(n) - 2) + " " + Vn(un.internal.getHeight(n) - 2) + " re"), i.push("W"), i.push("n"), i.push(Vn(t.x1.x) + " " + Vn(t.x1.y) + " m"), i.push(Vn(t.x2.x) + " " + Vn(t.x2.y) + " l"), i.push(Vn(t.x4.x) + " " + Vn(t.x4.y) + " m"), i.push(Vn(t.x3.x) + " " + Vn(t.x3.y) + " l"), i.push("s"), i.push("Q"), e.stream = i.join(`
`), e;
}, OffPushDown: function(n) {
  var e = ac(n);
  e.scope = n.scope;
  var t = [];
  return t.push("0.749023 g"), t.push("0 0 " + Vn(un.internal.getWidth(n)) + " " + Vn(un.internal.getHeight(n)) + " re"), t.push("f"), e.stream = t.join(`
`), e;
} } }, createDefaultAppearanceStream: function(n) {
  var e = n.scope.internal.getFont(n.fontName, n.fontStyle).id, t = n.scope.__private__.encodeColorString(n.color);
  return "/" + e + " " + n.fontSize + " Tf " + t;
} };
un.internal = { Bezier_C: 0.551915024494, calculateCross: function(n) {
  var e = un.internal.getWidth(n), t = un.internal.getHeight(n), i = Math.min(e, t);
  return { x1: { x: (e - i) / 2, y: (t - i) / 2 + i }, x2: { x: (e - i) / 2 + i, y: (t - i) / 2 }, x3: { x: (e - i) / 2, y: (t - i) / 2 }, x4: { x: (e - i) / 2 + i, y: (t - i) / 2 + i } };
} }, un.internal.getWidth = function(n) {
  var e = 0;
  return zi(n) === "object" && (e = OA(n.Rect[2])), e;
}, un.internal.getHeight = function(n) {
  var e = 0;
  return zi(n) === "object" && (e = OA(n.Rect[3])), e;
};
var oV = Cr.addField = function(n) {
  if (sV(this, n), !(n instanceof Ml))
    throw new Error("Invalid argument passed to jsPDF.addField.");
  var e;
  return (e = n).scope.internal.acroformPlugin.printedOut && (e.scope.internal.acroformPlugin.printedOut = !1, e.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), e.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e), n.page = n.scope.internal.getCurrentPageInfo().pageNumber, this;
};
Cr.AcroFormChoiceField = Fd, Cr.AcroFormListBox = Dd, Cr.AcroFormComboBox = kd, Cr.AcroFormEditBox = Kg, Cr.AcroFormButton = ps, Cr.AcroFormPushButton = Qg, Cr.AcroFormRadioButton = Nd, Cr.AcroFormCheckBox = em, Cr.AcroFormTextField = Fh, Cr.AcroFormPasswordField = tm, Cr.AcroFormAppearance = un, Cr.AcroForm = { ChoiceField: Fd, ListBox: Dd, ComboBox: kd, EditBox: Kg, Button: ps, PushButton: Qg, RadioButton: Nd, CheckBox: em, TextField: Fh, PasswordField: tm, Appearance: un }, Bn.AcroForm = { ChoiceField: Fd, ListBox: Dd, ComboBox: kd, EditBox: Kg, Button: ps, PushButton: Qg, RadioButton: Nd, CheckBox: em, TextField: Fh, PasswordField: tm, Appearance: un };
function xT(n) {
  return n.reduce(function(e, t, i) {
    return e[t] = i, e;
  }, {});
}
(function(n) {
  n.__addimage__ = {};
  var e = "UNKNOWN", t = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, i = n.__addimage__.getImageFileTypeByImageData = function(ae, de) {
    var Te, be, tt, st, lt, Ye = e;
    if ((de = de || e) === "RGBA" || ae.data !== void 0 && ae.data instanceof Uint8ClampedArray && "height" in ae && "width" in ae)
      return "RGBA";
    if (De(ae))
      for (lt in t)
        for (tt = t[lt], Te = 0; Te < tt.length; Te += 1) {
          for (st = !0, be = 0; be < tt[Te].length; be += 1)
            if (tt[Te][be] !== void 0 && tt[Te][be] !== ae[be]) {
              st = !1;
              break;
            }
          if (st === !0) {
            Ye = lt;
            break;
          }
        }
    else
      for (lt in t)
        for (tt = t[lt], Te = 0; Te < tt.length; Te += 1) {
          for (st = !0, be = 0; be < tt[Te].length; be += 1)
            if (tt[Te][be] !== void 0 && tt[Te][be] !== ae.charCodeAt(be)) {
              st = !1;
              break;
            }
          if (st === !0) {
            Ye = lt;
            break;
          }
        }
    return Ye === e && de !== e && (Ye = de), Ye;
  }, r = function ae(de) {
    for (var Te = this.internal.write, be = this.internal.putStream, tt = (0, this.internal.getFilters)(); tt.indexOf("FlateEncode") !== -1; )
      tt.splice(tt.indexOf("FlateEncode"), 1);
    de.objectId = this.internal.newObject();
    var st = [];
    if (st.push({ key: "Type", value: "/XObject" }), st.push({ key: "Subtype", value: "/Image" }), st.push({ key: "Width", value: de.width }), st.push({ key: "Height", value: de.height }), de.colorSpace === V.INDEXED ? st.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (de.palette.length / 3 - 1) + " " + ("sMask" in de && de.sMask !== void 0 ? de.objectId + 2 : de.objectId + 1) + " 0 R]" }) : (st.push({ key: "ColorSpace", value: "/" + de.colorSpace }), de.colorSpace === V.DEVICE_CMYK && st.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), st.push({ key: "BitsPerComponent", value: de.bitsPerComponent }), "decodeParameters" in de && de.decodeParameters !== void 0 && st.push({ key: "DecodeParms", value: "<<" + de.decodeParameters + ">>" }), "transparency" in de && Array.isArray(de.transparency)) {
      for (var lt = "", Ye = 0, ht = de.transparency.length; Ye < ht; Ye++)
        lt += de.transparency[Ye] + " " + de.transparency[Ye] + " ";
      st.push({ key: "Mask", value: "[" + lt + "]" });
    }
    de.sMask !== void 0 && st.push({ key: "SMask", value: de.objectId + 1 + " 0 R" });
    var ct = de.filter !== void 0 ? ["/" + de.filter] : void 0;
    if (be({ data: de.data, additionalKeyValues: st, alreadyAppliedFilters: ct, objectId: de.objectId }), Te("endobj"), "sMask" in de && de.sMask !== void 0) {
      var Pt = "/Predictor " + de.predictor + " /Colors 1 /BitsPerComponent " + de.bitsPerComponent + " /Columns " + de.width, se = { width: de.width, height: de.height, colorSpace: "DeviceGray", bitsPerComponent: de.bitsPerComponent, decodeParameters: Pt, data: de.sMask };
      "filter" in de && (se.filter = de.filter), ae.call(this, se);
    }
    if (de.colorSpace === V.INDEXED) {
      var Ae = this.internal.newObject();
      be({ data: ye(new Uint8Array(de.palette)), objectId: Ae }), Te("endobj");
    }
  }, s = function() {
    var ae = this.internal.collections.addImage_images;
    for (var de in ae)
      r.call(this, ae[de]);
  }, c = function() {
    var ae, de = this.internal.collections.addImage_images, Te = this.internal.write;
    for (var be in de)
      Te("/I" + (ae = de[be]).index, ae.objectId, "0", "R");
  }, l = function() {
    this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", s), this.internal.events.subscribe("putXobjectDict", c));
  }, m = function() {
    var ae = this.internal.collections.addImage_images;
    return l.call(this), ae;
  }, y = function() {
    return Object.keys(this.internal.collections.addImage_images).length;
  }, A = function(ae) {
    return typeof n["process" + ae.toUpperCase()] == "function";
  }, T = function(ae) {
    return zi(ae) === "object" && ae.nodeType === 1;
  }, I = function(ae, de) {
    if (ae.nodeName === "IMG" && ae.hasAttribute("src")) {
      var Te = "" + ae.getAttribute("src");
      if (Te.indexOf("data:image/") === 0)
        return lp(unescape(Te).split("base64,").pop());
      var be = n.loadFile(Te, !0);
      if (be !== void 0)
        return be;
    }
    if (ae.nodeName === "CANVAS") {
      if (ae.width === 0 || ae.height === 0)
        throw new Error("Given canvas must have data. Canvas width: " + ae.width + ", height: " + ae.height);
      var tt;
      switch (de) {
        case "PNG":
          tt = "image/png";
          break;
        case "WEBP":
          tt = "image/webp";
          break;
        case "JPEG":
        case "JPG":
        default:
          tt = "image/jpeg";
      }
      return lp(ae.toDataURL(tt, 1).split("base64,").pop());
    }
  }, L = function(ae) {
    var de = this.internal.collections.addImage_images;
    if (de) {
      for (var Te in de)
        if (ae === de[Te].alias)
          return de[Te];
    }
  }, N = function(ae, de, Te) {
    return ae || de || (ae = -96, de = -96), ae < 0 && (ae = -1 * Te.width * 72 / ae / this.internal.scaleFactor), de < 0 && (de = -1 * Te.height * 72 / de / this.internal.scaleFactor), ae === 0 && (ae = de * Te.width / Te.height), de === 0 && (de = ae * Te.height / Te.width), [ae, de];
  }, z = function(ae, de, Te, be, tt, st) {
    var lt = N.call(this, Te, be, tt), Ye = this.internal.getCoordinateString, ht = this.internal.getVerticalCoordinateString, ct = m.call(this);
    if (Te = lt[0], be = lt[1], ct[tt.index] = tt, st) {
      st *= Math.PI / 180;
      var Pt = Math.cos(st), se = Math.sin(st), Ae = function(Ue) {
        return Ue.toFixed(4);
      }, Ce = [Ae(Pt), Ae(se), Ae(-1 * se), Ae(Pt), 0, 0, "cm"];
    }
    this.internal.write("q"), st ? (this.internal.write([1, "0", "0", 1, Ye(ae), ht(de + be), "cm"].join(" ")), this.internal.write(Ce.join(" ")), this.internal.write([Ye(Te), "0", "0", Ye(be), "0", "0", "cm"].join(" "))) : this.internal.write([Ye(Te), "0", "0", Ye(be), Ye(ae), ht(de + be), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + tt.index + " Do"), this.internal.write("Q");
  }, V = n.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  n.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var H = n.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, J = n.__addimage__.sHashCode = function(ae) {
    var de, Te, be = 0;
    if (typeof ae == "string")
      for (Te = ae.length, de = 0; de < Te; de++)
        be = (be << 5) - be + ae.charCodeAt(de), be |= 0;
    else if (De(ae))
      for (Te = ae.byteLength / 2, de = 0; de < Te; de++)
        be = (be << 5) - be + ae[de], be |= 0;
    return be;
  }, ce = n.__addimage__.validateStringAsBase64 = function(ae) {
    (ae = ae || "").toString().trim();
    var de = !0;
    return ae.length === 0 && (de = !1), ae.length % 4 != 0 && (de = !1), /^[A-Za-z0-9+/]+$/.test(ae.substr(0, ae.length - 2)) === !1 && (de = !1), /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(ae.substr(-2)) === !1 && (de = !1), de;
  }, me = n.__addimage__.extractImageFromDataUrl = function(ae) {
    var de = (ae = ae || "").split("base64,"), Te = null;
    if (de.length === 2) {
      var be = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(de[0]);
      Array.isArray(be) && (Te = { mimeType: be[1], charset: be[2], data: de[1] });
    }
    return Te;
  }, Se = n.__addimage__.supportsArrayBuffer = function() {
    return typeof ArrayBuffer < "u" && typeof Uint8Array < "u";
  };
  n.__addimage__.isArrayBuffer = function(ae) {
    return Se() && ae instanceof ArrayBuffer;
  };
  var De = n.__addimage__.isArrayBufferView = function(ae) {
    return Se() && typeof Uint32Array < "u" && (ae instanceof Int8Array || ae instanceof Uint8Array || typeof Uint8ClampedArray < "u" && ae instanceof Uint8ClampedArray || ae instanceof Int16Array || ae instanceof Uint16Array || ae instanceof Int32Array || ae instanceof Uint32Array || ae instanceof Float32Array || ae instanceof Float64Array);
  }, Le = n.__addimage__.binaryStringToUint8Array = function(ae) {
    for (var de = ae.length, Te = new Uint8Array(de), be = 0; be < de; be++)
      Te[be] = ae.charCodeAt(be);
    return Te;
  }, ye = n.__addimage__.arrayBufferToBinaryString = function(ae) {
    for (var de = "", Te = De(ae) ? ae : new Uint8Array(ae), be = 0; be < Te.length; be += 8192)
      de += String.fromCharCode.apply(null, Te.subarray(be, be + 8192));
    return de;
  };
  n.addImage = function() {
    var ae, de, Te, be, tt, st, lt, Ye, ht;
    if (typeof arguments[1] == "number" ? (de = e, Te = arguments[1], be = arguments[2], tt = arguments[3], st = arguments[4], lt = arguments[5], Ye = arguments[6], ht = arguments[7]) : (de = arguments[1], Te = arguments[2], be = arguments[3], tt = arguments[4], st = arguments[5], lt = arguments[6], Ye = arguments[7], ht = arguments[8]), zi(ae = arguments[0]) === "object" && !T(ae) && "imageData" in ae) {
      var ct = ae;
      ae = ct.imageData, de = ct.format || de || e, Te = ct.x || Te || 0, be = ct.y || be || 0, tt = ct.w || ct.width || tt, st = ct.h || ct.height || st, lt = ct.alias || lt, Ye = ct.compression || Ye, ht = ct.rotation || ct.angle || ht;
    }
    var Pt = this.internal.getFilters();
    if (Ye === void 0 && Pt.indexOf("FlateEncode") !== -1 && (Ye = "SLOW"), isNaN(Te) || isNaN(be))
      throw new Error("Invalid coordinates passed to jsPDF.addImage");
    l.call(this);
    var se = Ve.call(this, ae, de, lt, Ye);
    return z.call(this, Te, be, tt, st, se, ht), this;
  };
  var Ve = function(ae, de, Te, be) {
    var tt, st, lt;
    if (typeof ae == "string" && i(ae) === e) {
      ae = unescape(ae);
      var Ye = Fe(ae, !1);
      (Ye !== "" || (Ye = n.loadFile(ae, !0)) !== void 0) && (ae = Ye);
    }
    if (T(ae) && (ae = I(ae, de)), de = i(ae, de), !A(de))
      throw new Error("addImage does not support files of type '" + de + "', please ensure that a plugin for '" + de + "' support is added.");
    if (((lt = Te) == null || lt.length === 0) && (Te = function(ht) {
      return typeof ht == "string" || De(ht) ? J(ht) : De(ht.data) ? J(ht.data) : null;
    }(ae)), (tt = L.call(this, Te)) || (Se() && (ae instanceof Uint8Array || de === "RGBA" || (st = ae, ae = Le(ae))), tt = this["process" + de.toUpperCase()](ae, y.call(this), Te, function(ht) {
      return ht && typeof ht == "string" && (ht = ht.toUpperCase()), ht in n.image_compression ? ht : H.NONE;
    }(be), st)), !tt)
      throw new Error("An unknown error occurred whilst processing the image.");
    return tt;
  }, Fe = n.__addimage__.convertBase64ToBinaryString = function(ae, de) {
    var Te;
    de = typeof de != "boolean" || de;
    var be, tt = "";
    if (typeof ae == "string") {
      be = (Te = me(ae)) !== null ? Te.data : ae;
      try {
        tt = lp(be);
      } catch (st) {
        if (de)
          throw ce(be) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + st.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return tt;
  };
  n.getImageProperties = function(ae) {
    var de, Te, be = "";
    if (T(ae) && (ae = I(ae)), typeof ae == "string" && i(ae) === e && ((be = Fe(ae, !1)) === "" && (be = n.loadFile(ae) || ""), ae = be), Te = i(ae), !A(Te))
      throw new Error("addImage does not support files of type '" + Te + "', please ensure that a plugin for '" + Te + "' support is added.");
    if (!Se() || ae instanceof Uint8Array || (ae = Le(ae)), !(de = this["process" + Te.toUpperCase()](ae)))
      throw new Error("An unknown error occurred whilst processing the image");
    return de.fileType = Te, de;
  };
})(Bn.API), /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  var e = function(t) {
    if (t !== void 0 && t != "")
      return !0;
  };
  Bn.API.events.push(["addPage", function(t) {
    this.internal.getPageInfo(t.pageNumber).pageContext.annotations = [];
  }]), n.events.push(["putPage", function(t) {
    for (var i, r, s, c = this.internal.getCoordinateString, l = this.internal.getVerticalCoordinateString, m = this.internal.getPageInfoByObjId(t.objId), y = t.pageContext.annotations, A = !1, T = 0; T < y.length && !A; T++)
      switch ((i = y[T]).type) {
        case "link":
          (e(i.options.url) || e(i.options.pageNumber)) && (A = !0);
          break;
        case "reference":
        case "text":
        case "freetext":
          A = !0;
      }
    if (A != 0) {
      this.internal.write("/Annots [");
      for (var I = 0; I < y.length; I++) {
        i = y[I];
        var L = this.internal.pdfEscape, N = this.internal.getEncryptor(t.objId);
        switch (i.type) {
          case "reference":
            this.internal.write(" " + i.object.objId + " 0 R ");
            break;
          case "text":
            var z = this.internal.newAdditionalObject(), V = this.internal.newAdditionalObject(), H = this.internal.getEncryptor(z.objId), J = i.title || "Note";
            s = "<</Type /Annot /Subtype /Text " + (r = "/Rect [" + c(i.bounds.x) + " " + l(i.bounds.y + i.bounds.h) + " " + c(i.bounds.x + i.bounds.w) + " " + l(i.bounds.y) + "] ") + "/Contents (" + L(H(i.contents)) + ")", s += " /Popup " + V.objId + " 0 R", s += " /P " + m.objId + " 0 R", s += " /T (" + L(H(J)) + ") >>", z.content = s;
            var ce = z.objId + " 0 R";
            s = "<</Type /Annot /Subtype /Popup " + (r = "/Rect [" + c(i.bounds.x + 30) + " " + l(i.bounds.y + i.bounds.h) + " " + c(i.bounds.x + i.bounds.w + 30) + " " + l(i.bounds.y) + "] ") + " /Parent " + ce, i.open && (s += " /Open true"), s += " >>", V.content = s, this.internal.write(z.objId, "0 R", V.objId, "0 R");
            break;
          case "freetext":
            r = "/Rect [" + c(i.bounds.x) + " " + l(i.bounds.y) + " " + c(i.bounds.x + i.bounds.w) + " " + l(i.bounds.y + i.bounds.h) + "] ";
            var me = i.color || "#000000";
            s = "<</Type /Annot /Subtype /FreeText " + r + "/Contents (" + L(N(i.contents)) + ")", s += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + me + ")", s += " /Border [0 0 0]", s += " >>", this.internal.write(s);
            break;
          case "link":
            if (i.options.name) {
              var Se = this.annotations._nameMap[i.options.name];
              i.options.pageNumber = Se.page, i.options.top = Se.y;
            } else
              i.options.top || (i.options.top = 0);
            if (r = "/Rect [" + i.finalBounds.x + " " + i.finalBounds.y + " " + i.finalBounds.w + " " + i.finalBounds.h + "] ", s = "", i.options.url)
              s = "<</Type /Annot /Subtype /Link " + r + "/Border [0 0 0] /A <</S /URI /URI (" + L(N(i.options.url)) + ") >>";
            else if (i.options.pageNumber)
              switch (s = "<</Type /Annot /Subtype /Link " + r + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(i.options.pageNumber).objId + " 0 R", i.options.magFactor = i.options.magFactor || "XYZ", i.options.magFactor) {
                case "Fit":
                  s += " /Fit]";
                  break;
                case "FitH":
                  s += " /FitH " + i.options.top + "]";
                  break;
                case "FitV":
                  i.options.left = i.options.left || 0, s += " /FitV " + i.options.left + "]";
                  break;
                case "XYZ":
                default:
                  var De = l(i.options.top);
                  i.options.left = i.options.left || 0, i.options.zoom === void 0 && (i.options.zoom = 0), s += " /XYZ " + i.options.left + " " + De + " " + i.options.zoom + "]";
              }
            s != "" && (s += " >>", this.internal.write(s));
        }
      }
      this.internal.write("]");
    }
  }]), n.createAnnotation = function(t) {
    var i = this.internal.getCurrentPageInfo();
    switch (t.type) {
      case "link":
        this.link(t.bounds.x, t.bounds.y, t.bounds.w, t.bounds.h, t);
        break;
      case "text":
      case "freetext":
        i.pageContext.annotations.push(t);
    }
  }, n.link = function(t, i, r, s, c) {
    var l = this.internal.getCurrentPageInfo(), m = this.internal.getCoordinateString, y = this.internal.getVerticalCoordinateString;
    l.pageContext.annotations.push({ finalBounds: { x: m(t), y: y(i), w: m(t + r), h: y(i + s) }, options: c, type: "link" });
  }, n.textWithLink = function(t, i, r, s) {
    var c, l, m = this.getTextWidth(t), y = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (s.maxWidth !== void 0) {
      l = s.maxWidth;
      var A = this.splitTextToSize(t, l).length;
      c = Math.ceil(y * A);
    } else
      l = m, c = y;
    return this.text(t, i, r, s), r += 0.2 * y, s.align === "center" && (i -= m / 2), s.align === "right" && (i -= m), this.link(i, r - y, l, c, s), m;
  }, n.getTextWidth = function(t) {
    var i = this.internal.getFontSize();
    return this.getStringUnitWidth(t) * i / this.internal.scaleFactor;
  };
}(Bn.API), /**
* @license
* Copyright (c) 2017 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  var e = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, t = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, i = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, r = [1570, 1571, 1573, 1575];
  n.__arabicParser__ = {};
  var s = n.__arabicParser__.isInArabicSubstitutionA = function(z) {
    return e[z.charCodeAt(0)] !== void 0;
  }, c = n.__arabicParser__.isArabicLetter = function(z) {
    return typeof z == "string" && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(z);
  }, l = n.__arabicParser__.isArabicEndLetter = function(z) {
    return c(z) && s(z) && e[z.charCodeAt(0)].length <= 2;
  }, m = n.__arabicParser__.isArabicAlfLetter = function(z) {
    return c(z) && r.indexOf(z.charCodeAt(0)) >= 0;
  };
  n.__arabicParser__.arabicLetterHasIsolatedForm = function(z) {
    return c(z) && s(z) && e[z.charCodeAt(0)].length >= 1;
  };
  var y = n.__arabicParser__.arabicLetterHasFinalForm = function(z) {
    return c(z) && s(z) && e[z.charCodeAt(0)].length >= 2;
  };
  n.__arabicParser__.arabicLetterHasInitialForm = function(z) {
    return c(z) && s(z) && e[z.charCodeAt(0)].length >= 3;
  };
  var A = n.__arabicParser__.arabicLetterHasMedialForm = function(z) {
    return c(z) && s(z) && e[z.charCodeAt(0)].length == 4;
  }, T = n.__arabicParser__.resolveLigatures = function(z) {
    var V = 0, H = t, J = "", ce = 0;
    for (V = 0; V < z.length; V += 1)
      H[z.charCodeAt(V)] !== void 0 ? (ce++, typeof (H = H[z.charCodeAt(V)]) == "number" && (J += String.fromCharCode(H), H = t, ce = 0), V === z.length - 1 && (H = t, J += z.charAt(V - (ce - 1)), V -= ce - 1, ce = 0)) : (H = t, J += z.charAt(V - ce), V -= ce, ce = 0);
    return J;
  };
  n.__arabicParser__.isArabicDiacritic = function(z) {
    return z !== void 0 && i[z.charCodeAt(0)] !== void 0;
  };
  var I = n.__arabicParser__.getCorrectForm = function(z, V, H) {
    return c(z) ? s(z) === !1 ? -1 : !y(z) || !c(V) && !c(H) || !c(H) && l(V) || l(z) && !c(V) || l(z) && m(V) || l(z) && l(V) ? 0 : A(z) && c(V) && !l(V) && c(H) && y(H) ? 3 : l(z) || !c(H) ? 1 : 2 : -1;
  }, L = function(z) {
    var V = 0, H = 0, J = 0, ce = "", me = "", Se = "", De = (z = z || "").split("\\s+"), Le = [];
    for (V = 0; V < De.length; V += 1) {
      for (Le.push(""), H = 0; H < De[V].length; H += 1)
        ce = De[V][H], me = De[V][H - 1], Se = De[V][H + 1], c(ce) ? (J = I(ce, me, Se), Le[V] += J !== -1 ? String.fromCharCode(e[ce.charCodeAt(0)][J]) : ce) : Le[V] += ce;
      Le[V] = T(Le[V]);
    }
    return Le.join(" ");
  }, N = n.__arabicParser__.processArabic = n.processArabic = function() {
    var z, V = typeof arguments[0] == "string" ? arguments[0] : arguments[0].text, H = [];
    if (Array.isArray(V)) {
      var J = 0;
      for (H = [], J = 0; J < V.length; J += 1)
        Array.isArray(V[J]) ? H.push([L(V[J][0]), V[J][1], V[J][2]]) : H.push([L(V[J])]);
      z = H;
    } else
      z = L(V);
    return typeof arguments[0] == "string" ? z : (arguments[0].text = z, arguments[0]);
  };
  n.events.push(["preProcessText", N]);
}(Bn.API), Bn.API.autoPrint = function(n) {
  var e;
  switch ((n = n || {}).variant = n.variant || "non-conform", n.variant) {
    case "javascript":
      this.addJS("print({});");
      break;
    case "non-conform":
    default:
      this.internal.events.subscribe("postPutResources", function() {
        e = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + e + " 0 R");
      });
  }
  return this;
}, /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  var e = function() {
    var t = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return t;
    }, set: function(l) {
      t = l;
    } });
    var i = 150;
    Object.defineProperty(this, "width", { get: function() {
      return i;
    }, set: function(l) {
      i = isNaN(l) || Number.isInteger(l) === !1 || l < 0 ? 150 : l, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = i + 1);
    } });
    var r = 300;
    Object.defineProperty(this, "height", { get: function() {
      return r;
    }, set: function(l) {
      r = isNaN(l) || Number.isInteger(l) === !1 || l < 0 ? 300 : l, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = r + 1);
    } });
    var s = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return s;
    }, set: function(l) {
      s = l;
    } });
    var c = {};
    Object.defineProperty(this, "style", { get: function() {
      return c;
    }, set: function(l) {
      c = l;
    } }), Object.defineProperty(this, "parentNode", {});
  };
  e.prototype.getContext = function(t, i) {
    var r;
    if ((t = t || "2d") !== "2d")
      return null;
    for (r in i)
      this.pdf.context2d.hasOwnProperty(r) && (this.pdf.context2d[r] = i[r]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, e.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, n.events.push(["initialized", function() {
    this.canvas = new e(), this.canvas.pdf = this;
  }]);
}(Bn.API), function(n) {
  var e = { left: 0, top: 0, bottom: 0, right: 0 }, t = !1, i = function() {
    this.internal.__cell__ === void 0 && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, e), this.internal.__cell__.margins.width = this.getPageWidth(), r.call(this));
  }, r = function() {
    this.internal.__cell__.lastCell = new s(), this.internal.__cell__.pages = 1;
  }, s = function() {
    var m = arguments[0];
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return m;
    }, set: function(z) {
      m = z;
    } });
    var y = arguments[1];
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return y;
    }, set: function(z) {
      y = z;
    } });
    var A = arguments[2];
    Object.defineProperty(this, "width", { enumerable: !0, get: function() {
      return A;
    }, set: function(z) {
      A = z;
    } });
    var T = arguments[3];
    Object.defineProperty(this, "height", { enumerable: !0, get: function() {
      return T;
    }, set: function(z) {
      T = z;
    } });
    var I = arguments[4];
    Object.defineProperty(this, "text", { enumerable: !0, get: function() {
      return I;
    }, set: function(z) {
      I = z;
    } });
    var L = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: !0, get: function() {
      return L;
    }, set: function(z) {
      L = z;
    } });
    var N = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: !0, get: function() {
      return N;
    }, set: function(z) {
      N = z;
    } }), this;
  };
  s.prototype.clone = function() {
    return new s(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, s.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, n.setHeaderFunction = function(m) {
    return i.call(this), this.internal.__cell__.headerFunction = typeof m == "function" ? m : void 0, this;
  }, n.getTextDimensions = function(m, y) {
    i.call(this);
    var A = (y = y || {}).fontSize || this.getFontSize(), T = y.font || this.getFont(), I = y.scaleFactor || this.internal.scaleFactor, L = 0, N = 0, z = 0, V = this;
    if (!Array.isArray(m) && typeof m != "string") {
      if (typeof m != "number")
        throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      m = String(m);
    }
    var H = y.maxWidth;
    H > 0 ? typeof m == "string" ? m = this.splitTextToSize(m, H) : Object.prototype.toString.call(m) === "[object Array]" && (m = m.reduce(function(ce, me) {
      return ce.concat(V.splitTextToSize(me, H));
    }, [])) : m = Array.isArray(m) ? m : [m];
    for (var J = 0; J < m.length; J++)
      L < (z = this.getStringUnitWidth(m[J], { font: T }) * A) && (L = z);
    return L !== 0 && (N = m.length), { w: L /= I, h: Math.max((N * A * this.getLineHeightFactor() - A * (this.getLineHeightFactor() - 1)) / I, 0) };
  }, n.cellAddPage = function() {
    i.call(this), this.addPage();
    var m = this.internal.__cell__.margins || e;
    return this.internal.__cell__.lastCell = new s(m.left, m.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var c = n.cell = function() {
    var m;
    m = arguments[0] instanceof s ? arguments[0] : new s(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), i.call(this);
    var y = this.internal.__cell__.lastCell, A = this.internal.__cell__.padding, T = this.internal.__cell__.margins || e, I = this.internal.__cell__.tableHeaderRow, L = this.internal.__cell__.printHeaders;
    return y.lineNumber !== void 0 && (y.lineNumber === m.lineNumber ? (m.x = (y.x || 0) + (y.width || 0), m.y = y.y || 0) : y.y + y.height + m.height + T.bottom > this.getPageHeight() ? (this.cellAddPage(), m.y = T.top, L && I && (this.printHeaderRow(m.lineNumber, !0), m.y += I[0].height)) : m.y = y.y + y.height || m.y), m.text[0] !== void 0 && (this.rect(m.x, m.y, m.width, m.height, t === !0 ? "FD" : void 0), m.align === "right" ? this.text(m.text, m.x + m.width - A, m.y + A, { align: "right", baseline: "top" }) : m.align === "center" ? this.text(m.text, m.x + m.width / 2, m.y + A, { align: "center", baseline: "top", maxWidth: m.width - A - A }) : this.text(m.text, m.x + A, m.y + A, { align: "left", baseline: "top", maxWidth: m.width - A - A })), this.internal.__cell__.lastCell = m, this;
  };
  n.table = function(m, y, A, T, I) {
    if (i.call(this), !A)
      throw new Error("No data for PDF table.");
    var L, N, z, V, H = [], J = [], ce = [], me = {}, Se = {}, De = [], Le = [], ye = (I = I || {}).autoSize || !1, Ve = I.printHeaders !== !1, Fe = I.css && I.css["font-size"] !== void 0 ? 16 * I.css["font-size"] : I.fontSize || 12, ae = I.margins || Object.assign({ width: this.getPageWidth() }, e), de = typeof I.padding == "number" ? I.padding : 3, Te = I.headerBackgroundColor || "#c8c8c8", be = I.headerTextColor || "#000";
    if (r.call(this), this.internal.__cell__.printHeaders = Ve, this.internal.__cell__.margins = ae, this.internal.__cell__.table_font_size = Fe, this.internal.__cell__.padding = de, this.internal.__cell__.headerBackgroundColor = Te, this.internal.__cell__.headerTextColor = be, this.setFontSize(Fe), T == null)
      J = H = Object.keys(A[0]), ce = H.map(function() {
        return "left";
      });
    else if (Array.isArray(T) && zi(T[0]) === "object")
      for (H = T.map(function(ct) {
        return ct.name;
      }), J = T.map(function(ct) {
        return ct.prompt || ct.name || "";
      }), ce = T.map(function(ct) {
        return ct.align || "left";
      }), L = 0; L < T.length; L += 1)
        Se[T[L].name] = T[L].width * (19.049976 / 25.4);
    else
      Array.isArray(T) && typeof T[0] == "string" && (J = H = T, ce = H.map(function() {
        return "left";
      }));
    if (ye || Array.isArray(T) && typeof T[0] == "string")
      for (L = 0; L < H.length; L += 1) {
        for (me[V = H[L]] = A.map(function(ct) {
          return ct[V];
        }), this.setFont(void 0, "bold"), De.push(this.getTextDimensions(J[L], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), N = me[V], this.setFont(void 0, "normal"), z = 0; z < N.length; z += 1)
          De.push(this.getTextDimensions(N[z], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
        Se[V] = Math.max.apply(null, De) + de + de, De = [];
      }
    if (Ve) {
      var tt = {};
      for (L = 0; L < H.length; L += 1)
        tt[H[L]] = {}, tt[H[L]].text = J[L], tt[H[L]].align = ce[L];
      var st = l.call(this, tt, Se);
      Le = H.map(function(ct) {
        return new s(m, y, Se[ct], st, tt[ct].text, void 0, tt[ct].align);
      }), this.setTableHeaderRow(Le), this.printHeaderRow(1, !1);
    }
    var lt = T.reduce(function(ct, Pt) {
      return ct[Pt.name] = Pt.align, ct;
    }, {});
    for (L = 0; L < A.length; L += 1) {
      "rowStart" in I && I.rowStart instanceof Function && I.rowStart({ row: L, data: A[L] }, this);
      var Ye = l.call(this, A[L], Se);
      for (z = 0; z < H.length; z += 1) {
        var ht = A[L][H[z]];
        "cellStart" in I && I.cellStart instanceof Function && I.cellStart({ row: L, col: z, data: ht }, this), c.call(this, new s(m, y, Se[H[z]], Ye, ht, L + 2, lt[H[z]]));
      }
    }
    return this.internal.__cell__.table_x = m, this.internal.__cell__.table_y = y, this;
  };
  var l = function(m, y) {
    var A = this.internal.__cell__.padding, T = this.internal.__cell__.table_font_size, I = this.internal.scaleFactor;
    return Object.keys(m).map(function(L) {
      var N = m[L];
      return this.splitTextToSize(N.hasOwnProperty("text") ? N.text : N, y[L] - A - A);
    }, this).map(function(L) {
      return this.getLineHeightFactor() * L.length * T / I + A + A;
    }, this).reduce(function(L, N) {
      return Math.max(L, N);
    }, 0);
  };
  n.setTableHeaderRow = function(m) {
    i.call(this), this.internal.__cell__.tableHeaderRow = m;
  }, n.printHeaderRow = function(m, y) {
    if (i.call(this), !this.internal.__cell__.tableHeaderRow)
      throw new Error("Property tableHeaderRow does not exist.");
    var A;
    if (t = !0, typeof this.internal.__cell__.headerFunction == "function") {
      var T = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new s(T[0], T[1], T[2], T[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var I = [], L = 0; L < this.internal.__cell__.tableHeaderRow.length; L += 1) {
      A = this.internal.__cell__.tableHeaderRow[L].clone(), y && (A.y = this.internal.__cell__.margins.top || 0, I.push(A)), A.lineNumber = m;
      var N = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), c.call(this, A), this.setTextColor(N);
    }
    I.length > 0 && this.setTableHeaderRow(I), this.setFont(void 0, "normal"), t = !1;
  };
}(Bn.API);
var wT = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] }, AT = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"], Ky = xT(AT), ET = [100, 200, 300, 400, 500, 600, 700, 800, 900], aV = xT(ET);
function Qy(n) {
  var e = n.family.replace(/"|'/g, "").toLowerCase(), t = function(s) {
    return wT[s = s || "normal"] ? s : "normal";
  }(n.style), i = function(s) {
    if (!s)
      return 400;
    if (typeof s == "number")
      return s >= 100 && s <= 900 && s % 100 == 0 ? s : 400;
    if (/^\d00$/.test(s))
      return parseInt(s);
    switch (s) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
  }(n.weight), r = function(s) {
    return typeof Ky[s = s || "normal"] == "number" ? s : "normal";
  }(n.stretch);
  return { family: e, style: t, weight: i, stretch: r, src: n.src || [], ref: n.ref || { name: e, style: [r, t, i].join(" ") } };
}
function FA(n, e, t, i) {
  var r;
  for (r = t; r >= 0 && r < e.length; r += i)
    if (n[e[r]])
      return n[e[r]];
  for (r = t; r >= 0 && r < e.length; r -= i)
    if (n[e[r]])
      return n[e[r]];
}
var lV = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" }, DA = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function kA(n) {
  return [n.stretch, n.style, n.weight, n.family].join(" ");
}
function cV(n, e, t) {
  for (var i = (t = t || {}).defaultFontFamily || "times", r = Object.assign({}, lV, t.genericFontFamilies || {}), s = null, c = null, l = 0; l < e.length; ++l)
    if (r[(s = Qy(e[l])).family] && (s.family = r[s.family]), n.hasOwnProperty(s.family)) {
      c = n[s.family];
      break;
    }
  if (!(c = c || n[i]))
    throw new Error("Could not find a font-family for the rule '" + kA(s) + "' and default family '" + i + "'.");
  if (c = function(m, y) {
    if (y[m])
      return y[m];
    var A = Ky[m], T = A <= Ky.normal ? -1 : 1, I = FA(y, AT, A, T);
    if (!I)
      throw new Error("Could not find a matching font-stretch value for " + m);
    return I;
  }(s.stretch, c), c = function(m, y) {
    if (y[m])
      return y[m];
    for (var A = wT[m], T = 0; T < A.length; ++T)
      if (y[A[T]])
        return y[A[T]];
    throw new Error("Could not find a matching font-style for " + m);
  }(s.style, c), !(c = function(m, y) {
    if (y[m])
      return y[m];
    if (m === 400 && y[500])
      return y[500];
    if (m === 500 && y[400])
      return y[400];
    var A = aV[m], T = FA(y, ET, A, m < 400 ? -1 : 1);
    if (!T)
      throw new Error("Could not find a matching font-weight for value " + m);
    return T;
  }(s.weight, c)))
    throw new Error("Failed to resolve a font for the rule '" + kA(s) + "'.");
  return c;
}
function NA(n) {
  return n.trimLeft();
}
function uV(n, e) {
  for (var t = 0; t < n.length; ) {
    if (n.charAt(t) === e)
      return [n.substring(0, t), n.substring(t + 1)];
    t += 1;
  }
  return null;
}
function hV(n) {
  var e = n.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return e === null ? null : [e[0], n.substring(e[0].length)];
}
var Ng, zA, UA, jA = ["times"];
(function(n) {
  var e, t, i, r, s, c, l, m, y, A = function(se) {
    return se = se || {}, this.isStrokeTransparent = se.isStrokeTransparent || !1, this.strokeOpacity = se.strokeOpacity || 1, this.strokeStyle = se.strokeStyle || "#000000", this.fillStyle = se.fillStyle || "#000000", this.isFillTransparent = se.isFillTransparent || !1, this.fillOpacity = se.fillOpacity || 1, this.font = se.font || "10px sans-serif", this.textBaseline = se.textBaseline || "alphabetic", this.textAlign = se.textAlign || "left", this.lineWidth = se.lineWidth || 1, this.lineJoin = se.lineJoin || "miter", this.lineCap = se.lineCap || "butt", this.path = se.path || [], this.transform = se.transform !== void 0 ? se.transform.clone() : new m(), this.globalCompositeOperation = se.globalCompositeOperation || "normal", this.globalAlpha = se.globalAlpha || 1, this.clip_path = se.clip_path || [], this.currentPoint = se.currentPoint || new c(), this.miterLimit = se.miterLimit || 10, this.lastPoint = se.lastPoint || new c(), this.lineDashOffset = se.lineDashOffset || 0, this.lineDash = se.lineDash || [], this.margin = se.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = se.prevPageLastElemOffset || 0, this.ignoreClearRect = typeof se.ignoreClearRect != "boolean" || se.ignoreClearRect, this;
  };
  n.events.push(["initialized", function() {
    this.context2d = new T(this), e = this.internal.f2, t = this.internal.getCoordinateString, i = this.internal.getVerticalCoordinateString, r = this.internal.getHorizontalCoordinate, s = this.internal.getVerticalCoordinate, c = this.internal.Point, l = this.internal.Rectangle, m = this.internal.Matrix, y = new A();
  }]);
  var T = function(se) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: !1, style: !1 };
    } });
    var Ae = se;
    Object.defineProperty(this, "pdf", { get: function() {
      return Ae;
    } });
    var Ce = !1;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return Ce;
    }, set: function(ut) {
      Ce = !!ut;
    } });
    var Ue = !1;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return Ue;
    }, set: function(ut) {
      Ue = !!ut;
    } });
    var qe = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return qe;
    }, set: function(ut) {
      isNaN(ut) || (qe = ut);
    } });
    var We = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return We;
    }, set: function(ut) {
      isNaN(ut) || (We = ut);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return y.margin;
    }, set: function(ut) {
      var re;
      typeof ut == "number" ? re = [ut, ut, ut, ut] : ((re = new Array(4))[0] = ut[0], re[1] = ut.length >= 2 ? ut[1] : re[0], re[2] = ut.length >= 3 ? ut[2] : re[0], re[3] = ut.length >= 4 ? ut[3] : re[1]), y.margin = re;
    } });
    var Ke = !1;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return Ke;
    }, set: function(ut) {
      Ke = ut;
    } });
    var Ze = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return Ze;
    }, set: function(ut) {
      Ze = ut;
    } });
    var At = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return At;
    }, set: function(ut) {
      At = ut;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return y;
    }, set: function(ut) {
      ut instanceof A && (y = ut);
    } }), Object.defineProperty(this, "path", { get: function() {
      return y.path;
    }, set: function(ut) {
      y.path = ut;
    } });
    var It = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return It;
    }, set: function(ut) {
      It = ut;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(ut) {
      var re;
      re = I(ut), this.ctx.fillStyle = re.style, this.ctx.isFillTransparent = re.a === 0, this.ctx.fillOpacity = re.a, this.pdf.setFillColor(re.r, re.g, re.b, { a: re.a }), this.pdf.setTextColor(re.r, re.g, re.b, { a: re.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(ut) {
      var re = I(ut);
      this.ctx.strokeStyle = re.style, this.ctx.isStrokeTransparent = re.a === 0, this.ctx.strokeOpacity = re.a, re.a === 0 ? this.pdf.setDrawColor(255, 255, 255) : (re.a, this.pdf.setDrawColor(re.r, re.g, re.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(ut) {
      ["butt", "round", "square"].indexOf(ut) !== -1 && (this.ctx.lineCap = ut, this.pdf.setLineCap(ut));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(ut) {
      isNaN(ut) || (this.ctx.lineWidth = ut, this.pdf.setLineWidth(ut));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(ut) {
      ["bevel", "round", "miter"].indexOf(ut) !== -1 && (this.ctx.lineJoin = ut, this.pdf.setLineJoin(ut));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(ut) {
      isNaN(ut) || (this.ctx.miterLimit = ut, this.pdf.setMiterLimit(ut));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(ut) {
      this.ctx.textBaseline = ut;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(ut) {
      ["right", "end", "center", "left", "start"].indexOf(ut) !== -1 && (this.ctx.textAlign = ut);
    } });
    var Rt = null;
    function kt(ut, re) {
      if (Rt === null) {
        var mn = function(Qt) {
          var pt = [];
          return Object.keys(Qt).forEach(function(Et) {
            Qt[Et].forEach(function(Lt) {
              var Ft = null;
              switch (Lt) {
                case "bold":
                  Ft = { family: Et, weight: "bold" };
                  break;
                case "italic":
                  Ft = { family: Et, style: "italic" };
                  break;
                case "bolditalic":
                  Ft = { family: Et, weight: "bold", style: "italic" };
                  break;
                case "":
                case "normal":
                  Ft = { family: Et };
              }
              Ft !== null && (Ft.ref = { name: Et, style: Lt }, pt.push(Ft));
            });
          }), pt;
        }(ut.getFontList());
        Rt = function(Qt) {
          for (var pt = {}, Et = 0; Et < Qt.length; ++Et) {
            var Lt = Qy(Qt[Et]), Ft = Lt.family, nn = Lt.stretch, Tn = Lt.style, xn = Lt.weight;
            pt[Ft] = pt[Ft] || {}, pt[Ft][nn] = pt[Ft][nn] || {}, pt[Ft][nn][Tn] = pt[Ft][nn][Tn] || {}, pt[Ft][nn][Tn][xn] = Lt;
          }
          return pt;
        }(mn.concat(re));
      }
      return Rt;
    }
    var on = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return on;
    }, set: function(ut) {
      Rt = null, on = ut;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(ut) {
      var re;
      if (this.ctx.font = ut, (re = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(ut)) !== null) {
        var mn = re[1], Qt = (re[2], re[3]), pt = re[4], Et = (re[5], re[6]), Lt = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(pt)[2];
        pt = Math.floor(Lt === "px" ? parseFloat(pt) * this.pdf.internal.scaleFactor : Lt === "em" ? parseFloat(pt) * this.pdf.getFontSize() : parseFloat(pt) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(pt);
        var Ft = function(hn) {
          var wn, Bt, bi = [], _t = hn.trim();
          if (_t === "")
            return jA;
          if (_t in DA)
            return [DA[_t]];
          for (; _t !== ""; ) {
            switch (Bt = null, wn = (_t = NA(_t)).charAt(0)) {
              case '"':
              case "'":
                Bt = uV(_t.substring(1), wn);
                break;
              default:
                Bt = hV(_t);
            }
            if (Bt === null || (bi.push(Bt[0]), (_t = NA(Bt[1])) !== "" && _t.charAt(0) !== ","))
              return jA;
            _t = _t.replace(/^,/, "");
          }
          return bi;
        }(Et);
        if (this.fontFaces) {
          var nn = cV(kt(this.pdf, this.fontFaces), Ft.map(function(hn) {
            return { family: hn, stretch: "normal", weight: Qt, style: mn };
          }));
          this.pdf.setFont(nn.ref.name, nn.ref.style);
        } else {
          var Tn = "";
          (Qt === "bold" || parseInt(Qt, 10) >= 700 || mn === "bold") && (Tn = "bold"), mn === "italic" && (Tn += "italic"), Tn.length === 0 && (Tn = "normal");
          for (var xn = "", On = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, Un = 0; Un < Ft.length; Un++) {
            if (this.pdf.internal.getFont(Ft[Un], Tn, { noFallback: !0, disableWarning: !0 }) !== void 0) {
              xn = Ft[Un];
              break;
            }
            if (Tn === "bolditalic" && this.pdf.internal.getFont(Ft[Un], "bold", { noFallback: !0, disableWarning: !0 }) !== void 0)
              xn = Ft[Un], Tn = "bold";
            else if (this.pdf.internal.getFont(Ft[Un], "normal", { noFallback: !0, disableWarning: !0 }) !== void 0) {
              xn = Ft[Un], Tn = "normal";
              break;
            }
          }
          if (xn === "") {
            for (var mt = 0; mt < Ft.length; mt++)
              if (On[Ft[mt]]) {
                xn = On[Ft[mt]];
                break;
              }
          }
          xn = xn === "" ? "Times" : xn, this.pdf.setFont(xn, Tn);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(ut) {
      this.ctx.globalCompositeOperation = ut;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(ut) {
      this.ctx.globalAlpha = ut;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(ut) {
      this.ctx.lineDashOffset = ut, Pt.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(ut) {
      this.ctx.lineDash = ut, Pt.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(ut) {
      this.ctx.ignoreClearRect = !!ut;
    } });
  };
  T.prototype.setLineDash = function(se) {
    this.lineDash = se;
  }, T.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, T.prototype.fill = function() {
    me.call(this, "fill", !1);
  }, T.prototype.stroke = function() {
    me.call(this, "stroke", !1);
  }, T.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, T.prototype.moveTo = function(se, Ae) {
    if (isNaN(se) || isNaN(Ae))
      throw Ki.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var Ce = this.ctx.transform.applyToPoint(new c(se, Ae));
    this.path.push({ type: "mt", x: Ce.x, y: Ce.y }), this.ctx.lastPoint = new c(se, Ae);
  }, T.prototype.closePath = function() {
    var se = new c(0, 0), Ae = 0;
    for (Ae = this.path.length - 1; Ae !== -1; Ae--)
      if (this.path[Ae].type === "begin" && zi(this.path[Ae + 1]) === "object" && typeof this.path[Ae + 1].x == "number") {
        se = new c(this.path[Ae + 1].x, this.path[Ae + 1].y);
        break;
      }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new c(se.x, se.y);
  }, T.prototype.lineTo = function(se, Ae) {
    if (isNaN(se) || isNaN(Ae))
      throw Ki.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var Ce = this.ctx.transform.applyToPoint(new c(se, Ae));
    this.path.push({ type: "lt", x: Ce.x, y: Ce.y }), this.ctx.lastPoint = new c(Ce.x, Ce.y);
  }, T.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), me.call(this, null, !0);
  }, T.prototype.quadraticCurveTo = function(se, Ae, Ce, Ue) {
    if (isNaN(Ce) || isNaN(Ue) || isNaN(se) || isNaN(Ae))
      throw Ki.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var qe = this.ctx.transform.applyToPoint(new c(Ce, Ue)), We = this.ctx.transform.applyToPoint(new c(se, Ae));
    this.path.push({ type: "qct", x1: We.x, y1: We.y, x: qe.x, y: qe.y }), this.ctx.lastPoint = new c(qe.x, qe.y);
  }, T.prototype.bezierCurveTo = function(se, Ae, Ce, Ue, qe, We) {
    if (isNaN(qe) || isNaN(We) || isNaN(se) || isNaN(Ae) || isNaN(Ce) || isNaN(Ue))
      throw Ki.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var Ke = this.ctx.transform.applyToPoint(new c(qe, We)), Ze = this.ctx.transform.applyToPoint(new c(se, Ae)), At = this.ctx.transform.applyToPoint(new c(Ce, Ue));
    this.path.push({ type: "bct", x1: Ze.x, y1: Ze.y, x2: At.x, y2: At.y, x: Ke.x, y: Ke.y }), this.ctx.lastPoint = new c(Ke.x, Ke.y);
  }, T.prototype.arc = function(se, Ae, Ce, Ue, qe, We) {
    if (isNaN(se) || isNaN(Ae) || isNaN(Ce) || isNaN(Ue) || isNaN(qe))
      throw Ki.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if (We = !!We, !this.ctx.transform.isIdentity) {
      var Ke = this.ctx.transform.applyToPoint(new c(se, Ae));
      se = Ke.x, Ae = Ke.y;
      var Ze = this.ctx.transform.applyToPoint(new c(0, Ce)), At = this.ctx.transform.applyToPoint(new c(0, 0));
      Ce = Math.sqrt(Math.pow(Ze.x - At.x, 2) + Math.pow(Ze.y - At.y, 2));
    }
    Math.abs(qe - Ue) >= 2 * Math.PI && (Ue = 0, qe = 2 * Math.PI), this.path.push({ type: "arc", x: se, y: Ae, radius: Ce, startAngle: Ue, endAngle: qe, counterclockwise: We });
  }, T.prototype.arcTo = function(se, Ae, Ce, Ue, qe) {
    throw new Error("arcTo not implemented.");
  }, T.prototype.rect = function(se, Ae, Ce, Ue) {
    if (isNaN(se) || isNaN(Ae) || isNaN(Ce) || isNaN(Ue))
      throw Ki.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(se, Ae), this.lineTo(se + Ce, Ae), this.lineTo(se + Ce, Ae + Ue), this.lineTo(se, Ae + Ue), this.lineTo(se, Ae), this.lineTo(se + Ce, Ae), this.lineTo(se, Ae);
  }, T.prototype.fillRect = function(se, Ae, Ce, Ue) {
    if (isNaN(se) || isNaN(Ae) || isNaN(Ce) || isNaN(Ue))
      throw Ki.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!L.call(this)) {
      var qe = {};
      this.lineCap !== "butt" && (qe.lineCap = this.lineCap, this.lineCap = "butt"), this.lineJoin !== "miter" && (qe.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(se, Ae, Ce, Ue), this.fill(), qe.hasOwnProperty("lineCap") && (this.lineCap = qe.lineCap), qe.hasOwnProperty("lineJoin") && (this.lineJoin = qe.lineJoin);
    }
  }, T.prototype.strokeRect = function(se, Ae, Ce, Ue) {
    if (isNaN(se) || isNaN(Ae) || isNaN(Ce) || isNaN(Ue))
      throw Ki.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    N.call(this) || (this.beginPath(), this.rect(se, Ae, Ce, Ue), this.stroke());
  }, T.prototype.clearRect = function(se, Ae, Ce, Ue) {
    if (isNaN(se) || isNaN(Ae) || isNaN(Ce) || isNaN(Ue))
      throw Ki.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(se, Ae, Ce, Ue));
  }, T.prototype.save = function(se) {
    se = typeof se != "boolean" || se;
    for (var Ae = this.pdf.internal.getCurrentPageInfo().pageNumber, Ce = 0; Ce < this.pdf.internal.getNumberOfPages(); Ce++)
      this.pdf.setPage(Ce + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(Ae), se) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var Ue = new A(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = Ue;
    }
  }, T.prototype.restore = function(se) {
    se = typeof se != "boolean" || se;
    for (var Ae = this.pdf.internal.getCurrentPageInfo().pageNumber, Ce = 0; Ce < this.pdf.internal.getNumberOfPages(); Ce++)
      this.pdf.setPage(Ce + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(Ae), se && this.ctxStack.length !== 0 && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, T.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var I = function(se) {
    var Ae, Ce, Ue, qe;
    if (se.isCanvasGradient === !0 && (se = se.getColor()), !se)
      return { r: 0, g: 0, b: 0, a: 0, style: se };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(se))
      Ae = 0, Ce = 0, Ue = 0, qe = 0;
    else {
      var We = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(se);
      if (We !== null)
        Ae = parseInt(We[1]), Ce = parseInt(We[2]), Ue = parseInt(We[3]), qe = 1;
      else if ((We = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(se)) !== null)
        Ae = parseInt(We[1]), Ce = parseInt(We[2]), Ue = parseInt(We[3]), qe = parseFloat(We[4]);
      else {
        if (qe = 1, typeof se == "string" && se.charAt(0) !== "#") {
          var Ke = new gT(se);
          se = Ke.ok ? Ke.toHex() : "#000000";
        }
        se.length === 4 ? (Ae = se.substring(1, 2), Ae += Ae, Ce = se.substring(2, 3), Ce += Ce, Ue = se.substring(3, 4), Ue += Ue) : (Ae = se.substring(1, 3), Ce = se.substring(3, 5), Ue = se.substring(5, 7)), Ae = parseInt(Ae, 16), Ce = parseInt(Ce, 16), Ue = parseInt(Ue, 16);
      }
    }
    return { r: Ae, g: Ce, b: Ue, a: qe, style: se };
  }, L = function() {
    return this.ctx.isFillTransparent || this.globalAlpha == 0;
  }, N = function() {
    return !!(this.ctx.isStrokeTransparent || this.globalAlpha == 0);
  };
  T.prototype.fillText = function(se, Ae, Ce, Ue) {
    if (isNaN(Ae) || isNaN(Ce) || typeof se != "string")
      throw Ki.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (Ue = isNaN(Ue) ? void 0 : Ue, !L.call(this)) {
      var qe = Ye(this.ctx.transform.rotation), We = this.ctx.transform.scaleX;
      de.call(this, { text: se, x: Ae, y: Ce, scale: We, angle: qe, align: this.textAlign, maxWidth: Ue });
    }
  }, T.prototype.strokeText = function(se, Ae, Ce, Ue) {
    if (isNaN(Ae) || isNaN(Ce) || typeof se != "string")
      throw Ki.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!N.call(this)) {
      Ue = isNaN(Ue) ? void 0 : Ue;
      var qe = Ye(this.ctx.transform.rotation), We = this.ctx.transform.scaleX;
      de.call(this, { text: se, x: Ae, y: Ce, scale: We, renderingMode: "stroke", angle: qe, align: this.textAlign, maxWidth: Ue });
    }
  }, T.prototype.measureText = function(se) {
    if (typeof se != "string")
      throw Ki.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var Ae = this.pdf, Ce = this.pdf.internal.scaleFactor, Ue = Ae.internal.getFontSize(), qe = Ae.getStringUnitWidth(se) * Ue / Ae.internal.scaleFactor, We = function(Ke) {
      var Ze = (Ke = Ke || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return Ze;
      } }), this;
    };
    return new We({ width: qe *= Math.round(96 * Ce / 72 * 1e4) / 1e4 });
  }, T.prototype.scale = function(se, Ae) {
    if (isNaN(se) || isNaN(Ae))
      throw Ki.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var Ce = new m(se, 0, 0, Ae, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(Ce);
  }, T.prototype.rotate = function(se) {
    if (isNaN(se))
      throw Ki.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var Ae = new m(Math.cos(se), Math.sin(se), -Math.sin(se), Math.cos(se), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(Ae);
  }, T.prototype.translate = function(se, Ae) {
    if (isNaN(se) || isNaN(Ae))
      throw Ki.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var Ce = new m(1, 0, 0, 1, se, Ae);
    this.ctx.transform = this.ctx.transform.multiply(Ce);
  }, T.prototype.transform = function(se, Ae, Ce, Ue, qe, We) {
    if (isNaN(se) || isNaN(Ae) || isNaN(Ce) || isNaN(Ue) || isNaN(qe) || isNaN(We))
      throw Ki.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var Ke = new m(se, Ae, Ce, Ue, qe, We);
    this.ctx.transform = this.ctx.transform.multiply(Ke);
  }, T.prototype.setTransform = function(se, Ae, Ce, Ue, qe, We) {
    se = isNaN(se) ? 1 : se, Ae = isNaN(Ae) ? 0 : Ae, Ce = isNaN(Ce) ? 0 : Ce, Ue = isNaN(Ue) ? 1 : Ue, qe = isNaN(qe) ? 0 : qe, We = isNaN(We) ? 0 : We, this.ctx.transform = new m(se, Ae, Ce, Ue, qe, We);
  };
  var z = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  T.prototype.drawImage = function(se, Ae, Ce, Ue, qe, We, Ke, Ze, At) {
    var It = this.pdf.getImageProperties(se), Rt = 1, kt = 1, on = 1, ut = 1;
    Ue !== void 0 && Ze !== void 0 && (on = Ze / Ue, ut = At / qe, Rt = It.width / Ue * Ze / Ue, kt = It.height / qe * At / qe), We === void 0 && (We = Ae, Ke = Ce, Ae = 0, Ce = 0), Ue !== void 0 && Ze === void 0 && (Ze = Ue, At = qe), Ue === void 0 && Ze === void 0 && (Ze = It.width, At = It.height);
    for (var re, mn = this.ctx.transform.decompose(), Qt = Ye(mn.rotate.shx), pt = new m(), Et = (pt = (pt = (pt = pt.multiply(mn.translate)).multiply(mn.skew)).multiply(mn.scale)).applyToRectangle(new l(We - Ae * on, Ke - Ce * ut, Ue * Rt, qe * kt)), Lt = V.call(this, Et), Ft = [], nn = 0; nn < Lt.length; nn += 1)
      Ft.indexOf(Lt[nn]) === -1 && Ft.push(Lt[nn]);
    if (ce(Ft), this.autoPaging)
      for (var Tn = Ft[0], xn = Ft[Ft.length - 1], On = Tn; On < xn + 1; On++) {
        this.pdf.setPage(On);
        var Un = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], mt = On === 1 ? this.posY + this.margin[0] : this.margin[0], hn = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], wn = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], Bt = On === 1 ? 0 : hn + (On - 2) * wn;
        if (this.ctx.clip_path.length !== 0) {
          var bi = this.path;
          re = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = J(re, this.posX + this.margin[3], -Bt + mt + this.ctx.prevPageLastElemOffset), Se.call(this, "fill", !0), this.path = bi;
        }
        var _t = JSON.parse(JSON.stringify(Et));
        _t = J([_t], this.posX + this.margin[3], -Bt + mt + this.ctx.prevPageLastElemOffset)[0];
        var bn = (On > Tn || On < xn) && z.call(this);
        bn && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], Un, wn, null).clip().discardPath()), this.pdf.addImage(se, "JPEG", _t.x, _t.y, _t.w, _t.h, null, null, Qt), bn && this.pdf.restoreGraphicsState();
      }
    else
      this.pdf.addImage(se, "JPEG", Et.x, Et.y, Et.w, Et.h, null, null, Qt);
  };
  var V = function(se, Ae, Ce) {
    var Ue = [];
    Ae = Ae || this.pdf.internal.pageSize.width, Ce = Ce || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var qe = this.posY + this.ctx.prevPageLastElemOffset;
    switch (se.type) {
      default:
      case "mt":
      case "lt":
        Ue.push(Math.floor((se.y + qe) / Ce) + 1);
        break;
      case "arc":
        Ue.push(Math.floor((se.y + qe - se.radius) / Ce) + 1), Ue.push(Math.floor((se.y + qe + se.radius) / Ce) + 1);
        break;
      case "qct":
        var We = ht(this.ctx.lastPoint.x, this.ctx.lastPoint.y, se.x1, se.y1, se.x, se.y);
        Ue.push(Math.floor((We.y + qe) / Ce) + 1), Ue.push(Math.floor((We.y + We.h + qe) / Ce) + 1);
        break;
      case "bct":
        var Ke = ct(this.ctx.lastPoint.x, this.ctx.lastPoint.y, se.x1, se.y1, se.x2, se.y2, se.x, se.y);
        Ue.push(Math.floor((Ke.y + qe) / Ce) + 1), Ue.push(Math.floor((Ke.y + Ke.h + qe) / Ce) + 1);
        break;
      case "rect":
        Ue.push(Math.floor((se.y + qe) / Ce) + 1), Ue.push(Math.floor((se.y + se.h + qe) / Ce) + 1);
    }
    for (var Ze = 0; Ze < Ue.length; Ze += 1)
      for (; this.pdf.internal.getNumberOfPages() < Ue[Ze]; )
        H.call(this);
    return Ue;
  }, H = function() {
    var se = this.fillStyle, Ae = this.strokeStyle, Ce = this.font, Ue = this.lineCap, qe = this.lineWidth, We = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = se, this.strokeStyle = Ae, this.font = Ce, this.lineCap = Ue, this.lineWidth = qe, this.lineJoin = We;
  }, J = function(se, Ae, Ce) {
    for (var Ue = 0; Ue < se.length; Ue++)
      switch (se[Ue].type) {
        case "bct":
          se[Ue].x2 += Ae, se[Ue].y2 += Ce;
        case "qct":
          se[Ue].x1 += Ae, se[Ue].y1 += Ce;
        case "mt":
        case "lt":
        case "arc":
        default:
          se[Ue].x += Ae, se[Ue].y += Ce;
      }
    return se;
  }, ce = function(se) {
    return se.sort(function(Ae, Ce) {
      return Ae - Ce;
    });
  }, me = function(se, Ae) {
    for (var Ce, Ue, qe = this.fillStyle, We = this.strokeStyle, Ke = this.lineCap, Ze = this.lineWidth, At = Math.abs(Ze * this.ctx.transform.scaleX), It = this.lineJoin, Rt = JSON.parse(JSON.stringify(this.path)), kt = JSON.parse(JSON.stringify(this.path)), on = [], ut = 0; ut < kt.length; ut++)
      if (kt[ut].x !== void 0)
        for (var re = V.call(this, kt[ut]), mn = 0; mn < re.length; mn += 1)
          on.indexOf(re[mn]) === -1 && on.push(re[mn]);
    for (var Qt = 0; Qt < on.length; Qt++)
      for (; this.pdf.internal.getNumberOfPages() < on[Qt]; )
        H.call(this);
    if (ce(on), this.autoPaging)
      for (var pt = on[0], Et = on[on.length - 1], Lt = pt; Lt < Et + 1; Lt++) {
        this.pdf.setPage(Lt), this.fillStyle = qe, this.strokeStyle = We, this.lineCap = Ke, this.lineWidth = At, this.lineJoin = It;
        var Ft = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], nn = Lt === 1 ? this.posY + this.margin[0] : this.margin[0], Tn = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], xn = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], On = Lt === 1 ? 0 : Tn + (Lt - 2) * xn;
        if (this.ctx.clip_path.length !== 0) {
          var Un = this.path;
          Ce = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = J(Ce, this.posX + this.margin[3], -On + nn + this.ctx.prevPageLastElemOffset), Se.call(this, se, !0), this.path = Un;
        }
        if (Ue = JSON.parse(JSON.stringify(Rt)), this.path = J(Ue, this.posX + this.margin[3], -On + nn + this.ctx.prevPageLastElemOffset), Ae === !1 || Lt === 0) {
          var mt = (Lt > pt || Lt < Et) && z.call(this);
          mt && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], Ft, xn, null).clip().discardPath()), Se.call(this, se, Ae), mt && this.pdf.restoreGraphicsState();
        }
        this.lineWidth = Ze;
      }
    else
      this.lineWidth = At, Se.call(this, se, Ae), this.lineWidth = Ze;
    this.path = Rt;
  }, Se = function(se, Ae) {
    if ((se !== "stroke" || Ae || !N.call(this)) && (se === "stroke" || Ae || !L.call(this))) {
      for (var Ce, Ue, qe = [], We = this.path, Ke = 0; Ke < We.length; Ke++) {
        var Ze = We[Ke];
        switch (Ze.type) {
          case "begin":
            qe.push({ begin: !0 });
            break;
          case "close":
            qe.push({ close: !0 });
            break;
          case "mt":
            qe.push({ start: Ze, deltas: [], abs: [] });
            break;
          case "lt":
            var At = qe.length;
            if (We[Ke - 1] && !isNaN(We[Ke - 1].x) && (Ce = [Ze.x - We[Ke - 1].x, Ze.y - We[Ke - 1].y], At > 0)) {
              for (; At >= 0; At--)
                if (qe[At - 1].close !== !0 && qe[At - 1].begin !== !0) {
                  qe[At - 1].deltas.push(Ce), qe[At - 1].abs.push(Ze);
                  break;
                }
            }
            break;
          case "bct":
            Ce = [Ze.x1 - We[Ke - 1].x, Ze.y1 - We[Ke - 1].y, Ze.x2 - We[Ke - 1].x, Ze.y2 - We[Ke - 1].y, Ze.x - We[Ke - 1].x, Ze.y - We[Ke - 1].y], qe[qe.length - 1].deltas.push(Ce);
            break;
          case "qct":
            var It = We[Ke - 1].x + 2 / 3 * (Ze.x1 - We[Ke - 1].x), Rt = We[Ke - 1].y + 2 / 3 * (Ze.y1 - We[Ke - 1].y), kt = Ze.x + 2 / 3 * (Ze.x1 - Ze.x), on = Ze.y + 2 / 3 * (Ze.y1 - Ze.y), ut = Ze.x, re = Ze.y;
            Ce = [It - We[Ke - 1].x, Rt - We[Ke - 1].y, kt - We[Ke - 1].x, on - We[Ke - 1].y, ut - We[Ke - 1].x, re - We[Ke - 1].y], qe[qe.length - 1].deltas.push(Ce);
            break;
          case "arc":
            qe.push({ deltas: [], abs: [], arc: !0 }), Array.isArray(qe[qe.length - 1].abs) && qe[qe.length - 1].abs.push(Ze);
        }
      }
      Ue = Ae ? null : se === "stroke" ? "stroke" : "fill";
      for (var mn = !1, Qt = 0; Qt < qe.length; Qt++)
        if (qe[Qt].arc)
          for (var pt = qe[Qt].abs, Et = 0; Et < pt.length; Et++) {
            var Lt = pt[Et];
            Lt.type === "arc" ? ye.call(this, Lt.x, Lt.y, Lt.radius, Lt.startAngle, Lt.endAngle, Lt.counterclockwise, void 0, Ae, !mn) : Te.call(this, Lt.x, Lt.y), mn = !0;
          }
        else if (qe[Qt].close === !0)
          this.pdf.internal.out("h"), mn = !1;
        else if (qe[Qt].begin !== !0) {
          var Ft = qe[Qt].start.x, nn = qe[Qt].start.y;
          be.call(this, qe[Qt].deltas, Ft, nn), mn = !0;
        }
      Ue && Ve.call(this, Ue), Ae && Fe.call(this);
    }
  }, De = function(se) {
    var Ae = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, Ce = Ae * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return se - Ce;
      case "top":
        return se + Ae - Ce;
      case "hanging":
        return se + Ae - 2 * Ce;
      case "middle":
        return se + Ae / 2 - Ce;
      case "ideographic":
        return se;
      case "alphabetic":
      default:
        return se;
    }
  }, Le = function(se) {
    return se + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  T.prototype.createLinearGradient = function() {
    var se = function() {
    };
    return se.colorStops = [], se.addColorStop = function(Ae, Ce) {
      this.colorStops.push([Ae, Ce]);
    }, se.getColor = function() {
      return this.colorStops.length === 0 ? "#000000" : this.colorStops[0][1];
    }, se.isCanvasGradient = !0, se;
  }, T.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, T.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var ye = function(se, Ae, Ce, Ue, qe, We, Ke, Ze, At) {
    for (var It = st.call(this, Ce, Ue, qe, We), Rt = 0; Rt < It.length; Rt++) {
      var kt = It[Rt];
      Rt === 0 && (At ? ae.call(this, kt.x1 + se, kt.y1 + Ae) : Te.call(this, kt.x1 + se, kt.y1 + Ae)), tt.call(this, se, Ae, kt.x2, kt.y2, kt.x3, kt.y3, kt.x4, kt.y4);
    }
    Ze ? Fe.call(this) : Ve.call(this, Ke);
  }, Ve = function(se) {
    switch (se) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, Fe = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, ae = function(se, Ae) {
    this.pdf.internal.out(t(se) + " " + i(Ae) + " m");
  }, de = function(se) {
    var Ae;
    switch (se.align) {
      case "right":
      case "end":
        Ae = "right";
        break;
      case "center":
        Ae = "center";
        break;
      case "left":
      case "start":
      default:
        Ae = "left";
    }
    var Ce = this.pdf.getTextDimensions(se.text), Ue = De.call(this, se.y), qe = Le.call(this, Ue) - Ce.h, We = this.ctx.transform.applyToPoint(new c(se.x, Ue)), Ke = this.ctx.transform.decompose(), Ze = new m();
    Ze = (Ze = (Ze = Ze.multiply(Ke.translate)).multiply(Ke.skew)).multiply(Ke.scale);
    for (var At, It, Rt, kt = this.ctx.transform.applyToRectangle(new l(se.x, Ue, Ce.w, Ce.h)), on = Ze.applyToRectangle(new l(se.x, qe, Ce.w, Ce.h)), ut = V.call(this, on), re = [], mn = 0; mn < ut.length; mn += 1)
      re.indexOf(ut[mn]) === -1 && re.push(ut[mn]);
    if (ce(re), this.autoPaging)
      for (var Qt = re[0], pt = re[re.length - 1], Et = Qt; Et < pt + 1; Et++) {
        this.pdf.setPage(Et);
        var Lt = Et === 1 ? this.posY + this.margin[0] : this.margin[0], Ft = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], nn = this.pdf.internal.pageSize.height - this.margin[2], Tn = nn - this.margin[0], xn = this.pdf.internal.pageSize.width - this.margin[1], On = xn - this.margin[3], Un = Et === 1 ? 0 : Ft + (Et - 2) * Tn;
        if (this.ctx.clip_path.length !== 0) {
          var mt = this.path;
          At = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = J(At, this.posX + this.margin[3], -1 * Un + Lt), Se.call(this, "fill", !0), this.path = mt;
        }
        var hn = J([JSON.parse(JSON.stringify(on))], this.posX + this.margin[3], -Un + Lt + this.ctx.prevPageLastElemOffset)[0];
        se.scale >= 0.01 && (It = this.pdf.internal.getFontSize(), this.pdf.setFontSize(It * se.scale), Rt = this.lineWidth, this.lineWidth = Rt * se.scale);
        var wn = this.autoPaging !== "text";
        if (wn || hn.y + hn.h <= nn) {
          if (wn || hn.y >= Lt && hn.x <= xn) {
            var Bt = wn ? se.text : this.pdf.splitTextToSize(se.text, se.maxWidth || xn - hn.x)[0], bi = J([JSON.parse(JSON.stringify(kt))], this.posX + this.margin[3], -Un + Lt + this.ctx.prevPageLastElemOffset)[0], _t = wn && (Et > Qt || Et < pt) && z.call(this);
            _t && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], On, Tn, null).clip().discardPath()), this.pdf.text(Bt, bi.x, bi.y, { angle: se.angle, align: Ae, renderingMode: se.renderingMode }), _t && this.pdf.restoreGraphicsState();
          }
        } else
          hn.y < nn && (this.ctx.prevPageLastElemOffset += nn - hn.y);
        se.scale >= 0.01 && (this.pdf.setFontSize(It), this.lineWidth = Rt);
      }
    else
      se.scale >= 0.01 && (It = this.pdf.internal.getFontSize(), this.pdf.setFontSize(It * se.scale), Rt = this.lineWidth, this.lineWidth = Rt * se.scale), this.pdf.text(se.text, We.x + this.posX, We.y + this.posY, { angle: se.angle, align: Ae, renderingMode: se.renderingMode, maxWidth: se.maxWidth }), se.scale >= 0.01 && (this.pdf.setFontSize(It), this.lineWidth = Rt);
  }, Te = function(se, Ae, Ce, Ue) {
    Ce = Ce || 0, Ue = Ue || 0, this.pdf.internal.out(t(se + Ce) + " " + i(Ae + Ue) + " l");
  }, be = function(se, Ae, Ce) {
    return this.pdf.lines(se, Ae, Ce, null, null);
  }, tt = function(se, Ae, Ce, Ue, qe, We, Ke, Ze) {
    this.pdf.internal.out([e(r(Ce + se)), e(s(Ue + Ae)), e(r(qe + se)), e(s(We + Ae)), e(r(Ke + se)), e(s(Ze + Ae)), "c"].join(" "));
  }, st = function(se, Ae, Ce, Ue) {
    for (var qe = 2 * Math.PI, We = Math.PI / 2; Ae > Ce; )
      Ae -= qe;
    var Ke = Math.abs(Ce - Ae);
    Ke < qe && Ue && (Ke = qe - Ke);
    for (var Ze = [], At = Ue ? -1 : 1, It = Ae; Ke > 1e-5; ) {
      var Rt = It + At * Math.min(Ke, We);
      Ze.push(lt.call(this, se, It, Rt)), Ke -= Math.abs(Rt - It), It = Rt;
    }
    return Ze;
  }, lt = function(se, Ae, Ce) {
    var Ue = (Ce - Ae) / 2, qe = se * Math.cos(Ue), We = se * Math.sin(Ue), Ke = qe, Ze = -We, At = Ke * Ke + Ze * Ze, It = At + Ke * qe + Ze * We, Rt = 4 / 3 * (Math.sqrt(2 * At * It) - It) / (Ke * We - Ze * qe), kt = Ke - Rt * Ze, on = Ze + Rt * Ke, ut = kt, re = -on, mn = Ue + Ae, Qt = Math.cos(mn), pt = Math.sin(mn);
    return { x1: se * Math.cos(Ae), y1: se * Math.sin(Ae), x2: kt * Qt - on * pt, y2: kt * pt + on * Qt, x3: ut * Qt - re * pt, y3: ut * pt + re * Qt, x4: se * Math.cos(Ce), y4: se * Math.sin(Ce) };
  }, Ye = function(se) {
    return 180 * se / Math.PI;
  }, ht = function(se, Ae, Ce, Ue, qe, We) {
    var Ke = se + 0.5 * (Ce - se), Ze = Ae + 0.5 * (Ue - Ae), At = qe + 0.5 * (Ce - qe), It = We + 0.5 * (Ue - We), Rt = Math.min(se, qe, Ke, At), kt = Math.max(se, qe, Ke, At), on = Math.min(Ae, We, Ze, It), ut = Math.max(Ae, We, Ze, It);
    return new l(Rt, on, kt - Rt, ut - on);
  }, ct = function(se, Ae, Ce, Ue, qe, We, Ke, Ze) {
    var At, It, Rt, kt, on, ut, re, mn, Qt, pt, Et, Lt, Ft, nn, Tn = Ce - se, xn = Ue - Ae, On = qe - Ce, Un = We - Ue, mt = Ke - qe, hn = Ze - We;
    for (It = 0; It < 41; It++)
      Qt = (re = (Rt = se + (At = It / 40) * Tn) + At * ((on = Ce + At * On) - Rt)) + At * (on + At * (qe + At * mt - on) - re), pt = (mn = (kt = Ae + At * xn) + At * ((ut = Ue + At * Un) - kt)) + At * (ut + At * (We + At * hn - ut) - mn), It == 0 ? (Et = Qt, Lt = pt, Ft = Qt, nn = pt) : (Et = Math.min(Et, Qt), Lt = Math.min(Lt, pt), Ft = Math.max(Ft, Qt), nn = Math.max(nn, pt));
    return new l(Math.round(Et), Math.round(Lt), Math.round(Ft - Et), Math.round(nn - Lt));
  }, Pt = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var se, Ae, Ce = (se = this.ctx.lineDash, Ae = this.ctx.lineDashOffset, JSON.stringify({ lineDash: se, lineDashOffset: Ae }));
      this.prevLineDash !== Ce && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = Ce);
    }
  };
})(Bn.API), /**
* @license
* jsPDF filters PlugIn
* Copyright (c) 2014 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  var e = function(s) {
    var c, l, m, y, A, T, I, L, N, z;
    for (l = [], m = 0, y = (s += c = "\0\0\0\0".slice(s.length % 4 || 4)).length; y > m; m += 4)
      (A = (s.charCodeAt(m) << 24) + (s.charCodeAt(m + 1) << 16) + (s.charCodeAt(m + 2) << 8) + s.charCodeAt(m + 3)) !== 0 ? (T = (A = ((A = ((A = ((A = (A - (z = A % 85)) / 85) - (N = A % 85)) / 85) - (L = A % 85)) / 85) - (I = A % 85)) / 85) % 85, l.push(T + 33, I + 33, L + 33, N + 33, z + 33)) : l.push(122);
    return function(V, H) {
      for (var J = H; J > 0; J--)
        V.pop();
    }(l, c.length), String.fromCharCode.apply(String, l) + "~>";
  }, t = function(s) {
    var c, l, m, y, A, T = String, I = "length", L = 255, N = "charCodeAt", z = "slice", V = "replace";
    for (s[z](-2), s = s[z](0, -2)[V](/\s/g, "")[V]("z", "!!!!!"), m = [], y = 0, A = (s += c = "uuuuu"[z](s[I] % 5 || 5))[I]; A > y; y += 5)
      l = 52200625 * (s[N](y) - 33) + 614125 * (s[N](y + 1) - 33) + 7225 * (s[N](y + 2) - 33) + 85 * (s[N](y + 3) - 33) + (s[N](y + 4) - 33), m.push(L & l >> 24, L & l >> 16, L & l >> 8, L & l);
    return function(H, J) {
      for (var ce = J; ce > 0; ce--)
        H.pop();
    }(m, c[I]), T.fromCharCode.apply(T, m);
  }, i = function(s) {
    var c = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if ((s = s.replace(/\s/g, "")).indexOf(">") !== -1 && (s = s.substr(0, s.indexOf(">"))), s.length % 2 && (s += "0"), c.test(s) === !1)
      return "";
    for (var l = "", m = 0; m < s.length; m += 2)
      l += String.fromCharCode("0x" + (s[m] + s[m + 1]));
    return l;
  }, r = function(s) {
    for (var c = new Uint8Array(s.length), l = s.length; l--; )
      c[l] = s.charCodeAt(l);
    return s = (c = Xy(c)).reduce(function(m, y) {
      return m + String.fromCharCode(y);
    }, "");
  };
  n.processDataByFilters = function(s, c) {
    var l = 0, m = s || "", y = [];
    for (typeof (c = c || []) == "string" && (c = [c]), l = 0; l < c.length; l += 1)
      switch (c[l]) {
        case "ASCII85Decode":
        case "/ASCII85Decode":
          m = t(m), y.push("/ASCII85Encode");
          break;
        case "ASCII85Encode":
        case "/ASCII85Encode":
          m = e(m), y.push("/ASCII85Decode");
          break;
        case "ASCIIHexDecode":
        case "/ASCIIHexDecode":
          m = i(m), y.push("/ASCIIHexEncode");
          break;
        case "ASCIIHexEncode":
        case "/ASCIIHexEncode":
          m = m.split("").map(function(A) {
            return ("0" + A.charCodeAt().toString(16)).slice(-2);
          }).join("") + ">", y.push("/ASCIIHexDecode");
          break;
        case "FlateEncode":
        case "/FlateEncode":
          m = r(m), y.push("/FlateDecode");
          break;
        default:
          throw new Error('The filter: "' + c[l] + '" is not implemented');
      }
    return { data: m, reverseChain: y.reverse().join(" ") };
  };
}(Bn.API), /**
* @license
* jsPDF fileloading PlugIn
* Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  n.loadFile = function(e, t, i) {
    return function(r, s, c) {
      s = s !== !1, c = typeof c == "function" ? c : function() {
      };
      var l = void 0;
      try {
        l = function(m, y, A) {
          var T = new XMLHttpRequest(), I = 0, L = function(N) {
            var z = N.length, V = [], H = String.fromCharCode;
            for (I = 0; I < z; I += 1)
              V.push(H(255 & N.charCodeAt(I)));
            return V.join("");
          };
          if (T.open("GET", m, !y), T.overrideMimeType("text/plain; charset=x-user-defined"), y === !1 && (T.onload = function() {
            T.status === 200 ? A(L(this.responseText)) : A(void 0);
          }), T.send(null), y && T.status === 200)
            return L(T.responseText);
        }(r, s, c);
      } catch {
      }
      return l;
    }(e, t, i);
  }, n.loadImageFile = n.loadFile;
}(Bn.API), function(n) {
  function e() {
    return (Rn.html2canvas ? Promise.resolve(Rn.html2canvas) : import("./html2canvas.esm-CKxSAI8P-DSC9_HHp.mjs")).catch(function(c) {
      return Promise.reject(new Error("Could not load html2canvas: " + c));
    }).then(function(c) {
      return c.default ? c.default : c;
    });
  }
  function t() {
    return (Rn.DOMPurify ? Promise.resolve(Rn.DOMPurify) : import("./purify.es-CLxMp-4V-DmiRgNNX.mjs")).catch(function(c) {
      return Promise.reject(new Error("Could not load dompurify: " + c));
    }).then(function(c) {
      return c.default ? c.default : c;
    });
  }
  var i = function(c) {
    var l = zi(c);
    return l === "undefined" ? "undefined" : l === "string" || c instanceof String ? "string" : l === "number" || c instanceof Number ? "number" : l === "function" || c instanceof Function ? "function" : c && c.constructor === Array ? "array" : c && c.nodeType === 1 ? "element" : l === "object" ? "object" : "unknown";
  }, r = function(c, l) {
    var m = document.createElement(c);
    for (var y in l.className && (m.className = l.className), l.innerHTML && l.dompurify && (m.innerHTML = l.dompurify.sanitize(l.innerHTML)), l.style)
      m.style[y] = l.style[y];
    return m;
  }, s = function c(l) {
    var m = Object.assign(c.convert(Promise.resolve()), JSON.parse(JSON.stringify(c.template))), y = c.convert(Promise.resolve(), m);
    return y = (y = y.setProgress(1, c, 1, [c])).set(l);
  };
  (s.prototype = Object.create(Promise.prototype)).constructor = s, s.convert = function(c, l) {
    return c.__proto__ = l || s.prototype, c;
  }, s.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: !0, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, s.prototype.from = function(c, l) {
    return this.then(function() {
      switch (l = l || function(m) {
        switch (i(m)) {
          case "string":
            return "string";
          case "element":
            return m.nodeName.toLowerCase() === "canvas" ? "canvas" : "element";
          default:
            return "unknown";
        }
      }(c)) {
        case "string":
          return this.then(t).then(function(m) {
            return this.set({ src: r("div", { innerHTML: c, dompurify: m }) });
          });
        case "element":
          return this.set({ src: c });
        case "canvas":
          return this.set({ canvas: c });
        case "img":
          return this.set({ img: c });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, s.prototype.to = function(c) {
    switch (c) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, s.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var c = { position: "relative", display: "inline-block", width: (typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, l = function m(y, A) {
        for (var T = y.nodeType === 3 ? document.createTextNode(y.nodeValue) : y.cloneNode(!1), I = y.firstChild; I; I = I.nextSibling)
          A !== !0 && I.nodeType === 1 && I.nodeName === "SCRIPT" || T.appendChild(m(I, A));
        return y.nodeType === 1 && (y.nodeName === "CANVAS" ? (T.width = y.width, T.height = y.height, T.getContext("2d").drawImage(y, 0, 0)) : y.nodeName !== "TEXTAREA" && y.nodeName !== "SELECT" || (T.value = y.value), T.addEventListener("load", function() {
          T.scrollTop = y.scrollTop, T.scrollLeft = y.scrollLeft;
        }, !0)), T;
      }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      l.tagName === "BODY" && (c.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = r("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = r("div", { className: "html2pdf__container", style: c }), this.prop.container.appendChild(l), this.prop.container.firstChild.appendChild(r("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, s.prototype.toCanvas = function() {
    var c = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(c).then(e).then(function(l) {
      var m = Object.assign({}, this.opt.html2canvas);
      return delete m.onrendered, l(this.prop.container, m);
    }).then(function(l) {
      (this.opt.html2canvas.onrendered || function() {
      })(l), this.prop.canvas = l, document.body.removeChild(this.prop.overlay);
    });
  }, s.prototype.toContext2d = function() {
    var c = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(c).then(e).then(function(l) {
      var m = this.opt.jsPDF, y = this.opt.fontFaces, A = typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, T = Object.assign({ async: !0, allowTaint: !0, scale: A, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: !0, proxy: null, removeContainer: !0, foreignObjectRendering: !1, useCORS: !1 }, this.opt.html2canvas);
      if (delete T.onrendered, m.context2d.autoPaging = this.opt.autoPaging === void 0 || this.opt.autoPaging, m.context2d.posX = this.opt.x, m.context2d.posY = this.opt.y, m.context2d.margin = this.opt.margin, m.context2d.fontFaces = y, y)
        for (var I = 0; I < y.length; ++I) {
          var L = y[I], N = L.src.find(function(z) {
            return z.format === "truetype";
          });
          N && m.addFont(N.url, L.ref.name, L.ref.style);
        }
      return T.windowHeight = T.windowHeight || 0, T.windowHeight = T.windowHeight == 0 ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : T.windowHeight, m.context2d.save(!0), l(this.prop.container, T);
    }).then(function(l) {
      this.opt.jsPDF.context2d.restore(!0), (this.opt.html2canvas.onrendered || function() {
      })(l), this.prop.canvas = l, document.body.removeChild(this.prop.overlay);
    });
  }, s.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var c = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = c;
    });
  }, s.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, s.prototype.output = function(c, l, m) {
    return (m = m || "pdf").toLowerCase() === "img" || m.toLowerCase() === "image" ? this.outputImg(c, l) : this.outputPdf(c, l);
  }, s.prototype.outputPdf = function(c, l) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(c, l);
    });
  }, s.prototype.outputImg = function(c) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (c) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + c + '" is not supported.';
      }
    });
  }, s.prototype.save = function(c) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(c ? { filename: c } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, s.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, s.prototype.set = function(c) {
    if (i(c) !== "object")
      return this;
    var l = Object.keys(c || {}).map(function(m) {
      if (m in s.template.prop)
        return function() {
          this.prop[m] = c[m];
        };
      switch (m) {
        case "margin":
          return this.setMargin.bind(this, c.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = c.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, c.pageSize);
        default:
          return function() {
            this.opt[m] = c[m];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(l);
    });
  }, s.prototype.get = function(c, l) {
    return this.then(function() {
      var m = c in s.template.prop ? this.prop[c] : this.opt[c];
      return l ? l(m) : m;
    });
  }, s.prototype.setMargin = function(c) {
    return this.then(function() {
      switch (i(c)) {
        case "number":
          c = [c, c, c, c];
        case "array":
          if (c.length === 2 && (c = [c[0], c[1], c[0], c[1]]), c.length === 4)
            break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = c;
    }).then(this.setPageSize);
  }, s.prototype.setPageSize = function(c) {
    function l(m, y) {
      return Math.floor(m * y / 72 * 96);
    }
    return this.then(function() {
      (c = c || Bn.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (c.inner = { width: c.width - this.opt.margin[1] - this.opt.margin[3], height: c.height - this.opt.margin[0] - this.opt.margin[2] }, c.inner.px = { width: l(c.inner.width, c.k), height: l(c.inner.height, c.k) }, c.inner.ratio = c.inner.height / c.inner.width), this.prop.pageSize = c;
    });
  }, s.prototype.setProgress = function(c, l, m, y) {
    return c != null && (this.progress.val = c), l != null && (this.progress.state = l), m != null && (this.progress.n = m), y != null && (this.progress.stack = y), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, s.prototype.updateProgress = function(c, l, m, y) {
    return this.setProgress(c ? this.progress.val + c : null, l || null, m ? this.progress.n + m : null, y ? this.progress.stack.concat(y) : null);
  }, s.prototype.then = function(c, l) {
    var m = this;
    return this.thenCore(c, l, function(y, A) {
      return m.updateProgress(null, null, 1, [y]), Promise.prototype.then.call(this, function(T) {
        return m.updateProgress(null, y), T;
      }).then(y, A).then(function(T) {
        return m.updateProgress(1), T;
      });
    });
  }, s.prototype.thenCore = function(c, l, m) {
    m = m || Promise.prototype.then, c && (c = c.bind(this)), l && (l = l.bind(this));
    var y = Promise.toString().indexOf("[native code]") !== -1 && Promise.name === "Promise" ? this : s.convert(Object.assign({}, this), Promise.prototype), A = m.call(y, c, l);
    return s.convert(A, this.__proto__);
  }, s.prototype.thenExternal = function(c, l) {
    return Promise.prototype.then.call(this, c, l);
  }, s.prototype.thenList = function(c) {
    var l = this;
    return c.forEach(function(m) {
      l = l.thenCore(m);
    }), l;
  }, s.prototype.catch = function(c) {
    c && (c = c.bind(this));
    var l = Promise.prototype.catch.call(this, c);
    return s.convert(l, this);
  }, s.prototype.catchExternal = function(c) {
    return Promise.prototype.catch.call(this, c);
  }, s.prototype.error = function(c) {
    return this.then(function() {
      throw new Error(c);
    });
  }, s.prototype.using = s.prototype.set, s.prototype.saveAs = s.prototype.save, s.prototype.export = s.prototype.output, s.prototype.run = s.prototype.then, Bn.getPageSize = function(c, l, m) {
    if (zi(c) === "object") {
      var y = c;
      c = y.orientation, l = y.unit || l, m = y.format || m;
    }
    l = l || "mm", m = m || "a4", c = ("" + (c || "P")).toLowerCase();
    var A, T = ("" + m).toLowerCase(), I = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (l) {
      case "pt":
        A = 1;
        break;
      case "mm":
        A = 72 / 25.4;
        break;
      case "cm":
        A = 72 / 2.54;
        break;
      case "in":
        A = 72;
        break;
      case "px":
        A = 0.75;
        break;
      case "pc":
      case "em":
        A = 12;
        break;
      case "ex":
        A = 6;
        break;
      default:
        throw "Invalid unit: " + l;
    }
    var L, N = 0, z = 0;
    if (I.hasOwnProperty(T))
      N = I[T][1] / A, z = I[T][0] / A;
    else
      try {
        N = m[1], z = m[0];
      } catch {
        throw new Error("Invalid format: " + m);
      }
    if (c === "p" || c === "portrait")
      c = "p", z > N && (L = z, z = N, N = L);
    else {
      if (c !== "l" && c !== "landscape")
        throw "Invalid orientation: " + c;
      c = "l", N > z && (L = z, z = N, N = L);
    }
    return { width: z, height: N, unit: l, k: A, orientation: c };
  }, n.html = function(c, l) {
    (l = l || {}).callback = l.callback || function() {
    }, l.html2canvas = l.html2canvas || {}, l.html2canvas.canvas = l.html2canvas.canvas || this.canvas, l.jsPDF = l.jsPDF || this, l.fontFaces = l.fontFaces ? l.fontFaces.map(Qy) : null;
    var m = new s(l);
    return l.worker ? m : m.from(c).doCallback();
  };
}(Bn.API), Bn.API.addJS = function(n) {
  return UA = n, this.internal.events.subscribe("postPutResources", function() {
    Ng = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (Ng + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), zA = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + UA + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    Ng !== void 0 && zA !== void 0 && this.internal.out("/Names <</JavaScript " + Ng + " 0 R>>");
  }), this;
}, /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  var e;
  n.events.push(["postPutResources", function() {
    var t = this, i = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0)
      for (var r = t.outline.render().split(/\r\n/), s = 0; s < r.length; s++) {
        var c = r[s], l = i.exec(c);
        if (l != null) {
          var m = l[1];
          t.internal.newObjectDeferredBegin(m, !1);
        }
        t.internal.write(c);
      }
    if (this.outline.createNamedDestinations) {
      var y = this.internal.pages.length, A = [];
      for (s = 0; s < y; s++) {
        var T = t.internal.newObject();
        A.push(T);
        var I = t.internal.getPageInfo(s + 1);
        t.internal.write("<< /D[" + I.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var L = t.internal.newObject();
      for (t.internal.write("<< /Names [ "), s = 0; s < A.length; s++)
        t.internal.write("(page_" + (s + 1) + ")" + A[s] + " 0 R");
      t.internal.write(" ] >>", "endobj"), e = t.internal.newObject(), t.internal.write("<< /Dests " + L + " 0 R"), t.internal.write(">>", "endobj");
    }
  }]), n.events.push(["putCatalog", function() {
    this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + e + " 0 R"));
  }]), n.events.push(["initialized", function() {
    var t = this;
    t.outline = { createNamedDestinations: !1, root: { children: [] } }, t.outline.add = function(i, r, s) {
      var c = { title: r, options: s, children: [] };
      return i == null && (i = this.root), i.children.push(c), c;
    }, t.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = t, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, t.outline.genIds_r = function(i) {
      i.id = t.internal.newObjectDeferred();
      for (var r = 0; r < i.children.length; r++)
        this.genIds_r(i.children[r]);
    }, t.outline.renderRoot = function(i) {
      this.objStart(i), this.line("/Type /Outlines"), i.children.length > 0 && (this.line("/First " + this.makeRef(i.children[0])), this.line("/Last " + this.makeRef(i.children[i.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, i)), this.objEnd();
    }, t.outline.renderItems = function(i) {
      for (var r = this.ctx.pdf.internal.getVerticalCoordinateString, s = 0; s < i.children.length; s++) {
        var c = i.children[s];
        this.objStart(c), this.line("/Title " + this.makeString(c.title)), this.line("/Parent " + this.makeRef(i)), s > 0 && this.line("/Prev " + this.makeRef(i.children[s - 1])), s < i.children.length - 1 && this.line("/Next " + this.makeRef(i.children[s + 1])), c.children.length > 0 && (this.line("/First " + this.makeRef(c.children[0])), this.line("/Last " + this.makeRef(c.children[c.children.length - 1])));
        var l = this.count = this.count_r({ count: 0 }, c);
        if (l > 0 && this.line("/Count " + l), c.options && c.options.pageNumber) {
          var m = t.internal.getPageInfo(c.options.pageNumber);
          this.line("/Dest [" + m.objId + " 0 R /XYZ 0 " + r(0) + " 0]");
        }
        this.objEnd();
      }
      for (var y = 0; y < i.children.length; y++)
        this.renderItems(i.children[y]);
    }, t.outline.line = function(i) {
      this.ctx.val += i + `\r
`;
    }, t.outline.makeRef = function(i) {
      return i.id + " 0 R";
    }, t.outline.makeString = function(i) {
      return "(" + t.internal.pdfEscape(i) + ")";
    }, t.outline.objStart = function(i) {
      this.ctx.val += `\r
` + i.id + ` 0 obj\r
<<\r
`;
    }, t.outline.objEnd = function() {
      this.ctx.val += `>> \r
endobj\r
`;
    }, t.outline.count_r = function(i, r) {
      for (var s = 0; s < r.children.length; s++)
        i.count++, this.count_r(i, r.children[s]);
      return i.count;
    };
  }]);
}(Bn.API), /**
* @license
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  var e = [192, 193, 194, 195, 196, 197, 198, 199];
  n.processJPEG = function(t, i, r, s, c, l) {
    var m, y = this.decode.DCT_DECODE, A = null;
    if (typeof t == "string" || this.__addimage__.isArrayBuffer(t) || this.__addimage__.isArrayBufferView(t)) {
      switch (t = c || t, t = this.__addimage__.isArrayBuffer(t) ? new Uint8Array(t) : t, (m = function(T) {
        for (var I, L = 256 * T.charCodeAt(4) + T.charCodeAt(5), N = T.length, z = { width: 0, height: 0, numcomponents: 1 }, V = 4; V < N; V += 2) {
          if (V += L, e.indexOf(T.charCodeAt(V + 1)) !== -1) {
            I = 256 * T.charCodeAt(V + 5) + T.charCodeAt(V + 6), z = { width: 256 * T.charCodeAt(V + 7) + T.charCodeAt(V + 8), height: I, numcomponents: T.charCodeAt(V + 9) };
            break;
          }
          L = 256 * T.charCodeAt(V + 2) + T.charCodeAt(V + 3);
        }
        return z;
      }(t = this.__addimage__.isArrayBufferView(t) ? this.__addimage__.arrayBufferToBinaryString(t) : t)).numcomponents) {
        case 1:
          l = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          l = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          l = this.color_spaces.DEVICE_RGB;
      }
      A = { data: t, width: m.width, height: m.height, colorSpace: l, bitsPerComponent: 8, filter: y, index: i, alias: r };
    }
    return A;
  };
}(Bn.API);
var vd, zg, GA, VA, qA, dV = function() {
  var n, e, t;
  function i(s) {
    var c, l, m, y, A, T, I, L, N, z, V, H, J, ce;
    for (this.data = s, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, T = null; ; ) {
      switch (c = this.readUInt32(), N = (function() {
        var me, Se;
        for (Se = [], me = 0; me < 4; ++me)
          Se.push(String.fromCharCode(this.data[this.pos++]));
        return Se;
      }).call(this).join("")) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(c);
          break;
        case "fcTL":
          T && this.animation.frames.push(T), this.pos += 4, T = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, A = this.readUInt16(), y = this.readUInt16() || 100, T.delay = 1e3 * A / y, T.disposeOp = this.data[this.pos++], T.blendOp = this.data[this.pos++], T.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for (N === "fdAT" && (this.pos += 4, c -= 4), s = (T != null ? T.data : void 0) || this.imgData, H = 0; 0 <= c ? H < c : H > c; 0 <= c ? ++H : --H)
            s.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (m = this.palette.length / 3, this.transparency.indexed = this.read(c), this.transparency.indexed.length > m)
                throw new Error("More transparent colors than palette size");
              if ((z = m - this.transparency.indexed.length) > 0)
                for (J = 0; 0 <= z ? J < z : J > z; 0 <= z ? ++J : --J)
                  this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(c)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(c);
          }
          break;
        case "tEXt":
          I = (V = this.read(c)).indexOf(0), L = String.fromCharCode.apply(String, V.slice(0, I)), this.text[L] = String.fromCharCode.apply(String, V.slice(I + 1));
          break;
        case "IEND":
          return T && this.animation.frames.push(T), this.colors = (function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }).call(this), this.hasAlphaChannel = (ce = this.colorType) === 4 || ce === 6, l = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * l, this.colorSpace = (function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }).call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += c;
      }
      if (this.pos += 4, this.pos > this.data.length)
        throw new Error("Incomplete or corrupt PNG file");
    }
  }
  i.prototype.read = function(s) {
    var c, l;
    for (l = [], c = 0; 0 <= s ? c < s : c > s; 0 <= s ? ++c : --c)
      l.push(this.data[this.pos++]);
    return l;
  }, i.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, i.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, i.prototype.decodePixels = function(s) {
    var c = this.pixelBitlength / 8, l = new Uint8Array(this.width * this.height * c), m = 0, y = this;
    if (s == null && (s = this.imgData), s.length === 0)
      return new Uint8Array(0);
    function A(T, I, L, N) {
      var z, V, H, J, ce, me, Se, De, Le, ye, Ve, Fe, ae, de, Te, be, tt, st, lt, Ye, ht, ct = Math.ceil((y.width - T) / L), Pt = Math.ceil((y.height - I) / N), se = y.width == ct && y.height == Pt;
      for (de = c * ct, Fe = se ? l : new Uint8Array(de * Pt), me = s.length, ae = 0, V = 0; ae < Pt && m < me; ) {
        switch (s[m++]) {
          case 0:
            for (J = tt = 0; tt < de; J = tt += 1)
              Fe[V++] = s[m++];
            break;
          case 1:
            for (J = st = 0; st < de; J = st += 1)
              z = s[m++], ce = J < c ? 0 : Fe[V - c], Fe[V++] = (z + ce) % 256;
            break;
          case 2:
            for (J = lt = 0; lt < de; J = lt += 1)
              z = s[m++], H = (J - J % c) / c, Te = ae && Fe[(ae - 1) * de + H * c + J % c], Fe[V++] = (Te + z) % 256;
            break;
          case 3:
            for (J = Ye = 0; Ye < de; J = Ye += 1)
              z = s[m++], H = (J - J % c) / c, ce = J < c ? 0 : Fe[V - c], Te = ae && Fe[(ae - 1) * de + H * c + J % c], Fe[V++] = (z + Math.floor((ce + Te) / 2)) % 256;
            break;
          case 4:
            for (J = ht = 0; ht < de; J = ht += 1)
              z = s[m++], H = (J - J % c) / c, ce = J < c ? 0 : Fe[V - c], ae === 0 ? Te = be = 0 : (Te = Fe[(ae - 1) * de + H * c + J % c], be = H && Fe[(ae - 1) * de + (H - 1) * c + J % c]), Se = ce + Te - be, De = Math.abs(Se - ce), ye = Math.abs(Se - Te), Ve = Math.abs(Se - be), Le = De <= ye && De <= Ve ? ce : ye <= Ve ? Te : be, Fe[V++] = (z + Le) % 256;
            break;
          default:
            throw new Error("Invalid filter algorithm: " + s[m - 1]);
        }
        if (!se) {
          var Ae = ((I + ae * N) * y.width + T) * c, Ce = ae * de;
          for (J = 0; J < ct; J += 1) {
            for (var Ue = 0; Ue < c; Ue += 1)
              l[Ae++] = Fe[Ce++];
            Ae += (L - 1) * c;
          }
        }
        ae++;
      }
    }
    return s = WG(s), y.interlaceMethod == 1 ? (A(0, 0, 8, 8), A(4, 0, 8, 8), A(0, 4, 4, 8), A(2, 0, 4, 4), A(0, 2, 2, 4), A(1, 0, 2, 2), A(0, 1, 1, 2)) : A(0, 0, 1, 1), l;
  }, i.prototype.decodePalette = function() {
    var s, c, l, m, y, A, T, I, L;
    for (l = this.palette, A = this.transparency.indexed || [], y = new Uint8Array((A.length || 0) + l.length), m = 0, s = 0, c = T = 0, I = l.length; T < I; c = T += 3)
      y[m++] = l[c], y[m++] = l[c + 1], y[m++] = l[c + 2], y[m++] = (L = A[s++]) != null ? L : 255;
    return y;
  }, i.prototype.copyToImageData = function(s, c) {
    var l, m, y, A, T, I, L, N, z, V, H;
    if (m = this.colors, z = null, l = this.hasAlphaChannel, this.palette.length && (z = (H = this._decodedPalette) != null ? H : this._decodedPalette = this.decodePalette(), m = 4, l = !0), N = (y = s.data || s).length, T = z || c, A = I = 0, m === 1)
      for (; A < N; )
        L = z ? 4 * c[A / 4] : I, V = T[L++], y[A++] = V, y[A++] = V, y[A++] = V, y[A++] = l ? T[L++] : 255, I = L;
    else
      for (; A < N; )
        L = z ? 4 * c[A / 4] : I, y[A++] = T[L++], y[A++] = T[L++], y[A++] = T[L++], y[A++] = l ? T[L++] : 255, I = L;
  }, i.prototype.decode = function() {
    var s;
    return s = new Uint8Array(this.width * this.height * 4), this.copyToImageData(s, this.decodePixels()), s;
  };
  var r = function() {
    if (Object.prototype.toString.call(Rn) === "[object Window]") {
      try {
        e = Rn.document.createElement("canvas"), t = e.getContext("2d");
      } catch {
        return !1;
      }
      return !0;
    }
    return !1;
  };
  return r(), n = function(s) {
    var c;
    if (r() === !0)
      return t.width = s.width, t.height = s.height, t.clearRect(0, 0, s.width, s.height), t.putImageData(s, 0, 0), (c = new Image()).src = e.toDataURL(), c;
    throw new Error("This method requires a Browser with Canvas-capability.");
  }, i.prototype.decodeFrames = function(s) {
    var c, l, m, y, A, T, I, L;
    if (this.animation) {
      for (L = [], l = A = 0, T = (I = this.animation.frames).length; A < T; l = ++A)
        c = I[l], m = s.createImageData(c.width, c.height), y = this.decodePixels(new Uint8Array(c.data)), this.copyToImageData(m, y), c.imageData = m, L.push(c.image = n(m));
      return L;
    }
  }, i.prototype.renderFrame = function(s, c) {
    var l, m, y;
    return l = (m = this.animation.frames)[c], y = m[c - 1], c === 0 && s.clearRect(0, 0, this.width, this.height), (y != null ? y.disposeOp : void 0) === 1 ? s.clearRect(y.xOffset, y.yOffset, y.width, y.height) : (y != null ? y.disposeOp : void 0) === 2 && s.putImageData(y.imageData, y.xOffset, y.yOffset), l.blendOp === 0 && s.clearRect(l.xOffset, l.yOffset, l.width, l.height), s.drawImage(l.image, l.xOffset, l.yOffset);
  }, i.prototype.animate = function(s) {
    var c, l, m, y, A, T, I = this;
    return l = 0, T = this.animation, y = T.numFrames, m = T.frames, A = T.numPlays, (c = function() {
      var L, N;
      if (L = l++ % y, N = m[L], I.renderFrame(s, L), y > 1 && l / y < A)
        return I.animation._timeout = setTimeout(c, N.delay);
    })();
  }, i.prototype.stopAnimation = function() {
    var s;
    return clearTimeout((s = this.animation) != null ? s._timeout : void 0);
  }, i.prototype.render = function(s) {
    var c, l;
    return s._png && s._png.stopAnimation(), s._png = this, s.width = this.width, s.height = this.height, c = s.getContext("2d"), this.animation ? (this.decodeFrames(c), this.animate(c)) : (l = c.createImageData(this.width, this.height), this.copyToImageData(l, this.decodePixels()), c.putImageData(l, 0, 0));
  }, i;
}();
/**
* @license
*
* Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
/**
* @license
* (c) Dean McNamee <dean@gmail.com>, 2013.
*
* https://github.com/deanm/omggif
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*
* omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
* including animation and compression.  It does not rely on any specific
* underlying system, so should run in the browser, Node, or Plask.
*/
function fV(n) {
  var e = 0;
  if (n[e++] !== 71 || n[e++] !== 73 || n[e++] !== 70 || n[e++] !== 56 || (n[e++] + 1 & 253) != 56 || n[e++] !== 97)
    throw new Error("Invalid GIF 87a/89a header.");
  var t = n[e++] | n[e++] << 8, i = n[e++] | n[e++] << 8, r = n[e++], s = r >> 7, c = 1 << (7 & r) + 1;
  n[e++], n[e++];
  var l = null, m = null;
  s && (l = e, m = c, e += 3 * c);
  var y = !0, A = [], T = 0, I = null, L = 0, N = null;
  for (this.width = t, this.height = i; y && e < n.length; )
    switch (n[e++]) {
      case 33:
        switch (n[e++]) {
          case 255:
            if (n[e] !== 11 || n[e + 1] == 78 && n[e + 2] == 69 && n[e + 3] == 84 && n[e + 4] == 83 && n[e + 5] == 67 && n[e + 6] == 65 && n[e + 7] == 80 && n[e + 8] == 69 && n[e + 9] == 50 && n[e + 10] == 46 && n[e + 11] == 48 && n[e + 12] == 3 && n[e + 13] == 1 && n[e + 16] == 0)
              e += 14, N = n[e++] | n[e++] << 8, e++;
            else
              for (e += 12; ; ) {
                if (!((ae = n[e++]) >= 0))
                  throw Error("Invalid block size");
                if (ae === 0)
                  break;
                e += ae;
              }
            break;
          case 249:
            if (n[e++] !== 4 || n[e + 4] !== 0)
              throw new Error("Invalid graphics extension block.");
            var z = n[e++];
            T = n[e++] | n[e++] << 8, I = n[e++], !(1 & z) && (I = null), L = z >> 2 & 7, e++;
            break;
          case 254:
            for (; ; ) {
              if (!((ae = n[e++]) >= 0))
                throw Error("Invalid block size");
              if (ae === 0)
                break;
              e += ae;
            }
            break;
          default:
            throw new Error("Unknown graphic control label: 0x" + n[e - 1].toString(16));
        }
        break;
      case 44:
        var V = n[e++] | n[e++] << 8, H = n[e++] | n[e++] << 8, J = n[e++] | n[e++] << 8, ce = n[e++] | n[e++] << 8, me = n[e++], Se = me >> 6 & 1, De = 1 << (7 & me) + 1, Le = l, ye = m, Ve = !1;
        me >> 7 && (Ve = !0, Le = e, ye = De, e += 3 * De);
        var Fe = e;
        for (e++; ; ) {
          var ae;
          if (!((ae = n[e++]) >= 0))
            throw Error("Invalid block size");
          if (ae === 0)
            break;
          e += ae;
        }
        A.push({ x: V, y: H, width: J, height: ce, has_local_palette: Ve, palette_offset: Le, palette_size: ye, data_offset: Fe, data_length: e - Fe, transparent_index: I, interlaced: !!Se, delay: T, disposal: L });
        break;
      case 59:
        y = !1;
        break;
      default:
        throw new Error("Unknown gif block: 0x" + n[e - 1].toString(16));
    }
  this.numFrames = function() {
    return A.length;
  }, this.loopCount = function() {
    return N;
  }, this.frameInfo = function(de) {
    if (de < 0 || de >= A.length)
      throw new Error("Frame index out of range.");
    return A[de];
  }, this.decodeAndBlitFrameBGRA = function(de, Te) {
    var be = this.frameInfo(de), tt = be.width * be.height, st = new Uint8Array(tt);
    HA(n, be.data_offset, st, tt);
    var lt = be.palette_offset, Ye = be.transparent_index;
    Ye === null && (Ye = 256);
    var ht = be.width, ct = t - ht, Pt = ht, se = 4 * (be.y * t + be.x), Ae = 4 * ((be.y + be.height) * t + be.x), Ce = se, Ue = 4 * ct;
    be.interlaced === !0 && (Ue += 4 * t * 7);
    for (var qe = 8, We = 0, Ke = st.length; We < Ke; ++We) {
      var Ze = st[We];
      if (Pt === 0 && (Pt = ht, (Ce += Ue) >= Ae && (Ue = 4 * ct + 4 * t * (qe - 1), Ce = se + (ht + ct) * (qe << 1), qe >>= 1)), Ze === Ye)
        Ce += 4;
      else {
        var At = n[lt + 3 * Ze], It = n[lt + 3 * Ze + 1], Rt = n[lt + 3 * Ze + 2];
        Te[Ce++] = Rt, Te[Ce++] = It, Te[Ce++] = At, Te[Ce++] = 255;
      }
      --Pt;
    }
  }, this.decodeAndBlitFrameRGBA = function(de, Te) {
    var be = this.frameInfo(de), tt = be.width * be.height, st = new Uint8Array(tt);
    HA(n, be.data_offset, st, tt);
    var lt = be.palette_offset, Ye = be.transparent_index;
    Ye === null && (Ye = 256);
    var ht = be.width, ct = t - ht, Pt = ht, se = 4 * (be.y * t + be.x), Ae = 4 * ((be.y + be.height) * t + be.x), Ce = se, Ue = 4 * ct;
    be.interlaced === !0 && (Ue += 4 * t * 7);
    for (var qe = 8, We = 0, Ke = st.length; We < Ke; ++We) {
      var Ze = st[We];
      if (Pt === 0 && (Pt = ht, (Ce += Ue) >= Ae && (Ue = 4 * ct + 4 * t * (qe - 1), Ce = se + (ht + ct) * (qe << 1), qe >>= 1)), Ze === Ye)
        Ce += 4;
      else {
        var At = n[lt + 3 * Ze], It = n[lt + 3 * Ze + 1], Rt = n[lt + 3 * Ze + 2];
        Te[Ce++] = At, Te[Ce++] = It, Te[Ce++] = Rt, Te[Ce++] = 255;
      }
      --Pt;
    }
  };
}
function HA(n, e, t, i) {
  for (var r = n[e++], s = 1 << r, c = s + 1, l = c + 1, m = r + 1, y = (1 << m) - 1, A = 0, T = 0, I = 0, L = n[e++], N = new Int32Array(4096), z = null; ; ) {
    for (; A < 16 && L !== 0; )
      T |= n[e++] << A, A += 8, L === 1 ? L = n[e++] : --L;
    if (A < m)
      break;
    var V = T & y;
    if (T >>= m, A -= m, V !== s) {
      if (V === c)
        break;
      for (var H = V < l ? V : z, J = 0, ce = H; ce > s; )
        ce = N[ce] >> 8, ++J;
      var me = ce;
      if (I + J + (H !== V ? 1 : 0) > i)
        return void Ki.log("Warning, gif stream longer than expected.");
      t[I++] = me;
      var Se = I += J;
      for (H !== V && (t[I++] = me), ce = H; J--; )
        ce = N[ce], t[--Se] = 255 & ce, ce >>= 8;
      z !== null && l < 4096 && (N[l++] = z << 8 | me, l >= y + 1 && m < 12 && (++m, y = y << 1 | 1)), z = V;
    } else
      l = c + 1, y = (1 << (m = r + 1)) - 1, z = null;
  }
  return I !== i && Ki.log("Warning, gif stream shorter than expected."), t;
}
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function V_(n) {
  var e, t, i, r, s, c = Math.floor, l = new Array(64), m = new Array(64), y = new Array(64), A = new Array(64), T = new Array(65535), I = new Array(65535), L = new Array(64), N = new Array(64), z = [], V = 0, H = 7, J = new Array(64), ce = new Array(64), me = new Array(64), Se = new Array(256), De = new Array(2048), Le = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], ye = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], Ve = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], Fe = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], ae = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], de = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], Te = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], be = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], tt = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function st(se, Ae) {
    for (var Ce = 0, Ue = 0, qe = new Array(), We = 1; We <= 16; We++) {
      for (var Ke = 1; Ke <= se[We]; Ke++)
        qe[Ae[Ue]] = [], qe[Ae[Ue]][0] = Ce, qe[Ae[Ue]][1] = We, Ue++, Ce++;
      Ce *= 2;
    }
    return qe;
  }
  function lt(se) {
    for (var Ae = se[0], Ce = se[1] - 1; Ce >= 0; )
      Ae & 1 << Ce && (V |= 1 << H), Ce--, --H < 0 && (V == 255 ? (Ye(255), Ye(0)) : Ye(V), H = 7, V = 0);
  }
  function Ye(se) {
    z.push(se);
  }
  function ht(se) {
    Ye(se >> 8 & 255), Ye(255 & se);
  }
  function ct(se, Ae, Ce, Ue, qe) {
    for (var We, Ke = qe[0], Ze = qe[240], At = function(pt, Et) {
      var Lt, Ft, nn, Tn, xn, On, Un, mt, hn, wn, Bt = 0;
      for (hn = 0; hn < 8; ++hn) {
        Lt = pt[Bt], Ft = pt[Bt + 1], nn = pt[Bt + 2], Tn = pt[Bt + 3], xn = pt[Bt + 4], On = pt[Bt + 5], Un = pt[Bt + 6];
        var bi = Lt + (mt = pt[Bt + 7]), _t = Lt - mt, bn = Ft + Un, Gt = Ft - Un, qn = nn + On, er = nn - On, Nt = Tn + xn, vr = Tn - xn, ii = bi + Nt, sr = bi - Nt, or = bn + qn, ve = bn - qn;
        pt[Bt] = ii + or, pt[Bt + 4] = ii - or;
        var X = 0.707106781 * (ve + sr);
        pt[Bt + 2] = sr + X, pt[Bt + 6] = sr - X;
        var $ = 0.382683433 * ((ii = vr + er) - (ve = Gt + _t)), he = 0.5411961 * ii + $, _e = 1.306562965 * ve + $, Oe = 0.707106781 * (or = er + Gt), je = _t + Oe, Be = _t - Oe;
        pt[Bt + 5] = Be + he, pt[Bt + 3] = Be - he, pt[Bt + 1] = je + _e, pt[Bt + 7] = je - _e, Bt += 8;
      }
      for (Bt = 0, hn = 0; hn < 8; ++hn) {
        Lt = pt[Bt], Ft = pt[Bt + 8], nn = pt[Bt + 16], Tn = pt[Bt + 24], xn = pt[Bt + 32], On = pt[Bt + 40], Un = pt[Bt + 48];
        var Ie = Lt + (mt = pt[Bt + 56]), nt = Lt - mt, ft = Ft + Un, Xe = Ft - Un, xt = nn + On, $t = nn - On, Kt = Tn + xn, _n = Tn - xn, An = Ie + Kt, an = Ie - Kt, Fn = ft + xt, Yn = ft - xt;
        pt[Bt] = An + Fn, pt[Bt + 32] = An - Fn;
        var Kn = 0.707106781 * (Yn + an);
        pt[Bt + 16] = an + Kn, pt[Bt + 48] = an - Kn;
        var dn = 0.382683433 * ((An = _n + $t) - (Yn = Xe + nt)), Dn = 0.5411961 * An + dn, Jn = 1.306562965 * Yn + dn, di = 0.707106781 * (Fn = $t + Xe), Bi = nt + di, Xi = nt - di;
        pt[Bt + 40] = Xi + Dn, pt[Bt + 24] = Xi - Dn, pt[Bt + 8] = Bi + Jn, pt[Bt + 56] = Bi - Jn, Bt++;
      }
      for (hn = 0; hn < 64; ++hn)
        wn = pt[hn] * Et[hn], L[hn] = wn > 0 ? wn + 0.5 | 0 : wn - 0.5 | 0;
      return L;
    }(se, Ae), It = 0; It < 64; ++It)
      N[Le[It]] = At[It];
    var Rt = N[0] - Ce;
    Ce = N[0], Rt == 0 ? lt(Ue[0]) : (lt(Ue[I[We = 32767 + Rt]]), lt(T[We]));
    for (var kt = 63; kt > 0 && N[kt] == 0; )
      kt--;
    if (kt == 0)
      return lt(Ke), Ce;
    for (var on, ut = 1; ut <= kt; ) {
      for (var re = ut; N[ut] == 0 && ut <= kt; )
        ++ut;
      var mn = ut - re;
      if (mn >= 16) {
        on = mn >> 4;
        for (var Qt = 1; Qt <= on; ++Qt)
          lt(Ze);
        mn &= 15;
      }
      We = 32767 + N[ut], lt(qe[(mn << 4) + I[We]]), lt(T[We]), ut++;
    }
    return kt != 63 && lt(Ke), Ce;
  }
  function Pt(se) {
    se = Math.min(Math.max(se, 1), 100), s != se && (function(Ae) {
      for (var Ce = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], Ue = 0; Ue < 64; Ue++) {
        var qe = c((Ce[Ue] * Ae + 50) / 100);
        qe = Math.min(Math.max(qe, 1), 255), l[Le[Ue]] = qe;
      }
      for (var We = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], Ke = 0; Ke < 64; Ke++) {
        var Ze = c((We[Ke] * Ae + 50) / 100);
        Ze = Math.min(Math.max(Ze, 1), 255), m[Le[Ke]] = Ze;
      }
      for (var At = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], It = 0, Rt = 0; Rt < 8; Rt++)
        for (var kt = 0; kt < 8; kt++)
          y[It] = 1 / (l[Le[It]] * At[Rt] * At[kt] * 8), A[It] = 1 / (m[Le[It]] * At[Rt] * At[kt] * 8), It++;
    }(se < 50 ? Math.floor(5e3 / se) : Math.floor(200 - 2 * se)), s = se);
  }
  this.encode = function(se, Ae) {
    Ae && Pt(Ae), z = new Array(), V = 0, H = 7, ht(65496), ht(65504), ht(16), Ye(74), Ye(70), Ye(73), Ye(70), Ye(0), Ye(1), Ye(1), Ye(0), ht(1), ht(1), Ye(0), Ye(0), function() {
      ht(65499), ht(132), Ye(0);
      for (var Ft = 0; Ft < 64; Ft++)
        Ye(l[Ft]);
      Ye(1);
      for (var nn = 0; nn < 64; nn++)
        Ye(m[nn]);
    }(), function(Ft, nn) {
      ht(65472), ht(17), Ye(8), ht(nn), ht(Ft), Ye(3), Ye(1), Ye(17), Ye(0), Ye(2), Ye(17), Ye(1), Ye(3), Ye(17), Ye(1);
    }(se.width, se.height), function() {
      ht(65476), ht(418), Ye(0);
      for (var Ft = 0; Ft < 16; Ft++)
        Ye(ye[Ft + 1]);
      for (var nn = 0; nn <= 11; nn++)
        Ye(Ve[nn]);
      Ye(16);
      for (var Tn = 0; Tn < 16; Tn++)
        Ye(Fe[Tn + 1]);
      for (var xn = 0; xn <= 161; xn++)
        Ye(ae[xn]);
      Ye(1);
      for (var On = 0; On < 16; On++)
        Ye(de[On + 1]);
      for (var Un = 0; Un <= 11; Un++)
        Ye(Te[Un]);
      Ye(17);
      for (var mt = 0; mt < 16; mt++)
        Ye(be[mt + 1]);
      for (var hn = 0; hn <= 161; hn++)
        Ye(tt[hn]);
    }(), ht(65498), ht(12), Ye(3), Ye(1), Ye(0), Ye(2), Ye(17), Ye(3), Ye(17), Ye(0), Ye(63), Ye(0);
    var Ce = 0, Ue = 0, qe = 0;
    V = 0, H = 7, this.encode.displayName = "_encode_";
    for (var We, Ke, Ze, At, It, Rt, kt, on, ut, re = se.data, mn = se.width, Qt = se.height, pt = 4 * mn, Et = 0; Et < Qt; ) {
      for (We = 0; We < pt; ) {
        for (It = pt * Et + We, kt = -1, on = 0, ut = 0; ut < 64; ut++)
          Rt = It + (on = ut >> 3) * pt + (kt = 4 * (7 & ut)), Et + on >= Qt && (Rt -= pt * (Et + 1 + on - Qt)), We + kt >= pt && (Rt -= We + kt - pt + 4), Ke = re[Rt++], Ze = re[Rt++], At = re[Rt++], J[ut] = (De[Ke] + De[Ze + 256 >> 0] + De[At + 512 >> 0] >> 16) - 128, ce[ut] = (De[Ke + 768 >> 0] + De[Ze + 1024 >> 0] + De[At + 1280 >> 0] >> 16) - 128, me[ut] = (De[Ke + 1280 >> 0] + De[Ze + 1536 >> 0] + De[At + 1792 >> 0] >> 16) - 128;
        Ce = ct(J, y, Ce, e, i), Ue = ct(ce, A, Ue, t, r), qe = ct(me, A, qe, t, r), We += 32;
      }
      Et += 8;
    }
    if (H >= 0) {
      var Lt = [];
      Lt[1] = H + 1, Lt[0] = (1 << H + 1) - 1, lt(Lt);
    }
    return ht(65497), new Uint8Array(z);
  }, n = n || 50, function() {
    for (var se = String.fromCharCode, Ae = 0; Ae < 256; Ae++)
      Se[Ae] = se(Ae);
  }(), e = st(ye, Ve), t = st(de, Te), i = st(Fe, ae), r = st(be, tt), function() {
    for (var se = 1, Ae = 2, Ce = 1; Ce <= 15; Ce++) {
      for (var Ue = se; Ue < Ae; Ue++)
        I[32767 + Ue] = Ce, T[32767 + Ue] = [], T[32767 + Ue][1] = Ce, T[32767 + Ue][0] = Ue;
      for (var qe = -(Ae - 1); qe <= -se; qe++)
        I[32767 + qe] = Ce, T[32767 + qe] = [], T[32767 + qe][1] = Ce, T[32767 + qe][0] = Ae - 1 + qe;
      se <<= 1, Ae <<= 1;
    }
  }(), function() {
    for (var se = 0; se < 256; se++)
      De[se] = 19595 * se, De[se + 256 >> 0] = 38470 * se, De[se + 512 >> 0] = 7471 * se + 32768, De[se + 768 >> 0] = -11059 * se, De[se + 1024 >> 0] = -21709 * se, De[se + 1280 >> 0] = 32768 * se + 8421375, De[se + 1536 >> 0] = -27439 * se, De[se + 1792 >> 0] = -5329 * se;
  }(), Pt(n);
}
/**
* @license
* Copyright (c) 2017 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function bl(n, e) {
  if (this.pos = 0, this.buffer = n, this.datav = new DataView(n.buffer), this.is_with_alpha = !!e, this.bottom_up = !0, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag) === -1)
    throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function WA(n) {
  function e(ye) {
    if (!ye)
      throw Error("assert :P");
  }
  function t(ye, Ve, Fe) {
    for (var ae = 0; 4 > ae; ae++)
      if (ye[Ve + ae] != Fe.charCodeAt(ae))
        return !0;
    return !1;
  }
  function i(ye, Ve, Fe, ae, de) {
    for (var Te = 0; Te < de; Te++)
      ye[Ve + Te] = Fe[ae + Te];
  }
  function r(ye, Ve, Fe, ae) {
    for (var de = 0; de < ae; de++)
      ye[Ve + de] = Fe;
  }
  function s(ye) {
    return new Int32Array(ye);
  }
  function c(ye, Ve) {
    for (var Fe = [], ae = 0; ae < ye; ae++)
      Fe.push(new Ve());
    return Fe;
  }
  function l(ye, Ve) {
    var Fe = [];
    return function ae(de, Te, be) {
      for (var tt = be[Te], st = 0; st < tt && (de.push(be.length > Te + 1 ? [] : new Ve()), !(be.length < Te + 1)); st++)
        ae(de[st], Te + 1, be);
    }(Fe, 0, ye), Fe;
  }
  var m = function() {
    var ye = this;
    function Ve(h, p) {
      for (var b = 1 << p - 1 >>> 0; h & b; )
        b >>>= 1;
      return b ? (h & b - 1) + b : h;
    }
    function Fe(h, p, b, x, C) {
      e(!(x % b));
      do
        h[p + (x -= b)] = C;
      while (0 < x);
    }
    function ae(h, p, b, x, C) {
      if (e(2328 >= C), 512 >= C)
        var M = s(512);
      else if ((M = s(C)) == null)
        return 0;
      return function(R, O, D, U, W, Q) {
        var Y, K, fe = O, ne = 1 << D, ie = s(16), le = s(16);
        for (e(W != 0), e(U != null), e(R != null), e(0 < D), K = 0; K < W; ++K) {
          if (15 < U[K])
            return 0;
          ++ie[U[K]];
        }
        if (ie[0] == W)
          return 0;
        for (le[1] = 0, Y = 1; 15 > Y; ++Y) {
          if (ie[Y] > 1 << Y)
            return 0;
          le[Y + 1] = le[Y] + ie[Y];
        }
        for (K = 0; K < W; ++K)
          Y = U[K], 0 < U[K] && (Q[le[Y]++] = K);
        if (le[15] == 1)
          return (U = new de()).g = 0, U.value = Q[0], Fe(R, fe, 1, ne, U), ne;
        var xe, Me = -1, Ne = ne - 1, ot = 0, et = 1, rt = 1, $e = 1 << D;
        for (K = 0, Y = 1, W = 2; Y <= D; ++Y, W <<= 1) {
          if (et += rt <<= 1, 0 > (rt -= ie[Y]))
            return 0;
          for (; 0 < ie[Y]; --ie[Y])
            (U = new de()).g = Y, U.value = Q[K++], Fe(R, fe + ot, W, $e, U), ot = Ve(ot, Y);
        }
        for (Y = D + 1, W = 2; 15 >= Y; ++Y, W <<= 1) {
          if (et += rt <<= 1, 0 > (rt -= ie[Y]))
            return 0;
          for (; 0 < ie[Y]; --ie[Y]) {
            if (U = new de(), (ot & Ne) != Me) {
              for (fe += $e, xe = 1 << (Me = Y) - D; 15 > Me && !(0 >= (xe -= ie[Me])); )
                ++Me, xe <<= 1;
              ne += $e = 1 << (xe = Me - D), R[O + (Me = ot & Ne)].g = xe + D, R[O + Me].value = fe - O - Me;
            }
            U.g = Y - D, U.value = Q[K++], Fe(R, fe + (ot >> D), W, $e, U), ot = Ve(ot, Y);
          }
        }
        return et != 2 * le[15] - 1 ? 0 : ne;
      }(h, p, b, x, C, M);
    }
    function de() {
      this.value = this.g = 0;
    }
    function Te() {
      this.value = this.g = 0;
    }
    function be() {
      this.G = c(5, de), this.H = s(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = c(Pi, Te);
    }
    function tt(h, p, b, x) {
      e(h != null), e(p != null), e(2147483648 > x), h.Ca = 254, h.I = 0, h.b = -8, h.Ka = 0, h.oa = p, h.pa = b, h.Jd = p, h.Yc = b + x, h.Zc = 4 <= x ? b + x - 4 + 1 : b, We(h);
    }
    function st(h, p) {
      for (var b = 0; 0 < p--; )
        b |= Ze(h, 128) << p;
      return b;
    }
    function lt(h, p) {
      var b = st(h, p);
      return Ke(h) ? -b : b;
    }
    function Ye(h, p, b, x) {
      var C, M = 0;
      for (e(h != null), e(p != null), e(4294967288 > x), h.Sb = x, h.Ra = 0, h.u = 0, h.h = 0, 4 < x && (x = 4), C = 0; C < x; ++C)
        M += p[b + C] << 8 * C;
      h.Ra = M, h.bb = x, h.oa = p, h.pa = b;
    }
    function ht(h) {
      for (; 8 <= h.u && h.bb < h.Sb; )
        h.Ra >>>= 8, h.Ra += h.oa[h.pa + h.bb] << Ea - 8 >>> 0, ++h.bb, h.u -= 8;
      Ce(h) && (h.h = 1, h.u = 0);
    }
    function ct(h, p) {
      if (e(0 <= p), !h.h && p <= Wo) {
        var b = Ae(h) & Aa[p];
        return h.u += p, ht(h), b;
      }
      return h.h = 1, h.u = 0;
    }
    function Pt() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function se() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function Ae(h) {
      return h.Ra >>> (h.u & Ea - 1) >>> 0;
    }
    function Ce(h) {
      return e(h.bb <= h.Sb), h.h || h.bb == h.Sb && h.u > Ea;
    }
    function Ue(h, p) {
      h.u = p, h.h = Ce(h);
    }
    function qe(h) {
      h.u >= io && (e(h.u >= io), ht(h));
    }
    function We(h) {
      e(h != null && h.oa != null), h.pa < h.Zc ? (h.I = (h.oa[h.pa++] | h.I << 8) >>> 0, h.b += 8) : (e(h != null && h.oa != null), h.pa < h.Yc ? (h.b += 8, h.I = h.oa[h.pa++] | h.I << 8) : h.Ka ? h.b = 0 : (h.I <<= 8, h.b += 8, h.Ka = 1));
    }
    function Ke(h) {
      return st(h, 1);
    }
    function Ze(h, p) {
      var b = h.Ca;
      0 > h.b && We(h);
      var x = h.b, C = b * p >>> 8, M = (h.I >>> x > C) + 0;
      for (M ? (b -= C, h.I -= C + 1 << x >>> 0) : b = C + 1, x = b, C = 0; 256 <= x; )
        C += 8, x >>= 8;
      return x = 7 ^ C + Lr[x], h.b -= x, h.Ca = (b << x) - 1, M;
    }
    function At(h, p, b) {
      h[p + 0] = b >> 24 & 255, h[p + 1] = b >> 16 & 255, h[p + 2] = b >> 8 & 255, h[p + 3] = b >> 0 & 255;
    }
    function It(h, p) {
      return h[p + 0] << 0 | h[p + 1] << 8;
    }
    function Rt(h, p) {
      return It(h, p) | h[p + 2] << 16;
    }
    function kt(h, p) {
      return It(h, p) | It(h, p + 2) << 16;
    }
    function on(h, p) {
      var b = 1 << p;
      return e(h != null), e(0 < p), h.X = s(b), h.X == null ? 0 : (h.Mb = 32 - p, h.Xa = p, 1);
    }
    function ut(h, p) {
      e(h != null), e(p != null), e(h.Xa == p.Xa), i(p.X, 0, h.X, 0, 1 << p.Xa);
    }
    function re() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function mn(h, p, b, x) {
      e(b != null), e(x != null);
      var C = b[0], M = x[0];
      return C == 0 && (C = (h * M + p / 2) / p), M == 0 && (M = (p * C + h / 2) / h), 0 >= C || 0 >= M ? 0 : (b[0] = C, x[0] = M, 1);
    }
    function Qt(h, p) {
      return h + (1 << p) - 1 >>> p;
    }
    function pt(h, p) {
      return ((4278255360 & h) + (4278255360 & p) >>> 0 & 4278255360) + ((16711935 & h) + (16711935 & p) >>> 0 & 16711935) >>> 0;
    }
    function Et(h, p) {
      ye[p] = function(b, x, C, M, R, O, D) {
        var U;
        for (U = 0; U < R; ++U) {
          var W = ye[h](O[D + U - 1], C, M + U);
          O[D + U] = pt(b[x + U], W);
        }
      };
    }
    function Lt() {
      this.ud = this.hd = this.jd = 0;
    }
    function Ft(h, p) {
      return ((4278124286 & (h ^ p)) >>> 1) + (h & p) >>> 0;
    }
    function nn(h) {
      return 0 <= h && 256 > h ? h : 0 > h ? 0 : 255 < h ? 255 : void 0;
    }
    function Tn(h, p) {
      return nn(h + (h - p + 0.5 >> 1));
    }
    function xn(h, p, b) {
      return Math.abs(p - b) - Math.abs(h - b);
    }
    function On(h, p, b, x, C, M, R) {
      for (x = M[R - 1], b = 0; b < C; ++b)
        M[R + b] = x = pt(h[p + b], x);
    }
    function Un(h, p, b, x, C) {
      var M;
      for (M = 0; M < b; ++M) {
        var R = h[p + M], O = R >> 8 & 255, D = 16711935 & (D = (D = 16711935 & R) + ((O << 16) + O));
        x[C + M] = (4278255360 & R) + D >>> 0;
      }
    }
    function mt(h, p) {
      p.jd = h >> 0 & 255, p.hd = h >> 8 & 255, p.ud = h >> 16 & 255;
    }
    function hn(h, p, b, x, C, M) {
      var R;
      for (R = 0; R < x; ++R) {
        var O = p[b + R], D = O >>> 8, U = O, W = 255 & (W = (W = O >>> 16) + ((h.jd << 24 >> 24) * (D << 24 >> 24) >>> 5));
        U = 255 & (U = (U = U + ((h.hd << 24 >> 24) * (D << 24 >> 24) >>> 5)) + ((h.ud << 24 >> 24) * (W << 24 >> 24) >>> 5)), C[M + R] = (4278255360 & O) + (W << 16) + U;
      }
    }
    function wn(h, p, b, x, C) {
      ye[p] = function(M, R, O, D, U, W, Q, Y, K) {
        for (D = Q; D < Y; ++D)
          for (Q = 0; Q < K; ++Q)
            U[W++] = C(O[x(M[R++])]);
      }, ye[h] = function(M, R, O, D, U, W, Q) {
        var Y = 8 >> M.b, K = M.Ea, fe = M.K[0], ne = M.w;
        if (8 > Y)
          for (M = (1 << M.b) - 1, ne = (1 << Y) - 1; R < O; ++R) {
            var ie, le = 0;
            for (ie = 0; ie < K; ++ie)
              ie & M || (le = x(D[U++])), W[Q++] = C(fe[le & ne]), le >>= Y;
          }
        else
          ye["VP8LMapColor" + b](D, U, fe, ne, W, Q, R, O, K);
      };
    }
    function Bt(h, p, b, x, C) {
      for (b = p + b; p < b; ) {
        var M = h[p++];
        x[C++] = M >> 16 & 255, x[C++] = M >> 8 & 255, x[C++] = M >> 0 & 255;
      }
    }
    function bi(h, p, b, x, C) {
      for (b = p + b; p < b; ) {
        var M = h[p++];
        x[C++] = M >> 16 & 255, x[C++] = M >> 8 & 255, x[C++] = M >> 0 & 255, x[C++] = M >> 24 & 255;
      }
    }
    function _t(h, p, b, x, C) {
      for (b = p + b; p < b; ) {
        var M = (R = h[p++]) >> 16 & 240 | R >> 12 & 15, R = R >> 0 & 240 | R >> 28 & 15;
        x[C++] = M, x[C++] = R;
      }
    }
    function bn(h, p, b, x, C) {
      for (b = p + b; p < b; ) {
        var M = (R = h[p++]) >> 16 & 248 | R >> 13 & 7, R = R >> 5 & 224 | R >> 3 & 31;
        x[C++] = M, x[C++] = R;
      }
    }
    function Gt(h, p, b, x, C) {
      for (b = p + b; p < b; ) {
        var M = h[p++];
        x[C++] = M >> 0 & 255, x[C++] = M >> 8 & 255, x[C++] = M >> 16 & 255;
      }
    }
    function qn(h, p, b, x, C, M) {
      if (M == 0)
        for (b = p + b; p < b; )
          At(x, ((M = h[p++])[0] >> 24 | M[1] >> 8 & 65280 | M[2] << 8 & 16711680 | M[3] << 24) >>> 0), C += 32;
      else
        i(x, C, h, p, b);
    }
    function er(h, p) {
      ye[p][0] = ye[h + "0"], ye[p][1] = ye[h + "1"], ye[p][2] = ye[h + "2"], ye[p][3] = ye[h + "3"], ye[p][4] = ye[h + "4"], ye[p][5] = ye[h + "5"], ye[p][6] = ye[h + "6"], ye[p][7] = ye[h + "7"], ye[p][8] = ye[h + "8"], ye[p][9] = ye[h + "9"], ye[p][10] = ye[h + "10"], ye[p][11] = ye[h + "11"], ye[p][12] = ye[h + "12"], ye[p][13] = ye[h + "13"], ye[p][14] = ye[h + "0"], ye[p][15] = ye[h + "0"];
    }
    function Nt(h) {
      return h == lo || h == Cc || h == Ic || h == Pc;
    }
    function vr() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function ii() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function sr() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new vr(), this.f.kb = new ii(), this.sd = null;
    }
    function or() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function ve() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function X(h) {
      return alert("todo:WebPSamplerProcessPlane"), h.T;
    }
    function $(h, p) {
      var b = h.T, x = p.ba.f.RGBA, C = x.eb, M = x.fb + h.ka * x.A, R = As[p.ba.S], O = h.y, D = h.O, U = h.f, W = h.N, Q = h.ea, Y = h.W, K = p.cc, fe = p.dc, ne = p.Mc, ie = p.Nc, le = h.ka, xe = h.ka + h.T, Me = h.U, Ne = Me + 1 >> 1;
      for (le == 0 ? R(O, D, null, null, U, W, Q, Y, U, W, Q, Y, C, M, null, null, Me) : (R(p.ec, p.fc, O, D, K, fe, ne, ie, U, W, Q, Y, C, M - x.A, C, M, Me), ++b); le + 2 < xe; le += 2)
        K = U, fe = W, ne = Q, ie = Y, W += h.Rc, Y += h.Rc, M += 2 * x.A, R(O, (D += 2 * h.fa) - h.fa, O, D, K, fe, ne, ie, U, W, Q, Y, C, M - x.A, C, M, Me);
      return D += h.fa, h.j + xe < h.o ? (i(p.ec, p.fc, O, D, Me), i(p.cc, p.dc, U, W, Ne), i(p.Mc, p.Nc, Q, Y, Ne), b--) : 1 & xe || R(O, D, null, null, U, W, Q, Y, U, W, Q, Y, C, M + x.A, null, null, Me), b;
    }
    function he(h, p, b) {
      var x = h.F, C = [h.J];
      if (x != null) {
        var M = h.U, R = p.ba.S, O = R == Hl || R == Ic;
        p = p.ba.f.RGBA;
        var D = [0], U = h.ka;
        D[0] = h.T, h.Kb && (U == 0 ? --D[0] : (--U, C[0] -= h.width), h.j + h.ka + h.T == h.o && (D[0] = h.o - h.j - U));
        var W = p.eb;
        U = p.fb + U * p.A, h = Ko(x, C[0], h.width, M, D, W, U + (O ? 0 : 3), p.A), e(b == D), h && Nt(R) && bs(W, U, O, M, D, p.A);
      }
      return 0;
    }
    function _e(h) {
      var p = h.ma, b = p.ba.S, x = 11 > b, C = b == Ra || b == ql || b == Hl || b == Tc || b == 12 || Nt(b);
      if (p.memory = null, p.Ib = null, p.Jb = null, p.Nd = null, !sl(p.Oa, h, C ? 11 : 12))
        return 0;
      if (C && Nt(b) && Tt(), h.da)
        alert("todo:use_scaling");
      else {
        if (x) {
          if (p.Ib = X, h.Kb) {
            if (b = h.U + 1 >> 1, p.memory = s(h.U + 2 * b), p.memory == null)
              return 0;
            p.ec = p.memory, p.fc = 0, p.cc = p.ec, p.dc = p.fc + h.U, p.Mc = p.cc, p.Nc = p.dc + b, p.Ib = $, Tt();
          }
        } else
          alert("todo:EmitYUV");
        C && (p.Jb = he, x && Je());
      }
      if (x && !ll) {
        for (h = 0; 256 > h; ++h)
          Yh[h] = 89858 * (h - 128) + Jl >> Bc, To[h] = -22014 * (h - 128) + Jl, Oc[h] = -45773 * (h - 128), lh[h] = 113618 * (h - 128) + Jl >> Bc;
        for (h = Ds; h < pi; ++h)
          p = 76283 * (h - 16) + Jl >> Bc, mu[h - Ds] = zr(p, 255), en[h - Ds] = zr(p + 8 >> 4, 15);
        ll = 1;
      }
      return 1;
    }
    function Oe(h) {
      var p = h.ma, b = h.U, x = h.T;
      return e(!(1 & h.ka)), 0 >= b || 0 >= x ? 0 : (b = p.Ib(h, p), p.Jb != null && p.Jb(h, p, b), p.Dc += b, 1);
    }
    function je(h) {
      h.ma.memory = null;
    }
    function Be(h, p, b, x) {
      return ct(h, 8) != 47 ? 0 : (p[0] = ct(h, 14) + 1, b[0] = ct(h, 14) + 1, x[0] = ct(h, 1), ct(h, 3) != 0 ? 0 : !h.h);
    }
    function Ie(h, p) {
      if (4 > h)
        return h + 1;
      var b = h - 2 >> 1;
      return (2 + (1 & h) << b) + ct(p, b) + 1;
    }
    function nt(h, p) {
      return 120 < p ? p - 120 : 1 <= (b = ((b = Xh[p - 1]) >> 4) * h + (8 - (15 & b))) ? b : 1;
      var b;
    }
    function ft(h, p, b) {
      var x = Ae(b), C = h[p += 255 & x].g - 8;
      return 0 < C && (Ue(b, b.u + 8), x = Ae(b), p += h[p].value, p += x & (1 << C) - 1), Ue(b, b.u + h[p].g), h[p].value;
    }
    function Xe(h, p, b) {
      return b.g += h.g, b.value += h.value << p >>> 0, e(8 >= b.g), h.g;
    }
    function xt(h, p, b) {
      var x = h.xc;
      return e((p = x == 0 ? 0 : h.vc[h.md * (b >> x) + (p >> x)]) < h.Wb), h.Ya[p];
    }
    function $t(h, p, b, x) {
      var C = h.ab, M = h.c * p, R = h.C;
      p = R + p;
      var O = b, D = x;
      for (x = h.Ta, b = h.Ua; 0 < C--; ) {
        var U = h.gc[C], W = R, Q = p, Y = O, K = D, fe = (D = x, O = b, U.Ea);
        switch (e(W < Q), e(Q <= U.nc), U.hc) {
          case 2:
            ol(Y, K, (Q - W) * fe, D, O);
            break;
          case 0:
            var ne = W, ie = Q, le = D, xe = O, Me = ($e = U).Ea;
            ne == 0 && (jl(Y, K, null, null, 1, le, xe), On(Y, K + 1, 0, 0, Me - 1, le, xe + 1), K += Me, xe += Me, ++ne);
            for (var Ne = 1 << $e.b, ot = Ne - 1, et = Qt(Me, $e.b), rt = $e.K, $e = $e.w + (ne >> $e.b) * et; ne < ie; ) {
              var Ct = rt, qt = $e, yt = 1;
              for (Xo(Y, K, le, xe - Me, 1, le, xe); yt < Me; ) {
                var vt = (yt & ~ot) + Ne;
                vt > Me && (vt = Me), (0, vs[Ct[qt++] >> 8 & 15])(Y, K + +yt, le, xe + yt - Me, vt - yt, le, xe + yt), yt = vt;
              }
              K += Me, xe += Me, ++ne & ot || ($e += et);
            }
            Q != U.nc && i(D, O - fe, D, O + (Q - W - 1) * fe, fe);
            break;
          case 1:
            for (fe = Y, ie = K, Me = (Y = U.Ea) - (xe = Y & ~(le = (K = 1 << U.b) - 1)), ne = Qt(Y, U.b), Ne = U.K, U = U.w + (W >> U.b) * ne; W < Q; ) {
              for (ot = Ne, et = U, rt = new Lt(), $e = ie + xe, Ct = ie + Y; ie < $e; )
                mt(ot[et++], rt), Mn(rt, fe, ie, K, D, O), ie += K, O += K;
              ie < Ct && (mt(ot[et++], rt), Mn(rt, fe, ie, Me, D, O), ie += Me, O += Me), ++W & le || (U += ne);
            }
            break;
          case 3:
            if (Y == D && K == O && 0 < U.b) {
              for (ie = D, Y = fe = O + (Q - W) * fe - (xe = (Q - W) * Qt(U.Ea, U.b)), K = D, le = O, ne = [], xe = (Me = xe) - 1; 0 <= xe; --xe)
                ne[xe] = K[le + xe];
              for (xe = Me - 1; 0 <= xe; --xe)
                ie[Y + xe] = ne[xe];
              Bs(U, W, Q, D, fe, D, O);
            } else
              Bs(U, W, Q, Y, K, D, O);
        }
        O = x, D = b;
      }
      D != b && i(x, b, O, D, M);
    }
    function Kt(h, p) {
      var b = h.V, x = h.Ba + h.c * h.C, C = p - h.C;
      if (e(p <= h.l.o), e(16 >= C), 0 < C) {
        var M = h.l, R = h.Ta, O = h.Ua, D = M.width;
        if ($t(h, C, b, x), C = O = [O], e((b = h.C) < (x = p)), e(M.v < M.va), x > M.o && (x = M.o), b < M.j) {
          var U = M.j - b;
          b = M.j, C[0] += U * D;
        }
        if (b >= x ? b = 0 : (C[0] += 4 * M.v, M.ka = b - M.j, M.U = M.va - M.v, M.T = x - b, b = 1), b) {
          if (O = O[0], 11 > (b = h.ca).S) {
            var W = b.f.RGBA, Q = (x = b.S, C = M.U, M = M.T, U = W.eb, W.A), Y = M;
            for (W = W.fb + h.Ma * W.A; 0 < Y--; ) {
              var K = R, fe = O, ne = C, ie = U, le = W;
              switch (x) {
                case Ba:
                  $r(K, fe, ne, ie, le);
                  break;
                case Ra:
                  $o(K, fe, ne, ie, le);
                  break;
                case lo:
                  $o(K, fe, ne, ie, le), bs(ie, le, 0, ne, 1, 0);
                  break;
                case Vl:
                  Zo(K, fe, ne, ie, le);
                  break;
                case ql:
                  qn(K, fe, ne, ie, le, 1);
                  break;
                case Cc:
                  qn(K, fe, ne, ie, le, 1), bs(ie, le, 0, ne, 1, 0);
                  break;
                case Hl:
                  qn(K, fe, ne, ie, le, 0);
                  break;
                case Ic:
                  qn(K, fe, ne, ie, le, 0), bs(ie, le, 1, ne, 1, 0);
                  break;
                case Tc:
                  ro(K, fe, ne, ie, le);
                  break;
                case Pc:
                  ro(K, fe, ne, ie, le), Pa(ie, le, ne, 1, 0);
                  break;
                case fu:
                  Zr(K, fe, ne, ie, le);
                  break;
                default:
                  e(0);
              }
              O += D, W += Q;
            }
            h.Ma += M;
          } else
            alert("todo:EmitRescaledRowsYUVA");
          e(h.Ma <= b.height);
        }
      }
      h.C = p, e(h.C <= h.i);
    }
    function _n(h) {
      var p;
      if (0 < h.ua)
        return 0;
      for (p = 0; p < h.Wb; ++p) {
        var b = h.Ya[p].G, x = h.Ya[p].H;
        if (0 < b[1][x[1] + 0].g || 0 < b[2][x[2] + 0].g || 0 < b[3][x[3] + 0].g)
          return 0;
      }
      return 1;
    }
    function An(h, p, b, x, C, M) {
      if (h.Z != 0) {
        var R = h.qd, O = h.rd;
        for (e(Br[h.Z] != null); p < b; ++p)
          Br[h.Z](R, O, x, C, x, C, M), R = x, O = C, C += M;
        h.qd = R, h.rd = O;
      }
    }
    function an(h, p) {
      var b = h.l.ma, x = b.Z == 0 || b.Z == 1 ? h.l.j : h.C;
      if (x = h.C < x ? x : h.C, e(p <= h.l.o), p > x) {
        var C = h.l.width, M = b.ca, R = b.tb + C * x, O = h.V, D = h.Ba + h.c * x, U = h.gc;
        e(h.ab == 1), e(U[0].hc == 3), Jo(U[0], x, p, O, D, M, R), An(b, x, p, M, R, C);
      }
      h.C = h.Ma = p;
    }
    function Fn(h, p, b, x, C, M, R) {
      var O = h.$ / x, D = h.$ % x, U = h.m, W = h.s, Q = b + h.$, Y = Q;
      C = b + x * C;
      var K = b + x * M, fe = 280 + W.ua, ne = h.Pb ? O : 16777216, ie = 0 < W.ua ? W.Wa : null, le = W.wc, xe = Q < K ? xt(W, D, O) : null;
      e(h.C < M), e(K <= C);
      var Me = !1;
      e:
        for (; ; ) {
          for (; Me || Q < K; ) {
            var Ne = 0;
            if (O >= ne) {
              var ot = Q - b;
              e((ne = h).Pb), ne.wd = ne.m, ne.xd = ot, 0 < ne.s.ua && ut(ne.s.Wa, ne.s.vb), ne = O + co;
            }
            if (D & le || (xe = xt(W, D, O)), e(xe != null), xe.Qb && (p[Q] = xe.qb, Me = !0), !Me)
              if (qe(U), xe.jc) {
                Ne = U, ot = p;
                var et = Q, rt = xe.pd[Ae(Ne) & Pi - 1];
                e(xe.jc), 256 > rt.g ? (Ue(Ne, Ne.u + rt.g), ot[et] = rt.value, Ne = 0) : (Ue(Ne, Ne.u + rt.g - 256), e(256 <= rt.value), Ne = rt.value), Ne == 0 && (Me = !0);
              } else
                Ne = ft(xe.G[0], xe.H[0], U);
            if (U.h)
              break;
            if (Me || 256 > Ne) {
              if (!Me)
                if (xe.nd)
                  p[Q] = (xe.qb | Ne << 8) >>> 0;
                else {
                  if (qe(U), Me = ft(xe.G[1], xe.H[1], U), qe(U), ot = ft(xe.G[2], xe.H[2], U), et = ft(xe.G[3], xe.H[3], U), U.h)
                    break;
                  p[Q] = (et << 24 | Me << 16 | Ne << 8 | ot) >>> 0;
                }
              if (Me = !1, ++Q, ++D >= x && (D = 0, ++O, R != null && O <= M && !(O % 16) && R(h, O), ie != null))
                for (; Y < Q; )
                  Ne = p[Y++], ie.X[(506832829 * Ne & 4294967295) >>> ie.Mb] = Ne;
            } else if (280 > Ne) {
              if (Ne = Ie(Ne - 256, U), ot = ft(xe.G[4], xe.H[4], U), qe(U), ot = nt(x, ot = Ie(ot, U)), U.h)
                break;
              if (Q - b < ot || C - Q < Ne)
                break e;
              for (et = 0; et < Ne; ++et)
                p[Q + et] = p[Q + et - ot];
              for (Q += Ne, D += Ne; D >= x; )
                D -= x, ++O, R != null && O <= M && !(O % 16) && R(h, O);
              if (e(Q <= C), D & le && (xe = xt(W, D, O)), ie != null)
                for (; Y < Q; )
                  Ne = p[Y++], ie.X[(506832829 * Ne & 4294967295) >>> ie.Mb] = Ne;
            } else {
              if (!(Ne < fe))
                break e;
              for (Me = Ne - 280, e(ie != null); Y < Q; )
                Ne = p[Y++], ie.X[(506832829 * Ne & 4294967295) >>> ie.Mb] = Ne;
              Ne = Q, e(!(Me >>> (ot = ie).Xa)), p[Ne] = ot.X[Me], Me = !0;
            }
            Me || e(U.h == Ce(U));
          }
          if (h.Pb && U.h && Q < C)
            e(h.m.h), h.a = 5, h.m = h.wd, h.$ = h.xd, 0 < h.s.ua && ut(h.s.vb, h.s.Wa);
          else {
            if (U.h)
              break e;
            R != null && R(h, O > M ? M : O), h.a = 0, h.$ = Q - b;
          }
          return 1;
        }
      return h.a = 3, 0;
    }
    function Yn(h) {
      e(h != null), h.vc = null, h.yc = null, h.Ya = null;
      var p = h.Wa;
      p != null && (p.X = null), h.vb = null, e(h != null);
    }
    function Kn() {
      var h = new uu();
      return h == null ? null : (h.a = 0, h.xb = Xl, er("Predictor", "VP8LPredictors"), er("Predictor", "VP8LPredictors_C"), er("PredictorAdd", "VP8LPredictorsAdd"), er("PredictorAdd", "VP8LPredictorsAdd_C"), ol = Un, Mn = hn, $r = Bt, $o = bi, ro = _t, Zr = bn, Zo = Gt, ye.VP8LMapColor32b = Eo, ye.VP8LMapColor8b = Sc, h);
    }
    function dn(h, p, b, x, C) {
      var M = 1, R = [h], O = [p], D = x.m, U = x.s, W = null, Q = 0;
      e:
        for (; ; ) {
          if (b)
            for (; M && ct(D, 1); ) {
              var Y = R, K = O, fe = x, ne = 1, ie = fe.m, le = fe.gc[fe.ab], xe = ct(ie, 2);
              if (fe.Oc & 1 << xe)
                M = 0;
              else {
                switch (fe.Oc |= 1 << xe, le.hc = xe, le.Ea = Y[0], le.nc = K[0], le.K = [null], ++fe.ab, e(4 >= fe.ab), xe) {
                  case 0:
                  case 1:
                    le.b = ct(ie, 3) + 2, ne = dn(Qt(le.Ea, le.b), Qt(le.nc, le.b), 0, fe, le.K), le.K = le.K[0];
                    break;
                  case 3:
                    var Me, Ne = ct(ie, 8) + 1, ot = 16 < Ne ? 0 : 4 < Ne ? 1 : 2 < Ne ? 2 : 3;
                    if (Y[0] = Qt(le.Ea, ot), le.b = ot, Me = ne = dn(Ne, 1, 0, fe, le.K)) {
                      var et, rt = Ne, $e = le, Ct = 1 << (8 >> $e.b), qt = s(Ct);
                      if (qt == null)
                        Me = 0;
                      else {
                        var yt = $e.K[0], vt = $e.w;
                        for (qt[0] = $e.K[0][0], et = 1; et < 1 * rt; ++et)
                          qt[et] = pt(yt[vt + et], qt[et - 1]);
                        for (; et < 4 * Ct; ++et)
                          qt[et] = 0;
                        $e.K[0] = null, $e.K[0] = qt, Me = 1;
                      }
                    }
                    ne = Me;
                    break;
                  case 2:
                    break;
                  default:
                    e(0);
                }
                M = ne;
              }
            }
          if (R = R[0], O = O[0], M && ct(D, 1) && !(M = 1 <= (Q = ct(D, 4)) && 11 >= Q)) {
            x.a = 3;
            break e;
          }
          var Ht;
          if (Ht = M)
            t: {
              var Sn, Ot, gn, Wn = x, Qn = R, ji = O, En = Q, Li = b, Ai = Wn.m, ni = Wn.s, ri = [null], ki = 1, Ar = 0, Es = Os[En];
              n:
                for (; ; ) {
                  if (Li && ct(Ai, 1)) {
                    var Yi = ct(Ai, 3) + 2, ts = Qt(Qn, Yi), Co = Qt(ji, Yi), Fa = ts * Co;
                    if (!dn(ts, Co, 0, Wn, ri))
                      break n;
                    for (ri = ri[0], ni.xc = Yi, Sn = 0; Sn < Fa; ++Sn) {
                      var Gi = ri[Sn] >> 8 & 65535;
                      ri[Sn] = Gi, Gi >= ki && (ki = Gi + 1);
                    }
                  }
                  if (Ai.h)
                    break n;
                  for (Ot = 0; 5 > Ot; ++Ot) {
                    var si = pu[Ot];
                    !Ot && 0 < En && (si += 1 << En), Ar < si && (Ar = si);
                  }
                  var Io = c(ki * Es, de), cl = ki, Rr = c(cl, be);
                  if (Rr == null)
                    var mr = null;
                  else
                    e(65536 >= cl), mr = Rr;
                  var nr = s(Ar);
                  if (mr == null || nr == null || Io == null) {
                    Wn.a = 1;
                    break n;
                  }
                  var Ei = Io;
                  for (Sn = gn = 0; Sn < ki; ++Sn) {
                    var Ur = mr[Sn], Da = Ur.G, Vi = Ur.H, ch = 0, ul = 1, Fc = 0;
                    for (Ot = 0; 5 > Ot; ++Ot) {
                      si = pu[Ot], Da[Ot] = Ei, Vi[Ot] = gn, !Ot && 0 < En && (si += 1 << En);
                      r: {
                        var ho, _u = si, Zl = Wn, hl = nr, uh = Ei, yu = gn, ka = 0, dl = Zl.m, af = ct(dl, 1);
                        if (r(hl, 0, 0, _u), af) {
                          var Kh = ct(dl, 1) + 1, Dc = ct(dl, 1), hh = ct(dl, Dc == 0 ? 1 : 8);
                          hl[hh] = 1, Kh == 2 && (hl[hh = ct(dl, 8)] = 1);
                          var dh = 1;
                        } else {
                          var lf = s(19), Vp = ct(dl, 4) + 4;
                          if (19 < Vp) {
                            Zl.a = 3;
                            var vu = 0;
                            break r;
                          }
                          for (ho = 0; ho < Vp; ++ho)
                            lf[Lc[ho]] = ct(dl, 3);
                          var kc = void 0, Na = void 0, za = Zl, Qo = lf, ea = _u, cf = hl, fl = 0, Yl = za.m, uf = 8, ar = c(128, de);
                          i:
                            for (; ae(ar, 0, 7, Qo, 19); ) {
                              if (ct(Yl, 1)) {
                                var hf = 2 + 2 * ct(Yl, 3);
                                if ((kc = 2 + ct(Yl, hf)) > ea)
                                  break i;
                              } else
                                kc = ea;
                              for (Na = 0; Na < ea && kc--; ) {
                                qe(Yl);
                                var df = ar[0 + (127 & Ae(Yl))];
                                Ue(Yl, Yl.u + df.g);
                                var Po = df.value;
                                if (16 > Po)
                                  cf[Na++] = Po, Po != 0 && (uf = Po);
                                else {
                                  var Nc = Po == 16, fh = Po - 16, ff = th[fh], pf = ct(Yl, Wh[fh]) + ff;
                                  if (Na + pf > ea)
                                    break i;
                                  for (var $m = Nc ? uf : 0; 0 < pf--; )
                                    cf[Na++] = $m;
                                }
                              }
                              fl = 1;
                              break i;
                            }
                          fl || (za.a = 3), dh = fl;
                        }
                        (dh = dh && !dl.h) && (ka = ae(uh, yu, 8, hl, _u)), dh && ka != 0 ? vu = ka : (Zl.a = 3, vu = 0);
                      }
                      if (vu == 0)
                        break n;
                      if (ul && nh[Ot] == 1 && (ul = Ei[gn].g == 0), ch += Ei[gn].g, gn += vu, 3 >= Ot) {
                        var bu, gf = nr[0];
                        for (bu = 1; bu < si; ++bu)
                          nr[bu] > gf && (gf = nr[bu]);
                        Fc += gf;
                      }
                    }
                    if (Ur.nd = ul, Ur.Qb = 0, ul && (Ur.qb = (Da[3][Vi[3] + 0].value << 24 | Da[1][Vi[1] + 0].value << 16 | Da[2][Vi[2] + 0].value) >>> 0, ch == 0 && 256 > Da[0][Vi[0] + 0].value && (Ur.Qb = 1, Ur.qb += Da[0][Vi[0] + 0].value << 8)), Ur.jc = !Ur.Qb && 6 > Fc, Ur.jc) {
                      var xu, pl = Ur;
                      for (xu = 0; xu < Pi; ++xu) {
                        var Ua = xu, gl = pl.pd[Ua], ph = pl.G[0][pl.H[0] + Ua];
                        256 <= ph.value ? (gl.g = ph.g + 256, gl.value = ph.value) : (gl.g = 0, gl.value = 0, Ua >>= Xe(ph, 8, gl), Ua >>= Xe(pl.G[1][pl.H[1] + Ua], 16, gl), Ua >>= Xe(pl.G[2][pl.H[2] + Ua], 0, gl), Xe(pl.G[3][pl.H[3] + Ua], 24, gl));
                      }
                    }
                  }
                  ni.vc = ri, ni.Wb = ki, ni.Ya = mr, ni.yc = Io, Ht = 1;
                  break t;
                }
              Ht = 0;
            }
          if (!(M = Ht)) {
            x.a = 3;
            break e;
          }
          if (0 < Q) {
            if (U.ua = 1 << Q, !on(U.Wa, Q)) {
              x.a = 1, M = 0;
              break e;
            }
          } else
            U.ua = 0;
          var Kl = x, qp = R, gh = O, wu = Kl.s, Au = wu.xc;
          if (Kl.c = qp, Kl.i = gh, wu.md = Qt(qp, Au), wu.wc = Au == 0 ? -1 : (1 << Au) - 1, b) {
            x.xb = $h;
            break e;
          }
          if ((W = s(R * O)) == null) {
            x.a = 1, M = 0;
            break e;
          }
          M = (M = Fn(x, W, 0, R, O, O, null)) && !D.h;
          break e;
        }
      return M ? (C != null ? C[0] = W : (e(W == null), e(b)), x.$ = 0, b || Yn(U)) : Yn(U), M;
    }
    function Dn(h, p) {
      var b = h.c * h.i, x = b + p + 16 * p;
      return e(h.c <= p), h.V = s(x), h.V == null ? (h.Ta = null, h.Ua = 0, h.a = 1, 0) : (h.Ta = h.V, h.Ua = h.Ba + b + p, 1);
    }
    function Jn(h, p) {
      var b = h.C, x = p - b, C = h.V, M = h.Ba + h.c * b;
      for (e(p <= h.l.o); 0 < x; ) {
        var R = 16 < x ? 16 : x, O = h.l.ma, D = h.l.width, U = D * R, W = O.ca, Q = O.tb + D * b, Y = h.Ta, K = h.Ua;
        $t(h, R, C, M), hu(Y, K, W, Q, U), An(O, b, b + R, W, Q, D), x -= R, C += R * h.c, b += R;
      }
      e(b == p), h.C = h.Ma = p;
    }
    function di() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function Bi() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function Xi() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = s(4), this.Lb = s(4);
    }
    function yo() {
      this.Yb = function() {
        var h = [];
        return function p(b, x, C) {
          for (var M = C[x], R = 0; R < M && (b.push(C.length > x + 1 ? [] : 0), !(C.length < x + 1)); R++)
            p(b[R], x + 1, C);
        }(h, 0, [3, 11]), h;
      }();
    }
    function Xn() {
      this.jb = s(3), this.Wc = l([4, 8], yo), this.Xc = l([4, 17], yo);
    }
    function br() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new s(4), this.od = new s(4);
    }
    function Hr() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Ri() {
      this.Na = this.la = 0;
    }
    function Oi() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function Ys() {
      this.ad = s(384), this.Za = 0, this.Ob = s(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function Ii() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new Hr()), this.Y = 0, this.ya = Array(new Ys()), this.aa = 0, this.l = new _s();
    }
    function fi() {
      this.y = s(16), this.f = s(8), this.ea = s(8);
    }
    function zo() {
      this.cb = this.a = 0, this.sc = "", this.m = new Pt(), this.Od = new di(), this.Kc = new Bi(), this.ed = new br(), this.Qa = new Xi(), this.Ic = this.$c = this.Aa = 0, this.D = new Ii(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = c(8, Pt), this.ia = 0, this.pb = c(4, Oi), this.Pa = new Xn(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new fi()), this.Hd = 0, this.rb = Array(new Ri()), this.sb = 0, this.wa = Array(new Hr()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new Ys()), this.L = this.aa = 0, this.gd = l([4, 2], Hr), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function _s() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function xi() {
      var h = new zo();
      return h != null && (h.a = 0, h.sc = "OK", h.cb = 0, h.Xb = 0, ws || (ws = Ks)), h;
    }
    function Nn(h, p, b) {
      return h.a == 0 && (h.a = p, h.sc = b, h.cb = 0), 0;
    }
    function Wr(h, p, b) {
      return 3 <= b && h[p + 0] == 157 && h[p + 1] == 1 && h[p + 2] == 42;
    }
    function _i(h, p) {
      if (h == null)
        return 0;
      if (h.a = 0, h.sc = "OK", p == null)
        return Nn(h, 2, "null VP8Io passed to VP8GetHeaders()");
      var b = p.data, x = p.w, C = p.ha;
      if (4 > C)
        return Nn(h, 7, "Truncated header.");
      var M = b[x + 0] | b[x + 1] << 8 | b[x + 2] << 16, R = h.Od;
      if (R.Rb = !(1 & M), R.td = M >> 1 & 7, R.yd = M >> 4 & 1, R.ub = M >> 5, 3 < R.td)
        return Nn(h, 3, "Incorrect keyframe parameters.");
      if (!R.yd)
        return Nn(h, 4, "Frame not displayable.");
      x += 3, C -= 3;
      var O = h.Kc;
      if (R.Rb) {
        if (7 > C)
          return Nn(h, 7, "cannot parse picture header");
        if (!Wr(b, x, C))
          return Nn(h, 3, "Bad code word");
        O.c = 16383 & (b[x + 4] << 8 | b[x + 3]), O.Td = b[x + 4] >> 6, O.i = 16383 & (b[x + 6] << 8 | b[x + 5]), O.Ud = b[x + 6] >> 6, x += 7, C -= 7, h.za = O.c + 15 >> 4, h.Ub = O.i + 15 >> 4, p.width = O.c, p.height = O.i, p.Da = 0, p.j = 0, p.v = 0, p.va = p.width, p.o = p.height, p.da = 0, p.ib = p.width, p.hb = p.height, p.U = p.width, p.T = p.height, r((M = h.Pa).jb, 0, 255, M.jb.length), e((M = h.Qa) != null), M.Cb = 0, M.Bb = 0, M.Fb = 1, r(M.Zb, 0, 0, M.Zb.length), r(M.Lb, 0, 0, M.Lb);
      }
      if (R.ub > C)
        return Nn(h, 7, "bad partition length");
      tt(M = h.m, b, x, R.ub), x += R.ub, C -= R.ub, R.Rb && (O.Ld = Ke(M), O.Kd = Ke(M)), O = h.Qa;
      var D, U = h.Pa;
      if (e(M != null), e(O != null), O.Cb = Ke(M), O.Cb) {
        if (O.Bb = Ke(M), Ke(M)) {
          for (O.Fb = Ke(M), D = 0; 4 > D; ++D)
            O.Zb[D] = Ke(M) ? lt(M, 7) : 0;
          for (D = 0; 4 > D; ++D)
            O.Lb[D] = Ke(M) ? lt(M, 6) : 0;
        }
        if (O.Bb)
          for (D = 0; 3 > D; ++D)
            U.jb[D] = Ke(M) ? st(M, 8) : 255;
      } else
        O.Bb = 0;
      if (M.Ka)
        return Nn(h, 3, "cannot parse segment header");
      if ((O = h.ed).zd = Ke(M), O.Tb = st(M, 6), O.wb = st(M, 3), O.Pc = Ke(M), O.Pc && Ke(M)) {
        for (U = 0; 4 > U; ++U)
          Ke(M) && (O.vd[U] = lt(M, 6));
        for (U = 0; 4 > U; ++U)
          Ke(M) && (O.od[U] = lt(M, 6));
      }
      if (h.L = O.Tb == 0 ? 0 : O.zd ? 1 : 2, M.Ka)
        return Nn(h, 3, "cannot parse filter header");
      var W = C;
      if (C = D = x, x = D + W, O = W, h.Xb = (1 << st(h.m, 2)) - 1, W < 3 * (U = h.Xb))
        b = 7;
      else {
        for (D += 3 * U, O -= 3 * U, W = 0; W < U; ++W) {
          var Q = b[C + 0] | b[C + 1] << 8 | b[C + 2] << 16;
          Q > O && (Q = O), tt(h.Jc[+W], b, D, Q), D += Q, O -= Q, C += 3;
        }
        tt(h.Jc[+U], b, D, O), b = D < x ? 0 : 5;
      }
      if (b != 0)
        return Nn(h, b, "cannot parse partitions");
      for (b = st(D = h.m, 7), C = Ke(D) ? lt(D, 4) : 0, x = Ke(D) ? lt(D, 4) : 0, O = Ke(D) ? lt(D, 4) : 0, U = Ke(D) ? lt(D, 4) : 0, D = Ke(D) ? lt(D, 4) : 0, W = h.Qa, Q = 0; 4 > Q; ++Q) {
        if (W.Cb) {
          var Y = W.Zb[Q];
          W.Fb || (Y += b);
        } else {
          if (0 < Q) {
            h.pb[Q] = h.pb[0];
            continue;
          }
          Y = b;
        }
        var K = h.pb[Q];
        K.Sc[0] = Mc[zr(Y + C, 127)], K.Sc[1] = xs[zr(Y + 0, 127)], K.Eb[0] = 2 * Mc[zr(Y + x, 127)], K.Eb[1] = 101581 * xs[zr(Y + O, 127)] >> 16, 8 > K.Eb[1] && (K.Eb[1] = 8), K.Qc[0] = Mc[zr(Y + U, 117)], K.Qc[1] = xs[zr(Y + D, 127)], K.lc = Y + D;
      }
      if (!R.Rb)
        return Nn(h, 4, "Not a key frame.");
      for (Ke(M), R = h.Pa, b = 0; 4 > b; ++b) {
        for (C = 0; 8 > C; ++C)
          for (x = 0; 3 > x; ++x)
            for (O = 0; 11 > O; ++O)
              U = Ze(M, Wl[b][C][x][O]) ? st(M, 8) : of[b][C][x][O], R.Wc[b][C].Yb[x][O] = U;
        for (C = 0; 17 > C; ++C)
          R.Xc[b][C] = R.Wc[b][So[C]];
      }
      return h.kc = Ke(M), h.kc && (h.Bd = st(M, 8)), h.cb = 1;
    }
    function Ks(h, p, b, x, C, M, R) {
      var O = p[C].Yb[b];
      for (b = 0; 16 > C; ++C) {
        if (!Ze(h, O[b + 0]))
          return C;
        for (; !Ze(h, O[b + 1]); )
          if (O = p[++C].Yb[0], b = 0, C == 16)
            return 16;
        var D = p[C + 1].Yb;
        if (Ze(h, O[b + 2])) {
          var U = h, W = 0;
          if (Ze(U, (Y = O)[(Q = b) + 3]))
            if (Ze(U, Y[Q + 6])) {
              for (O = 0, Q = 2 * (W = Ze(U, Y[Q + 8])) + (Y = Ze(U, Y[Q + 9 + W])), W = 0, Y = sf[Q]; Y[O]; ++O)
                W += W + Ze(U, Y[O]);
              W += 3 + (8 << Q);
            } else
              Ze(U, Y[Q + 7]) ? (W = 7 + 2 * Ze(U, 165), W += Ze(U, 145)) : W = 5 + Ze(U, 159);
          else
            W = Ze(U, Y[Q + 4]) ? 3 + Ze(U, Y[Q + 5]) : 2;
          O = D[2];
        } else
          W = 1, O = D[1];
        D = R + ih[C], 0 > (U = h).b && We(U);
        var Q, Y = U.b, K = (Q = U.Ca >> 1) - (U.I >> Y) >> 31;
        --U.b, U.Ca += K, U.Ca |= 1, U.I -= (Q + 1 & K) << Y, M[D] = ((W ^ K) - K) * x[(0 < C) + 0];
      }
      return 16;
    }
    function hr(h) {
      var p = h.rb[h.sb - 1];
      p.la = 0, p.Na = 0, r(h.zc, 0, 0, h.zc.length), h.ja = 0;
    }
    function Qs(h, p) {
      if (h == null)
        return 0;
      if (p == null)
        return Nn(h, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!h.cb && !_i(h, p))
        return 0;
      if (e(h.cb), p.ac == null || p.ac(p)) {
        p.ob && (h.L = 0);
        var b = E[h.L];
        if (h.L == 2 ? (h.yb = 0, h.zb = 0) : (h.yb = p.v - b >> 4, h.zb = p.j - b >> 4, 0 > h.yb && (h.yb = 0), 0 > h.zb && (h.zb = 0)), h.Va = p.o + 15 + b >> 4, h.Hb = p.va + 15 + b >> 4, h.Hb > h.za && (h.Hb = h.za), h.Va > h.Ub && (h.Va = h.Ub), 0 < h.L) {
          var x = h.ed;
          for (b = 0; 4 > b; ++b) {
            var C;
            if (h.Qa.Cb) {
              var M = h.Qa.Lb[b];
              h.Qa.Fb || (M += x.Tb);
            } else
              M = x.Tb;
            for (C = 0; 1 >= C; ++C) {
              var R = h.gd[b][C], O = M;
              if (x.Pc && (O += x.vd[0], C && (O += x.od[0])), 0 < (O = 0 > O ? 0 : 63 < O ? 63 : O)) {
                var D = O;
                0 < x.wb && (D = 4 < x.wb ? D >> 2 : D >> 1) > 9 - x.wb && (D = 9 - x.wb), 1 > D && (D = 1), R.dd = D, R.tc = 2 * O + D, R.ld = 40 <= O ? 2 : 15 <= O ? 1 : 0;
              } else
                R.tc = 0;
              R.La = C;
            }
          }
        }
        b = 0;
      } else
        Nn(h, 6, "Frame setup failed"), b = h.a;
      if (b = b == 0) {
        if (b) {
          h.$c = 0, 0 < h.Aa || (h.Ic = f);
          e: {
            b = h.Ic, x = 4 * (D = h.za);
            var U = 32 * D, W = D + 1, Q = 0 < h.L ? D * (0 < h.Aa ? 2 : 1) : 0, Y = (h.Aa == 2 ? 2 : 1) * D;
            if ((R = x + 832 + (C = 3 * (16 * b + E[h.L]) / 2 * U) + (M = h.Fa != null && 0 < h.Fa.length ? h.Kc.c * h.Kc.i : 0)) != R)
              b = 0;
            else {
              if (R > h.Vb) {
                if (h.Vb = 0, h.Ec = s(R), h.Fc = 0, h.Ec == null) {
                  b = Nn(h, 1, "no memory during frame initialization.");
                  break e;
                }
                h.Vb = R;
              }
              R = h.Ec, O = h.Fc, h.Ac = R, h.Bc = O, O += x, h.Gd = c(U, fi), h.Hd = 0, h.rb = c(W + 1, Ri), h.sb = 1, h.wa = Q ? c(Q, Hr) : null, h.Y = 0, h.D.Nb = 0, h.D.wa = h.wa, h.D.Y = h.Y, 0 < h.Aa && (h.D.Y += D), e(!0), h.oc = R, h.pc = O, O += 832, h.ya = c(Y, Ys), h.aa = 0, h.D.ya = h.ya, h.D.aa = h.aa, h.Aa == 2 && (h.D.aa += D), h.R = 16 * D, h.B = 8 * D, D = (U = E[h.L]) * h.R, U = U / 2 * h.B, h.sa = R, h.ta = O + D, h.qa = h.sa, h.ra = h.ta + 16 * b * h.R + U, h.Ha = h.qa, h.Ia = h.ra + 8 * b * h.B + U, h.$c = 0, O += C, h.mb = M ? R : null, h.nb = M ? O : null, e(O + M <= h.Fc + h.Vb), hr(h), r(h.Ac, h.Bc, 0, x), b = 1;
            }
          }
          if (b) {
            if (p.ka = 0, p.y = h.sa, p.O = h.ta, p.f = h.qa, p.N = h.ra, p.ea = h.Ha, p.Vd = h.Ia, p.fa = h.R, p.Rc = h.B, p.F = null, p.J = 0, !Qr) {
              for (b = -255; 255 >= b; ++b)
                du[255 + b] = 0 > b ? -b : b;
              for (b = -1020; 1020 >= b; ++b)
                eh[1020 + b] = -128 > b ? -128 : 127 < b ? 127 : b;
              for (b = -112; 112 >= b; ++b)
                wi[112 + b] = -16 > b ? -16 : 15 < b ? 15 : b;
              for (b = -255; 510 >= b; ++b)
                La[255 + b] = 0 > b ? 0 : 255 < b ? 255 : b;
              Qr = 1;
            }
            os = ge, Sa = Uo, so = ma, Yr = jo, Kr = ue, al = jn, Yo = Dl, Ta = il, Ca = lu, oo = kl, Ia = au, Mr = ya, Rs = Nl, Gn = wc, ci = _a, Zi = qo, tr = to, ao = Qu, Fs[0] = eo, Fs[1] = it, Fs[2] = el, Fs[3] = Rl, Fs[4] = vc, Fs[5] = tl, Fs[6] = vo, Fs[7] = bc, Fs[8] = su, Fs[9] = Ku, zt[0] = fr, zt[1] = Wt, zt[2] = Pn, zt[3] = Fi, zt[4] = ti, zt[5] = Qa, zt[6] = Nr, uo[0] = xo, uo[1] = St, uo[2] = ou, uo[3] = xc, uo[4] = Go, uo[5] = Ol, uo[6] = nl, b = 1;
          } else
            b = 0;
        }
        b && (b = function(K, fe) {
          for (K.M = 0; K.M < K.Va; ++K.M) {
            var ne, ie = K.Jc[K.M & K.Xb], le = K.m, xe = K;
            for (ne = 0; ne < xe.za; ++ne) {
              var Me = le, Ne = xe, ot = Ne.Ac, et = Ne.Bc + 4 * ne, rt = Ne.zc, $e = Ne.ya[Ne.aa + ne];
              if (Ne.Qa.Bb ? $e.$b = Ze(Me, Ne.Pa.jb[0]) ? 2 + Ze(Me, Ne.Pa.jb[2]) : Ze(Me, Ne.Pa.jb[1]) : $e.$b = 0, Ne.kc && ($e.Ad = Ze(Me, Ne.Bd)), $e.Za = !Ze(Me, 145) + 0, $e.Za) {
                var Ct = $e.Ob, qt = 0;
                for (Ne = 0; 4 > Ne; ++Ne) {
                  var yt, vt = rt[0 + Ne];
                  for (yt = 0; 4 > yt; ++yt) {
                    vt = rh[ot[et + yt]][vt];
                    for (var Ht = Jh[Ze(Me, vt[0])]; 0 < Ht; )
                      Ht = Jh[2 * Ht + Ze(Me, vt[Ht])];
                    vt = -Ht, ot[et + yt] = vt;
                  }
                  i(Ct, qt, ot, et, 4), qt += 4, rt[0 + Ne] = vt;
                }
              } else
                vt = Ze(Me, 156) ? Ze(Me, 128) ? 1 : 3 : Ze(Me, 163) ? 2 : 0, $e.Ob[0] = vt, r(ot, et, vt, 4), r(rt, 0, vt, 4);
              $e.Dd = Ze(Me, 142) ? Ze(Me, 114) ? Ze(Me, 183) ? 1 : 3 : 2 : 0;
            }
            if (xe.m.Ka)
              return Nn(K, 7, "Premature end-of-partition0 encountered.");
            for (; K.ja < K.za; ++K.ja) {
              if (xe = ie, Me = (le = K).rb[le.sb - 1], ot = le.rb[le.sb + le.ja], ne = le.ya[le.aa + le.ja], et = le.kc ? ne.Ad : 0)
                Me.la = ot.la = 0, ne.Za || (Me.Na = ot.Na = 0), ne.Hc = 0, ne.Gc = 0, ne.ia = 0;
              else {
                var Sn, Ot;
                if (Me = ot, ot = xe, et = le.Pa.Xc, rt = le.ya[le.aa + le.ja], $e = le.pb[rt.$b], Ne = rt.ad, Ct = 0, qt = le.rb[le.sb - 1], vt = yt = 0, r(Ne, Ct, 0, 384), rt.Za)
                  var gn = 0, Wn = et[3];
                else {
                  Ht = s(16);
                  var Qn = Me.Na + qt.Na;
                  if (Qn = ws(ot, et[1], Qn, $e.Eb, 0, Ht, 0), Me.Na = qt.Na = (0 < Qn) + 0, 1 < Qn)
                    os(Ht, 0, Ne, Ct);
                  else {
                    var ji = Ht[0] + 3 >> 3;
                    for (Ht = 0; 256 > Ht; Ht += 16)
                      Ne[Ct + Ht] = ji;
                  }
                  gn = 1, Wn = et[0];
                }
                var En = 15 & Me.la, Li = 15 & qt.la;
                for (Ht = 0; 4 > Ht; ++Ht) {
                  var Ai = 1 & Li;
                  for (ji = Ot = 0; 4 > ji; ++ji)
                    En = En >> 1 | (Ai = (Qn = ws(ot, Wn, Qn = Ai + (1 & En), $e.Sc, gn, Ne, Ct)) > gn) << 7, Ot = Ot << 2 | (3 < Qn ? 3 : 1 < Qn ? 2 : Ne[Ct + 0] != 0), Ct += 16;
                  En >>= 4, Li = Li >> 1 | Ai << 7, yt = (yt << 8 | Ot) >>> 0;
                }
                for (Wn = En, gn = Li >> 4, Sn = 0; 4 > Sn; Sn += 2) {
                  for (Ot = 0, En = Me.la >> 4 + Sn, Li = qt.la >> 4 + Sn, Ht = 0; 2 > Ht; ++Ht) {
                    for (Ai = 1 & Li, ji = 0; 2 > ji; ++ji)
                      Qn = Ai + (1 & En), En = En >> 1 | (Ai = 0 < (Qn = ws(ot, et[2], Qn, $e.Qc, 0, Ne, Ct))) << 3, Ot = Ot << 2 | (3 < Qn ? 3 : 1 < Qn ? 2 : Ne[Ct + 0] != 0), Ct += 16;
                    En >>= 2, Li = Li >> 1 | Ai << 5;
                  }
                  vt |= Ot << 4 * Sn, Wn |= En << 4 << Sn, gn |= (240 & Li) << Sn;
                }
                Me.la = Wn, qt.la = gn, rt.Hc = yt, rt.Gc = vt, rt.ia = 43690 & vt ? 0 : $e.ia, et = !(yt | vt);
              }
              if (0 < le.L && (le.wa[le.Y + le.ja] = le.gd[ne.$b][ne.Za], le.wa[le.Y + le.ja].La |= !et), xe.Ka)
                return Nn(K, 7, "Premature end-of-file encountered.");
            }
            if (hr(K), le = fe, xe = 1, ne = (ie = K).D, Me = 0 < ie.L && ie.M >= ie.zb && ie.M <= ie.Va, ie.Aa == 0)
              e: {
                if (ne.M = ie.M, ne.uc = Me, wa(ie, ne), xe = 1, ne = (Ot = ie.D).Nb, Me = (vt = E[ie.L]) * ie.R, ot = vt / 2 * ie.B, Ht = 16 * ne * ie.R, ji = 8 * ne * ie.B, et = ie.sa, rt = ie.ta - Me + Ht, $e = ie.qa, Ne = ie.ra - ot + ji, Ct = ie.Ha, qt = ie.Ia - ot + ji, Li = (En = Ot.M) == 0, yt = En >= ie.Va - 1, ie.Aa == 2 && wa(ie, Ot), Ot.uc)
                  for (Ai = (Qn = ie).D.M, e(Qn.D.uc), Ot = Qn.yb; Ot < Qn.Hb; ++Ot) {
                    gn = Ot, Wn = Ai;
                    var ni = (ri = (si = Qn).D).Nb;
                    Sn = si.R;
                    var ri = ri.wa[ri.Y + gn], ki = si.sa, Ar = si.ta + 16 * ni * Sn + 16 * gn, Es = ri.dd, Yi = ri.tc;
                    if (Yi != 0)
                      if (e(3 <= Yi), si.L == 1)
                        0 < gn && Zi(ki, Ar, Sn, Yi + 4), ri.La && ao(ki, Ar, Sn, Yi), 0 < Wn && ci(ki, Ar, Sn, Yi + 4), ri.La && tr(ki, Ar, Sn, Yi);
                      else {
                        var ts = si.B, Co = si.qa, Fa = si.ra + 8 * ni * ts + 8 * gn, Gi = si.Ha, si = si.Ia + 8 * ni * ts + 8 * gn;
                        ni = ri.ld, 0 < gn && (Ta(ki, Ar, Sn, Yi + 4, Es, ni), oo(Co, Fa, Gi, si, ts, Yi + 4, Es, ni)), ri.La && (Mr(ki, Ar, Sn, Yi, Es, ni), Gn(Co, Fa, Gi, si, ts, Yi, Es, ni)), 0 < Wn && (Yo(ki, Ar, Sn, Yi + 4, Es, ni), Ca(Co, Fa, Gi, si, ts, Yi + 4, Es, ni)), ri.La && (Ia(ki, Ar, Sn, Yi, Es, ni), Rs(Co, Fa, Gi, si, ts, Yi, Es, ni));
                      }
                  }
                if (ie.ia && alert("todo:DitherRow"), le.put != null) {
                  if (Ot = 16 * En, En = 16 * (En + 1), Li ? (le.y = ie.sa, le.O = ie.ta + Ht, le.f = ie.qa, le.N = ie.ra + ji, le.ea = ie.Ha, le.W = ie.Ia + ji) : (Ot -= vt, le.y = et, le.O = rt, le.f = $e, le.N = Ne, le.ea = Ct, le.W = qt), yt || (En -= vt), En > le.o && (En = le.o), le.F = null, le.J = null, ie.Fa != null && 0 < ie.Fa.length && Ot < En && (le.J = Ec(ie, le, Ot, En - Ot), le.F = ie.mb, le.F == null && le.F.length == 0)) {
                    xe = Nn(ie, 3, "Could not decode alpha data.");
                    break e;
                  }
                  Ot < le.j && (vt = le.j - Ot, Ot = le.j, e(!(1 & vt)), le.O += ie.R * vt, le.N += ie.B * (vt >> 1), le.W += ie.B * (vt >> 1), le.F != null && (le.J += le.width * vt)), Ot < En && (le.O += le.v, le.N += le.v >> 1, le.W += le.v >> 1, le.F != null && (le.J += le.v), le.ka = Ot - le.j, le.U = le.va - le.v, le.T = En - Ot, xe = le.put(le));
                }
                ne + 1 != ie.Ic || yt || (i(ie.sa, ie.ta - Me, et, rt + 16 * ie.R, Me), i(ie.qa, ie.ra - ot, $e, Ne + 8 * ie.B, ot), i(ie.Ha, ie.Ia - ot, Ct, qt + 8 * ie.B, ot));
              }
            if (!xe)
              return Nn(K, 6, "Output aborted.");
          }
          return 1;
        }(h, p)), p.bc != null && p.bc(p), b &= 1;
      }
      return b ? (h.cb = 0, b) : 0;
    }
    function Ji(h, p, b, x, C) {
      C = h[p + b + 32 * x] + (C >> 3), h[p + b + 32 * x] = -256 & C ? 0 > C ? 0 : 255 : C;
    }
    function Pr(h, p, b, x, C, M) {
      Ji(h, p, 0, b, x + C), Ji(h, p, 1, b, x + M), Ji(h, p, 2, b, x - M), Ji(h, p, 3, b, x - C);
    }
    function dr(h) {
      return (20091 * h >> 16) + h;
    }
    function Xr(h, p, b, x) {
      var C, M = 0, R = s(16);
      for (C = 0; 4 > C; ++C) {
        var O = h[p + 0] + h[p + 8], D = h[p + 0] - h[p + 8], U = (35468 * h[p + 4] >> 16) - dr(h[p + 12]), W = dr(h[p + 4]) + (35468 * h[p + 12] >> 16);
        R[M + 0] = O + W, R[M + 1] = D + U, R[M + 2] = D - U, R[M + 3] = O - W, M += 4, p++;
      }
      for (C = M = 0; 4 > C; ++C)
        O = (h = R[M + 0] + 4) + R[M + 8], D = h - R[M + 8], U = (35468 * R[M + 4] >> 16) - dr(R[M + 12]), Ji(b, x, 0, 0, O + (W = dr(R[M + 4]) + (35468 * R[M + 12] >> 16))), Ji(b, x, 1, 0, D + U), Ji(b, x, 2, 0, D - U), Ji(b, x, 3, 0, O - W), M++, x += 32;
    }
    function jn(h, p, b, x) {
      var C = h[p + 0] + 4, M = 35468 * h[p + 4] >> 16, R = dr(h[p + 4]), O = 35468 * h[p + 1] >> 16;
      Pr(b, x, 0, C + R, h = dr(h[p + 1]), O), Pr(b, x, 1, C + M, h, O), Pr(b, x, 2, C - M, h, O), Pr(b, x, 3, C - R, h, O);
    }
    function Uo(h, p, b, x, C) {
      Xr(h, p, b, x), C && Xr(h, p + 16, b, x + 4);
    }
    function ma(h, p, b, x) {
      Sa(h, p + 0, b, x, 1), Sa(h, p + 32, b, x + 128, 1);
    }
    function jo(h, p, b, x) {
      var C;
      for (h = h[p + 0] + 4, C = 0; 4 > C; ++C)
        for (p = 0; 4 > p; ++p)
          Ji(b, x, p, C, h);
    }
    function ue(h, p, b, x) {
      h[p + 0] && Yr(h, p + 0, b, x), h[p + 16] && Yr(h, p + 16, b, x + 4), h[p + 32] && Yr(h, p + 32, b, x + 128), h[p + 48] && Yr(h, p + 48, b, x + 128 + 4);
    }
    function ge(h, p, b, x) {
      var C, M = s(16);
      for (C = 0; 4 > C; ++C) {
        var R = h[p + 0 + C] + h[p + 12 + C], O = h[p + 4 + C] + h[p + 8 + C], D = h[p + 4 + C] - h[p + 8 + C], U = h[p + 0 + C] - h[p + 12 + C];
        M[0 + C] = R + O, M[8 + C] = R - O, M[4 + C] = U + D, M[12 + C] = U - D;
      }
      for (C = 0; 4 > C; ++C)
        R = (h = M[0 + 4 * C] + 3) + M[3 + 4 * C], O = M[1 + 4 * C] + M[2 + 4 * C], D = M[1 + 4 * C] - M[2 + 4 * C], U = h - M[3 + 4 * C], b[x + 0] = R + O >> 3, b[x + 16] = U + D >> 3, b[x + 32] = R - O >> 3, b[x + 48] = U - D >> 3, x += 64;
    }
    function Re(h, p, b) {
      var x, C = p - 32, M = es, R = 255 - h[C - 1];
      for (x = 0; x < b; ++x) {
        var O, D = M, U = R + h[p - 1];
        for (O = 0; O < b; ++O)
          h[p + O] = D[U + h[C + O]];
        p += 32;
      }
    }
    function it(h, p) {
      Re(h, p, 4);
    }
    function St(h, p) {
      Re(h, p, 8);
    }
    function Wt(h, p) {
      Re(h, p, 16);
    }
    function Pn(h, p) {
      var b;
      for (b = 0; 16 > b; ++b)
        i(h, p + 32 * b, h, p - 32, 16);
    }
    function Fi(h, p) {
      var b;
      for (b = 16; 0 < b; --b)
        r(h, p, h[p - 1], 16), p += 32;
    }
    function Di(h, p, b) {
      var x;
      for (x = 0; 16 > x; ++x)
        r(p, b + 32 * x, h, 16);
    }
    function fr(h, p) {
      var b, x = 16;
      for (b = 0; 16 > b; ++b)
        x += h[p - 1 + 32 * b] + h[p + b - 32];
      Di(x >> 5, h, p);
    }
    function ti(h, p) {
      var b, x = 8;
      for (b = 0; 16 > b; ++b)
        x += h[p - 1 + 32 * b];
      Di(x >> 4, h, p);
    }
    function Qa(h, p) {
      var b, x = 8;
      for (b = 0; 16 > b; ++b)
        x += h[p + b - 32];
      Di(x >> 4, h, p);
    }
    function Nr(h, p) {
      Di(128, h, p);
    }
    function yn(h, p, b) {
      return h + 2 * p + b + 2 >> 2;
    }
    function el(h, p) {
      var b, x = p - 32;
      for (x = new Uint8Array([yn(h[x - 1], h[x + 0], h[x + 1]), yn(h[x + 0], h[x + 1], h[x + 2]), yn(h[x + 1], h[x + 2], h[x + 3]), yn(h[x + 2], h[x + 3], h[x + 4])]), b = 0; 4 > b; ++b)
        i(h, p + 32 * b, x, 0, x.length);
    }
    function Rl(h, p) {
      var b = h[p - 1], x = h[p - 1 + 32], C = h[p - 1 + 64], M = h[p - 1 + 96];
      At(h, p + 0, 16843009 * yn(h[p - 1 - 32], b, x)), At(h, p + 32, 16843009 * yn(b, x, C)), At(h, p + 64, 16843009 * yn(x, C, M)), At(h, p + 96, 16843009 * yn(C, M, M));
    }
    function eo(h, p) {
      var b, x = 4;
      for (b = 0; 4 > b; ++b)
        x += h[p + b - 32] + h[p - 1 + 32 * b];
      for (x >>= 3, b = 0; 4 > b; ++b)
        r(h, p + 32 * b, x, 4);
    }
    function vc(h, p) {
      var b = h[p - 1 + 0], x = h[p - 1 + 32], C = h[p - 1 + 64], M = h[p - 1 - 32], R = h[p + 0 - 32], O = h[p + 1 - 32], D = h[p + 2 - 32], U = h[p + 3 - 32];
      h[p + 0 + 96] = yn(x, C, h[p - 1 + 96]), h[p + 1 + 96] = h[p + 0 + 64] = yn(b, x, C), h[p + 2 + 96] = h[p + 1 + 64] = h[p + 0 + 32] = yn(M, b, x), h[p + 3 + 96] = h[p + 2 + 64] = h[p + 1 + 32] = h[p + 0 + 0] = yn(R, M, b), h[p + 3 + 64] = h[p + 2 + 32] = h[p + 1 + 0] = yn(O, R, M), h[p + 3 + 32] = h[p + 2 + 0] = yn(D, O, R), h[p + 3 + 0] = yn(U, D, O);
    }
    function vo(h, p) {
      var b = h[p + 1 - 32], x = h[p + 2 - 32], C = h[p + 3 - 32], M = h[p + 4 - 32], R = h[p + 5 - 32], O = h[p + 6 - 32], D = h[p + 7 - 32];
      h[p + 0 + 0] = yn(h[p + 0 - 32], b, x), h[p + 1 + 0] = h[p + 0 + 32] = yn(b, x, C), h[p + 2 + 0] = h[p + 1 + 32] = h[p + 0 + 64] = yn(x, C, M), h[p + 3 + 0] = h[p + 2 + 32] = h[p + 1 + 64] = h[p + 0 + 96] = yn(C, M, R), h[p + 3 + 32] = h[p + 2 + 64] = h[p + 1 + 96] = yn(M, R, O), h[p + 3 + 64] = h[p + 2 + 96] = yn(R, O, D), h[p + 3 + 96] = yn(O, D, D);
    }
    function tl(h, p) {
      var b = h[p - 1 + 0], x = h[p - 1 + 32], C = h[p - 1 + 64], M = h[p - 1 - 32], R = h[p + 0 - 32], O = h[p + 1 - 32], D = h[p + 2 - 32], U = h[p + 3 - 32];
      h[p + 0 + 0] = h[p + 1 + 64] = M + R + 1 >> 1, h[p + 1 + 0] = h[p + 2 + 64] = R + O + 1 >> 1, h[p + 2 + 0] = h[p + 3 + 64] = O + D + 1 >> 1, h[p + 3 + 0] = D + U + 1 >> 1, h[p + 0 + 96] = yn(C, x, b), h[p + 0 + 64] = yn(x, b, M), h[p + 0 + 32] = h[p + 1 + 96] = yn(b, M, R), h[p + 1 + 32] = h[p + 2 + 96] = yn(M, R, O), h[p + 2 + 32] = h[p + 3 + 96] = yn(R, O, D), h[p + 3 + 32] = yn(O, D, U);
    }
    function bc(h, p) {
      var b = h[p + 0 - 32], x = h[p + 1 - 32], C = h[p + 2 - 32], M = h[p + 3 - 32], R = h[p + 4 - 32], O = h[p + 5 - 32], D = h[p + 6 - 32], U = h[p + 7 - 32];
      h[p + 0 + 0] = b + x + 1 >> 1, h[p + 1 + 0] = h[p + 0 + 64] = x + C + 1 >> 1, h[p + 2 + 0] = h[p + 1 + 64] = C + M + 1 >> 1, h[p + 3 + 0] = h[p + 2 + 64] = M + R + 1 >> 1, h[p + 0 + 32] = yn(b, x, C), h[p + 1 + 32] = h[p + 0 + 96] = yn(x, C, M), h[p + 2 + 32] = h[p + 1 + 96] = yn(C, M, R), h[p + 3 + 32] = h[p + 2 + 96] = yn(M, R, O), h[p + 3 + 64] = yn(R, O, D), h[p + 3 + 96] = yn(O, D, U);
    }
    function Ku(h, p) {
      var b = h[p - 1 + 0], x = h[p - 1 + 32], C = h[p - 1 + 64], M = h[p - 1 + 96];
      h[p + 0 + 0] = b + x + 1 >> 1, h[p + 2 + 0] = h[p + 0 + 32] = x + C + 1 >> 1, h[p + 2 + 32] = h[p + 0 + 64] = C + M + 1 >> 1, h[p + 1 + 0] = yn(b, x, C), h[p + 3 + 0] = h[p + 1 + 32] = yn(x, C, M), h[p + 3 + 32] = h[p + 1 + 64] = yn(C, M, M), h[p + 3 + 64] = h[p + 2 + 64] = h[p + 0 + 96] = h[p + 1 + 96] = h[p + 2 + 96] = h[p + 3 + 96] = M;
    }
    function su(h, p) {
      var b = h[p - 1 + 0], x = h[p - 1 + 32], C = h[p - 1 + 64], M = h[p - 1 + 96], R = h[p - 1 - 32], O = h[p + 0 - 32], D = h[p + 1 - 32], U = h[p + 2 - 32];
      h[p + 0 + 0] = h[p + 2 + 32] = b + R + 1 >> 1, h[p + 0 + 32] = h[p + 2 + 64] = x + b + 1 >> 1, h[p + 0 + 64] = h[p + 2 + 96] = C + x + 1 >> 1, h[p + 0 + 96] = M + C + 1 >> 1, h[p + 3 + 0] = yn(O, D, U), h[p + 2 + 0] = yn(R, O, D), h[p + 1 + 0] = h[p + 3 + 32] = yn(b, R, O), h[p + 1 + 32] = h[p + 3 + 64] = yn(x, b, R), h[p + 1 + 64] = h[p + 3 + 96] = yn(C, x, b), h[p + 1 + 96] = yn(M, C, x);
    }
    function ou(h, p) {
      var b;
      for (b = 0; 8 > b; ++b)
        i(h, p + 32 * b, h, p - 32, 8);
    }
    function xc(h, p) {
      var b;
      for (b = 0; 8 > b; ++b)
        r(h, p, h[p - 1], 8), p += 32;
    }
    function bo(h, p, b) {
      var x;
      for (x = 0; 8 > x; ++x)
        r(p, b + 32 * x, h, 8);
    }
    function xo(h, p) {
      var b, x = 8;
      for (b = 0; 8 > b; ++b)
        x += h[p + b - 32] + h[p - 1 + 32 * b];
      bo(x >> 4, h, p);
    }
    function Ol(h, p) {
      var b, x = 4;
      for (b = 0; 8 > b; ++b)
        x += h[p + b - 32];
      bo(x >> 3, h, p);
    }
    function Go(h, p) {
      var b, x = 4;
      for (b = 0; 8 > b; ++b)
        x += h[p - 1 + 32 * b];
      bo(x >> 3, h, p);
    }
    function nl(h, p) {
      bo(128, h, p);
    }
    function Jr(h, p, b) {
      var x = h[p - b], C = h[p + 0], M = 3 * (C - x) + Gl[1020 + h[p - 2 * b] - h[p + b]], R = Ma[112 + (M + 4 >> 3)];
      h[p - b] = es[255 + x + Ma[112 + (M + 3 >> 3)]], h[p + 0] = es[255 + C - R];
    }
    function Fl(h, p, b, x) {
      var C = h[p + 0], M = h[p + b];
      return wr[255 + h[p - 2 * b] - h[p - b]] > x || wr[255 + M - C] > x;
    }
    function Vo(h, p, b, x) {
      return 4 * wr[255 + h[p - b] - h[p + 0]] + wr[255 + h[p - 2 * b] - h[p + b]] <= x;
    }
    function Hn(h, p, b, x, C) {
      var M = h[p - 3 * b], R = h[p - 2 * b], O = h[p - b], D = h[p + 0], U = h[p + b], W = h[p + 2 * b], Q = h[p + 3 * b];
      return 4 * wr[255 + O - D] + wr[255 + R - U] > x ? 0 : wr[255 + h[p - 4 * b] - M] <= C && wr[255 + M - R] <= C && wr[255 + R - O] <= C && wr[255 + Q - W] <= C && wr[255 + W - U] <= C && wr[255 + U - D] <= C;
    }
    function _a(h, p, b, x) {
      var C = 2 * x + 1;
      for (x = 0; 16 > x; ++x)
        Vo(h, p + x, b, C) && Jr(h, p + x, b);
    }
    function qo(h, p, b, x) {
      var C = 2 * x + 1;
      for (x = 0; 16 > x; ++x)
        Vo(h, p + x * b, 1, C) && Jr(h, p + x * b, 1);
    }
    function to(h, p, b, x) {
      var C;
      for (C = 3; 0 < C; --C)
        _a(h, p += 4 * b, b, x);
    }
    function Qu(h, p, b, x) {
      var C;
      for (C = 3; 0 < C; --C)
        qo(h, p += 4, b, x);
    }
    function ys(h, p, b, x, C, M, R, O) {
      for (M = 2 * M + 1; 0 < C--; ) {
        if (Hn(h, p, b, M, R))
          if (Fl(h, p, b, O))
            Jr(h, p, b);
          else {
            var D = h, U = p, W = b, Q = D[U - 2 * W], Y = D[U - W], K = D[U + 0], fe = D[U + W], ne = D[U + 2 * W], ie = 27 * (xe = Gl[1020 + 3 * (K - Y) + Gl[1020 + Q - fe]]) + 63 >> 7, le = 18 * xe + 63 >> 7, xe = 9 * xe + 63 >> 7;
            D[U - 3 * W] = es[255 + D[U - 3 * W] + xe], D[U - 2 * W] = es[255 + Q + le], D[U - W] = es[255 + Y + ie], D[U + 0] = es[255 + K - ie], D[U + W] = es[255 + fe - le], D[U + 2 * W] = es[255 + ne - xe];
          }
        p += x;
      }
    }
    function no(h, p, b, x, C, M, R, O) {
      for (M = 2 * M + 1; 0 < C--; ) {
        if (Hn(h, p, b, M, R))
          if (Fl(h, p, b, O))
            Jr(h, p, b);
          else {
            var D = h, U = p, W = b, Q = D[U - W], Y = D[U + 0], K = D[U + W], fe = Ma[112 + ((ne = 3 * (Y - Q)) + 4 >> 3)], ne = Ma[112 + (ne + 3 >> 3)], ie = fe + 1 >> 1;
            D[U - 2 * W] = es[255 + D[U - 2 * W] + ie], D[U - W] = es[255 + Q + ne], D[U + 0] = es[255 + Y - fe], D[U + W] = es[255 + K - ie];
          }
        p += x;
      }
    }
    function Dl(h, p, b, x, C, M) {
      ys(h, p, b, 1, 16, x, C, M);
    }
    function il(h, p, b, x, C, M) {
      ys(h, p, 1, b, 16, x, C, M);
    }
    function au(h, p, b, x, C, M) {
      var R;
      for (R = 3; 0 < R; --R)
        no(h, p += 4 * b, b, 1, 16, x, C, M);
    }
    function ya(h, p, b, x, C, M) {
      var R;
      for (R = 3; 0 < R; --R)
        no(h, p += 4, 1, b, 16, x, C, M);
    }
    function lu(h, p, b, x, C, M, R, O) {
      ys(h, p, C, 1, 8, M, R, O), ys(b, x, C, 1, 8, M, R, O);
    }
    function kl(h, p, b, x, C, M, R, O) {
      ys(h, p, 1, C, 8, M, R, O), ys(b, x, 1, C, 8, M, R, O);
    }
    function Nl(h, p, b, x, C, M, R, O) {
      no(h, p + 4 * C, C, 1, 8, M, R, O), no(b, x + 4 * C, C, 1, 8, M, R, O);
    }
    function wc(h, p, b, x, C, M, R, O) {
      no(h, p + 4, 1, C, 8, M, R, O), no(b, x + 4, 1, C, 8, M, R, O);
    }
    function Ps() {
      this.ba = new sr(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new ve(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function zl() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function Ac() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function cu() {
      this.ua = 0, this.Wa = new re(), this.vb = new re(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new be(), this.yc = new de();
    }
    function uu() {
      this.xb = this.a = 0, this.l = new _s(), this.ca = new sr(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new se(), this.Pb = 0, this.wd = new se(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new cu(), this.ab = 0, this.gc = c(4, Ac), this.Oc = 0;
    }
    function wo() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new _s(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function rl(h, p, b, x, C, M, R) {
      for (h = h == null ? 0 : h[p + 0], p = 0; p < R; ++p)
        C[M + p] = h + b[x + p] & 255, h = C[M + p];
    }
    function va(h, p, b, x, C, M, R) {
      var O;
      if (h == null)
        rl(null, null, b, x, C, M, R);
      else
        for (O = 0; O < R; ++O)
          C[M + O] = h[p + O] + b[x + O] & 255;
    }
    function ba(h, p, b, x, C, M, R) {
      if (h == null)
        rl(null, null, b, x, C, M, R);
      else {
        var O, D = h[p + 0], U = D, W = D;
        for (O = 0; O < R; ++O)
          U = W + (D = h[p + O]) - U, W = b[x + O] + (-256 & U ? 0 > U ? 0 : 255 : U) & 255, U = D, C[M + O] = W;
      }
    }
    function Ec(h, p, b, x) {
      var C = p.width, M = p.o;
      if (e(h != null && p != null), 0 > b || 0 >= x || b + x > M)
        return null;
      if (!h.Cc) {
        if (h.ga == null) {
          var R;
          if (h.ga = new wo(), (R = h.ga == null) || (R = p.width * p.o, e(h.Gb.length == 0), h.Gb = s(R), h.Uc = 0, h.Gb == null ? R = 0 : (h.mb = h.Gb, h.nb = h.Uc, h.rc = null, R = 1), R = !R), !R) {
            R = h.ga;
            var O = h.Fa, D = h.P, U = h.qc, W = h.mb, Q = h.nb, Y = D + 1, K = U - 1, fe = R.l;
            if (e(O != null && W != null && p != null), Br[0] = null, Br[1] = rl, Br[2] = va, Br[3] = ba, R.ca = W, R.tb = Q, R.c = p.width, R.i = p.height, e(0 < R.c && 0 < R.i), 1 >= U)
              p = 0;
            else if (R.$a = O[D + 0] >> 0 & 3, R.Z = O[D + 0] >> 2 & 3, R.Lc = O[D + 0] >> 4 & 3, D = O[D + 0] >> 6 & 3, 0 > R.$a || 1 < R.$a || 4 <= R.Z || 1 < R.Lc || D)
              p = 0;
            else if (fe.put = Oe, fe.ac = _e, fe.bc = je, fe.ma = R, fe.width = p.width, fe.height = p.height, fe.Da = p.Da, fe.v = p.v, fe.va = p.va, fe.j = p.j, fe.o = p.o, R.$a)
              e: {
                e(R.$a == 1), p = Kn();
                t:
                  for (; ; ) {
                    if (p == null) {
                      p = 0;
                      break e;
                    }
                    if (e(R != null), R.mc = p, p.c = R.c, p.i = R.i, p.l = R.l, p.l.ma = R, p.l.width = R.c, p.l.height = R.i, p.a = 0, Ye(p.m, O, Y, K), !dn(R.c, R.i, 1, p, null) || (p.ab == 1 && p.gc[0].hc == 3 && _n(p.s) ? (R.ic = 1, O = p.c * p.i, p.Ta = null, p.Ua = 0, p.V = s(O), p.Ba = 0, p.V == null ? (p.a = 1, p = 0) : p = 1) : (R.ic = 0, p = Dn(p, R.c)), !p))
                      break t;
                    p = 1;
                    break e;
                  }
                R.mc = null, p = 0;
              }
            else
              p = K >= R.c * R.i;
            R = !p;
          }
          if (R)
            return null;
          h.ga.Lc != 1 ? h.Ga = 0 : x = M - b;
        }
        e(h.ga != null), e(b + x <= M);
        e: {
          if (p = (O = h.ga).c, M = O.l.o, O.$a == 0) {
            if (Y = h.rc, K = h.Vc, fe = h.Fa, D = h.P + 1 + b * p, U = h.mb, W = h.nb + b * p, e(D <= h.P + h.qc), O.Z != 0)
              for (e(Br[O.Z] != null), R = 0; R < x; ++R)
                Br[O.Z](Y, K, fe, D, U, W, p), Y = U, K = W, W += p, D += p;
            else
              for (R = 0; R < x; ++R)
                i(U, W, fe, D, p), Y = U, K = W, W += p, D += p;
            h.rc = Y, h.Vc = K;
          } else {
            if (e(O.mc != null), p = b + x, e((R = O.mc) != null), e(p <= R.i), R.C >= p)
              p = 1;
            else if (O.ic || Je(), O.ic) {
              O = R.V, Y = R.Ba, K = R.c;
              var ne = R.i, ie = (fe = 1, D = R.$ / K, U = R.$ % K, W = R.m, Q = R.s, R.$), le = K * ne, xe = K * p, Me = Q.wc, Ne = ie < xe ? xt(Q, U, D) : null;
              e(ie <= le), e(p <= ne), e(_n(Q));
              t:
                for (; ; ) {
                  for (; !W.h && ie < xe; ) {
                    if (U & Me || (Ne = xt(Q, U, D)), e(Ne != null), qe(W), 256 > (ne = ft(Ne.G[0], Ne.H[0], W)))
                      O[Y + ie] = ne, ++ie, ++U >= K && (U = 0, ++D <= p && !(D % 16) && an(R, D));
                    else {
                      if (!(280 > ne)) {
                        fe = 0;
                        break t;
                      }
                      ne = Ie(ne - 256, W);
                      var ot, et = ft(Ne.G[4], Ne.H[4], W);
                      if (qe(W), !(ie >= (et = nt(K, et = Ie(et, W))) && le - ie >= ne)) {
                        fe = 0;
                        break t;
                      }
                      for (ot = 0; ot < ne; ++ot)
                        O[Y + ie + ot] = O[Y + ie + ot - et];
                      for (ie += ne, U += ne; U >= K; )
                        U -= K, ++D <= p && !(D % 16) && an(R, D);
                      ie < xe && U & Me && (Ne = xt(Q, U, D));
                    }
                    e(W.h == Ce(W));
                  }
                  an(R, D > p ? p : D);
                  break t;
                }
              !fe || W.h && ie < le ? (fe = 0, R.a = W.h ? 5 : 3) : R.$ = ie, p = fe;
            } else
              p = Fn(R, R.V, R.Ba, R.c, R.i, p, Jn);
            if (!p) {
              x = 0;
              break e;
            }
          }
          b + x >= M && (h.Cc = 1), x = 1;
        }
        if (!x)
          return null;
        if (h.Cc && ((x = h.ga) != null && (x.mc = null), h.ga = null, 0 < h.Ga))
          return alert("todo:WebPDequantizeLevels"), null;
      }
      return h.nb + b * C;
    }
    function F(h, p, b, x, C, M) {
      for (; 0 < C--; ) {
        var R, O = h, D = p + (b ? 1 : 0), U = h, W = p + (b ? 0 : 3);
        for (R = 0; R < x; ++R) {
          var Q = U[W + 4 * R];
          Q != 255 && (Q *= 32897, O[D + 4 * R + 0] = O[D + 4 * R + 0] * Q >> 23, O[D + 4 * R + 1] = O[D + 4 * R + 1] * Q >> 23, O[D + 4 * R + 2] = O[D + 4 * R + 2] * Q >> 23);
        }
        p += M;
      }
    }
    function te(h, p, b, x, C) {
      for (; 0 < x--; ) {
        var M;
        for (M = 0; M < b; ++M) {
          var R = h[p + 2 * M + 0], O = 15 & (U = h[p + 2 * M + 1]), D = 4369 * O, U = (240 & U | U >> 4) * D >> 16;
          h[p + 2 * M + 0] = (240 & R | R >> 4) * D >> 16 & 240 | (15 & R | R << 4) * D >> 16 >> 4 & 15, h[p + 2 * M + 1] = 240 & U | O;
        }
        p += C;
      }
    }
    function Ee(h, p, b, x, C, M, R, O) {
      var D, U, W = 255;
      for (U = 0; U < C; ++U) {
        for (D = 0; D < x; ++D) {
          var Q = h[p + D];
          M[R + 4 * D] = Q, W &= Q;
        }
        p += b, R += O;
      }
      return W != 255;
    }
    function ze(h, p, b, x, C) {
      var M;
      for (M = 0; M < C; ++M)
        b[x + M] = h[p + M] >> 8;
    }
    function Je() {
      bs = F, Pa = te, Ko = Ee, hu = ze;
    }
    function dt(h, p, b) {
      ye[h] = function(x, C, M, R, O, D, U, W, Q, Y, K, fe, ne, ie, le, xe, Me) {
        var Ne, ot = Me - 1 >> 1, et = O[D + 0] | U[W + 0] << 16, rt = Q[Y + 0] | K[fe + 0] << 16;
        e(x != null);
        var $e = 3 * et + rt + 131074 >> 2;
        for (p(x[C + 0], 255 & $e, $e >> 16, ne, ie), M != null && ($e = 3 * rt + et + 131074 >> 2, p(M[R + 0], 255 & $e, $e >> 16, le, xe)), Ne = 1; Ne <= ot; ++Ne) {
          var Ct = O[D + Ne] | U[W + Ne] << 16, qt = Q[Y + Ne] | K[fe + Ne] << 16, yt = et + Ct + rt + qt + 524296, vt = yt + 2 * (Ct + rt) >> 3;
          $e = vt + et >> 1, et = (yt = yt + 2 * (et + qt) >> 3) + Ct >> 1, p(x[C + 2 * Ne - 1], 255 & $e, $e >> 16, ne, ie + (2 * Ne - 1) * b), p(x[C + 2 * Ne - 0], 255 & et, et >> 16, ne, ie + (2 * Ne - 0) * b), M != null && ($e = yt + rt >> 1, et = vt + qt >> 1, p(M[R + 2 * Ne - 1], 255 & $e, $e >> 16, le, xe + (2 * Ne - 1) * b), p(M[R + 2 * Ne + 0], 255 & et, et >> 16, le, xe + (2 * Ne + 0) * b)), et = Ct, rt = qt;
        }
        1 & Me || ($e = 3 * et + rt + 131074 >> 2, p(x[C + Me - 1], 255 & $e, $e >> 16, ne, ie + (Me - 1) * b), M != null && ($e = 3 * rt + et + 131074 >> 2, p(M[R + Me - 1], 255 & $e, $e >> 16, le, xe + (Me - 1) * b)));
      };
    }
    function Tt() {
      As[Ba] = Vt, As[Ra] = Zh, As[Vl] = sh, As[ql] = oh, As[Hl] = gu, As[Tc] = ah, As[fu] = Oa, As[lo] = Zh, As[Cc] = oh, As[Ic] = gu, As[Pc] = ah;
    }
    function Xt(h) {
      return h & ~$l ? 0 > h ? 0 : 255 : h >> Rc;
    }
    function vn(h, p) {
      return Xt((19077 * h >> 8) + (26149 * p >> 8) - 14234);
    }
    function Ln(h, p, b) {
      return Xt((19077 * h >> 8) - (6419 * p >> 8) - (13320 * b >> 8) + 8708);
    }
    function zn(h, p) {
      return Xt((19077 * h >> 8) + (33050 * p >> 8) - 17685);
    }
    function $n(h, p, b, x, C) {
      x[C + 0] = vn(h, b), x[C + 1] = Ln(h, p, b), x[C + 2] = zn(h, p);
    }
    function In(h, p, b, x, C) {
      x[C + 0] = zn(h, p), x[C + 1] = Ln(h, p, b), x[C + 2] = vn(h, b);
    }
    function $i(h, p, b, x, C) {
      var M = Ln(h, p, b);
      p = M << 3 & 224 | zn(h, p) >> 3, x[C + 0] = 248 & vn(h, b) | M >> 5, x[C + 1] = p;
    }
    function fn(h, p, b, x, C) {
      var M = 240 & zn(h, p) | 15;
      x[C + 0] = 240 & vn(h, b) | Ln(h, p, b) >> 4, x[C + 1] = M;
    }
    function xr(h, p, b, x, C) {
      x[C + 0] = 255, $n(h, p, b, x, C + 1);
    }
    function kn(h, p, b, x, C) {
      In(h, p, b, x, C), x[C + 3] = 255;
    }
    function Zn(h, p, b, x, C) {
      $n(h, p, b, x, C), x[C + 3] = 255;
    }
    function zr(h, p) {
      return 0 > h ? 0 : h > p ? p : h;
    }
    function Ao(h, p, b) {
      ye[h] = function(x, C, M, R, O, D, U, W, Q) {
        for (var Y = W + (-2 & Q) * b; W != Y; )
          p(x[C + 0], M[R + 0], O[D + 0], U, W), p(x[C + 1], M[R + 0], O[D + 0], U, W + b), C += 2, ++R, ++D, W += 2 * b;
        1 & Q && p(x[C + 0], M[R + 0], O[D + 0], U, W);
      };
    }
    function Ul(h, p, b) {
      return b == 0 ? h == 0 ? p == 0 ? 6 : 5 : p == 0 ? 4 : 0 : b;
    }
    function xa(h, p, b, x, C) {
      switch (h >>> 30) {
        case 3:
          Sa(p, b, x, C, 0);
          break;
        case 2:
          al(p, b, x, C);
          break;
        case 1:
          Yr(p, b, x, C);
      }
    }
    function wa(h, p) {
      var b, x, C = p.M, M = p.Nb, R = h.oc, O = h.pc + 40, D = h.oc, U = h.pc + 584, W = h.oc, Q = h.pc + 600;
      for (b = 0; 16 > b; ++b)
        R[O + 32 * b - 1] = 129;
      for (b = 0; 8 > b; ++b)
        D[U + 32 * b - 1] = 129, W[Q + 32 * b - 1] = 129;
      for (0 < C ? R[O - 1 - 32] = D[U - 1 - 32] = W[Q - 1 - 32] = 129 : (r(R, O - 32 - 1, 127, 21), r(D, U - 32 - 1, 127, 9), r(W, Q - 32 - 1, 127, 9)), x = 0; x < h.za; ++x) {
        var Y = p.ya[p.aa + x];
        if (0 < x) {
          for (b = -1; 16 > b; ++b)
            i(R, O + 32 * b - 4, R, O + 32 * b + 12, 4);
          for (b = -1; 8 > b; ++b)
            i(D, U + 32 * b - 4, D, U + 32 * b + 4, 4), i(W, Q + 32 * b - 4, W, Q + 32 * b + 4, 4);
        }
        var K = h.Gd, fe = h.Hd + x, ne = Y.ad, ie = Y.Hc;
        if (0 < C && (i(R, O - 32, K[fe].y, 0, 16), i(D, U - 32, K[fe].f, 0, 8), i(W, Q - 32, K[fe].ea, 0, 8)), Y.Za) {
          var le = R, xe = O - 32 + 16;
          for (0 < C && (x >= h.za - 1 ? r(le, xe, K[fe].y[15], 4) : i(le, xe, K[fe + 1].y, 0, 4)), b = 0; 4 > b; b++)
            le[xe + 128 + b] = le[xe + 256 + b] = le[xe + 384 + b] = le[xe + 0 + b];
          for (b = 0; 16 > b; ++b, ie <<= 2)
            le = R, xe = O + pn[b], Fs[Y.Ob[b]](le, xe), xa(ie, ne, 16 * +b, le, xe);
        } else if (le = Ul(x, C, Y.Ob[0]), zt[le](R, O), ie != 0)
          for (b = 0; 16 > b; ++b, ie <<= 2)
            xa(ie, ne, 16 * +b, R, O + pn[b]);
        for (b = Y.Gc, le = Ul(x, C, Y.Dd), uo[le](D, U), uo[le](W, Q), ie = ne, le = D, xe = U, 255 & (Y = b >> 0) && (170 & Y ? so(ie, 256, le, xe) : Kr(ie, 256, le, xe)), Y = W, ie = Q, 255 & (b >>= 8) && (170 & b ? so(ne, 320, Y, ie) : Kr(ne, 320, Y, ie)), C < h.Ub - 1 && (i(K[fe].y, 0, R, O + 480, 16), i(K[fe].f, 0, D, U + 224, 8), i(K[fe].ea, 0, W, Q + 224, 8)), b = 8 * M * h.B, K = h.sa, fe = h.ta + 16 * x + 16 * M * h.R, ne = h.qa, Y = h.ra + 8 * x + b, ie = h.Ha, le = h.Ia + 8 * x + b, b = 0; 16 > b; ++b)
          i(K, fe + b * h.R, R, O + 32 * b, 16);
        for (b = 0; 8 > b; ++b)
          i(ne, Y + b * h.B, D, U + 32 * b, 8), i(ie, le + b * h.B, W, Q + 32 * b, 8);
      }
    }
    function Ho(h, p, b, x, C, M, R, O, D) {
      var U = [0], W = [0], Q = 0, Y = D != null ? D.kd : 0, K = D ?? new zl();
      if (h == null || 12 > b)
        return 7;
      K.data = h, K.w = p, K.ha = b, p = [p], b = [b], K.gb = [K.gb];
      e: {
        var fe = p, ne = b, ie = K.gb;
        if (e(h != null), e(ne != null), e(ie != null), ie[0] = 0, 12 <= ne[0] && !t(h, fe[0], "RIFF")) {
          if (t(h, fe[0] + 8, "WEBP")) {
            ie = 3;
            break e;
          }
          var le = kt(h, fe[0] + 4);
          if (12 > le || 4294967286 < le) {
            ie = 3;
            break e;
          }
          if (Y && le > ne[0] - 8) {
            ie = 7;
            break e;
          }
          ie[0] = le, fe[0] += 12, ne[0] -= 12;
        }
        ie = 0;
      }
      if (ie != 0)
        return ie;
      for (le = 0 < K.gb[0], b = b[0]; ; ) {
        e: {
          var xe = h;
          ne = p, ie = b;
          var Me = U, Ne = W, ot = fe = [0];
          if (($e = Q = [Q])[0] = 0, 8 > ie[0])
            ie = 7;
          else {
            if (!t(xe, ne[0], "VP8X")) {
              if (kt(xe, ne[0] + 4) != 10) {
                ie = 3;
                break e;
              }
              if (18 > ie[0]) {
                ie = 7;
                break e;
              }
              var et = kt(xe, ne[0] + 8), rt = 1 + Rt(xe, ne[0] + 12);
              if (2147483648 <= rt * (xe = 1 + Rt(xe, ne[0] + 15))) {
                ie = 3;
                break e;
              }
              ot != null && (ot[0] = et), Me != null && (Me[0] = rt), Ne != null && (Ne[0] = xe), ne[0] += 18, ie[0] -= 18, $e[0] = 1;
            }
            ie = 0;
          }
        }
        if (Q = Q[0], fe = fe[0], ie != 0)
          return ie;
        if (ne = !!(2 & fe), !le && Q)
          return 3;
        if (M != null && (M[0] = !!(16 & fe)), R != null && (R[0] = ne), O != null && (O[0] = 0), R = U[0], fe = W[0], Q && ne && D == null) {
          ie = 0;
          break;
        }
        if (4 > b) {
          ie = 7;
          break;
        }
        if (le && Q || !le && !Q && !t(h, p[0], "ALPH")) {
          b = [b], K.na = [K.na], K.P = [K.P], K.Sa = [K.Sa];
          e: {
            et = h, ie = p, le = b;
            var $e = K.gb;
            Me = K.na, Ne = K.P, ot = K.Sa, rt = 22, e(et != null), e(le != null), xe = ie[0];
            var Ct = le[0];
            for (e(Me != null), e(ot != null), Me[0] = null, Ne[0] = null, ot[0] = 0; ; ) {
              if (ie[0] = xe, le[0] = Ct, 8 > Ct) {
                ie = 7;
                break e;
              }
              var qt = kt(et, xe + 4);
              if (4294967286 < qt) {
                ie = 3;
                break e;
              }
              var yt = 8 + qt + 1 & -2;
              if (rt += yt, 0 < $e && rt > $e) {
                ie = 3;
                break e;
              }
              if (!t(et, xe, "VP8 ") || !t(et, xe, "VP8L")) {
                ie = 0;
                break e;
              }
              if (Ct[0] < yt) {
                ie = 7;
                break e;
              }
              t(et, xe, "ALPH") || (Me[0] = et, Ne[0] = xe + 8, ot[0] = qt), xe += yt, Ct -= yt;
            }
          }
          if (b = b[0], K.na = K.na[0], K.P = K.P[0], K.Sa = K.Sa[0], ie != 0)
            break;
        }
        b = [b], K.Ja = [K.Ja], K.xa = [K.xa];
        e:
          if ($e = h, ie = p, le = b, Me = K.gb[0], Ne = K.Ja, ot = K.xa, et = ie[0], xe = !t($e, et, "VP8 "), rt = !t($e, et, "VP8L"), e($e != null), e(le != null), e(Ne != null), e(ot != null), 8 > le[0])
            ie = 7;
          else {
            if (xe || rt) {
              if ($e = kt($e, et + 4), 12 <= Me && $e > Me - 12) {
                ie = 3;
                break e;
              }
              if (Y && $e > le[0] - 8) {
                ie = 7;
                break e;
              }
              Ne[0] = $e, ie[0] += 8, le[0] -= 8, ot[0] = rt;
            } else
              ot[0] = 5 <= le[0] && $e[et + 0] == 47 && !($e[et + 4] >> 5), Ne[0] = le[0];
            ie = 0;
          }
        if (b = b[0], K.Ja = K.Ja[0], K.xa = K.xa[0], p = p[0], ie != 0)
          break;
        if (4294967286 < K.Ja)
          return 3;
        if (O == null || ne || (O[0] = K.xa ? 2 : 1), R = [R], fe = [fe], K.xa) {
          if (5 > b) {
            ie = 7;
            break;
          }
          O = R, Y = fe, ne = M, h == null || 5 > b ? h = 0 : 5 <= b && h[p + 0] == 47 && !(h[p + 4] >> 5) ? (le = [0], $e = [0], Me = [0], Ye(Ne = new se(), h, p, b), Be(Ne, le, $e, Me) ? (O != null && (O[0] = le[0]), Y != null && (Y[0] = $e[0]), ne != null && (ne[0] = Me[0]), h = 1) : h = 0) : h = 0;
        } else {
          if (10 > b) {
            ie = 7;
            break;
          }
          O = fe, h == null || 10 > b || !Wr(h, p + 3, b - 3) ? h = 0 : (Y = h[p + 0] | h[p + 1] << 8 | h[p + 2] << 16, ne = 16383 & (h[p + 7] << 8 | h[p + 6]), h = 16383 & (h[p + 9] << 8 | h[p + 8]), 1 & Y || 3 < (Y >> 1 & 7) || !(Y >> 4 & 1) || Y >> 5 >= K.Ja || !ne || !h ? h = 0 : (R && (R[0] = ne), O && (O[0] = h), h = 1));
        }
        if (!h || (R = R[0], fe = fe[0], Q && (U[0] != R || W[0] != fe)))
          return 3;
        D != null && (D[0] = K, D.offset = p - D.w, e(4294967286 > p - D.w), e(D.offset == D.ha - b));
        break;
      }
      return ie == 0 || ie == 7 && Q && D == null ? (M != null && (M[0] |= K.na != null && 0 < K.na.length), x != null && (x[0] = R), C != null && (C[0] = fe), 0) : ie;
    }
    function sl(h, p, b) {
      var x = p.width, C = p.height, M = 0, R = 0, O = x, D = C;
      if (p.Da = h != null && 0 < h.Da, p.Da && (O = h.cd, D = h.bd, M = h.v, R = h.j, 11 > b || (M &= -2, R &= -2), 0 > M || 0 > R || 0 >= O || 0 >= D || M + O > x || R + D > C))
        return 0;
      if (p.v = M, p.j = R, p.va = M + O, p.o = R + D, p.U = O, p.T = D, p.da = h != null && 0 < h.da, p.da) {
        if (!mn(O, D, b = [h.ib], M = [h.hb]))
          return 0;
        p.ib = b[0], p.hb = M[0];
      }
      return p.ob = h != null && h.ob, p.Kb = h == null || !h.Sd, p.da && (p.ob = p.ib < 3 * x / 4 && p.hb < 3 * C / 4, p.Kb = 0), 1;
    }
    function Ls(h) {
      if (h == null)
        return 2;
      if (11 > h.S) {
        var p = h.f.RGBA;
        p.fb += (h.height - 1) * p.A, p.A = -p.A;
      } else
        p = h.f.kb, h = h.height, p.O += (h - 1) * p.fa, p.fa = -p.fa, p.N += (h - 1 >> 1) * p.Ab, p.Ab = -p.Ab, p.W += (h - 1 >> 1) * p.Db, p.Db = -p.Db, p.F != null && (p.J += (h - 1) * p.lb, p.lb = -p.lb);
      return 0;
    }
    function Ms(h, p, b, x) {
      if (x == null || 0 >= h || 0 >= p)
        return 2;
      if (b != null) {
        if (b.Da) {
          var C = b.cd, M = b.bd, R = -2 & b.v, O = -2 & b.j;
          if (0 > R || 0 > O || 0 >= C || 0 >= M || R + C > h || O + M > p)
            return 2;
          h = C, p = M;
        }
        if (b.da) {
          if (!mn(h, p, C = [b.ib], M = [b.hb]))
            return 2;
          h = C[0], p = M[0];
        }
      }
      x.width = h, x.height = p;
      e: {
        var D = x.width, U = x.height;
        if (h = x.S, 0 >= D || 0 >= U || !(h >= Ba && 13 > h))
          h = 2;
        else {
          if (0 >= x.Rd && x.sd == null) {
            R = M = C = p = 0;
            var W = (O = D * _[h]) * U;
            if (11 > h || (M = (U + 1) / 2 * (p = (D + 1) / 2), h == 12 && (R = (C = D) * U)), (U = s(W + 2 * M + R)) == null) {
              h = 1;
              break e;
            }
            x.sd = U, 11 > h ? ((D = x.f.RGBA).eb = U, D.fb = 0, D.A = O, D.size = W) : ((D = x.f.kb).y = U, D.O = 0, D.fa = O, D.Fd = W, D.f = U, D.N = 0 + W, D.Ab = p, D.Cd = M, D.ea = U, D.W = 0 + W + M, D.Db = p, D.Ed = M, h == 12 && (D.F = U, D.J = 0 + W + 2 * M), D.Tc = R, D.lb = C);
          }
          if (p = 1, C = x.S, M = x.width, R = x.height, C >= Ba && 13 > C)
            if (11 > C)
              h = x.f.RGBA, p &= (O = Math.abs(h.A)) * (R - 1) + M <= h.size, p &= O >= M * _[C], p &= h.eb != null;
            else {
              h = x.f.kb, O = (M + 1) / 2, W = (R + 1) / 2, D = Math.abs(h.fa), U = Math.abs(h.Ab);
              var Q = Math.abs(h.Db), Y = Math.abs(h.lb), K = Y * (R - 1) + M;
              p &= D * (R - 1) + M <= h.Fd, p &= U * (W - 1) + O <= h.Cd, p = (p &= Q * (W - 1) + O <= h.Ed) & D >= M & U >= O & Q >= O, p &= h.y != null, p &= h.f != null, p &= h.ea != null, C == 12 && (p &= Y >= M, p &= K <= h.Tc, p &= h.F != null);
            }
          else
            p = 0;
          h = p ? 0 : 2;
        }
      }
      return h != 0 || b != null && b.fd && (h = Ls(x)), h;
    }
    var Pi = 64, Aa = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], Wo = 24, Ea = 32, io = 8, Lr = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    Et("Predictor0", "PredictorAdd0"), ye.Predictor0 = function() {
      return 4278190080;
    }, ye.Predictor1 = function(h) {
      return h;
    }, ye.Predictor2 = function(h, p, b) {
      return p[b + 0];
    }, ye.Predictor3 = function(h, p, b) {
      return p[b + 1];
    }, ye.Predictor4 = function(h, p, b) {
      return p[b - 1];
    }, ye.Predictor5 = function(h, p, b) {
      return Ft(Ft(h, p[b + 1]), p[b + 0]);
    }, ye.Predictor6 = function(h, p, b) {
      return Ft(h, p[b - 1]);
    }, ye.Predictor7 = function(h, p, b) {
      return Ft(h, p[b + 0]);
    }, ye.Predictor8 = function(h, p, b) {
      return Ft(p[b - 1], p[b + 0]);
    }, ye.Predictor9 = function(h, p, b) {
      return Ft(p[b + 0], p[b + 1]);
    }, ye.Predictor10 = function(h, p, b) {
      return Ft(Ft(h, p[b - 1]), Ft(p[b + 0], p[b + 1]));
    }, ye.Predictor11 = function(h, p, b) {
      var x = p[b + 0];
      return 0 >= xn(x >> 24 & 255, h >> 24 & 255, (p = p[b - 1]) >> 24 & 255) + xn(x >> 16 & 255, h >> 16 & 255, p >> 16 & 255) + xn(x >> 8 & 255, h >> 8 & 255, p >> 8 & 255) + xn(255 & x, 255 & h, 255 & p) ? x : h;
    }, ye.Predictor12 = function(h, p, b) {
      var x = p[b + 0];
      return (nn((h >> 24 & 255) + (x >> 24 & 255) - ((p = p[b - 1]) >> 24 & 255)) << 24 | nn((h >> 16 & 255) + (x >> 16 & 255) - (p >> 16 & 255)) << 16 | nn((h >> 8 & 255) + (x >> 8 & 255) - (p >> 8 & 255)) << 8 | nn((255 & h) + (255 & x) - (255 & p))) >>> 0;
    }, ye.Predictor13 = function(h, p, b) {
      var x = p[b - 1];
      return (Tn((h = Ft(h, p[b + 0])) >> 24 & 255, x >> 24 & 255) << 24 | Tn(h >> 16 & 255, x >> 16 & 255) << 16 | Tn(h >> 8 & 255, x >> 8 & 255) << 8 | Tn(h >> 0 & 255, x >> 0 & 255)) >>> 0;
    };
    var jl = ye.PredictorAdd0;
    ye.PredictorAdd1 = On, Et("Predictor2", "PredictorAdd2"), Et("Predictor3", "PredictorAdd3"), Et("Predictor4", "PredictorAdd4"), Et("Predictor5", "PredictorAdd5"), Et("Predictor6", "PredictorAdd6"), Et("Predictor7", "PredictorAdd7"), Et("Predictor8", "PredictorAdd8"), Et("Predictor9", "PredictorAdd9"), Et("Predictor10", "PredictorAdd10"), Et("Predictor11", "PredictorAdd11"), Et("Predictor12", "PredictorAdd12"), Et("Predictor13", "PredictorAdd13");
    var Xo = ye.PredictorAdd2;
    wn("ColorIndexInverseTransform", "MapARGB", "32b", function(h) {
      return h >> 8 & 255;
    }, function(h) {
      return h;
    }), wn("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(h) {
      return h;
    }, function(h) {
      return h >> 8 & 255;
    });
    var ol, Bs = ye.ColorIndexInverseTransform, Eo = ye.MapARGB, Jo = ye.VP8LColorIndexInverseTransformAlpha, Sc = ye.MapAlpha, vs = ye.VP8LPredictorsAdd = [];
    vs.length = 16, (ye.VP8LPredictors = []).length = 16, (ye.VP8LPredictorsAdd_C = []).length = 16, (ye.VP8LPredictors_C = []).length = 16;
    var Mn, $r, $o, ro, Zr, Zo, os, Sa, al, so, Yr, Kr, Yo, Ta, Ca, oo, Ia, Mr, Rs, Gn, ci, Zi, tr, ao, bs, Pa, Ko, hu, du = s(511), eh = s(2041), wi = s(225), La = s(767), Qr = 0, Gl = eh, Ma = wi, es = La, wr = du, Ba = 0, Ra = 1, Vl = 2, ql = 3, Hl = 4, Tc = 5, fu = 6, lo = 7, Cc = 8, Ic = 9, Pc = 10, Wh = [2, 3, 7], th = [3, 3, 11], pu = [280, 256, 256, 256, 40], nh = [0, 1, 1, 1, 0], Lc = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], Xh = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], Os = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], co = 8, Mc = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], xs = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], ws = null, sf = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], ih = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], Jh = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], of = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], rh = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], Wl = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], So = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], zt = [], Fs = [], uo = [], $h = 1, Xl = 2, Br = [], As = [];
    dt("UpsampleRgbLinePair", $n, 3), dt("UpsampleBgrLinePair", In, 3), dt("UpsampleRgbaLinePair", Zn, 4), dt("UpsampleBgraLinePair", kn, 4), dt("UpsampleArgbLinePair", xr, 4), dt("UpsampleRgba4444LinePair", fn, 2), dt("UpsampleRgb565LinePair", $i, 2);
    var Vt = ye.UpsampleRgbLinePair, sh = ye.UpsampleBgrLinePair, Zh = ye.UpsampleRgbaLinePair, oh = ye.UpsampleBgraLinePair, gu = ye.UpsampleArgbLinePair, ah = ye.UpsampleRgba4444LinePair, Oa = ye.UpsampleRgb565LinePair, Bc = 16, Jl = 1 << Bc - 1, Ds = -227, pi = 482, Rc = 6, $l = (256 << Rc) - 1, ll = 0, Yh = s(256), lh = s(256), Oc = s(256), To = s(256), mu = s(pi - Ds), en = s(pi - Ds);
    Ao("YuvToRgbRow", $n, 3), Ao("YuvToBgrRow", In, 3), Ao("YuvToRgbaRow", Zn, 4), Ao("YuvToBgraRow", kn, 4), Ao("YuvToArgbRow", xr, 4), Ao("YuvToRgba4444Row", fn, 2), Ao("YuvToRgb565Row", $i, 2);
    var pn = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], E = [0, 2, 8], a = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], f = 1;
    this.WebPDecodeRGBA = function(h, p, b, x, C) {
      var M = Ra, R = new Ps(), O = new sr();
      R.ba = O, O.S = M, O.width = [O.width], O.height = [O.height];
      var D = O.width, U = O.height, W = new or();
      if (W == null || h == null)
        var Q = 2;
      else
        e(W != null), Q = Ho(h, p, b, W.width, W.height, W.Pd, W.Qd, W.format, null);
      if (Q != 0 ? D = 0 : (D != null && (D[0] = W.width[0]), U != null && (U[0] = W.height[0]), D = 1), D) {
        O.width = O.width[0], O.height = O.height[0], x != null && (x[0] = O.width), C != null && (C[0] = O.height);
        e: {
          if (x = new _s(), (C = new zl()).data = h, C.w = p, C.ha = b, C.kd = 1, p = [0], e(C != null), ((h = Ho(C.data, C.w, C.ha, null, null, null, p, null, C)) == 0 || h == 7) && p[0] && (h = 4), (p = h) == 0) {
            if (e(R != null), x.data = C.data, x.w = C.w + C.offset, x.ha = C.ha - C.offset, x.put = Oe, x.ac = _e, x.bc = je, x.ma = R, C.xa) {
              if ((h = Kn()) == null) {
                R = 1;
                break e;
              }
              if (function(Y, K) {
                var fe = [0], ne = [0], ie = [0];
                t:
                  for (; ; ) {
                    if (Y == null)
                      return 0;
                    if (K == null)
                      return Y.a = 2, 0;
                    if (Y.l = K, Y.a = 0, Ye(Y.m, K.data, K.w, K.ha), !Be(Y.m, fe, ne, ie)) {
                      Y.a = 3;
                      break t;
                    }
                    if (Y.xb = Xl, K.width = fe[0], K.height = ne[0], !dn(fe[0], ne[0], 1, Y, null))
                      break t;
                    return 1;
                  }
                return e(Y.a != 0), 0;
              }(h, x)) {
                if (x = (p = Ms(x.width, x.height, R.Oa, R.ba)) == 0) {
                  t: {
                    x = h;
                    n:
                      for (; ; ) {
                        if (x == null) {
                          x = 0;
                          break t;
                        }
                        if (e(x.s.yc != null), e(x.s.Ya != null), e(0 < x.s.Wb), e((b = x.l) != null), e((C = b.ma) != null), x.xb != 0) {
                          if (x.ca = C.ba, x.tb = C.tb, e(x.ca != null), !sl(C.Oa, b, ql)) {
                            x.a = 2;
                            break n;
                          }
                          if (!Dn(x, b.width) || b.da)
                            break n;
                          if ((b.da || Nt(x.ca.S)) && Je(), 11 > x.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), x.ca.f.kb.F != null && Je()), x.Pb && 0 < x.s.ua && x.s.vb.X == null && !on(x.s.vb, x.s.Wa.Xa)) {
                            x.a = 1;
                            break n;
                          }
                          x.xb = 0;
                        }
                        if (!Fn(x, x.V, x.Ba, x.c, x.i, b.o, Kt))
                          break n;
                        C.Dc = x.Ma, x = 1;
                        break t;
                      }
                    e(x.a != 0), x = 0;
                  }
                  x = !x;
                }
                x && (p = h.a);
              } else
                p = h.a;
            } else {
              if ((h = new xi()) == null) {
                R = 1;
                break e;
              }
              if (h.Fa = C.na, h.P = C.P, h.qc = C.Sa, _i(h, x)) {
                if ((p = Ms(x.width, x.height, R.Oa, R.ba)) == 0) {
                  if (h.Aa = 0, b = R.Oa, e((C = h) != null), b != null) {
                    if (0 < (D = 0 > (D = b.Md) ? 0 : 100 < D ? 255 : 255 * D / 100)) {
                      for (U = W = 0; 4 > U; ++U)
                        12 > (Q = C.pb[U]).lc && (Q.ia = D * a[0 > Q.lc ? 0 : Q.lc] >> 3), W |= Q.ia;
                      W && (alert("todo:VP8InitRandom"), C.ia = 1);
                    }
                    C.Ga = b.Id, 100 < C.Ga ? C.Ga = 100 : 0 > C.Ga && (C.Ga = 0);
                  }
                  Qs(h, x) || (p = h.a);
                }
              } else
                p = h.a;
            }
            p == 0 && R.Oa != null && R.Oa.fd && (p = Ls(R.ba));
          }
          R = p;
        }
        M = R != 0 ? null : 11 > M ? O.f.RGBA.eb : O.f.kb.y;
      } else
        M = null;
      return M;
    };
    var _ = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function y(ye, Ve) {
    for (var Fe = "", ae = 0; ae < 4; ae++)
      Fe += String.fromCharCode(ye[Ve++]);
    return Fe;
  }
  function A(ye, Ve) {
    return (ye[Ve + 0] << 0 | ye[Ve + 1] << 8 | ye[Ve + 2] << 16) >>> 0;
  }
  function T(ye, Ve) {
    return (ye[Ve + 0] << 0 | ye[Ve + 1] << 8 | ye[Ve + 2] << 16 | ye[Ve + 3] << 24) >>> 0;
  }
  new m();
  var I = [0], L = [0], N = [], z = new m(), V = n, H = function(ye, Ve) {
    var Fe = {}, ae = 0, de = !1, Te = 0, be = 0;
    if (Fe.frames = [], !/** @license
     * Copyright (c) 2017 Dominik Homberger
    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    https://webpjs.appspot.com
    WebPRiffParser dominikhlbg@gmail.com
    */
    function(Ae, Ce, Ue, qe) {
      for (var We = 0; We < qe; We++)
        if (Ae[Ce + We] != Ue.charCodeAt(We))
          return !0;
      return !1;
    }(ye, Ve, "RIFF", 4)) {
      var tt, st;
      for (T(ye, Ve += 4), Ve += 8; Ve < ye.length; ) {
        var lt = y(ye, Ve), Ye = T(ye, Ve += 4);
        Ve += 4;
        var ht = Ye + (1 & Ye);
        switch (lt) {
          case "VP8 ":
          case "VP8L":
            Fe.frames[ae] === void 0 && (Fe.frames[ae] = {}), (se = Fe.frames[ae]).src_off = de ? be : Ve - 8, se.src_size = Te + Ye + 8, ae++, de && (de = !1, Te = 0, be = 0);
            break;
          case "VP8X":
            (se = Fe.header = {}).feature_flags = ye[Ve];
            var ct = Ve + 4;
            se.canvas_width = 1 + A(ye, ct), ct += 3, se.canvas_height = 1 + A(ye, ct), ct += 3;
            break;
          case "ALPH":
            de = !0, Te = ht + 8, be = Ve - 8;
            break;
          case "ANIM":
            (se = Fe.header).bgcolor = T(ye, Ve), ct = Ve + 4, se.loop_count = (tt = ye)[(st = ct) + 0] << 0 | tt[st + 1] << 8, ct += 2;
            break;
          case "ANMF":
            var Pt, se;
            (se = Fe.frames[ae] = {}).offset_x = 2 * A(ye, Ve), Ve += 3, se.offset_y = 2 * A(ye, Ve), Ve += 3, se.width = 1 + A(ye, Ve), Ve += 3, se.height = 1 + A(ye, Ve), Ve += 3, se.duration = A(ye, Ve), Ve += 3, Pt = ye[Ve++], se.dispose = 1 & Pt, se.blend = Pt >> 1 & 1;
        }
        lt != "ANMF" && (Ve += ht);
      }
      return Fe;
    }
  }(V, 0);
  H.response = V, H.rgbaoutput = !0, H.dataurl = !1;
  var J = H.header ? H.header : null, ce = H.frames ? H.frames : null;
  if (J) {
    J.loop_counter = J.loop_count, I = [J.canvas_height], L = [J.canvas_width];
    for (var me = 0; me < ce.length && ce[me].blend != 0; me++)
      ;
  }
  var Se = ce[0], De = z.WebPDecodeRGBA(V, Se.src_off, Se.src_size, L, I);
  Se.rgba = De, Se.imgwidth = L[0], Se.imgheight = I[0];
  for (var Le = 0; Le < L[0] * I[0] * 4; Le++)
    N[Le] = De[Le];
  return this.width = L, this.height = I, this.data = N, this;
}
(function(n) {
  var e = function() {
    return typeof Xy == "function";
  }, t = function(I, L, N, z) {
    var V = 4, H = c;
    switch (z) {
      case n.image_compression.FAST:
        V = 1, H = s;
        break;
      case n.image_compression.MEDIUM:
        V = 6, H = l;
        break;
      case n.image_compression.SLOW:
        V = 9, H = m;
    }
    I = i(I, L, N, H);
    var J = Xy(I, { level: V });
    return n.__addimage__.arrayBufferToBinaryString(J);
  }, i = function(I, L, N, z) {
    for (var V, H, J, ce = I.length / L, me = new Uint8Array(I.length + ce), Se = A(), De = 0; De < ce; De += 1) {
      if (J = De * L, V = I.subarray(J, J + L), z)
        me.set(z(V, N, H), J + De);
      else {
        for (var Le, ye = Se.length, Ve = []; Le < ye; Le += 1)
          Ve[Le] = Se[Le](V, N, H);
        var Fe = T(Ve.concat());
        me.set(Ve[Fe], J + De);
      }
      H = V;
    }
    return me;
  }, r = function(I) {
    var L = Array.apply([], I);
    return L.unshift(0), L;
  }, s = function(I, L) {
    var N, z = [], V = I.length;
    z[0] = 1;
    for (var H = 0; H < V; H += 1)
      N = I[H - L] || 0, z[H + 1] = I[H] - N + 256 & 255;
    return z;
  }, c = function(I, L, N) {
    var z, V = [], H = I.length;
    V[0] = 2;
    for (var J = 0; J < H; J += 1)
      z = N && N[J] || 0, V[J + 1] = I[J] - z + 256 & 255;
    return V;
  }, l = function(I, L, N) {
    var z, V, H = [], J = I.length;
    H[0] = 3;
    for (var ce = 0; ce < J; ce += 1)
      z = I[ce - L] || 0, V = N && N[ce] || 0, H[ce + 1] = I[ce] + 256 - (z + V >>> 1) & 255;
    return H;
  }, m = function(I, L, N) {
    var z, V, H, J, ce = [], me = I.length;
    ce[0] = 4;
    for (var Se = 0; Se < me; Se += 1)
      z = I[Se - L] || 0, V = N && N[Se] || 0, H = N && N[Se - L] || 0, J = y(z, V, H), ce[Se + 1] = I[Se] - J + 256 & 255;
    return ce;
  }, y = function(I, L, N) {
    if (I === L && L === N)
      return I;
    var z = Math.abs(L - N), V = Math.abs(I - N), H = Math.abs(I + L - N - N);
    return z <= V && z <= H ? I : V <= H ? L : N;
  }, A = function() {
    return [r, s, c, l, m];
  }, T = function(I) {
    var L = I.map(function(N) {
      return N.reduce(function(z, V) {
        return z + Math.abs(V);
      }, 0);
    });
    return L.indexOf(Math.min.apply(null, L));
  };
  n.processPNG = function(I, L, N, z) {
    var V, H, J, ce, me, Se, De, Le, ye, Ve, Fe, ae, de, Te, be, tt = this.decode.FLATE_DECODE, st = "";
    if (this.__addimage__.isArrayBuffer(I) && (I = new Uint8Array(I)), this.__addimage__.isArrayBufferView(I)) {
      if (I = (J = new dV(I)).imgData, H = J.bits, V = J.colorSpace, me = J.colors, [4, 6].indexOf(J.colorType) !== -1) {
        if (J.bits === 8) {
          ye = (Le = J.pixelBitlength == 32 ? new Uint32Array(J.decodePixels().buffer) : J.pixelBitlength == 16 ? new Uint16Array(J.decodePixels().buffer) : new Uint8Array(J.decodePixels().buffer)).length, Fe = new Uint8Array(ye * J.colors), Ve = new Uint8Array(ye);
          var lt, Ye = J.pixelBitlength - J.bits;
          for (Te = 0, be = 0; Te < ye; Te++) {
            for (de = Le[Te], lt = 0; lt < Ye; )
              Fe[be++] = de >>> lt & 255, lt += J.bits;
            Ve[Te] = de >>> lt & 255;
          }
        }
        if (J.bits === 16) {
          ye = (Le = new Uint32Array(J.decodePixels().buffer)).length, Fe = new Uint8Array(ye * (32 / J.pixelBitlength) * J.colors), Ve = new Uint8Array(ye * (32 / J.pixelBitlength)), ae = J.colors > 1, Te = 0, be = 0;
          for (var ht = 0; Te < ye; )
            de = Le[Te++], Fe[be++] = de >>> 0 & 255, ae && (Fe[be++] = de >>> 16 & 255, de = Le[Te++], Fe[be++] = de >>> 0 & 255), Ve[ht++] = de >>> 16 & 255;
          H = 8;
        }
        z !== n.image_compression.NONE && e() ? (I = t(Fe, J.width * J.colors, J.colors, z), De = t(Ve, J.width, 1, z)) : (I = Fe, De = Ve, tt = void 0);
      }
      if (J.colorType === 3 && (V = this.color_spaces.INDEXED, Se = J.palette, J.transparency.indexed)) {
        var ct = J.transparency.indexed, Pt = 0;
        for (Te = 0, ye = ct.length; Te < ye; ++Te)
          Pt += ct[Te];
        if ((Pt /= 255) === ye - 1 && ct.indexOf(0) !== -1)
          ce = [ct.indexOf(0)];
        else if (Pt !== ye) {
          for (Le = J.decodePixels(), Ve = new Uint8Array(Le.length), Te = 0, ye = Le.length; Te < ye; Te++)
            Ve[Te] = ct[Le[Te]];
          De = t(Ve, J.width, 1);
        }
      }
      var se = function(Ae) {
        var Ce;
        switch (Ae) {
          case n.image_compression.FAST:
            Ce = 11;
            break;
          case n.image_compression.MEDIUM:
            Ce = 13;
            break;
          case n.image_compression.SLOW:
            Ce = 14;
            break;
          default:
            Ce = 12;
        }
        return Ce;
      }(z);
      return tt === this.decode.FLATE_DECODE && (st = "/Predictor " + se + " "), st += "/Colors " + me + " /BitsPerComponent " + H + " /Columns " + J.width, (this.__addimage__.isArrayBuffer(I) || this.__addimage__.isArrayBufferView(I)) && (I = this.__addimage__.arrayBufferToBinaryString(I)), (De && this.__addimage__.isArrayBuffer(De) || this.__addimage__.isArrayBufferView(De)) && (De = this.__addimage__.arrayBufferToBinaryString(De)), { alias: N, data: I, index: L, filter: tt, decodeParameters: st, transparency: ce, palette: Se, sMask: De, predictor: se, width: J.width, height: J.height, bitsPerComponent: H, colorSpace: V };
    }
  };
})(Bn.API), function(n) {
  n.processGIF89A = function(e, t, i, r) {
    var s = new fV(e), c = s.width, l = s.height, m = [];
    s.decodeAndBlitFrameRGBA(0, m);
    var y = { data: m, width: c, height: l }, A = new V_(100).encode(y, 100);
    return n.processJPEG.call(this, A, t, i, r);
  }, n.processGIF87A = n.processGIF89A;
}(Bn.API), bl.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, !0), this.pos += 4, this.offset = this.datav.getUint32(this.pos, !0), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.width = this.datav.getUint32(this.pos, !0), this.pos += 4, this.height = this.datav.getInt32(this.pos, !0), this.pos += 4, this.planes = this.datav.getUint16(this.pos, !0), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, !0), this.pos += 2, this.compress = this.datav.getUint32(this.pos, !0), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.hr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.vr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.colors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var n = this.colors === 0 ? 1 << this.bitPP : this.colors;
    this.palette = new Array(n);
    for (var e = 0; e < n; e++) {
      var t = this.datav.getUint8(this.pos++, !0), i = this.datav.getUint8(this.pos++, !0), r = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0);
      this.palette[e] = { red: r, green: i, blue: t, quad: s };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = !1);
}, bl.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var n = "bit" + this.bitPP, e = this.width * this.height * 4;
    this.data = new Uint8Array(e), this[n]();
  } catch (t) {
    Ki.log("bit decode error:" + t);
  }
}, bl.prototype.bit1 = function() {
  var n, e = Math.ceil(this.width / 8), t = e % 4;
  for (n = this.height - 1; n >= 0; n--) {
    for (var i = this.bottom_up ? n : this.height - 1 - n, r = 0; r < e; r++)
      for (var s = this.datav.getUint8(this.pos++, !0), c = i * this.width * 4 + 8 * r * 4, l = 0; l < 8 && 8 * r + l < this.width; l++) {
        var m = this.palette[s >> 7 - l & 1];
        this.data[c + 4 * l] = m.blue, this.data[c + 4 * l + 1] = m.green, this.data[c + 4 * l + 2] = m.red, this.data[c + 4 * l + 3] = 255;
      }
    t !== 0 && (this.pos += 4 - t);
  }
}, bl.prototype.bit4 = function() {
  for (var n = Math.ceil(this.width / 2), e = n % 4, t = this.height - 1; t >= 0; t--) {
    for (var i = this.bottom_up ? t : this.height - 1 - t, r = 0; r < n; r++) {
      var s = this.datav.getUint8(this.pos++, !0), c = i * this.width * 4 + 2 * r * 4, l = s >> 4, m = 15 & s, y = this.palette[l];
      if (this.data[c] = y.blue, this.data[c + 1] = y.green, this.data[c + 2] = y.red, this.data[c + 3] = 255, 2 * r + 1 >= this.width)
        break;
      y = this.palette[m], this.data[c + 4] = y.blue, this.data[c + 4 + 1] = y.green, this.data[c + 4 + 2] = y.red, this.data[c + 4 + 3] = 255;
    }
    e !== 0 && (this.pos += 4 - e);
  }
}, bl.prototype.bit8 = function() {
  for (var n = this.width % 4, e = this.height - 1; e >= 0; e--) {
    for (var t = this.bottom_up ? e : this.height - 1 - e, i = 0; i < this.width; i++) {
      var r = this.datav.getUint8(this.pos++, !0), s = t * this.width * 4 + 4 * i;
      if (r < this.palette.length) {
        var c = this.palette[r];
        this.data[s] = c.red, this.data[s + 1] = c.green, this.data[s + 2] = c.blue, this.data[s + 3] = 255;
      } else
        this.data[s] = 255, this.data[s + 1] = 255, this.data[s + 2] = 255, this.data[s + 3] = 255;
    }
    n !== 0 && (this.pos += 4 - n);
  }
}, bl.prototype.bit15 = function() {
  for (var n = this.width % 3, e = parseInt("11111", 2), t = this.height - 1; t >= 0; t--) {
    for (var i = this.bottom_up ? t : this.height - 1 - t, r = 0; r < this.width; r++) {
      var s = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var c = (s & e) / e * 255 | 0, l = (s >> 5 & e) / e * 255 | 0, m = (s >> 10 & e) / e * 255 | 0, y = s >> 15 ? 255 : 0, A = i * this.width * 4 + 4 * r;
      this.data[A] = m, this.data[A + 1] = l, this.data[A + 2] = c, this.data[A + 3] = y;
    }
    this.pos += n;
  }
}, bl.prototype.bit16 = function() {
  for (var n = this.width % 3, e = parseInt("11111", 2), t = parseInt("111111", 2), i = this.height - 1; i >= 0; i--) {
    for (var r = this.bottom_up ? i : this.height - 1 - i, s = 0; s < this.width; s++) {
      var c = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var l = (c & e) / e * 255 | 0, m = (c >> 5 & t) / t * 255 | 0, y = (c >> 11) / e * 255 | 0, A = r * this.width * 4 + 4 * s;
      this.data[A] = y, this.data[A + 1] = m, this.data[A + 2] = l, this.data[A + 3] = 255;
    }
    this.pos += n;
  }
}, bl.prototype.bit24 = function() {
  for (var n = this.height - 1; n >= 0; n--) {
    for (var e = this.bottom_up ? n : this.height - 1 - n, t = 0; t < this.width; t++) {
      var i = this.datav.getUint8(this.pos++, !0), r = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0), c = e * this.width * 4 + 4 * t;
      this.data[c] = s, this.data[c + 1] = r, this.data[c + 2] = i, this.data[c + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, bl.prototype.bit32 = function() {
  for (var n = this.height - 1; n >= 0; n--)
    for (var e = this.bottom_up ? n : this.height - 1 - n, t = 0; t < this.width; t++) {
      var i = this.datav.getUint8(this.pos++, !0), r = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0), c = this.datav.getUint8(this.pos++, !0), l = e * this.width * 4 + 4 * t;
      this.data[l] = s, this.data[l + 1] = r, this.data[l + 2] = i, this.data[l + 3] = c;
    }
}, bl.prototype.getData = function() {
  return this.data;
}, /**
* @license
* Copyright (c) 2018 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  n.processBMP = function(e, t, i, r) {
    var s = new bl(e, !1), c = s.width, l = s.height, m = { data: s.getData(), width: c, height: l }, y = new V_(100).encode(m, 100);
    return n.processJPEG.call(this, y, t, i, r);
  };
}(Bn.API), WA.prototype.getData = function() {
  return this.data;
}, /**
* @license
* Copyright (c) 2019 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  n.processWEBP = function(e, t, i, r) {
    var s = new WA(e), c = s.width, l = s.height, m = { data: s.getData(), width: c, height: l }, y = new V_(100).encode(m, 100);
    return n.processJPEG.call(this, y, t, i, r);
  };
}(Bn.API), Bn.API.processRGBA = function(n, e, t) {
  for (var i = n.data, r = i.length, s = new Uint8Array(r / 4 * 3), c = new Uint8Array(r / 4), l = 0, m = 0, y = 0; y < r; y += 4) {
    var A = i[y], T = i[y + 1], I = i[y + 2], L = i[y + 3];
    s[l++] = A, s[l++] = T, s[l++] = I, c[m++] = L;
  }
  var N = this.__addimage__.arrayBufferToBinaryString(s);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(c), data: N, index: e, alias: t, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: n.width, height: n.height };
}, Bn.API.setLanguage = function(n) {
  return this.internal.languageSettings === void 0 && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = !1), { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[n] !== void 0 && (this.internal.languageSettings.languageCode = n, this.internal.languageSettings.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = !0)), this;
}, vd = Bn.API, zg = vd.getCharWidthsArray = function(n, e) {
  var t, i, r = (e = e || {}).font || this.internal.getFont(), s = e.fontSize || this.internal.getFontSize(), c = e.charSpace || this.internal.getCharSpace(), l = e.widths ? e.widths : r.metadata.Unicode.widths, m = l.fof ? l.fof : 1, y = e.kerning ? e.kerning : r.metadata.Unicode.kerning, A = y.fof ? y.fof : 1, T = e.doKerning !== !1, I = 0, L = n.length, N = 0, z = l[0] || m, V = [];
  for (t = 0; t < L; t++)
    i = n.charCodeAt(t), typeof r.metadata.widthOfString == "function" ? V.push((r.metadata.widthOfGlyph(r.metadata.characterToGlyph(i)) + c * (1e3 / s) || 0) / 1e3) : (I = T && zi(y[i]) === "object" && !isNaN(parseInt(y[i][N], 10)) ? y[i][N] / A : 0, V.push((l[i] || z) / m + I)), N = i;
  return V;
}, GA = vd.getStringUnitWidth = function(n, e) {
  var t = (e = e || {}).fontSize || this.internal.getFontSize(), i = e.font || this.internal.getFont(), r = e.charSpace || this.internal.getCharSpace();
  return vd.processArabic && (n = vd.processArabic(n)), typeof i.metadata.widthOfString == "function" ? i.metadata.widthOfString(n, t, r) / t : zg.apply(this, arguments).reduce(function(s, c) {
    return s + c;
  }, 0);
}, VA = function(n, e, t, i) {
  for (var r = [], s = 0, c = n.length, l = 0; s !== c && l + e[s] < t; )
    l += e[s], s++;
  r.push(n.slice(0, s));
  var m = s;
  for (l = 0; s !== c; )
    l + e[s] > i && (r.push(n.slice(m, s)), l = 0, m = s), l += e[s], s++;
  return m !== s && r.push(n.slice(m, s)), r;
}, qA = function(n, e, t) {
  t || (t = {});
  var i, r, s, c, l, m, y, A = [], T = [A], I = t.textIndent || 0, L = 0, N = 0, z = n.split(" "), V = zg.apply(this, [" ", t])[0];
  if (m = t.lineIndent === -1 ? z[0].length + 2 : t.lineIndent || 0) {
    var H = Array(m).join(" "), J = [];
    z.map(function(me) {
      (me = me.split(/\s*\n/)).length > 1 ? J = J.concat(me.map(function(Se, De) {
        return (De && Se.length ? `
` : "") + Se;
      })) : J.push(me[0]);
    }), z = J, m = GA.apply(this, [H, t]);
  }
  for (s = 0, c = z.length; s < c; s++) {
    var ce = 0;
    if (i = z[s], m && i[0] == `
` && (i = i.substr(1), ce = 1), I + L + (N = (r = zg.apply(this, [i, t])).reduce(function(me, Se) {
      return me + Se;
    }, 0)) > e || ce) {
      if (N > e) {
        for (l = VA.apply(this, [i, r, e - (I + L), e]), A.push(l.shift()), A = [l.pop()]; l.length; )
          T.push([l.shift()]);
        N = r.slice(i.length - (A[0] ? A[0].length : 0)).reduce(function(me, Se) {
          return me + Se;
        }, 0);
      } else
        A = [i];
      T.push(A), I = N + m, L = V;
    } else
      A.push(i), I += L + N, L = V;
  }
  return y = m ? function(me, Se) {
    return (Se ? H : "") + me.join(" ");
  } : function(me) {
    return me.join(" ");
  }, T.map(y);
}, vd.splitTextToSize = function(n, e, t) {
  var i, r = (t = t || {}).fontSize || this.internal.getFontSize(), s = (function(A) {
    if (A.widths && A.kerning)
      return { widths: A.widths, kerning: A.kerning };
    var T = this.internal.getFont(A.fontName, A.fontStyle);
    return T.metadata.Unicode ? { widths: T.metadata.Unicode.widths || { 0: 1 }, kerning: T.metadata.Unicode.kerning || {} } : { font: T.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }).call(this, t);
  i = Array.isArray(n) ? n : String(n).split(/\r?\n/);
  var c = 1 * this.internal.scaleFactor * e / r;
  s.textIndent = t.textIndent ? 1 * t.textIndent * this.internal.scaleFactor / r : 0, s.lineIndent = t.lineIndent;
  var l, m, y = [];
  for (l = 0, m = i.length; l < m; l++)
    y = y.concat(qA.apply(this, [i[l], c, s]));
  return y;
}, function(n) {
  n.__fontmetrics__ = n.__fontmetrics__ || {};
  for (var e = "klmnopqrstuvwxyz", t = {}, i = {}, r = 0; r < e.length; r++)
    t[e[r]] = "0123456789abcdef"[r], i["0123456789abcdef"[r]] = e[r];
  var s = function(T) {
    return "0x" + parseInt(T, 10).toString(16);
  }, c = n.__fontmetrics__.compress = function(T) {
    var I, L, N, z, V = ["{"];
    for (var H in T) {
      if (I = T[H], isNaN(parseInt(H, 10)) ? L = "'" + H + "'" : (H = parseInt(H, 10), L = (L = s(H).slice(2)).slice(0, -1) + i[L.slice(-1)]), typeof I == "number")
        I < 0 ? (N = s(I).slice(3), z = "-") : (N = s(I).slice(2), z = ""), N = z + N.slice(0, -1) + i[N.slice(-1)];
      else {
        if (zi(I) !== "object")
          throw new Error("Don't know what to do with value type " + zi(I) + ".");
        N = c(I);
      }
      V.push(L + N);
    }
    return V.push("}"), V.join("");
  }, l = n.__fontmetrics__.uncompress = function(T) {
    if (typeof T != "string")
      throw new Error("Invalid argument passed to uncompress.");
    for (var I, L, N, z, V = {}, H = 1, J = V, ce = [], me = "", Se = "", De = T.length - 1, Le = 1; Le < De; Le += 1)
      (z = T[Le]) == "'" ? I ? (N = I.join(""), I = void 0) : I = [] : I ? I.push(z) : z == "{" ? (ce.push([J, N]), J = {}, N = void 0) : z == "}" ? ((L = ce.pop())[0][L[1]] = J, N = void 0, J = L[0]) : z == "-" ? H = -1 : N === void 0 ? t.hasOwnProperty(z) ? (me += t[z], N = parseInt(me, 16) * H, H = 1, me = "") : me += z : t.hasOwnProperty(z) ? (Se += t[z], J[N] = parseInt(Se, 16) * H, H = 1, N = void 0, Se = "") : Se += z;
    return V;
  }, m = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: l("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, y = { Unicode: { Courier: m, "Courier-Bold": m, "Courier-BoldOblique": m, "Courier-Oblique": m, Helvetica: m, "Helvetica-Bold": m, "Helvetica-BoldOblique": m, "Helvetica-Oblique": m, "Times-Roman": m, "Times-Bold": m, "Times-BoldItalic": m, "Times-Italic": m } }, A = { Unicode: { "Courier-Oblique": l("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": l("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": l("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: l("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": l("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": l("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: l("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: l("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": l("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: l("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": l("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": l("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": l("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": l("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  n.events.push(["addFont", function(T) {
    var I = T.font, L = A.Unicode[I.postScriptName];
    L && (I.metadata.Unicode = {}, I.metadata.Unicode.widths = L.widths, I.metadata.Unicode.kerning = L.kerning);
    var N = y.Unicode[I.postScriptName];
    N && (I.metadata.Unicode.encoding = N, I.encoding = N.codePages[0]);
  }]);
}(Bn.API), /**
* @license
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  var e = function(t) {
    for (var i = t.length, r = new Uint8Array(i), s = 0; s < i; s++)
      r[s] = t.charCodeAt(s);
    return r;
  };
  n.API.events.push(["addFont", function(t) {
    var i = void 0, r = t.font, s = t.instance;
    if (!r.isStandardFont) {
      if (s === void 0)
        throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + r.postScriptName + "').");
      if (typeof (i = s.existsFileInVFS(r.postScriptName) === !1 ? s.loadFile(r.postScriptName) : s.getFileFromVFS(r.postScriptName)) != "string")
        throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + r.postScriptName + "').");
      (function(c, l) {
        l = /^\x00\x01\x00\x00/.test(l) ? e(l) : e(lp(l)), c.metadata = n.API.TTFFont.open(l), c.metadata.Unicode = c.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, c.metadata.glyIdsUsed = [0];
      })(r, i);
    }
  }]);
}(Bn), /** @license
* Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
function(n) {
  function e() {
    return (Rn.canvg ? Promise.resolve(Rn.canvg) : import("./index.es-BWyxJuJN-DdIdVRyF.mjs")).catch(function(t) {
      return Promise.reject(new Error("Could not load canvg: " + t));
    }).then(function(t) {
      return t.default ? t.default : t;
    });
  }
  Bn.API.addSvgAsImage = function(t, i, r, s, c, l, m, y) {
    if (isNaN(i) || isNaN(r))
      throw Ki.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(s) || isNaN(c))
      throw Ki.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var A = document.createElement("canvas");
    A.width = s, A.height = c;
    var T = A.getContext("2d");
    T.fillStyle = "#fff", T.fillRect(0, 0, A.width, A.height);
    var I = { ignoreMouse: !0, ignoreAnimation: !0, ignoreDimensions: !0 }, L = this;
    return e().then(function(N) {
      return N.fromString(T, t, I);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(N) {
      return N.render(I);
    }).then(function() {
      L.addImage(A.toDataURL("image/jpeg", 1), i, r, s, c, m, y);
    });
  };
}(), Bn.API.putTotalPages = function(n) {
  var e, t = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (e = new RegExp(n, "g"), t = this.internal.getNumberOfPages()) : (e = new RegExp(this.pdfEscape16(n, this.internal.getFont()), "g"), t = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var i = 1; i <= this.internal.getNumberOfPages(); i++)
    for (var r = 0; r < this.internal.pages[i].length; r++)
      this.internal.pages[i][r] = this.internal.pages[i][r].replace(e, t);
  return this;
}, Bn.API.viewerPreferences = function(n, e) {
  var t;
  n = n || {}, e = e || !1;
  var i, r, s, c = { HideToolbar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideMenubar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, FitWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, CenterWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: !1, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: !1, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: !1, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: !1, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: !1, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: !1, valueSet: null, pdfVersion: 1.7 } }, l = Object.keys(c), m = [], y = 0, A = 0, T = 0;
  function I(N, z) {
    var V, H = !1;
    for (V = 0; V < N.length; V += 1)
      N[V] === z && (H = !0);
    return H;
  }
  if (this.internal.viewerpreferences === void 0 && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(c)), this.internal.viewerpreferences.isSubscribed = !1), t = this.internal.viewerpreferences.configuration, n === "reset" || e === !0) {
    var L = l.length;
    for (T = 0; T < L; T += 1)
      t[l[T]].value = t[l[T]].defaultValue, t[l[T]].explicitSet = !1;
  }
  if (zi(n) === "object") {
    for (r in n)
      if (s = n[r], I(l, r) && s !== void 0) {
        if (t[r].type === "boolean" && typeof s == "boolean")
          t[r].value = s;
        else if (t[r].type === "name" && I(t[r].valueSet, s))
          t[r].value = s;
        else if (t[r].type === "integer" && Number.isInteger(s))
          t[r].value = s;
        else if (t[r].type === "array") {
          for (y = 0; y < s.length; y += 1)
            if (i = !0, s[y].length === 1 && typeof s[y][0] == "number")
              m.push(String(s[y] - 1));
            else if (s[y].length > 1) {
              for (A = 0; A < s[y].length; A += 1)
                typeof s[y][A] != "number" && (i = !1);
              i === !0 && m.push([s[y][0] - 1, s[y][1] - 1].join(" "));
            }
          t[r].value = "[" + m.join(" ") + "]";
        } else
          t[r].value = t[r].defaultValue;
        t[r].explicitSet = !0;
      }
  }
  return this.internal.viewerpreferences.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    var N, z = [];
    for (N in t)
      t[N].explicitSet === !0 && (t[N].type === "name" ? z.push("/" + N + " /" + t[N].value) : z.push("/" + N + " " + t[N].value));
    z.length !== 0 && this.internal.write(`/ViewerPreferences
<<
` + z.join(`
`) + `
>>`);
  }), this.internal.viewerpreferences.isSubscribed = !0), this.internal.viewerpreferences.configuration = t, this;
}, /** ====================================================================
* @license
* jsPDF XMP metadata plugin
* Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
function(n) {
  var e = function() {
    var i = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', r = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), s = unescape(encodeURIComponent(i)), c = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), l = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), m = unescape(encodeURIComponent("</x:xmpmeta>")), y = s.length + c.length + l.length + r.length + m.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + y + " >>"), this.internal.write("stream"), this.internal.write(r + s + c + l + m), this.internal.write("endstream"), this.internal.write("endobj");
  }, t = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  n.addMetadata = function(i, r) {
    return this.internal.__metadata__ === void 0 && (this.internal.__metadata__ = { metadata: i, namespaceuri: r || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", t), this.internal.events.subscribe("postPutResources", e)), this;
  };
}(Bn.API), function(n) {
  var e = n.API, t = e.pdfEscape16 = function(s, c) {
    for (var l, m = c.metadata.Unicode.widths, y = ["", "0", "00", "000", "0000"], A = [""], T = 0, I = s.length; T < I; ++T) {
      if (l = c.metadata.characterToGlyph(s.charCodeAt(T)), c.metadata.glyIdsUsed.push(l), c.metadata.toUnicode[l] = s.charCodeAt(T), m.indexOf(l) == -1 && (m.push(l), m.push([parseInt(c.metadata.widthOfGlyph(l), 10)])), l == "0")
        return A.join("");
      l = l.toString(16), A.push(y[4 - l.length], l);
    }
    return A.join("");
  }, i = function(s) {
    var c, l, m, y, A, T, I;
    for (A = `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo <<
  /Registry (Adobe)
  /Ordering (UCS)
  /Supplement 0
>> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000><ffff>
endcodespacerange`, m = [], T = 0, I = (l = Object.keys(s).sort(function(L, N) {
      return L - N;
    })).length; T < I; T++)
      c = l[T], m.length >= 100 && (A += `
` + m.length + ` beginbfchar
` + m.join(`
`) + `
endbfchar`, m = []), s[c] !== void 0 && s[c] !== null && typeof s[c].toString == "function" && (y = ("0000" + s[c].toString(16)).slice(-4), c = ("0000" + (+c).toString(16)).slice(-4), m.push("<" + c + "><" + y + ">"));
    return m.length && (A += `
` + m.length + ` beginbfchar
` + m.join(`
`) + `
endbfchar
`), A += `endcmap
CMapName currentdict /CMap defineresource pop
end
end`;
  };
  e.events.push(["putFont", function(s) {
    (function(c) {
      var l = c.font, m = c.out, y = c.newObject, A = c.putStream;
      if (l.metadata instanceof n.API.TTFFont && l.encoding === "Identity-H") {
        for (var T = l.metadata.Unicode.widths, I = l.metadata.subset.encode(l.metadata.glyIdsUsed, 1), L = "", N = 0; N < I.length; N++)
          L += String.fromCharCode(I[N]);
        var z = y();
        A({ data: L, addLength1: !0, objectId: z }), m("endobj");
        var V = y();
        A({ data: i(l.metadata.toUnicode), addLength1: !0, objectId: V }), m("endobj");
        var H = y();
        m("<<"), m("/Type /FontDescriptor"), m("/FontName /" + Ad(l.fontName)), m("/FontFile2 " + z + " 0 R"), m("/FontBBox " + n.API.PDFObject.convert(l.metadata.bbox)), m("/Flags " + l.metadata.flags), m("/StemV " + l.metadata.stemV), m("/ItalicAngle " + l.metadata.italicAngle), m("/Ascent " + l.metadata.ascender), m("/Descent " + l.metadata.decender), m("/CapHeight " + l.metadata.capHeight), m(">>"), m("endobj");
        var J = y();
        m("<<"), m("/Type /Font"), m("/BaseFont /" + Ad(l.fontName)), m("/FontDescriptor " + H + " 0 R"), m("/W " + n.API.PDFObject.convert(T)), m("/CIDToGIDMap /Identity"), m("/DW 1000"), m("/Subtype /CIDFontType2"), m("/CIDSystemInfo"), m("<<"), m("/Supplement 0"), m("/Registry (Adobe)"), m("/Ordering (" + l.encoding + ")"), m(">>"), m(">>"), m("endobj"), l.objectNumber = y(), m("<<"), m("/Type /Font"), m("/Subtype /Type0"), m("/ToUnicode " + V + " 0 R"), m("/BaseFont /" + Ad(l.fontName)), m("/Encoding /" + l.encoding), m("/DescendantFonts [" + J + " 0 R]"), m(">>"), m("endobj"), l.isAlreadyPutted = !0;
      }
    })(s);
  }]), e.events.push(["putFont", function(s) {
    (function(c) {
      var l = c.font, m = c.out, y = c.newObject, A = c.putStream;
      if (l.metadata instanceof n.API.TTFFont && l.encoding === "WinAnsiEncoding") {
        for (var T = l.metadata.rawData, I = "", L = 0; L < T.length; L++)
          I += String.fromCharCode(T[L]);
        var N = y();
        A({ data: I, addLength1: !0, objectId: N }), m("endobj");
        var z = y();
        A({ data: i(l.metadata.toUnicode), addLength1: !0, objectId: z }), m("endobj");
        var V = y();
        m("<<"), m("/Descent " + l.metadata.decender), m("/CapHeight " + l.metadata.capHeight), m("/StemV " + l.metadata.stemV), m("/Type /FontDescriptor"), m("/FontFile2 " + N + " 0 R"), m("/Flags 96"), m("/FontBBox " + n.API.PDFObject.convert(l.metadata.bbox)), m("/FontName /" + Ad(l.fontName)), m("/ItalicAngle " + l.metadata.italicAngle), m("/Ascent " + l.metadata.ascender), m(">>"), m("endobj"), l.objectNumber = y();
        for (var H = 0; H < l.metadata.hmtx.widths.length; H++)
          l.metadata.hmtx.widths[H] = parseInt(l.metadata.hmtx.widths[H] * (1e3 / l.metadata.head.unitsPerEm));
        m("<</Subtype/TrueType/Type/Font/ToUnicode " + z + " 0 R/BaseFont/" + Ad(l.fontName) + "/FontDescriptor " + V + " 0 R/Encoding/" + l.encoding + " /FirstChar 29 /LastChar 255 /Widths " + n.API.PDFObject.convert(l.metadata.hmtx.widths) + ">>"), m("endobj"), l.isAlreadyPutted = !0;
      }
    })(s);
  }]);
  var r = function(s) {
    var c, l = s.text || "", m = s.x, y = s.y, A = s.options || {}, T = s.mutex || {}, I = T.pdfEscape, L = T.activeFontKey, N = T.fonts, z = L, V = "", H = 0, J = "", ce = N[z].encoding;
    if (N[z].encoding !== "Identity-H")
      return { text: l, x: m, y, options: A, mutex: T };
    for (J = l, z = L, Array.isArray(l) && (J = l[0]), H = 0; H < J.length; H += 1)
      N[z].metadata.hasOwnProperty("cmap") && (c = N[z].metadata.cmap.unicode.codeMap[J[H].charCodeAt(0)]), c || J[H].charCodeAt(0) < 256 && N[z].metadata.hasOwnProperty("Unicode") ? V += J[H] : V += "";
    var me = "";
    return parseInt(z.slice(1)) < 14 || ce === "WinAnsiEncoding" ? me = I(V, z).split("").map(function(Se) {
      return Se.charCodeAt(0).toString(16);
    }).join("") : ce === "Identity-H" && (me = t(V, N[z])), T.isHex = !0, { text: me, x: m, y, options: A, mutex: T };
  };
  e.events.push(["postProcessText", function(s) {
    var c = s.text || "", l = [], m = { text: c, x: s.x, y: s.y, options: s.options, mutex: s.mutex };
    if (Array.isArray(c)) {
      var y = 0;
      for (y = 0; y < c.length; y += 1)
        Array.isArray(c[y]) && c[y].length === 3 ? l.push([r(Object.assign({}, m, { text: c[y][0] })).text, c[y][1], c[y][2]]) : l.push(r(Object.assign({}, m, { text: c[y] })).text);
      s.text = l;
    } else
      s.text = r(Object.assign({}, m, { text: c })).text;
  }]);
}(Bn), /**
* @license
* jsPDF virtual FileSystem functionality
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  var e = function() {
    return this.internal.vFS === void 0 && (this.internal.vFS = {}), !0;
  };
  n.existsFileInVFS = function(t) {
    return e.call(this), this.internal.vFS[t] !== void 0;
  }, n.addFileToVFS = function(t, i) {
    return e.call(this), this.internal.vFS[t] = i, this;
  }, n.getFileFromVFS = function(t) {
    return e.call(this), this.internal.vFS[t] !== void 0 ? this.internal.vFS[t] : null;
  };
}(Bn.API), /**
* @license
* Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
* MIT License
*/
function(n) {
  n.__bidiEngine__ = n.prototype.__bidiEngine__ = function(i) {
    var r, s, c, l, m, y, A, T = e, I = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], L = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], N = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, z = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, V = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], H = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), J = !1, ce = 0;
    this.__bidiEngine__ = {};
    var me = function(ae) {
      var de = ae.charCodeAt(), Te = de >> 8, be = z[Te];
      return be !== void 0 ? T[256 * be + (255 & de)] : Te === 252 || Te === 253 ? "AL" : H.test(Te) ? "L" : Te === 8 ? "R" : "N";
    }, Se = function(ae) {
      for (var de, Te = 0; Te < ae.length; Te++) {
        if ((de = me(ae.charAt(Te))) === "L")
          return !1;
        if (de === "R")
          return !0;
      }
      return !1;
    }, De = function(ae, de, Te, be) {
      var tt, st, lt, Ye, ht = de[be];
      switch (ht) {
        case "L":
        case "R":
          J = !1;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          J && (ht = "AN");
          break;
        case "AL":
          J = !0, ht = "R";
          break;
        case "WS":
          ht = "N";
          break;
        case "CS":
          be < 1 || be + 1 >= de.length || (tt = Te[be - 1]) !== "EN" && tt !== "AN" || (st = de[be + 1]) !== "EN" && st !== "AN" ? ht = "N" : J && (st = "AN"), ht = st === tt ? st : "N";
          break;
        case "ES":
          ht = (tt = be > 0 ? Te[be - 1] : "B") === "EN" && be + 1 < de.length && de[be + 1] === "EN" ? "EN" : "N";
          break;
        case "ET":
          if (be > 0 && Te[be - 1] === "EN") {
            ht = "EN";
            break;
          }
          if (J) {
            ht = "N";
            break;
          }
          for (lt = be + 1, Ye = de.length; lt < Ye && de[lt] === "ET"; )
            lt++;
          ht = lt < Ye && de[lt] === "EN" ? "EN" : "N";
          break;
        case "NSM":
          if (c && !l) {
            for (Ye = de.length, lt = be + 1; lt < Ye && de[lt] === "NSM"; )
              lt++;
            if (lt < Ye) {
              var ct = ae[be], Pt = ct >= 1425 && ct <= 2303 || ct === 64286;
              if (tt = de[lt], Pt && (tt === "R" || tt === "AL")) {
                ht = "R";
                break;
              }
            }
          }
          ht = be < 1 || (tt = de[be - 1]) === "B" ? "N" : Te[be - 1];
          break;
        case "B":
          J = !1, r = !0, ht = ce;
          break;
        case "S":
          s = !0, ht = "N";
          break;
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          J = !1;
          break;
        case "BN":
          ht = "N";
      }
      return ht;
    }, Le = function(ae, de, Te) {
      var be = ae.split("");
      return Te && ye(be, Te, { hiLevel: ce }), be.reverse(), de && de.reverse(), be.join("");
    }, ye = function(ae, de, Te) {
      var be, tt, st, lt, Ye, ht = -1, ct = ae.length, Pt = 0, se = [], Ae = ce ? L : I, Ce = [];
      for (J = !1, r = !1, s = !1, tt = 0; tt < ct; tt++)
        Ce[tt] = me(ae[tt]);
      for (st = 0; st < ct; st++) {
        if (Ye = Pt, se[st] = De(ae, Ce, se, st), be = 240 & (Pt = Ae[Ye][N[se[st]]]), Pt &= 15, de[st] = lt = Ae[Pt][5], be > 0)
          if (be === 16) {
            for (tt = ht; tt < st; tt++)
              de[tt] = 1;
            ht = -1;
          } else
            ht = -1;
        if (Ae[Pt][6])
          ht === -1 && (ht = st);
        else if (ht > -1) {
          for (tt = ht; tt < st; tt++)
            de[tt] = lt;
          ht = -1;
        }
        Ce[st] === "B" && (de[st] = 0), Te.hiLevel |= lt;
      }
      s && function(Ue, qe, We) {
        for (var Ke = 0; Ke < We; Ke++)
          if (Ue[Ke] === "S") {
            qe[Ke] = ce;
            for (var Ze = Ke - 1; Ze >= 0 && Ue[Ze] === "WS"; Ze--)
              qe[Ze] = ce;
          }
      }(Ce, de, ct);
    }, Ve = function(ae, de, Te, be, tt) {
      if (!(tt.hiLevel < ae)) {
        if (ae === 1 && ce === 1 && !r)
          return de.reverse(), void (Te && Te.reverse());
        for (var st, lt, Ye, ht, ct = de.length, Pt = 0; Pt < ct; ) {
          if (be[Pt] >= ae) {
            for (Ye = Pt + 1; Ye < ct && be[Ye] >= ae; )
              Ye++;
            for (ht = Pt, lt = Ye - 1; ht < lt; ht++, lt--)
              st = de[ht], de[ht] = de[lt], de[lt] = st, Te && (st = Te[ht], Te[ht] = Te[lt], Te[lt] = st);
            Pt = Ye;
          }
          Pt++;
        }
      }
    }, Fe = function(ae, de, Te) {
      var be = ae.split(""), tt = { hiLevel: ce };
      return Te || (Te = []), ye(be, Te, tt), function(st, lt, Ye) {
        if (Ye.hiLevel !== 0 && A)
          for (var ht, ct = 0; ct < st.length; ct++)
            lt[ct] === 1 && (ht = V.indexOf(st[ct])) >= 0 && (st[ct] = V[ht + 1]);
      }(be, Te, tt), Ve(2, be, de, Te, tt), Ve(1, be, de, Te, tt), be.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(ae, de, Te) {
      if (function(tt, st) {
        if (st)
          for (var lt = 0; lt < tt.length; lt++)
            st[lt] = lt;
        l === void 0 && (l = Se(tt)), y === void 0 && (y = Se(tt));
      }(ae, de), c || !m || y)
        if (c && m && l ^ y)
          ce = l ? 1 : 0, ae = Le(ae, de, Te);
        else if (!c && m && y)
          ce = l ? 1 : 0, ae = Fe(ae, de, Te), ae = Le(ae, de);
        else if (!c || l || m || y) {
          if (c && !m && l ^ y)
            ae = Le(ae, de), l ? (ce = 0, ae = Fe(ae, de, Te)) : (ce = 1, ae = Fe(ae, de, Te), ae = Le(ae, de));
          else if (c && l && !m && y)
            ce = 1, ae = Fe(ae, de, Te), ae = Le(ae, de);
          else if (!c && !m && l ^ y) {
            var be = A;
            l ? (ce = 1, ae = Fe(ae, de, Te), ce = 0, A = !1, ae = Fe(ae, de, Te), A = be) : (ce = 0, ae = Fe(ae, de, Te), ae = Le(ae, de), ce = 1, A = !1, ae = Fe(ae, de, Te), A = be, ae = Le(ae, de));
          }
        } else
          ce = 0, ae = Fe(ae, de, Te);
      else
        ce = l ? 1 : 0, ae = Fe(ae, de, Te);
      return ae;
    }, this.__bidiEngine__.setOptions = function(ae) {
      ae && (c = ae.isInputVisual, m = ae.isOutputVisual, l = ae.isInputRtl, y = ae.isOutputRtl, A = ae.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(i), this.__bidiEngine__;
  };
  var e = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], t = new n.__bidiEngine__({ isInputVisual: !0 });
  n.API.events.push(["postProcessText", function(i) {
    var r = i.text, s = (i.x, i.y, i.options || {}), c = (i.mutex, s.lang, []);
    if (s.isInputVisual = typeof s.isInputVisual != "boolean" || s.isInputVisual, t.setOptions(s), Object.prototype.toString.call(r) === "[object Array]") {
      var l = 0;
      for (c = [], l = 0; l < r.length; l += 1)
        Object.prototype.toString.call(r[l]) === "[object Array]" ? c.push([t.doBidiReorder(r[l][0]), r[l][1], r[l][2]]) : c.push([t.doBidiReorder(r[l])]);
      i.text = c;
    } else
      i.text = t.doBidiReorder(r);
    t.setOptions({ isInputVisual: !0 });
  }]);
}(Bn), Bn.API.TTFFont = function() {
  function n(e) {
    var t;
    if (this.rawData = e, t = this.contents = new Yu(e), this.contents.pos = 4, t.readString(4) === "ttcf")
      throw new Error("TTCF not supported.");
    t.pos = 0, this.parse(), this.subset = new IV(this), this.registerTTF();
  }
  return n.open = function(e) {
    return new n(e);
  }, n.prototype.parse = function() {
    return this.directory = new pV(this.contents), this.head = new mV(this), this.name = new xV(this), this.cmap = new ST(this), this.toUnicode = {}, this.hhea = new _V(this), this.maxp = new wV(this), this.hmtx = new AV(this), this.post = new vV(this), this.os2 = new yV(this), this.loca = new CV(this), this.glyf = new EV(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, n.prototype.registerTTF = function() {
    var e, t, i, r, s;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = (function() {
      var c, l, m, y;
      for (y = [], c = 0, l = (m = this.bbox).length; c < l; c++)
        e = m[c], y.push(Math.round(e * this.scaleFactor));
      return y;
    }).call(this), this.stemV = 0, this.post.exists ? (i = 255 & (r = this.post.italic_angle), 32768 & (t = r >> 16) && (t = -(1 + (65535 ^ t))), this.italicAngle = +(t + "." + i)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = (s = this.familyClass) === 1 || s === 2 || s === 3 || s === 4 || s === 5 || s === 7, this.isScript = this.familyClass === 10, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), this.italicAngle !== 0 && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode)
      throw new Error("No unicode cmap for font");
  }, n.prototype.characterToGlyph = function(e) {
    var t;
    return ((t = this.cmap.unicode) != null ? t.codeMap[e] : void 0) || 0;
  }, n.prototype.widthOfGlyph = function(e) {
    var t;
    return t = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(e).advance * t;
  }, n.prototype.widthOfString = function(e, t, i) {
    var r, s, c, l;
    for (c = 0, s = 0, l = (e = "" + e).length; 0 <= l ? s < l : s > l; s = 0 <= l ? ++s : --s)
      r = e.charCodeAt(s), c += this.widthOfGlyph(this.characterToGlyph(r)) + i * (1e3 / t) || 0;
    return c * (t / 1e3);
  }, n.prototype.lineHeight = function(e, t) {
    var i;
    return t == null && (t = !1), i = t ? this.lineGap : 0, (this.ascender + i - this.decender) / 1e3 * e;
  }, n;
}();
var Bl, Yu = function() {
  function n(e) {
    this.data = e ?? [], this.pos = 0, this.length = this.data.length;
  }
  return n.prototype.readByte = function() {
    return this.data[this.pos++];
  }, n.prototype.writeByte = function(e) {
    return this.data[this.pos++] = e;
  }, n.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, n.prototype.writeUInt32 = function(e) {
    return this.writeByte(e >>> 24 & 255), this.writeByte(e >> 16 & 255), this.writeByte(e >> 8 & 255), this.writeByte(255 & e);
  }, n.prototype.readInt32 = function() {
    var e;
    return (e = this.readUInt32()) >= 2147483648 ? e - 4294967296 : e;
  }, n.prototype.writeInt32 = function(e) {
    return e < 0 && (e += 4294967296), this.writeUInt32(e);
  }, n.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, n.prototype.writeUInt16 = function(e) {
    return this.writeByte(e >> 8 & 255), this.writeByte(255 & e);
  }, n.prototype.readInt16 = function() {
    var e;
    return (e = this.readUInt16()) >= 32768 ? e - 65536 : e;
  }, n.prototype.writeInt16 = function(e) {
    return e < 0 && (e += 65536), this.writeUInt16(e);
  }, n.prototype.readString = function(e) {
    var t, i;
    for (i = [], t = 0; 0 <= e ? t < e : t > e; t = 0 <= e ? ++t : --t)
      i[t] = String.fromCharCode(this.readByte());
    return i.join("");
  }, n.prototype.writeString = function(e) {
    var t, i, r;
    for (r = [], t = 0, i = e.length; 0 <= i ? t < i : t > i; t = 0 <= i ? ++t : --t)
      r.push(this.writeByte(e.charCodeAt(t)));
    return r;
  }, n.prototype.readShort = function() {
    return this.readInt16();
  }, n.prototype.writeShort = function(e) {
    return this.writeInt16(e);
  }, n.prototype.readLongLong = function() {
    var e, t, i, r, s, c, l, m;
    return e = this.readByte(), t = this.readByte(), i = this.readByte(), r = this.readByte(), s = this.readByte(), c = this.readByte(), l = this.readByte(), m = this.readByte(), 128 & e ? -1 * (72057594037927940 * (255 ^ e) + 281474976710656 * (255 ^ t) + 1099511627776 * (255 ^ i) + 4294967296 * (255 ^ r) + 16777216 * (255 ^ s) + 65536 * (255 ^ c) + 256 * (255 ^ l) + (255 ^ m) + 1) : 72057594037927940 * e + 281474976710656 * t + 1099511627776 * i + 4294967296 * r + 16777216 * s + 65536 * c + 256 * l + m;
  }, n.prototype.writeLongLong = function(e) {
    var t, i;
    return t = Math.floor(e / 4294967296), i = 4294967295 & e, this.writeByte(t >> 24 & 255), this.writeByte(t >> 16 & 255), this.writeByte(t >> 8 & 255), this.writeByte(255 & t), this.writeByte(i >> 24 & 255), this.writeByte(i >> 16 & 255), this.writeByte(i >> 8 & 255), this.writeByte(255 & i);
  }, n.prototype.readInt = function() {
    return this.readInt32();
  }, n.prototype.writeInt = function(e) {
    return this.writeInt32(e);
  }, n.prototype.read = function(e) {
    var t, i;
    for (t = [], i = 0; 0 <= e ? i < e : i > e; i = 0 <= e ? ++i : --i)
      t.push(this.readByte());
    return t;
  }, n.prototype.write = function(e) {
    var t, i, r, s;
    for (s = [], i = 0, r = e.length; i < r; i++)
      t = e[i], s.push(this.writeByte(t));
    return s;
  }, n;
}(), pV = function() {
  var n;
  function e(t) {
    var i, r, s;
    for (this.scalarType = t.readInt(), this.tableCount = t.readShort(), this.searchRange = t.readShort(), this.entrySelector = t.readShort(), this.rangeShift = t.readShort(), this.tables = {}, r = 0, s = this.tableCount; 0 <= s ? r < s : r > s; r = 0 <= s ? ++r : --r)
      i = { tag: t.readString(4), checksum: t.readInt(), offset: t.readInt(), length: t.readInt() }, this.tables[i.tag] = i;
  }
  return e.prototype.encode = function(t) {
    var i, r, s, c, l, m, y, A, T, I, L, N, z;
    for (z in L = Object.keys(t).length, m = Math.log(2), T = 16 * Math.floor(Math.log(L) / m), c = Math.floor(T / m), A = 16 * L - T, (r = new Yu()).writeInt(this.scalarType), r.writeShort(L), r.writeShort(T), r.writeShort(c), r.writeShort(A), s = 16 * L, y = r.pos + s, l = null, N = [], t)
      for (I = t[z], r.writeString(z), r.writeInt(n(I)), r.writeInt(y), r.writeInt(I.length), N = N.concat(I), z === "head" && (l = y), y += I.length; y % 4; )
        N.push(0), y++;
    return r.write(N), i = 2981146554 - n(r.data), r.pos = l + 8, r.writeUInt32(i), r.data;
  }, n = function(t) {
    var i, r, s, c;
    for (t = TT.call(t); t.length % 4; )
      t.push(0);
    for (s = new Yu(t), r = 0, i = 0, c = t.length; i < c; i = i += 4)
      r += s.readUInt32();
    return 4294967295 & r;
  }, e;
}(), gV = {}.hasOwnProperty, _c = function(n, e) {
  for (var t in e)
    gV.call(e, t) && (n[t] = e[t]);
  function i() {
    this.constructor = n;
  }
  return i.prototype = e.prototype, n.prototype = new i(), n.__super__ = e.prototype, n;
};
Bl = function() {
  function n(e) {
    var t;
    this.file = e, t = this.file.directory.tables[this.tag], this.exists = !!t, t && (this.offset = t.offset, this.length = t.length, this.parse(this.file.contents));
  }
  return n.prototype.parse = function() {
  }, n.prototype.encode = function() {
  }, n.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, n;
}();
var mV = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return _c(e, Bl), e.prototype.tag = "head", e.prototype.parse = function(t) {
    return t.pos = this.offset, this.version = t.readInt(), this.revision = t.readInt(), this.checkSumAdjustment = t.readInt(), this.magicNumber = t.readInt(), this.flags = t.readShort(), this.unitsPerEm = t.readShort(), this.created = t.readLongLong(), this.modified = t.readLongLong(), this.xMin = t.readShort(), this.yMin = t.readShort(), this.xMax = t.readShort(), this.yMax = t.readShort(), this.macStyle = t.readShort(), this.lowestRecPPEM = t.readShort(), this.fontDirectionHint = t.readShort(), this.indexToLocFormat = t.readShort(), this.glyphDataFormat = t.readShort();
  }, e.prototype.encode = function(t) {
    var i;
    return (i = new Yu()).writeInt(this.version), i.writeInt(this.revision), i.writeInt(this.checkSumAdjustment), i.writeInt(this.magicNumber), i.writeShort(this.flags), i.writeShort(this.unitsPerEm), i.writeLongLong(this.created), i.writeLongLong(this.modified), i.writeShort(this.xMin), i.writeShort(this.yMin), i.writeShort(this.xMax), i.writeShort(this.yMax), i.writeShort(this.macStyle), i.writeShort(this.lowestRecPPEM), i.writeShort(this.fontDirectionHint), i.writeShort(t), i.writeShort(this.glyphDataFormat), i.data;
  }, e;
}(), XA = function() {
  function n(e, t) {
    var i, r, s, c, l, m, y, A, T, I, L, N, z, V, H, J, ce;
    switch (this.platformID = e.readUInt16(), this.encodingID = e.readShort(), this.offset = t + e.readInt(), T = e.pos, e.pos = this.offset, this.format = e.readUInt16(), this.length = e.readUInt16(), this.language = e.readUInt16(), this.isUnicode = this.platformID === 3 && this.encodingID === 1 && this.format === 4 || this.platformID === 0 && this.format === 4, this.codeMap = {}, this.format) {
      case 0:
        for (m = 0; m < 256; ++m)
          this.codeMap[m] = e.readByte();
        break;
      case 4:
        for (L = e.readUInt16(), I = L / 2, e.pos += 6, s = function() {
          var me, Se;
          for (Se = [], m = me = 0; 0 <= I ? me < I : me > I; m = 0 <= I ? ++me : --me)
            Se.push(e.readUInt16());
          return Se;
        }(), e.pos += 2, z = function() {
          var me, Se;
          for (Se = [], m = me = 0; 0 <= I ? me < I : me > I; m = 0 <= I ? ++me : --me)
            Se.push(e.readUInt16());
          return Se;
        }(), y = function() {
          var me, Se;
          for (Se = [], m = me = 0; 0 <= I ? me < I : me > I; m = 0 <= I ? ++me : --me)
            Se.push(e.readUInt16());
          return Se;
        }(), A = function() {
          var me, Se;
          for (Se = [], m = me = 0; 0 <= I ? me < I : me > I; m = 0 <= I ? ++me : --me)
            Se.push(e.readUInt16());
          return Se;
        }(), r = (this.length - e.pos + this.offset) / 2, l = function() {
          var me, Se;
          for (Se = [], m = me = 0; 0 <= r ? me < r : me > r; m = 0 <= r ? ++me : --me)
            Se.push(e.readUInt16());
          return Se;
        }(), m = H = 0, ce = s.length; H < ce; m = ++H)
          for (V = s[m], i = J = N = z[m]; N <= V ? J <= V : J >= V; i = N <= V ? ++J : --J)
            A[m] === 0 ? c = i + y[m] : (c = l[A[m] / 2 + (i - N) - (I - m)] || 0) !== 0 && (c += y[m]), this.codeMap[i] = 65535 & c;
    }
    e.pos = T;
  }
  return n.encode = function(e, t) {
    var i, r, s, c, l, m, y, A, T, I, L, N, z, V, H, J, ce, me, Se, De, Le, ye, Ve, Fe, ae, de, Te, be, tt, st, lt, Ye, ht, ct, Pt, se, Ae, Ce, Ue, qe, We, Ke, Ze, At, It, Rt;
    switch (be = new Yu(), c = Object.keys(e).sort(function(kt, on) {
      return kt - on;
    }), t) {
      case "macroman":
        for (z = 0, V = function() {
          var kt = [];
          for (N = 0; N < 256; ++N)
            kt.push(0);
          return kt;
        }(), J = { 0: 0 }, s = {}, tt = 0, ht = c.length; tt < ht; tt++)
          J[Ze = e[r = c[tt]]] == null && (J[Ze] = ++z), s[r] = { old: e[r], new: J[e[r]] }, V[r] = J[e[r]];
        return be.writeUInt16(1), be.writeUInt16(0), be.writeUInt32(12), be.writeUInt16(0), be.writeUInt16(262), be.writeUInt16(0), be.write(V), { charMap: s, subtable: be.data, maxGlyphID: z + 1 };
      case "unicode":
        for (de = [], T = [], ce = 0, J = {}, i = {}, H = y = null, st = 0, ct = c.length; st < ct; st++)
          J[Se = e[r = c[st]]] == null && (J[Se] = ++ce), i[r] = { old: Se, new: J[Se] }, l = J[Se] - r, H != null && l === y || (H && T.push(H), de.push(r), y = l), H = r;
        for (H && T.push(H), T.push(65535), de.push(65535), Fe = 2 * (Ve = de.length), ye = 2 * Math.pow(Math.log(Ve) / Math.LN2, 2), I = Math.log(ye / 2) / Math.LN2, Le = 2 * Ve - ye, m = [], De = [], L = [], N = lt = 0, Pt = de.length; lt < Pt; N = ++lt) {
          if (ae = de[N], A = T[N], ae === 65535) {
            m.push(0), De.push(0);
            break;
          }
          if (ae - (Te = i[ae].new) >= 32768)
            for (m.push(0), De.push(2 * (L.length + Ve - N)), r = Ye = ae; ae <= A ? Ye <= A : Ye >= A; r = ae <= A ? ++Ye : --Ye)
              L.push(i[r].new);
          else
            m.push(Te - ae), De.push(0);
        }
        for (be.writeUInt16(3), be.writeUInt16(1), be.writeUInt32(12), be.writeUInt16(4), be.writeUInt16(16 + 8 * Ve + 2 * L.length), be.writeUInt16(0), be.writeUInt16(Fe), be.writeUInt16(ye), be.writeUInt16(I), be.writeUInt16(Le), We = 0, se = T.length; We < se; We++)
          r = T[We], be.writeUInt16(r);
        for (be.writeUInt16(0), Ke = 0, Ae = de.length; Ke < Ae; Ke++)
          r = de[Ke], be.writeUInt16(r);
        for (At = 0, Ce = m.length; At < Ce; At++)
          l = m[At], be.writeUInt16(l);
        for (It = 0, Ue = De.length; It < Ue; It++)
          me = De[It], be.writeUInt16(me);
        for (Rt = 0, qe = L.length; Rt < qe; Rt++)
          z = L[Rt], be.writeUInt16(z);
        return { charMap: i, subtable: be.data, maxGlyphID: ce + 1 };
    }
  }, n;
}(), ST = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return _c(e, Bl), e.prototype.tag = "cmap", e.prototype.parse = function(t) {
    var i, r, s;
    for (t.pos = this.offset, this.version = t.readUInt16(), s = t.readUInt16(), this.tables = [], this.unicode = null, r = 0; 0 <= s ? r < s : r > s; r = 0 <= s ? ++r : --r)
      i = new XA(t, this.offset), this.tables.push(i), i.isUnicode && this.unicode == null && (this.unicode = i);
    return !0;
  }, e.encode = function(t, i) {
    var r, s;
    return i == null && (i = "macroman"), r = XA.encode(t, i), (s = new Yu()).writeUInt16(0), s.writeUInt16(1), r.table = s.data.concat(r.subtable), r;
  }, e;
}(), _V = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return _c(e, Bl), e.prototype.tag = "hhea", e.prototype.parse = function(t) {
    return t.pos = this.offset, this.version = t.readInt(), this.ascender = t.readShort(), this.decender = t.readShort(), this.lineGap = t.readShort(), this.advanceWidthMax = t.readShort(), this.minLeftSideBearing = t.readShort(), this.minRightSideBearing = t.readShort(), this.xMaxExtent = t.readShort(), this.caretSlopeRise = t.readShort(), this.caretSlopeRun = t.readShort(), this.caretOffset = t.readShort(), t.pos += 8, this.metricDataFormat = t.readShort(), this.numberOfMetrics = t.readUInt16();
  }, e;
}(), yV = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return _c(e, Bl), e.prototype.tag = "OS/2", e.prototype.parse = function(t) {
    if (t.pos = this.offset, this.version = t.readUInt16(), this.averageCharWidth = t.readShort(), this.weightClass = t.readUInt16(), this.widthClass = t.readUInt16(), this.type = t.readShort(), this.ySubscriptXSize = t.readShort(), this.ySubscriptYSize = t.readShort(), this.ySubscriptXOffset = t.readShort(), this.ySubscriptYOffset = t.readShort(), this.ySuperscriptXSize = t.readShort(), this.ySuperscriptYSize = t.readShort(), this.ySuperscriptXOffset = t.readShort(), this.ySuperscriptYOffset = t.readShort(), this.yStrikeoutSize = t.readShort(), this.yStrikeoutPosition = t.readShort(), this.familyClass = t.readShort(), this.panose = function() {
      var i, r;
      for (r = [], i = 0; i < 10; ++i)
        r.push(t.readByte());
      return r;
    }(), this.charRange = function() {
      var i, r;
      for (r = [], i = 0; i < 4; ++i)
        r.push(t.readInt());
      return r;
    }(), this.vendorID = t.readString(4), this.selection = t.readShort(), this.firstCharIndex = t.readShort(), this.lastCharIndex = t.readShort(), this.version > 0 && (this.ascent = t.readShort(), this.descent = t.readShort(), this.lineGap = t.readShort(), this.winAscent = t.readShort(), this.winDescent = t.readShort(), this.codePageRange = function() {
      var i, r;
      for (r = [], i = 0; i < 2; i = ++i)
        r.push(t.readInt());
      return r;
    }(), this.version > 1))
      return this.xHeight = t.readShort(), this.capHeight = t.readShort(), this.defaultChar = t.readShort(), this.breakChar = t.readShort(), this.maxContext = t.readShort();
  }, e;
}(), vV = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return _c(e, Bl), e.prototype.tag = "post", e.prototype.parse = function(t) {
    var i, r, s;
    switch (t.pos = this.offset, this.format = t.readInt(), this.italicAngle = t.readInt(), this.underlinePosition = t.readShort(), this.underlineThickness = t.readShort(), this.isFixedPitch = t.readInt(), this.minMemType42 = t.readInt(), this.maxMemType42 = t.readInt(), this.minMemType1 = t.readInt(), this.maxMemType1 = t.readInt(), this.format) {
      case 65536:
        break;
      case 131072:
        var c;
        for (r = t.readUInt16(), this.glyphNameIndex = [], c = 0; 0 <= r ? c < r : c > r; c = 0 <= r ? ++c : --c)
          this.glyphNameIndex.push(t.readUInt16());
        for (this.names = [], s = []; t.pos < this.offset + this.length; )
          i = t.readByte(), s.push(this.names.push(t.readString(i)));
        return s;
      case 151552:
        return r = t.readUInt16(), this.offsets = t.read(r);
      case 196608:
        break;
      case 262144:
        return this.map = (function() {
          var l, m, y;
          for (y = [], c = l = 0, m = this.file.maxp.numGlyphs; 0 <= m ? l < m : l > m; c = 0 <= m ? ++l : --l)
            y.push(t.readUInt32());
          return y;
        }).call(this);
    }
  }, e;
}(), bV = function(n, e) {
  this.raw = n, this.length = n.length, this.platformID = e.platformID, this.encodingID = e.encodingID, this.languageID = e.languageID;
}, xV = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return _c(e, Bl), e.prototype.tag = "name", e.prototype.parse = function(t) {
    var i, r, s, c, l, m, y, A, T, I, L;
    for (t.pos = this.offset, t.readShort(), i = t.readShort(), m = t.readShort(), r = [], c = 0; 0 <= i ? c < i : c > i; c = 0 <= i ? ++c : --c)
      r.push({ platformID: t.readShort(), encodingID: t.readShort(), languageID: t.readShort(), nameID: t.readShort(), length: t.readShort(), offset: this.offset + m + t.readShort() });
    for (y = {}, c = T = 0, I = r.length; T < I; c = ++T)
      s = r[c], t.pos = s.offset, A = t.readString(s.length), l = new bV(A, s), y[L = s.nameID] == null && (y[L] = []), y[s.nameID].push(l);
    this.strings = y, this.copyright = y[0], this.fontFamily = y[1], this.fontSubfamily = y[2], this.uniqueSubfamily = y[3], this.fontName = y[4], this.version = y[5];
    try {
      this.postscriptName = y[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch {
      this.postscriptName = y[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = y[7], this.manufacturer = y[8], this.designer = y[9], this.description = y[10], this.vendorUrl = y[11], this.designerUrl = y[12], this.license = y[13], this.licenseUrl = y[14], this.preferredFamily = y[15], this.preferredSubfamily = y[17], this.compatibleFull = y[18], this.sampleText = y[19];
  }, e;
}(), wV = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return _c(e, Bl), e.prototype.tag = "maxp", e.prototype.parse = function(t) {
    return t.pos = this.offset, this.version = t.readInt(), this.numGlyphs = t.readUInt16(), this.maxPoints = t.readUInt16(), this.maxContours = t.readUInt16(), this.maxCompositePoints = t.readUInt16(), this.maxComponentContours = t.readUInt16(), this.maxZones = t.readUInt16(), this.maxTwilightPoints = t.readUInt16(), this.maxStorage = t.readUInt16(), this.maxFunctionDefs = t.readUInt16(), this.maxInstructionDefs = t.readUInt16(), this.maxStackElements = t.readUInt16(), this.maxSizeOfInstructions = t.readUInt16(), this.maxComponentElements = t.readUInt16(), this.maxComponentDepth = t.readUInt16();
  }, e;
}(), AV = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return _c(e, Bl), e.prototype.tag = "hmtx", e.prototype.parse = function(t) {
    var i, r, s, c, l, m, y;
    for (t.pos = this.offset, this.metrics = [], i = 0, m = this.file.hhea.numberOfMetrics; 0 <= m ? i < m : i > m; i = 0 <= m ? ++i : --i)
      this.metrics.push({ advance: t.readUInt16(), lsb: t.readInt16() });
    for (s = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
      var A, T;
      for (T = [], i = A = 0; 0 <= s ? A < s : A > s; i = 0 <= s ? ++A : --A)
        T.push(t.readInt16());
      return T;
    }(), this.widths = (function() {
      var A, T, I, L;
      for (L = [], A = 0, T = (I = this.metrics).length; A < T; A++)
        c = I[A], L.push(c.advance);
      return L;
    }).call(this), r = this.widths[this.widths.length - 1], y = [], i = l = 0; 0 <= s ? l < s : l > s; i = 0 <= s ? ++l : --l)
      y.push(this.widths.push(r));
    return y;
  }, e.prototype.forGlyph = function(t) {
    return t in this.metrics ? this.metrics[t] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[t - this.metrics.length] };
  }, e;
}(), TT = [].slice, EV = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return _c(e, Bl), e.prototype.tag = "glyf", e.prototype.parse = function() {
    return this.cache = {};
  }, e.prototype.glyphFor = function(t) {
    var i, r, s, c, l, m, y, A, T, I;
    return t in this.cache ? this.cache[t] : (c = this.file.loca, i = this.file.contents, r = c.indexOf(t), (s = c.lengthOf(t)) === 0 ? this.cache[t] = null : (i.pos = this.offset + r, l = (m = new Yu(i.read(s))).readShort(), A = m.readShort(), I = m.readShort(), y = m.readShort(), T = m.readShort(), this.cache[t] = l === -1 ? new TV(m, A, I, y, T) : new SV(m, l, A, I, y, T), this.cache[t]));
  }, e.prototype.encode = function(t, i, r) {
    var s, c, l, m, y;
    for (l = [], c = [], m = 0, y = i.length; m < y; m++)
      s = t[i[m]], c.push(l.length), s && (l = l.concat(s.encode(r)));
    return c.push(l.length), { table: l, offsets: c };
  }, e;
}(), SV = function() {
  function n(e, t, i, r, s, c) {
    this.raw = e, this.numberOfContours = t, this.xMin = i, this.yMin = r, this.xMax = s, this.yMax = c, this.compound = !1;
  }
  return n.prototype.encode = function() {
    return this.raw.data;
  }, n;
}(), TV = function() {
  function n(e, t, i, r, s) {
    var c, l;
    for (this.raw = e, this.xMin = t, this.yMin = i, this.xMax = r, this.yMax = s, this.compound = !0, this.glyphIDs = [], this.glyphOffsets = [], c = this.raw; l = c.readShort(), this.glyphOffsets.push(c.pos), this.glyphIDs.push(c.readUInt16()), 32 & l; )
      c.pos += 1 & l ? 4 : 2, 128 & l ? c.pos += 8 : 64 & l ? c.pos += 4 : 8 & l && (c.pos += 2);
  }
  return n.prototype.encode = function() {
    var e, t, i;
    for (t = new Yu(TT.call(this.raw.data)), e = 0, i = this.glyphIDs.length; e < i; ++e)
      t.pos = this.glyphOffsets[e];
    return t.data;
  }, n;
}(), CV = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return _c(e, Bl), e.prototype.tag = "loca", e.prototype.parse = function(t) {
    var i, r;
    return t.pos = this.offset, i = this.file.head.indexToLocFormat, this.offsets = i === 0 ? (function() {
      var s, c;
      for (c = [], r = 0, s = this.length; r < s; r += 2)
        c.push(2 * t.readUInt16());
      return c;
    }).call(this) : (function() {
      var s, c;
      for (c = [], r = 0, s = this.length; r < s; r += 4)
        c.push(t.readUInt32());
      return c;
    }).call(this);
  }, e.prototype.indexOf = function(t) {
    return this.offsets[t];
  }, e.prototype.lengthOf = function(t) {
    return this.offsets[t + 1] - this.offsets[t];
  }, e.prototype.encode = function(t, i) {
    for (var r = new Uint32Array(this.offsets.length), s = 0, c = 0, l = 0; l < r.length; ++l)
      if (r[l] = s, c < i.length && i[c] == l) {
        ++c, r[l] = s;
        var m = this.offsets[l], y = this.offsets[l + 1] - m;
        y > 0 && (s += y);
      }
    for (var A = new Array(4 * r.length), T = 0; T < r.length; ++T)
      A[4 * T + 3] = 255 & r[T], A[4 * T + 2] = (65280 & r[T]) >> 8, A[4 * T + 1] = (16711680 & r[T]) >> 16, A[4 * T] = (4278190080 & r[T]) >> 24;
    return A;
  }, e;
}(), IV = function() {
  function n(e) {
    this.font = e, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return n.prototype.generateCmap = function() {
    var e, t, i, r, s;
    for (t in r = this.font.cmap.tables[0].codeMap, e = {}, s = this.subset)
      i = s[t], e[t] = r[i];
    return e;
  }, n.prototype.glyphsFor = function(e) {
    var t, i, r, s, c, l, m;
    for (r = {}, c = 0, l = e.length; c < l; c++)
      r[s = e[c]] = this.font.glyf.glyphFor(s);
    for (s in t = [], r)
      (i = r[s]) != null && i.compound && t.push.apply(t, i.glyphIDs);
    if (t.length > 0)
      for (s in m = this.glyphsFor(t))
        i = m[s], r[s] = i;
    return r;
  }, n.prototype.encode = function(e, t) {
    var i, r, s, c, l, m, y, A, T, I, L, N, z, V, H;
    for (r in i = ST.encode(this.generateCmap(), "unicode"), c = this.glyphsFor(e), L = { 0: 0 }, H = i.charMap)
      L[(m = H[r]).old] = m.new;
    for (N in I = i.maxGlyphID, c)
      N in L || (L[N] = I++);
    return A = function(J) {
      var ce, me;
      for (ce in me = {}, J)
        me[J[ce]] = ce;
      return me;
    }(L), T = Object.keys(A).sort(function(J, ce) {
      return J - ce;
    }), z = function() {
      var J, ce, me;
      for (me = [], J = 0, ce = T.length; J < ce; J++)
        l = T[J], me.push(A[l]);
      return me;
    }(), s = this.font.glyf.encode(c, z, L), y = this.font.loca.encode(s.offsets, z), V = { cmap: this.font.cmap.raw(), glyf: s.table, loca: y, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(t) }, this.font.os2.exists && (V["OS/2"] = this.font.os2.raw()), this.font.directory.encode(V);
  }, n;
}();
Bn.API.PDFObject = function() {
  var n;
  function e() {
  }
  return n = function(t, i) {
    return (Array(i + 1).join("0") + t).slice(-i);
  }, e.convert = function(t) {
    var i, r, s, c;
    if (Array.isArray(t))
      return "[" + function() {
        var l, m, y;
        for (y = [], l = 0, m = t.length; l < m; l++)
          i = t[l], y.push(e.convert(i));
        return y;
      }().join(" ") + "]";
    if (typeof t == "string")
      return "/" + t;
    if (t != null && t.isString)
      return "(" + t + ")";
    if (t instanceof Date)
      return "(D:" + n(t.getUTCFullYear(), 4) + n(t.getUTCMonth(), 2) + n(t.getUTCDate(), 2) + n(t.getUTCHours(), 2) + n(t.getUTCMinutes(), 2) + n(t.getUTCSeconds(), 2) + "Z)";
    if ({}.toString.call(t) === "[object Object]") {
      for (r in s = ["<<"], t)
        c = t[r], s.push("/" + r + " " + e.convert(c));
      return s.push(">>"), s.join(`
`);
    }
    return "" + t;
  }, e;
}();
const Tv = { "circle-radius": 8, "circle-color": "red", "circle-stroke-width": 1, "circle-stroke-color": "black" }, Cv = { textSize: 16, textHaloColor: "#FFFFFF", textHaloWidth: 0.8, textColor: "#000000", fallbackTextFont: ["Open Sans Regular"] };
class PV {
  /**
  * Constructor
  * @param map MaplibreMap object
  * @param size layout size. default is A4
  * @param dpi dpi value. deafult is 300
  * @param format image format. default is PNG
  * @param unit length unit. default is mm
  * @param fileName file name. default is 'map'
  */
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Mh.A4, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 300, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Wc.PNG, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : Zd.mm, c = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "map", l = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : "maplibregl-marker", m = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : Tv, y = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : "maplibregl-ctrl-attrib-inner", A = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : Cv;
    yi(this, "map"), yi(this, "width"), yi(this, "height"), yi(this, "dpi"), yi(this, "format"), yi(this, "unit"), yi(this, "fileName"), yi(this, "markerClassName"), yi(this, "markerCirclePaint"), yi(this, "attributionClassName"), yi(this, "attributionStyle"), this.map = e, this.width = t[0], this.height = t[1], this.dpi = i, this.format = r, this.unit = s, this.fileName = c, this.markerClassName = l, this.markerCirclePaint = m, this.attributionClassName = y, this.attributionStyle = A;
  }
  renderMapPost(e) {
    return e;
  }
  getMarkers() {
    return this.map.getCanvasContainer().getElementsByClassName(this.markerClassName);
  }
  renderMarkers(e) {
    const t = this.getMarkers();
    for (let i = 0; i < t.length; i++) {
      const r = t.item(i);
      if (!r)
        continue;
      const s = r.getAttribute("style");
      if (!s)
        continue;
      const c = /translate\(([^,]+)px,\s*([^,]+)px\)/, l = s.match(c);
      if (!l)
        continue;
      const m = parseInt(l[1]), y = parseInt(l[2]), A = this.map.unproject([m, y]), T = `point${i}`;
      e.addSource(T, { type: "geojson", data: { type: "Point", coordinates: [A.lng, A.lat] } }), e.addLayer({ id: T, source: T, type: "circle", paint: this.markerCirclePaint });
    }
    return e;
  }
  /**
  * Generate and download Map image
  */
  generate() {
    const e = this;
    JsLoadingOverlay.show({ overlayBackgroundColor: "#5D5959", overlayOpacity: "0.6", spinnerIcon: "ball-spin", spinnerColor: "#2400FD", spinnerSize: "2x", overlayIDName: "overlay", spinnerIDName: "spinner", offsetX: 0, offsetY: 0, containerID: null, lockScroll: !1, overlayZIndex: 9998, spinnerZIndex: 9999 });
    const t = window.devicePixelRatio;
    Object.defineProperty(window, "devicePixelRatio", { get() {
      return e.dpi / 96;
    } });
    const i = document.createElement("div");
    i.className = "hidden-map", document.body.appendChild(i);
    const r = document.createElement("div");
    r.style.width = this.toPixels(this.width), r.style.height = this.toPixels(this.height), i.appendChild(r);
    const s = this.map.getStyle();
    if (s && s.sources) {
      const l = s.sources;
      Object.keys(l).forEach((m) => {
        const y = l[m];
        Object.keys(y).forEach((A) => {
          y[A] || delete y[A];
        });
      });
    }
    let c = this.getRenderedMap(r, s);
    c.once("idle", () => {
      this.addAttributions(c) ? c.once("idle", () => {
        c = this.renderMapPost(c), this.getMarkers().length === 0 ? this.exportImage(c, i, t) : (c = this.renderMarkers(c), c.once("idle", () => {
          this.exportImage(c, i, t);
        }));
      }) : (c = this.renderMapPost(c), this.getMarkers().length === 0 ? this.exportImage(c, i, t) : (c = this.renderMarkers(c), c.once("idle", () => {
        this.exportImage(c, i, t);
      })));
    });
  }
  stripHtml(e) {
    const t = document.createElement("div");
    return t.innerHTML = e, t.textContent || t.innerText || "";
  }
  addAttributions(e) {
    if (!this.map.getStyle().glyphs)
      return !1;
    const t = e.getContainer(), i = parseInt(t.style.width.replace("px", "")) - 5, r = parseInt(t.style.height.replace("px", "")) - 5, s = [i, r], c = e.unproject(s), l = t.getElementsByClassName(this.attributionClassName), m = [];
    if ((l == null ? void 0 : l.length) > 0) {
      const L = l.item(0);
      if (L)
        for (let N = 0; N < L.children.length; N++) {
          const z = L.children.item(N);
          z && m.push(this.stripHtml(z.outerHTML));
        }
    } else {
      const L = this.map.getStyle().sources;
      Object.keys(L).forEach((N) => {
        const z = L[N];
        if ("attribution" in z) {
          const V = z.attribution;
          m.push(this.stripHtml(V));
        }
      });
    }
    if (m.length === 0)
      return !1;
    const y = m.join(" | "), A = "attribution";
    e.addSource(A, { type: "geojson", data: { type: "Feature", geometry: { type: "Point", coordinates: [c.lng, c.lat] }, properties: { attribution: y } } });
    const T = this.map.getStyle().layers.filter((L) => L.type === "symbol" && L.layout && "text-font" in L.layout), I = T.length > 0 && T[0].layout ? T[0].layout["text-font"] : this.attributionStyle.fallbackTextFont;
    return e.addLayer({ id: A, source: A, type: "symbol", layout: { "text-field": ["get", "attribution"], "text-font": I, "text-max-width": parseInt(`${i / this.attributionStyle.textSize}`), "text-anchor": "bottom-right", "text-justify": "right", "text-size": this.attributionStyle.textSize }, paint: { "text-halo-color": this.attributionStyle.textHaloColor, "text-halo-width": this.attributionStyle.textHaloWidth, "text-color": this.attributionStyle.textColor } }), !0;
  }
  exportImage(e, t, i) {
    var r;
    const s = e.getCanvas(), c = `${this.fileName}.${this.format}`;
    switch (this.format) {
      case Wc.PNG:
        this.toPNG(s, c);
        break;
      case Wc.JPEG:
        this.toJPEG(s, c);
        break;
      case Wc.PDF:
        this.toPDF(e, c);
        break;
      case Wc.SVG:
        this.toSVG(s, c);
        break;
      default:
        console.error(`Invalid file format: ${this.format}`);
        break;
    }
    e.remove(), (r = t.parentNode) == null || r.removeChild(t), Object.defineProperty(window, "devicePixelRatio", { get() {
      return i;
    } }), t.remove(), JsLoadingOverlay.hide();
  }
  /**
  * Convert canvas to PNG
  * @param canvas Canvas element
  * @param fileName file name
  */
  toPNG(e, t) {
    const i = document.createElement("a");
    i.href = e.toDataURL(), i.download = t, i.click(), i.remove();
  }
  /**
  * Convert canvas to JPEG
  * @param canvas Canvas element
  * @param fileName file name
  */
  toJPEG(e, t) {
    const i = e.toDataURL("image/jpeg", 0.85), r = document.createElement("a");
    r.href = i, r.download = t, r.click(), r.remove();
  }
  /**
  * Convert Map object to PDF
  * @param map Map object
  * @param fileName file name
  */
  toPDF(e, t) {
    const i = e.getCanvas(), r = new Bn({ orientation: this.width > this.height ? "l" : "p", unit: this.unit, compress: !0, format: [this.width, this.height] });
    r.addImage(i.toDataURL("image/png"), "png", 0, 0, this.width, this.height, void 0, "FAST");
    const { lng: s, lat: c } = e.getCenter();
    r.setProperties({ title: e.getStyle().name, subject: `center: [${s}, ${c}], zoom: ${e.getZoom()}`, creator: "Mapbox GL Export Plugin", author: "(c)Mapbox, (c)OpenStreetMap" }), r.save(t);
  }
  /**
  * Convert canvas to SVG
  * @param canvas Canvas element
  * @param fileName file name
  */
  toSVG(e, t) {
    const i = e.toDataURL("image/png"), r = Number(this.toPixels(this.width, this.dpi).replace("px", "")), s = Number(this.toPixels(this.height, this.dpi).replace("px", "")), c = `
    <svg xmlns="http://www.w3.org/2000/svg" 
      xmlns:xlink="http://www.w3.org/1999/xlink" 
      version="1.1" 
      width="${r}" 
      height="${s}" 
      viewBox="0 0 ${r} ${s}" 
      xml:space="preserve">
        <image style="stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: rgb(0,0,0); fill-rule: nonzero; opacity: 1;"  
      xlink:href="${i}" width="${r}" height="${s}"></image>
    </svg>`, l = document.createElement("a");
    l.href = `data:application/xml,${encodeURIComponent(c)}`, l.download = t, l.click(), l.remove();
  }
  /**
  * Convert mm/inch to pixel
  * @param length mm/inch length
  * @param conversionFactor DPI value. default is 96.
  */
  toPixels(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 96;
    return this.unit === Zd.mm && (t /= 25.4), `${t * e}px`;
  }
}
class LV extends PV {
  /**
  * Constructor
  * @param map MaplibreMap object
  * @param size layout size. default is A4
  * @param dpi dpi value. deafult is 300
  * @param format image format. default is PNG
  * @param unit length unit. default is mm
  * @param fileName file name. default is 'map'
  */
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Mh.A4, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 300, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Wc.PNG, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : Zd.mm, c = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "map", l = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : Tv, m = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : Cv;
    super(e, t, i, r, s, c, "maplibregl-marker", l, "maplibregl-ctrl-attrib-inner", m);
  }
  getRenderedMap(e, t) {
    const i = new f5.Map({
      container: e,
      style: t,
      center: this.map.getCenter(),
      zoom: this.map.getZoom(),
      bearing: this.map.getBearing(),
      pitch: this.map.getPitch(),
      interactive: !1,
      preserveDrawingBuffer: !0,
      fadeDuration: 0,
      // attributionControl: false,
      // hack to read transfrom request callback function
      // eslint-disable-next-line
      // @ts-ignore
      transformRequest: this.map._requestManager._transformRequestFn
    });
    this.map.getTerrain() && (i.setMaxPitch(85), i.setPitch(this.map.getPitch()));
    const r = (this.map.style.imageManager || {}).images || [];
    return Object.keys(r).forEach((s) => {
      i.addImage(s, r[s].data);
    }), i;
  }
  renderMapPost(e) {
    const t = this.map.getTerrain();
    return t && e.setTerrain({ source: t.source, exaggeration: t.exaggeration }), e;
  }
}
class MV {
  constructor(e) {
    yi(this, "controlContainer"), yi(this, "exportContainer"), yi(this, "crosshair"), yi(this, "printableArea"), yi(this, "map"), yi(this, "exportButton"), yi(this, "options", { PageSize: Mh.A4, PageOrientation: Qf.Landscape, Format: Wc.PDF, DPI: jy[300], Crosshair: !1, PrintableArea: !1, Local: "en", AllowedSizes: Object.keys(Mh), Filename: "map", markerCirclePaint: Tv, attributionStyle: Cv }), yi(this, "MAPLIB_CSS_PREFIX", "maplibregl"), e && (this.options = Object.assign(this.options, e)), this.onDocumentClick = this.onDocumentClick.bind(this);
  }
  getDefaultPosition() {
    return "top-right";
  }
  getTranslation() {
    const e = this.options.Local ?? "en";
    return BG(e);
  }
  onAdd(e) {
    var t;
    this.map = e, this.controlContainer = document.createElement("div"), this.controlContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl`), this.controlContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl-group`), this.exportContainer = document.createElement("div"), this.exportContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-export-list`), this.exportButton = document.createElement("button"), this.exportButton.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl-icon`), this.exportButton.classList.add(`${this.MAPLIB_CSS_PREFIX}-export-control`), this.exportButton.type = "button", this.exportButton.addEventListener("click", () => {
      this.exportButton.style.display = "none", this.exportContainer.style.display = "block", this.toggleCrosshair(!0), this.togglePrintableArea(!0);
    }), document.addEventListener("click", this.onDocumentClick), this.controlContainer.appendChild(this.exportButton), this.controlContainer.appendChild(this.exportContainer);
    const i = document.createElement("TABLE");
    i.className = "print-table";
    const r = {};
    (t = this.options.AllowedSizes) == null || t.forEach((A) => {
      Mh[A] && (r[A] = Mh[A]);
    });
    const s = this.createSelection(r, this.getTranslation().PageSize, "page-size", this.options.PageSize, (A, T) => JSON.stringify(A[T]));
    i.appendChild(s);
    const c = this.createSelection(Qf, this.getTranslation().PageOrientation, "page-orientation", this.options.PageOrientation, (A, T) => A[T]);
    i.appendChild(c);
    const l = this.createSelection(Wc, this.getTranslation().Format, "format-type", this.options.Format, (A, T) => A[T]);
    i.appendChild(l);
    const m = this.createSelection(jy, this.getTranslation().DPI, "dpi-type", this.options.DPI, (A, T) => A[T]);
    i.appendChild(m), this.exportContainer.appendChild(i);
    const y = document.createElement("button");
    return y.type = "button", y.textContent = this.getTranslation().Generate, y.classList.add("generate-button"), y.addEventListener("click", () => {
      const A = document.getElementById("mapbox-gl-export-page-size"), T = document.getElementById("mapbox-gl-export-page-orientation"), I = document.getElementById("mapbox-gl-export-format-type"), L = document.getElementById("mapbox-gl-export-dpi-type"), N = T.value;
      let z = JSON.parse(A.value);
      N === Qf.Portrait && (z = z.reverse()), this.generateMap(e, z, Number(L.value), I.value, Zd.mm, this.options.Filename);
    }), this.exportContainer.appendChild(y), this.controlContainer;
  }
  generateMap(e, t, i, r, s, c) {
    new LV(e, t, i, r, s, c, this.options.markerCirclePaint, this.options.attributionStyle).generate();
  }
  createSelection(e, t, i, r, s) {
    const c = document.createElement("label");
    c.textContent = t;
    const l = document.createElement("select");
    l.setAttribute("id", `mapbox-gl-export-${i}`), l.style.width = "100%", Object.keys(e).forEach((T) => {
      const I = document.createElement("option");
      I.setAttribute("value", s(e, T)), I.appendChild(document.createTextNode(T)), I.setAttribute("name", i), r === e[T] && (I.selected = !0), l.appendChild(I);
    }), l.addEventListener("change", () => {
      this.updatePrintableArea();
    });
    const m = document.createElement("TR"), y = document.createElement("TD"), A = document.createElement("TD");
    return y.appendChild(c), A.appendChild(l), m.appendChild(y), m.appendChild(A), m;
  }
  onRemove() {
    !this.controlContainer || !this.controlContainer.parentNode || !this.map || !this.exportButton || (this.exportButton.removeEventListener("click", this.onDocumentClick), this.controlContainer.parentNode.removeChild(this.controlContainer), document.removeEventListener("click", this.onDocumentClick), this.crosshair !== void 0 && (this.crosshair.destroy(), this.crosshair = void 0), this.printableArea !== void 0 && (this.printableArea.destroy(), this.printableArea = void 0), this.map = void 0);
  }
  onDocumentClick(e) {
    this.controlContainer && !this.controlContainer.contains(e.target) && this.exportContainer && this.exportButton && (this.exportContainer.style.display = "none", this.exportButton.style.display = "block", this.toggleCrosshair(!1), this.togglePrintableArea(!1));
  }
  toggleCrosshair(e) {
    this.options.Crosshair === !0 && (e === !1 ? this.crosshair !== void 0 && (this.crosshair.destroy(), this.crosshair = void 0) : (this.crosshair = new _G(this.map), this.crosshair.create()));
  }
  togglePrintableArea(e) {
    this.options.PrintableArea === !0 && (e === !1 ? this.printableArea !== void 0 && (this.printableArea.destroy(), this.printableArea = void 0) : (this.printableArea = new yG(this.map), this.updatePrintableArea()));
  }
  updatePrintableArea() {
    if (this.printableArea === void 0)
      return;
    const e = document.getElementById("mapbox-gl-export-page-size"), t = document.getElementById("mapbox-gl-export-page-orientation").value;
    let i = JSON.parse(e.value);
    t === Qf.Portrait && (i = i.reverse()), this.printableArea.updateArea(i[0], i[1]);
  }
}
var CT = RV, BV = Object.prototype.hasOwnProperty;
function RV() {
  for (var n = {}, e = 0; e < arguments.length; e++) {
    var t = arguments[e];
    for (var i in t)
      BV.call(t, i) && (n[i] = t[i]);
  }
  return n;
}
var IT = { exports: {} };
(function(n, e) {
  (function() {
    var t = {};
    n.exports = t, t.simpleFilter = function(i, r) {
      return r.filter(function(s) {
        return t.test(i, s);
      });
    }, t.test = function(i, r) {
      return t.match(i, r) !== null;
    }, t.match = function(i, r, s) {
      s = s || {};
      var c = 0, l = [], m = r.length, y = 0, A = 0, T = s.pre || "", I = s.post || "", L = s.caseSensitive && r || r.toLowerCase(), N;
      i = s.caseSensitive && i || i.toLowerCase();
      for (var z = 0; z < m; z++)
        N = r[z], L[z] === i[c] ? (N = T + N + I, c += 1, A += 1 + A) : A = 0, y += A, l[l.length] = N;
      return c === i.length ? (y = L === i ? 1 / 0 : y, {
        rendered: l.join(""),
        score: y
      }) : null;
    }, t.filter = function(i, r, s) {
      return !r || r.length === 0 ? [] : typeof i != "string" ? r : (s = s || {}, r.reduce(function(c, l, m, y) {
        var A = l;
        s.extract && (A = s.extract(l));
        var T = t.match(i, A, s);
        return T != null && (c[c.length] = {
          string: T.rendered,
          score: T.score,
          index: m,
          original: l
        }), c;
      }, []).sort(function(c, l) {
        var m = l.score - c.score;
        return m || c.index - l.index;
      }));
    };
  })();
})(IT);
var OV = IT.exports, No = function(n) {
  return this.component = n, this.items = [], this.active = n.options.noInitialSelection ? -1 : 0, this.wrapper = document.createElement("div"), this.wrapper.className = "suggestions-wrapper", this.element = document.createElement("ul"), this.element.className = "suggestions", this.wrapper.appendChild(this.element), this.selectingListItem = !1, n.el.parentNode.insertBefore(this.wrapper, n.el.nextSibling), this;
};
No.prototype.show = function() {
  this.element.style.display = "block";
};
No.prototype.hide = function() {
  this.element.style.display = "none";
};
No.prototype.add = function(n) {
  this.items.push(n);
};
No.prototype.clear = function() {
  this.items = [], this.active = this.component.options.noInitialSelection ? -1 : 0;
};
No.prototype.isEmpty = function() {
  return !this.items.length;
};
No.prototype.isVisible = function() {
  return this.element.style.display === "block";
};
No.prototype.draw = function() {
  if (this.element.innerHTML = "", this.items.length === 0) {
    this.hide();
    return;
  }
  for (var n = 0; n < this.items.length; n++)
    this.drawItem(this.items[n], this.active === n);
  this.show();
};
No.prototype.drawItem = function(n, e) {
  var t = document.createElement("li"), i = document.createElement("a");
  e && (t.className += " active"), i.innerHTML = n.string, t.appendChild(i), this.element.appendChild(t), t.addEventListener("mousedown", (function() {
    this.selectingListItem = !0;
  }).bind(this)), t.addEventListener("mouseup", (function() {
    this.handleMouseUp.call(this, n);
  }).bind(this));
};
No.prototype.handleMouseUp = function(n) {
  this.selectingListItem = !1, this.component.value(n.original), this.clear(), this.draw();
};
No.prototype.move = function(n) {
  this.active = n, this.draw();
};
No.prototype.previous = function() {
  this.move(this.active <= 0 ? this.items.length - 1 : this.active - 1);
};
No.prototype.next = function() {
  this.move(this.active >= this.items.length - 1 ? 0 : this.active + 1);
};
No.prototype.drawError = function(n) {
  var e = document.createElement("li");
  e.innerHTML = n, this.element.appendChild(e), this.show();
};
var FV = No, DV = CT, kV = OV, NV = FV, Zs = function(n, e, t) {
  return t = t || {}, this.options = DV({
    minLength: 2,
    limit: 5,
    filter: !0,
    hideOnBlur: !0,
    noInitialSelection: !0
  }, t), this.el = n, this.data = e || [], this.list = new NV(this), this.query = "", this.selected = null, this.list.draw(), this.el.addEventListener("keyup", (function(i) {
    this.handleKeyUp(i.keyCode, i);
  }).bind(this), !1), this.el.addEventListener("keydown", (function(i) {
    this.handleKeyDown(i);
  }).bind(this)), this.el.addEventListener("focus", (function() {
    this.handleFocus();
  }).bind(this)), this.el.addEventListener("blur", (function() {
    this.handleBlur();
  }).bind(this)), this.el.addEventListener("paste", (function(i) {
    this.handlePaste(i);
  }).bind(this)), this.render = this.options.render ? this.options.render.bind(this) : this.render.bind(this), this.getItemValue = this.options.getItemValue ? this.options.getItemValue.bind(this) : this.getItemValue.bind(this), this;
};
Zs.prototype.handleKeyUp = function(n, e) {
  if (!(n === 40 || n === 38 || n === 27 || n === 9)) {
    if (n === 13) {
      this.list.items[this.list.active] && (this.list.handleMouseUp(this.list.items[this.list.active]), e.stopPropagation());
      return;
    }
    this.handleInputChange(this.el.value);
  }
};
Zs.prototype.handleKeyDown = function(n) {
  switch (n.keyCode) {
    case 13:
      this.list.active >= 0 && (this.list.selectingListItem = !0);
      break;
    case 9:
      this.list.isEmpty() || (this.list.isVisible() && n.preventDefault(), this.value(this.list.active >= 0 ? this.list.items[this.list.active].original : null), this.list.hide());
      break;
    case 27:
      this.list.isEmpty() || this.list.hide();
      break;
    case 38:
      this.list.previous();
      break;
    case 40:
      this.list.next();
      break;
  }
};
Zs.prototype.handleBlur = function() {
  !this.list.selectingListItem && this.options.hideOnBlur && this.list.hide();
};
Zs.prototype.handlePaste = function(n) {
  if (n.clipboardData)
    this.handleInputChange(n.clipboardData.getData("Text"));
  else {
    var e = this;
    setTimeout(function() {
      e.handleInputChange(n.target.value);
    }, 100);
  }
};
Zs.prototype.handleInputChange = function(n) {
  if (this.query = this.normalize(n), this.list.clear(), this.query.length < this.options.minLength) {
    this.list.draw();
    return;
  }
  this.getCandidates((function(e) {
    for (var t = 0; t < e.length && (this.list.add(e[t]), t !== this.options.limit - 1); t++)
      ;
    this.list.draw();
  }).bind(this));
};
Zs.prototype.handleFocus = function() {
  this.list.isEmpty() || this.list.show(), this.list.selectingListItem = !1;
};
Zs.prototype.update = function(n) {
  this.data = n, this.handleKeyUp();
};
Zs.prototype.clear = function() {
  this.data = [], this.list.clear();
};
Zs.prototype.normalize = function(n) {
  return n = n.toLowerCase(), n;
};
Zs.prototype.match = function(n, e) {
  return n.indexOf(e) > -1;
};
Zs.prototype.value = function(n) {
  if (this.selected = n, this.el.value = this.getItemValue(n || {
    place_name: this.query
  }), document.createEvent) {
    var e = document.createEvent("HTMLEvents");
    e.initEvent("change", !0, !1), this.el.dispatchEvent(e);
  } else
    this.el.fireEvent("onchange");
};
Zs.prototype.getCandidates = function(n) {
  var e = {
    pre: "<strong>",
    post: "</strong>",
    extract: (function(i) {
      return this.getItemValue(i);
    }).bind(this)
  }, t;
  this.options.filter ? (t = kV.filter(this.query, this.data, e), t = t.map((function(i) {
    return {
      original: i.original,
      string: this.render(i.original, i.string)
    };
  }).bind(this))) : t = this.data.map((function(i) {
    var r = this.render(i);
    return {
      original: i,
      string: r
    };
  }).bind(this)), n(t);
};
Zs.prototype.getItemValue = function(n) {
  return n;
};
Zs.prototype.render = function(n, e) {
  if (e)
    return e;
  for (var t = n.original ? this.getItemValue(n.original) : this.getItemValue(n), i = this.normalize(t), r = i.lastIndexOf(this.query); r > -1; ) {
    var s = r + this.query.length;
    t = t.slice(0, r) + "<strong>" + t.slice(r, s) + "</strong>" + t.slice(s), r = i.slice(0, r).lastIndexOf(this.query);
  }
  return t;
};
Zs.prototype.renderError = function(n) {
  this.list.drawError(n);
};
var zV = Zs, PT = zV, UV = PT;
typeof window < "u" && (window.Suggestions = PT);
var jV = "Expected a function", JA = NaN, GV = "[object Symbol]", VV = /^\s+|\s+$/g, qV = /^[-+]0x[0-9a-f]+$/i, HV = /^0b[01]+$/i, WV = /^0o[0-7]+$/i, XV = parseInt, JV = typeof Ed == "object" && Ed && Ed.Object === Object && Ed, $V = typeof self == "object" && self && self.Object === Object && self, ZV = JV || $V || Function("return this")(), YV = Object.prototype, KV = YV.toString, QV = Math.max, eq = Math.min, q_ = function() {
  return ZV.Date.now();
};
function tq(n, e, t) {
  var i, r, s, c, l, m, y = 0, A = !1, T = !1, I = !0;
  if (typeof n != "function")
    throw new TypeError(jV);
  e = $A(e) || 0, e1(t) && (A = !!t.leading, T = "maxWait" in t, s = T ? QV($A(t.maxWait) || 0, e) : s, I = "trailing" in t ? !!t.trailing : I);
  function L(De) {
    var Le = i, ye = r;
    return i = r = void 0, y = De, c = n.apply(ye, Le), c;
  }
  function N(De) {
    return y = De, l = setTimeout(H, e), A ? L(De) : c;
  }
  function z(De) {
    var Le = De - m, ye = De - y, Ve = e - Le;
    return T ? eq(Ve, s - ye) : Ve;
  }
  function V(De) {
    var Le = De - m, ye = De - y;
    return m === void 0 || Le >= e || Le < 0 || T && ye >= s;
  }
  function H() {
    var De = q_();
    if (V(De))
      return J(De);
    l = setTimeout(H, z(De));
  }
  function J(De) {
    return l = void 0, I && i ? L(De) : (i = r = void 0, c);
  }
  function ce() {
    l !== void 0 && clearTimeout(l), y = 0, i = m = r = l = void 0;
  }
  function me() {
    return l === void 0 ? c : J(q_());
  }
  function Se() {
    var De = q_(), Le = V(De);
    if (i = arguments, r = this, m = De, Le) {
      if (l === void 0)
        return N(m);
      if (T)
        return l = setTimeout(H, e), L(m);
    }
    return l === void 0 && (l = setTimeout(H, e)), c;
  }
  return Se.cancel = ce, Se.flush = me, Se;
}
function e1(n) {
  var e = typeof n;
  return !!n && (e == "object" || e == "function");
}
function nq(n) {
  return !!n && typeof n == "object";
}
function iq(n) {
  return typeof n == "symbol" || nq(n) && KV.call(n) == GV;
}
function $A(n) {
  if (typeof n == "number")
    return n;
  if (iq(n))
    return JA;
  if (e1(n)) {
    var e = typeof n.valueOf == "function" ? n.valueOf() : n;
    n = e1(e) ? e + "" : e;
  }
  if (typeof n != "string")
    return n === 0 ? n : +n;
  n = n.replace(VV, "");
  var t = HV.test(n);
  return t || WV.test(n) ? XV(n.slice(2), t ? 2 : 8) : qV.test(n) ? JA : +n;
}
var rq = tq, Iv = { exports: {} }, zd = typeof Reflect == "object" ? Reflect : null, ZA = zd && typeof zd.apply == "function" ? zd.apply : function(e, t, i) {
  return Function.prototype.apply.call(e, t, i);
}, nm;
zd && typeof zd.ownKeys == "function" ? nm = zd.ownKeys : Object.getOwnPropertySymbols ? nm = function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : nm = function(e) {
  return Object.getOwnPropertyNames(e);
};
function sq(n) {
  console && console.warn && console.warn(n);
}
var LT = Number.isNaN || function(e) {
  return e !== e;
};
function Wi() {
  Wi.init.call(this);
}
Iv.exports = Wi;
Iv.exports.once = cq;
Wi.EventEmitter = Wi;
Wi.prototype._events = void 0;
Wi.prototype._eventsCount = 0;
Wi.prototype._maxListeners = void 0;
var YA = 10;
function qm(n) {
  if (typeof n != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof n);
}
Object.defineProperty(Wi, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return YA;
  },
  set: function(n) {
    if (typeof n != "number" || n < 0 || LT(n))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + n + ".");
    YA = n;
  }
});
Wi.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
Wi.prototype.setMaxListeners = function(e) {
  if (typeof e != "number" || e < 0 || LT(e))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
  return this._maxListeners = e, this;
};
function MT(n) {
  return n._maxListeners === void 0 ? Wi.defaultMaxListeners : n._maxListeners;
}
Wi.prototype.getMaxListeners = function() {
  return MT(this);
};
Wi.prototype.emit = function(e) {
  for (var t = [], i = 1; i < arguments.length; i++)
    t.push(arguments[i]);
  var r = e === "error", s = this._events;
  if (s !== void 0)
    r = r && s.error === void 0;
  else if (!r)
    return !1;
  if (r) {
    var c;
    if (t.length > 0 && (c = t[0]), c instanceof Error)
      throw c;
    var l = new Error("Unhandled error." + (c ? " (" + c.message + ")" : ""));
    throw l.context = c, l;
  }
  var m = s[e];
  if (m === void 0)
    return !1;
  if (typeof m == "function")
    ZA(m, this, t);
  else
    for (var y = m.length, A = DT(m, y), i = 0; i < y; ++i)
      ZA(A[i], this, t);
  return !0;
};
function BT(n, e, t, i) {
  var r, s, c;
  if (qm(t), s = n._events, s === void 0 ? (s = n._events = /* @__PURE__ */ Object.create(null), n._eventsCount = 0) : (s.newListener !== void 0 && (n.emit("newListener", e, t.listener ? t.listener : t), s = n._events), c = s[e]), c === void 0)
    c = s[e] = t, ++n._eventsCount;
  else if (typeof c == "function" ? c = s[e] = i ? [t, c] : [c, t] : i ? c.unshift(t) : c.push(t), r = MT(n), r > 0 && c.length > r && !c.warned) {
    c.warned = !0;
    var l = new Error("Possible EventEmitter memory leak detected. " + c.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    l.name = "MaxListenersExceededWarning", l.emitter = n, l.type = e, l.count = c.length, sq(l);
  }
  return n;
}
Wi.prototype.addListener = function(e, t) {
  return BT(this, e, t, !1);
};
Wi.prototype.on = Wi.prototype.addListener;
Wi.prototype.prependListener = function(e, t) {
  return BT(this, e, t, !0);
};
function oq() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function RT(n, e, t) {
  var i = {
    fired: !1,
    wrapFn: void 0,
    target: n,
    type: e,
    listener: t
  }, r = oq.bind(i);
  return r.listener = t, i.wrapFn = r, r;
}
Wi.prototype.once = function(e, t) {
  return qm(t), this.on(e, RT(this, e, t)), this;
};
Wi.prototype.prependOnceListener = function(e, t) {
  return qm(t), this.prependListener(e, RT(this, e, t)), this;
};
Wi.prototype.removeListener = function(e, t) {
  var i, r, s, c, l;
  if (qm(t), r = this._events, r === void 0)
    return this;
  if (i = r[e], i === void 0)
    return this;
  if (i === t || i.listener === t)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete r[e], r.removeListener && this.emit("removeListener", e, i.listener || t));
  else if (typeof i != "function") {
    for (s = -1, c = i.length - 1; c >= 0; c--)
      if (i[c] === t || i[c].listener === t) {
        l = i[c].listener, s = c;
        break;
      }
    if (s < 0)
      return this;
    s === 0 ? i.shift() : aq(i, s), i.length === 1 && (r[e] = i[0]), r.removeListener !== void 0 && this.emit("removeListener", e, l || t);
  }
  return this;
};
Wi.prototype.off = Wi.prototype.removeListener;
Wi.prototype.removeAllListeners = function(e) {
  var t, i, r;
  if (i = this._events, i === void 0)
    return this;
  if (i.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : i[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete i[e]), this;
  if (arguments.length === 0) {
    var s = Object.keys(i), c;
    for (r = 0; r < s.length; ++r)
      c = s[r], c !== "removeListener" && this.removeAllListeners(c);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (t = i[e], typeof t == "function")
    this.removeListener(e, t);
  else if (t !== void 0)
    for (r = t.length - 1; r >= 0; r--)
      this.removeListener(e, t[r]);
  return this;
};
function OT(n, e, t) {
  var i = n._events;
  if (i === void 0)
    return [];
  var r = i[e];
  return r === void 0 ? [] : typeof r == "function" ? t ? [r.listener || r] : [r] : t ? lq(r) : DT(r, r.length);
}
Wi.prototype.listeners = function(e) {
  return OT(this, e, !0);
};
Wi.prototype.rawListeners = function(e) {
  return OT(this, e, !1);
};
Wi.listenerCount = function(n, e) {
  return typeof n.listenerCount == "function" ? n.listenerCount(e) : FT.call(n, e);
};
Wi.prototype.listenerCount = FT;
function FT(n) {
  var e = this._events;
  if (e !== void 0) {
    var t = e[n];
    if (typeof t == "function")
      return 1;
    if (t !== void 0)
      return t.length;
  }
  return 0;
}
Wi.prototype.eventNames = function() {
  return this._eventsCount > 0 ? nm(this._events) : [];
};
function DT(n, e) {
  for (var t = new Array(e), i = 0; i < e; ++i)
    t[i] = n[i];
  return t;
}
function aq(n, e) {
  for (; e + 1 < n.length; e++)
    n[e] = n[e + 1];
  n.pop();
}
function lq(n) {
  for (var e = new Array(n.length), t = 0; t < e.length; ++t)
    e[t] = n[t].listener || n[t];
  return e;
}
function cq(n, e) {
  return new Promise(function(t, i) {
    function r(c) {
      n.removeListener(e, s), i(c);
    }
    function s() {
      typeof n.removeListener == "function" && n.removeListener("error", r), t([].slice.call(arguments));
    }
    kT(n, e, s, {
      once: !0
    }), e !== "error" && uq(n, r, {
      once: !0
    });
  });
}
function uq(n, e, t) {
  typeof n.on == "function" && kT(n, "error", e, t);
}
function kT(n, e, t, i) {
  if (typeof n.on == "function")
    i.once ? n.once(e, t) : n.on(e, t);
  else if (typeof n.addEventListener == "function")
    n.addEventListener(e, function r(s) {
      i.once && n.removeEventListener(e, r), t(s);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof n);
}
var NT = Iv.exports, hq = {
  fr: {
    name: "France",
    bbox: [[-4.59235, 41.380007], [9.560016, 51.148506]]
  },
  us: {
    name: "United States",
    bbox: [[-171.791111, 18.91619], [-66.96466, 71.357764]]
  },
  ru: {
    name: "Russia",
    bbox: [[19.66064, 41.151416], [190.10042, 81.2504]]
  },
  ca: {
    name: "Canada",
    bbox: [[-140.99778, 41.675105], [-52.648099, 83.23324]]
  }
}, dq = {
  // list drawn from https://docs.mapbox.com/api/search/#language-coverage
  de: "Suche",
  // german
  it: "Ricerca",
  //italian
  en: "Search",
  // english
  nl: "Zoeken",
  //dutch
  fr: "Chercher",
  //french
  ca: "Cerca",
  //catalan
  he: "",
  //hebrew
  ja: "",
  //japanese
  lv: "Meklt",
  //latvian
  pt: "Procurar",
  //portuguese 
  sr: "",
  //serbian
  zh: "",
  //chinese-simplified
  cs: "Vyhledvn",
  //czech
  hu: "Keress",
  //hungarian
  ka: "",
  // georgian
  nb: "Ske",
  //norwegian
  sk: "Vyhadvanie",
  //slovak
  th: "",
  //thai
  fi: "Hae",
  //finnish
  is: "Leita",
  //icelandic
  ko: "",
  //korean
  pl: "Szukaj",
  //polish
  sl: "Iskanje",
  //slovenian
  fa: "",
  //persian(aka farsi)
  ru: ""
  //russian
}, fq = {
  placeholder: dq
}, zT = { exports: {} };
(function(n) {
  (function(e, t, i) {
    n.exports ? n.exports = i() : e[t] = i();
  })(Ed, "subtag", function() {
    var e = "", t = /^([a-zA-Z]{2,3})(?:[_-]+([a-zA-Z]{3})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{4})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{2}|[0-9]{3})(?=$|[_-]+))?/;
    function i(m) {
      return m.match(t) || [];
    }
    function r(m) {
      return i(m).filter(function(y, A) {
        return y && A;
      });
    }
    function s(m) {
      return m = i(m), {
        language: m[1] || e,
        extlang: m[2] || e,
        script: m[3] || e,
        region: m[4] || e
      };
    }
    function c(m, y, A) {
      Object.defineProperty(m, y, {
        value: A,
        enumerable: !0
      });
    }
    function l(m, y, A) {
      function T(I) {
        return i(I)[m] || e;
      }
      c(T, "pattern", y), c(s, A, T);
    }
    return l(1, /^[a-zA-Z]{2,3}$/, "language"), l(2, /^[a-zA-Z]{3}$/, "extlang"), l(3, /^[a-zA-Z]{4}$/, "script"), l(4, /^[a-zA-Z]{2}$|^[0-9]{3}$/, "region"), c(s, "split", r), s;
  });
})(zT);
var pq = zT.exports, gq = UV, mq = rq, ua = CT, _q = NT.EventEmitter, KA = hq, yq = fq, vq = pq;
function UT(n, e) {
  this._eventEmitter = new _q(), this.options = ua({}, this.options, e), this.inputString = "", this.fresh = !0, this.lastSelected = null, this.geocoderApi = n;
}
UT.prototype = {
  options: {
    zoom: 16,
    flyTo: !0,
    trackProximity: !0,
    showResultsWhileTyping: !1,
    minLength: 2,
    reverseGeocode: !1,
    limit: 5,
    enableEventLogging: !0,
    marker: !0,
    popup: !1,
    maplibregl: null,
    collapsed: !1,
    clearAndBlurOnEsc: !1,
    clearOnBlur: !1,
    getItemValue: function(n) {
      return n.text !== void 0 ? n.text : n.place_name;
    },
    render: function(n) {
      if (n.geometry) {
        var l = n.place_name.split(",");
        return '<div class="mapboxgl-ctrl-geocoder--result maplibregl-ctrl-geocoder--result"><svg class="mapboxgl-ctrl-geocoder--result-icon maplibre-ctrl-geocoder--result-icon" viewBox="0 0 24 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 0C5.36571 0 0 5.38676 0 12.0471C0 21.0824 12 32 12 32C12 32 24 21.0824 24 12.0471C24 5.38676 18.6343 0 12 0ZM12 16.3496C9.63428 16.3496 7.71429 14.4221 7.71429 12.0471C7.71429 9.67207 9.63428 7.74454 12 7.74454C14.3657 7.74454 16.2857 9.67207 16.2857 12.0471C16.2857 14.4221 14.3657 16.3496 12 16.3496Z" fill="#687078"/></svg><div><div class="mapboxgl-ctrl-geocoder--result-title maplibregl-ctrl-geocoder--result-title">' + l[0] + '</div><div class="mapboxgl-ctrl-geocoder--result-address maplibregl-ctrl-geocoder--result-address">' + l.splice(1, l.length).join(",") + "</div></div></div>";
      } else {
        var e = n.text, t = e.toLowerCase().indexOf(this.query.toLowerCase()), i = this.query.length, r = e.substring(0, t), s = e.substring(t, t + i), c = e.substring(t + i);
        return '<div class="mapboxgl-ctrl-geocoder--suggestion maplibregl-ctrl-geocoder--suggestion"><svg class="mapboxgl-ctrl-geocoder--suggestion-icon maplibre-ctrl-geocoder--suggestion-icon" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M22.8702 20.1258H21.4248L20.9125 19.6318C22.7055 17.546 23.785 14.8382 23.785 11.8925C23.785 5.32419 18.4608 0 11.8925 0C5.32419 0 0 5.32419 0 11.8925C0 18.4608 5.32419 23.785 11.8925 23.785C14.8382 23.785 17.546 22.7055 19.6318 20.9125L20.1258 21.4248V22.8702L29.2739 32L32 29.2739L22.8702 20.1258ZM11.8925 20.1258C7.33676 20.1258 3.65923 16.4483 3.65923 11.8925C3.65923 7.33676 7.33676 3.65923 11.8925 3.65923C16.4483 3.65923 20.1258 7.33676 20.1258 11.8925C20.1258 16.4483 16.4483 20.1258 11.8925 20.1258Z" fill="#687078"/></svg><div class="mapboxgl-ctrl-geocoder--suggestion-info maplibregl-ctrl-geocoder--suggestion-info"><div class="mapboxgl-ctrl-geocoder--suggestion-title maplibregl-ctrl-geocoder--suggestion-title">' + r + '<span class="mapboxgl-ctrl-geocoder--suggestion-match maplibregl-ctrl-geocoder--suggestion-match">' + s + "</span>" + c + "</div></div></div>";
      }
    },
    popupRender: function(n) {
      var e = n.place_name.split(",");
      return '<div class="mapboxgl-ctrl-geocoder--suggestion maplibre-ctrl-geocoder--suggestion popup-suggestion"><div class="mapboxgl-ctrl-geocoder--suggestion-title maplibre-ctrl-geocoder--suggestion-title popup-suggestion-title">' + e[0] + '</div><div class="mapboxgl-ctrl-geocoder--suggestion-address maplibre-ctrl-geocoder--suggestion-address popup-suggestion-address">' + e.splice(1, e.length).join(",") + "</div></div>";
    },
    showResultMarkers: !0,
    debounceSearch: 200
  },
  /**
   * Add the geocoder to a container. The container can be either a `maplibregl.Map`, an `HTMLElement` or a CSS selector string.
   *
   * If the container is a [`maplibregl.Map`](https://maplibre.org/maplibre-gl-js-docs/api/map/#map), this function will behave identically to [`Map.addControl(geocoder)`](https://maplibre.org/maplibre-gl-js-docs/api/map/#map#addcontrol).
   * If the container is an instance of [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement), then the geocoder will be appended as a child of that [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement).
   * If the container is a [CSS selector string](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors), the geocoder will be appended to the element returned from the query.
   *
   * This function will throw an error if the container is none of the above.
   * It will also throw an error if the referenced HTML element cannot be found in the `document.body`.
   *
   * For example, if the HTML body contains the element `<div id='geocoder-container'></div>`, the following script will append the geocoder to `#geocoder-container`:
   *
   * ```javascript
   * var GeoApi = {
   *   forwardGeocode: (config) => { return { features: [] } },
   *   reverseGeocode: (config) => { return { features: [] } }
   * }
   * var geocoder = new MaplibreGeocoder(GeoAPI, {});
   * geocoder.addTo('#geocoder-container');
   * ```
   * @param {String|HTMLElement|maplibregl.Map} container A reference to the container to which to add the geocoder
   */
  addTo: function(n) {
    function e(i, r) {
      if (!document.body.contains(r))
        throw new Error("Element provided to #addTo() exists, but is not in the DOM");
      var s = i.onAdd();
      r.appendChild(s);
    }
    if (n._controlContainer)
      n.addControl(this);
    else if (n instanceof HTMLElement)
      e(this, n);
    else if (typeof n == "string") {
      var t = document.querySelectorAll(n);
      if (t.length === 0)
        throw new Error("Element ", n, "not found.");
      if (t.length > 1)
        throw new Error("Geocoder can only be added to a single html element");
      e(this, t[0]);
    } else
      throw new Error("Error: addTo must be a maplibre-gl-js map, an html element, or a CSS selector query for a single html element");
  },
  onAdd: function(n) {
    if (n && typeof n != "string" && (this._map = n), this.setLanguage(), this.options.localGeocoderOnly && !this.options.localGeocoder)
      throw new Error("A localGeocoder function must be specified to use localGeocoderOnly mode");
    this._onChange = this._onChange.bind(this), this._onKeyDown = this._onKeyDown.bind(this), this._onPaste = this._onPaste.bind(this), this._onBlur = this._onBlur.bind(this), this._showButton = this._showButton.bind(this), this._hideButton = this._hideButton.bind(this), this._onQueryResult = this._onQueryResult.bind(this), this.clear = this.clear.bind(this), this._updateProximity = this._updateProximity.bind(this), this._collapse = this._collapse.bind(this), this._unCollapse = this._unCollapse.bind(this), this._clear = this._clear.bind(this), this._clearOnBlur = this._clearOnBlur.bind(this);
    var e = this.container = document.createElement("div");
    e.className = "mapboxgl-ctrl-geocoder mapboxgl-ctrl maplibregl-ctrl-geocoder maplibregl-ctrl";
    var t = this.createIcon("search", '<path d="M7.4 2.5c-2.7 0-4.9 2.2-4.9 4.9s2.2 4.9 4.9 4.9c1 0 1.8-.2 2.5-.8l3.7 3.7c.2.2.4.3.8.3.7 0 1.1-.4 1.1-1.1 0-.3-.1-.5-.3-.8L11.4 10c.4-.8.8-1.6.8-2.5.1-2.8-2.1-5-4.8-5zm0 1.6c1.8 0 3.2 1.4 3.2 3.2s-1.4 3.2-3.2 3.2-3.3-1.3-3.3-3.1 1.4-3.3 3.3-3.3z"/>');
    this._inputEl = document.createElement("input"), this._inputEl.type = "text", this._inputEl.className = "mapboxgl-ctrl-geocoder--input maplibregl-ctrl-geocoder--input", this.setPlaceholder(), this.options.collapsed && (this._collapse(), this.container.addEventListener("mouseenter", this._unCollapse), this.container.addEventListener("mouseleave", this._collapse), this._inputEl.addEventListener("focus", this._unCollapse)), (this.options.collapsed || this.options.clearOnBlur) && this._inputEl.addEventListener("blur", this._onBlur), this._inputEl.addEventListener("keydown", mq(this._onKeyDown, this.options.debounceSearch)), this._inputEl.addEventListener("paste", this._onPaste), this._inputEl.addEventListener("change", this._onChange), this.container.addEventListener("mouseenter", this._showButton), this.container.addEventListener("mouseleave", this._hideButton);
    var i = document.createElement("div");
    i.classList.add("mapboxgl-ctrl-geocoder--pin-right", "maplibregl-ctrl-geocoder--pin-right"), this._clearEl = document.createElement("button"), this._clearEl.setAttribute("aria-label", "Clear"), this._clearEl.addEventListener("click", this.clear), this._clearEl.className = "mapboxgl-ctrl-geocoder--button maplibregl-ctrl-geocoder--button";
    var r = this.createIcon("close", '<path d="M3.8 2.5c-.6 0-1.3.7-1.3 1.3 0 .3.2.7.5.8L7.2 9 3 13.2c-.3.3-.5.7-.5 1 0 .6.7 1.3 1.3 1.3.3 0 .7-.2 1-.5L9 10.8l4.2 4.2c.2.3.7.3 1 .3.6 0 1.3-.7 1.3-1.3 0-.3-.2-.7-.3-1l-4.4-4L15 4.6c.3-.2.5-.5.5-.8 0-.7-.7-1.3-1.3-1.3-.3 0-.7.2-1 .3L9 7.1 4.8 2.8c-.3-.1-.7-.3-1-.3z"/>');
    return this._clearEl.appendChild(r), this._loadingEl = this.createIcon("loading", '<path fill="#333" d="M4.4 4.4l.8.8c2.1-2.1 5.5-2.1 7.6 0l.8-.8c-2.5-2.5-6.7-2.5-9.2 0z"/><path opacity=".1" d="M12.8 12.9c-2.1 2.1-5.5 2.1-7.6 0-2.1-2.1-2.1-5.5 0-7.7l-.8-.8c-2.5 2.5-2.5 6.7 0 9.2s6.6 2.5 9.2 0 2.5-6.6 0-9.2l-.8.8c2.2 2.1 2.2 5.6 0 7.7z"/>'), i.appendChild(this._clearEl), i.appendChild(this._loadingEl), e.appendChild(t), e.appendChild(this._inputEl), e.appendChild(i), this._typeahead = new gq(this._inputEl, [], {
      filter: !1,
      minLength: this.options.minLength,
      limit: this.options.limit,
      noInitialSelection: !0
    }), this.setRenderFunction(this.options.render), this._typeahead.getItemValue = this.options.getItemValue, this.mapMarker = null, this.resultMarkers = [], this._handleMarker = this._handleMarker.bind(this), this._handleResultMarkers = this._handleResultMarkers.bind(this), this._map && (this.options.trackProximity && (this._updateProximity(), this._map.on("moveend", this._updateProximity)), this._maplibregl = this.options.maplibregl, !this._maplibregl && this.options.marker && (console.error("No maplibregl detected in options. Map markers are disabled. Please set options.maplibregl."), this.options.marker = !1)), e;
  },
  createIcon: function(n, e) {
    var t = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    if (t.setAttribute("class", "mapboxgl-ctrl-geocoder--icon mapboxgl-ctrl-geocoder--icon-" + n + " maplibregl-ctrl-geocoder--icon maplibregl-ctrl-geocoder--icon-" + n), t.setAttribute("viewBox", "0 0 18 18"), t.setAttribute("xml:space", "preserve"), t.setAttribute("width", 18), t.setAttribute("height", 18), "innerHTML" in t)
      t.innerHTML = e;
    else {
      var i = document.createElement("div");
      i.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>";
      var r = i.firstChild, s = r.firstChild;
      t.appendChild(s);
    }
    return t;
  },
  onRemove: function() {
    return this.container.parentNode.removeChild(this.container), this.options.trackProximity && this._map && this._map.off("moveend", this._updateProximity), this._removeMarker(), this._map = null, this;
  },
  _onPaste: function(n) {
    var e = (n.clipboardData || window.clipboardData).getData("text");
    e.length >= this.options.minLength && this.options.showResultsWhileTyping && this._geocode(e);
  },
  _onKeyDown: function(n) {
    var e = 27, t = 9;
    if (n.keyCode === e && this.options.clearAndBlurOnEsc)
      return this._clear(n), this._inputEl.blur();
    var i = n.target && n.target.shadowRoot ? n.target.shadowRoot.activeElement : n.target, r = i ? i.value : "";
    if (!r)
      return this.fresh = !0, n.keyCode !== t && this.clear(n), this._clearEl.style.display = "none";
    if (!(n.metaKey || [t, e, 37, 39, 38, 40].indexOf(n.keyCode) !== -1)) {
      if (n.keyCode === 13)
        if (!this.options.showResultsWhileTyping)
          this._typeahead.selected || this._geocode(i.value);
        else {
          this._typeahead.selected == null && this.geocoderApi.getSuggestions ? this._geocode(i.value, !0) : this._typeahead.selected == null && this.options.showResultMarkers && this._fitBoundsForMarkers();
          return;
        }
      i.value.length >= this.options.minLength && this.options.showResultsWhileTyping && this._geocode(i.value);
    }
  },
  _showButton: function() {
    this._inputEl.value.length > 0 && (this._clearEl.style.display = "block");
  },
  _hideButton: function() {
    this._typeahead.selected && (this._clearEl.style.display = "none");
  },
  _onBlur: function(n) {
    this.options.clearOnBlur && this._clearOnBlur(n), this.options.collapsed && this._collapse();
  },
  // Change events are fire by suggestions library whenever the enter key is pressed or input is blurred
  // This can sometimes cause strange behavior as this function is called before our own onKeyDown handler and thus
  //  we cannot depend on some internal values of the suggestion state like `selected` as those will change or before
  //  our onKeyDown handler.
  _onChange: function() {
    var n = this._typeahead.selected;
    if (n && !n.geometry)
      n.placeId ? this._geocode(n.placeId, !0, !0) : this._geocode(n.text, !0);
    else if (n && JSON.stringify(n) !== this.lastSelected) {
      if (this._clearEl.style.display = "none", this.options.flyTo) {
        var e;
        if (this._removeResultMarkers(), n.properties && KA[n.properties.short_code])
          e = ua({}, this.options.flyTo), this._map && this._map.fitBounds(KA[n.properties.short_code].bbox, e);
        else if (n.bbox) {
          var t = n.bbox;
          e = ua({}, this.options.flyTo), this._map && this._map.fitBounds([[t[0], t[1]], [t[2], t[3]]], e);
        } else {
          var i = {
            zoom: this.options.zoom
          };
          e = ua({}, i, this.options.flyTo), n.center ? e.center = n.center : n.geometry && n.geometry.type && n.geometry.type === "Point" && n.geometry.coordinates && (e.center = n.geometry.coordinates), this._map && this._map.flyTo(e);
        }
      }
      this.options.marker && this._maplibregl && this._handleMarker(n), this._inputEl.focus(), this._inputEl.scrollLeft = 0, this._inputEl.setSelectionRange(0, 0), this.lastSelected = JSON.stringify(n), this._typeahead.selected = null, this._eventEmitter.emit("result", {
        result: n
      });
    }
  },
  _getConfigForRequest: function() {
    var n = ["bbox", "limit", "proximity", "countries", "types", "language", "reverseMode"], e = this, t = n.reduce(function(i, r) {
      return e.options[r] && (["countries", "types", "language"].indexOf(r) > -1 ? i[r] = e.options[r].split(/[\s,]+/) : i[r] = e.options[r], r === "proximity" && e.options[r] && typeof e.options[r].longitude == "number" && typeof e.options[r].latitude == "number" && (i[r] = [e.options[r].longitude, e.options[r].latitude])), i;
    }, {});
    return t;
  },
  _geocode: function(n, e, t) {
    this._loadingEl.style.display = "block", this._eventEmitter.emit("loading", {
      query: n
    }), this.inputString = n;
    var i = null, r = this._getConfigForRequest(), s;
    if (this.options.localGeocoderOnly)
      s = Promise.resolve();
    else if (this.options.reverseGeocode && /(-?\d+\.?\d*)[, ]+(-?\d+\.?\d*)[ ]*$/.test(n)) {
      var c = n.split(/[\s(,)?]+/).map(function(y) {
        return parseFloat(y, 10);
      }).reverse();
      r.types && r.types[0], r = ua(r, {
        query: c,
        limit: 1
      }), "proximity" in r && delete r.proximity, s = this.geocoderApi.reverseGeocode(r);
    } else
      r = ua(r, {
        query: n
      }), this.geocoderApi.getSuggestions ? e ? this.geocoderApi.searchByPlaceId && t ? s = this.geocoderApi.searchByPlaceId(r) : s = this.geocoderApi.forwardGeocode(r) : s = this.geocoderApi.getSuggestions(r) : s = this.geocoderApi.forwardGeocode(r);
    var l = [];
    this.options.localGeocoder && (l = this.options.localGeocoder(n), l || (l = []));
    var m = [];
    return s.catch((function(y) {
      i = y;
    }).bind(this)).then((function(y) {
      this._loadingEl.style.display = "none";
      var A = {};
      return y ? A = y : A = {
        type: "FeatureCollection",
        features: []
      }, A.config = r, this.fresh && (this.fresh = !1), A.features = A.features ? l.concat(A.features) : l, this.options.externalGeocoder ? (m = this.options.externalGeocoder(n, A.features, r) || [], m.then(function(T) {
        return A.features = A.features ? T.concat(A.features) : T, A;
      }, function() {
        return A;
      })) : A;
    }).bind(this)).then((function(y) {
      if (i)
        throw i;
      this.options.filter && y.features.length && (y.features = y.features.filter(this.options.filter));
      var A = [];
      y.suggestions ? A = y.suggestions : y.place ? A = [y.place] : A = y.features, A.length ? (this._clearEl.style.display = "block", this._typeahead.update(A), (!this.options.showResultsWhileTyping || e) && this.options.showResultMarkers && (y.features.length > 0 || y.place) && this._fitBoundsForMarkers(), this._eventEmitter.emit("results", y)) : (this._clearEl.style.display = "none", this._typeahead.selected = null, this._renderNoResults(), this._eventEmitter.emit("results", y));
    }).bind(this)).catch((function(y) {
      this._loadingEl.style.display = "none", l.length && this.options.localGeocoder || m.length && this.options.externalGeocoder ? (this._clearEl.style.display = "block", this._typeahead.update(l)) : (this._clearEl.style.display = "none", this._typeahead.selected = null, this._renderError()), this._eventEmitter.emit("results", {
        features: l
      }), this._eventEmitter.emit("error", {
        error: y
      });
    }).bind(this)), s;
  },
  /**
   * Shared logic for clearing input
   * @param {Event} [ev] the event that triggered the clear, if available
   * @private
   *
   */
  _clear: function(n) {
    n && n.preventDefault(), this._inputEl.value = "", this._typeahead.selected = null, this._typeahead.clear(), this._onChange(), this._clearEl.style.display = "none", this._removeMarker(), this._removeResultMarkers(), this.lastSelected = null, this._eventEmitter.emit("clear"), this.fresh = !0;
  },
  /**
   * Clear and then focus the input.
   * @param {Event} [ev] the event that triggered the clear, if available
   *
   */
  clear: function(n) {
    this._clear(n), this._inputEl.focus();
  },
  /**
   * Clear the input, without refocusing it. Used to implement clearOnBlur
   * constructor option.
   * @param {Event} [ev] the blur event
   * @private
   */
  _clearOnBlur: function(n) {
    var e = this;
    n.relatedTarget && e._clear(n);
  },
  _onQueryResult: function(n) {
    var e = n;
    if (e.features.length) {
      var t = e.features[0];
      this._typeahead.selected = t, this._inputEl.value = t.place_name, this._onChange();
    }
  },
  _updateProximity: function() {
    if (this._map)
      if (this._map.getZoom() > 9) {
        var n = this._map.getCenter().wrap();
        this.setProximity({
          longitude: n.lng,
          latitude: n.lat
        });
      } else
        this.setProximity(null);
  },
  _collapse: function() {
    !this._inputEl.value && this._inputEl !== document.activeElement && this.container.classList.add("mapboxgl-ctrl-geocoder--collapsed", "maplibregl-ctrl-geocoder--collapsed");
  },
  _unCollapse: function() {
    this.container.classList.remove("mapboxgl-ctrl-geocoder--collapsed", "maplibregl-ctrl-geocoder--collapsed");
  },
  /**
   * Set & query the input
   * @param {string} searchInput location name or other search input
   * @returns {MaplibreGeocoder} this
   */
  query: function(n) {
    return this._geocode(n).then(this._onQueryResult), this;
  },
  _renderError: function() {
    var n = "<div class='mapbox-gl-geocoder--error maplibre-gl-geocoder--error'>There was an error reaching the server</div>";
    this._renderMessage(n);
  },
  _renderNoResults: function() {
    var n = "<div class='mapbox-gl-geocoder--error mapbox-gl-geocoder--no-results maplibre-gl-geocoder--error maplibre-gl-geocoder--no-results'>No results found</div>";
    this._renderMessage(n);
  },
  _renderMessage: function(n) {
    this._typeahead.update([]), this._typeahead.selected = null, this._typeahead.clear(), this._typeahead.renderError(n);
  },
  /**
   * Get the text to use as the search bar placeholder
   *
   * If placeholder is provided in options, then use options.placeholder
   * Otherwise, if language is provided in options, then use the localized string of the first language if available
   * Otherwise use the default
   *
   * @returns {String} the value to use as the search bar placeholder
   * @private
   */
  _getPlaceholderText: function() {
    if (this.options.placeholder)
      return this.options.placeholder;
    if (this.options.language) {
      var n = this.options.language.split(",")[0], e = vq.language(n), t = yq.placeholder[e];
      if (t)
        return t;
    }
    return "Search";
  },
  /**
   * Fits the map to the current bounds for the searched results
   *
   * @returns {MaplibreGeocoder} this
   * @private
   */
  _fitBoundsForMarkers: function() {
    if (!(this._typeahead.data.length < 1)) {
      var n = this._typeahead.data.filter(function(r) {
        return typeof r != "string";
      }).slice(0, this.options.limit);
      if (this._clearEl.style.display = "none", this.options.flyTo && this._maplibregl && this._map) {
        var e = {
          padding: 100
        }, t = ua({}, e, this.options.flyTo), i = new this._maplibregl.LngLatBounds();
        n.forEach(function(r) {
          i.extend(r.geometry.coordinates);
        }), this._map.fitBounds(i.toArray(), t);
      }
      return n.length > 0 && this._maplibregl && this._handleResultMarkers(n), this;
    }
  },
  /**
   * Set input
   * @param {string} searchInput location name or other search input
   * @returns {MaplibreGeocoder} this
   */
  setInput: function(n) {
    return this._inputEl.value = n, this._typeahead.selected = null, this._typeahead.clear(), n.length >= this.options.minLength && this.options.showResultsWhileTyping && this._geocode(n), this;
  },
  /**
   * Set proximity
   * @param {Object} proximity The new `options.proximity` value. This is a geographical point given as an object with `latitude` and `longitude` properties.
   * @returns {MaplibreGeocoder} this
   */
  setProximity: function(n) {
    return this.options.proximity = n, this;
  },
  /**
   * Get proximity
   * @returns {Object} The geocoder proximity
   */
  getProximity: function() {
    return this.options.proximity;
  },
  /**
   * Set the render function used in the results dropdown
   * @param {Function} fn The function to use as a render function. This function accepts a single [Carmen GeoJSON](https://github.com/mapbox/carmen/blob/master/carmen-geojson.md) object as input and returns a string.
   * @returns {MaplibreGeocoder} this
   */
  setRenderFunction: function(n) {
    return n && typeof n == "function" && (this._typeahead.render = n), this;
  },
  /**
   * Get the function used to render the results dropdown
   *
   * @returns {Function} the render function
   */
  getRenderFunction: function() {
    return this._typeahead.render;
  },
  /**
   * Get the language to use in UI elements and when making search requests
   *
   * Look first at the explicitly set options otherwise use the browser's language settings
   * @param {String} language Specify the language to use for response text and query result weighting. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and optionally one or more IETF subtags for country or script. More than one value can also be specified, separated by commas.
   * @returns {MaplibreGeocoder} this
   */
  setLanguage: function(n) {
    var e = navigator.language || navigator.userLanguage || navigator.browserLanguage;
    return this.options.language = n || this.options.language || e, this;
  },
  /**
   * Get the language to use in UI elements and when making search requests
   * @returns {String} The language(s) used by the plugin, if any
   */
  getLanguage: function() {
    return this.options.language;
  },
  /**
   * Get the zoom level the map will move to when there is no bounding box on the selected result
   * @returns {Number} the map zoom
   */
  getZoom: function() {
    return this.options.zoom;
  },
  /**
   * Set the zoom level
   * @param {Number} zoom The zoom level that the map should animate to when a `bbox` isn't found in the response. If a `bbox` is found the map will fit to the `bbox`.
   * @returns {MaplibreGeocoder} this
   */
  setZoom: function(n) {
    return this.options.zoom = n, this;
  },
  /**
   * Get the parameters used to fly to the selected response, if any
   * @returns {Boolean|Object} The `flyTo` option
   */
  getFlyTo: function() {
    return this.options.flyTo;
  },
  /**
   * Set the flyTo options
   * @param {Boolean|Object} flyTo If false, animating the map to a selected result is disabled. If true, animating the map will use the default animation parameters. If an object, it will be passed as `options` to the map [`flyTo`](https://maplibre.org/maplibre-gl-js-docs/api/map/#map#flyto) or [`fitBounds`](https://maplibre.org/maplibre-gl-js-docs/api/map/#map#fitbounds) method providing control over the animation of the transition.
   */
  setFlyTo: function(n) {
    return this.options.flyTo = n, this;
  },
  /**
   * Get the value of the placeholder string
   * @returns {String} The input element's placeholder value
   */
  getPlaceholder: function() {
    return this.options.placeholder;
  },
  /**
   * Set the value of the input element's placeholder
   * @param {String} placeholder the text to use as the input element's placeholder
   * @returns {MaplibreGeocoder} this
   */
  setPlaceholder: function(n) {
    return this.placeholder = n || this._getPlaceholderText(), this._inputEl.placeholder = this.placeholder, this._inputEl.setAttribute("aria-label", this.placeholder), this;
  },
  /**
   * Get the bounding box used by the plugin
   * @returns {Array<Number>} the bounding box, if any
   */
  getBbox: function() {
    return this.options.bbox;
  },
  /**
   * Set the bounding box to limit search results to
   * @param {Array<Number>} bbox a bounding box given as an array in the format [minX, minY, maxX, maxY].
   * @returns {MaplibreGeocoder} this
   */
  setBbox: function(n) {
    return this.options.bbox = n, this;
  },
  /**
   * Get a list of the countries to limit search results to
   * @returns {String} a comma separated list of countries to limit to, if any
   */
  getCountries: function() {
    return this.options.countries;
  },
  /**
   * Set the countries to limit search results to
   * @param {String} countries a comma separated list of countries to limit to
   * @returns {MaplibreGeocoder} this
   */
  setCountries: function(n) {
    return this.options.countries = n, this;
  },
  /**
   * Get a list of the types to limit search results to
   * @returns {String} a comma separated list of types to limit to
   */
  getTypes: function() {
    return this.options.types;
  },
  /**
   * Set the types to limit search results to
   * @param {String} countries a comma separated list of types to limit to
   * @returns {MaplibreGeocoder} this
   */
  setTypes: function(n) {
    return this.options.types = n, this;
  },
  /**
   * Get the minimum number of characters typed to trigger results used in the plugin
   * @returns {Number} The minimum length in characters before a search is triggered
   */
  getMinLength: function() {
    return this.options.minLength;
  },
  /**
   * Set the minimum number of characters typed to trigger results used by the plugin
   * @param {Number} minLength the minimum length in characters
   * @returns {MaplibreGeocoder} this
   */
  setMinLength: function(n) {
    return this.options.minLength = n, this._typeahead && (this._typeahead.options.minLength = n), this;
  },
  /**
   * Get the limit value for the number of results to display used by the plugin
   * @returns {Number} The limit value for the number of results to display used by the plugin
   */
  getLimit: function() {
    return this.options.limit;
  },
  /**
   * Set the limit value for the number of results to display used by the plugin
   * @param {Number} limit the number of search results to return
   * @returns {MaplibreGeocoder}
   */
  setLimit: function(n) {
    return this.options.limit = n, this._typeahead && (this._typeahead.options.limit = n), this;
  },
  /**
   * Get the filter function used by the plugin
   * @returns {Function} the filter function
   */
  getFilter: function() {
    return this.options.filter;
  },
  /**
   * Set the filter function used by the plugin.
   * @param {Function} filter A function which accepts a Feature in the [Carmen GeoJSON](https://github.com/mapbox/carmen/blob/master/carmen-geojson.md) format to filter out results from the Geocoding API response before they are included in the suggestions list. Return `true` to keep the item, `false` otherwise.
   * @returns {MaplibreGeocoder} this
   */
  setFilter: function(n) {
    return this.options.filter = n, this;
  },
  /**
   * Set the geocoding api used by the plugin.
   * @param {Object} geocoderApi An API which contains reverseGeocode and forwardGeocode functions to be used by this plugin
   * @param {Function} geocoderApi.forwardGeocode Forward geocode function should return an object including a collection of Features in [Carmen GeoJSON](https://github.com/mapbox/carmen/blob/master/carmen-geojson.md) format
   * @param {Object} geocoderApi.forwardGeocode.config Query parameters
   * @param {String} geocoderApi.forwardGeocode.config.query Search query string
   * @param {Number} geocoderApi.forwardGeocode.config.limit Number of results to limit by
   * @param {Array} geocoderApi.forwardGeocode.config.bbox a bounding box given as an array in the format `[minX, minY, maxX, maxY]`. Search results will be limited to the bounding box.
   * @param {Object} geocoderApi.forwardGeocode.config.proximity a geographical point given as an object with `latitude` and `longitude` properties. Search results closer to this point will be given higher priority.
   * @param {Array} geocoderApi.forwardGeocode.config.countries a comma separated list of country codes to limit results to specified country or countries.
   * @param {Array} geocoderApi.forwardGeocode.config.types a comma seperated list of types that filter results to match those specified. See https://docs.mapbox.com/api/search/#data-types for available types. If reverseGeocode is enabled, you should specify one type. If you configure more than one type, the first type will be used.
   * @param {String} geocoderApi.forwardGeocode.config.language Specify the language to use for response text and query result weighting. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and optionally one or more IETF subtags for country or script. More than one value can also be specified, separated by commas. Defaults to the browser's language settings.
   * @param {distance|score} geocoderApi.forwardGeocode.config.reverseMode Set the factors that are used to sort nearby results.
   *
   * @param {Function} geocoderApi.reverseGeocode Reverse geocode function should return an object including a collection of Features in [Carmen GeoJSON](https://github.com/mapbox/carmen/blob/master/carmen-geojson.md) format
   * @param {Object} geocoderApi.reverseGeocode.config Query parameters
   * @param {Object} geocoderApi.reverseGeocode.config.query Search query coordinates
   * @param {Number} geocoderApi.reverseGeocode.config.limit Number of results to limit by
   * @param {Array} geocoderApi.reverseGeocode.config.bbox a bounding box given as an array in the format `[minX, minY, maxX, maxY]`. Search results will be limited to the bounding box.
   * @param {Object} geocoderApi.reverseGeocode.config.proximity a geographical point given as an object with `latitude` and `longitude` properties. Search results closer to this point will be given higher priority.
   * @param {Array} geocoderApi.reverseGeocode.config.countries a comma separated list of country codes to limit results to specified country or countries.
   * @param {Array} geocoderApi.reverseGeocode.config.types a comma seperated list of types that filter results to match those specified. See https://docs.mapbox.com/api/search/#data-types for available types. If reverseGeocode is enabled, you should specify one type. If you configure more than one type, the first type will be used.
   * @param {String} geocoderApi.reverseGeocode.config.language Specify the language to use for response text and query result weighting. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and optionally one or more IETF subtags for country or script. More than one value can also be specified, separated by commas. Defaults to the browser's language settings.
   * @param {distance|score} geocoderApi.reverseGeocode.config.reverseMode Set the factors that are used to sort nearby results.
   * @returns {MaplibreGeocoder} this
   */
  setGeocoderApi: function(n) {
    return this.geocoderApi = n, this;
  },
  /**
   * Get the geocoding endpoint the plugin is currently set to
   * @returns {Object} the geocoding API
   */
  getGeocoderApi: function() {
    return this.geocoderApi;
  },
  /**
   * Handle the placement of a result marking the selected result
   * @private
   * @param {Object} selected the selected geojson feature
   * @returns {MaplibreGeocoder} this
   */
  _handleMarker: function(n) {
    if (this._map) {
      this._removeMarker();
      var e = {
        color: "#4668F2"
      }, t = ua({}, e, this.options.marker);
      this.mapMarker = new this._maplibregl.Marker(t);
      var i;
      if (this.options.popup) {
        var r = {}, s = ua({}, r, this.options.popup);
        i = new this._maplibregl.Popup(s).setHTML(this.options.popupRender(n));
      }
      return n.center ? (this.mapMarker.setLngLat(n.center).addTo(this._map), this.options.popup && this.mapMarker.setPopup(i)) : n.geometry && n.geometry.type && n.geometry.type === "Point" && n.geometry.coordinates && (this.mapMarker.setLngLat(n.geometry.coordinates).addTo(this._map), this.options.popup && this.mapMarker.setPopup(i)), this;
    }
  },
  /**
   * Handle the removal of a result marker
   * @private
   */
  _removeMarker: function() {
    this.mapMarker && (this.mapMarker.remove(), this.mapMarker = null);
  },
  /**
   * Handle the placement of a result marking the selected result
   * @private
   * @param {Object[]} results the top results to display on the map
   * @returns {MaplibreGeocoder} this
   */
  _handleResultMarkers: function(n) {
    if (this._map) {
      this._removeResultMarkers();
      var e = {
        color: "#4668F2"
      }, t = ua({}, e, this.options.showResultMarkers);
      return n.forEach((function(i) {
        if (this.options.showResultMarkers && this.options.showResultMarkers.element) {
          var r = this.options.showResultMarkers.element.cloneNode(!0);
          t = ua(t, {
            element: r
          });
        }
        var s = new this._maplibregl.Marker(ua({}, t, {
          element: r
        })), c;
        if (this.options.popup) {
          var l = {}, m = ua({}, l, this.options.popup);
          c = new this._maplibregl.Popup(m).setHTML(this.options.popupRender(i));
        }
        i.center ? (s.setLngLat(i.center).addTo(this._map), this.options.popup && s.setPopup(c)) : i.geometry && i.geometry.type && i.geometry.type === "Point" && i.geometry.coordinates && (s.setLngLat(i.geometry.coordinates).addTo(this._map), this.options.popup && s.setPopup(c)), this.resultMarkers.push(s);
      }).bind(this)), this;
    }
  },
  /**
   * Handle the removal of a result marker
   * @private
   */
  _removeResultMarkers: function() {
    this.resultMarkers && this.resultMarkers.length > 0 && (this.resultMarkers.forEach(function(n) {
      n.remove();
    }), this.resultMarkers = []);
  },
  /**
   * Subscribe to events that happen within the plugin.
   * @param {String} type name of event. Available events and the data passed into their respective event objects are:
   *
   * - __clear__ `Emitted when the input is cleared`
   * - __loading__ `{ query } Emitted when the geocoder is looking up a query`
   * - __results__ `{ results } Fired when the geocoder returns a response`
   * - __result__ `{ result } Fired when input is set`
   * - __error__ `{ error } Error as string`
   * @param {Function} fn function that's called when the event is emitted.
   * @returns {MaplibreGeocoder} this;
   */
  on: function(n, e) {
    return this._eventEmitter.on(n, e), this;
  },
  /**
   * Remove an event
   * @returns {MaplibreGeocoder} this
   * @param {String} type Event name.
   * @param {Function} fn Function that should unsubscribe to the event emitted.
   */
  off: function(n, e) {
    return this._eventEmitter.removeListener(n, e), this;
  }
};
var bq = UT;
const xq = /* @__PURE__ */ Ap(bq), wq = {
  limitsUrl: "https://tilemaps.icgc.cat/vt/limits-tilejsonV3.json",
  geocoder: {
    peliasUrl1: "https://eines.icgc.cat/geocodificador/autocompletar?text=",
    peliasUrl2: "&layers=topo1%2Ctopo2%2Caddress&size=5"
  },
  mapOptions: {
    container: "map",
    center: {
      0: 1.537786,
      1: 41.837539
    },
    zoom: 7.5,
    bearing: 0,
    pitch: 0,
    hash: !1,
    style: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_gris.json.json",
    maxZoom: 18,
    maxPitch: 85
  },
  logoIcgcOptions: {
    logoUrlColor: "https://tilemaps.icgc.cat/cdn/logos/icgc_logo_color.png",
    logoUrlWhite: "https://tilemaps.icgc.cat/cdn/logos/icgc_logo_blanc.svg",
    logoLink: "https://www.icgc.cat",
    logoTitle: "Institut Cartogrfic i Geolgic de Catalunya",
    logoWidth: 100
  },
  logoGencatOptions: {
    logoUrlColor: "https://tilemaps.icgc.cat/cdn/logos/gencat_logo_color.png",
    logoUrlWhite: "https://tilemaps.icgc.cat/cdn/logos/gencat_logo_blanc.png",
    logoLink: "https://web.gencat.cat/",
    logoTitle: "Generalitat de Catalunya",
    logoWidth: 100
  },
  map3dOptions: {
    spaceErrorFactor: 2,
    exaggeration: 1,
    zfactor: 48,
    minZoomRange: 15.5,
    maxZoomRange: 22,
    urlTilesetCities: "https://tilemaps.icgc.cat/vector/3dtiles/ciutats/v1/tilesetV1.0.json",
    layerIdOrder: "place-isolated",
    sourceLayerFilterId: "place",
    minZoomFilter: 14,
    layerId3d: "edificisMapboxLayer",
    terrainSource: "ICGC5M",
    style3dName: "orto3d",
    imageIcon: "https://tilemaps.icgc.cat/cdn/images/stick.png"
  },
  baseStyles: [
    {
      key: "TOPO",
      url: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_topografic.json",
      image: "https://visors.icgc.cat/contextmaps/imatges_estil/icgc_mapa_estandard.png"
    },
    {
      key: "ORTO",
      url: "https://geoserveis.icgc.cat/styles/icgc_orto_estandard.json",
      image: "https://visors.icgc.cat/contextmaps/imatges_estil/icgc_orto_estandard.png"
    },
    {
      key: "ORTO3D",
      url: "https://tilemaps.icgc.cat/cdn/styles/icgc_orto_3d.json",
      image: "https://visors.icgc.cat/contextmaps/imatges_estil/icgc_orto_estandard.png"
    },
    {
      key: "ORTOHYBRID",
      url: "https://geoserveis.icgc.cat/styles/icgc_orto_hibrida.json",
      image: "https://visors.icgc.cat/contextmaps/imatges_estil/icgc_orto_hibrida.png"
    },
    {
      key: "ADMIN",
      url: "https://geoserveis.icgc.cat/styles/icgc_limits_administratius_gris.json",
      image: "https://visors.icgc.cat/contextmaps/imatges_estil/icgc_delimitacio_limits_administratius.png"
    },
    {
      key: "DARK",
      url: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_fosc.json",
      image: "https://visors.icgc.cat/contextmaps/imatges_estil/icgc_mapa_base_fosc.png"
    },
    {
      key: "LIGHT",
      url: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_gris.json",
      image: "https://visors.icgc.cat/contextmaps/imatges_estil/icgc_mapa_base_gris.png"
    },
    {
      key: "GEOLOGY",
      url: "https://geoserveis.icgc.cat/styles/icgc_geologic_informacio.json",
      image: "https://visors.icgc.cat/contextmaps/imatges_estil/icgc_geologic_informacio.png"
    }
  ],
  urlTerrainICGC: [
    {
      name: "ICGC5M",
      url: "https://tilemaps.icgc.cat/tileserver/tileserver/terreny-5m-30m-rgb-extent/{z}/{x}/{y}.png"
    },
    {
      name: "WORLD30M",
      url: "https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png",
      encoding: "terrarium"
    }
  ],
  ortoLayersICGC: [
    {
      name: "ortofotoColorProvisional",
      key: "ortofoto_color_provisional",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_provisional"
    },
    {
      name: "ortofotoColor2023",
      key: "ortofoto_color_2023",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2023"
    },
    {
      name: "ortofotoColor2022",
      key: "ortofoto_color_2022",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2022"
    },
    {
      name: "ortofotoColor2021",
      key: "ortofoto_color_2021",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2021"
    },
    {
      name: "ortofotoColor2020",
      key: "ortofoto_color_2020",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2020"
    },
    {
      name: "ortofotoColor2019",
      key: "ortofoto_color_2019",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2019"
    },
    {
      name: "ortofotoColor2018",
      key: "ortofoto_color_2018",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2018"
    },
    {
      name: "ortofotoColor2017",
      key: "ortofoto_color_2017",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2017"
    },
    {
      name: "ortofotoColor2016",
      key: "ortofoto_color_2016",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2016"
    },
    {
      name: "ortofotoColor2015",
      key: "ortofoto_color_2015",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2015"
    },
    {
      name: "ortofotoColor2014",
      key: "ortofoto_color_2014",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2014"
    },
    {
      name: "ortofotoColor2013",
      key: "ortofoto_color_2013",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2013"
    },
    {
      name: "ortofotoColor2012",
      key: "ortofoto_color_2012",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2012"
    },
    {
      name: "ortofotoColor2011",
      key: "ortofoto_color_2011",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2011"
    },
    {
      name: "ortofotoColor2010",
      key: "ortofoto_color_2010",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2010"
    },
    {
      name: "ortofotoColor2009",
      key: "ortofoto_color_2009",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2009"
    },
    {
      name: "ortofotoColor2008",
      key: "ortofoto_color_2008",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2008"
    },
    {
      name: "ortofotoColor20062007",
      key: "ortofoto_color_2006-2007",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2006-2007"
    },
    {
      name: "ortofotoColor20042005",
      key: "ortofoto_color_2004-2005",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2004-2005"
    },
    {
      name: "ortofotoColor20002003",
      key: "ortofoto_color_2000-2003",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2000-2003"
    },
    {
      name: "ortofotoBlancINegre1998",
      key: "ortofoto_blanc_i_negre_1998",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1998"
    },
    {
      name: "ortofotoBlancINegre19941997",
      key: "ortofoto_blanc_i_negre_1994-1997",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1994-1997"
    },
    {
      name: "ortofotoColor1993",
      key: "ortofoto_color_1993",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_1993"
    },
    {
      name: "ortofotoBlancINegre19831992",
      key: "ortofoto_blanc_i_negre_1983-1992",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1983-1992"
    },
    {
      name: "ortofotoBlancINegre19701977",
      key: "ortofoto_blanc_i_negre_1970-1977",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1970-1977"
    },
    {
      name: "ortofotoBlancINegre1956",
      key: "ortofoto_blanc_i_negre_1956",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1956"
    },
    {
      name: "ortofotoBlancINegre1945",
      key: "ortofoto_blanc_i_negre_1945",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1945"
    },
    {
      name: "ortofotoColorSerieAnual",
      key: "ortofoto_color_serie_anual",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_serie_anual"
    },
    {
      name: "ortofotoInfraroigProvisional",
      key: "ortofoto_infraroig_provisional",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_provisional"
    },
    {
      name: "ortofotoInfraroig2023",
      key: "ortofoto_infraroig_2023",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2023"
    },
    {
      name: "ortofotoInfraroig2022",
      key: "ortofoto_infraroig_2022",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2022"
    },
    {
      name: "ortofotoInfraroig2021",
      key: "ortofoto_infraroig_2021",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2021"
    },
    {
      name: "ortofotoInfraroig2020",
      key: "ortofoto_infraroig_2020",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2020"
    },
    {
      name: "ortofotoInfraroig2019",
      key: "ortofoto_infraroig_2019",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2019"
    },
    {
      name: "ortofotoInfraroig2018",
      key: "ortofoto_infraroig_2018",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2018"
    },
    {
      name: "ortofotoInfraroig2017",
      key: "ortofoto_infraroig_2017",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2017"
    },
    {
      name: "ortofotoInfraroig2016",
      key: "ortofoto_infraroig_2016",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2016"
    },
    {
      name: "ortofotoInfraroig2015",
      key: "ortofoto_infraroig_2015",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2015"
    },
    {
      name: "ortofotoInfraroig2014",
      key: "ortofoto_infraroig_2014",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2014"
    },
    {
      name: "ortofotoInfraroig2013",
      key: "ortofoto_infraroig_2013",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2013"
    },
    {
      name: "ortofotoInfraroig2012",
      key: "ortofoto_infraroig_2012",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2012"
    },
    {
      name: "ortofotoInfraroig2011",
      key: "ortofoto_infraroig_2011",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2011"
    },
    {
      name: "ortofotoInfraroig2010",
      key: "ortofoto_infraroig_2010",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2010"
    },
    {
      name: "ortofotoInfraroig2009",
      key: "ortofoto_infraroig_2009",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2009"
    },
    {
      name: "ortofotoInfraroig2008",
      key: "ortofoto_infraroig_2008",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2008"
    },
    {
      name: "ortofotoInfraroig20062007",
      key: "ortofoto_infraroig_2006-2007",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2006-2007"
    },
    {
      name: "ortofotoInfraroig19961997",
      key: "ortofoto_infraroig_1996-1997",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_1996-1997"
    },
    {
      name: "ortofotoInfraroigSerieAnual",
      key: "ortofoto_infraroig_serie_anual",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_serie_anual"
    }
  ],
  vectorLayersICGC: [
    {
      name: "agrupacionsCensals2015",
      key: "agrupacions_censals_2015"
    },
    {
      name: "agrupacionsCensals2016",
      key: "agrupacions_censals_2016"
    },
    {
      name: "agrupacionsCensals2017",
      key: "agrupacions_censals_2017"
    },
    {
      name: "agrupacionsCensals2018",
      key: "agrupacions_censals_2018"
    },
    {
      name: "agrupacionsCensals2019",
      key: "agrupacions_censals_2019"
    },
    {
      name: "agrupacionsCensals2020",
      key: "agrupacions_censals_2020"
    },
    {
      name: "agrupacionsCensals2021",
      key: "agrupacions_censals_2021"
    },
    {
      name: "agrupacionsCensalsVigent",
      key: "agrupacions_censals_vigent"
    },
    {
      name: "agrupacionsCensalsVigentText",
      key: "agrupacions_censals_vigent_text"
    },
    {
      name: "areesBasiquesPolicials2019",
      key: "arees_basiques_policials_2019"
    },
    {
      name: "areesBasiquesPolicials2020",
      key: "arees_basiques_policials_2020"
    },
    {
      name: "areesBasiquesPolicials2022",
      key: "arees_basiques_policials_2022"
    },
    {
      name: "areesBasiquesPolicialsVigent",
      key: "arees_basiques_policials_vigent"
    },
    {
      name: "areesBasiquesPolicialsVigentText",
      key: "arees_basiques_policials_vigent_text"
    },
    {
      name: "areesBasiquesSalutVigent",
      key: "arees_basiques_salut_vigent"
    },
    {
      name: "areesBasiquesServeisSocialsVigent",
      key: "arees_basiques_serveis_socials_vigent"
    },
    {
      name: "areesBasiquesServeisSocialsVigentText",
      key: "arees_basiques_serveis_socials_vigent_text"
    },
    {
      name: "areesGestioAssistencialVigent",
      key: "arees_gestio_assistencial_vigent"
    },
    {
      name: "areesHidrogeologiquesAquifersVigent",
      key: "arees_hidrogeologiques_aquifers_vigent"
    },
    {
      name: "catalunyaVigent",
      key: "catalunya_vigent"
    },
    {
      name: "catalunyaVigentText",
      key: "catalunya_vigent_text"
    },
    {
      name: "comarques2022",
      key: "comarques_2022"
    },
    {
      name: "comarquesVigent",
      key: "comarques_vigent"
    },
    {
      name: "comarquesVigentText",
      key: "comarques_vigent_text"
    },
    {
      name: "districtesCensals2015",
      key: "districtes_censals_2015"
    },
    {
      name: "districtesCensals2016",
      key: "districtes_censals_2016"
    },
    {
      name: "districtesCensals2017",
      key: "districtes_censals_2017"
    },
    {
      name: "districtesCensals2018",
      key: "districtes_censals_2018"
    },
    {
      name: "districtesCensals2019",
      key: "districtes_censals_2019"
    },
    {
      name: "districtesCensals2020",
      key: "districtes_censals_2020"
    },
    {
      name: "districtesCensals2021",
      key: "districtes_censals_2021"
    },
    {
      name: "districtesCensals2022",
      key: "districtes_censals_2022"
    },
    {
      name: "districtesCensals2023",
      key: "districtes_censals_2023"
    },
    {
      name: "districtesCensalsVigent",
      key: "districtes_censals_vigent"
    },
    {
      name: "districtesCensalsVigentText",
      key: "districtes_censals_vigent_text"
    },
    {
      name: "incendisForestalsVigent",
      key: "incendis_forestals_vigent"
    },
    {
      name: "incendisForestalsVigentText",
      key: "incendis_forestals_vigent_text"
    },
    {
      name: "municipis2022",
      key: "municipis_2022"
    },
    {
      name: "municipis2022Text",
      key: "municipis_2022_text"
    },
    {
      name: "municipisVigent",
      key: "municipis_vigent"
    },
    {
      name: "municipisVigentText",
      key: "municipis_vigent_text"
    },
    {
      name: "partitsJudicialsVigent",
      key: "partits_judicials_vigent"
    },
    {
      name: "partitsJudicialsVigentText",
      key: "partits_judicials_vigent_text"
    },
    {
      name: "plaTerritorial2015",
      key: "pla_territorial_2015"
    },
    {
      name: "plaTerritorialVigent",
      key: "pla_territorial_vigent"
    },
    {
      name: "plaTerritorialVigentText",
      key: "pla_territorial_vigent_text"
    },
    {
      name: "provinciesVigent",
      key: "provincies_vigent"
    },
    {
      name: "provinciesVigentText",
      key: "provincies_vigent_text"
    },
    {
      name: "regionsPolicialsVigent",
      key: "regions_policials_vigent"
    },
    {
      name: "regionsPolicialsVigentText",
      key: "regions_policials_vigent_text"
    },
    {
      name: "regionsSanitariesVigent",
      key: "regions_sanitaries_vigent"
    },
    {
      name: "regionsSanitariesVigentText",
      key: "regions_sanitaries_vigent_text"
    },
    {
      name: "seccionsCensals2015",
      key: "seccions_censals_2015"
    },
    {
      name: "seccionsCensals2016",
      key: "seccions_censals_2016"
    },
    {
      name: "seccionsCensals2017",
      key: "seccions_censals_2017"
    },
    {
      name: "seccionsCensals2018",
      key: "seccions_censals_2018"
    },
    {
      name: "seccionsCensals2019",
      key: "seccions_censals_2019"
    },
    {
      name: "seccionsCensals2020",
      key: "seccions_censals_2020"
    },
    {
      name: "seccionsCensals2021",
      key: "seccions_censals_2021"
    },
    {
      name: "seccionsCensals2022",
      key: "seccions_censals_2022"
    },
    {
      name: "seccionsCensals2023",
      key: "seccions_censals_2023"
    },
    {
      name: "seccionsCensalsVigent",
      key: "seccions_censals_vigent"
    },
    {
      name: "seccionsCensalsVigentText",
      key: "seccions_censals_vigent_text"
    },
    {
      name: "sectorsSanitarisVigent",
      key: "sectors_sanitaris_vigent"
    },
    {
      name: "vegueriesVigent",
      key: "vegueries_vigent"
    },
    {
      name: "vegueriesVigentText",
      key: "vegueries_vigent_text"
    }
  ],
  vectorLayers: [
    {
      key: "cobertes2018",
      url: "https://tilemaps.icgc.cat/tileserver/cobertes_tilejson.json",
      legend: "https://tilemaps.icgc.cat/cdn/images/llegendaCobertesSol2018.jpg"
    }
  ],
  wmsLayers: [
    {
      key: "espaisInteresGeologic",
      layer: "",
      url: "https://geoserveis.icgc.cat/servei/catalunya/espais-interes-geologic/wms/service?&service=WMS&request=GetMap&layers=espais-interes-geologic&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}"
    },
    {
      key: "gravimetriaBouguer500000",
      layer: "",
      url: "https://geoserveis.icgc.cat/servei/catalunya/gravimetria/wms/service?&service=WMS&request=GetMap&layers=anomalia_bouguer_500000&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}"
    },
    {
      key: "cobertesSol2018",
      layer: "",
      url: "https://geoserveis.icgc.cat/servei/catalunya/cobertes-sol/wms/service?&service=WMS&request=GetMap&layers=cobertes_2018&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}"
    },
    {
      key: "administratiu",
      layer: "",
      url: "http://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/administratiu/MON3857NW/{z}/{x}/{y}.png"
    },
    {
      key: "simplificat",
      layer: "",
      url: "http://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/simplificat/MON3857NW/{z}/{x}/{y}.png"
    },
    {
      key: "cims",
      layer: "",
      url: "https://geoserveis.icgc.cat/icc_100cims/wms/service?REQUEST=GetMap&SERVICE=WMS&VERSION=1.1.1&LAYERS=0&STYLES=&FORMAT=image/png&BGCOLOR=0xFFFFFF&TRANSPARENT=TRUE&SRS=EPSG:25831&BBOX=137118.923076923,4488408.75,650959.076923077,4749634.75&WIDTH=895&HEIGHT=455"
    },
    {
      key: "cobertesSol",
      layer: "",
      url: "http://geoserveis.icgc.cat/servei/catalunya/cobertes-sol/wms?REQUEST=GetMap&SERVICE=WMS&VERSION=1.3.0&LAYERS=cobertes_2009&STYLES=&FORMAT=image/png&BGCOLOR=0xFFFFFF&TRANSPARENT=TRUE&CRS=EPSG:25831&BBOX=374110.828167253,4639230.79853085,452621.120632226,4703578.45000215&WIDTH=1020&HEIGHT=836"
    }
  ],
  fgbLayers: [
    {
      name: "agrupacionsCensalsVigent",
      key: "agrupacions_censals_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/agrupacions_censals_vigent.fgb"
    },
    {
      name: "agrupacionsCensalsVigentText",
      key: "agrupacions_censals_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/agrupacions_censals_vigent_text.fgb"
    },
    {
      name: "areesBasiquesPolicialsVigent",
      key: "arees_basiques_policials_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_policials_vigent.fgb"
    },
    {
      name: "areesBasiquesPolicialsVigentText",
      key: "arees_basiques_policials_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_policials_vigent_text.fgb"
    },
    {
      name: "areesBasiquesSalutVigent",
      key: "arees_basiques_salut_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_salut_vigent.fgb"
    },
    {
      name: "areesBasiquesServeisSocialsVigent",
      key: "arees_basiques_serveis_socials_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_serveis_socials_vigent.fgb"
    },
    {
      name: "areesBasiquesServeisSocialsVigentText",
      key: "arees_basiques_serveis_socials_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_serveis_socials_vigent_text.fgb"
    },
    {
      name: "areesGestioAssistencialVigent",
      key: "arees_gestio_assistencial_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/arees_gestio_assistencial_vigent.fgb"
    },
    {
      name: "areesHidrogeologiquesAquifersVigent",
      key: "arees_hidrogeologiques_aquifers_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/arees_hidrogeologiques_aquifers_vigent.fgb"
    },
    {
      name: "catalunyaVigent",
      key: "catalunya_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/catalunya_vigent.fgb"
    },
    {
      name: "catalunyaVigentText",
      key: "catalunya_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/catalunya_vigent_text.fgb"
    },
    {
      name: "comarquesVigent",
      key: "comarques_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/comarques_vigent.fgb"
    },
    {
      name: "comarquesVigentText",
      key: "comarques_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/comarques_vigent_text.fgb"
    },
    {
      name: "districtesCensalsVigent",
      key: "districtes_censals_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/districtes_censals_vigent.fgb"
    },
    {
      name: "districtesCensalsVigentText",
      key: "districtes_censals_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/districtes_censals_vigent_text.fgb"
    },
    {
      name: "incendisForestalsVigent",
      key: "incendis_forestals_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/incendis_forestals_vigent.fgb"
    },
    {
      name: "incendisForestalsVigentText",
      key: "incendis_forestals_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/incendis_forestals_vigent_text.fgb"
    },
    {
      name: "municipisVigent",
      key: "municipis_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/municipis_vigent.fgb"
    },
    {
      name: "municipisVigentText",
      key: "municipis_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/municipis_vigent_text.fgb"
    },
    {
      name: "partitsJudicialsVigent",
      key: "partits_judicials_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/partits_judicials_vigent.fgb"
    },
    {
      name: "partitsJudicialsVigentText",
      key: "partits_judicials_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/partits_judicials_vigent_text.fgb"
    },
    {
      name: "plaTerritorialVigent",
      key: "pla_territorial_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/pla_territorial_vigent.fgb"
    },
    {
      name: "plaTerritorialVigentText",
      key: "pla_territorial_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/pla_territorial_vigent_text.fgb"
    },
    {
      name: "provinciesVigent",
      key: "provincies_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/provincies_vigent.fgb"
    },
    {
      name: "provinciesVigentText",
      key: "provincies_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/provincies_vigent_text.fgb"
    },
    {
      name: "regionsPolicialsVigent",
      key: "regions_policials_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/regions_policials_vigent.fgb"
    },
    {
      name: "regionsPolicialsVigentText",
      key: "regions_policials_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/regions_policials_vigent_text.fgb"
    },
    {
      name: "regionsSanitariesVigent",
      key: "regions_sanitaries_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/regions_sanitaries_vigent.fgb"
    },
    {
      name: "regionsSanitariesVigentText",
      key: "regions_sanitaries_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/regions_sanitaries_vigent_text.fgb"
    },
    {
      name: "seccionsCensalsVigent",
      key: "seccions_censals_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/seccions_censals_vigent.fgb"
    },
    {
      name: "seccionsCensalsVigentText",
      key: "seccions_censals_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/seccions_censals_vigent_text.fgb"
    },
    {
      name: "sectorsSanitarisVigent",
      key: "sectors_sanitaris_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/sectors_sanitaris_vigent.fgb"
    },
    {
      name: "vegueriesVigent",
      key: "vegueries_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/vegueries_vigent.fgb"
    },
    {
      name: "vegueriesVigentText",
      key: "vegueries_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/vegueries_vigent_text.fgb"
    }
  ]
}, Aq = {
  TOPO: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_topografic.json",
  ORTO: "https://geoserveis.icgc.cat/styles/icgc_orto_estandard.json",
  ORTO3D: "https://tilemaps.icgc.cat/cdn/styles/icgc_orto_3d.json",
  ORTOHYBRID: "https://geoserveis.icgc.cat/styles/icgc_orto_hibrida.json",
  ADMIN: "https://geoserveis.icgc.cat/styles/icgc_limits_administratius_gris.json",
  DARK: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_fosc.json",
  LIGHT: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_gris.json",
  GEOLOGY: "https://geoserveis.icgc.cat/styles/icgc_geologic_informacio.json"
}, Eq = {
  ICGC5M: "https://tilemaps.icgc.cat/tileserver/tileserver/terreny-5m-30m-rgb-extent/{z}/{x}/{y}.png",
  WORLD30M: "https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png"
}, Sq = {
  Orto: {
    ortofotoColorProvisional: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_provisional",
    ortofotoColor2023: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2023",
    ortofotoColor2022: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2022",
    ortofotoColor2021: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2021",
    ortofotoColor2020: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2020",
    ortofotoColor2019: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2019",
    ortofotoColor2018: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2018",
    ortofotoColor2017: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2017",
    ortofotoColor2016: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2016",
    ortofotoColor2015: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2015",
    ortofotoColor2014: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2014",
    ortofotoColor2013: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2013",
    ortofotoColor2012: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2012",
    ortofotoColor2011: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2011",
    ortofotoColor2010: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2010",
    ortofotoColor2009: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2009",
    ortofotoColor2008: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2008",
    ortofotoColor20062007: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2006-2007",
    ortofotoColor20042005: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2004-2005",
    ortofotoColor20002003: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2000-2003",
    ortofotoBlancINegre1998: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1998",
    ortofotoBlancINegre19941997: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1994-1997",
    ortofotoColor1993: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_1993",
    ortofotoBlancINegre19831992: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1983-1992",
    ortofotoBlancINegre19701977: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1970-1977",
    ortofotoBlancINegre1956: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1956",
    ortofotoBlancINegre1945: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1945",
    ortofotoColorSerieAnual: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_serie_anual",
    ortofotoInfraroigProvisional: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_provisional",
    ortofotoInfraroig2023: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2023",
    ortofotoInfraroig2022: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2022",
    ortofotoInfraroig2021: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2021",
    ortofotoInfraroig2020: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2020",
    ortofotoInfraroig2019: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2019",
    ortofotoInfraroig2018: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2018",
    ortofotoInfraroig2017: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2017",
    ortofotoInfraroig2016: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2016",
    ortofotoInfraroig2015: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2015",
    ortofotoInfraroig2014: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2014",
    ortofotoInfraroig2013: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2013",
    ortofotoInfraroig2012: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2012",
    ortofotoInfraroig2011: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2011",
    ortofotoInfraroig2010: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2010",
    ortofotoInfraroig2009: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2009",
    ortofotoInfraroig2008: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2008",
    ortofotoInfraroig20062007: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2006-2007",
    ortofotoInfraroig19961997: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_1996-1997",
    ortofotoInfraroigSerieAnual: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_serie_anual"
  },
  VectorAdmin: {
    agrupacionsCensals2015: "agrupacions_censals_2015",
    agrupacionsCensals2016: "agrupacions_censals_2016",
    agrupacionsCensals2017: "agrupacions_censals_2017",
    agrupacionsCensals2018: "agrupacions_censals_2018",
    agrupacionsCensals2019: "agrupacions_censals_2019",
    agrupacionsCensals2020: "agrupacions_censals_2020",
    agrupacionsCensals2021: "agrupacions_censals_2021",
    agrupacionsCensalsVigent: "agrupacions_censals_vigent",
    agrupacionsCensalsVigentText: "agrupacions_censals_vigent_text",
    areesBasiquesPolicials2019: "arees_basiques_policials_2019",
    areesBasiquesPolicials2020: "arees_basiques_policials_2020",
    areesBasiquesPolicials2022: "arees_basiques_policials_2022",
    areesBasiquesPolicialsVigent: "arees_basiques_policials_vigent",
    areesBasiquesPolicialsVigentText: "arees_basiques_policials_vigent_text",
    areesBasiquesSalutVigent: "arees_basiques_salut_vigent",
    areesBasiquesServeisSocialsVigent: "arees_basiques_serveis_socials_vigent",
    areesBasiquesServeisSocialsVigentText: "arees_basiques_serveis_socials_vigent_text",
    areesGestioAssistencialVigent: "arees_gestio_assistencial_vigent",
    areesHidrogeologiquesAquifersVigent: "arees_hidrogeologiques_aquifers_vigent",
    catalunyaVigent: "catalunya_vigent",
    catalunyaVigentText: "catalunya_vigent_text",
    comarques2022: "comarques_2022",
    comarquesVigent: "comarques_vigent",
    comarquesVigentText: "comarques_vigent_text",
    districtesCensals2015: "districtes_censals_2015",
    districtesCensals2016: "districtes_censals_2016",
    districtesCensals2017: "districtes_censals_2017",
    districtesCensals2018: "districtes_censals_2018",
    districtesCensals2019: "districtes_censals_2019",
    districtesCensals2020: "districtes_censals_2020",
    districtesCensals2021: "districtes_censals_2021",
    districtesCensals2022: "districtes_censals_2022",
    districtesCensals2023: "districtes_censals_2023",
    districtesCensalsVigent: "districtes_censals_vigent",
    districtesCensalsVigentText: "districtes_censals_vigent_text",
    incendisForestalsVigent: "incendis_forestals_vigent",
    incendisForestalsVigentText: "incendis_forestals_vigent_text",
    municipis2022: "municipis_2022",
    municipis2022Text: "municipis_2022_text",
    municipisVigent: "municipis_vigent",
    municipisVigentText: "municipis_vigent_text",
    partitsJudicialsVigent: "partits_judicials_vigent",
    partitsJudicialsVigentText: "partits_judicials_vigent_text",
    plaTerritorial2015: "pla_territorial_2015",
    plaTerritorialVigent: "pla_territorial_vigent",
    plaTerritorialVigentText: "pla_territorial_vigent_text",
    provinciesVigent: "provincies_vigent",
    provinciesVigentText: "provincies_vigent_text",
    regionsPolicialsVigent: "regions_policials_vigent",
    regionsPolicialsVigentText: "regions_policials_vigent_text",
    regionsSanitariesVigent: "regions_sanitaries_vigent",
    regionsSanitariesVigentText: "regions_sanitaries_vigent_text",
    seccionsCensals2015: "seccions_censals_2015",
    seccionsCensals2016: "seccions_censals_2016",
    seccionsCensals2017: "seccions_censals_2017",
    seccionsCensals2018: "seccions_censals_2018",
    seccionsCensals2019: "seccions_censals_2019",
    seccionsCensals2020: "seccions_censals_2020",
    seccionsCensals2021: "seccions_censals_2021",
    seccionsCensals2022: "seccions_censals_2022",
    seccionsCensals2023: "seccions_censals_2023",
    seccionsCensalsVigent: "seccions_censals_vigent",
    seccionsCensalsVigentText: "seccions_censals_vigent_text",
    sectorsSanitarisVigent: "sectors_sanitaris_vigent",
    vegueriesVigent: "vegueries_vigent",
    vegueriesVigentText: "vegueries_vigent_text"
  },
  FGBAdmin: {
    agrupacionsCensalsVigent: "https://tilemaps.icgc.cat/vector/fgb/agrupacions_censals_vigent.fgb",
    agrupacionsCensalsVigentText: "https://tilemaps.icgc.cat/vector/fgb/agrupacions_censals_vigent_text.fgb",
    areesBasiquesPolicialsVigent: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_policials_vigent.fgb",
    areesBasiquesPolicialsVigentText: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_policials_vigent_text.fgb",
    areesBasiquesSalutVigent: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_salut_vigent.fgb",
    areesBasiquesServeisSocialsVigent: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_serveis_socials_vigent.fgb",
    areesBasiquesServeisSocialsVigentText: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_serveis_socials_vigent_text.fgb",
    areesGestioAssistencialVigent: "https://tilemaps.icgc.cat/vector/fgb/arees_gestio_assistencial_vigent.fgb",
    areesHidrogeologiquesAquifersVigent: "https://tilemaps.icgc.cat/vector/fgb/arees_hidrogeologiques_aquifers_vigent.fgb",
    catalunyaVigent: "https://tilemaps.icgc.cat/vector/fgb/catalunya_vigent.fgb",
    catalunyaVigentText: "https://tilemaps.icgc.cat/vector/fgb/catalunya_vigent_text.fgb",
    comarquesVigent: "https://tilemaps.icgc.cat/vector/fgb/comarques_vigent.fgb",
    comarquesVigentText: "https://tilemaps.icgc.cat/vector/fgb/comarques_vigent_text.fgb",
    districtesCensalsVigent: "https://tilemaps.icgc.cat/vector/fgb/districtes_censals_vigent.fgb",
    districtesCensalsVigentText: "https://tilemaps.icgc.cat/vector/fgb/districtes_censals_vigent_text.fgb",
    incendisForestalsVigent: "https://tilemaps.icgc.cat/vector/fgb/incendis_forestals_vigent.fgb",
    incendisForestalsVigentText: "https://tilemaps.icgc.cat/vector/fgb/incendis_forestals_vigent_text.fgb",
    municipisVigent: "https://tilemaps.icgc.cat/vector/fgb/municipis_vigent.fgb",
    municipisVigentText: "https://tilemaps.icgc.cat/vector/fgb/municipis_vigent_text.fgb",
    partitsJudicialsVigent: "https://tilemaps.icgc.cat/vector/fgb/partits_judicials_vigent.fgb",
    partitsJudicialsVigentText: "https://tilemaps.icgc.cat/vector/fgb/partits_judicials_vigent_text.fgb",
    plaTerritorialVigent: "https://tilemaps.icgc.cat/vector/fgb/pla_territorial_vigent.fgb",
    plaTerritorialVigentText: "https://tilemaps.icgc.cat/vector/fgb/pla_territorial_vigent_text.fgb",
    provinciesVigent: "https://tilemaps.icgc.cat/vector/fgb/provincies_vigent.fgb",
    provinciesVigentText: "https://tilemaps.icgc.cat/vector/fgb/provincies_vigent_text.fgb",
    regionsPolicialsVigent: "https://tilemaps.icgc.cat/vector/fgb/regions_policials_vigent.fgb",
    regionsPolicialsVigentText: "https://tilemaps.icgc.cat/vector/fgb/regions_policials_vigent_text.fgb",
    regionsSanitariesVigent: "https://tilemaps.icgc.cat/vector/fgb/regions_sanitaries_vigent.fgb",
    regionsSanitariesVigentText: "https://tilemaps.icgc.cat/vector/fgb/regions_sanitaries_vigent_text.fgb",
    seccionsCensalsVigent: "https://tilemaps.icgc.cat/vector/fgb/seccions_censals_vigent.fgb",
    seccionsCensalsVigentText: "https://tilemaps.icgc.cat/vector/fgb/seccions_censals_vigent_text.fgb",
    sectorsSanitarisVigent: "https://tilemaps.icgc.cat/vector/fgb/sectors_sanitaris_vigent.fgb",
    vegueriesVigent: "https://tilemaps.icgc.cat/vector/fgb/vegueries_vigent.fgb",
    vegueriesVigentText: "https://tilemaps.icgc.cat/vector/fgb/vegueries_vigent_text.fgb"
  },
  Vector: {
    cobertes2018: "https://tilemaps.icgc.cat/tileserver/cobertes_tilejson.json"
  },
  WMS: {
    espaisInteresGeologic: "https://geoserveis.icgc.cat/servei/catalunya/espais-interes-geologic/wms/service?&service=WMS&request=GetMap&layers=espais-interes-geologic&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}",
    gravimetriaBouguer500000: "https://geoserveis.icgc.cat/servei/catalunya/gravimetria/wms/service?&service=WMS&request=GetMap&layers=anomalia_bouguer_500000&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}",
    cobertesSol2018: "https://geoserveis.icgc.cat/servei/catalunya/cobertes-sol/wms/service?&service=WMS&request=GetMap&layers=cobertes_2018&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}",
    administratiu: "http://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/administratiu/MON3857NW/{z}/{x}/{y}.png",
    simplificat: "http://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/simplificat/MON3857NW/{z}/{x}/{y}.png",
    cims: "https://geoserveis.icgc.cat/icc_100cims/wms/service?REQUEST=GetMap&SERVICE=WMS&VERSION=1.1.1&LAYERS=0&STYLES=&FORMAT=image/png&BGCOLOR=0xFFFFFF&TRANSPARENT=TRUE&SRS=EPSG:25831&BBOX=137118.923076923,4488408.75,650959.076923077,4749634.75&WIDTH=895&HEIGHT=455",
    cobertesSol: "http://geoserveis.icgc.cat/servei/catalunya/cobertes-sol/wms?REQUEST=GetMap&SERVICE=WMS&VERSION=1.3.0&LAYERS=cobertes_2009&STYLES=&FORMAT=image/png&BGCOLOR=0xFFFFFF&TRANSPARENT=TRUE&CRS=EPSG:25831&BBOX=374110.828167253,4639230.79853085,452621.120632226,4703578.45000215&WIDTH=1020&HEIGHT=836"
  }
}, Bh = {
  defaultOptions: wq,
  Styles: Aq,
  Terrains: Eq,
  Layers: Sq
};
class Tq {
  constructor(e) {
    this.options = e || {};
  }
  onAdd(e) {
    let t = Bh.defaultOptions;
    return this._map = e, this._img1 = document.createElement("img"), this._img1.className = "maplibregl-ctrl", this._img1.src = this.options.color ? t.logoIcgcOptions.logoUrlColor : t.logoIcgcOptions.logoUrlWhite, this._img1.width = t.logoIcgcOptions.logoWidth, this._img1.title = t.logoIcgcOptions.logoTitle, this.link1 = document.createElement("a"), this.link1.href = t.logoIcgcOptions.logoLink, this.link1.target = "_blank", this.link1.appendChild(this._img1), this._container1 = document.createElement("div"), this._container1.className = "maplibregl-ctrl", this._container1.style.width = `${t.logoIcgcOptions.logoWidth}px`, this._container1.appendChild(this.link1), this._img2 = document.createElement("img"), this._img2.className = "maplibregl-ctrl", this._img2.src = this.options.color ? t.logoGencatOptions.logoUrlColor : t.logoGencatOptions.logoUrlWhite, this._img2.width = t.logoGencatOptions.logoWidth, this._img2.title = t.logoGencatOptions.logoTitle, this.link2 = document.createElement("a"), this.link2.href = t.logoGencatOptions.logoLink, this.link2.target = "_blank", this.link2.appendChild(this._img2), this._container2 = document.createElement("div"), this._container2.className = "maplibregl-ctrl", this._container2.style.width = `${t.logoGencatOptions.logoWidth}px`, this._container2.appendChild(this.link2), this._mainContainer = document.createElement("div"), this._mainContainer.className = "divLogos", this._mainContainer.style = "display: flex", this._mainContainer.appendChild(this._container1), this._mainContainer.appendChild(this._container2), this._mainContainer;
  }
}
class Cq {
  constructor(e) {
    this.options = e || {};
  }
  onAdd(e) {
    this._map = e, this._img1 = document.createElement("img"), this._img1.src = this.options.url, this._img1.width = 150, this._img1.title = 300, this.controlContainer = document.createElement("div"), this.controlContainer.classList.add("maplibregl-ctrl"), this.controlContainer.classList.add("maplibregl-ctrl-group"), this.legendContainer = document.createElement("div"), this.legendContainer.classList.add("maplibregl-legend-list"), this.legendButton = document.createElement("button"), this.legendButton.classList.add("maplibregl-ctrl-icon"), this.legendButton.classList.add("maplibregl-legend-switcher"), this.legendButton.addEventListener("click", () => {
      this.legendButton.style.display = "none", this.legendContainer.style.display = "block";
    }), document.addEventListener("click", this.onDocumentClick), this.controlContainer.appendChild(this.legendButton), this.controlContainer.appendChild(this.legendContainer), this.closeButton = document.createElement("button"), this.closeButton.textContent = "x", this.closeButton.classList.add("maplibregl-legend-close-button"), this.closeButton.addEventListener("click", () => {
      this.legendButton.style.display = "block", this.legendContainer.style.display = "none";
    }), this.legendContainer.appendChild(this.closeButton);
    const t = document.createElement("label");
    return t.classList.add("maplibregl-legend-title-label"), t.textContent = this.options.idLayer || "Llegenda", this.legendContainer.appendChild(t), this.legendContainer.appendChild(document.createElement("br")), this.legendContainer.appendChild(this._img1), this.controlContainer;
  }
}
var nf = jT.prototype, t1 = "WGS 84";
function jT(n) {
  n !== void 0 && (t1 = n), this.setEllipsoid(t1);
}
nf.convertLatLngToUtm = function(n, e, t) {
  var i;
  if (this.status)
    return "No ecclipsoid data associated with unknown datum: " + t1;
  if (!Number.isInteger(t))
    return "Precision is not integer number.";
  n = parseFloat(n), e = parseFloat(e);
  var r = e, s = this.toRadians(n), c = this.toRadians(r);
  r >= 8 && r <= 13 && n > 54.5 && n < 58 || n >= 56 && n < 64 && r >= 3 && r < 12 ? i = 32 : (i = (r + 180) / 6 + 1, n >= 72 && n < 84 && (r >= 0 && r < 9 ? i = 31 : r >= 9 && r < 21 ? i = 33 : r >= 21 && r < 33 ? i = 35 : r >= 33 && r < 42 && (i = 37))), i = parseInt(i);
  var l = (i - 1) * 6 - 180 + 3, m = this.toRadians(l), y = this.getUtmLetterDesignator(n), A = this.eccSquared / (1 - this.eccSquared), T = this.a / Math.sqrt(1 - this.eccSquared * Math.sin(s) * Math.sin(s)), I = Math.tan(s) * Math.tan(s), L = A * Math.cos(s) * Math.cos(s), N = Math.cos(s) * (c - m), z = this.a * ((1 - this.eccSquared / 4 - 3 * this.eccSquared * this.eccSquared / 64 - 5 * this.eccSquared * this.eccSquared * this.eccSquared / 256) * s - (3 * this.eccSquared / 8 + 3 * this.eccSquared * this.eccSquared / 32 + 45 * this.eccSquared * this.eccSquared * this.eccSquared / 1024) * Math.sin(2 * s) + (15 * this.eccSquared * this.eccSquared / 256 + 45 * this.eccSquared * this.eccSquared * this.eccSquared / 1024) * Math.sin(4 * s) - 35 * this.eccSquared * this.eccSquared * this.eccSquared / 3072 * Math.sin(6 * s)), V = parseFloat(0.9996 * T * (N + (1 - I + L) * N * N * N / 6 + (5 - 18 * I + I * I + 72 * L - 58 * A) * N * N * N * N * N / 120) + 5e5), H = parseFloat(0.9996 * (z + T * Math.tan(s) * (N * N / 2 + (5 - I + 9 * L + 4 * L * L) * N * N * N * N / 24 + (61 - 58 * I + I * I + 600 * L - 330 * A) * N * N * N * N * N * N / 720)));
  return n < 0 && (H += 1e7), H = QA(H, t), V = QA(V, t), {
    Easting: V,
    Northing: H,
    ZoneNumber: parseInt(i),
    ZoneLetter: y
  };
};
nf.convertUtmToLatLng = function(n, e, t, i) {
  var r = (1 - Math.sqrt(1 - this.eccSquared)) / (1 + Math.sqrt(1 - this.eccSquared)), s = n - 5e5, c = e, l = t, m = i;
  if (n === void 0)
    return "Please pass the UTMEasting!";
  if (e === void 0)
    return "Please pass the UTMNorthing!";
  if (t === void 0)
    return "Please pass the UTMZoneNumber!";
  if (i === void 0)
    return "Please pass the UTMZoneLetter!";
  ["N", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"].indexOf(m) !== -1 || (c -= 1e7);
  var y = (l - 1) * 6 - 180 + 3, A = this.eccSquared / (1 - this.eccSquared), T = c / 0.9996, I = T / (this.a * (1 - this.eccSquared / 4 - 3 * this.eccSquared * this.eccSquared / 64 - 5 * this.eccSquared * this.eccSquared * this.eccSquared / 256)), L = I + (3 * r / 2 - 27 * r * r * r / 32) * Math.sin(2 * I) + (21 * r * r / 16 - 55 * r * r * r * r / 32) * Math.sin(4 * I) + 151 * r * r * r / 96 * Math.sin(6 * I);
  this.toDegrees(L);
  var N = this.a / Math.sqrt(1 - this.eccSquared * Math.sin(L) * Math.sin(L)), z = Math.tan(L) * Math.tan(L), V = A * Math.cos(L) * Math.cos(L), H = this.a * (1 - this.eccSquared) / Math.pow(1 - this.eccSquared * Math.sin(L) * Math.sin(L), 1.5), J = s / (N * 0.9996), ce = L - N * Math.tan(L) / H * (J * J / 2 - (5 + 3 * z + 10 * V - 4 * V * V - 9 * A) * J * J * J * J / 24 + (61 + 90 * z + 298 * V + 45 * z * z - 252 * A - 3 * V * V) * J * J * J * J * J * J / 720);
  ce = this.toDegrees(ce);
  var me = (J - (1 + 2 * z + V) * J * J * J / 6 + (5 - 2 * V + 28 * z - 3 * V * V + 8 * A + 24 * z * z) * J * J * J * J * J / 120) / Math.cos(L);
  return me = y + this.toDegrees(me), {
    lat: ce,
    lng: me
  };
};
nf.getUtmLetterDesignator = function(n) {
  return n = parseFloat(n), 84 >= n && n >= 72 ? "X" : 72 > n && n >= 64 ? "W" : 64 > n && n >= 56 ? "V" : 56 > n && n >= 48 ? "U" : 48 > n && n >= 40 ? "T" : 40 > n && n >= 32 ? "S" : 32 > n && n >= 24 ? "R" : 24 > n && n >= 16 ? "Q" : 16 > n && n >= 8 ? "P" : 8 > n && n >= 0 ? "N" : 0 > n && n >= -8 ? "M" : -8 > n && n >= -16 ? "L" : -16 > n && n >= -24 ? "K" : -24 > n && n >= -32 ? "J" : -32 > n && n >= -40 ? "H" : -40 > n && n >= -48 ? "G" : -48 > n && n >= -56 ? "F" : -56 > n && n >= -64 ? "E" : -64 > n && n >= -72 ? "D" : -72 > n && n >= -80 ? "C" : "Z";
};
nf.setEllipsoid = function(n) {
  switch (n) {
    case "Airy":
      this.a = 6377563, this.eccSquared = 667054e-8;
      break;
    case "Australian National":
      this.a = 6378160, this.eccSquared = 6694542e-9;
      break;
    case "Bessel 1841":
      this.a = 6377397, this.eccSquared = 6674372e-9;
      break;
    case "Bessel 1841 Nambia":
      this.a = 6377484, this.eccSquared = 6674372e-9;
      break;
    case "Clarke 1866":
      this.a = 6378206, this.eccSquared = 6768658e-9;
      break;
    case "Clarke 1880":
      this.a = 6378249, this.eccSquared = 6803511e-9;
      break;
    case "Everest":
      this.a = 6377276, this.eccSquared = 6637847e-9;
      break;
    case "Fischer 1960 Mercury":
      this.a = 6378166, this.eccSquared = 6693422e-9;
      break;
    case "Fischer 1968":
      this.a = 6378150, this.eccSquared = 6693422e-9;
      break;
    case "GRS 1967":
      this.a = 6378160, this.eccSquared = 6694605e-9;
      break;
    case "GRS 1980":
      this.a = 6378137, this.eccSquared = 669438e-8;
      break;
    case "Helmert 1906":
      this.a = 6378200, this.eccSquared = 6693422e-9;
      break;
    case "Hough":
      this.a = 6378270, this.eccSquared = 672267e-8;
      break;
    case "International":
      this.a = 6378388, this.eccSquared = 672267e-8;
      break;
    case "Krassovsky":
      this.a = 6378245, this.eccSquared = 6693422e-9;
      break;
    case "Modified Airy":
      this.a = 6377340, this.eccSquared = 667054e-8;
      break;
    case "Modified Everest":
      this.a = 6377304, this.eccSquared = 6637847e-9;
      break;
    case "Modified Fischer 1960":
      this.a = 6378155, this.eccSquared = 6693422e-9;
      break;
    case "South American 1969":
      this.a = 6378160, this.eccSquared = 6694542e-9;
      break;
    case "WGS 60":
      this.a = 6378165, this.eccSquared = 6693422e-9;
      break;
    case "WGS 66":
      this.a = 6378145, this.eccSquared = 6694542e-9;
      break;
    case "WGS 72":
      this.a = 6378135, this.eccSquared = 6694318e-9;
      break;
    case "ED50":
      this.a = 6378388, this.eccSquared = 672267e-8;
      break;
    case "WGS 84":
    case "EUREF89":
    case "ETRS89":
      this.a = 6378137, this.eccSquared = 669438e-8;
      break;
    default:
      this.status = !0;
  }
};
nf.toDegrees = function(n) {
  return n / Math.PI * 180;
};
nf.toRadians = function(n) {
  return n * Math.PI / 180;
};
function QA(n, e) {
  var t = Math.pow(10, e);
  return Math.round(n * t) / t;
}
var Iq = jT;
const Pq = /* @__PURE__ */ Ap(Iq);
class Lq {
  constructor(e) {
    this.options = e || {}, this.options.utm = this.options.hasOwnProperty("utm") ? this.options.utm : !0, this.options.lonlat = this.options.hasOwnProperty("lonlat") ? this.options.lonlat : !0;
  }
  onAdd(e) {
    const t = new Pq();
    return this._map = e, this._container = document.createElement("div"), this._container.className = "maplibregl-ctrl coordControl", this._container.style.width = `${this.options.width || "225px"}`, this._map.on("mousemove", (i) => {
      const r = i.lngLat.lat, s = i.lngLat.lng;
      let c = "", l = "";
      const m = t.convertLatLngToUtm(r, s, 2), y = r > 0 ? "N" : "S";
      this.options.utm && (c = `ETRS89 UTM ${m.ZoneNumber}${y} X:<b> ${m.Easting}</b> Y:<b> ${m.Northing}</b> <br>`), this.options.lonlat && (l = `WGS 84 Lon:<b> ${s.toFixed(5)}</b>  Lat:<b> ${r.toFixed(5)}</b>`);
      const A = `${c}${l}`;
      this._container.innerHTML = A;
    }), this._container;
  }
  _lookUTM31(e, t) {
    var i = 0, r = 0, s = 6, c = 84;
    return e >= i && e <= s && t >= r && t <= c;
  }
  onRemove() {
    this._container.parentNode.removeChild(this._container), this._map = void 0;
  }
}
function GT(n, e) {
  return function() {
    return n.apply(e, arguments);
  };
}
const {
  toString: Mq
} = Object.prototype, {
  getPrototypeOf: Pv
} = Object, Hm = /* @__PURE__ */ ((n) => (e) => {
  const t = Mq.call(e);
  return n[t] || (n[t] = t.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), yc = (n) => (n = n.toLowerCase(), (e) => Hm(e) === n), Wm = (n) => (e) => typeof e === n, {
  isArray: rf
} = Array, wp = Wm("undefined");
function Bq(n) {
  return n !== null && !wp(n) && n.constructor !== null && !wp(n.constructor) && Ya(n.constructor.isBuffer) && n.constructor.isBuffer(n);
}
const VT = yc("ArrayBuffer");
function Rq(n) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(n) : e = n && n.buffer && VT(n.buffer), e;
}
const Oq = Wm("string"), Ya = Wm("function"), qT = Wm("number"), Xm = (n) => n !== null && typeof n == "object", Fq = (n) => n === !0 || n === !1, im = (n) => {
  if (Hm(n) !== "object")
    return !1;
  const e = Pv(n);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in n) && !(Symbol.iterator in n);
}, Dq = yc("Date"), kq = yc("File"), Nq = yc("Blob"), zq = yc("FileList"), Uq = (n) => Xm(n) && Ya(n.pipe), jq = (n) => {
  let e;
  return n && (typeof FormData == "function" && n instanceof FormData || Ya(n.append) && ((e = Hm(n)) === "formdata" || // detect form-data instance
  e === "object" && Ya(n.toString) && n.toString() === "[object FormData]"));
}, Gq = yc("URLSearchParams"), Vq = (n) => n.trim ? n.trim() : n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Up(n, e) {
  let {
    allOwnKeys: t = !1
  } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (n === null || typeof n > "u")
    return;
  let i, r;
  if (typeof n != "object" && (n = [n]), rf(n))
    for (i = 0, r = n.length; i < r; i++)
      e.call(null, n[i], i, n);
  else {
    const s = t ? Object.getOwnPropertyNames(n) : Object.keys(n), c = s.length;
    let l;
    for (i = 0; i < c; i++)
      l = s[i], e.call(null, n[l], l, n);
  }
}
function HT(n, e) {
  e = e.toLowerCase();
  const t = Object.keys(n);
  let i = t.length, r;
  for (; i-- > 0; )
    if (r = t[i], e === r.toLowerCase())
      return r;
  return null;
}
const WT = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, XT = (n) => !wp(n) && n !== WT;
function n1() {
  const {
    caseless: n
  } = XT(this) && this || {}, e = {}, t = (i, r) => {
    const s = n && HT(e, r) || r;
    im(e[s]) && im(i) ? e[s] = n1(e[s], i) : im(i) ? e[s] = n1({}, i) : rf(i) ? e[s] = i.slice() : e[s] = i;
  };
  for (let i = 0, r = arguments.length; i < r; i++)
    arguments[i] && Up(arguments[i], t);
  return e;
}
const qq = function(n, e, t) {
  let {
    allOwnKeys: i
  } = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  return Up(e, (r, s) => {
    t && Ya(r) ? n[s] = GT(r, t) : n[s] = r;
  }, {
    allOwnKeys: i
  }), n;
}, Hq = (n) => (n.charCodeAt(0) === 65279 && (n = n.slice(1)), n), Wq = (n, e, t, i) => {
  n.prototype = Object.create(e.prototype, i), n.prototype.constructor = n, Object.defineProperty(n, "super", {
    value: e.prototype
  }), t && Object.assign(n.prototype, t);
}, Xq = (n, e, t, i) => {
  let r, s, c;
  const l = {};
  if (e = e || {}, n == null)
    return e;
  do {
    for (r = Object.getOwnPropertyNames(n), s = r.length; s-- > 0; )
      c = r[s], (!i || i(c, n, e)) && !l[c] && (e[c] = n[c], l[c] = !0);
    n = t !== !1 && Pv(n);
  } while (n && (!t || t(n, e)) && n !== Object.prototype);
  return e;
}, Jq = (n, e, t) => {
  n = String(n), (t === void 0 || t > n.length) && (t = n.length), t -= e.length;
  const i = n.indexOf(e, t);
  return i !== -1 && i === t;
}, $q = (n) => {
  if (!n)
    return null;
  if (rf(n))
    return n;
  let e = n.length;
  if (!qT(e))
    return null;
  const t = new Array(e);
  for (; e-- > 0; )
    t[e] = n[e];
  return t;
}, Zq = /* @__PURE__ */ ((n) => (e) => n && e instanceof n)(typeof Uint8Array < "u" && Pv(Uint8Array)), Yq = (n, e) => {
  const i = (n && n[Symbol.iterator]).call(n);
  let r;
  for (; (r = i.next()) && !r.done; ) {
    const s = r.value;
    e.call(n, s[0], s[1]);
  }
}, Kq = (n, e) => {
  let t;
  const i = [];
  for (; (t = n.exec(e)) !== null; )
    i.push(t);
  return i;
}, Qq = yc("HTMLFormElement"), eH = (n) => n.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(t, i, r) {
  return i.toUpperCase() + r;
}), e5 = ((n) => {
  let {
    hasOwnProperty: e
  } = n;
  return (t, i) => e.call(t, i);
})(Object.prototype), tH = yc("RegExp"), JT = (n, e) => {
  const t = Object.getOwnPropertyDescriptors(n), i = {};
  Up(t, (r, s) => {
    let c;
    (c = e(r, s, n)) !== !1 && (i[s] = c || r);
  }), Object.defineProperties(n, i);
}, nH = (n) => {
  JT(n, (e, t) => {
    if (Ya(n) && ["arguments", "caller", "callee"].indexOf(t) !== -1)
      return !1;
    const i = n[t];
    if (Ya(i)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + t + "'");
      });
    }
  });
}, iH = (n, e) => {
  const t = {}, i = (r) => {
    r.forEach((s) => {
      t[s] = !0;
    });
  };
  return rf(n) ? i(n) : i(String(n).split(e)), t;
}, rH = () => {
}, sH = (n, e) => (n = +n, Number.isFinite(n) ? n : e), H_ = "abcdefghijklmnopqrstuvwxyz", t5 = "0123456789", $T = {
  DIGIT: t5,
  ALPHA: H_,
  ALPHA_DIGIT: H_ + H_.toUpperCase() + t5
}, oH = function() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : $T.ALPHA_DIGIT, t = "";
  const {
    length: i
  } = e;
  for (; n--; )
    t += e[Math.random() * i | 0];
  return t;
};
function aH(n) {
  return !!(n && Ya(n.append) && n[Symbol.toStringTag] === "FormData" && n[Symbol.iterator]);
}
const lH = (n) => {
  const e = new Array(10), t = (i, r) => {
    if (Xm(i)) {
      if (e.indexOf(i) >= 0)
        return;
      if (!("toJSON" in i)) {
        e[r] = i;
        const s = rf(i) ? [] : {};
        return Up(i, (c, l) => {
          const m = t(c, r + 1);
          !wp(m) && (s[l] = m);
        }), e[r] = void 0, s;
      }
    }
    return i;
  };
  return t(n, 0);
}, cH = yc("AsyncFunction"), uH = (n) => n && (Xm(n) || Ya(n)) && Ya(n.then) && Ya(n.catch), wt = {
  isArray: rf,
  isArrayBuffer: VT,
  isBuffer: Bq,
  isFormData: jq,
  isArrayBufferView: Rq,
  isString: Oq,
  isNumber: qT,
  isBoolean: Fq,
  isObject: Xm,
  isPlainObject: im,
  isUndefined: wp,
  isDate: Dq,
  isFile: kq,
  isBlob: Nq,
  isRegExp: tH,
  isFunction: Ya,
  isStream: Uq,
  isURLSearchParams: Gq,
  isTypedArray: Zq,
  isFileList: zq,
  forEach: Up,
  merge: n1,
  extend: qq,
  trim: Vq,
  stripBOM: Hq,
  inherits: Wq,
  toFlatObject: Xq,
  kindOf: Hm,
  kindOfTest: yc,
  endsWith: Jq,
  toArray: $q,
  forEachEntry: Yq,
  matchAll: Kq,
  isHTMLForm: Qq,
  hasOwnProperty: e5,
  hasOwnProp: e5,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: JT,
  freezeMethods: nH,
  toObjectSet: iH,
  toCamelCase: eH,
  noop: rH,
  toFiniteNumber: sH,
  findKey: HT,
  global: WT,
  isContextDefined: XT,
  ALPHABET: $T,
  generateString: oH,
  isSpecCompliantForm: aH,
  toJSONObject: lH,
  isAsyncFn: cH,
  isThenable: uH
};
function ui(n, e, t, i, r) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = n, this.name = "AxiosError", e && (this.code = e), t && (this.config = t), i && (this.request = i), r && (this.response = r);
}
wt.inherits(ui, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: wt.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const ZT = ui.prototype, YT = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((n) => {
  YT[n] = {
    value: n
  };
});
Object.defineProperties(ui, YT);
Object.defineProperty(ZT, "isAxiosError", {
  value: !0
});
ui.from = (n, e, t, i, r, s) => {
  const c = Object.create(ZT);
  return wt.toFlatObject(n, c, function(m) {
    return m !== Error.prototype;
  }, (l) => l !== "isAxiosError"), ui.call(c, n.message, e, t, i, r), c.cause = n, c.name = n.name, s && Object.assign(c, s), c;
};
const hH = null;
function i1(n) {
  return wt.isPlainObject(n) || wt.isArray(n);
}
function KT(n) {
  return wt.endsWith(n, "[]") ? n.slice(0, -2) : n;
}
function n5(n, e, t) {
  return n ? n.concat(e).map(function(r, s) {
    return r = KT(r), !t && s ? "[" + r + "]" : r;
  }).join(t ? "." : "") : e;
}
function dH(n) {
  return wt.isArray(n) && !n.some(i1);
}
const fH = wt.toFlatObject(wt, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function Jm(n, e, t) {
  if (!wt.isObject(n))
    throw new TypeError("target must be an object");
  e = e || new FormData(), t = wt.toFlatObject(t, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(z, V) {
    return !wt.isUndefined(V[z]);
  });
  const i = t.metaTokens, r = t.visitor || A, s = t.dots, c = t.indexes, m = (t.Blob || typeof Blob < "u" && Blob) && wt.isSpecCompliantForm(e);
  if (!wt.isFunction(r))
    throw new TypeError("visitor must be a function");
  function y(N) {
    if (N === null)
      return "";
    if (wt.isDate(N))
      return N.toISOString();
    if (!m && wt.isBlob(N))
      throw new ui("Blob is not supported. Use a Buffer instead.");
    return wt.isArrayBuffer(N) || wt.isTypedArray(N) ? m && typeof Blob == "function" ? new Blob([N]) : Buffer.from(N) : N;
  }
  function A(N, z, V) {
    let H = N;
    if (N && !V && typeof N == "object") {
      if (wt.endsWith(z, "{}"))
        z = i ? z : z.slice(0, -2), N = JSON.stringify(N);
      else if (wt.isArray(N) && dH(N) || (wt.isFileList(N) || wt.endsWith(z, "[]")) && (H = wt.toArray(N)))
        return z = KT(z), H.forEach(function(ce, me) {
          !(wt.isUndefined(ce) || ce === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            c === !0 ? n5([z], me, s) : c === null ? z : z + "[]",
            y(ce)
          );
        }), !1;
    }
    return i1(N) ? !0 : (e.append(n5(V, z, s), y(N)), !1);
  }
  const T = [], I = Object.assign(fH, {
    defaultVisitor: A,
    convertValue: y,
    isVisitable: i1
  });
  function L(N, z) {
    if (!wt.isUndefined(N)) {
      if (T.indexOf(N) !== -1)
        throw Error("Circular reference detected in " + z.join("."));
      T.push(N), wt.forEach(N, function(H, J) {
        (!(wt.isUndefined(H) || H === null) && r.call(e, H, wt.isString(J) ? J.trim() : J, z, I)) === !0 && L(H, z ? z.concat(J) : [J]);
      }), T.pop();
    }
  }
  if (!wt.isObject(n))
    throw new TypeError("data must be an object");
  return L(n), e;
}
function i5(n) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(n).replace(/[!'()~]|%20|%00/g, function(i) {
    return e[i];
  });
}
function Lv(n, e) {
  this._pairs = [], n && Jm(n, this, e);
}
const QT = Lv.prototype;
QT.append = function(e, t) {
  this._pairs.push([e, t]);
};
QT.toString = function(e) {
  const t = e ? function(i) {
    return e.call(this, i, i5);
  } : i5;
  return this._pairs.map(function(r) {
    return t(r[0]) + "=" + t(r[1]);
  }, "").join("&");
};
function pH(n) {
  return encodeURIComponent(n).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function e3(n, e, t) {
  if (!e)
    return n;
  const i = t && t.encode || pH, r = t && t.serialize;
  let s;
  if (r ? s = r(e, t) : s = wt.isURLSearchParams(e) ? e.toString() : new Lv(e, t).toString(i), s) {
    const c = n.indexOf("#");
    c !== -1 && (n = n.slice(0, c)), n += (n.indexOf("?") === -1 ? "?" : "&") + s;
  }
  return n;
}
class r5 {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, t, i) {
    return this.handlers.push({
      fulfilled: e,
      rejected: t,
      synchronous: i ? i.synchronous : !1,
      runWhen: i ? i.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    wt.forEach(this.handlers, function(i) {
      i !== null && e(i);
    });
  }
}
const t3 = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, gH = typeof URLSearchParams < "u" ? URLSearchParams : Lv, mH = typeof FormData < "u" ? FormData : null, _H = typeof Blob < "u" ? Blob : null, yH = {
  isBrowser: !0,
  classes: {
    URLSearchParams: gH,
    FormData: mH,
    Blob: _H
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, n3 = typeof window < "u" && typeof document < "u", vH = ((n) => n3 && ["ReactNative", "NativeScript", "NS"].indexOf(n) < 0)(typeof navigator < "u" && navigator.product), bH = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", xH = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: n3,
  hasStandardBrowserEnv: vH,
  hasStandardBrowserWebWorkerEnv: bH
}, Symbol.toStringTag, { value: "Module" })), pc = {
  ...xH,
  ...yH
};
function wH(n, e) {
  return Jm(n, new pc.classes.URLSearchParams(), Object.assign({
    visitor: function(t, i, r, s) {
      return pc.isNode && wt.isBuffer(t) ? (this.append(i, t.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments);
    }
  }, e));
}
function AH(n) {
  return wt.matchAll(/\w+|\[(\w*)]/g, n).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function EH(n) {
  const e = {}, t = Object.keys(n);
  let i;
  const r = t.length;
  let s;
  for (i = 0; i < r; i++)
    s = t[i], e[s] = n[s];
  return e;
}
function i3(n) {
  function e(t, i, r, s) {
    let c = t[s++];
    if (c === "__proto__")
      return !0;
    const l = Number.isFinite(+c), m = s >= t.length;
    return c = !c && wt.isArray(r) ? r.length : c, m ? (wt.hasOwnProp(r, c) ? r[c] = [r[c], i] : r[c] = i, !l) : ((!r[c] || !wt.isObject(r[c])) && (r[c] = []), e(t, i, r[c], s) && wt.isArray(r[c]) && (r[c] = EH(r[c])), !l);
  }
  if (wt.isFormData(n) && wt.isFunction(n.entries)) {
    const t = {};
    return wt.forEachEntry(n, (i, r) => {
      e(AH(i), r, t, 0);
    }), t;
  }
  return null;
}
function SH(n, e, t) {
  if (wt.isString(n))
    try {
      return (e || JSON.parse)(n), wt.trim(n);
    } catch (i) {
      if (i.name !== "SyntaxError")
        throw i;
    }
  return (t || JSON.stringify)(n);
}
const jp = {
  transitional: t3,
  adapter: ["xhr", "http"],
  transformRequest: [function(e, t) {
    const i = t.getContentType() || "", r = i.indexOf("application/json") > -1, s = wt.isObject(e);
    if (s && wt.isHTMLForm(e) && (e = new FormData(e)), wt.isFormData(e))
      return r ? JSON.stringify(i3(e)) : e;
    if (wt.isArrayBuffer(e) || wt.isBuffer(e) || wt.isStream(e) || wt.isFile(e) || wt.isBlob(e))
      return e;
    if (wt.isArrayBufferView(e))
      return e.buffer;
    if (wt.isURLSearchParams(e))
      return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let l;
    if (s) {
      if (i.indexOf("application/x-www-form-urlencoded") > -1)
        return wH(e, this.formSerializer).toString();
      if ((l = wt.isFileList(e)) || i.indexOf("multipart/form-data") > -1) {
        const m = this.env && this.env.FormData;
        return Jm(l ? {
          "files[]": e
        } : e, m && new m(), this.formSerializer);
      }
    }
    return s || r ? (t.setContentType("application/json", !1), SH(e)) : e;
  }],
  transformResponse: [function(e) {
    const t = this.transitional || jp.transitional, i = t && t.forcedJSONParsing, r = this.responseType === "json";
    if (e && wt.isString(e) && (i && !this.responseType || r)) {
      const c = !(t && t.silentJSONParsing) && r;
      try {
        return JSON.parse(e);
      } catch (l) {
        if (c)
          throw l.name === "SyntaxError" ? ui.from(l, ui.ERR_BAD_RESPONSE, this, null, this.response) : l;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: pc.classes.FormData,
    Blob: pc.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
wt.forEach(["delete", "get", "head", "post", "put", "patch"], (n) => {
  jp.headers[n] = {};
});
const TH = wt.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), CH = (n) => {
  const e = {};
  let t, i, r;
  return n && n.split(`
`).forEach(function(c) {
    r = c.indexOf(":"), t = c.substring(0, r).trim().toLowerCase(), i = c.substring(r + 1).trim(), !(!t || e[t] && TH[t]) && (t === "set-cookie" ? e[t] ? e[t].push(i) : e[t] = [i] : e[t] = e[t] ? e[t] + ", " + i : i);
  }), e;
}, s5 = Symbol("internals");
function Jf(n) {
  return n && String(n).trim().toLowerCase();
}
function rm(n) {
  return n === !1 || n == null ? n : wt.isArray(n) ? n.map(rm) : String(n);
}
function IH(n) {
  const e = /* @__PURE__ */ Object.create(null), t = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let i;
  for (; i = t.exec(n); )
    e[i[1]] = i[2];
  return e;
}
const PH = (n) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(n.trim());
function W_(n, e, t, i, r) {
  if (wt.isFunction(i))
    return i.call(this, e, t);
  if (r && (e = t), !!wt.isString(e)) {
    if (wt.isString(i))
      return e.indexOf(i) !== -1;
    if (wt.isRegExp(i))
      return i.test(e);
  }
}
function LH(n) {
  return n.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, t, i) => t.toUpperCase() + i);
}
function MH(n, e) {
  const t = wt.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((i) => {
    Object.defineProperty(n, i + t, {
      value: function(r, s, c) {
        return this[i].call(this, e, r, s, c);
      },
      configurable: !0
    });
  });
}
class Ka {
  constructor(e) {
    e && this.set(e);
  }
  set(e, t, i) {
    const r = this;
    function s(l, m, y) {
      const A = Jf(m);
      if (!A)
        throw new Error("header name must be a non-empty string");
      const T = wt.findKey(r, A);
      (!T || r[T] === void 0 || y === !0 || y === void 0 && r[T] !== !1) && (r[T || m] = rm(l));
    }
    const c = (l, m) => wt.forEach(l, (y, A) => s(y, A, m));
    return wt.isPlainObject(e) || e instanceof this.constructor ? c(e, t) : wt.isString(e) && (e = e.trim()) && !PH(e) ? c(CH(e), t) : e != null && s(t, e, i), this;
  }
  get(e, t) {
    if (e = Jf(e), e) {
      const i = wt.findKey(this, e);
      if (i) {
        const r = this[i];
        if (!t)
          return r;
        if (t === !0)
          return IH(r);
        if (wt.isFunction(t))
          return t.call(this, r, i);
        if (wt.isRegExp(t))
          return t.exec(r);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, t) {
    if (e = Jf(e), e) {
      const i = wt.findKey(this, e);
      return !!(i && this[i] !== void 0 && (!t || W_(this, this[i], i, t)));
    }
    return !1;
  }
  delete(e, t) {
    const i = this;
    let r = !1;
    function s(c) {
      if (c = Jf(c), c) {
        const l = wt.findKey(i, c);
        l && (!t || W_(i, i[l], l, t)) && (delete i[l], r = !0);
      }
    }
    return wt.isArray(e) ? e.forEach(s) : s(e), r;
  }
  clear(e) {
    const t = Object.keys(this);
    let i = t.length, r = !1;
    for (; i--; ) {
      const s = t[i];
      (!e || W_(this, this[s], s, e, !0)) && (delete this[s], r = !0);
    }
    return r;
  }
  normalize(e) {
    const t = this, i = {};
    return wt.forEach(this, (r, s) => {
      const c = wt.findKey(i, s);
      if (c) {
        t[c] = rm(r), delete t[s];
        return;
      }
      const l = e ? LH(s) : String(s).trim();
      l !== s && delete t[s], t[l] = rm(r), i[l] = !0;
    }), this;
  }
  concat() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return this.constructor.concat(this, ...t);
  }
  toJSON(e) {
    const t = /* @__PURE__ */ Object.create(null);
    return wt.forEach(this, (i, r) => {
      i != null && i !== !1 && (t[r] = e && wt.isArray(i) ? i.join(", ") : i);
    }), t;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map((e) => {
      let [t, i] = e;
      return t + ": " + i;
    }).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e) {
    const t = new this(e);
    for (var i = arguments.length, r = new Array(i > 1 ? i - 1 : 0), s = 1; s < i; s++)
      r[s - 1] = arguments[s];
    return r.forEach((c) => t.set(c)), t;
  }
  static accessor(e) {
    const i = (this[s5] = this[s5] = {
      accessors: {}
    }).accessors, r = this.prototype;
    function s(c) {
      const l = Jf(c);
      i[l] || (MH(r, c), i[l] = !0);
    }
    return wt.isArray(e) ? e.forEach(s) : s(e), this;
  }
}
Ka.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
wt.reduceDescriptors(Ka.prototype, (n, e) => {
  let {
    value: t
  } = n, i = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => t,
    set(r) {
      this[i] = r;
    }
  };
});
wt.freezeMethods(Ka);
function X_(n, e) {
  const t = this || jp, i = e || t, r = Ka.from(i.headers);
  let s = i.data;
  return wt.forEach(n, function(l) {
    s = l.call(t, s, r.normalize(), e ? e.status : void 0);
  }), r.normalize(), s;
}
function r3(n) {
  return !!(n && n.__CANCEL__);
}
function Gp(n, e, t) {
  ui.call(this, n ?? "canceled", ui.ERR_CANCELED, e, t), this.name = "CanceledError";
}
wt.inherits(Gp, ui, {
  __CANCEL__: !0
});
function BH(n, e, t) {
  const i = t.config.validateStatus;
  !t.status || !i || i(t.status) ? n(t) : e(new ui("Request failed with status code " + t.status, [ui.ERR_BAD_REQUEST, ui.ERR_BAD_RESPONSE][Math.floor(t.status / 100) - 4], t.config, t.request, t));
}
const RH = pc.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(n, e, t, i, r, s) {
      const c = [n + "=" + encodeURIComponent(e)];
      wt.isNumber(t) && c.push("expires=" + new Date(t).toGMTString()), wt.isString(i) && c.push("path=" + i), wt.isString(r) && c.push("domain=" + r), s === !0 && c.push("secure"), document.cookie = c.join("; ");
    },
    read(n) {
      const e = document.cookie.match(new RegExp("(^|;\\s*)(" + n + ")=([^;]*)"));
      return e ? decodeURIComponent(e[3]) : null;
    },
    remove(n) {
      this.write(n, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function OH(n) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(n);
}
function FH(n, e) {
  return e ? n.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : n;
}
function s3(n, e) {
  return n && !OH(e) ? FH(n, e) : e;
}
const DH = pc.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const e = /(msie|trident)/i.test(navigator.userAgent), t = document.createElement("a");
    let i;
    function r(s) {
      let c = s;
      return e && (t.setAttribute("href", c), c = t.href), t.setAttribute("href", c), {
        href: t.href,
        protocol: t.protocol ? t.protocol.replace(/:$/, "") : "",
        host: t.host,
        search: t.search ? t.search.replace(/^\?/, "") : "",
        hash: t.hash ? t.hash.replace(/^#/, "") : "",
        hostname: t.hostname,
        port: t.port,
        pathname: t.pathname.charAt(0) === "/" ? t.pathname : "/" + t.pathname
      };
    }
    return i = r(window.location.href), function(c) {
      const l = wt.isString(c) ? r(c) : c;
      return l.protocol === i.protocol && l.host === i.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function() {
    return function() {
      return !0;
    };
  }()
);
function kH(n) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(n);
  return e && e[1] || "";
}
function NH(n, e) {
  n = n || 10;
  const t = new Array(n), i = new Array(n);
  let r = 0, s = 0, c;
  return e = e !== void 0 ? e : 1e3, function(m) {
    const y = Date.now(), A = i[s];
    c || (c = y), t[r] = m, i[r] = y;
    let T = s, I = 0;
    for (; T !== r; )
      I += t[T++], T = T % n;
    if (r = (r + 1) % n, r === s && (s = (s + 1) % n), y - c < e)
      return;
    const L = A && y - A;
    return L ? Math.round(I * 1e3 / L) : void 0;
  };
}
function o5(n, e) {
  let t = 0;
  const i = NH(50, 250);
  return (r) => {
    const s = r.loaded, c = r.lengthComputable ? r.total : void 0, l = s - t, m = i(l), y = s <= c;
    t = s;
    const A = {
      loaded: s,
      total: c,
      progress: c ? s / c : void 0,
      bytes: l,
      rate: m || void 0,
      estimated: m && c && y ? (c - s) / m : void 0,
      event: r
    };
    A[e ? "download" : "upload"] = !0, n(A);
  };
}
const zH = typeof XMLHttpRequest < "u", UH = zH && function(n) {
  return new Promise(function(t, i) {
    let r = n.data;
    const s = Ka.from(n.headers).normalize();
    let {
      responseType: c,
      withXSRFToken: l
    } = n, m;
    function y() {
      n.cancelToken && n.cancelToken.unsubscribe(m), n.signal && n.signal.removeEventListener("abort", m);
    }
    let A;
    if (wt.isFormData(r)) {
      if (pc.hasStandardBrowserEnv || pc.hasStandardBrowserWebWorkerEnv)
        s.setContentType(!1);
      else if ((A = s.getContentType()) !== !1) {
        const [z, ...V] = A ? A.split(";").map((H) => H.trim()).filter(Boolean) : [];
        s.setContentType([z || "multipart/form-data", ...V].join("; "));
      }
    }
    let T = new XMLHttpRequest();
    if (n.auth) {
      const z = n.auth.username || "", V = n.auth.password ? unescape(encodeURIComponent(n.auth.password)) : "";
      s.set("Authorization", "Basic " + btoa(z + ":" + V));
    }
    const I = s3(n.baseURL, n.url);
    T.open(n.method.toUpperCase(), e3(I, n.params, n.paramsSerializer), !0), T.timeout = n.timeout;
    function L() {
      if (!T)
        return;
      const z = Ka.from("getAllResponseHeaders" in T && T.getAllResponseHeaders()), H = {
        data: !c || c === "text" || c === "json" ? T.responseText : T.response,
        status: T.status,
        statusText: T.statusText,
        headers: z,
        config: n,
        request: T
      };
      BH(function(ce) {
        t(ce), y();
      }, function(ce) {
        i(ce), y();
      }, H), T = null;
    }
    if ("onloadend" in T ? T.onloadend = L : T.onreadystatechange = function() {
      !T || T.readyState !== 4 || T.status === 0 && !(T.responseURL && T.responseURL.indexOf("file:") === 0) || setTimeout(L);
    }, T.onabort = function() {
      T && (i(new ui("Request aborted", ui.ECONNABORTED, n, T)), T = null);
    }, T.onerror = function() {
      i(new ui("Network Error", ui.ERR_NETWORK, n, T)), T = null;
    }, T.ontimeout = function() {
      let V = n.timeout ? "timeout of " + n.timeout + "ms exceeded" : "timeout exceeded";
      const H = n.transitional || t3;
      n.timeoutErrorMessage && (V = n.timeoutErrorMessage), i(new ui(V, H.clarifyTimeoutError ? ui.ETIMEDOUT : ui.ECONNABORTED, n, T)), T = null;
    }, pc.hasStandardBrowserEnv && (l && wt.isFunction(l) && (l = l(n)), l || l !== !1 && DH(I))) {
      const z = n.xsrfHeaderName && n.xsrfCookieName && RH.read(n.xsrfCookieName);
      z && s.set(n.xsrfHeaderName, z);
    }
    r === void 0 && s.setContentType(null), "setRequestHeader" in T && wt.forEach(s.toJSON(), function(V, H) {
      T.setRequestHeader(H, V);
    }), wt.isUndefined(n.withCredentials) || (T.withCredentials = !!n.withCredentials), c && c !== "json" && (T.responseType = n.responseType), typeof n.onDownloadProgress == "function" && T.addEventListener("progress", o5(n.onDownloadProgress, !0)), typeof n.onUploadProgress == "function" && T.upload && T.upload.addEventListener("progress", o5(n.onUploadProgress)), (n.cancelToken || n.signal) && (m = (z) => {
      T && (i(!z || z.type ? new Gp(null, n, T) : z), T.abort(), T = null);
    }, n.cancelToken && n.cancelToken.subscribe(m), n.signal && (n.signal.aborted ? m() : n.signal.addEventListener("abort", m)));
    const N = kH(I);
    if (N && pc.protocols.indexOf(N) === -1) {
      i(new ui("Unsupported protocol " + N + ":", ui.ERR_BAD_REQUEST, n));
      return;
    }
    T.send(r || null);
  });
}, r1 = {
  http: hH,
  xhr: UH
};
wt.forEach(r1, (n, e) => {
  if (n) {
    try {
      Object.defineProperty(n, "name", {
        value: e
      });
    } catch {
    }
    Object.defineProperty(n, "adapterName", {
      value: e
    });
  }
});
const a5 = (n) => `- ${n}`, jH = (n) => wt.isFunction(n) || n === null || n === !1, o3 = {
  getAdapter: (n) => {
    n = wt.isArray(n) ? n : [n];
    const {
      length: e
    } = n;
    let t, i;
    const r = {};
    for (let s = 0; s < e; s++) {
      t = n[s];
      let c;
      if (i = t, !jH(t) && (i = r1[(c = String(t)).toLowerCase()], i === void 0))
        throw new ui(`Unknown adapter '${c}'`);
      if (i)
        break;
      r[c || "#" + s] = i;
    }
    if (!i) {
      const s = Object.entries(r).map((l) => {
        let [m, y] = l;
        return `adapter ${m} ` + (y === !1 ? "is not supported by the environment" : "is not available in the build");
      });
      let c = e ? s.length > 1 ? `since :
` + s.map(a5).join(`
`) : " " + a5(s[0]) : "as no adapter specified";
      throw new ui("There is no suitable adapter to dispatch the request " + c, "ERR_NOT_SUPPORT");
    }
    return i;
  },
  adapters: r1
};
function J_(n) {
  if (n.cancelToken && n.cancelToken.throwIfRequested(), n.signal && n.signal.aborted)
    throw new Gp(null, n);
}
function l5(n) {
  return J_(n), n.headers = Ka.from(n.headers), n.data = X_.call(n, n.transformRequest), ["post", "put", "patch"].indexOf(n.method) !== -1 && n.headers.setContentType("application/x-www-form-urlencoded", !1), o3.getAdapter(n.adapter || jp.adapter)(n).then(function(i) {
    return J_(n), i.data = X_.call(n, n.transformResponse, i), i.headers = Ka.from(i.headers), i;
  }, function(i) {
    return r3(i) || (J_(n), i && i.response && (i.response.data = X_.call(n, n.transformResponse, i.response), i.response.headers = Ka.from(i.response.headers))), Promise.reject(i);
  });
}
const c5 = (n) => n instanceof Ka ? {
  ...n
} : n;
function Yd(n, e) {
  e = e || {};
  const t = {};
  function i(y, A, T) {
    return wt.isPlainObject(y) && wt.isPlainObject(A) ? wt.merge.call({
      caseless: T
    }, y, A) : wt.isPlainObject(A) ? wt.merge({}, A) : wt.isArray(A) ? A.slice() : A;
  }
  function r(y, A, T) {
    if (wt.isUndefined(A)) {
      if (!wt.isUndefined(y))
        return i(void 0, y, T);
    } else
      return i(y, A, T);
  }
  function s(y, A) {
    if (!wt.isUndefined(A))
      return i(void 0, A);
  }
  function c(y, A) {
    if (wt.isUndefined(A)) {
      if (!wt.isUndefined(y))
        return i(void 0, y);
    } else
      return i(void 0, A);
  }
  function l(y, A, T) {
    if (T in e)
      return i(y, A);
    if (T in n)
      return i(void 0, y);
  }
  const m = {
    url: s,
    method: s,
    data: s,
    baseURL: c,
    transformRequest: c,
    transformResponse: c,
    paramsSerializer: c,
    timeout: c,
    timeoutMessage: c,
    withCredentials: c,
    withXSRFToken: c,
    adapter: c,
    responseType: c,
    xsrfCookieName: c,
    xsrfHeaderName: c,
    onUploadProgress: c,
    onDownloadProgress: c,
    decompress: c,
    maxContentLength: c,
    maxBodyLength: c,
    beforeRedirect: c,
    transport: c,
    httpAgent: c,
    httpsAgent: c,
    cancelToken: c,
    socketPath: c,
    responseEncoding: c,
    validateStatus: l,
    headers: (y, A) => r(c5(y), c5(A), !0)
  };
  return wt.forEach(Object.keys(Object.assign({}, n, e)), function(A) {
    const T = m[A] || r, I = T(n[A], e[A], A);
    wt.isUndefined(I) && T !== l || (t[A] = I);
  }), t;
}
const a3 = "1.6.8", Mv = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((n, e) => {
  Mv[n] = function(i) {
    return typeof i === n || "a" + (e < 1 ? "n " : " ") + n;
  };
});
const u5 = {};
Mv.transitional = function(e, t, i) {
  function r(s, c) {
    return "[Axios v" + a3 + "] Transitional option '" + s + "'" + c + (i ? ". " + i : "");
  }
  return (s, c, l) => {
    if (e === !1)
      throw new ui(r(c, " has been removed" + (t ? " in " + t : "")), ui.ERR_DEPRECATED);
    return t && !u5[c] && (u5[c] = !0, console.warn(r(c, " has been deprecated since v" + t + " and will be removed in the near future"))), e ? e(s, c, l) : !0;
  };
};
function GH(n, e, t) {
  if (typeof n != "object")
    throw new ui("options must be an object", ui.ERR_BAD_OPTION_VALUE);
  const i = Object.keys(n);
  let r = i.length;
  for (; r-- > 0; ) {
    const s = i[r], c = e[s];
    if (c) {
      const l = n[s], m = l === void 0 || c(l, s, n);
      if (m !== !0)
        throw new ui("option " + s + " must be " + m, ui.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (t !== !0)
      throw new ui("Unknown option " + s, ui.ERR_BAD_OPTION);
  }
}
const s1 = {
  assertOptions: GH,
  validators: Mv
}, Uu = s1.validators;
class Dh {
  constructor(e) {
    this.defaults = e, this.interceptors = {
      request: new r5(),
      response: new r5()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, t) {
    try {
      return await this._request(e, t);
    } catch (i) {
      if (i instanceof Error) {
        let r;
        Error.captureStackTrace ? Error.captureStackTrace(r = {}) : r = new Error();
        const s = r.stack ? r.stack.replace(/^.+\n/, "") : "";
        i.stack ? s && !String(i.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (i.stack += `
` + s) : i.stack = s;
      }
      throw i;
    }
  }
  _request(e, t) {
    typeof e == "string" ? (t = t || {}, t.url = e) : t = e || {}, t = Yd(this.defaults, t);
    const {
      transitional: i,
      paramsSerializer: r,
      headers: s
    } = t;
    i !== void 0 && s1.assertOptions(i, {
      silentJSONParsing: Uu.transitional(Uu.boolean),
      forcedJSONParsing: Uu.transitional(Uu.boolean),
      clarifyTimeoutError: Uu.transitional(Uu.boolean)
    }, !1), r != null && (wt.isFunction(r) ? t.paramsSerializer = {
      serialize: r
    } : s1.assertOptions(r, {
      encode: Uu.function,
      serialize: Uu.function
    }, !0)), t.method = (t.method || this.defaults.method || "get").toLowerCase();
    let c = s && wt.merge(s.common, s[t.method]);
    s && wt.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (N) => {
      delete s[N];
    }), t.headers = Ka.concat(c, s);
    const l = [];
    let m = !0;
    this.interceptors.request.forEach(function(z) {
      typeof z.runWhen == "function" && z.runWhen(t) === !1 || (m = m && z.synchronous, l.unshift(z.fulfilled, z.rejected));
    });
    const y = [];
    this.interceptors.response.forEach(function(z) {
      y.push(z.fulfilled, z.rejected);
    });
    let A, T = 0, I;
    if (!m) {
      const N = [l5.bind(this), void 0];
      for (N.unshift.apply(N, l), N.push.apply(N, y), I = N.length, A = Promise.resolve(t); T < I; )
        A = A.then(N[T++], N[T++]);
      return A;
    }
    I = l.length;
    let L = t;
    for (T = 0; T < I; ) {
      const N = l[T++], z = l[T++];
      try {
        L = N(L);
      } catch (V) {
        z.call(this, V);
        break;
      }
    }
    try {
      A = l5.call(this, L);
    } catch (N) {
      return Promise.reject(N);
    }
    for (T = 0, I = y.length; T < I; )
      A = A.then(y[T++], y[T++]);
    return A;
  }
  getUri(e) {
    e = Yd(this.defaults, e);
    const t = s3(e.baseURL, e.url);
    return e3(t, e.params, e.paramsSerializer);
  }
}
wt.forEach(["delete", "get", "head", "options"], function(e) {
  Dh.prototype[e] = function(t, i) {
    return this.request(Yd(i || {}, {
      method: e,
      url: t,
      data: (i || {}).data
    }));
  };
});
wt.forEach(["post", "put", "patch"], function(e) {
  function t(i) {
    return function(s, c, l) {
      return this.request(Yd(l || {}, {
        method: e,
        headers: i ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: s,
        data: c
      }));
    };
  }
  Dh.prototype[e] = t(), Dh.prototype[e + "Form"] = t(!0);
});
class Bv {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let t;
    this.promise = new Promise(function(s) {
      t = s;
    });
    const i = this;
    this.promise.then((r) => {
      if (!i._listeners)
        return;
      let s = i._listeners.length;
      for (; s-- > 0; )
        i._listeners[s](r);
      i._listeners = null;
    }), this.promise.then = (r) => {
      let s;
      const c = new Promise((l) => {
        i.subscribe(l), s = l;
      }).then(r);
      return c.cancel = function() {
        i.unsubscribe(s);
      }, c;
    }, e(function(s, c, l) {
      i.reason || (i.reason = new Gp(s, c, l), t(i.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const t = this._listeners.indexOf(e);
    t !== -1 && this._listeners.splice(t, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new Bv(function(r) {
        e = r;
      }),
      cancel: e
    };
  }
}
function VH(n) {
  return function(t) {
    return n.apply(null, t);
  };
}
function qH(n) {
  return wt.isObject(n) && n.isAxiosError === !0;
}
const o1 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(o1).forEach((n) => {
  let [e, t] = n;
  o1[t] = e;
});
function l3(n) {
  const e = new Dh(n), t = GT(Dh.prototype.request, e);
  return wt.extend(t, Dh.prototype, e, {
    allOwnKeys: !0
  }), wt.extend(t, e, null, {
    allOwnKeys: !0
  }), t.create = function(r) {
    return l3(Yd(n, r));
  }, t;
}
const qr = l3(jp);
qr.Axios = Dh;
qr.CanceledError = Gp;
qr.CancelToken = Bv;
qr.isCancel = r3;
qr.VERSION = a3;
qr.toFormData = Jm;
qr.AxiosError = ui;
qr.Cancel = qr.CanceledError;
qr.all = function(e) {
  return Promise.all(e);
};
qr.spread = VH;
qr.isAxiosError = qH;
qr.mergeConfig = Yd;
qr.AxiosHeaders = Ka;
qr.formToJSON = (n) => i3(wt.isHTMLForm(n) ? new FormData(n) : n);
qr.getAdapter = o3.getAdapter;
qr.HttpStatusCode = o1;
qr.default = qr;
const HH = "https://tilemaps.icgc.cat/cdn/configs/mapicgc-config.json", WH = 5e3;
class XH {
  static async getConfigICGC() {
    try {
      const e = await qr.get(HH, {
        timeout: WH
      });
      return e.data ? e.data : (console.log("Resposta sense dades:", e), Bh);
    } catch (e) {
      return e.response ? (console.error("Error de resposta:", e.response.data), console.error("Codi d'estat:", e.response.status)) : e.request ? console.error("No s'ha rebut resposta del servidor:", e.request) : console.error("Error:", e.message), Bh;
    }
  }
}
const JH = {
  "fill-opacity": ["interpolate", ["exponential", 0.5], ["zoom"], 13.5, 1, 18, 0.4],
  "fill-outline-color": "rgba(0,0, 0, 0)",
  "fill-color": ["interpolate", ["cubic-bezier", 0.5, 1, 1, 1], ["get", "nivell_2"], 0, "#ffffff", 111, "#ffff00", 112, "#ccff33", 113, "#af5b15", 114, "#808000", 115, "#cdcd00", 116, "#ffffcc", 221, "#33cc33", 222, "#66ff33", 223, "#689018", 224, "#967d5f", 225, "#19e61e", 226, "#b4ff9b", 227, "#aaa500", 228, "#c3c3a0", 229, "#00ff9b", 230, "#ff9632", 231, "#282828", 232, "#79797a", 233, "#f5df78", 234, "#3296ff", 341, "#ff007d", 342, "#ff53cd", 343, "#ffa4e2", 344, "#ffc8e2", 345, "#ffb4b4", 346, "#0f3700", 347, "#730055", 348, "#6200c4", 349, "#4a9595", 350, "#ff00f0", 351, "#adaaca", 352, "#ffe6e6", 353, "#67629a", 354, "#4a466e", 355, "#2f2d46", 461, "#6f6fff", 462, "#0000dc", 463, "#000064", 464, "#185f94", 465, "#12466d", 466, "#000080"]
}, $H = {
  cobertesSol: JH
}, ZH = "lines", Ug = "labels";
let Ah, $f, Sr, gi, oW = class {
  /**
   * Constructor for the Map class.
   * @param {Object} options - Options to initialize the map.
   */
  constructor(e) {
    XH.getConfigICGC().then((t) => {
      Ah = {
        ...t.Styles
      }, Sr = {
        ...t.Layers
      }, $f = {
        ...t.Terrains
      }, gi = {
        ...t.defaultOptions
      }, this.initTheMap(e);
    }).catch((t) => {
      console.info("Configuracio per defecte", t), Ah = {
        ...Bh.Styles
      }, Sr = {
        ...Bh.Layers
      }, $f = {
        ...Bh.Terrains
      }, gi = {
        ...Bh.defaultOptions
      }, this.initTheMap(e);
    });
  }
  initTheMap(e) {
    if (!e)
      e = gi.mapOptions;
    else
      for (const t in gi.mapOptions) {
        let i = [gi.mapOptions.center[0], gi.mapOptions.center[1]];
        gi.mapOptions.center = i, e.hasOwnProperty(t) || (e[t] = gi.mapOptions[t]);
      }
    e.maxPitch = 85, e.maplibreLogo = !1, e.attributionControl = !1, this.map = new hs.Map(e), this.map.options = e, this.map.addControl(new hs.AttributionControl({
      compact: !0
    })), this.map.on("load", async () => {
      const t = this.map.getStyle().name, i = this.map.options.style;
      if (window.document.querySelector(".maplibregl-compact-show")) {
        var r = window.document.querySelector(".maplibregl-compact-show");
        r.classList.remove("maplibregl-compact-show");
      }
      this.map.addControl(new Tq({
        color: i.indexOf("orto") === -1,
        defaultOptions: gi
      }), "bottom-left"), this._dealOrto3dStyle(t);
    });
  }
  /**
   * Add geocoder.
   * @function addGeocoderICGC
   * @param {string} [position='top-right'] - Position to add the control on the map.
   * @returns {Object} - The current position of the search result.
   */
  addGeocoderICGC(e) {
    try {
      e === void 0 && (e = "top-right");
      let t = {
        collapsed: !0,
        marker: !0,
        popup: !0,
        showResultMarkers: !0,
        maplibregl: hs,
        showResultsWhileTyping: !0,
        minLength: 2
      };
      const i = {
        forwardGeocode: async (s) => {
          const c = [];
          try {
            const l = gi.geocoder.peliasUrl1 + encodeURIComponent(s.query) + gi.geocoder.peliasUrl2, y = await (await fetch(l)).json();
            for (const A of y.features) {
              const T = A.geometry.coordinates, I = {
                type: "Feature",
                geometry: {
                  type: "Point",
                  coordinates: T
                },
                place_name: A.properties.etiqueta,
                properties: A.properties,
                text: A.properties.etiqueta,
                place_type: ["place"],
                center: T
              };
              c.push(I);
            }
          } catch (l) {
            console.error(`Failed to forwardGeocode with error: ${l}`);
          }
          return {
            features: c
          };
        }
      };
      this.map.addControl(new xq(i, t), e);
      let r = document.getElementsByClassName("maplibregl-ctrl-geocoder--input");
      r[0].attributes[2].nodeValue = "Cerca...", r[0].addEventListener("input", function(s) {
        s.target.value.length > 3;
      });
    } catch (t) {
      console.error(`Error adding ICGC geocoder: ${t.message}`);
    }
  }
  //geocoder ends
  async loadImage(e) {
    try {
      return this.map.loadImage(e);
    } catch (t) {
      console.error(`Error getting loadImage: ${t.message}`);
    }
  }
  /**
   * Retrieves the available base styles from default options.
   * @function getConfigStyles
   * @returns {Array} - Array containing the names of available base styles.
   */
  getConfigStyles() {
    try {
      let e = [];
      for (const t of Ah)
        e.push(t.name);
      return e;
    } catch (e) {
      console.error(`Error retrieving base styles: ${e.message}`);
    }
  }
  /**
   * Retrieves the available WMS image layers from default options.
   * @function getConfigWMSLayers
   * @returns {Array} - Array containing the keys of available WMS image layers.
   */
  getConfigWMSLayers() {
    try {
      let e = [];
      for (const t in Sr.WMS)
        Sr.WMS.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving WMS layers: ${e.message}`);
    }
  }
  /**
   * Retrieves the available orto image layers from default options.
   * @function getConfigOrtoLayers
   * @returns {Array} - Array containing the keys of available image layers.
   */
  getConfigOrtoLayers() {
    try {
      let e = [];
      for (const t in Sr.Orto)
        Sr.Orto.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving orto image layers: ${e.message}`);
    }
  }
  /**
   * Retrieves the available vector layers from default options.
   * @function getConfigVectorLayers
   * @returns {Array} - Array containing the keys of available vector layers.
   */
  getConfigVectorLayers() {
    try {
      let e = [];
      for (const t in Sr.Vector)
        Sr.Vector.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving vector layers: ${e.message}`);
    }
  }
  /**
   * Retrieves the available vector layers from default options.
   * @function getConfigVectorAdminLayers
   * @returns {Array} - Array containing the keys of available vectorAdmin layers.
   */
  getConfigVectorAdminLayers() {
    try {
      let e = [];
      for (const t in Sr.VectorAdmin)
        Sr.VectorAdmin.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving vectorAdmin layers: ${e.message}`);
    }
  }
  /**
   * Retrieves the available fgb layers from default options.
   * @function getConfigFGBAdminLayers
   * @returns {Array} - Array containing the keys of available fgbadmin layers.
   */
  getConfigFGBAdminLayers() {
    try {
      let e = [];
      for (const t in Sr.FGBAdmin)
        Sr.FGBAdmin.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving FGBAdmin layers: ${e.message}`);
    }
  }
  /**
   * Fetches GeoJSON data from a URL and adds a corresponding layer to the map based on the specified geometry type.
   * @param {string} url - The URL to fetch GeoJSON data from.
   * @param {string} idLayer - The id for the layer.
   * @param {Object} options - Additional options for configuring the layer.
   */
  async fetchData(e, t, i) {
    try {
      (!i || i === void 0) && (i = {
        type: "line",
        layout: {
          visibility: "visible"
        },
        paint: {
          "line-color": "grey",
          "line-width": 2
        },
        layerPosition: "top"
        // select: 'top', 'lines' or 'labels'
      });
      let r = i.layerPosition;
      if (e.includes(".fgb"))
        this.addFGBLayerICGC(e, t, i);
      else {
        const c = await (await fetch(e)).json();
        let l = t, m = this._dealOrderLayer(r), y = c.features[0].geometry.type;
        y.includes("ine") && (i !== void 0 ? this.map.addLayer({
          id: l,
          type: "line",
          source: {
            type: "geojson",
            data: c
          },
          layout: i.layout || {},
          paint: i.paint || {}
        }, m) : this.map.addLayer({
          id: l,
          type: "line",
          source: {
            type: "geojson",
            data: c
          },
          layout: {
            visibility: "visible"
          },
          paint: {
            "line-color": "black",
            "line-width": 2,
            "line-opacity": 1
          }
        }, m)), y.includes("olygon") && (i !== void 0 ? this.map.addLayer({
          id: l,
          type: "fill",
          source: {
            type: "geojson",
            data: c
          },
          layout: i.layout,
          paint: i.paint
        }, m) : this.map.addLayer({
          id: l,
          type: "fill",
          source: {
            type: "geojson",
            data: c
          },
          layout: {
            visibility: "visible"
          },
          paint: {
            "fill-color": "blue",
            "fill-opacity": 0.6
          }
        }, m)), y.includes("oint") && (i !== void 0 ? this.map.addLayer({
          id: l,
          type: "circle",
          source: {
            type: "geojson",
            data: c
          },
          layout: i.layout,
          paint: i.paint
        }, m) : this.map.addLayer({
          id: l,
          type: "circle",
          source: {
            type: "geojson",
            data: c
          },
          layout: {
            visibility: "visible"
          },
          paint: {
            "circle-color": "red",
            "circle-opacity": 0.85
          }
        }, m));
      }
    } catch (r) {
      console.error(`Error fetching data: ${r.message}`);
    }
  }
  /**
   * Fetches GeoJSON data from a URL and adds a corresponding layer to the map based on the specified geometry type and adds to the Menu as a checkbox item.
   * @param {string} url - The URL to fetch GeoJSON data from.
   * @param {string} idLayer - The geometry name (e.g., 'buildings').
   * @param {string} filterField - Import all features as unique or group based on a field ('all', 'field').
   * @param {Object} options - Additional options for configuring the layer.
   */
  async fetchDataAndMenu(e, t, i, r) {
    try {
      let s;
      r !== null ? s = r.layerPosition : s = Ug;
      let c, l = document.getElementById("map");
      if (document.getElementById("menu-group") ? c = document.getElementById("menu-group") : (c = document.createElement("nav"), c.id = "menu-group", c.classList.add = "filter-group", l.appendChild(c)), c !== null) {
        let m = "visible", y = this._dealOrderLayer(s), A;
        if (e.includes(".fgb")) {
          let I = this._getKeyByUrlFGB(e);
          I === null && (I = "userFGB");
          const L = await fetch(e), N = {
            type: "FeatureCollection",
            features: []
          };
          for await (const V of g2(L.body))
            N.features.push(V);
          A = N;
          let z = t;
          if (this.map.addSource(z, {
            type: "geojson",
            data: N
          }), e.includes("text"))
            r !== void 0 ? this.map.addLayer({
              id: t,
              type: "symbol",
              source: z,
              layout: r.layout,
              paint: r.paint
            }, y) : this.map.addLayer({
              id: t,
              type: "symbol",
              source: z,
              layout: {
                "text-letter-spacing": 0.1,
                "text-size": {
                  base: 1.2,
                  stops: [[8, 0], [12, 14], [15, 15]]
                },
                "text-font": ["FiraSans-Regular"],
                "text-field": ["get", "NOM_AC"],
                "text-transform": "none",
                "text-max-width": 25,
                visibility: m,
                "text-justify": "right",
                "text-anchor": "top",
                "text-allow-overlap": !1,
                "symbol-spacing": 2,
                "text-line-height": 1
              },
              paint: {
                "text-halo-blur": 0.5,
                "text-color": "rgba(90, 7, 7, 1)",
                "text-halo-width": 2,
                "text-halo-color": "rgba(255, 255, 255,0.8)"
              }
            }, y);
          else {
            let V = t + "Text";
            this.map.addLayer({
              id: V,
              type: "symbol",
              source: z,
              layout: {
                "text-letter-spacing": 0.1,
                "text-size": {
                  base: 1.2,
                  stops: [[8, 0], [12, 14], [15, 15]]
                },
                "text-font": ["FiraSans-Regular"],
                "text-field": ["get", "NOM_AC"],
                "text-transform": "none",
                "text-max-width": 25,
                visibility: m,
                "text-justify": "right",
                "text-anchor": "top",
                "text-allow-overlap": !1,
                "symbol-spacing": 2,
                "text-line-height": 1
              },
              paint: {
                "text-halo-blur": 0.5,
                "text-color": "rgba(90, 7, 7, 1)",
                "text-halo-width": 2,
                "text-halo-color": "rgba(255, 255, 255,0.8)"
              }
            }, y);
          }
        } else
          A = await (await fetch(e)).json();
        if (i !== "all") {
          const I = document.createElement("div");
          I.id = "titleDivMenu", I.textContent = t, c.appendChild(I);
          const L = document.createElement("div");
          L.id = "titleDivMenuSub", L.textContent = ` ${i}`, c.appendChild(L);
        }
        let T;
        if (r.type ? T = r.type : T = A.features[0].geometry.type, i === "all")
          T.includes("ine") && (r !== void 0 ? this.map.addLayer({
            id: t,
            type: "line",
            source: {
              type: "geojson",
              data: A
            },
            layout: r.layout,
            paint: r.paint
          }, y) : this.map.addLayer({
            id: t,
            type: "line",
            source: {
              type: "geojson",
              data: A
            },
            layout: {
              visibility: "visible"
            },
            paint: {
              "line-color": "black",
              "line-width": 2,
              "line-opacity": 1
            }
          }, y)), T.includes("olygon") && (r !== void 0 ? this.map.addLayer({
            id: t,
            type: "fill",
            source: {
              type: "geojson",
              data: A
            },
            layout: r.layout,
            paint: r.paint
          }, y) : this.map.addLayer({
            id: t,
            type: "fill",
            source: {
              type: "geojson",
              data: A
            },
            layout: {
              visibility: "visible"
            },
            paint: {
              "fill-color": "#0000FF",
              "fill-opacity": 0
            }
          }, y)), T.includes("oint") && (r !== void 0 ? this.map.addLayer({
            id: t,
            type: "circle",
            source: {
              type: "geojson",
              data: A
            },
            layout: r.layout,
            paint: r.paint
          }, y) : this.map.addLayer({
            id: t,
            type: "circle",
            source: {
              type: "geojson",
              data: A
            },
            layout: {
              visibility: "visible"
            },
            paint: {
              "circle-color": "red",
              "circle-opacity": 0.85
            }
          }, y)), T.includes("ymbol") && (r !== void 0 ? this.map.addLayer({
            id: t,
            type: "symbol",
            source: {
              type: "geojson",
              data: A
            },
            layout: r.layout,
            paint: r.paint
          }, y) : this.map.addLayer({
            id: t,
            type: "symbol",
            source: {
              type: "geojson",
              data: A
            },
            layout: {
              visibility: "visible"
            },
            paint: {
              "text-halo-blur": 0.5,
              "text-color": "rgba(90, 7, 7, 1)",
              "text-halo-width": 2,
              "text-halo-color": "rgba(255, 255, 255,0.8)"
            }
          }, y)), this.addMenuItem(t);
        else {
          let I = i;
          const L = {};
          A.features.forEach((N) => {
            const z = N.properties[I], V = z + "-userFieldFilter-" + t;
            z !== null && (L[V] || (T.includes("ine") && (r !== void 0 ? this.map.addLayer({
              id: V,
              type: "line",
              source: {
                type: "geojson",
                data: A
              },
              layout: r.layout,
              paint: r.paint,
              filter: ["==", `${I}`, z]
            }, y) : this.map.addLayer({
              id: V,
              type: "line",
              source: {
                type: "geojson",
                data: A
              },
              layout: {
                visibility: "visible"
              },
              filter: ["==", `${I}`, z],
              paint: {
                "line-color": "black",
                "line-width": 2,
                "line-opacity": 1
              }
            }, y)), T.includes("olygon") && (r !== void 0 ? this.map.addLayer({
              id: V,
              type: "fill",
              source: {
                type: "geojson",
                data: A
              },
              filter: ["==", `${I}`, z],
              layout: r.layout,
              paint: r.paint
            }, y) : this.map.addLayer({
              id: V,
              type: "fill",
              source: {
                type: "geojson",
                data: A
              },
              layout: {
                visibility: "visible"
              },
              filter: ["==", `${I}`, z],
              paint: {
                "fill-color": "blue",
                "fill-opacity": 0.6
              }
            }, y)), T.includes("oint") && (r !== void 0 ? this.map.addLayer({
              id: V,
              type: "circle",
              source: {
                type: "geojson",
                data: A
              },
              filter: ["==", `${I}`, z],
              layout: r.layout,
              paint: r.paint
            }, y) : this.map.addLayer({
              id: V,
              type: "circle",
              source: {
                type: "geojson",
                data: A
              },
              layout: {
                visibility: "visible"
              },
              filter: ["==", `${I}`, z],
              paint: {
                "circle-color": "red",
                "circle-opacity": 0.85
              }
            }, y)), L[V] = !0, this.addMenuItem(V)));
          });
        }
      }
    } catch (s) {
      console.error(`Error fetching data: ${s.message}`);
    }
  }
  /**
   * Adds an event listener to the map.
   * @function on
   * @param {string} type - The type of the event.
   * @param {Function} func - The callback function to be executed when the event occurs.
   */
  on(e, t) {
    setTimeout(() => {
      try {
        return this.map.on(e, t);
      } catch (i) {
        console.error(`Error adding event ON listener: ${i.message}`);
      }
    }, 100);
  }
  /**
   * Sets the style of the map.
   * @function setStyle
   * @param {string} style - Name of the map style.
   * @param {Object} [options] - Options for setting the style.
   */
  setStyle(e, t) {
    try {
      t !== void 0 ? this.map.setStyle(e, t) : this.map.setStyle(e), this.map.on("styledata", () => {
        if (window.document.querySelector(".maplibregl-compact-show")) {
          var i = window.document.querySelector(".maplibregl-compact-show");
          i.classList.remove("maplibregl-compact-show");
        }
        this._dealOrto3dStyle(this.map.getStyle().name);
      });
    } catch (i) {
      console.error(`Error setting style: ${i.message}`);
    }
  }
  /**
   * Adds a control to the map with the specified position.
   * @function addControl
   * @param {Object} control - The control to add.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), this.map.addControl(e, t);
    } catch (i) {
      console.error(`Error adding control: ${i.message}`);
    }
  }
  /**
   * Sets the sky properties of the map.
   * @function setSky
   * @param {Object} options - Options to set the sky properties.
   * @param {string} [options.skyType='gradient'] - Type of sky to set (e.g., 'gradient', 'atmosphere').
   * @param {string} [options.color='lightblue'] - Color of the sky.
   * @param {Number} [options.horizonBlend=0.03] - Blend horizon value.
   * @param {Number} [options.starIntensity=0.5] - Intensity of stars in the sky.
   * @param {Number} [options.sunIntensity=0.1] - Intensity of the sun in the sky.
   * @param {Array<Number>} [options.sunPosition=[0, 0]] - Position of the sun in the sky.
   */
  setSky(e) {
    try {
      e === void 0 && (this.map.options.style.includes("orto") && (e = {
        "sky-color": "#86bbd5",
        "sky-horizon-blend": 0.3,
        "horizon-color": "#ffffff33",
        "horizon-fog-blend": 0.1,
        "fog-ground-blend": 0.75,
        "fog-color": "#c5d6d6"
      }), this.map.options.style.includes("mapa_estandard_general") && (e = {
        "sky-color": "#a5f0f0",
        "sky-horizon-blend": 0.3,
        "horizon-color": "#e1e3e3",
        "horizon-fog-blend": 0.9,
        "fog-ground-blend": 0.85,
        "fog-color": "#c5d6d6"
      }), this.map.options.style.includes("fosc") && (e = {
        "sky-color": "#232423",
        "sky-horizon-blend": 0.3,
        "horizon-color": "#969996",
        "horizon-fog-blend": 0.9,
        "fog-ground-blend": 0.85,
        "fog-color": "#383838"
      })), this.map.setSky(e);
    } catch (t) {
      console.error(`Error setting sky properties: ${t.message}`);
    }
  }
  /**
   * Adds a mouse coordinate control to the map.
   * @function addMouseCoordControl
   * @param {Number} options.width - Width control i.
   * @param {Boolean} options.utm - Boolean to show coordinates in UTM.
   * @param {Boolean} options.lonlat - Boolean to show coordinates in Lon Lat.
   * @param {string} [position='bottom-left'] - Position to add the control on the map.
   */
  addMouseCoordControl(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "bottom-left";
    try {
      this.map.addControl(new Lq(e), t);
    } catch (i) {
      console.error(`Error adding mouse coordinate control: ${i.message}`);
    }
  }
  /**
   * Adds a geolocate control to the map.
   * @function addGeolocateControl
   * @param {Object} options - Options for the geolocate control.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addGeolocateControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), e === void 0 ? this.map.addControl(new hs.GeolocateControl({
        positionOptions: {
          enableHighAccuracy: !0
        },
        trackUserLocation: !0
      }), t) : this.map.addControl(new hs.GeolocateControl(e), t);
    } catch (i) {
      console.error(`Error adding geolocate control: ${i.message}`);
    }
  }
  /**
   * Adds a fullscreen control to the map.
   * @function addFullscreenControl
   * @param {Object} options - Options for the geolocate control.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addFullscreenControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), e === void 0 ? this.map.addControl(new hs.FullscreenControl({
        container: HTMLElement
      }), t) : this.map.addControl(new hs.FullscreenControl(e), t);
    } catch (i) {
      console.error(`Error adding fullscreen control: ${i.message}`);
    }
  }
  /**
   * Adds a layer to the map.
   * @function addLayer
   * @param {Object} layer - Options for the layer to add.
   * @param {string} layerIdOrder - Optional layer Id draw position.
   */
  addLayer(e, t) {
    try {
      this.map.addLayer(e, t);
    } catch (i) {
      console.error(`Error adding layer: ${i.message}`);
    }
  }
  //add maplibre methods
  /**
   * Adds an image to the map.
   * @function addImage
   * @param {string} id - The ID of the image.
   * @param {ImageBitmap | HTMLImageElement | ImageData | StyleImageInterface | object} image - The image object to add.
   * @param {Partial<StyleImageMetadata>} options - Optional metadata for the image.
   * @returns {this}
   */
  addImage(e, t, i) {
    try {
      this.map.addImage(e, t, i);
    } catch (r) {
      console.error(`Error adding image: ${r.message}`);
    }
    return this;
  }
  /**
   * Adds a source to the map.
   * @function addSource
   * @param {string} id - The ID of the source.
   * @param {SourceSpecification} source - The source object to add.
   * @returns {this}
   */
  addSource(e, t) {
    try {
      this.map.addSource(e, t);
    } catch (i) {
      console.error(`Error adding source: ${i.message}`);
    }
    return this;
  }
  /**
   * Adds a sprite to the map.
   * @function addSprite
   * @param {string} id - The ID of the sprite.
   * @param {string} url - The URL to load the sprite from.
   * @param {StyleSetterOptions} options - Options object.
   * @returns {this}
   */
  addSprite(e, t, i) {
    try {
      this.map.addSprite(e, t, i);
    } catch (r) {
      console.error(`Error adding sprite: ${r.message}`);
    }
    return this;
  }
  /**
   * Checks if all tiles in the viewport are loaded.
   * @function areTilesLoaded
   * @returns {boolean}
   */
  areTilesLoaded() {
    return this.map.areTilesLoaded();
  }
  /**
   * Calculates the camera position for given bounds.
   * @function cameraForBounds
   * @param {LngLatBoundsLike} bounds - The geographical bounds to fit.
   * @param {CameraForBoundsOptions} options - Options object.
   * @returns {CenterZoomBearing | undefined}
   */
  cameraForBounds(e, t) {
    return this.map.cameraForBounds(e, t);
  }
  /**
   * Eases the camera to a new position.
   * @function easeTo
   * @param {object} options - Options describing the animation.
   * @param {any} eventData - Additional properties for event objects.
   * @returns {this}
   */
  easeTo(e, t) {
    return this.map.easeTo(e, t), this;
  }
  /**
   * Fits the map to the given geographical bounds.
   * @function fitBounds
   * @param {LngLatBoundsLike} bounds - The geographical bounds to fit.
   * @param {FitBoundsOptions} options - Options object.
   * @param {any} eventData - Additional properties for event objects.
   * @returns {this}
   */
  fitBounds(e, t, i) {
    return this.map.fitBounds(e, t, i), this;
  }
  /**
   * Fits the map to the given screen coordinates.
   * @function fitScreenCoordinates
   * @param {PointLike} p0 - First point on screen, in pixel coordinates.
   * @param {PointLike} p1 - Second point on screen, in pixel coordinates.
   * @param {number} bearing - Desired map bearing at end of animation, in degrees.
   * @param {FitBoundsOptions} options - Options object.
   * @param {any} eventData - Additional properties for event objects.
   * @returns {this}
   */
  fitScreenCoordinates(e, t, i, r, s) {
    return this.map.fitScreenCoordinates(e, t, i, r, s), this;
  }
  /**
   * Flies the camera to a new position.
   * @function flyTo
   * @param {FlyToOptions} options - Options describing the flight.
   * @param {any} eventData - Additional properties for event objects.
   * @returns {this}
   */
  flyTo(e, t) {
    return this.map.flyTo(e, t), this;
  }
  /**
   * Gets the current bearing of the map.
   * @function getBearing
   * @returns {number}
   */
  getBearing() {
    return this.map.getBearing();
  }
  /**
   * Gets the current geographical bounds of the map.
   * @function getBounds
   * @returns {LngLatBounds}
   */
  getBounds() {
    return this.map.getBounds();
  }
  /**
   * Gets the elevation for the point where the camera is looking.
   * @function getCameraTargetElevation
   * @returns {number}
   */
  getCameraTargetElevation() {
    return this.map.getCameraTargetElevation();
  }
  /**
   * Gets the map's <canvas> element.
   * @function getCanvas
   * @returns {HTMLCanvasElement}
   */
  getCanvas() {
    return this.map.getCanvas();
  }
  /**
   * Gets the HTML element containing the map's <canvas> element.
   * @function getCanvasContainer
   * @returns {HTMLElement}
   */
  getCanvasContainer() {
    return this.map.getCanvasContainer();
  }
  /**
   * Returns the map's geographical centerpoint.
   * @function getCenter
   * @returns {LngLat} The map's geographical centerpoint.
   */
  getCenter() {
    return this.map.getCenter();
  }
  /**
   * Returns the map's containing HTML element.
   * @function getContainer
   * @returns {HTMLElement} The map's container.
   */
  getContainer() {
    return this.map.getContainer();
  }
  /**
   * Gets the state of a feature.
   * @function getFeatureState
   * @param {FeatureIdentifier} feature - Feature identifier.
   * @returns {any} The state of the feature.
   */
  getFeatureState(e) {
    return this.map.getFeatureState(e);
  }
  /**
   * Returns the filter applied to the specified style layer.
   * @function getFilter
   * @param {string} layerId - The ID of the style layer.
   * @returns {void | FilterSpecification} The layer's filter.
   */
  getFilter(e) {
    return this.map.getFilter(e);
  }
  /**
   * Returns the value of the style's glyphs URL.
   * @function getGlyphs
   * @returns {string} The glyphs Style's glyphs URL.
   */
  getGlyphs() {
    return this.map.getGlyphs();
  }
  /**
   * Returns an image currently available in the map.
   * @function getImage
   * @param {string} id - The ID of the image.
   * @returns {StyleImage} An image in the map with the specified ID.
   */
  getImage(e) {
    return this.map.getImage(e);
  }
  /**
   * Returns the layer with the specified ID in the map's style.
   * @function getLayer
   * @param {string} id - The ID of the layer to get.
   * @returns {StyleLayer} The layer with the specified ID.
   */
  getLayer(e) {
    return this.map.getLayer(e);
  }
  /**
   * Return the ids of all layers currently in the style, including custom layers, in order.
   * @function getLayersOrder
   * @returns {string[]} Ids of layers, in order.
   */
  getLayersOrder() {
    return this.map.getLayersOrder();
  }
  /**
   * Returns the value of a layout property in the specified style layer.
   * @function getLayoutProperty
   * @param {string} layerId - The ID of the layer.
   * @param {string} name - The name of the layout property.
   * @returns {any} The value of the specified layout property.
   */
  getLayoutProperty(e, t) {
    return this.map.getLayoutProperty(e, t);
  }
  /**
   * Returns the value of the light object.
   * @function getLight
   * @returns {LightSpecification} Light properties of the style.
   */
  getLight() {
    return this.map.getLight();
  }
  /**
   * Returns the maximum geographical bounds the map is constrained to.
   * @function getMaxBounds
   * @returns {LngLatBounds} The map's maximum geographical bounds.
   */
  getMaxBounds() {
    return this.map.getMaxBounds();
  }
  /**
   * Returns the map's maximum allowable pitch.
   * @function getMaxPitch
   * @returns {number} The maxPitch.
   */
  getMaxPitch() {
    return this.map.getMaxPitch();
  }
  /**
   * Returns the map's maximum allowable zoom level.
   * @function getMaxZoom
   * @returns {number} The maxZoom.
   */
  getMaxZoom() {
    return this.map.getMaxZoom();
  }
  /**
   * Returns the map's minimum allowable pitch.
   * @function getMinPitch
   * @returns {number} The minPitch.
   */
  getMinPitch() {
    return this.map.getMinPitch();
  }
  /**
   * Returns the map's minimum allowable zoom level.
   * @function getMinZoom
   * @returns {number} The minZoom.
   */
  getMinZoom() {
    return this.map.getMinZoom();
  }
  /**
   * Returns the current padding applied around the map viewport.
   * @function getPadding
   * @returns {PaddingOptions} The current padding around the map viewport.
   */
  getPadding() {
    return this.map.getPadding();
  }
  /**
   * Returns the value of a paint property in the specified style layer.
   * @function getPaintProperty
   * @param {string} layerId - The ID of the layer.
   * @param {string} name - The name of a paint property.
   * @returns {unknown} The value of the specified paint property.
   */
  getPaintProperty(e, t) {
    return this.map.getPaintProperty(e, t);
  }
  /**
   * Returns the map's current pitch (tilt).
   * @function getPitch
   * @returns {number} The map's current pitch, measured in degrees away from the plane of the screen.
   */
  getPitch() {
    return this.map.getPitch();
  }
  /**
   * Returns the map's pixel ratio.
   * @function getPixelRatio
   * @returns {number} The pixel ratio.
   */
  getPixelRatio() {
    return this.map.getPixelRatio();
  }
  /**
   * Returns the state of renderWorldCopies.
   * @function getRenderWorldCopies
   * @returns {boolean} The renderWorldCopies.
   */
  getRenderWorldCopies() {
    return this.map.getRenderWorldCopies();
  }
  /**
   * Returns the source with the specified ID in the map's style.
   * @function getSource
   * @param {string} id - The ID of the source to get.
   * @returns {Source} The style source with the specified ID.
   */
  getSource(e) {
    return this.map.getSource(e);
  }
  /**
   * Returns the as-is value of the style's sprite.
   * @function getSprite
   * @returns {object[]} Style's sprite list of id-url pairs.
   */
  getSprite() {
    return this.map.getSprite();
  }
  /**
   * Returns the map's MapLibre style object.
   * @function getStyle
   * @returns {StyleSpecification} The map's style JSON object.
   */
  getStyle() {
    return this.map.getStyle();
  }
  /**
   * Get the terrain-options if terrain is loaded.
   * @function getTerrain
   * @returns {TerrainSpecification} The TerrainSpecification passed to setTerrain.
   */
  getTerrain() {
    return this.map.getTerrain();
  }
  //  Function getZoom()
  /**
   * Returns the map's current zoom level.
   * @function getZoom
   * @returns {number} The map's current zoom level.
   */
  getZoom() {
    return this.map.getZoom();
  }
  //  Function hasControl()
  /**
   * Checks if a control exists on the map.
   * @function hasControl
   * @param {IControl} control - The IControl to check.
   * @returns {boolean} true if map contains control.
   */
  hasControl(e) {
    return this.map.hasControl(e);
  }
  //  Function hasImage()
  /**
   * Check whether or not an image with a specific ID exists in the style.
   * @function hasImage
   * @param {string} id - The ID of the image.
   * @returns {boolean} A Boolean indicating whether the image exists.
   */
  hasImage(e) {
    return this.map.hasImage(e);
  }
  //  Function isMoving()
  /**
   * Returns true if the map is panning, zooming, rotating, or pitching due to a camera animation or user gesture.
   * @function isMoving
   * @returns {boolean} true if the map is moving.
   */
  isMoving() {
    return this.map.isMoving();
  }
  //  Function isRotating()
  /**
   * Returns true if the map is rotating due to a camera animation or user gesture.
   * @function isRotating
   * @returns {boolean} true if the map is rotating.
   */
  isRotating() {
    return this.map.isRotating();
  }
  //  Function isSourceLoaded()
  /**
   * Returns a Boolean indicating whether the source is loaded.
   * @function isSourceLoaded
   * @param {string} id - The ID of the source to be checked.
   * @returns {boolean} A Boolean indicating whether the source is loaded.
   */
  isSourceLoaded(e) {
    return this.map.isSourceLoaded(e);
  }
  //  Function isStyleLoaded()
  /**
   * Returns a Boolean indicating whether the map's style is fully loaded.
   * @function isStyleLoaded
   * @returns {boolean | void} A Boolean indicating whether the style is fully loaded.
   */
  isStyleLoaded() {
    return this.map.isStyleLoaded();
  }
  //  Function isZooming()
  /**
   * Returns true if the map is zooming due to a camera animation or user gesture.
   * @function isZooming
   * @returns {boolean} true if the map is zooming.
   */
  isZooming() {
    return this.map.isZooming();
  }
  //  Function jumpTo()
  /**
   * Changes any combination of center, zoom, bearing, and pitch, without an animated transition.
   * @function jumpTo
   * @param {JumpToOptions} options - Options object
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  jumpTo(e, t) {
    return this.map.jumpTo(e, t);
  }
  //  Function listImages()
  /**
   * Returns an Array of strings containing the IDs of all images currently available in the map.
   * @function listImages
   * @returns {string[]} An Array of strings containing the names of all sprites/images currently available in the map.
   */
  listImages() {
    return this.map.listImages();
  }
  //  Function listens()
  /**
   * Returns a true if this instance of Evented or any forwardeed instances of Evented have a listener for the specified type.
   * @function listens
   * @param {string} type - The event type.
   * @returns {boolean} true if there is at least one registered listener for specified event type, false otherwise.
   */
  listens(e) {
    return this.map.listens(e);
  }
  //  Function loadImage()
  /**
   * Load an image from an external URL to be used with Map#addImage.
   * @function loadImage
   * @param {string} url - The URL of the image file. Image file must be in png, webp, or jpg format.
   * @returns {Promise<GetResourceResponse<ImageBitmap | HTMLImageElement>>} A promise that is resolved when the image is loaded.
   */
  loadImage(e) {
    return this.map.loadImage(e);
  }
  //  Function loaded()
  /**
   * Returns a Boolean indicating whether the map is fully loaded.
   * @function loaded
   * @returns {boolean} A Boolean indicating whether the map is fully loaded.
   */
  loaded() {
    return this.map.loaded();
  }
  //  Function new LngLatBounds()
  /**
   * Constructs a new LngLatBounds object representing a geographical bounding box.
   * @class LngLatBounds
   * @constructor
   * @param {LngLatLike} [sw] - The southwest corner of the bounding box. Can be specified as an array of 4 numbers in the order of west, south, east, north, or an array of 2 LngLatLike representing [sw,ne].
   * @param {LngLatLike} [ne] - The northeast corner of the bounding box.
   */
  LngLatBounds(e, t) {
    return new hs.LngLatBounds(e, t);
  }
  //  Function addProtocol()
  /**
   * Adds a custom load resource function that will be called when using a URL that starts with a custom URL schema.
   * @function addProtocol
   * @param {string} customProtocol - The protocol to hook, for example 'custom'.
   * @param {AddProtocolAction} loadFn - The function to use when trying to fetch a resource specified by the customProtocol.
   * @returns {void}
   */
  addProtocol(e, t) {
    return this.map.addProtocol(e, t);
  }
  //  Function moveLayer()
  /**
   * Moves a layer to a different z-position.
   * @function moveLayer
   * @param {string} id - The ID of the layer to move.
   * @param {string} [beforeId] - The ID of an existing layer to insert the new layer before.
   * @returns {this}
   */
  moveLayer(e, t) {
    return this.map.moveLayer(e, t);
  }
  //  Function panBy()
  /**
   * Pans the map by the specified offset.
   * @function panBy
   * @param {PointLike} offset - x and y coordinates by which to pan the map.
   * @param {AnimationOptions} [options] - Options object.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  panBy(e, t, i) {
    return this.map.panBy(e, t, i);
  }
  //  Function panTo()
  /**
   * Pans the map to the specified location with an animated transition.
   * @function panTo
   * @param {LngLatLike} lnglat - The location to pan the map to.
   * @param {AnimationOptions} [options] - Options describing the destination and animation of the transition.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  panTo(e, t, i) {
    return this.map.panTo(e, t, i);
  }
  //  Function project()
  /**
   * Returns a Point representing pixel coordinates, relative to the map's container, that correspond to the specified geographical location.
   * @function project
   * @param {LngLatLike} lnglat - The geographical location to project.
   * @returns {Point} The Point corresponding to lnglat, relative to the map's container.
   */
  project(e) {
    return this.map.project(e);
  }
  //  Function queryRenderedFeatures()
  /**
   * Queries rendered features within a specified geometry or bounding box.
   * @function queryRenderedFeatures
   * @param {GeometryLike | Array | Object} [geometryOrOptions] - The geometry or options for the query.
   * @param {Object} [options] - Options for the query.
   * @returns {Array} An array of GeoJSON Feature objects representing the features that intersect the query geometry.
   */
  queryRenderedFeatures(e, t) {
    return this.map.queryRenderedFeatures(e, t);
  }
  //  Function querySourceFeatures()
  /**
   * Queries source features within a specified source.
   * @function querySourceFeatures
   * @param {string} sourceId - The ID of the source to query.
   * @param {Object} parameters - Parameters for the query.
   * @returns {Array} An array of GeoJSON Feature objects representing the features in the source that satisfy the query parameters.
   */
  querySourceFeatures(e, t) {
    return this.map.querySourceFeatures(e, t);
  }
  //  Function queryTerrainElevation()
  /**
   * Queries the terrain elevation at a specified geographical location.
   * @function queryTerrainElevation
   * @param {LngLatLike} lngLatLike - The geographical location to query.
   * @returns {number} The elevation (in meters) at the specified location.
   */
  queryTerrainElevation(e) {
    return this.map.queryTerrainElevation(e);
  }
  //  Function redraw()
  /**
   * Redraws the map.
   * @function redraw
   * @returns {this}
   */
  redraw() {
    return this.map.redraw();
  }
  //  Function remove()
  /**
   * Removes the map from the DOM.
   * @function remove
   * @returns {this}
   */
  remove() {
    return this.map.remove();
  }
  //  Function removeControl()
  /**
   * Removes a control from the map.
   * @function removeControl
   * @param {Object} control - The control to remove.
   * @returns {this}
   */
  removeControl(e) {
    return this.map.removeControl(e);
  }
  //  Function removeFeatureState()
  /**
   * Removes the state of a feature.
   * @function removeFeatureState
   * @param {Object} target - The target feature.
   * @param {string} [key] - The key of the state to remove.
   * @returns {this}
   */
  removeFeatureState(e, t) {
    return this.map.removeFeatureState(e, t);
  }
  //  Function removeImage()
  /**
   * Removes an image from the style's sprite.
   * @function removeImage
   * @param {string} id - The ID of the image to remove.
   * @returns {this}
   */
  removeImage(e) {
    return this.map.removeImage(e);
  }
  /**
   * Removes a layer from the map.
   * @function removeLayer
   * @param {string} idLayer - Identifier of the layer to remove.
   */
  removeLayer(e) {
    try {
      this.map.removeLayer(e);
    } catch (t) {
      console.error(`Error removing layer: ${t.message}`);
    }
  }
  /**
   * Removes a source from the map.
   * @function removeSource
   * @param {string} idLayer - Identifier of the source to remove.
   */
  removeSource(e) {
    try {
      this.map.removeSource(e);
    } catch (t) {
      console.error(`Error removing source: ${t.message}`);
    }
  }
  //  Function removeSprite()
  /**
   * Removes a sprite from the style.
   * @function removeSprite
   * @param {string} id - The ID of the sprite to remove.
   * @returns {this}
   */
  removeSprite(e) {
    return this.map.removeSprite(e);
  }
  //  Function resetNorth()
  /**
   * Resets the map orientation so that north is up.
   * @function resetNorth
   * @param {Object} [options] - Options for the reset.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  resetNorth(e, t) {
    return this.map.resetNorth(e, t);
  }
  //  Function resetNorthPitch()
  /**
   * Resets the map orientation so that north is up and pitch is set to 0.
   * @function resetNorthPitch
   * @param {Object} [options] - Options for the reset.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  resetNorthPitch(e, t) {
    return this.map.resetNorthPitch(e, t);
  }
  //  Function resize()
  /**
   * Resizes the map to fit its container.
   * @function resize
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  resize(e) {
    return this.map.resize(e);
  }
  //  Function rotateTo()
  /**
   * Rotates the map to the specified bearing with an animated transition.
   * @function rotateTo
   * @param {number} bearing - The desired bearing (in degrees) to rotate the map to.
   * @param {Object} [options] - Options for the rotation.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  rotateTo(e, t, i) {
    return this.map.rotateTo(e, t, i);
  }
  //  Function setBearing()
  /**
   * Sets the map's bearing with an optional animated transition.
   * @function setBearing
   * @param {number} bearing - The desired bearing (in degrees) to set for the map.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setBearing(e, t) {
    return this.map.setBearing(e, t);
  }
  //  Function setCenter()
  /**
   * Sets the map's center coordinates with an optional animated transition.
   * @function setCenter
   * @param {LngLatLike} center - The desired center coordinates to set for the map.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setCenter(e, t) {
    return this.map.setCenter(e, t);
  }
  //  Function setEventedParent()
  /**
   * Sets the parent of the map's event emitter.
   * @function setEventedParent
   * @param {any} [parent] - The parent object to set for the event emitter.
   * @param {any} [data] - Additional data to pass to the parent.
   * @returns {this}
   */
  setEventedParent(e, t) {
    return this.map.setEventedParent(e, t);
  }
  //  Function setFeatureState()
  /**
   * Sets the state of a feature.
   * @function setFeatureState
   * @param {Object} feature - The feature to set the state for.
   * @param {Object} state - The state object to set for the feature.
   * @returns {this}
   */
  setFeatureState(e, t) {
    return this.map.setFeatureState(e, t);
  }
  //  Function setFilter()
  /**
   * Sets the filter for a specified layer.
   * @function setFilter
   * @param {string} layerId - The ID of the layer to set the filter for.
   * @param {Array} [filter] - The filter array to apply to the layer.
   * @param {Object} [options] - Options for the filter.
   * @returns {this}
   */
  setFilter(e, t, i) {
    return this.map.setFilter(e, t, i);
  }
  //  Function setGlyphs()
  /**
   * Sets the glyphs for the map's style.
   * @function setGlyphs
   * @param {string} glyphsUrl - The URL to the glyphs.
   * @param {Object} [options] - Options for setting the glyphs.
   * @returns {this}
   */
  setGlyphs(e, t) {
    return this.map.setGlyphs(e, t);
  }
  //  Function setLayerZoomRange()
  /**
   * Sets the zoom range for a specified layer.
   * @function setLayerZoomRange
   * @param {string} layerId - The ID of the layer to set the zoom range for.
   * @param {number} minzoom - The minimum zoom level for the layer.
   * @param {number} maxzoom - The maximum zoom level for the layer.
   * @returns {this}
   */
  setLayerZoomRange(e, t, i) {
    return this.map.setLayerZoomRange(e, t, i);
  }
  //  Function setLayoutProperty()
  /**
   * Sets a layout property for a specified layer.
   * @function setLayoutProperty
   * @param {string} layerId - The ID of the layer to set the layout property for.
   * @param {string} name - The name of the layout property to set.
   * @param {any} value - The value to set for the layout property.
   * @param {Object} [options] - Options for setting the layout property.
   * @returns {this}
   */
  setLayoutProperty(e, t, i, r) {
    return this.map.setLayoutProperty(e, t, i, r);
  }
  //  Function setLight()
  /**
   * Sets the light for the map's style.
   * @function setLight
   * @param {Object} light - The light object to set for the map.
   * @param {Object} [options] - Options for setting the light.
   * @returns {this}
   */
  setLight(e, t) {
    return this.map.setLight(e, t);
  }
  //  Function setMaxBounds()
  /**
   * Sets the maximum bounds for the map.
   * @function setMaxBounds
   * @param {Array} bounds - The maximum bounds for the map.
   * @returns {this}
   */
  setMaxBounds(e) {
    return this.map.setMaxBounds(e);
  }
  //  Function setMaxPitch()
  /**
   * Sets the maximum pitch for the map.
   * @function setMaxPitch
   * @param {number} maxPitch - The maximum pitch (in degrees) for the map.
   * @returns {this}
   */
  setMaxPitch(e) {
    return this.map.setMaxPitch(e);
  }
  //  Function setMaxZoom()
  /**
   * Sets the maximum zoom level for the map.
   * @function setMaxZoom
   * @param {number} maxZoom - The maximum zoom level for the map.
   * @returns {this}
   */
  setMaxZoom(e) {
    return this.map.setMaxZoom(e);
  }
  //  Function setMinPitch()
  /**
   * Sets the minimum pitch for the map.
   * @function setMinPitch
   * @param {number} minPitch - The minimum pitch (in degrees) for the map.
   * @returns {this}
   */
  setMinPitch(e) {
    return this.map.setMinPitch(e);
  }
  //  Function setMinZoom()
  /**
   * Sets the minimum zoom level for the map.
   * @function setMinZoom
   * @param {number} minZoom - The minimum zoom level for the map.
   * @returns {this}
   */
  setMinZoom(e) {
    return this.map.setMinZoom(e);
  }
  //  Function setPadding()
  /**
   * Sets padding for the map's container.
   * @function setPadding
   * @param {Object} padding - The padding object to set for the map's container.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setPadding(e, t) {
    return this.map.setPadding(e, t);
  }
  //  Function setPaintProperty()
  /**
   * Sets a paint property for a specified layer.
   * @function setPaintProperty
   * @param {string} layerId - The ID of the layer to set the paint property for.
   * @param {string} name - The name of the paint property to set.
   * @param {any} value - The value to set for the paint property.
   * @param {Object} [options] - Options for setting the paint property.
   * @returns {this}
   */
  setPaintProperty(e, t, i, r) {
    return this.map.setPaintProperty(e, t, i, r);
  }
  //  Function setPitch()
  /**
   * Sets the map's pitch angle with an optional animated transition.
   * @function setPitch
   * @param {number} pitch - The desired pitch angle (in degrees) to set for the map.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setPitch(e, t) {
    return this.map.setPitch(e, t);
  }
  //  Function setPixelRatio()
  /**
   * Sets the pixel ratio for the map.
   * @function setPixelRatio
   * @param {number} pixelRatio - The desired pixel ratio for the map.
   * @returns {this}
   */
  setPixelRatio(e) {
    return this.map.setPixelRatio(e);
  }
  //  Function setRenderWorldCopies()
  /**
   * Sets whether the map should render world copies when the center longitude is greater than or less than 180 degrees.
   * @function setRenderWorldCopies
   * @param {boolean} renderWorldCopies - A boolean indicating whether to render world copies.
   * @returns {this}
   */
  setRenderWorldCopies(e) {
    return this.map.setRenderWorldCopies(e);
  }
  //  Function setSprite()
  /**
   * Sets the sprite for the map's style.
   * @function setSprite
   * @param {string} spriteUrl - The URL to the sprite.
   * @param {Object} [options] - Options for setting the sprite.
   * @returns {this}
   */
  setSprite(e, t) {
    return this.map.setSprite(e, t);
  }
  //  Function setTerrain()
  /**
   * Loads a 3D terrain mesh based on a "raster-dem" source.
   * @function setTerrain
   * @param {TerrainSpecification} options - Options object specifying the terrain source.
   * @returns {this}
   */
  setTerrain(e) {
    return this.map.setTerrain(e);
  }
  //  Function setTransformRequest()
  /**
   * Updates the requestManager's transform request with a new function.
   * @function setTransformRequest
   * @param {RequestTransformFunction} transformRequest - The callback function to update the transform request.
   * @returns {this}
   */
  setTransformRequest(e) {
    return this.map.setTransformRequest(e);
  }
  //  Function setZoom()
  /**
   * Sets the map's zoom level.
   * @function setZoom
   * @param {number} zoom - The zoom level to set (0-20).
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setZoom(e, t) {
    return this.map.setZoom(e, t);
  }
  //  Function snapToNorth()
  /**
   * Snaps the map so that north is up (0 bearing), if the current bearing is close enough to it.
   * @function snapToNorth
   * @param {Object} [options] - Options for snapping to north.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  snapToNorth(e, t) {
    return this.map.snapToNorth(e, t);
  }
  //  Function stop()
  /**
   * Stops any animated transition underway.
   * @function stop
   * @returns {this}
   */
  stop() {
    return this.map.stop();
  }
  //  Function triggerRepaint()
  /**
   * Triggers the rendering of a single frame.
   * @function triggerRepaint
   * @returns {void}
   */
  triggerRepaint() {
    return this.map.triggerRepaint();
  }
  //  Function unproject()
  /**
   * Returns geographical coordinates corresponding to the specified pixel coordinates.
   * @function unproject
   * @param {PointLike} point - The pixel coordinates to unproject.
   * @returns {LngLat} The geographical coordinates corresponding to the specified pixel coordinates.
   */
  unproject(e) {
    return this.map.unproject(e);
  }
  //  Function updateImage()
  /**
   * Updates an existing image in the style's sprite.
   * @function updateImage
   * @param {string} id - The ID of the image to update.
   * @param {ImageBitmap | HTMLImageElement | ImageData | StyleImageInterface | object} image - The new image data.
   * @returns {this}
   */
  updateImage(e, t) {
    return this.map.updateImage(e, t);
  }
  //  Function zoomIn()
  /**
   * Increases the map's zoom level by 1.
   * @function zoomIn
   * @param {Object} [options] - Options for zooming in.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  zoomIn(e, t) {
    return this.map.zoomIn(e, t);
  }
  //  Function zoomOut()
  /**
   * Decreases the map's zoom level by 1.
   * @function zoomOut
   * @param {Object} [options] - Options for zooming out.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  zoomOut(e, t) {
    return this.map.zoomOut(e, t);
  }
  //  Function zoomTo()
  /**
   * Zooms the map to the specified zoom level with an animated transition.
   * @function zoomTo
   * @param {number} zoom - The zoom level to transition to.
   * @param {Object} [options] - Options for zooming to.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  zoomTo(e, t, i) {
    return this.map.zoomTo(e, t, i);
  }
  // end maplibre methods
  /**
   * Adds a GeoJSON layer to the map.
   * @function addLayerGeoJSON
   * @param {Object} layer - Options for the GeoJSON layer to add.
   * @param {string} layer.id - Unique identifier for the layer.
   * @param {Object} layer.data - GeoJSON data for the layer.
   * @param {string} layer.type - Map layer type (e.g., 'symbol', 'circle', 'fill').   *
   * @param {Object} layer.layout - Layer layout configuration.
   * @param {Object} layer.paint - Layer paint configuration.
   * @param {string} layerPosition - Position of the layer: 'top', below 'labels' or below 'lines'.
   */
  addLayerGeoJSON(e, t) {
    try {
      let i = this._dealOrderLayer(t);
      this.map.addSource(`${e.id}`, {
        type: "geojson",
        data: e.data
      }), this.map.addLayer({
        id: `${e.id}-layerIcgcMap`,
        type: e.type,
        source: `${e.id}`,
        layout: e.layout,
        paint: e.paint
      }, i);
    } catch (i) {
      console.error(`Error adding GeoJSON layer: ${i.message}`);
    }
  }
  /**
   * Adds a WMS layer to the map.
   * @function addLayerWMS
   
   * @param {string[]} tiles - Tiles for the raster layer.
   * @param {string} idLayer - Unique identifier for the layer.
   * @param {Object} options - Options of the layer: layout, paint and layerPosition.
   */
  addLayerWMS(e, t, i) {
    try {
      let r = this._dealOrderLayer(i.layerPosition);
      i ? (this.map.addSource(`${t}`, {
        type: "raster",
        tiles: [e],
        tileSize: 256
      }, r), this.map.addLayer({
        id: t,
        type: "raster",
        source: t,
        layout: i.layout,
        paint: i.paint
      }, r)) : (this.map.addSource(`${t}`, {
        type: "raster",
        tiles: [e],
        tileSize: 256
      }, r), this.map.addLayer({
        id: t,
        type: "raster",
        source: t,
        paint: {}
      }, r));
    } catch (r) {
      console.error(`Error adding WMS layer: ${r.message}`);
    }
  }
  /**
   * Adds a logo to the map.
   * @function addLogo
   * @param {Object} options - Options for the logo to add.
   * @param {string} options.id - Unique identifier for the logo.
   * @param {string} options.url - URL of the logo image.
   * @param {string} options.href - URL to navigate to when the logo is clicked.
   * @param {string} options.height - Height of the logo.
   */
  addLogo(e) {
    try {
      let t = document.getElementById("map"), i;
      i = document.createElement("div"), i.id = "logos", t.appendChild(i);
      const r = document.createElement("img");
      r.src = e.url, r.style.height = e.height;
      const s = document.getElementById("logos"), c = document.createElement("a");
      c.id = e.id, c.href = e.href, c.target = "_blank", c.style.position = "relative", c.style.bottom = "1px", c.appendChild(r), s.appendChild(c);
    } catch (t) {
      console.error(`Error adding logo: ${t.message}`);
    }
  }
  /**
   * Adds base layers to the map.
   * @function addBasemapsICGC
   * @param {Object[]} basesArray - Array of base layer objects.
   */
  addBasemapsICGC(e) {
    try {
      const t = (c) => {
        this.map.setStyle(c);
      };
      let i = document.getElementById("map"), r;
      r = document.createElement("div"), r.id = "basemap-group", r.classList.add = "filter-group", i.appendChild(r);
      const s = document.getElementById("basemap-group");
      for (const c of e)
        for (const l of Object.keys(gi.baseStyles)) {
          const m = gi.baseStyles[l];
          if (c === m.url) {
            const y = document.createElement("div");
            y.className = "basemap-item", y.title = m.key, y.style.backgroundImage = `url('${m.image}')`, s.appendChild(y), y.addEventListener("click", () => t(m.url));
          }
        }
    } catch (t) {
      console.error(`Error adding basemaps: ${t.message}`);
    }
  }
  /**
   * Adds base layers to the map.
   * @function addBasemaps
   * @param {Object[]} baseLayers - Array of base layer objects.
   * @param {string} baseLayers.label - Label for the base layer.
   * @param {string} baseLayers.image - URL of the image representing the base layer.
   * @param {string} baseLayers.url - URL of the base layer style.
   */
  addBasemaps(e) {
    try {
      const t = (c) => {
        map.setStyle(c.url);
      };
      let i = document.getElementById("map"), r;
      r = document.createElement("div"), r.id = "basemap-group", r.classList.add = "basemap-group", i.appendChild(r);
      const s = document.getElementById("basemap-group");
      e.forEach((c) => {
        const l = document.createElement("div");
        l.className = "basemap-item", l.title = c.label, l.style.backgroundImage = `url('${c.image}')`, s.appendChild(l), l.addEventListener("click", () => t(c));
      });
    } catch (t) {
      console.error(`Error adding basemaps: ${t.message}`);
    }
  }
  /**
   * Adds feature query function to a layer.
   * @function addFeatureQuery
   * @param {string} idLayer - name of the layer
   * @param {objetc} queryFields - optional indications for the popup
   * @param {objetc} popupStyle - optional indications for the popup style
   */
  addFeatureQuery(e, t, i) {
    try {
      let r;
      this.map.on("mouseenter", e, () => {
        this.map.getCanvas().style.cursor = "pointer";
      }), this.map.on("mouseleave", e, () => {
        this.map.getCanvas().style.cursor = "";
      }), this.map.on("click", (s) => {
        let c = this.map.queryRenderedFeatures(s.point);
        if (c && c[0].source.includes(e)) {
          let l = [s.lngLat.lng, s.lngLat.lat];
          if (t !== void 0 && t.length > 0 && t !== "all") {
            if (t !== null) {
              let m = "";
              t.forEach((y) => {
                let A = c[0].properties[y];
                m = m + `<h4>${A}</h4>`;
              }), r = m, this.addPopup(l, r, i);
            }
          } else {
            let m = "";
            for (const y in c[0].properties)
              m += "<b>" + y + "</b>:" + c[0].properties[y] + "<br>";
            r = m, this.addPopup(l, r, i);
          }
        }
      });
    } catch (r) {
      console.error(`Error adding feature query: ${r.message}`);
    }
  }
  /**
   * Adds a scale control to the map.
   *  * @function addScaleControl
   * @param {Object} options - Options for configuring the scale control.
   * @param {string} position - The position on the map to place the scale control (e.g., 'top-left', 'bottom-right').
   */
  addScaleControl(e, t) {
    try {
      var i = new hs.ScaleControl(e);
      this.map.addControl(i, t);
    } catch (r) {
      console.error(`Error adding scale: ${r.message}`);
    }
  }
  /**
   * Adds an export control to the map with the provided options and position.
   * @function addExportControl
   * @param {Object|string} options - Options for the export control or position if provided as a string.
   * @param {string} [position] - Position to place the export control (e.g., 'top-right').
   */
  addExportControl(e, t) {
    try {
      typeof e == "string" && (t = e, e = void 0), e === void 0 && (e = {
        PageSize: Mh.A4,
        PageOrientation: Qf.Landscape,
        Format: Wc.PNG,
        DPI: jy[300],
        Crosshair: !0,
        PrintableArea: !0,
        Local: "ca"
      }, t = "top-right"), this.map.addControl(new MV(e), t);
    } catch (i) {
      console.error(`Error adding export control: ${i.message}`);
    }
  }
  /**
   * Adds a marker to the map.
   * @function addMarker
   * @param {Object} options - Options for the marker to add.
   * @param {string} options.text - Text content for the marker popup.
   * @param {Object} options.options - Marker options.
   * @param {LngLatLike} options.coord - Coordinates for placing the marker.
   * @param {Object} options.textOffset - Text offset for the marker popup.
   * @returns {Object} - Instance of the added marker.
   */
  addMarker(e) {
    try {
      let t, i;
      return e.text === void 0 ? t = new hs.Marker(e.options).setLngLat(e.coord).addTo(this.map) : (i = new hs.Popup({
        offset: e.textOffset
      }).setHTML(e.text), t = new hs.Marker(e.options).setLngLat(e.coord).setPopup(i).addTo(this.map)), t;
    } catch (t) {
      return console.error(`Error adding marker: ${t.message}`), null;
    }
  }
  /**
   * Adds a popup to the map.
   * @function addPopup
   * @param {Object} options - Options for the popup to add.
   * @param {LngLatLike} coord - Coordinates for placing the popup.
   * @param {string} text - HTML content for the popup.
   * @param {string} popupStyle - css content for the popup style.
   * @returns {Object} - Instance of the added popup.
   */
  addPopup(e, t, i) {
    try {
      return i.image === void 0 ? new hs.Popup().setLngLat(e).setHTML(`
        <div class="popupBody">
          <div class="popupTop">
          ${i.title}
          </div>
          <div class="popupBottom">
          <div class="popupBottomUp">
 ${t}
          </div>
          <div class="popupBottomDown">
          </div>
          </div>
        </div>
      `).addTo(this.map) : new hs.Popup().setLngLat(e).setHTML(`
        <div class="popupBody">
          <div class="popupTop">
          ${i.title}
          </div>
          <div class="popupBottom">
          <div class="popupBottomUp">
          ${t}
          </div>
          <div class="popupBottomDown">
             <img style="  padding: 8px;  width: 50%;" src=${i.image} />
          </div>
          </div>
        </div>
      `).addTo(this.map);
    } catch (r) {
      return console.error(`Error adding popup: ${r.message}`), null;
    }
  }
  /**
   * Adds a fullscreen control to the map.
   * @function addFullScreen
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addFullScreen(e) {
    try {
      e === void 0 && (e = "top-right"), this.map.addControl(new hs.FullscreenControl(), e);
    } catch (t) {
      console.error(`Error adding fullscreen control: ${t.message}`);
    }
  }
  /**
   * Adds a menu item with a checkbox for controlling the visibility of a layer on the map.
   * @function addMenuItem
   * @param {string} name - The name of the layer corresponding to the menu item.
   */
  addMenuItem(e) {
    try {
      let t;
      if (e.includes("-userFieldFilter-") ? t = e.split("-userFieldFilter-")[0] : t = e, e.length > 0) {
        const i = document.getElementById("menu-group"), r = document.createElement("input");
        r.type = "checkbox", r.id = e, r.checked = !0, i.appendChild(r);
        const s = document.createElement("label");
        s.setAttribute("for", e), s.textContent = t, i.appendChild(s), r.addEventListener("change", (c) => {
          this.map.setLayoutProperty(e, "visibility", c.target.checked ? "visible" : "none");
        });
      }
    } catch (t) {
      console.error(`Error adding menu item: ${t.message}`);
    }
  }
  /**
   * Adds a layer tree to the map.
   * @function addLayerTree
   * @param {Object} options - Options for the layer tree to add.
   * @param {Object} options.features - Features for the layer tree.
   * @param {string} options.id - Unique identifier for the layer tree.
   * @param {string} options.type - Type of layer tree ('geojson', 'raster', etc.).
   */
  addLayerTree(e) {
    try {
      let t = e.features, i = document.getElementById("map"), r = document.createElement("nav");
      r.id = "filter-group", i.appendChild(r);
      const s = document.getElementById("filter-group");
      this.map.addSource(`${e.id}`, {
        type: e.type,
        data: t
      }), t.features.forEach((c) => {
        const l = c.properties.icon, m = `poi-${l}`;
        if (!this.map.getLayer(m)) {
          this.map.addLayer({
            id: m,
            type: "circle",
            source: `${e.id}`,
            paint: {
              "circle-radius": 6,
              "circle-color": "#B42222"
            },
            filter: ["==", "icon", l]
          }, this._firstSymbolLayer());
          const y = document.createElement("input");
          y.type = "checkbox", y.id = m, y.checked = !0, s.appendChild(y);
          const A = document.createElement("label");
          A.setAttribute("for", m), A.textContent = l, s.appendChild(A), y.addEventListener("change", (T) => {
            this.map.setLayoutProperty(m, "visibility", T.target.checked ? "visible" : "none");
          });
        }
      });
    } catch (t) {
      console.error(`Error adding layer tree: ${t.message}`);
    }
  }
  /**
   * Creates a navigation control with the provided options.
   * @function createNavigationControl
   * @param {Object} options - Options for the navigation control.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   * @returns {Object} - Instance of the created navigation control.
   */
  createNavigationControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), this.map.addControl(new hs.NavigationControl(e), t);
    } catch (i) {
      return console.error(`Error creating navigation control: ${i.message}`), null;
    }
  }
  /**
   * Adds a navigation control to the map with the provided options.
   * @function addNavigationControl
   * @param {Object} options - Options for the navigation control.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addNavigationControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), this.map.addControl(new hs.NavigationControl(e), t);
    } catch (i) {
      console.error(`Error adding navigation control: ${i.message}`);
    }
  }
  /**
   * Adds an attribution control to the map with the provided options.
   * @function addAttributionControl
   * @param {Object} options - Options for the attribution control.
   * @param {string} [position='bottom-right'] - Position to add the control on the map.
   */
  addAttributionControl(e, t) {
    try {
      this.map.addControl(new hs.AttributionControl(e), t);
    } catch (i) {
      console.error(`Error adding attribution control: ${i.message}`);
    }
  }
  /**
   * Adds an ICGC image layer to the map based on the specified name and year.
   * @function addImageLayerICGC
   * @param {string} url - The url of the  layer.
   * @param {string} idLayer - The user id for the  layer.
   * @param {object} options - Type, position,layout and paint options for the layer
   */
  addImageLayerICGC(e, t, i) {
    try {
      let r = null, s, c;
      i ? (c = i, s = i.layerPosition) : c = {
        type: "raster",
        layout: {
          visibility: "visible"
        },
        paint: {
          "raster-opacity": 1
        },
        layerPosition: Ug
      }, r = this._findImageType(e, Sr.Orto, Sr.VectorAdmin, Sr.WMS, Sr.Vector), r || console.log(" %c The layer: %c%s%c does not exist in the ICGC DB. Consult the documentation.", "font-weight: bold; font-style: italic;", "font-weight: normal; font-style: normal; color: red;", e, "font-weight: bold; font-style: italic;");
      let l = {
        id: t,
        tiles: e
      };
      this.addLayerWMS(e, t, c);
    } catch (r) {
      console.error(`Error adding ICGC image layer: ${r.message}`);
    }
  }
  /**
   * Adds an ICGC vector layer to the map based on the specified name and year.
   * @function addVectorLayerICGC
   * @param {string} url - The url of the vector layer.
   * @param {string} idLayer - The user id for the vector layer.
   * @param {object} options - Type, position,layout and paint options for the layer
   *
   */
  async addVectorLayerICGC(e, t, i) {
    try {
      let {
        type: r = "line",
        layerPosition: s = Ug,
        layoutOptions: c = {
          visibility: "visible"
        },
        paintOption: l
      } = i || {}, m = this._dealOrderLayer(s);
      if (!e) {
        console.log(" %c The layer: %c%s%c does not exist in the ICGC DB. Consult the documentation.", "font-weight: bold; font-style: italic;", "font-weight: normal; font-style: normal; color: red;", e, "font-weight: bold; font-style: italic;");
        return;
      }
      if (e.includes("https")) {
        let y = this._getKeyByUrlVector(e);
        this.map.addSource(y, {
          type: "vector",
          url: e
        });
        let A = {
          id: y,
          type: "fill",
          source: y,
          "source-layer": "cobertes",
          maxzoom: 18,
          layout: i.layout,
          paint: $H.cobertesSol
        };
        if (y === "cobertes2018" && this.map.addLayer(A, m), c.visibility === "visible") {
          let T = this._getLegendByName(y);
          console.info("legendUrl", T), console.info("sourceName", y), this.addLegend(T, y);
        }
      } else {
        let y = t;
        this.map.addSource(y, {
          type: "vector",
          url: gi.limitsUrl
        });
        let A = {
          id: t,
          type: r,
          source: y,
          "source-layer": e,
          layout: i.layout,
          paint: i.paint || {}
        };
        r === "fill" || r === "polygon" ? A.paint = l || {
          "fill-color": "#0000FF",
          "fill-opacity": 0
        } : r === "line" && (A.paint = l || {
          "line-color": "#4832a8",
          "line-opacity": 1,
          "line-width": 1
        }), this.map.addLayer(A, m);
      }
    } catch (r) {
      console.error(`Error adding ICGC vector layer: ${r.message}`);
    }
  }
  /**
   * Adds an ICGC FGB layer to the map based on the specified name and year.
   * @function addFGBLayerICGC
   * @param {string} url - The url of the FGB layer.
   * @param {string} idLayer - Id for the layer.
   * @param {object} options - Paint option for the layer
   *
   */
  async addFGBLayerICGC(e, t, i) {
    try {
      i || (i.layout = {
        visibility: !0
      }, i.paint = {
        "line-color": "#4832a8",
        "line-opacity": 1,
        "line-width": 1
      }, i.type = "lines", i.layerPosition = "labels");
      let r = this._dealOrderLayer(i.layerPosition);
      const s = await fetch(e), c = {
        type: "FeatureCollection",
        features: []
      };
      for await (const m of g2(s.body))
        c.features.push(m);
      let l = t;
      this.map.addSource(l, {
        type: "geojson",
        data: c
      }), e.includes("text") ? this.map.addLayer({
        id: t,
        type: "symbol",
        source: l,
        layout: {
          "text-letter-spacing": 0.1,
          "text-size": {
            base: 1.2,
            stops: [[8, 0], [12, 14], [15, 15]]
          },
          "text-font": ["FiraSans-Regular"],
          "text-field": ["get", "NOM_AC"],
          "text-transform": "none",
          "text-max-width": 25,
          visibility: i.layout.visibility,
          "text-justify": "right",
          "text-anchor": "top",
          "text-allow-overlap": !1,
          "symbol-spacing": 2,
          "text-line-height": 1
        },
        paint: {
          "text-halo-blur": 0.5,
          "text-color": "rgba(90, 7, 7, 1)",
          "text-halo-width": 2,
          "text-halo-color": "rgba(255, 255, 255,0.8)"
        }
      }, r) : this.map.addLayer({
        id: t,
        type: i.type,
        source: l,
        layout: i.layout,
        paint: i.paint
      }, r);
    } catch (r) {
      console.error(`Error adding ICGC FGB layer: ${r.message}`);
    }
  }
  /**
   * Adds 3D terrain to the map using hillshade.
   * @function addTerrainICGC
   * @param {string} url - dataset url of the terrain
   * @param {string} controlPosition - Position to add the control on the map.
   */
  addTerrainICGC(e, t) {
    try {
      let i;
      for (const s in $f)
        if ($f.hasOwnProperty(s)) {
          const c = $f[s];
          c === e && (i = c);
        }
      let r = i;
      this.getSource("terrainICGC") !== void 0 && (this.getStyle().layers.forEach((c) => {
        c.source === "terrainICGC" && this.removeLayer(c.id);
      }), this.removeSource("terrainICGC")), this.getSource("terrainICGC") === void 0 && (e.includes("terrarium") ? this.map.addSource("terrainICGC", {
        type: "raster-dem",
        tiles: [r],
        tileSize: 512,
        encoding: "terrarium",
        maxzoom: 16
      }) : this.map.addSource("terrainICGC", {
        type: "raster-dem",
        tiles: [r],
        tileSize: 512,
        maxzoom: 16
      })), this.map.setTerrain({
        source: "terrainICGC",
        exaggeration: 1.5
      }), t == null || this.map.addControl(new SI({
        pitch: 90,
        bearing: null,
        minpitchzoom: null
      }), t);
    } catch (i) {
      console.error(`Error adding 3D terrain: ${i.message}`);
    }
  }
  /**
   * Add image legend.
   * @function addLegend
   * @param {string} url - image legend url.
   * @param {string} idLayer - layer's name.
   */
  addLegend(e, t) {
    try {
      this.map.addControl(new Cq({
        url: e,
        idLayer: t
      }));
    } catch (i) {
      console.error(`Error adding legend: ${i.message}`);
    }
  }
  //Internal methods
  /**
   * Finds the type of image based on the provided URL and specified vectors.
   * @function _findImageType
   * @param {string} url - The URL of the image to find the type for.
   * @param {Object} var1 - The first vector object containing key-value pairs.
   * @param {Object} var2 - The second vector object containing key-value pairs.
   * @param {Object} var3 - The third vector object containing key-value pairs.
   * @param {Object} var4 - The fourth vector object containing key-value pairs.
   * @returns {string|null} - The type of image if found, otherwise null.
   */
  _findImageType(e, t, i, r, s) {
    const c = [t, i, r, s];
    for (const l of c)
      for (const [m, y] of Object.entries(l))
        if (y === e)
          return m;
    return null;
  }
  /**
   * Gets the key by URL from the FGBAdmin layers.
   * @function _getKeyByUrlFGB
   * @param {string} url - The URL to find the key for in the FGBAdmin layers.
   * @returns {string|null} - The key if found, otherwise null.
   */
  _getKeyByUrlFGB(e) {
    for (const t in Sr.FGBAdmin)
      if (Sr.FGBAdmin.hasOwnProperty(t) && Sr.FGBAdmin[t] === e)
        return t;
    return null;
  }
  /**
   * Gets the legend by name from the default vector layers.
   * @function _getLegendByName
   * @param {string} name - The name of the vector layer to get the legend for.
   * @returns {string|null} - The legend if found, otherwise null.
   */
  _getLegendByName(e) {
    for (const t in gi.vectorLayers) {
      const i = gi.vectorLayers[t];
      if (i.key === e)
        return i.legend;
    }
    return null;
  }
  /**
   * Gets the key by URL from the Vector layers.
   * @function _getKeyByUrlVector
   * @param {string} url - The URL to find the key for in the Vector layers.
   * @returns {string|null} - The key if found, otherwise null.
   */
  _getKeyByUrlVector(e) {
    for (const t in Sr.Vector)
      if (Sr.Vector.hasOwnProperty(t) && Sr.Vector[t] === e)
        return t;
    return null;
  }
  /**
   * Raises text 3D style on the map.
   * @function _raiseText3DStyle
   * @async
   * @returns {Promise<void>} - A promise that resolves after updating the text 3D style on the map.
   */
  async _raiseText3DStyle() {
    try {
      const e = await this.map.loadImage(gi.map3dOptions.imageIcon);
      this.map.addImage("stick", e.data), this.map.getStyle().layers.forEach((t) => {
        if (t["source-layer"] === gi.map3dOptions.sourceLayerFilterId && t.minzoom >= gi.map3dOptions.minZoomFilter && e) {
          const i = t.id;
          this.map.setLayoutProperty(i, "icon-image", "stick"), this.map.setLayoutProperty(i, "text-offset", [0, -9]), this.map.setLayoutProperty(i, "symbol-placement", "point"), this.map.setLayoutProperty(i, "symbol-avoid-edges", !1), this.map.setLayoutProperty(i, "text-allow-overlap", !0), this.map.setLayoutProperty(i, "text-ignore-placement", !1), this.map.setLayoutProperty(i, "text-pitch-alignment", "auto"), this.map.setLayoutProperty(i, "text-rotation-alignment", "auto"), this.map.setLayoutProperty(i, "text-justify", "center"), this.map.setLayoutProperty(i, "text-anchor", "bottom"), this.map.setLayoutProperty(i, "icon-anchor", "bottom"), this.map.setPaintProperty(i, "text-color", "#ffffff"), this.map.setPaintProperty(i, "text-halo-color", "#000000"), this.map.setPaintProperty(i, "text-halo-width", 2);
        }
      });
    } catch (e) {
      return console.error(`Error dealing orto 3D: ${e.message}`), null;
    }
  }
  /**
   * Deals with map styles based on the name.
   * @function _dealStyleMaps
   * @param {string} name - The name of the map style.
   * @returns {Object|string|null} - The map style object if found, or the input name if not found, or null if an error occurs.
   */
  _dealStyleMaps(e) {
    try {
      if (e && e.indexOf("icgc.cat") != -1) {
        for (const t in Ah)
          if (Ah.hasOwnProperty(t)) {
            const i = Ah[t];
            if (t === e)
              return i;
          }
        return Ah[0];
      } else
        return e;
    } catch (t) {
      return console.error(`Error dealing with map styles: ${t.message}`), null;
    }
  }
  /**
   * Deals with the 3D ortho style based on the name.
   * @function _dealOrto3dStyle
   * @param {string} name - The name of the orto3D style.
   * @returns {void|null} - Returns null if an error occurs.
   */
  _dealOrto3dStyle(e) {
    try {
      if (e == "orto3d") {
        this.map.setMaxZoom(18.8), this.map.easeTo({
          pitch: 45
        });
        const t = new OE({
          intensity: 4
        }), i = new X1({
          ambientLight: t
        });
        this.map.setTerrain({
          source: gi.map3dOptions.terrainSource,
          exaggeration: gi.map3dOptions.exaggeration
        });
        const r = this._createCitiesMapboxLayer();
        this.map.getLayer(gi.map3dOptions.layerId3d) || (this.map.addLayer(r, gi.map3dOptions.layerIdOrder), this.map.setLayerZoomRange(gi.map3dOptions.layerId3d, gi.map3dOptions.minZoomRange, gi.map3dOptions.maxZoomRange), r.deck.setProps({
          effects: [i]
        }), this._raiseText3DStyle()), this.map.setSky({
          "sky-color": "#86bbd5",
          "sky-horizon-blend": 0.3,
          "horizon-color": "#ffffff33",
          "horizon-fog-blend": 0.1,
          "fog-ground-blend": 0.75,
          "fog-color": "#c5d6d6"
        });
      } else
        this.map.getLayer(gi.map3dOptions.layerId3d) && (this.map.removeLayer(gi.map3dOptions.layerId3d), this.map.setTerrain(null));
    } catch (t) {
      return console.error(`Error dealing orto 3D: ${t.message}`), null;
    }
  }
  /**
   * Deals with the order of the layer.
   * @function _dealOrderLayer
   * @param {string} order - The order of the layer.
   * @returns {string} - The id of the first symbol layer if the order is 'symbol', the id of the first line layer if the order is 'line', otherwise an empty string.
   */
  _dealOrderLayer(e) {
    return e === Ug ? this._firstSymbolLayer() : e === ZH ? this._firstLineLayer() : "";
  }
  /**
   * Retrieves the id of the first symbol layer.
   * @function _firstSymbolLayer
   * @returns {string|undefined} - The id of the first symbol layer if found, otherwise undefined.
   */
  _firstSymbolLayer() {
    try {
      const e = this.map.getStyle().layers;
      let t;
      for (let i = 0; i < e.length; i++)
        if (e[i].type === "symbol" && e[i].id.indexOf("contour") === -1 && e[i].id.indexOf("water") === -1) {
          console.info(e[i].id), t = e[i].id;
          break;
        }
      return t;
    } catch (e) {
      console.error(`Error getting first symbol layer: ${e.message}`);
    }
  }
  /**
   * Retrieves the id of the first line layer.
   * @function _firstLineLayer
   * @returns {string|undefined} - The id of the first line layer if found, otherwise undefined.
   */
  _firstLineLayer() {
    try {
      const e = this.map.getStyle().layers;
      let t;
      for (let i = 0; i < e.length; i++)
        if (e[i].type === "line") {
          t = e[i].id;
          break;
        }
      return t;
    } catch (e) {
      console.error(`Error getting first symbol layer: ${e.message}`);
    }
  }
  /**
   * Creates a Mapbox layer for displaying cities in 3D.
   * @function _createCitiesMapboxLayer
   * @returns {MapboxLayer|null} - The Mapbox layer for displaying cities in 3D if created successfully, otherwise null.
   */
  _createCitiesMapboxLayer() {
    try {
      return new i8({
        id: gi.map3dOptions.layerId3d,
        type: Av,
        data: gi.map3dOptions.urlTilesetCities,
        loader: wv,
        loadOptions: {
          tileset: {
            viewDistanceScale: 1,
            updateTransforms: !0,
            maximumScreenSpaceError: gi.map3dOptions.spaceErrorFactor
          }
        },
        onTilesetLoad: (t) => {
          t.options.maximumScreenSpaceError = gi.map3dOptions.spaceErrorFactor;
        },
        onTileLoad: (t) => {
          t.content.cartographicOrigin.z -= gi.map3dOptions.zfactor;
        },
        operation: "terrain+draw"
      });
    } catch (e) {
      return console.error(`Error adding MapboxLayer: ${e.message}`), null;
    }
  }
};
var c3 = { exports: {} };
function YH(n, e) {
  var t = n.getCenter(), i = n.getZoom(), r = n.getBearing(), s = n.getPitch();
  e.forEach(function(c) {
    c.jumpTo({
      center: t,
      zoom: i,
      bearing: r,
      pitch: s
    });
  });
}
function KH() {
  var n, e = arguments.length;
  if (e === 1)
    n = arguments[0];
  else {
    n = [];
    for (var t = 0; t < e; t++)
      n.push(arguments[t]);
  }
  var i = [];
  n.forEach(function(l, m) {
    i[m] = c.bind(null, l, n.filter(function(y, A) {
      return A !== m;
    }));
  });
  function r() {
    n.forEach(function(l, m) {
      l.on("move", i[m]);
    });
  }
  function s() {
    n.forEach(function(l, m) {
      l.off("move", i[m]);
    });
  }
  function c(l, m) {
    s(), YH(l, m), r();
  }
  return r(), function() {
    s(), i = [], n = [];
  };
}
var QH = KH;
(function(n) {
  var e = QH, t = NT.EventEmitter;
  function i(r, s, c, l) {
    if (this.options = l || {}, this._mapA = r, this._mapB = s, this._horizontal = this.options.orientation === "horizontal", this._onDown = this._onDown.bind(this), this._onMove = this._onMove.bind(this), this._onMouseUp = this._onMouseUp.bind(this), this._onTouchEnd = this._onTouchEnd.bind(this), this._ev = new t(), this._swiper = document.createElement("div"), this._swiper.className = this._horizontal ? "compare-swiper-horizontal" : "compare-swiper-vertical", this._controlContainer = document.createElement("div"), this._controlContainer.className = this._horizontal ? "maplibregl-compare maplibregl-compare-horizontal" : "maplibregl-compare", this._controlContainer.className = this._controlContainer.className, this._controlContainer.appendChild(this._swiper), typeof c == "string" && document.body.querySelectorAll) {
      var m = document.body.querySelectorAll(c)[0];
      if (!m)
        throw new Error("Cannot find element with specified container selector.");
      m.appendChild(this._controlContainer);
    } else if (c instanceof Element && c.appendChild)
      c.appendChild(this._controlContainer);
    else
      throw new Error("Invalid container specified. Must be CSS selector or HTML element.");
    this._bounds = s.getContainer().getBoundingClientRect();
    var y = (this._horizontal ? this._bounds.height : this._bounds.width) / 2;
    this._setPosition(y), this._clearSync = e(r, s), this._onResize = (function() {
      this._bounds = s.getContainer().getBoundingClientRect(), this.currentPosition && this._setPosition(this.currentPosition);
    }).bind(this), s.on("resize", this._onResize), this.options && this.options.mousemove && (r.getContainer().addEventListener("mousemove", this._onMove), s.getContainer().addEventListener("mousemove", this._onMove)), this._swiper.addEventListener("mousedown", this._onDown), this._swiper.addEventListener("touchstart", this._onDown);
  }
  i.prototype = {
    _setPointerEvents: function(r) {
      this._controlContainer.style.pointerEvents = r, this._swiper.style.pointerEvents = r;
    },
    _onDown: function(r) {
      r.touches ? (document.addEventListener("touchmove", this._onMove), document.addEventListener("touchend", this._onTouchEnd)) : (document.addEventListener("mousemove", this._onMove), document.addEventListener("mouseup", this._onMouseUp));
    },
    _setPosition: function(r) {
      r = Math.min(r, this._horizontal ? this._bounds.height : this._bounds.width);
      var s = this._horizontal ? "translate(0, " + r + "px)" : "translate(" + r + "px, 0)";
      this._controlContainer.style.transform = s, this._controlContainer.style.WebkitTransform = s;
      var c = this._horizontal ? "rect(0, 999em, " + r + "px, 0)" : "rect(0, " + r + "px, " + this._bounds.height + "px, 0)", l = this._horizontal ? "rect(" + r + "px, 999em, " + this._bounds.height + "px,0)" : "rect(0, 999em, " + this._bounds.height + "px," + r + "px)";
      this._mapA.getContainer().style.clip = c, this._mapB.getContainer().style.clip = l, this.currentPosition = r;
    },
    _onMove: function(r) {
      this.options && this.options.mousemove && this._setPointerEvents(r.touches ? "auto" : "none"), this._horizontal ? this._setPosition(this._getY(r)) : this._setPosition(this._getX(r));
    },
    _onMouseUp: function() {
      document.removeEventListener("mousemove", this._onMove), document.removeEventListener("mouseup", this._onMouseUp), this.fire("slideend", {
        currentPosition: this.currentPosition
      });
    },
    _onTouchEnd: function() {
      document.removeEventListener("touchmove", this._onMove), document.removeEventListener("touchend", this._onTouchEnd), this.fire("slideend", {
        currentPosition: this.currentPosition
      });
    },
    _getX: function(r) {
      r = r.touches ? r.touches[0] : r;
      var s = r.clientX - this._bounds.left;
      return s < 0 && (s = 0), s > this._bounds.width && (s = this._bounds.width), s;
    },
    _getY: function(r) {
      r = r.touches ? r.touches[0] : r;
      var s = r.clientY - this._bounds.top;
      return s < 0 && (s = 0), s > this._bounds.height && (s = this._bounds.height), s;
    },
    /**
     * Set the position of the slider.
     *
     * @param {number} x Slider position in pixels from left/top.
     */
    setSlider: function(r) {
      this._setPosition(r);
    },
    /**
     * Adds a listener for events of a specified type.
     *
     * @param {string} type The event type to listen for; one of `slideend`.
     * @param {Function} listener The function to be called when the event is fired.
     * @returns {Compare} `this`
     */
    on: function(r, s) {
      return this._ev.on(r, s), this;
    },
    /**
     * Fire an event of a specified type.
     *
     * @param {string} type The event type to fire; one of `slideend`.
     * @param {Object} data Data passed to the event listener.
     * @returns {Compare} `this`
     */
    fire: function(r, s) {
      return this._ev.emit(r, s), this;
    },
    /**
     * Removes an event listener previously added with `Compare#on`.
     *
     * @param {string} type The event type previously used to install the listener.
     * @param {Function} listener The function previously installed as a listener.
     * @returns {Compare} `this`
     */
    off: function(r, s) {
      return this._ev.removeListener(r, s), this;
    },
    remove: function() {
      this._clearSync(), this._mapB.off("resize", this._onResize);
      var r = this._mapA.getContainer();
      r && (r.style.clip = null, r.removeEventListener("mousemove", this._onMove));
      var s = this._mapB.getContainer();
      s && (s.style.clip = null, s.removeEventListener("mousemove", this._onMove)), this._swiper.removeEventListener("mousedown", this._onDown), this._swiper.removeEventListener("touchstart", this._onDown), this._controlContainer.remove();
    }
  }, window.maplibregl ? maplibregl.Compare = i : n.exports = i;
})(c3);
var eW = c3.exports;
const tW = /* @__PURE__ */ Ap(eW);
class lW {
  /**
   * Constructor for the map comparison class.
   * @class MapComparison
   * @param {Object} map1 - The first map object to compare.
   * @param {Object} map2 - The second map object to compare.
   * @param {string} container - The HTML container element ID for displaying the comparison.
   * @param {Object} options - Additional options for map comparison (if needed).
   */
  constructor(e, t, i, r) {
    const s = this;
    setTimeout(function() {
      s.mapCompare = new tW(e.map, t.map, i, {});
    }, 1e3);
  }
}
export {
  lW as C,
  oW as M,
  XH as a,
  zi as p
};
